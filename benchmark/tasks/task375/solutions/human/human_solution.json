[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define DEC(i, k) for (int i = (k); i >= 0; --i)\n#define FORIT(i, c) for (__tyoeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n#define ALL(c) (c).begin(), (c).end()\n\nint m, n;\ndouble probability[20][20];\ndouble memo[18][1 << 16];\n\ninline int bsf(int x) {\n    __asm__(\"bsf %1, %0;\" :\"=r\"(x) :\"r\"(x));\n    return x;\n}\n\ndouble calc(int room, int rest) {\n    if (!isnan(memo[room][rest])) { return memo[room][rest]; }\n    if (room == n) { return 1.0; }\n    if (rest == 0) { return 0.0; }\n    double ret = 0.0;\n    int cand = rest;\n    while (cand != 0) {\n        int cat = bsf(cand);\n        cand -= cand & -cand;\n        if (!((1 << cat) & rest)) { continue; }\n        int nrest = rest ^ (1 << cat);\n        double win = 0.0;\n        double p = 1.0;\n        FOREQ(i, room, n) {\n            win += p * (1.0 - probability[cat][i]) * calc(i, nrest);\n            p *= probability[cat][i];\n        }\n        ret = max(ret, win);\n    }\n    return memo[room][rest] = ret;\n}\n\nint main() {\n    scanf(\"%d %d\", &m, &n);\n    MEMSET(probability, 0);\n    REP(cat, m) {\n        REP(room, n) {\n            scanf(\"%lf\", &probability[cat][room]);\n        }\n    }\n    MEMSET(memo, -1);\n    printf(\"%.9lf\\n\", calc(0, (1 << m) - 1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int m,n;\n    cin >> m >> n;\n    vector<vector<double>> win(m,vector<double>(n));\n    rep(i,0,m) rep(j,0,n) cin >> win[i][j];\n\n    vector<vector<double>> memo(1<<m,vector<double>(n+1));\n    vector<vector<bool>> done(1<<m,vector<bool>(n+1));\n    function<double(int,int)> rec=[&](int s,int k){\n        if(done[s][k]) return memo[s][k];\n        done[s][k]=true;\n\n        if(k==n) return memo[s][k]=1;\n\n        double res=0;\n        bitset<16> bs(s);\n        rep(i,0,m){\n            if(bs[i]) continue;\n            bs[i].flip();\n            double p=1,tmp=0;\n            rep(j,k,n){\n                tmp+=rec(bs.to_ulong(),j)*p*(1-win[i][j]);\n                p*=win[i][j];\n            }\n            tmp+=rec(bs.to_ulong(),n)*p;\n            res=max(res,tmp);\n            bs[i].flip();\n        }\n        return memo[s][k]=res;\n    };\n\n    cout << rec(0,0) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nfloat p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][15];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ndouble dp[20][1<<16];\ndouble c[20][20];\nint m,n;\ndouble solve(int a,int b){\n\tif(dp[a][b]>-0.5)return dp[a][b];\n\tif(a==n)return 1;\n\tif(b==0)return 0;\n\tdouble ret=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(b&(1<<i)){\n\t\t\tdouble val=0;\n\t\t\tdouble ks=1;\n\t\t\tfor(int j=a;j<n;j++){\n\t\t\t\tval+=ks*(1.0-c[i][j])*solve(j,b-(1<<i));\n\t\t\t\tks*=c[i][j];\n\t\t\t}\n\t\t\tval+=ks;\n\t\t\tret=max(ret,val);\n\t\t//\tret=max(ret,c[i][a]*solve(a+1,b)+(1.0-c[i][a])*solve(a,b-(1<<i)));\n\t\t}\n\t}\n\treturn dp[a][b]=ret;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tm=a;n=b;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%lf\",&c[i][j]);\n\tfor(int i=0;i<=b;i++)for(int j=0;j<(1<<a);j++)dp[i][j]=-1;\n\tprintf(\"%.12f\\n\",solve(0,(1<<a)-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\n\nint n,m;\ndouble cat[N][M];\ndouble memo[M][T][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\ndouble solve(){\n\treturn 1.0;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\ndouble dp[17][17][1 << 16];\nint n, m;\ndouble p[17][17];\ndouble solve(int stage, int now, int cats){\n\tdouble &res = dp[stage][now][cats];\n\tif(res != -1)return res;\n\tres = 0;\n\tif((1<<now) & cats)return res;\n\tif(stage == n)return res = 1;\n\t\n\tif(now == 16){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tres = max(res, solve(stage, i, cats));\n\t\t}\n\t}\n\telse{\n\t\tres = solve(stage+1, now, cats) * p[now][stage]\n\t\t\t+ solve(stage, 16, cats | (1<<now)) * (1 - p[now][stage]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < 17;i++)\n\t\tfor(int j = 0;j < 17;j++)\n\t\t\tfor(int k = 0;k < (1<<m);k++)\n\t\t\t\tdp[i][j][k] = -1;\n\n\tprintf(\"%.10lf\\n\", solve(0, 16, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m;\ndouble dp[1<<16][17][17];\ndouble dp2[1<<16][17];\ndouble data[17][17];\n\ndouble memo(int bit,int v,int c){\n\tif(v==n)return 1.0;\n\tif(bit==0)return 0.0;\n\tif(dp[bit][v][c]>=0.0)return dp[bit][v][c];\n\tdouble lost=0.0;\n\tint lbit=bit-(1<<c);\n\tif(dp2[lbit][v]>=0.0)lost=dp2[lbit][v];\n\telse{\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(lbit>>i & 1){\n\t\t\t\tlost=max(lost,memo(lbit,v,i));\n\t\t\t}\n\t\t}\n\t\tdp2[lbit][v]=lost;\n\t}\n\tdouble res=memo(bit,v+1,c)*data[c][v]+lost*(1.0-data[c][v]);\n\treturn dp[bit][v][c]=res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%lf\",&data[i][j]);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tdouble res=0.0;\n\tfor(int i=0;i<m;i++){\n\t\tres=max(res,memo((1<<m)-1,0,i));\n\t}\n\tprintf(\"%.10f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int MAX_M = 16;\nconst double EPS = 1e-10;\n\ndouble dp[1<<MAX_M][MAX_N];\n\ndouble prob[MAX_M][MAX_N];\nint M, N;\n\ndouble dfs(int b, int x){\n  if(x == N) return 1.0;\n  if(b == (1<<M)-1){\n    return 0.0;\n  }\n  if(dp[b][x] - -1 > EPS) return dp[b][x];\n  //cout << b << \" \" << x << \" \" << M << \" \" << N << endl;  \n  double ret = 0; \n  for(int i=0;i<M;i++){\n    if(b&(1<<i)) continue;\n    double p = 0.0;\n    double tmpp = 1.0;\n    for(int j=x;j<N;j++){\n      p += tmpp * (1 - prob[i][j]) * dfs(b | (1<<i), j);\n      //cout << p << endl;\n      //cout << \"tmpp: \" << tmpp << \" prob[i][j]: \" << prob[i][j] << endl;      \n      tmpp *= prob[i][j];\n    }\n    p += tmpp * dfs(b | (1<<i), N);\n    ret = max(ret, p);\n  }\n  dp[b][x] = ret;\n  return ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &M, &N);\n  memset(dp, -1, sizeof(dp));\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++){\n      scanf(\"%lf\", &prob[i][j]);\n    }\n  }\n\n  printf(\"%0.30lf\\n\", dfs(0, 0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N (17) \nusing namespace std;\nint m,n;\ndouble neko[N][N];\n\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static int used[N][1<<N]={};\n  static double mem[N][1<<N];\n  if(used[pos][bit]++) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\ndouble mem[N][N][1<<N];\nint used[N][N][1<<N];\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(used[pos][k][bit]++) return mem[pos][k][bit];\n  double p = neko[k][pos];\n  return mem[pos][k][bit]= p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n    neko[i][n] = 0;\n  }\n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n,m;\n  cin >> m >> n;\n  vector<vector<LD>> p(m,vector<LD>(n));\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++) cin >> p[i][j];\n  }\n  vector<vector<LD>> dp(n,vector<LD>(1<<m,0));\n  LD tmp,pp;\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<(1<<m);j++){\n      dp[i][j]=0;\n      for(int k=0;k<m;k++){\n        if(j&(1<<k)){\n          tmp=0,pp=1;\n          for(int l=i;l<n;l++){\n            tmp+=pp*(1-p[k][l])*dp[l][j-(1<<k)];\n            pp*=p[k][l];\n          }\n          tmp+=pp;\n          dp[i][j]=max(dp[i][j],tmp);\n        }\n      }\n    }\n  }\n  cout << fixed << setprecision(12) << dp[0][(1<<m)-1] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef float double;\n\nreal dp[17][17][1 << 16];\nint n, m;\nreal p[17][17];\nreal solve(int stage, int now, int cats){\n\treal &res = dp[stage][now][cats];\n\tif(res != -1)return res;\n\tres = 0;\n\tif((1<<now) & cats)return res;\n\tif(stage == n)return res = 1;\n\t\n\tif(now == 16){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tres = max(res, solve(stage, i, cats));\n\t\t}\n\t}\n\telse{\n\t\tres = solve(stage+1, now, cats) * p[now][stage]\n\t\t\t+ solve(stage, 16, cats | (1<<now)) * (1 - p[now][stage]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < 17;i++)\n\t\tfor(int j = 0;j < 17;j++)\n\t\t\tfor(int k = 0;k < (1<<17);k++)\n\t\t\t\tdp[i][j][k] = -1;\n\n\tprintf(\"%.10lf\\n\", solve(0, 16, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n;\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) % 2 == 1)continue;\n\t\tlong double w1 = solve(pos + 1, ret)*x[i][pos];\n\t\tlong double w2 = solve(pos, ret + (1 << i))*(1.0l - x[i][pos]);\n\t\tmaxn = max(maxn, w1 + w2);\n\t}\n\treturn maxn;\n}\nint main() {\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  double dp[1<<n][m], prob[n][m];\n  for(int i = 0; i < (1<<n); ++i){\n    fill(dp[i],dp[i]+m,0);\n  }\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  \n  for(int bit = 0; bit < (1<<n); ++bit){\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(bit>>j & 1){\n\t  double t = 0, p = 1.0;\n\t  for(int k = i; k < m; ++k){\n\t    t += p*(1.0 - prob[j][k])*dp[bit-(1<<j)][k];\n\t    p *= prob[j][k];\n\t  }\n\t  t += p;\n\t  dp[bit][i] = max(dp[bit][i],t);\n\t}\n      }\n    }\n  }\n\n  double ans = dp[(1<<n)-1][0];\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m;\ndouble dp[(1<<17)][17][17];\nbool past[(1<<17)][17][17];\ndouble a[20][20];\n\ndouble memo(int state,int now,int enemy){\n\tif(past[state][now][enemy])return dp[state][now][enemy];\n\tdouble res=0;\n\tres+=memo(state,now,enemy+1)*a[now][enemy];\n\tdouble nowmax=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(state&(1<<i))continue;\n\t\tif(i==now)continue;\n\t\tnowmax=max(nowmax,memo(state|(1<<now),i,enemy));\n\t}\n\tres+=nowmax*(1-a[now][enemy]);\n\tdp[state][now][enemy]=res;\n\tpast[state][now][enemy]=1;\n\treturn dp[state][now][enemy];\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\tcout<<fixed;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++)for(int j=0;j<n;j++){\n\t\tdp[i][j][m]=1;\n\t\tpast[i][j][m]=1;\n\t}\n\tdouble ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tans=max(ans,memo(0,i,0));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    double P[M][N];//???,???\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++) cin>>P[i][j];\n    }\n    double DP[1<<M][N];//[S][n]:=S??????????????£????????????n??????????????????????±??????????????????????????????????????????¶???????¢????\n    fill(DP[0],DP[1<<M],0);\n    for(int m=0;m<M;m++){\n        double p=1;\n        for(int n=N-1;n>=0;n--){\n            p*=P[m][n];\n            DP[1<<m][n]=p;\n        }\n    }\n    for(int s=0;s<(1<<M);s++){\n        for(int n=0;n<N;n++){\n            for(int m=0;m<M;m++){\n                if((s&(1<<m))==0) continue;\n                double sum=0,p=1;\n                for(int nn=n;nn<N;nn++){\n                    sum+=p*(1-P[m][nn])*DP[s^(1<<m)][nn];\n                    p*=P[m][nn];\n                }\n                sum+=p;\n                DP[s][n]=max(DP[s][n],sum);\n            }\n        }\n    }\n    cout.precision(10);\n    cout<<fixed;\n    cout<<DP[(1<<M)-1][0]<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\nlong double data[16][1<<16];\nlong double input[16][16];\n \nlong double func(int d, int s){\n  if(data[d][s] != -1) return data[d][s];\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    long double np = 1.0;\n    long double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  data[d][s] = res;\n  return res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\nstruct data{\n  double x[16];\n  bool operator<(const data&r)const{\n    for(int i=0;i<n-1;i++)\n      if(x[i]!=r.x[i])return x[i]>r.x[i];\n    return x[n-1]>r.x[n-1];\n  };\n};\n\nvector<data> v;\ndouble ans[17];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    data d;\n    for(int j=0;j<n;j++)\n      cin>>d.x[j];\n    v.push_back(d);\n  }\n  sort(v.begin(),v.end());\n  ans[0]=1;\n  for(int i=0;i<v.size();i++){\n    for(int j=0;j<n;j++){\n      ans[j+1]+=ans[j]*v[i].x[j];\n      ans[j]=ans[j]*(1.0-v[i].x[j]);\n    }\n  }\n  printf(\"%.10f\\n\",ans[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin >> m >> n;\n    vector<vector<double> > win(m, vector<double>(n));\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            cin >> win[i][j];\n        }\n    }\n\n    vector<vector<double> > dp(1<<m, vector<double>(m+1, 1.0));\n    for(int a=n-1; a>=0; --a){ // ツ攻ツ猟ェツつキツづゥツ敵\n        vector<vector<double> > next(1<<m, vector<double>(m+1, 0.0));\n        for(int b=1; b<(1<<m); ++b){ // ツ残ツづィツづ個猫\n            for(int c=0; c<=m; ++c){ // ツ選ツ妥ーツつオツつスツ猫(c==mツづ按づァツづ篠、ツづ慊つセツ選ツ妥ーツつオツづつ「ツづ按つ「)\n                double ret = 0.0;\n                for(int i=0; i<m; ++i){\n                    bitset<16> bs(b);\n                    if(!bs[i])\n                        continue;\n                    if(c != m && c != i)\n                        continue;\n\n                    double p = win[i][a] * dp[b][i];\n                    bs[i] = false;\n                    p += (1.0 - win[i][a]) * next[bs.to_ulong()][m];\n\n                    ret = max(ret, p);\n                }\n                next[b][c] = ret;\n            }\n        }\n        dp.swap(next);\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<m)-1][m]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint m,n;\ndouble p[16][16];\n\ndouble dp[1<<16][16];\ndouble dfs(int S,int pos){\n\tif(pos==n) return 1;\n\tif( S ==0) return 0;\n\n\tif(dp[S][pos]!=-1) return dp[S][pos];\n\n\tdouble res=0;\n\trep(i,m) if(S&1<<i) { // 猫 i を派遣する\n\t\tdouble tmp=0,q=1;\n\t\tfor(int j=pos;j<n;j++){ // j 番目の敵にやられた\n\t\t\ttmp+=q*(1-p[i][j])*dfs(S&~(1<<i),j);\n\t\t\tq*=p[i][j];\n\t\t}\n\t\ttmp+=q*dfs(S&~(1<<i),n); // ゴール\n\t\tres=max(res,tmp);\n\t}\n\treturn dp[S][pos]=res;\n}\n\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\trep(i,m) rep(j,n) scanf(\"%lf\",p[i]+j);\n\n\trep(S,1<<m) rep(j,n) dp[S][j]=-1;\n\tprintf(\"%.15f\\n\",dfs((1<<m)-1,0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nfloat dp[8][16][1<<16];\nfloat prob[16][16];\n\nfloat dfs(int n, int m, int bitmap){\n\n  if(n >= N) return 1;\n  float &ret = dp[n][m][bitmap];\n  if(ret != INF) return ret;\n\n  ret = 0;\n  for(int i=0;i<M;i++){\n    if(bitmap & 1<<i) continue;\n    ret = max(ret, dfs(n, i, bitmap|(1<<i)) * (1 - prob[m][n]));\n  }\n  ret += dfs(n+1, m, bitmap) * prob[m][n]; \n  /*\n  for(int i=0;i<16;i++) for(int j=0;j<1<<16;j++) dp[N][i][j] = 1;\n  for(int i=N-1;i>=0;i--){\n    //    for(int k=(1<<M)-1;k>=0;k--) for(int j=M-1;j>=0;j--) dp[i&1][j][k] = 0;\n      for(int k=(1<<M);k>=0;k--){          \n    for(int j=M-1;j>=0;j--){\n\tfor(int l=M-1;l>=0;l--){\t        \n\t  if((k & (1<<l))){\n\t    dp[i][j][k] = max(dp[i][j][k], dp[i][l][k&-(1<<l)] * (1 - prob[j][i]));;\n\t  }\n\t}\n\tdp[i][j][k] += dp[(i+1)][j][k] * prob[j][i]; \n\t  //\t  cout << dp[i][j][k] << endl;\n\t  //\tcout << dp[i+1][j][k] << \" \" << prob[i][j] << endl;\n      }\n    }\n  }\n  */\n    return ret;\n}\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    rep(j, N) cin >> prob[i][j];\n  }\n  for(int i=0;i<8;i++) for(int j=0;j<16;j++) for(int k=0;k<1<<16;k++) dp[i][j][k] = INF;\n  dfs(0, 0, 0);\n  float res = 0;\n  for(int i=0;i<M;i++){\n    //    for(int j=0;j<1<<M;j++){\n                res = max(res, dfs(0, i, 1<<i));\n\t\t//      res = max(res, dp[0][i][j]);\n\t\t//    }\n  }\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      for(int k=0;k<1<<M;k++){\n\tcout << dp[i][j][k] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n  */\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nconst int MAX = 16;\n\nint n, m;\ndouble win[MAX][MAX];\ndouble memo[MAX][1 << MAX];\n\ndouble rec(int p, int mask){\n  if (p == n){\n    return 1.0;\n  }\n  \n  if (mask == 0){\n    return 0.0;\n  }\n  \n  if (memo[p][mask] > -0.5){\n    return memo[p][mask];\n  }\n  \n  double &res = memo[p][mask] = 0;\n  \n  REP(i, m) if (mask & (1 << i)){\n    int nmask = mask  ^ (1 << i);\n    double expected = 0;\n    double alive    = 1;\n    \n    REP2(j, p, n){\n      expected += alive * (1 - win[i][j]) * rec(j, nmask);\n      alive *= win[i][j];\n    }\n    expected += alive * rec(n, nmask);\n    res = max(res, expected);\n  }\n  \n  // cout << p << \" \" << mask << \" \" << res << endl;\n  return res;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  while (cin >> m >> n && n + m){\n    REP(i, m) REP(j, n) cin >> win[i][j];\n    fill(&memo[0][0], &memo[0][0] + MAX * (1 << MAX), -1);\n    cout << fixed << setprecision(20) << rec(0, (1 << m) - 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <bitset>\n#include <cstring>\nusing namespace std;\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } else return false; }\n\nint n, stage;\nvector<vector<double> > p;\n\ndouble dp[(1<<16)+10][20]; // remained member, #. of remained stages\ndouble rec(int bit, int rem) {\n    if (dp[bit][rem] >= -1e-10) return dp[bit][rem];\n    if (rem == 0) return 1.0;\n    \n    double res = 0.0;\n    int start = stage - rem;\n    for (int i = 0; i < n; ++i) {\n        if (!(bit & (1<<i))) continue;\n        int nbit = bit & ~(1<<i);\n        double tmp = 0.0;\n        double prob = 1.0;\n        for (int lose = start; lose < stage; ++lose) {\n            double loseprob = prob * (1.0 - p[i][lose]);\n            tmp += loseprob * rec(nbit, stage - lose);\n            prob *= p[i][lose];\n        }\n        tmp += prob * rec(nbit, 0);\n        chmax(res, tmp);\n    }\n    return dp[bit][rem] = res;\n}\n\nint main() {\n    while (cin >> n >> stage) {\n        p.assign(n, vector<double>(stage, 0.0));\n        for (int i = 0; i < n; ++i) for (int j = 0; j < stage; ++j) cin >> p[i][j];\n\n        memset(dp, -1, sizeof(dp));\n        cout << fixed << setprecision(10) << rec((1<<n)-1, stage) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 4;\nconst int M = 16;\nconst int T = (1<<N);\nconst double INF = (1<<30);\n\nint n,m;\ndouble cat[N][M];\ndouble memo[2][T][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring bitstr(int state){\n\tstring ret = \"\";\n\trep(i,n) ret += has(state,i) ? \"1\" : \"0\";\n\treturn ret;\n}\n\nvoid setEdge(int state, int e[N], int* esum){\n\t(*esum)=0;\n\trep(i,n){\n\t\tif(has(state,i)){\n\t\t\te[(*esum)]=i;\n\t\t\t(*esum)++;\n\t\t}\n\t}\n}\n\ndouble solve_dp(){\n\trep(i,2)rep(j,T)rep(k,N)memo[i][j][k]=0;\n\t\n\tint t = (1<<n);\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,T)rep(k,N)memo[i%2][j][k]=0;\n\t\trep(j,t){\n\t\t\tint edge[N];\n\t\t\tint esum = 0;\n\t\t\tsetEdge(j, edge, &esum);\n\t\t\t\n\t\t\trep(k,n){\n\t\t\t\tif(!has(j,k))continue;\n\t\t\t\tdouble maxi = 0;\n\t\t\t\tdouble val1=0;\n\t\t\t\tdouble winrate = cat[k][i];\n\t\t\t\t\n\t\t\t\tif(i!=m-1)val1 = winrate * memo[(i+1)%2][j][k];\n\t\t\t\telse val1 = winrate;\n\t\t\t\t\n\t\t\t\tmaxi = max(maxi, val1);\n\t\t\t\t\n\t\t\t\tint dstate = j^(1<<k);\n\t\t\t\trep(p,esum){\n\t\t\t\t\tint e = edge[p];\n\t\t\t\t\tif(!has(dstate,e))continue;\n\t\t\t\t\tmaxi = max(maxi, val1 + (1-winrate)*memo[i%2][dstate][e]);\n\t\t\t\t}\n\t\t\t\tmemo[i%2][j][k] = maxi;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 0;\n\trep(i,n) ans = max(ans, memo[0][t-1][i]);\n\t\n\treturn ans;\n}\ndouble solve(){\n\t\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%.12f\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N (17) \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble mem[N][1<<N];\nint used[N][1<<N];\n\ndouble dfs(int pos,int bit){\n  if(pos==n) return 1;\n  if(used[pos][bit]++) return mem[pos][bit];\n\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(bit&(1<<i))continue;\n    double r=0,t=1;\n    for(int j=pos;j<=n;j++){\n      r+=t*(1-neko[i][j])*dfs(j,bit|(1<<i));\n      t*=neko[i][j];\n    }\n    res = max(res,r);\n  }\n  return mem[pos][bit] = res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n    neko[i][n] = 0;\n  }\n\n  printf(\"%.10f\\n\",dfs(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define double long double\n\nint n, m;\ndouble prob[20][20];\ndouble dp[20][1 << 20];\n\ndouble f(int opp, int rem) {\n\tif(dp[opp][rem] != -1) {\n\t\treturn dp[opp][rem];\n\t}\n\tif(opp == n) return 1.0;\n\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif((rem >> i) & 1) {\n\t\t\tdouble res = f(opp + 1, rem) * prob[i][opp] + f(opp, rem ^ (1 << i)) * (1.0 - prob[i][opp]);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\n\treturn dp[opp][rem] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcin >> prob[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n + 1; i++) {\n\t\tfor(int j = 0; j < 1 << m; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << f(0, (1 << m) - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\n//double dp[1 << 16][17];\n\ndouble dfs(int nekos, int room, double q){\n\t//if(dp[nekos][room] != -1) return dp[nekos][room];\n\n\tdouble res = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\n\t\tdouble sum = 0;\n\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t}\n\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t//cout << bitset<2>(nekos) << ' '<<room << ' ' << sum << endl;\n\t\tres = max(res,sum);\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\treturn res;\n\t//return dp[nekos][room] = res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//rep(i,1 << 16) rep(j,17) dp[i][j] = -1;\n\tcout << fixed << setprecision(10) << dfs(0, 0, 1) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[17][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l <= n + 1; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout << fixed<<setprecision(100) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndouble dp[2][1 << 16][16];\ndouble memo[1 << 16];\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<vector<double>> p(m, vector<double>(n));\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j < n; ++j) {\n            cin >> p[i][j];\n        }\n    }\n    for(int S = 1; S < (1 << m); ++S) {\n        for(int i = 0; i < m; ++i) {\n            dp[n & 1][S][i] = 1;\n        }\n    }\n    for(int i = n - 1; i >= 0; --i) {\n        for(int S = 0; S < (1 << m); ++S) {\n            for(int j = 0; j < m; ++j) {\n                dp[i & 1][S][j] = 0;\n            }\n            for(int j = 0; j < m; ++j) {\n                if(!((S >> j) & 1)) {\n                    continue;\n                }\n                dp[i & 1][S][j] = dp[(i + 1) & 1][S][j] * p[j][i] + memo[S & ~(1 << j)] * (1 - p[j][i]);\n            }\n            double ma = 0;\n            for(int j = 0; j < m; ++j) {\n                if((S >> j) & 1) {\n                    ma = max(ma, dp[i & 1][S][j]);\n                }\n            }\n            memo[S] = ma;\n        }\n    }\n    double res = *max_element(begin(dp[0][(1 << m) - 1]), end(dp[0][(1 << m) - 1]));\n    cout << fixed << setprecision(10) << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint n,m;\ndouble v[22][22];\ndouble dp[1<<16][22];\n\ndouble dfs(int state,int num){\n\t\n\tif(dp[state][num] != -1)return dp[state][num];\n\tdouble ret = 0;\n\t\n\tREP(i,n){\n\t\tif(!(state & (1<<i))){\n\t\t\tdouble tmp = 0;\n\t\t\tdouble p = 1;\n\t\t\tfor(int k = num;k < m;k++){\n\t\t\t\ttmp += p * (1 - v[i][k]) * dfs(state|(1<<i),k);\n\t\t\t\tp *= v[i][k];\n\t\t\t}\n\t\t\tret = max(ret,tmp+p);\n\t\t}\n\t}\n\t\t\t\n\treturn dp[state][num] = ret;\n}\n\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tREP(i,1<<16)REP(j,22)dp[i][j] = -1;\n\t\t\n\tREP(i,n){\n\t\tREP(j,m){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t\n\tcout << Decimal << dfs(0,0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l < n; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tt += dp[n][j&~(1 << k)] * pass;\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout <<setprecision(100) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\n\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static vector<vector<double> > mem(n,vector<double>(1<<m,-1));\n  if(mem[pos][bit]>=0) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\ndouble mem[N][N][1<<N];\nint used[N][N][1<<N];\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(used[pos][k][bit]++) return mem[pos][k][bit];\n  double p = neko[k][pos];\n  return mem[pos][k][bit]= p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,N;\nvvd in,dp;\ndouble dfs(int a,int b){\n\tif(dp[a][b]+1)return dp[a][b];\n\tdouble out=0;\n\trep(i,n)if((a&1<<i)==0){\n\t\tdouble sum=0;\n\t\tdouble p=1;\n\t\tloop(j,b,m){\n\t\t\tsum+=p*(1-in[i][j])*dfs(a|1<<i,j);\n\t\t\tp*=in[i][j];\n\t\t}\n\t\tout=max(out,sum+p);\n\t}\n\t\n\treturn dp[a][b]=out;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vvd(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tN=1<<n;\n\tdp=vvd(N,vd(m,-1));\n\tcout<<shosu(11)<<dfs(0,0)<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\n\n#define MAX 16\n\nint m, n;\ndouble win[MAX][MAX];\ndouble memo[MAX][(1 << MAX)];\n\ninline double dfs(int room = 0, int rest = (1 << m) - 1) {\n\tif(memo[room][rest] >= 0.0)\n\t\treturn memo[room][rest];\n\n\tdouble res = 0.0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tif(rest & (1 << i)) {\n\t\t\tconst int next_rest = rest ^ (1 << i);\n\t\t\tdouble tmp = 0.0, p = 1.0;\n\t\t\tfor(int j = room; j < n; ++j) {\n\t\t\t\ttmp += p * (1 - win[i][j]) * dfs(j, next_rest);\n\t\t\t\tp *= win[i][j];\n\t\t\t}\n\n\t\t\tchmax(res, tmp + p);\n\t\t}\n\t}\n\n\treturn memo[room][rest] = res;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor(int i = 0; i < m; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tscanf(\"%lf\", &win[i][j]);\n\n\tmemset(memo, -1, sizeof(memo));\n\tfor(int i = 0; i < n; ++i)\n\t\tmemo[i][0] = 0.0;\n\n\tprintf(\"%.15lf\\n\", dfs());\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint main(void) {\n  int M, N;\n  cin >> M >> N;\n  vector<vector<float>> P(M, vector<float>(N));\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  vector<vector<vector<float>>> dp(1 << M, vector<vector<float>>(N + 1, vector<float>(M)));\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        dp[S][i][j] = max(dp[S][i][j], dp[S][i + 1][j] * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          float p = dp[S][i + 1][j] * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4f \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  float ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15f\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m;\ndouble p[22][22];\ndouble lose[1<<16][16];\ndouble win[1<<16][16][16];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m;\n  rep(i,n)rep(j,m){\n    cin>>p[i][j];\n  }\n  lose[0][0]=1.0;\n  rep(S,1<<n)rep(j,m){\n    rep(i,n){\n      if(((S>>i)&1)==0){\n        maxch(lose[S|(1<<i)][j],win[S][i][j]*(1-p[i][j])+lose[S][j]*(1-p[i][j]));\n        maxch(win[S][i][j+1],(win[S][i][j]+lose[S][j])*p[i][j]);\n      }\n    }\n  }\n  /*\n  rep(S,1<<n)rep(j,m){\n    printf(\"%lld %lld : %.10f\\n\", S,j,lose[S][j]);\n  }\n  rep(S,1<<n)rep(i,n)rep(j,m+1){\n    printf(\"%lld %lld %lld : %.10f\\n\", S,i,j,win[S][i][j]);\n  }\n  */\n  double res=0;\n  ll nS=0;\n  rep(S,1<<n)rep(i,n){\n    if(((S>>i)&1)==1||bcnt(S)!=n-1)continue;\n    if(res<win[S][i][m]){\n      res=win[S][i][m];\n      nS=S;\n    }\n  }\n  while(nS>0){\n    double maxp=0;\n    ll maxi=-1;\n    rep(i,n){\n      if(((nS>>i)&1)==0)continue;\n      if(maxp<win[nS^(1<<i)][i][m]){\n        maxp=win[nS^(1<<i)][i][m];\n        maxi=i;\n      }\n    }\n    res+=maxp;\n    nS^=(1<<maxi);\n  }\n  printf(\"%.10f\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(pair<int,vector<int>> x) const {\n\t\tsize_t t = x.first;\n\t\tt *= 16;\n\t\t\n\t\tfor (int i = 0; i < x.second.size(); ++i) {\n\t\t\tt += x.second[i];\n\t\t\tt *= 2;\n\t\t}\n\t\treturn t;\n\t\t\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nvector<vector<ld>>pers;\nunordered_map<pair<int,vector<int>>, ld, HashVI>memo;\nint M, N;\nld check(const int now,vector<int>lives) {\n\tif (memo.find(make_pair(now, lives))!=memo.end()) {\n\t\treturn memo[make_pair(now, lives)];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < lives.size(); ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[make_pair(now, lives)]=amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tld ans = check(0, vector<int>(M, 1));\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nint main(){\n    int m,n;\n    cin>>m>>n;\n    vector<vector<ld>> p(m,vector<ld>(n));\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++) cin>>p[i][j];\n    }\n    vector<vector<vector<ld>>> dp(2,vector<vector<ld>>(m,vector<ld>(1<<m,0)));\n    for(int i=0;i<m;i++){\n        for(int bit=0;bit<(1<<m);bit++){\n            if((bit>>i)&1) dp[n&1][i][bit]=1;\n        }\n    }\n    for(int i=n-1;i>=0;i--){\n        for(int bit=(1<<m)-1;bit>=0;bit--){\n            for(int j=0;j<m;j++){\n                if(!((bit>>j)&1)) continue;\n                ld x=p[j][i]*dp[(i+1)&1][j][bit];\n                ld y=0;\n                for(int k=0;k<m;k++){\n                    if(!((bit>>k)&1)) y=max(y,dp[i&1][k][bit|(1<<k)]);\n                }\n                dp[i&1][j][bit]=x+(1-p[j][i])*y;\n            }\n            \n        }\n    }\n\n    ld res=0;\n    for(int i=0;i<m;i++){\n        res=max(res,dp[0][i][(1<<i)]);\n    }\n    cout<<fixed<<setprecision(10);\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-3;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\n\nint n, m;\nld p[16][17];\nld memo[17][1 << 16];\nbool used[17][1 << 16];\nld dfs(int i, int x) {\n\tif (i == m)return 1;\n\tif (used[i][x])return memo[i][x];\n\tused[i][x] = true;\n\tld res = 0;\n\trep(j, n) {\n\t\tif (x&(1 << j))continue;\n\t\tint nj = x ^ (1 << j);\n\t\tld sum = 0; ld pro = 1;\n\t\tRep1(k, i, m) {\n\t\t\tsum += dfs(k, nj)*pro*(1 - p[j][k]); pro *= p[j][k];\n\t\t}\n\t\tres = max(res, sum);\n\t}\n\treturn memo[i][x] = res;\n}\n\nint main() {\n\tcout << fixed << setprecision(12);\n\tcin >> n >> m;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tcout << dfs(0, 0) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-12;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][16];\n\n// double rec(int mask, int now, int id){\n//     if(id == n){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n//         return 1.0;\n//     }\n//     if(mask == 0 || (mask & (1LL << now)) == 0){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n//         return 0.0;\n//     }\n//     if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n//     double res = 0.0;\n//     rep(i, 0, m){\n//         if(!(mask & (1LL << i))) continue;\n//         if(i == now) continue;\n//         double tmp = rec(mask - (1LL << now), i, id);\n//         res = max(res, tmp);\n//     }\n//     res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n//     // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n//     return memo[mask][now][id] = res;\n// }\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.15Lf\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l < n; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tt += dp[n][j&~(1 << k)] * pass;\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout << fixed<<setprecision(100) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, m;\nvector<vector<double> > win;\nvector<vector<double> > memo;\n\ndouble solve(int curr, bitset<16> rest)\n{\n    if(curr == n)\n        return 1.0;\n    if(memo[curr][rest.to_ulong()] > -0.5)\n        return memo[curr][rest.to_ulong()];\n\n    double ret = 0.0;\n    for(int i=0; i<m; ++i){\n        if(!rest[i])\n            continue;\n\n        double p = win[i][curr] * solve(curr+1, rest);\n        rest[i] = false;\n        p += (1.0 - win[i][curr]) * solve(curr, rest);\n        rest[i] = true;\n\n        ret = max(ret, p);\n    }\n\n    return memo[curr][rest.to_ulong()] = ret;\n}\n\nint main()\n{\n    cin >> m >> n;\n    win.assign(m, vector<double>(n));\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            cin >> win[i][j];\n        }\n    }\n\n    memo.assign(n, vector<double>(1<<m, -1.0));\n    printf(\"%.10f\\n\", solve(0, (1<<m)-1));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  vector<vector<double>> prob(M, vector<double>(N));\n  REP(i,M) REP(j,N) cin >> prob[i][j];\n  vector<vector<double>> dp(1<<M, vector<double>(N+1, 0.));\n  dp[0][0] = 1.;\n\n  REP(i,N){\n\tREP(b,1<<M){\n\t  REP(bi,M){\n\t\tif((b>>bi&1) == 1) continue;\n\t\tint nxt = b | (1<<bi);\n\t\tdouble p = dp[b][i];\n\t\tfor(int j=i;j<N;++j){\n\t\t  dp[nxt][j] = max(dp[nxt][j], p * (1. - prob[bi][j]));\n\t\t  p *= prob[bi][j];\n\t\t}\n\t\tdp[nxt][N] = max(dp[nxt][N], p);\n\t  }\n\t}\n  }\n  /*\n  REP(b,1<<M){\n\tcout << b << \" : \";\n\tREP(i,N+1) cout << dp[b][i] << \" \";\n\tcout << endl;\n  }\n  */\n  double ans = 0.;\n  REP(b,1<<M)\n\tans += dp[b][N];\n\n  cout << fixed << setprecision(10) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][16];\n\n// double rec(int mask, int now, int id){\n//     if(id == n){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n//         return 1.0;\n//     }\n//     if(mask == 0 || (mask & (1LL << now)) == 0){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n//         return 0.0;\n//     }\n//     if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n//     double res = 0.0;\n//     rep(i, 0, m){\n//         if(!(mask & (1LL << i))) continue;\n//         if(i == now) continue;\n//         double tmp = rec(mask - (1LL << now), i, id);\n//         res = max(res, tmp);\n//     }\n//     res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n//     // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n//     return memo[mask][now][id] = res;\n// }\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.15f\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[17][17][(1 << 16) + 1];\n\nld solve(int room, int tmp, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][tmp][rest] >= 0) return dp[room][tmp][rest];\n\tld winrate = rate[tmp][room] * solve(room + 1, tmp, rest);\n\tld res = winrate;\n\tREP(i, m)\n\t{\n\t\tif (i == tmp || (rest >> i) & 1) continue;\n\t\tchmax(res, winrate + (1.0 - rate[tmp][room]) * solve(room, i, rest | (1 << tmp)));\n\t}\n\treturn dp[room][tmp][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 17)REP(j, 17)REP(k, (1 << 16)+1) dp[i][j][k] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tld ans = 0;\n\tREP(i, m) chmax(ans, solve(0, i, 0));\n\tcout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m; double a[17][17], dp[18][65555]; bool vis[18][65555];\ndouble solve(int t, int bit) {\n\tif(t == n) return 1.0;\n\tif(bit == 0) return 0.0;\n\tif(vis[t][bit]) return dp[t][bit];\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif(!(bit & (1 << i))) continue;\n\t\tdouble res1 = solve(t + 1, bit);\n\t\tdouble res2 = solve(t, bit - (1 << i));\n\t\tdouble res3 = res1 * a[i][t] + res2 * (1.0 - a[i][t]);\n\t\tret = max(ret, res3);\n\t}\n\tvis[t][bit] = true;\n\treturn dp[t][bit] = ret;\n}\nint main() {\n\tscanf(\"%d%d\", &m, &n);\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) scanf(\"%lf\", &a[i][j]);\n\t}\n\tprintf(\"%.12lf\\n\", solve(0, (1 << m) - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int MAXM = 17;\n\nint N, M;\ndouble dp[1<<MAXM][MAXN];\ndouble P[MAXM][MAXN];\n\nint main() {\n  while(cin >> M >> N) {\n    for(int i = 0; i < M; ++i) {\n      for(int j = 0; j < N; ++j) {\n        cin >> P[i][j];\n      }\n    }\n    fill(dp[0], dp[1<<MAXM], 0.0);\n    dp[0][0] = 1.0;\n    for(int j = 0; j < N; ++j) {\n      for(int i = 0; i < (1<<M); ++i) {\n        if(dp[i][j] == 0.0) continue;\n        for(int k = 0; k < M; ++k) {\n          if(i & (1<<k)) continue;\n          int ni = (i | (1<<k));\n          double np = 1.0;\n          for(int nj = j; nj < N; ++nj) {\n            dp[ni][nj] = max(dp[ni][nj], dp[i][j] * np * (1.0 - P[k][nj]));\n            np *= P[k][nj];\n          }\n          dp[ni][N] = max(dp[ni][N], dp[i][j] * np);\n        }\n      }\n    }\n    double res = 0.0;\n    for(int i = 0; i < (1<<M); ++i) {\n      res += dp[i][N];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\nlong double data[16][1<<16];\nlong double input[16][16];\n \nlong double func(int d, int s){\n  if(data[d][s] != -1) return data[d][s];\n  long double& res = data[d][s];\n  res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    long double np = 1.0;\n    long double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  return res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble dp[1 << 16][17];\ndouble ans = 0;\n\ndouble dfs(int nekos, int room, double q){\n\t//if(dp[nekos][room] != -1) return dp[nekos][room];\n\n\tdouble res = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\n\t\tdouble sum = 0;\n\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t}\n\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t//cout << bitset<2>(nekos) << ' '<<room << ' ' << sum << endl;\n\t\tres = max(res,sum);\n\t}\n\n\t//cout << \"res  \" << bitset<2>(nekos) << ' ' << room << ' ' << res << endl;\n\treturn dp[nekos][room] = res;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\t//show(neko[i][j][j])\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t\t//cout << neko[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,17) dp[i][j] = -1;\n\tcout <<fixed << setprecision(10) <<  dfs(0, 0, 1) << endl;\n\treturn 0;\n\n\t/*\n\trep(s, 1 << n){\n\t\trep(i,n){\n\t\t\tif(getBit(s,i)) continue;\n\n\t\t\tdouble q = dp[s][i][kkk\n\t\t\tdouble sum = 0;\n\n\t\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t\t}\n\t\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t\trep(j,m - room - 1){\n\n\t\t\t}\n\t\t}\n\t}\n\t*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\nmap<pair<vector<int>, int>, double> dp;\nmap<pair<vector<int>, int>, bool> done;\n\ndouble dfs(int reached) {\n\t// static double dp[1 << 18];\n\t// static bool done[1 << 18];\n\tstatic vector<int> used(20);\n\tpair<vector<int>, int> cur_status = { used, reached };\n\tif (done[cur_status] == true) {\n\t\treturn dp[cur_status];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused[i] = false;\n\t}\n\tdone[cur_status] = true;\n\treturn dp[cur_status] = res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint M, N;\ndouble P[16][16];\n\nint i, j, k, S;\ndouble win, lose, ans;\ndouble dp[17][1 << 16][16];\n\nint main(void) {\n  cin >> M >> N;\n  for(i = 0; i < M; i++) for(j = 0; j < N; j++) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[i][S][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[N][S][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[i][S][j] = dp[i + 1][S][j] * P[j][i] + max(dp[i][S | (1 << k)][k]) * (1 - P[j][i])\n   *   where k not in S\n   */\n\n  for(S = 0; S < (1 << M); S++) for(j = 0; j < M; j++) dp[N % 2][S][j] = 1;\n\n  for(i = N - 1; i >= 0; i--) {\n    for(S = 0; S < (1 << M); S++) for(j = 0; j < M; j++) dp[i % 2][S][j] = 0;\n    for(S = (1 << M) - 1; S >= 0; S--) {\n      for(j = 0; j < M; j++) if(S & (1 << j)) {\n        win = dp[(i + 1) % 2][S][j] * P[j][i];\n        lose = 0;\n        for(k = 0; k < M; k++) if(!(S & (1 << k))) {\n          lose = max(lose, dp[i % 2][S | (1 << k)][k] * (1 - P[j][i]));\n        }\n        dp[i % 2][S][j] = max(dp[i % 2][S][j], win + lose);\n      }\n    }\n  }\n\n  ans = 0;\n  for(i = 0; i < M; i++) ans = max(ans, dp[0][1 << i][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint m, n;\ndouble p[16][20];\ndouble memo[17][1<<16];\n\ndouble calc(int clear, int state)\n{\n\tif(clear >= n) return 1.0;\n\tif(memo[clear][state] > -1e8) return memo[clear][state];\n\t\n\tint nstate;\n\tdouble ret = 0.0, sum, pro;\n\tfor(int i = 0; i < m; i++){\n\t\tif(state & (1<<i)) continue;\n\t\tnstate = state | (1<<i);\n\t\tsum = 0, pro = 1;\n\t\tfor(int j = clear+1; j <= n; j++){\n\t\t\tsum += pro * (1 - p[i][j]) * calc(j-1, nstate);\n\t\t\tpro *= p[i][j];\n\t\t}\n\t\tsum += pro;\n\t\tret = max(ret, sum);\n\t}\n\treturn memo[clear][state] = ret;\n}\n\nint main(void)\n{\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j < (1 << m); j++){\n\t\t\tmemo[i][j] = -1e9;\n\t\t}\n\t}\n\t\t\n\t\n\tprintf(\"%.11f\\n\", calc(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m;\ndouble p[17][17];\ndouble dp[17][1<<16];\n\ndouble solve(int room, int bit) {\n  if(room == n) return 1;\n  double& res = dp[room][bit];\n  if(res != -1) return res;\n  res = 0;\n  rep(i, m) if(!((bit>>i)&1)) {\n    double tmp = 0, r = 1;\n    reps(j, room, n+1) {\n      tmp += r*(1-p[i][j])*solve(j, bit|1<<i);\n      r *= p[i][j];\n    }\n    chmax(res, tmp);\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> m >> n;\n  rep(i, m) {\n    rep(j, n) cin >> p[i][j];\n    p[i][n] = 0;\n  }\n  fill(dp[0], dp[16], -1);\n  cout << solve(0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[16][16][1 << 16];\n\nld solve(int room, int tmp, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][tmp][rest] >= 0) return dp[room][tmp][rest];\n\tld winrate = rate[tmp][room] * solve(room + 1, tmp, rest);\n\tld res = winrate;\n\tREP(i, m)\n\t{\n\t\tif (i == tmp || (rest >> i) & 1) continue;\n\t\tchmax(res, winrate + (1.0 - rate[tmp][room]) * solve(room, i, rest | (1 << tmp)));\n\t}\n\treturn dp[room][tmp][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 20)REP(j, 20)REP(k, 1 << 17) dp[i][j][k] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tld ans = 0;\n\tREP(i, m) chmax(ans, solve(0, i, 0));\n\tcout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nbool ok[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>&lives) {\n\tconst int a = lives.to_ulong();\n\tif (!memo[now][a]<-1) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -2;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tbitset<16>bs((1 << 16) - 1);\n\tld ans = check(0, bs);\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[20][20][1 << 17];\n\nld solve(int room, int tmp, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][tmp][rest] >= 0) return dp[room][tmp][rest];\n\tld winrate = rate[tmp][room] * solve(room + 1, tmp, rest);\n\tld res = winrate;\n\tREP(i, m)\n\t{\n\t\tif (i == tmp || (rest >> i) & 1) continue;\n\t\tchmax(res, winrate + (1.0 - rate[tmp][room]) * solve(room, i, rest | (1 << tmp)));\n\t}\n\treturn dp[room][tmp][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 20)REP(j, 20)REP(k, 1 << 17) dp[i][j][k] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tld ans = 0;\n\tREP(i, m) chmax(ans, solve(0, i, 0));\n\tcout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nfloat p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][15];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,15) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 4;\nconst int M = 17;\nconst int T = (1<<N);\nconst int INF = (1<<30);\n\nint n,m;\ndouble cat[M][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring getbit(int state,int n){\n\tstring ret = \"\";\n\trep(i,n)ret += has(state,i) ? '1' : '0';\n\treturn ret;\n}\n\ndouble dp[2][T][N];\ndouble solve_dp(){\n\tint t = (1<<n);\n\trep(i,m){\n\t\trep(j,T)rep(k,N)dp[i%2][j][k]=0.0;\n\t\tfor(int j=t-1;j>=0;j--){\n\t\t\trep(k,n){\n\t\t\t\tif(has(j,k))continue;\n\t\t\t\t\n\t\t\t\tdouble befval = 1.0;\n\t\t\t\tif(i!=0)befval = dp[(i+1)%2][j][k];\n\t\t\t\tdouble win = cat[k][m-1-i];\n\t\t\t\t\n\t\t\t\tdouble mini = 0;\n\t\t\t\t\n\t\t\t\tdouble ans1 = befval * win;\n\t\t\t\t\n\t\t\t\tmini = max(mini, ans1);\n\t\t\t\trep(p,n){\n\t\t\t\t\tint next = j^(1<<k);\n\t\t\t\t\tif(!has(next,p)){\n\t\t\t\t\t\tdouble ans2 = dp[i%2][j^(1<<k)][p] * (1-win);\n\t\t\t\t\t\tmini = max(mini, ans2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i%2][j][k] = mini;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,m){\n\t\trep(j,t){\n\t\t\trep(k,n){\n\t\t\t\tprintf(\"%s-%d  %lf | \",getbit(j,n).c_str(),k,dp[i][j][k]);\n\t\t\t}puts(\"\");\n\t\t}puts(\"\");\n\t}*/\n\t\n\tdouble ret = 0;\n\trep(i,n)ret += dp[(m-1)%2][0][i];\n\t\n\t\n\treturn ret;\n}\n\ndouble solve(){\n\treturn solve_dp();\n}\n\n\nint main(){\n\tinput();\n\tprintf(\"%.9f\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  // M - cat N - room\n  double pos[16][16];\n  REP(i, M) REP(j, N) cin >> pos[i][j];\n\n  static double dp[1 << 16][17];\n  REP(S, 1 << M) REP(u, N + 1) dp[S][N] = (S > 0 && u == N) ? 1.0 : 0.0;\n\n  for(int u = N - 1; u >= 0; u--){\n    for(int S = 0; S < 1 << M; S++){\n      for(int i = 0; i < M; i++) if(S >> i & 1){\n        double p = 1.0;\n        double npos = 0.0;\n        for(int v = u; v < N; v++){\n          npos += dp[S & ~(1 << i)][v] * p * (1.0 - pos[i][v]);\n          p *= pos[i][v];\n        }\n        npos += dp[S][N] * p;\n        dp[S][u] = max(dp[S][u], npos);\n      }\n    }\n  }\n\n  printf(\"%.12f\\n\", dp[(1 << M) - 1][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing R = long double;\n\nvector<vector<R>> memo, p;\n\nint m, n;\n\nR rec(int ri, int used){\n    R& ret = memo[ri][used];\n    if(ret > EPS) return ret;\n\n    ret = 0.0;\n\n    rep(i, m){\n        R cur = 0.0;\n\n        if(used & (1 << i)) continue;\n        int nused = used | (1 << i);\n\n        R won_p = 1.0;\n        rep(nri, ri, n){\n            cur += won_p * (1.0 - p[i][nri]) * rec(nri, nused);\n            won_p *= p[i][nri];\n        }\n        cur += won_p;\n\n        chmax(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> m >> n;\n    p = vector<vector<R>>(m, vector<R>(n));\n    rep(i, m) rep(j, n) cin >> p[i][j];\n    rep(i, m) p[i].push_back(0.0);\n\n    memo = vector<vector<R>>(n + 1, vector<R>(1 << m));\n\n    cout.precision(20);\n    cout << fixed << rec(0, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint N,M;\ndouble dp[16][1<<16],p[16][16];\nint main(){\n\tcin>>N>>M;\n\trep(i,N) rep(j,M) cin>>p[i][j];\n\tfor(int j=M-1;j>=0;j--){\n\t\tfor(int i=(1<<N)-1;i>=0;i--){\n\t\t\tdouble mx=0;\n\t\t\trep(k,N) if(((i>>k)&1)==0){\n\t\t\t\tdouble e=0,pp=1;\n\t\t\t\tfor(int h=j;h<M;h++){\n\t\t\t\t\te+=pp*(1-p[k][h])*dp[h][i+(1<<k)];\n\t\t\t\t\tpp*=p[k][h];\n\t\t\t\t}\n\t\t\t\te+=pp;\n\t\t\t\tmx=max(mx,e);\n\t\t\t}\n\t\t\tdp[j][i]=mx;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",dp[0][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\nconst double INF = (1<<30);\n\nint n,m;\ndouble cat[N][M];\n\nbool edged[T];\nvector<char> edge[T];\n\ndouble memo[M][T][N];\nvoid init(){\n\trep(i,M)rep(j,T)rep(k,N)memo[i][j][k]=INF;\n\trep(i,T)edged[i]=false;\n}\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool checked(int hoge){\n\t\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring strbit(int state, int n){\n\tstring ret = \"\";\n\trep(i,n)ret += has(state,i)?'1':'0';\n\treturn ret;\n}\n\nvoid setEdge(int state){\n\tif(edged[state])return;\n\tfor(int i=0;i<n;i++){\n\t\tif(has(state, i))edge[state].push_back(i);\n\t}\n\tedged[state]=true;\n}\n\ndouble req(int p, int state, int c){\n\tif(memo[p][state][c] != INF) return memo[p][state][c];\n\t\n\tdouble ret = 0;\n\tif(p==m)ret=1.0;\n\telse{\n\t\tsetEdge(state);\n\t\t\n\t\tdouble winrate = cat[c][p];\n\t\tdouble win = winrate * req(p+1, state, c);\n\t\trep(i,edge[state].size()){\n\t\t\tchar e = edge[state][i];\n\t\t\tret = max(ret, win + (1-winrate)*req(p, state^(1<<e), e)); \n\t\t}\n\t}\n\t\n\t//printf(\"%d %s %d %lf\\n\",p,strbit(state,n).c_str(),c,ret);\n\treturn memo[p][state][c] = ret;\n}\n\ndouble solve(){\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, req(0, (1<<n)-1, i));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tinput();\n\tprintf(\"%.12lf\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\n double dp[17][1<<16]={};\n   \nint main(){\n    int n,m;\n    cin >> m >>n;\n    vector<vector<double > > p(m+1,vector<double>(n+1));\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> p[i][j];\n        }\n    }\n    double s[17][17][17]={};\n    for(int i=0;i<m;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=j;k<=n;k++){\n                double tmp = 1.0;\n                for(int x = j;x<k;x++){\n                    tmp *= p[i][x];\n                }\n                if(k!=n)tmp *= 1.0-p[i][k];\n                s[i][j][k] = tmp;\n            }\n        }\n    }\n    dp[0][0] =1.0;\n    for(int i=1;i<(1<<m);i++){\n        for(int j=0;j<=n;j++){\n            for(int k=0;k<m;k++){\n                if(i>>k&1){\n                    double tmp = 0.0;\n                    for(int z=0;z<=j;z++){\n                        tmp += dp[z][i-(1<<k)]*s[k][z][j];\n                    }\n                    dp[j][i] = max(dp[j][i],tmp);\n\n                }\n            }\n        }\n    }\n    cout <<fixed << setprecision(15) <<  dp[n][(1<<m)-1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n//ld dp[17][1 << 16] = {0}; // dp[next enemy][used cat]\n\nint N, M;\nld P[16][16];\n\nbool m1[16][1 << 16] = {0};\nld m2[16][1 << 16];\n\nld dp(int n, int rest) {\n\tif (n >= N) return (ld)1;\n\n\tif (m1[n][rest]) return m2[n][rest];\n\n\tld ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld p = 0;\n\t\tif (rest & (1 << i)) {\n\t\t\tint nr = rest & ~(1 << i);\n\n\t\t\tld per = 1;\n\t\t\tfor (int j = n; j < N; ++j) {\n\t\t\t\tp += per * (1 - P[i][j]) * dp(j, nr);\n\t\t\t\tper *= P[i][j];\n\t\t\t}\n\t\t\tp += per;\n\t\t}\n\t\tret = max(ret, p);\n\t}\n\treturn m1[n][rest] = true, m2[n][rest] = ret;\n}\nint main() {\n\tcin >> M >> N;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tprintf(\"%.12f\\n\", (double)dp(0, (1 << M)-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[17][17][1<<16];\nint n,m;\n\ndouble DFS(int idx, int state, int cidx){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][cidx][state] >= -0.1)return dp[idx][cidx][state];\n\tif(cidx!=16)return dp[idx][cidx][state] = p[cidx][idx]*DFS(idx+1, state, cidx)+(1-p[cidx][idx])*DFS(idx, (state|(1<<cidx)), 16);\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state, i)+(1-p[i][idx])*DFS(idx, (state|mask), 16));\n\t}\n\treturn dp[idx][cidx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,17)REP(k,(1<<m))dp[i][j][k]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0,16));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\n\ndouble dp[1<<16][17];\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n  vector<vector<double>> cats(m, vector<double>(n));\n  REP(i,m)REP(j,n) {\n    cin>>cats[i][j];\n  }\n  dp[0][n] = 1.0;\n  REP(i,1<<m)FOR(j,0,n+1) {\n    REP(k,m) {\n      if ((i>>k)&1) continue;\n      double live = 1.0;\n      double sum = 0.0;\n      FOR(l,j,n+1) {\n        double oldlive = live;\n        live *= cats[k][l];\n        sum += dp[i][l] * (oldlive - live);\n      }\n      dp[i|(1<<k)][j] = max(dp[i|(1<<k)][j], sum);\n    }\n  }\n  double res = 0.0;\n  REP(i,1<<m) {\n    res = max(res, dp[i][0]);\n  }\n  cout << fixed << setprecision(14) << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble dp[65536][16];\ndouble table[16][16];\n\ndouble dfs(int state,int enemy){\n\n\tif(enemy == N)return 1.0;\n\tif(state == 0)return 0.0;\n\n\tif(dp[state][enemy] >= 0.0)return dp[state][enemy];\n\n\tdouble maximum = 0.0;\n\n\tfor(int cat = 0; cat < M; cat++){\n\t\tif(!(state & (1 << cat)))continue;\n\n\t\tdouble sum = 0.0,prob = 1.0;\n\t\tint next_state = state - POW[cat];\n\n\t\tfor(int i = enemy; i < N; i++){\n\t\t\tsum += dfs(next_state,i)*prob*(1.0-table[cat][i]);\n\t\t\tprob *= table[cat][i];\n\t\t}\n\t\tsum += prob;\n\n\t\tmaximum = max(maximum,sum);\n\t}\n\n\treturn dp[state][enemy] = maximum;\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tfor(int i = 0; i < limit; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = -1.0;\n\t\t}\n\t}\n\n\tprintf(\"%.12lf\\n\",dfs(limit-1,0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\ndouble dp[1<<16][18]={};\n\nint main()\n{\n    int m,n;\n    scanf(\" %d %d\", &m, &n);\n\n    double p[16][16]={};\n    rep(i,m)rep(j,n) scanf(\" %lf\", &p[i][j]);\n\n    dp[0][0] = 1;\n    rep(mask,1<<m)\n    {\n        rep(i,m)if(!(mask>>i&1))\n        {\n            int nmask = mask|(1<<i);\n            double now = 0;\n            rep(j,n+1)\n            {\n                now += dp[mask][j];\n                dp[nmask][j] = max(dp[nmask][j], now*(1-p[i][j]));\n                if(j<n) now *= p[i][j];\n            }\n        }\n    }\n    \n    printf(\"%.10f\\n\", dp[(1<<m)-1][n]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16];\ndouble mem[16][(1<<16)];\nbool visited[16][(1<<16)];\n\ndouble rec(int x,int S){\n  if(visited[x][S])return mem[x][S];\n  visited[x][S]=true;\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(S>>i&1)continue;\n    double p=1.0,k=0;\n    for(int j=x;j<n;j++){      \n      k+=rec(j,S|(1<<i))*p*(1.0-t[i][j]);\n      p*=t[i][j];\n    }\n    res=max(res,k+p);\n  }\n  return mem[x][S]=res;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  printf(\"%.12f\\n\",rec(0,0));  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nint n;\nint m;\ndouble dp[2][(1 << 16) + 1][17];\ndouble P[17][17];\n  \nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n  \n  int dst = 0;\n  int src = 1;\n  int lim = 1 << m;\n  for (int i=1; i<lim; i++) {\n    for (int j=0; j<m; j++) {\n      if (!(i >> j & 1)) continue;\n     dp[src][i][j] = 1.0;\n    }\n  }\n\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        cand += dp[dst][nst][n]*(1-P[j][i]);\n        cand += dp[src][st][j]*P[j][i];\n        dp[dst][st][j] = cand;\n        dp[dst][st][n] = max(dp[dst][st][n], cand);\n      }\n    }\n    swap(src, dst);\n    fill(dp[dst][0], dp[dst][lim], 0);\n  }\n  printf(\"%.20f\\n\", dp[src][lim-1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][17];\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.20Lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  // M - cat N - room\n  static double pos[16][17];\n  REP(i, M) REP(j, N) cin >> pos[i][j];\n\n  static double dp[1 << 16][17];\n  REP(S, 1 << M) REP(u, N + 1) dp[S][N] = (u == N) ? 1.0 : 0.0;\n\n  for(int u = N - 1; u >= 0; u--){\n    for(int S = 0; S < 1 << M; S++){\n      for(int i = 0; i < M; i++) if(S >> i & 1){\n        double p = 1.0;\n        double npos = 0.0;\n        for(int v = u; v <= N; v++){\n          npos += dp[S & ~(1 << i)][v] * p * (1.0 - pos[i][v]);\n          p *= pos[i][v];\n        }\n        dp[S][u] = max(dp[S][u], npos);\n      }\n    }\n  }\n\n  printf(\"%.12f\\n\", dp[(1 << M) - 1][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic bool used[20];\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused[i] = false;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20], dp[20][100000];\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tif (dp[pos][ret] >= -0.1l)return dp[pos][ret];\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) & 1 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\tdp[pos][ret] = maxn;\n\treturn maxn;\n}\nint main() {\n\tfor (int i = 0; i < 20; i++) { for (int j = 0; j < 100000; j++)dp[i][j] = -1.0l; }\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n,m;\n  cin>>m>>n;\n  \n  double p[m][n+1];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) cin>>p[i][j];\n  for(int i=0;i<m;i++) p[i][n]=0.0;\n  \n  double dp[n+1][1<<m],tmp[n+1];\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(1<<m);j++) dp[i][j]=0;\n  dp[0][0]=1.0;\n\n  for(int j=0;j<(1<<m);j++){\n    for(int k=0;k<m;k++){\n      if((j>>k)&1) continue;\n      memset(tmp,0,sizeof(tmp));\n      for(int i=0;i<=n;i++){\n\tdouble t=dp[i][j];\n\tfor(int l=i;l<=n;l++){\n\t  tmp[l]+=t*(1.0-p[k][l]);\n\t  t*=p[k][l];\n\t}\n      }\n\n      for(int i=0;i<=n;i++)\n\tdp[i][j+(1<<k)]=max(dp[i][j+(1<<k)],tmp[i]);\n      \n      /*//\n      bool f=0;\n      for(int i=n;i>=0;i--){\n\tf|=dp[i][j+(1<<k)]<tmp[i];\n\tif(dp[i][j+(1<<k)]>tmp[i]) break;\n      }\n      if(f) for(int i=0;i<=n;i++) dp[i][j+(1<<k)]=tmp[i];\n      //*/\n    }\n  }\n  /*\n  for(int j=0;j<(1<<m);j++){\n    bitset<4> b(j);\n    cout<<b<<endl;\n    for(int i=0;i<=n;i++){\n      cout<<dp[i][j]<<\" \\n\"[i==n];\n    }\n  }\n  //*/\n  /*//\n  double ans=0;\n  for(int j=0;j<(1<<m);j++) ans=max(ans,dp[n][j]);\n  printf(\"%.12lf\\n\",ans);\n  //*/\n  printf(\"%.12lf\\n\",dp[n][(1<<m)-1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  // M - cat N - room\n  double pos[16][16];\n  REP(i, M) REP(j, N) cin >> pos[i][j];\n\n  static double dp[1 << 16][17] = {};\n  REP(S, 1 << M) dp[S][N] = 1.0;\n\n  for(int u = N - 1; u >= 0; u--){\n    for(int S = 0; S < 1 << M; S++){\n      for(int i = 0; i < M; i++) if(S >> i & 1){\n        dp[S][u] = max(dp[S][u], dp[S ^ (1 << i)][u] * (1.0 - pos[i][u]) + dp[S][u + 1] * pos[i][u]);\n      }\n    }\n  }\n\n  printf(\"%.12f\\n\", dp[(1 << M) - 1][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int MAXM = 17;\n\nint N, M;\nlong double dp[1<<MAXM][MAXN];\nlong double P[MAXM][MAXN];\n\nint main() {\n  while(cin >> M >> N) {\n    for(int i = 0; i < M; ++i) {\n      for(int j = 0; j < N; ++j) {\n        cin >> P[i][j];\n      }\n    }\n    fill(dp[0], dp[1<<MAXM], 0.0);\n    dp[0][0] = 1.0;\n    for(int j = 0; j < N; ++j) {\n      for(int i = 0; i < (1<<M); ++i) {\n        if(dp[i][j] == 0.0) continue;\n        for(int k = 0; k < M; ++k) {\n          if(i & (1<<k)) continue;\n          int ni = (i | (1<<k));\n          long double np = 1.0;\n          for(int nj = j; nj < N; ++nj) {\n            dp[ni][nj] = max(dp[ni][nj], dp[i][j] * np * (1.0 - P[k][nj]));\n            np *= P[k][nj];\n          }\n          dp[ni][N] = max(dp[ni][N], dp[i][j] * np);\n        }\n      }\n    }\n    long double res = 0.0;\n    for(int i = 0; i < (1<<M); ++i) {\n      res += dp[i][N];\n    }\n    printf(\"%.10Lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n//double neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble memo[1 << 16][16][16];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\t//rep(i,n){\n\t//\trep(j,m){\n\t//\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t//\t\trange(k,j + 1,m){\n\t//\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\trep(i,1 << 16) rep(j,17) rep(k,17) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\ndouble data[16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int s){\n  if(d == n) return 1.0;\n  if(s == (1<<m)) return 0.0;\n  if(data[d][s] != -1) return data[d][s];\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    double np = 1.0;\n    double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  data[d][s] = res;\n  return res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint N;\nint M;\nvector<vector<double> > dp;\nvector<vector<double> >p;\n\ndouble solve(int i, int j) {\n\tif (dp[i][j] > -0.5) {\n\t\treturn dp[i][j];\n\t}\n\tdouble res = -1;\n\tfor (int x = 0; x < N; x++) {\n\t\tdouble tmp = 0;\n\t\tdouble prob = 1;\n\t\tif (j & (1 << x)) {\n\t\t\tfor (int m = i; m <= M; m++) {\n\t\t\t\ttmp += prob * (1 - p[x][m]) * solve(m, j ^ (1 << x));\n\t\t\t\tprob *= p[x][m];\n\t\t\t}\n\t\t}\n\t\tres = max(res, tmp);\n\t}\n\tdp[i][j] = res;\n\treturn dp[i][j];\n}\nsigned main() {\n\t\n\tcin >> N >> M;\n\tp.resize(N, vector<double>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].push_back(0);\n\t}\n\tdp.resize(M + 1, vector<double>(1 << N, -1));\n\tdp[M][0] = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tdp[i][0] = 0;\n\t}\n\tcout << setprecision(15) << solve(0, (1 << N) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tdouble p[16][16],dp[1 << 16][17] = {},ans = 0.0;\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < m;j++) cin >> p[i][j];\n\t}\n\tdp[0][0] = 1.0;\n\tfor(int i = 0;i < (1 << n);i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif((i >> j) & 1) continue;\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tdouble tmp = 1.0;\n\t\t\t\tfor(int l = k;l < m;l++){\n\t\t\t\t\tdp[i | (1 << j)][l] = max(dp[i | (1 << j)][l],dp[i][k] * tmp * (1.0 - p[j][l]));\n\t\t\t\t\ttmp *= p[j][l];\n\t\t\t\t}\n\t\t\t\tdp[i | (1 << j)][m] = max(dp[i | (1 << j)][m],dp[i][k] * tmp);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < (1 << n);i++) ans += dp[i][m];\n\tprintf(\"%.12lf\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<vector<double>> w(m, vector<double>(n + 1, 0));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n    vector<vector<double>> dp(1 << m, vector<double>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i < (1 << m); ++i) {\n        for (int j = 1; j <= n; ++j) {\n            for (int k = 0; k < m; ++k) {\n                if ((i >> k) & 1) {\n                    double d = 1 - w[k][j];\n                    for (int l = j; l >= 0; --l) {\n                        if (l < j) d *= w[k][l];\n                        dp[i][j] = max(dp[i][j], d * dp[i ^ (1 << k)][l]);\n                    }\n                }\n            }\n        }\n    }\n    double ans = 0;\n    for (int i = 1; i < (1 << m); ++i)\n        ans += dp[i][n];\n\n    printf(\"%.9lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint n, m;\ndouble p[16][16];\ndouble dp[16][1<<16];\n\ndouble solve(int room, int bit) {\n  if(room == n) return 1;\n  double& res = dp[room][bit];\n  if(res != -1) return res;\n  res = 0;\n  rep(i, m) if(!((bit>>i)&1)) {\n    double tmp = 0, r = 1;\n    reps(j, room, n+1) {\n      tmp += r*(1-p[i][j])*solve(j, bit|1<<i);\n      r *= p[i][j];\n    }\n    chmax(res, tmp);\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> m >> n;\n  rep(i, m) {\n    rep(j, n) cin >> p[i][j];\n    p[i][n] = 0;\n  }\n  fill(dp[0], dp[16], -1);\n  cout << solve(0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N, M;\ndouble p[16][16];\ndouble prob(int S, int k){\n  double res = 0;\n  REP(i, N) if(!(S >> i & 1)){\n    double r = 1;\n    double sum = 0;\n    FOR(j, k, M){\n      sum += r * (1 - p[i][j]) * prob(S | (1<<i), j);\n      r *= p[i][j];\n    }\n    sum += r;\n    res = max(res, sum);\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>N>>M && N){\n    REP(i, N) REP(j, M) cin>>p[i][j]; //cat-i wins ops-j.\n    printf(\"%.12lf\\n\", prob(0, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\ndouble dp[101010][20], a[20][20];\nint n, m;\ndouble rec(int mask, int x)\n{\n    if(dp[mask][x]!=0)\n        return dp[mask][x];\n    if(x==m)\n        return dp[mask][x] = 1;\n    if(mask==0)\n        return 0;\n    double ret = 0;\n    rep(i,n){\n        if(mask & 1<<i){\n            double res = 0,pos=1.0;\n            REP(j, x, m){\n                res += rec(mask ^ (1 << i), j) * pos * (1.0 - a[i][j]);\n                pos = pos * a[i][j];\n            }\n            res += pos;\n            ret = max(res, ret);\n        }\n    }\n    return dp[mask][x] = ret;\n}\nint main(){\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> a[i][j];\n    }\n    int all = 1 << n;\n    cout << rec(all-1, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double ld;\n\n//ld dp[17][1 << 16] = {0}; // dp[next enemy][used cat]\n\nint N, M;\nld P[16][16];\n\nbool m1[16][1 << 16] = {0};\nld m2[16][1 << 16];\n\nld dp(int n, int rest) {\n\tif (n >= N) return (ld)1;\n\n\tif (m1[n][rest]) return m2[n][rest];\n\n\tld ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld p = 0;\n\t\tif (rest & (1 << i)) {\n\t\t\tint nr = rest & ~(1 << i);\n\n\t\t\tld per = 1;\n\t\t\tfor (int j = n; j < N; ++j) {\n\t\t\t\tp += per * (1 - P[i][j]) * dp(j, nr);\n\t\t\t\tper *= P[i][j];\n\t\t\t}\n\t\t\tp += per;\n\t\t}\n\t\tret = max(ret, p);\n\t}\n\treturn m1[n][rest] = true, m2[n][rest] = ret;\n}\nint main() {\n\tcin >> M >> N;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tprintf(\"%.12f\\n\", (double)dp(0, (1 << M)-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n\ntypedef tuple<int,int,int> T;\nmap<T,double> memo;\n//double memo[1 << 16][16][16];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo.count(T(nekos, room, neko))) return memo[T(nekos, room, neko)];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[T(nekos,room,neko)] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\t//rep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\nmap<pair<int,int>, double> dp;\nmap<pair<int,int>, bool> done;\n\ndouble dfs(int reached) {\n\tstatic int used;\n\tpair<int,int> cur_status = {used, reached};\n\n\tif (done[cur_status] == true) {\n\t\treturn dp[cur_status];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif ((used >> i) & 1) continue;\n\t\tused |= 1 << i;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused ^= 1 << i;\n\t}\n\tdone[cur_status] = true;\n\treturn dp[cur_status] = res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  // M - cat N - room\n  double pos[16][16];\n  REP(i, M) REP(j, N) cin >> pos[i][j];\n\n  static double dp[1 << 16][17];\n  REP(S, 1 << M) REP(u, N + 1) dp[S][N] = (S > 0 && u == N) ? 1.0 : 0.0;\n\n  for(int u = N - 1; u >= 0; u--){\n    for(int S = 0; S < 1 << M; S++){\n      for(int i = 0; i < M; i++) if(S >> i & 1){\n        dp[S][u] = max(dp[S][u], dp[S & ~(1 << i)][u] * (1.0 - pos[i][u]) + dp[S][u + 1] * pos[i][u]);\n      }\n    }\n  }\n\n  printf(\"%.12f\\n\", dp[(1 << M) - 1][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n#define mod 1000000007\ndouble result[(1 << 16)][17] = {};\n\nint main()\n{\n\tint m, n;\n\tcin >> m >> n;\n\tdouble winper[17][17] = {};\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> winper[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < (1 << m); i++){\n\t\tresult[i][n] = 1.0;\n\t}\n\t// 今j番目の部屋にいる(今からj番目の敵を倒す)\n\tfor(int j = n - 1; j >= 0; j--){\n\t\t// 残っている猫の組み合わせ : i\n\t\tfor(int i = 0; i < (1 << m); i++){\n\t\t\t// 次に戦う猫を決める\n\t\t\tdouble tmpres = 0.0;\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tif((i & (1 << k)) == 0) continue;\n\t\t\t\t// どこまで戦い抜くか？\n\t\t\t\tdouble tmp = 1.0;\n\t\t\t\tdouble tmpres = (1.0 - winper[k][j]) * result[i ^ (1 << k)][j];\n\t\t\t\tfor(int l = j; l < n; l++){\n\t\t\t\t\ttmp *= winper[k][l];\n\t\t\t\t\ttmpres += tmp * (1.0 - winper[k][l + 1]) * result[i ^ (1 << k)][l + 1];\n\t\t\t\t}\n\t\t\t\tresult[i][j] = max(result[i][j], tmpres);\n\t\t\t}\n\t\t\t// cout << i << \" \" << j << \" \" << result[i][j] << endl;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", result[(1 << m) - 1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\n\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static int used[N][1<<N]={};\n  static double mem[N][1<<N];\n  if(used[pos][bit]++) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\ndouble mem[N][N][1<<N];\nint used[N][N][1<<N];\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(used[pos][k][bit]++) return mem[pos][k][bit];\n  double p = neko[k][pos];\n  return mem[pos][k][bit]= p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n#define double float\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][16][16];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][17];\n\ndouble rec(int mask, int id){\n    if(id == n) return 1.0;\n    if(mask == 0) return 0.0;\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        res = max(res, tmp);\n    }\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m) rep(j, 0, n) cin >> p[i][j];\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.20Lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-12;\n \nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][17];\n \n// double rec(int mask, int now, int id){\n//     if(id == n){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n//         return 1.0;\n//     }\n//     if(mask == 0 || (mask & (1LL << now)) == 0){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n//         return 0.0;\n//     }\n//     if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n//     double res = 0.0;\n//     rep(i, 0, m){\n//         if(!(mask & (1LL << i))) continue;\n//         if(i == now) continue;\n//         double tmp = rec(mask - (1LL << now), i, id);\n//         res = max(res, tmp);\n//     }\n//     res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n//     // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n//     return memo[mask][now][id] = res;\n// }\n \ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n \nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.20Lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\ndouble dp[1 << 16][16][16];\n\nint main(void) {\n  int M, N;\n  cin >> M >> N;\n  vector<vector<double>> P(M, vector<double>(N));\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  REP(S, 0, 1 << M) REP(i, 0, N + 1) REP(j, 0, N) dp[S][i][j] = 0;\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        double x = i + 1 < N ? dp[S][i + 1][j] : 1;\n        dp[S][i][j] = max(dp[S][i][j], x * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          double p = x * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4lf \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  double ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint m, n;\ndouble mat[18][18];\nbool visited[(1<<16)][16];\ndouble memo[(1<<16)][16];\n\ndouble dfs(int used, int stage){\n    if(stage == n) return 1;\n    if(used == (1 << m)-1) return 0;\n    if(visited[used][stage]) return memo[used][stage];\n    double ret = 0;\n    for(int i=0;i<m;i++){\n        if((used>>i)&1) continue;\n        double path = 1;\n        double suc = 0;\n        int nused = used | (1 << i);\n        for(int j=stage;j<n;j++){\n            suc += path * (1 - mat[i][j]) * dfs(nused, j);\n            path *= mat[i][j];\n        }\n        suc += path;\n        ret = max(ret, suc);\n    }\n    visited[used][stage] = true;\n    memo[used][stage] = ret;\n    return ret;\n}\n\nint main(){\n    cin >> m >> n;\n\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> mat[i][j];\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    printf(\"%.10f\\n\", dfs(0, 0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nint p[16][16];\n\ntypedef tuple<int,int,int> T;\nint memo[1 << 16][16][16];\n\nint dfs(int nekos, int room, int neko){\n\tif(room == m) return 1e9;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tint res = dfs(nekos, room + 1, neko) / 1e2 * p[neko][room];\n\tint maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max<int>(maxi, dfs(setBit(nekos, neko), room, i) / 1e2 * (100 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tdouble a;\n\t\t\tcin >> a;\n\t\t\tp[i][j] = a * 100;\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max<double>(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans / 1000000000.0 << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n\tint m,n;//ねこ　階数\n\tcin>>m>>n;\n\tvector<vector<vector<double> > >   dp(1<<m,vector<vector<double> >(n+1, vector<double>(m,0) ) );\n\tvector<vector<double> >   p(m,vector<double> (n,0) );\n\t\n\tfor(int i=0;i< (1<<m) ;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(  ( (1<<j) & i ) != 0 ) dp[i][0][j] = 1;  \n\t\t}\n\t}\n\t\n\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<n;j++)cin>>p[i][j];\n\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<(1<<m);j++){\n\t\t\tfor(int k = 0;k<m;k++){\n\t\t\t\tif( (j&(1<<k) ) == 0 ) continue;\n\t\t\t\tdouble mx = 0;\n\t\t\t\tfor(int l = 0; l< m;l++ ) {\n\t\t\t\t\tmx = max(mx,dp[ (j&~(1<<k) )][i+1][l] ) ;\n\t\t\t\t}\n\t\t\t\tdp[j][i][k] = p[k][i]*dp[j][i][k] + (1- p[k][i])*mx;\n\n\t\t\t\tdp[j][i+1][k] = dp[j][i][k];\n\t\t\t}\n\n\t\t}\n\t}\n\t\n\tcout << *max_element(dp[(1<<m) -1][n].begin(), dp[(1<<m) -1][n].end()) << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ndouble dp[1<<16][17];\ndouble prob[16][16];\nint n, m;\n\ndouble solve(int bit, int k, double p){\n  if(bit == 0){\n    //cout << bit << \" \" << k << \" \" << p << \" \" << 0 << endl;\n    return 0;\n  }\n  if(k == m){\n    dp[bit][k] = max(dp[bit][k],p);\n    //cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n    return dp[bit][k];\n  }\n  double ret = 0.0;\n  for(int i = 0; i < n; ++i){\n    if((bit >> i) & 1){\n      double t = p, s = 0.0;\n      for(int j = k; j < m; ++j){\n\ts += solve(bit - (1<<i), j, t*(1.0-prob[i][j]));\n\tt *= prob[i][j];\n      }\n      s += solve(bit, m, t);\n      ret = max(ret,s);\n    }\n  }\n  dp[bit][k] = max(dp[bit][k], ret);\n  //cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n  return dp[bit][k];\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  double ans = solve((1<<n)-1,0,1);\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic int used;\n\tstatic double dp[1 << 17][20];\n\tstatic bool done[1 << 18][20];\n\tif (done[used][reached] == true) {\n\t\treturn dp[used][reached];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif ((used >> i) & 1) continue;\n\t\tused |= 1 << i;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused ^= 1 << i;\n\t}\n\tdone[used][reached] = true;\n\treturn dp[used][reached] = res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m;\ndouble dp[1<<16][22],x[111][111];\ndouble dfs(int S,int dep){\n    if(dep==m)return 1;\n    if(dp[S][dep]!=-1)return dp[S][dep];\n    double res=0;\n    for(int i=0;i<n;i++){\n        if(!((1<<i)&S))continue;\n        double tmp=0,X=1;\n        for(int j=dep;j<=m;j++){\n            tmp+=X*(1.0-x[i][j])*dfs(S-(1<<i),j);\n            X*=x[i][j];\n        }\n        res=max(res,tmp);\n    }\n    return dp[S][dep]=res;\n}\nint main(){\n    r(i,1<<16)r(j,22)dp[i][j]=-1;\n    cin>>n>>m;\n    r(i,n)r(j,m)cin>>x[i][j];\n    printf(\"%.9f\\n\",dfs((1<<n)-1,0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\ndouble dp[101010][20], a[20][20];\nint n, m;\ndouble rec(int mask, int x)\n{\n    if(dp[mask][x]!=0)\n        return dp[mask][x];\n    if(x==m)\n        return dp[mask][x] = 1;\n    if(mask==0)\n        return 0;\n    double ret = 0;\n    rep(i,n){\n        if(mask & 1<<i){\n            double res = 0,pos=1.0;\n            REP(j, x, m){\n                res += rec(mask ^ (1 << i), j) * pos * (1.0 - a[i][j]);\n                pos = pos * a[i][j];\n            }\n            res += pos;\n            ret = max(res, ret);\n        }\n    }\n    return dp[mask][x] = ret;\n}\nint main(){\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> a[i][j];\n    }\n    int all = 1 << n;\n    cout << fixed << setprecision(12) << rec(all - 1, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n, m;\n//long double data[16][16][1<<16];\nlong double input[16][16];\n\nlong double func(int d, int c, int s){\n  long double res = 0.0;\n  for(int i=0;i<=n-d;i++){\n    long double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][c];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n        if((s >> j) & 1) continue;\n        /*if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n          else res += tmp * func(d+i, j, s|(1<<j));*/\n        res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n  }\n  //data[d][c][s] = res;\n  return res;\n}\n\nlong double solve(){\n  //fill(data[0][0], data[16][0], -1.0);\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, i, 1<<i));\n  }\n  return res;\n}\n\nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>&lives) {\n\tconst int a = lives.to_ulong();\n\tif (!memo[now][a]<0) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tbitset<16>bs((1 << 16) - 1);\n\tld ans = check(0, bs);\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20], dp[20][100000];\ninline long double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tif (dp[pos][ret] >= -0.1l)return dp[pos][ret];\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret >> i) & 1 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\tdp[pos][ret] = maxn;\n\treturn maxn;\n}\nint main() {\n\tfor (int i = 0; i < 20; i++) { for (int j = 0; j < 100000; j++)dp[i][j] = -1.0l; }\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble dp[17][(1LL << 16) + 1];\ndouble nxt[17][(1LL << 16) + 1];\ndouble memo[1LL << 16][16][16];\n\ndouble rec(int mask, int now, int id){\n    if(id == n) return 1.0;\n    if(mask == 0) return 0.0;\n    if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        if(i == now) continue;\n        double tmp = rec(mask - (1LL << i), i, id);\n        res = max(res, tmp);\n    }\n    res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    return memo[mask][now][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(j, 0, m) rep(k, 0, n + 1) memo[i][j][k] = -1.0;\n    double ans = 0.0;\n    rep(i, 0, m){\n        ans = max(ans, rec((1LL << m) - 1, i, 0));\n    }\n    // rep(i, 0, 1 << m){\n    //     rep(j, 0, m){\n    //         rep(k, 0, n + 1){\n    //             cout << i << ' ' << j << ' ' << k << ' ' << memo[i][j][k] << endl;\n    //         }\n    //     }\n    // }\n    printf(\"%.10f\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\nlong double data[16][1<<16];\nlong double input[16][16];\n\nlong double func(int d, int s){\n  if(d == n) return 1.0;\n  if(s == (1<<m)) return 0.0;\n  if(data[d][s] != -1) return data[d][s];\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    long double np = 1.0;\n    long double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  data[d][s] = res;\n  return res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m; double a[17][17], dp[18][65555]; bool vis[18][65555];\ndouble solve(int t, int bit) {\n\tif (bit == 0) return 0.0;\n\tif (vis[t][bit]) return dp[t][bit];\n\tdouble ret = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!(bit & (1 << i))) continue;\n\t\tdouble res = 0.0, mul = 1.0;\n\t\tfor (int j = t; j < n; j++) {\n\t\t\tres += solve(j, bit - (1 << i)) * mul * (1.0 - a[i][j]);\n\t\t\tmul *= a[i][j];\n\t\t}\n\t\tres += mul; // all complete\n\t\tret = max(ret, res);\n\t}\n\tvis[t][bit] = true;\n\treturn dp[t][bit] = ret;\n}\nint main() {\n\tscanf(\"%d%d\", &m, &n);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) scanf(\"%lf\", &a[i][j]);\n\t}\n\tprintf(\"%.12lf\\n\", solve(0, (1 << m) - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][17];\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.20Lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ndouble dp[17][16][1<<16];\n\nint main()\n{\n    int m, n;\n    cin >> m >> n;\n    vector<vector<double>> p(m, vector<double>(n));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> p[i][j];\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < (1<<m); k++) {\n                dp[i][j][k] = 0;\n            }\n            dp[0][j][0] = 1;\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < (1<<m); k++) {\n                if (dp[i][j][k] == 0) continue;\n                if (k >> j & 1) continue;\n                dp[i+1][j][k] += (dp[i][j][k] * p[j][i]);\n                int nk = (k | (1<<j));\n                for (int l = 0; l < m; l++) {\n                    if (nk >> l & 1) continue;\n                    dp[i][l][nk] += (dp[i][j][k] * (1 - p[j][i]));\n                }\n            }\n        }\n    }\n    \n    double res = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < (1<<m)-1; j++) {\n            res = max(res, dp[n][i][j]);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<double>> v, dp;\nvector<vector<vector<double>>> sum;\n\nlong double solve();\n\nint main() {\n  cout << fixed << setprecision(10);\n  cin >> m >> n;\n  v.assign(m, vector<double>(n + 1, 0.0L));\n  for(int i = 0; i < m; ++i)\n    for(int j = 0; j < n; ++j) cin >> v[i][j];\n  cout << solve() << endl;\n  return 0;\n}\n\nlong double solve() {\n  dp.assign(2, vector<double>(1LL << m, 0));\n  sum.assign(2, vector<vector<double>>(\n                    m, vector<double>(1LL << m, 0.0L)));\n  for(int i = n; i >= 0; --i)\n    for(int j = 0; j < (1LL << m); ++j) {\n      dp[i % 2][j] = 0;\n      if(i == n)\n        dp[i % 2][j] = 1;\n      else\n        for(int k = 0; k < m; ++k) {\n          sum[i % 2][k][j] =\n              sum[(i + 1) % 2][k][j] * v[k][i];\n          if(j >> k & 1)\n            dp[i % 2][j] =\n                max(dp[i % 2][j],\n                    sum[i % 2][k][j - (1LL << k)]);\n        }\n      for(int k = 0; k < m; ++k)\n        if(!(j >> k & 1))\n          sum[i % 2][k][j] += dp[i % 2][j] * (1 - v[k][i]);\n    }\n  return dp[0][(1LL << m) - 1];\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,N;\nvvd in,dp;\ndouble dfs(int a,int b){\n\tif(abs(dp[a][b]+1)>EPS)return dp[a][b];\n\tdouble out=0;\n\trep(i,n)if((a&1<<i)==0){\n\t\tdouble sum=0;\n\t\tdouble p=1;\n\t\tloop(j,b,m){\n\t\t\tsum+=p*(1-in[i][j])*dfs(a|1<<i,j);\n\t\t\tp*=in[i][j];\n\t\t}\n\t\tout=max(out,sum+p);\n\t}\n\t\n\treturn dp[a][b]=out;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vvd(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tN=1<<n;\n\tdp=vvd(N,vd(m,-1));\n\tcout<<shosu(11)<<dfs(0,0)<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[22][1<<13];\nint n,m;\n\ndouble DFS(int idx, int state){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][state] >= -0.1)return dp[idx][state];\n\tdouble ret = -0.1;\n\tREP(i,n){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state)+(1-p[i][idx])*DFS(idx, state ^ mask));\n\t}\n\treturn dp[idx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,(1<<m))dp[i][j]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nint n;\nint m;\ndouble dp[17][(1 << 16) + 1][17];\ndouble P[17][17];\n  \nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n  \n  int lim = 1 << m;\n  for (int i=1; i<lim; i++) {\n    for (int j=0; j<m; j++) {\n      if (!(i >> j & 1)) continue;\n     dp[n][i][j] = 1.0;\n    }\n  }\n\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        cand += dp[i][nst][n]*(1-P[j][i]);\n        cand += dp[i+1][st][j]*P[j][i];\n        dp[i][st][j] = cand;\n        dp[i][st][n] = max(dp[i][st][n], cand);\n      }\n    }\n  }\n  printf(\"%.20f\\n\", dp[0][lim-1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16];\ndouble dp[16][(1<<16)];\ndouble P[16][(1<<16)];\n\ndouble rec(int x,int S){\n\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(S>>i&1)continue;\n    double p=1.0,k=0;\n    for(int j=x;j<n;j++){      \n      k+=rec(j,S|(1<<i))*p*(1.0-t[i][j]);\n      p*=t[i][j];\n    }\n    res=max(res,k+p);\n  }\n  return res;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      cin>>t[i][j];\n    }\n  }\n  \n  double p,k;  \n  for(int S=(1<<m)-1;S>=0;S--){\n    for(int x=n-1;x>=0;x--){\n      \n      p=1.0,k=0.0;\n      for(int i=0;i<m;i++){\n        if(S>>i&1)continue;\n        p=1.0,k=0.0;\n        for(int j=x;j<n;j++){      \n          k+=dp[j][S|(1<<i)]*p*(1.0-t[i][j]);\n          p*=t[i][j];\n        }\n        dp[x][S]=max(dp[x][S],k+p);\n      }\n      \n    }\n  }\n  printf(\"%.12f\\n\",dp[0][0]);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n\tint m,n;//ねこ　階数\n\tcin>>m>>n;\n\tvector<vector<double> >    dp(1<<m, vector<double>(m,0) ) ;\n\tvector<vector<double> >   p(m,vector<double> (n,0) );\n\t\n\tfor(int i=0;i< (1<<m) ;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(  ( (1<<j) & i ) != 0 ) dp[i][j] = 1;  \n\t\t}\n\t}\n\t\n\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<n;j++)cin>>p[i][j];\n\n\n\tfor(int i=n-1;i>=0;i--){\n\t\tvector<vector<double> > mem(1<<m,vector<double> (m,0) );\n\t\tfor(int j=0;j<(1<<m);j++){\n\t\t\tfor(int k = 0;k<m;k++){\n\t\t\t\tif( (j&(1<<k) ) == 0 ) continue;\n\t\t\t\tdouble mx = 0;\n\t\t\t\tfor(int l = 0; l< m;l++ ) {\n\t\t\t\t\tmx = max(mx,mem[ (j&~(1<<k) )][l] ) ;\n\t\t\t\t}\n\t\t\t\tmem[j][k] = p[k][i]*dp[j][k] + (1- p[k][i])*mx;\n\t\t\t}\n\t\t}\n\t\tdp = mem;\n\t}\n\n\tcout << fixed << setprecision(10);\n\tcout << *max_element(dp[(1<<m) -1].begin(), dp[(1<<m) -1].end()) << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 4;\nconst int M = 17;\nconst int T = (1<<N);\nconst int INF = (1<<30);\n\nint n,m;\ndouble cat[M][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring getbit(int state,int n){\n\tstring ret = \"\";\n\trep(i,n)ret += has(state,i) ? '1' : '0';\n\treturn ret;\n}\n\ndouble dp[2][T][N];\ndouble solve_dp(){\n\tint t = (1<<n);\n\trep(i,m){\n\t\trep(j,T)rep(k,N)dp[i%2][j][k]=0.0;\n\t\tfor(int j=t-1;j>=0;j--){\n\t\t\trep(k,n){\n\t\t\t\tif(has(j,k))continue;\n\t\t\t\t\n\t\t\t\tdouble befval = 1.0;\n\t\t\t\tif(i!=0)befval = dp[(i+1)%2][j][k];\n\t\t\t\tdouble win = cat[k][m-1-i];\n\t\t\t\t\n\t\t\t\tdouble mini = 0;\n\t\t\t\t\n\t\t\t\tdouble ans1 = befval * win;\n\t\t\t\t\n\t\t\t\tmini = max(mini, ans1);\n\t\t\t\trep(p,n){\n\t\t\t\t\tint next = j^(1<<k);\n\t\t\t\t\tif(!has(next,p)){\n\t\t\t\t\t\tdouble ans2 = dp[i%2][j^(1<<k)][p] * (1-win);\n\t\t\t\t\t\tmini = max(mini, ans2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i%2][j][k] = mini;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,m){\n\t\trep(j,t){\n\t\t\trep(k,n){\n\t\t\t\tprintf(\"%s-%d  %lf | \",getbit(j,n).c_str(),k,dp[i][j][k]);\n\t\t\t}puts(\"\");\n\t\t}puts(\"\");\n\t}*/\n\t\n\tdouble ret = 0;\n\trep(i,n)ret += dp[(m-1)%2][0][i];\n\t\n\t\n\treturn ret;\n}\n\ndouble solve(){\n\treturn solve_dp();\n}\n\n\nint main(){\n\tinput();\n\tprintf(\"%.12f\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconstexpr ll MOD = ll(1e9+7);\n\nint n, m;\ndouble dp[17][16][1<<16];  // dp[i][j][S] i番目より後の敵を倒して、現在ねこjを派遣しており、やられたねこの集合がSの最大確率\ndouble dp2[17][1<<16];  // dp2[i][S] i番目以降の敵を倒して、やられたねこの集合がSである最大確率\ndouble w[17][17];\n\nvoid chmax(double &a, double b){\n    a = max(a, b);\n}\n\nint main(){\n    cin >> m >> n;\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> w[i][j];\n        }\n    }\n    for(int i=0;i<m;i++){\n        for(int S=0;S<1<<m;S++){\n            dp[n][i][S] = 1.0;\n        }\n    }\n    for(int i=n-1;i>=0;i--){\n        for(int S=(1<<m)-2;S>=0;S--){\n            for(int j=0;j<m;j++){\n                if((S>>j)&1) continue;\n                dp[i][j][S] = dp[i+1][j][S] * w[j][i] + dp2[i][S|(1<<j)] * (1-w[j][i]);\n                chmax(dp2[i][S], dp[i][j][S]);\n            }\n        }\n    }\n\n    double ans = dp2[0][0];\n    printf(\"%.12lf\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int MAXM = 17;\n\nint N, M;\nlong double dp[1<<MAXM][MAXN];\nlong double P[MAXM][MAXN];\n\nlong double rec(int i, int j) {\n  long double &res = dp[i][j];\n  if(res != -1.0) return res;\n  res = 0.0;\n  for(int k = 0; k < M; ++k) {\n    if(i & (1<<k)) continue;\n    int ni = (i | (1<<k));\n    long double np = 1.0;\n    long double sum = 0.0;\n    for(int nj = j; nj < N; ++nj) {\n      sum += rec(ni, nj) * np * (1.0 - P[k][nj]);\n      np *= P[k][nj];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> M >> N) {\n    for(int i = 0; i < M; ++i) {\n      for(int j = 0; j < N; ++j) {\n        cin >> P[i][j];\n      }\n    }\n    fill(dp[0], dp[1<<MAXM], -1.0);\n    printf(\"%.10Lf\\n\", rec(0,0));\n    continue;\n\n\n    dp[0][0] = 1.0;\n    long double res = 0.0;\n    for(int j = 0; j < N; ++j) {\n      for(int i = 0; i < (1<<M); ++i) {\n        if(dp[i][j] == 0.0) continue;\n        for(int k = 0; k < M; ++k) {\n          if(i & (1<<k)) continue;\n          int ni = (i | (1<<k));\n          long double np = 1.0;\n          for(int nj = j; nj < N; ++nj) {\n            dp[ni][nj] = max(dp[ni][nj], dp[i][j] * np * (1.0 - P[k][nj]));\n            np *= P[k][nj];\n          }\n          res += dp[i][j] * np;\n          //          dp[ni][N] = max(dp[ni][N], dp[i][j] * np);\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < (1<<M); ++i) {\n      res += dp[i][N];\n    }\n    */\n    printf(\"%.10Lf\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000009;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nsigned main(){\n\tint m,n;\n\tdouble p[20][20] = {};\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++) cin >> p[i][j];\n\t}\n\tdouble dp[1 << 16][20] = {};\n\tfor(int i = 0;i < (1 << m);i++) dp[i][n] = 1;\n\tfor(int i = (1 << m) - 2;i >= 0;i--){\n\t\tfor(int j = n - 1;j >= 0;j--){\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tif((i >> k) & 1) continue;\n\t\t\t\tdouble sum = 0,q = 1;\n\t\t\t\tfor(int l = j;l <= n;l++){\n\t\t\t\t\tsum += dp[i | (1 << k)][l] * q * (1.0 - p[k][l]);\n\t\t\t\t\tq *= p[k][l];\n\t\t\t\t}\n\t\t\t\tchmax(dp[i][j],sum);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.15lf\\n\",dp[0][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) ((int)(x.size()))\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint m, n;\ndouble dp[17][1 << 16];\ndouble p[17][17];\n\ndouble rec(int i, int S) {\n    auto &DP = dp[i][S];\n    if (DP != -1) return DP;\n\n    double ret = 0;\n    REP(k, m) {\n        if (S >> k & 1) continue;\n        int nextS = S | (1 << k);\n        double tmp = 0, prd = 1;\n        for (int l = 0; i + l < n; ++l) {\n            tmp += prd * (1 - p[k][i + l]) * rec(i + l, nextS);  // i+l に負ける\n            prd *= p[k][i + l];\n        }\n        tmp += prd;  // 全勝\n        chmax(ret, tmp);\n    }\n    return DP = ret;\n}\n\nsigned main() {\n    REP(i, 17) REP(j, 1 << 16) dp[i][j] = -1;\n\n    cin >> m >> n;\n    REP(i, m) {\n        REP(j, n) {\n            cin >> p[i][j];\n        }\n    }\n    cout << setprecision(20) << fixed << rec(0, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ndouble memo[16][1 << 16];\nbool   dp[16][1 << 16];\ndouble prob[16][16];\n\nint m, n;\n\ndouble solve(int pos, int flag){\n  if(pos == n)      return 1.0;\n  if(dp[pos][flag]) return memo[pos][flag];\n  dp[pos][flag] = true;\n\n  double ret = 0.0;\n\n  REP(i,m) if(flag & (1 << i)){\n    double p   = 1.0;\n    double tmp = 0.0;\n    for(int j = pos; j < n; j++){\n      double pp = p * prob[i][j];\n      tmp += (p - pp) * solve(j, flag ^ (1 << i));\n      p = pp;\n      if(p < 1e-10) break;\n    }\n    tmp += p;\n    ret = max(ret, tmp);\n  }\n\n  return memo[pos][flag] = ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &m, &n);\n  REP(i,m) REP(j,n)\n    scanf(\"%lf\", &prob[i][j]);\n  printf(\"%.11f\\n\", solve(0, (1 << m) - 1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(pair<int,vector<int>> x) const {\n\t\tsize_t t = x.first;\n\t\tt *= 16;\n\t\t\n\t\tfor (int i = 0; i < x.second.size(); ++i) {\n\t\t\tt += x.second[i];\n\t\t\tt *= 2;\n\t\t}\n\t\treturn t;\n\t\t\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nvector<vector<ld>>pers;\nunordered_map<pair<int,vector<int>>, ld, HashVI>memo;\nint M, N;\nld check(const int now,vector<int>&lives) {\n\tif (memo.find(make_pair(now, lives))!=memo.end()) {\n\t\treturn memo[make_pair(now, lives)];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < lives.size(); ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[make_pair(now, lives)]=amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tld ans = check(0, vector<int>(M, true));\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-11)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\n#define MAX 17\nint m,n;\ndouble p[MAX][MAX];\n\ndouble memo[MAX][1<<MAX]; // memo[今いる部屋の番号][倒された猫の状態] := この状態から最適な順番で猫を送り出して全ての敵を倒す確率の最大値\n\ninline double dfs(int room_id, int cat_state) {\n  if( room_id >= n ) {\n    return 1.0;\n  }\n  double &cur_p = memo[room_id][cat_state];\n  if( LTE(0,cur_p) ) return cur_p;\n  cur_p = 0.0;\n  rep(i,m) if( !( (cat_state>>i) & 1 ) ) {\n    double q = 1.0, tmp = 0;\n    REP(j,room_id,n) {\n      // lose\n      tmp += ( dfs(j,cat_state|(1<<i)) * q * ( 1.0 - p[i][j] ) );\n      q = q * p[i][j];\n    }\n    // all win\n    tmp += q;\n    if( LT(cur_p,tmp) ) cur_p = tmp;\n  }\n  return cur_p;\n}\n\nvoid solve() {\n  rep(i,n+1) rep(j,(1<<m)) memo[i][j] = -1;\n  double maxi = dfs(0,0);\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> m >> n;\n  rep(i,m) rep(j,n) cin >> p[i][j];\n  rep(i,m) p[i][n] = 0.0; // 猫が全ての敵を倒した時用\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m;\nfloat dp[1<<16][16][16];\ndouble dp2[1<<16][17];\ndouble data[17][17];\n\ndouble memo(int bit,int v,int c){\n\tif(v==n)return 1.0;\n\tif(bit==0)return 0.0;\n\tif(dp[bit][v][c]>=0.0)return dp[bit][v][c];\n\tdouble lost=0.0;\n\tint lbit=bit-(1<<c);\n\tif(dp2[lbit][v]>=0.0)lost=dp2[lbit][v];\n\telse{\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(lbit>>i & 1){\n\t\t\t\tlost=max(lost,memo(lbit,v,i));\n\t\t\t}\n\t\t}\n\t\tdp2[lbit][v]=lost;\n\t}\n\tdouble res=memo(bit,v+1,c)*data[c][v]+lost*(1.0-data[c][v]);\n\treturn dp[bit][v][c]=res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%lf\",&data[i][j]);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tdouble res=0.0;\n\tfor(int i=0;i<m;i++){\n\t\tres=max(res,memo((1<<m)-1,0,i));\n\t}\n\tprintf(\"%.10f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\ndouble dp[101010][20], a[20][20];\nint n, m;\ndouble rec(int mask, int x)\n{\n    if(dp[mask][x]!=0)\n        return dp[mask][x];\n    if(x==m)\n        return dp[mask][x] = 1;\n    if(mask==0)\n        return 0;\n    double ret = 0;\n    rep(i,n){\n        if(mask & 1<<i){\n            double res = 0,pos=1.0;\n            REP(j, x, m){\n                res += rec(mask ^ (1 << i), j) * pos * (1.0 - a[i][j]);\n                pos = pos * a[i][j];\n            }\n            res += pos;\n            ret = max(res, ret);\n        }\n    }\n    return dp[mask][x] = ret;\n}\nint main(){\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> a[i][j];\n    }\n    int all = 1 << n;\n    cout << setprecision(12) << rec(all - 1, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 2237\nint m,n;\ndouble wp[16][16];\n\n\n//k:倒された猫のリスト\n//depth:倒した敵の数\n//neko:使う猫\ndouble DFS(int k, int depth, int neko){\n\tint ix = 1;\n\tdouble ret=0.0;\n\tif(depth==n)return 1.0;\n\tif((k+1)==(1<<m))return 0.0;\n\tif(neko==-1){\n\t\tREP(i,m){\n\t\t\tif(!(k&ix)){\n\t\t\t\tret = max(ret, DFS(k,depth,i));\n\t\t\t}\n\t\t\tix<<=1;\n\t\t}\n\t}else{\n\t\tdouble tmp=0.0;\n\t\t//買った場合\n\t\ttmp += wp[neko][depth]*DFS(k,depth+1,neko);\n\t\t//負けた場合\n\t\ttmp += (1-wp[neko][depth])*DFS(k|(1<<neko),depth,-1);\n\t\tret=max(ret, tmp);\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcin>>m>>n;\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &wp[i][j]);\n\tprintf(\"%.11f\\n\", DFS(0, 0, -1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,N;\nvvd in,dp;\ndouble dfs(int a,int b){\n\tif(dp[a][b]+1)return dp[a][b];\n\tdouble out=0;\n\trep(i,n)if((a&1<<i)==0){\n\t\tdouble sum=0;\n\t\tdouble p=1;\n\t\tloop(j,b,m){\n\t\t\tsum+=p*(1-in[i][j])*dfs(a|1<<i,j);\n\t\t\tp*=in[i][j];\n\t\t}\n\t\tout=max(out,sum+p);\n\t}\n\t\n\treturn dp[a][b]=out;\n}\nint main(){\n\tcin>>n>>m;\n\tin=vvd(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\tN=1<<n;\n\tdp=vvd(N,vd(m,-1));\n\tcout<<shosu(11)<<dfs(0,0)<<endl;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble memo[1 << 16][17][2];\n\ndouble dfs(int nekos, int room, double q){\n\tif(memo[nekos][room][0] > q) return memo[nekos][room][1];\n\n\tdouble res = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\n\t\tdouble sum = 0;\n\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t}\n\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t//cout << bitset<2>(nekos) << ' '<<room << ' ' << sum << endl;\n\t\tres = max(res,sum);\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\tmemo[nekos][room][0] = q;\n\treturn memo[nekos][room][1] = res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t//rep(i,1 << 16) rep(j,17) dp[i][j] = -1;\n\tcout << fixed << setprecision(10) << dfs(0, 0, 1) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 16;\ndouble dp[N][1<<N];\ndouble nx[N][1<<N];\n\nint main(){\n    int m,n;\n    scanf(\" %d %d\", &m, &n);\n\n    double p[16][16]={};\n    rep(i,m)rep(j,n) scanf(\" %lf\", &p[i][j]);\n\n    fill(dp[0], dp[N], 1);\n    // i-th enemy\n    for(int i=n-1; i>=0; --i){\n        double max_p[1<<N];\n        rep(mask,1<<m){\n            rep(j,m)if(mask>>j&1){\n                double win = p[j][i];\n                int lmask = mask^(1<<j);\n                nx[j][mask] = win*dp[j][mask] + (1-win)*max_p[lmask];\n            }\n\n            max_p[mask] = 0;\n            rep(j,m)if(mask>>j&1) max_p[mask] = max(max_p[mask], nx[j][mask]);\n        }\n\n        rep(j,N)rep(k,1<<N) dp[j][k] = nx[j][k];\n    }\n\n    double ans = 0;\n    rep(i,m) ans = max(ans, dp[i][(1<<m)-1]);\n    printf(\"%.10f\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\nusing ld = long double;\ntemplate <typename T>\nvector<T> Vec(int n, T v)\n{\n    return vector<T>(n, v);\n}\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    auto p = Vec(M, N, static_cast<ld>(0.0));\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> p[i][j];\n        }\n    }\n    const int maximum = 1 << M;\n    auto dp = Vec(maximum, M, N + 1, static_cast<ld>(0.0));  // 残りネコ集合=i,戦闘ネコ=k,敵k-1まで倒した の状態から攻略する確率\n    auto sub = Vec(maximum, N + 1, static_cast<ld>(0.0));    // 残りネコ集合=i,敵j-1まで倒した の状態から攻略する確率の最大値\n    for (int i = 0; i < maximum; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j][N] = (i & (1 << j)) ? 1 : 0;\n        }\n    }\n\n    for (int k = N - 1; k >= 0; k--) {\n        for (int i = 0; i < maximum; i++) {\n            for (int j = 0; j < M; j++) {\n                if (i & (1 << j)) {\n                    dp[i][j][k] = p[j][k] * dp[i][j][k + 1] + (1 - p[j][k]) * sub[i - (1 << j)][k];\n                    sub[i][k] = max(sub[i][k], dp[i][j][k]);\n                }\n            }\n        }\n    }\n    cout << fixed << setprecision(15) << sub[maximum - 1][0] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[17][(1 << 16) + 1];\n\nld solve(int room, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][rest] >= 0) return dp[room][rest];\n\tld res = 0;\n\tREP(i, m)\n\t{\n\t\tif ((rest >> i) & 1) continue;\n\t\tld exp = 1.0; ld tres = 0;\n\t\tFOR(j, room, n)\n\t\t{\n\t\t\tld win = rate[i][j];\n\t\t\ttres += exp * (1.0 - win) * solve(j, rest | (1 << i));\n\t\t\texp *= win;\n\t\t}\n\t\ttres += exp;\n\t\tchmax(res, tres);\n\t}\n\treturn dp[room][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 17)REP(j, (1 << 16)+1) dp[i][j] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tcout << D10 << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define N 17\nusing namespace std;\ndouble x[N][N],d[(1<<N)][N],com[N];\nint m,n;\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>x[i][j];\n  d[0][0]=1;\n  double ans=0;\n  for(int i=0;i<(1<<m);i++){\n    for(int j=0;j<m;j++){\n      if(i&(1<<j))continue;\n      for(int k=0;k<=n;k++)\n\tcom[k]=d[i][k];\n      for(int k=0;k<n;k++){\n\tcom[k+1]+=com[k]*x[j][k];\n\tcom[k]*=(1-x[j][k]);\n      }\n      int f=0;\n      for(int k=n;k>=0;k--){\n\tif(EPS<com[k]-d[i|(1<<j)][k])f=1;\n\tif(EPS<d[i|(1<<j)][k]-com[k])break;\n      }\n      for(int k=0;f&&k<=n;k++)\n\td[i|(1<<j)][k]=com[k];\n    }\n    ans=max(ans,d[i][n]);\n  }\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  double dp[1<<n][m], prob[n][m];\n  for(int i = 0; i < (1<<n); ++i){\n    fill(dp[i],dp[i]+m,0);\n  }\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  \n  for(int bit = 0; bit < (1<<n); ++bit){\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(bit>>j & 1){\n\t  double t = 0, p = 1.0;\n\t  for(int k = i; k < m; ++k){\n\t    t += p*(1.0 - prob[j][k])*dp[bit-(1<<j)][k];\n\t    p *= prob[j][k];\n\t  }\n\t  t += p;\n\t  dp[bit][i] = max(dp[bit][i],t);\n\t}\n      }\n    }\n  }\n\n  double ans = dp[(1<<n)-1][0];\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint m, n;\ndouble mat[18][18];\nbool visited[(1<<16)][16][16];\ndouble memo[(1<<16)][16][16];\n\ndouble dfs(int used, int pos, int stage){\n    if(stage == n) return 1;\n    if(pos == m) return 0;\n    if(visited[used][pos][stage]) return memo[used][pos][stage];\n    double ret = 0;\n    for(int i=0;i<m;i++){\n        if((used>>i)&1) continue;\n        double path = 1;\n        double suc = 0;\n        int nused = used | (1 << i);\n        for(int j=stage;j<n;j++){\n            suc += path * (1 - mat[i][j]) * dfs(nused, pos+1, j);\n            path *= mat[i][j];\n        }\n        suc += path;\n        ret = max(ret, suc);\n    }\n    visited[used][pos][stage] = true;\n    memo[used][pos][stage] = ret;\n    return ret;\n}\n\nint main(){\n    cin >> m >> n;\n\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> mat[i][j];\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    printf(\"%.10f\\n\", dfs(0, 0, 0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\ndouble DP[17][(1 << 16)];\n\nint main(){\n\t\n\tint m, n;\n\tcin >> m >> n;\n\t\n\tdouble cost[17][17];\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> cost[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j = 0; j < (1 << m); j++){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tDP[i][j] = 0;\n\t\t}\n\t\tDP[n][j] = 1;\n\t}\n\t\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tfor(int j = 0; j < (1 << m); j++){\n\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\tif(j & (1 << k)){\n\t\t\t\t\tdouble P = 1;\n\t\t\t\t\tdouble S = 0;\n\t\t\t\t\tfor(int l = i; l < n; l++){\n\t\t\t\t\t\tS += P * (1 - cost[k][l]) * DP[l][j - (1 << k)];\n\t\t\t\t\t\tP *= cost[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tS += P;\n\t\t\t\t\tDP[i][j] = max(DP[i][j], S);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%.12f\\n\", DP[0][(1 << m) - 1]);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint m,n;\ndouble dp[17][(1<<16) + 1];\ndouble prob[17][17];\n\ndouble calc(int f, int s) {\n\n    if (f == n)   return 1.0;\n    if (dp[f][s]) return dp[f][s];\n\n    double ret = 0;\n    for (int k=0; k<m; ++k) if (!(s & (1<<k))) { // ???????????????????????????\n        double cp = 1.0;\n        double sum = 0;\n        for (int j=f; j<n && cp > 0.0; ++j) { // ?????????????????¢\n            sum += calc(j, s|(1<<k)) * cp * (1.0 - prob[k][j]);\n            cp *= prob[k][j];\n        }\n        // ???????????§???????¶????????¢????(????????§?¢????0????????£?????????????????§??§??????\n        sum += cp;\n        ret = max(ret, sum);\n    }\n    //printf(\"f:%d\\ts:%d\\tp:%f\\tret:%f\\n\",f,s,p,ret);\n    return dp[f][s] = ret;\n}\n\nint main() {\n    cin >> m >> n;\n    for (int i=0; i<m; ++i) {\n        for (int j=0; j<n; ++j) {\n            cin >> prob[i][j];\n        }\n    }\n\n    printf(\"%.12f\\n\", calc(0, 0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic bool used[20];\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tcerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tdump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused[i] = false;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(20);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\nusing namespace std;\n\n double dp[17][1<<16]={};\n   \nint main(){\n    int n,m;\n    cin >> m >>n;\n    vector<vector<double > > p(m+1,vector<double>(n+1));\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> p[i][j];\n        }\n    }\n    double s[17][17][17]={};\n    for(int i=0;i<m;i++){\n        for(int j=0;j<=n;j++){\n            for(int k=j;k<=n;k++){\n                double tmp = 1.0;\n                for(int x = j;x<k;x++){\n                    tmp *= p[i][x];\n                }\n                if(k!=n)tmp *= 1.0-p[i][k];\n                s[i][j][k] = tmp;\n                //cout << i << \" \" << j << \" \" << k << \" \" << tmp << endl;\n            }\n        }\n    }\n    for(int i=0;i<(1<<m);i++){\n        dp[n][i] = 1.0;\n    }\n    for(int i=(1<<m)-1;i>=0;i--){\n        for(int j=n;j>=0;j--){\n            for(int k=0;k<m;k++){\n                if((i>>k&1)==0){\n                    double tmp = 0.0;\n                    for(int z=n;z>=j;z--){\n                        tmp += dp[z][i+(1<<k)]*s[k][j][z];\n                    }\n                    //cout << j << \" \" << i << \" \" <<  tmp << endl;\n                    dp[j][i] = max(dp[j][i],tmp);\n\n                }\n            }\n        }\n    }\n    cout <<fixed << setprecision(15) <<  dp[0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ndouble dp[20][1<<16];\ndouble c[20][20];\nint m,n;\ndouble solve(int a,int b){\n\tif(dp[a][b]>-0.5)return dp[a][b];\n\tif(a==n)return 1;\n\tif(b==0)return 0;\n\tdouble ret=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(b&(1<<i)){\n\t\t\tret=max(ret,c[i][a]*solve(a+1,b)+(1.0-c[i][a])*solve(a,b-(1<<i)));\n\t\t}\n\t}\n\treturn dp[a][b]=ret;\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tm=a;n=b;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%lf\",&c[i][j]);\n\tfor(int i=0;i<=b;i++)for(int j=0;j<(1<<a);j++)dp[i][j]=-1;\n\tprintf(\"%.12f\\n\",solve(0,(1<<a)-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\nfloat dp[65536][16][16];\nfloat table[16][16];\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%f\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tfor(int i = 0; i < limit; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = -1.0;\n\t\t}\n\t}\n\n\tint next_cat[M]; //?¬???????????????????????£?\n\tint next_num,next_state;\n\n\tfloat maximum;\n\n\t//?????????????????????????¢???????????????????????¨????????????????\n\tfor(int state = 0; state < limit; state++){\n\n\t\tnext_num = 0;\n\t\t//?¬????????????????????????????????¨????????????????\n\t\tfor(int cat = 0; cat < M; cat++){ //???????????????\n\t\t\tif(state & (1 << cat)){ //???????????£???????????´???\n\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t}\n\t\t}\n\n\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\tif(state & (1 << cat)){\n\n\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\tif(next_state == 0){ //??????????????§????????´???\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1];\n\t\t\t\t}else{ //?????????????????????????????´???\n\n\t\t\t\t\t//?¬??????????????????¢???\n\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\tif(dp[next_state][N-1][next_cat[i]] > maximum){\n\t\t\t\t\t\t\tmaximum = dp[next_state][N-1][next_cat[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1] + (1.0-table[cat][N-1])*maximum; //????????????????¢????+????????????????????????????°?????????¨???1?????????????????????????¢????\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int enemy = N-2; enemy >= 0; enemy--){\n\t\tfor(int state = 0; state < limit;state++){\n\n\t\t\tnext_num = 0;\n\t\t\t//?¬????????????????????????????????¨????????????????\n\t\t\tfor(int cat = 0; cat < M; cat++){ //???????????????\n\t\t\t\tif(state & (1 << cat)){ //???????????£???????????´???\n\t\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\t\tif(state & (1 << cat)){\n\n\t\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\t\tif(next_state == 0){ //??????????????§????????´???\n\t\t\t\t\t\tdp[state][enemy][cat] = max(dp[state][enemy][cat],dp[state][enemy+1][cat]*table[cat][enemy]);\n\t\t\t\t\t}else{ //?????????????????????????????´???\n\n\t\t\t\t\t\t//?¬??????????????????¢???\n\t\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\t\tif(dp[next_state][enemy][next_cat[i]] > maximum){\n\t\t\t\t\t\t\t\tmaximum = dp[next_state][enemy][next_cat[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(dp[state][enemy][cat] < table[cat][enemy]*dp[state][enemy+1][cat]+(1.0-table[cat][enemy])*maximum){\n\t\t\t\t\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dp[state][enemy+1][cat]+(1.0-table[cat][enemy])*maximum;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat ans = 0.0;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(ans < dp[limit-1][0][i]){\n\t\t\tans = dp[limit-1][0][i];\n\t\t}\n\t}\n\n\tprintf(\"%.6f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nclass HashVI {  // ???????????\\??¢??°???????????§??????\npublic:\n\tsize_t operator()(pair<int,vector<int>> x) const {\n\t\tsize_t t = x.first;\n\t\tt *= 16;\n\t\t\n\t\tfor (int i = 0; i < x.second.size(); ++i) {\n\t\t\tt += x.second[i];\n\t\t\tt *= 2;\n\t\t}\n\t\treturn t;\n\t\t\n\t}\n\tsize_t operator()(const vector<vector<int>> &x) const {\n\t\tconst int C = 997;      // ?´???°\n\t\tsize_t t = 0;\n\t\tfor (int i = 0; i != x.size(); ++i) {\n\t\t\tfor (int j = 0; j < x[i].size(); ++j) {\n\t\t\t\tt = t * C + x[i][j];\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n};\nvector<vector<ld>>pers;\nunordered_map<pair<int,vector<int>>, ld, HashVI>memo;\nint M, N;\nld check(const int now,vector<int>&lives) {\n\tif (memo.find(make_pair(now, lives))!=memo.end()) {\n\t\treturn memo[make_pair(now, lives)];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < lives.size(); ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[make_pair(now, lives)]=amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tld ans = check(0, vector<int>(M, 1));\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef float real;\n\nreal dp[17][17][1 << 16];\nint n, m;\nreal p[17][17];\nreal solve(int stage, int now, int cats){\n\treal &res = dp[stage][now][cats];\n\tif(res != -1)return res;\n\tres = 0;\n\tif((1<<now) & cats)return res;\n\tif(stage == n)return res = 1;\n\t\n\tif(now == 16){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tres = max(res, solve(stage, i, cats));\n\t\t}\n\t}\n\telse{\n\t\tres = solve(stage+1, now, cats) * p[now][stage]\n\t\t\t+ solve(stage, 16, cats | (1<<now)) * (1 - p[now][stage]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < 17;i++)\n\t\tfor(int j = 0;j < 17;j++)\n\t\t\tfor(int k = 0;k < (1<<m);k++)\n\t\t\t\tdp[i][j][k] = -1;\n\n\tprintf(\"%.10lf\\n\", solve(0, 16, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m;\ndouble dp[1<<16][16];\ndouble data[17][17];\n\ndouble memo(int bit,int v){\n\tif(v==n)return 1.0;\n\tif(bit==0)return 0.0;\n\tif(dp[bit][v]>=0.0)return dp[bit][v];\n\tdouble res=0.0;\n\tfor(int i=0;i<m;i++){\n\t\tif(!(bit>>i & 1))continue;\n\t\tdouble lost=0.0;\n\t\tint lbit=bit-(1<<i);\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(lbit>>j & 1){\n\t\t\t\tlost=max(lost,memo(lbit,v));\n\t\t\t}\n\t\t}\n\t\tres=max(res,memo(bit,v+1)*data[i][v]+lost*(1.0-data[i][v]));\n\t}\n\treturn dp[bit][v]=res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%lf\",&data[i][j]);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdouble res=0.0;\n\tprintf(\"%.10f\\n\",memo((1<<m)-1,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20];\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) % 2 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\treturn maxn;\n}\nint main() {\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 16\n#define MAX_M 16\n\nint M, N;\ndouble P[MAX_M][MAX_N];\ndouble dp[MAX_N][1<<MAX_M];\n\ndouble solve(int n, int m)\n{   \n    double &res = dp[n][m];\n    \n    if (res != -1) {\n        return res;\n    }\n    res = 0;\n\n    for (int i = 0; i < M; i++) {\n        if (!(m >> i & 1)) continue;\n        double p = 1.0, q = 0.0;\n        for (int j = n; j < N; j++) { \n            q += p * (1 - P[i][j]) * solve(j, m & ~(1<<i));\n            p *= P[i][j];\n        }\n        q += p;\n        res = max(res, q);\n    }    \n    return res;\n}\n\nint main()\n{\n    cin >> M >> N;\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> P[i][j];\n        }\n    }\n    fill(dp[0], dp[MAX_N], -1);\n    printf(\"%.10f\\n\", solve(0, (1<<M)-1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ndouble dp[1<<16][17];\ndouble prob[16][16];\nint n, m;\n\ndouble solve(int bit, int k, double p){\n  if(bit == 0){\n    cout << bit << \" \" << k << \" \" << p << \" \" << 0 << endl;\n    return 0;\n  }\n  if(k == m){\n    dp[bit][k] = max(dp[bit][k],p);\n    cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n    return dp[bit][k];\n  }\n  double ret = 0.0;\n  for(int i = 0; i < n; ++i){\n    if((bit >> i) & 1){\n      double t = p, s = 0.0;\n      for(int j = k; j < m; ++j){\n\ts += solve(bit - (1<<i), j, t*(1.0-prob[i][j]));\n\tt *= prob[i][j];\n      }\n      s += solve(bit, m, t);\n      ret = max(ret,s);\n    }\n  }\n  dp[bit][k] = max(dp[bit][k], ret);\n  //cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n  return dp[bit][k];\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  double ans = solve((1<<n)-1,0,1);\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20], dp[20][100000];\ninline long double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tif (dp[pos][ret] >= -0.1l)return dp[pos][ret];\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) & 1 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\tdp[pos][ret] = maxn;\n\treturn maxn;\n}\nint main() {\n\tfor (int i = 0; i < 20; i++) { for (int j = 0; j < 100000; j++)dp[i][j] = -1.0l; }\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\ndouble p[20][20];\ndouble dp[20][1<<16];\n\nint main(void){\n\tcin >> m >> n;\n\trep(i,m)rep(j,n) cin >> p[j][i];\n\trep(mask,1<<m) dp[n][mask]=1.0;\n\n\tfor(int i=n-1;i>=0;--i){\n\t\tfor(int mask=(1<<m)-1;mask>=0;--mask){\n\t\t\trep(j,m){\n\t\t\t\tif(mask&(1<<j)) continue;\n\t\t\t\tdouble cur=1.0,res=0.0;\n\t\t\t\tint nmask=mask|(1<<j);\n\t\t\t\trange(ni,i,n){\n\t\t\t\t\tdouble pp=cur*(1.0-p[ni][j]);\n\t\t\t\t\tres+=pp*dp[ni][nmask];\n\t\t\t\t\tcur*=p[ni][j];\n\t\t\t\t}\n\t\t\t\tres+=cur;\n\t\t\t\tdp[i][mask]=max(dp[i][mask],res);\n\t\t\t}\n\t\t}\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[0][0]  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int m,n;\n  cin>>m>>n;\n  double p[m][n+1];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) cin>>p[i][j];\n  for(int i=0;i<m;i++) p[i][n]=0.0;\n  double dp[n+1][1<<m];\n  for(int i=0;i<(1<<m);i++)\n    for(int j=0;j<=n;j++) dp[j][i]=0;\n  dp[0][0]=1.0;\n  for(int i=0;i<(1<<m);i++){\n    for(int k=0;k<m;k++){\n      if((i>>k)&1) continue;\n      for(int j=0;j<=n;j++){\n\tdouble tmp=dp[j][i];\n\tfor(int l=j;l<=n;l++){\n\t  //dp[l][i+(1<<k)]=max(dp[l][i+(1<<k)],tmp*(1.0-p[k][l]));\n\t  dp[l][i+(1<<k)]+=tmp*(1.0-p[k][l]); \n\t  tmp*=p[k][l];\n\t}\n\tdp[j][i]=0;\n      }\n    }\n  }\n  /*//\n  for(int i=0;i<(1<<m);i++){\n    printf(\"%.12f\\n\",dp[n][i]);\n    double s=0;\n    for(int j=0;j<=n;j++) s+=dp[j][i];\n    cout<<s<<endl;\n  }\n  //*/\n  printf(\"%.12f\\n\",dp[n][(1<<m)-1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble*** dp;\ndouble table[16][16];\n\ndouble dfs(int state,int enemy,int cat){\n\n\tif(dp[state][enemy][cat] != 0.0)return dp[state][enemy][cat];\n\n\tint next_state = state - POW[cat];\n\n\tint next_cat = BIG_NUM;\n\n\tdouble maximum = 0.0,tmp;\n\n\tif(next_state != 0){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i == cat)continue;\n\t\t\tif(state & (1 << i)){\n\t\t\t\ttmp = dfs(next_state,enemy,i);\n\t\t\t\tif(tmp > maximum){\n\t\t\t\t\tmaximum = tmp;\n\t\t\t\t\tnext_cat = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(enemy == N-1){\n\t\t\tdp[state][enemy][cat] = table[cat][enemy] +\n\t\t\t\t\t(1.0-table[cat][enemy])*dfs(next_state,enemy,next_cat);\n\t\t}else{\n\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat) +\n\t\t\t\t(1.0-table[cat][enemy])*dfs(next_state,enemy,next_cat);\n\t\t}\n\n\t}else{\n\n\t\tif(enemy == N-1){\n\t\t\tdp[state][enemy][cat] = table[cat][enemy];\n\t\t}else{\n\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat);\n\t\t}\n\t}\n\n\treturn dp[state][enemy][cat];\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tdp = new double**[limit];\n\tfor(int i = 0; i < limit; i++){\n\t\tdp[i] = new double*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new double[M];\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = 0.0;\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\n\tfor(int cat = 0; cat < M; cat++){\n\t\tans = max(ans,dfs(limit-1,0,cat));\n\t}\n\n\tprintf(\"%.12lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[17][17];\ndouble dp[17][1<<16];\nint n,m;\n\ndouble DFS(int idx, int state){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][state] >= -0.1)return dp[idx][state];\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tdouble ret1=0.0;\n\t\tdouble tmp =1.0;\n\t\tFOR(j, idx, n){\n\t\t\tret1 += tmp*(1-p[i][j])*DFS(j, (state|mask));\n\t\t\ttmp *= p[i][j];\n\t\t}\n\t\tret1+=tmp;\n\t\tret = max(ret, ret1);\n\t}\n\treturn dp[idx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,(1<<m))dp[i][j]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\n\nld memo[1 << 16][16];\nint M, N;\nld getans(const vector<vector<ld>>&ps,bitset<16>bs, const int now) {\n\tif (now == N)return 1;\n\tif (memo[bs.to_ulong()][now] > -0.5)return memo[bs.to_ulong()][now];\n\tld ans = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (bs[i]) {\n\t\t\tbs[i] = false;\n\t\t\tld live = 1;\n\t\t\tld nans = 0;\n\t\t\tfor (int op = now; op < N; ++op) {\n\n\t\t\t\tld death = live*(1 - ps[i][op]);\n\t\t\t\tnans += death*getans(ps, bs, op);\n\t\t\t\tlive -= death;\n\t\t\t}\n\t\t\tnans += live;\n\t\t\tans = max(ans, nans);\n\t\t\tbs[i] = true;\n\t\t}\n\t}\n\treturn memo[bs.to_ulong()][now] = ans;\n}\nint main() {\n\tfor (int i = 0; i < 1 << 16; ++i) {\n\t\tfor (int j = 0; j < 16; ++j) {\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\tcin >> M >> N;\n\n\tvector<vector<ld>>ps(M, vector<ld>(N));\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tld p; cin >> ps[i][j];\n\t\t}\n\t}\n\tld ans = getans(ps, bitset<16>((1 << (M)) - 1), 0);\n\tcout << setprecision(22)<<fixed<<ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble*** dp;\ndouble table[16][16];\n\ndouble dfs(int state,int enemy,int cat){\n\n\tif(dp[state][enemy][cat] != -1.0)return dp[state][enemy][cat];\n\n\tint next_state = state - POW[cat];\n\n\tint next_cat = BIG_NUM;\n\n\tdouble maximum = 0.0,tmp;\n\n\tif(next_state != 0){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i == cat)continue;\n\t\t\tif(state & (1 << i)){\n\t\t\t\ttmp = dfs(next_state,enemy,i);\n\t\t\t\tif(tmp > maximum){\n\t\t\t\t\tmaximum = tmp;\n\t\t\t\t\tnext_cat = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(enemy == N-1){\n\t\t\tif(next_cat != BIG_NUM){\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy] +\n\t\t\t\t\t(1.0-table[cat][enemy])*maximum;\n\t\t\t}else{\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy];\n\t\t\t}\n\t\t}else{\n\t\t\tif(next_cat != BIG_NUM){\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat) +\n\t\t\t\t(1.0-table[cat][enemy])*maximum;\n\t\t\t}else{\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat);\n\t\t\t}\n\t\t}\n\n\t}else{\n\n\t\tif(enemy == N-1){\n\t\t\tdp[state][enemy][cat] = table[cat][enemy];\n\t\t}else{\n\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat);\n\t\t}\n\t}\n\n\treturn dp[state][enemy][cat];\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tdp = new double**[limit];\n\tfor(int i = 0; i < limit; i++){\n\t\tdp[i] = new double*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new double[M];\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = -1.0;\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\n\tfor(int cat = 0; cat < M; cat++){\n\t\tans = max(ans,dfs(limit-1,0,cat));\n\t}\n\n\tprintf(\"%.12lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nstd::map<std::pair<char,char>, double> mo;\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00000;\n\tif(room == 15 and mo.count(std::make_pair(nekos, neko))) return mo[std::make_pair(nekos, neko)];\n\tif(room != 15 and memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return mo[std::make_pair(nekos, neko)] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\ndouble data[16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int s){\n  if(d == n) return 1.0;\n  if(s == (1<<m)) return 0.0;\n  if(data[d][s] != -1) return data[d][s];\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    double np = 1.0, sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, s|(1<<i)) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np * func(n, s|(1<<i));\n    res = max(res, sum);\n  }\n  return data[d][s] = res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  //cout << func(0, 0) << endl;\n  printf(\"%.15f\\n\", func(0, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std; \nconst int INF = 1e9;\n\nint n,m;\ndouble P[16][16];\ndouble dp[1<<16][17];\n\nint main(){\n    cin >> m >> n;\n    rep(i,m)rep(j,n) cin >> P[i][j];\n    rep(S,1<<m)rep(i,n+1) dp[S][n] = (S > 0 && i == n) ? 1 : 0;\n \n    for(int u = n-1; u >= 0; --u){\n        rep(S,1<<m){\n            rep(i,m){\n                if(S>>i&1){\n                    double p = 1, q = 0;\n                    for(int v = u; v < n; ++v){\n                        q += dp[S^(1<<i)][v] * p * (1-P[i][v]);\n                        p *= P[i][v];\n                    }\n                    q += dp[S][n] * p;\n                    dp[S][u] = max(dp[S][u], q);\n                }\n            }\n        }\n    }\n    double ans = dp[(1<<m)-1][0];\n    cout << fixed << setprecision(20) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\ndouble dp[101010][20], a[20][20];\nint n, m;\ndouble rec(int mask, int x)\n{\n    if(dp[mask][x]!=0)\n        return dp[mask][x];\n    if(x==m)\n        return dp[mask][x] = 1;\n    if(mask==0)\n        return 0;\n    double ret = 0;\n    rep(i,n){\n        if(mask & 1<<i){\n            double res = 0,pos=1.0;\n            REP(j, x, m){\n                res += rec(mask ^ (1 << i), j) * pos * (1.0 - a[i][j]);\n                pos = pos * a[i][j];\n            }\n            res += pos;\n            ret = max(res, ret);\n        }\n    }\n    return dp[mask][x] = ret;\n}\nint main(){\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> a[i][j];\n    }\n    int all = 1 << n;\n    cout << setprecision(12) << rec(all - 1, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n#define all(n) n.begin(),n.end()\n#define clr(n) memset(n,0,sizeof(n))\n#define mclr(n) memset(n,-1,sizeof(n))\n\n//dp[bit][i][j] ?´???£??????????????????bit???i???????????¨?±????j?????????????????????\n//??¨??¨????????????????¢????\ndouble dp[1 << 16][16];\n\n//ap[i][j][k] ???i ?????¨?±?j????????¨?±?k?????????????¢????\ndouble ap[16][16][17];\ndouble a[16][17];\n\nint main() {\n\tint n, m;\n\tcin >> m >> n;\n\tclr(dp);\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\ta[i][n] = 0.0;\n\t}\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\trep(k, n + 1) {\n\t\t\t\tap[i][j][k] = 1.0;\n\t\t\t\tfor (int l = j; l < k; l++) {\n\t\t\t\t\tap[i][j][k] *= a[i][l];\n\t\t\t\t}\n\t\t\t\tap[i][j][k] *= (1.0 - a[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfunction<double(int, int)> solve = [&](int bit, int i) {\n\t\tif (i == n)return 1.0;\n\t\tif (dp[bit][i]) {\n\t\t\treturn dp[bit][i];\n\t\t}\n\t\tdouble re = 0.0;\n\t\trep(k, m) if(!(bit & (1 << k))) {\n\t\t\tdouble p = 0.0;\n\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\tp += solve(bit | (1 << k), l) * ap[k][i][l];\n\t\t\t}\n\t\t\tre = max(re, p);\n\t\t}\n\t\treturn dp[bit][i] = re;\n\t};\n\tcout << fixed << setprecision(30) << solve(0, 0) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint m, n;\ndouble p[16][16], dp[2][1 << 16][16];\n\nconst double EPS = 1e-9;\n\nint main() {\n\tcin >> m >> n;\n\tfor_(i,0,m) for_(j,0,n) cin >> p[i][j];\n\t\t\n\tfor_(i,0,m) dp[0][1 << i][i] = 1.0;\n\t\n\tfor_(i,0,n) {\n\t\tint ci = i & 1, ni = 1 - ci;\n\t\t\n\t\tmemset(dp[ni], 0, sizeof(dp[ni]));\n\t\t\n\t\tfor_(S,0,(1<<m)+1) for_(j,0,m) {\n\t\t\tif (dp[ci][S][j] < EPS) continue;\n\t\t\tif (!(S >> j & 1)) continue;\n\t\t\t\n\t\t\tdp[ni][S][j] += dp[ci][S][j] * p[j][i];\n\t\t\t\n\t\t\tfor_(k,0,m) {\n\t\t\t\tif (S >> k & 1) continue;\n\t\t\t\tdp[ci][S | 1 << k][k] += dp[ci][S][j] * (1.0 - p[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 0.0;\n\tfor_(S,0,(1<<m)) for_(i,0,m) ans = max(ans, dp[n & 1][S][i]);\n\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll m, n; cin >> m >> n;\n\tvector<vector<double>> p(m, vector<double>(n));\n\tREP(i, m) REP(j, n) cin >> p[i][j];\n\n\t// dp[?????????????????° % 2][????´???£???????????????][????????????] = ??????\n\tvector<vvd> dp(2, vvd(m, vd(1ll << m, 0)));\n\t// win_max_p[??????????????????????????????????????°][????????§?????? | ????????????] = ????????????????´???£??????????????????\n\tvvd win_max_p(n, vd(1ll << m, 0));\n\tREP(i, 1ll << m) REP(j, m) dp[n % 2][j][i & ~(1ll << j)] = 1;\n\n\tfor (ll i = n - 1; i >= 0; --i) for (ll j = (1ll << m) - 1; j >= 0; --j) {\n\t\tREP(k, m) if ((j & (1ll << k)) == 0) {\n\t\t\tdp[i % 2][k][j] =\n\t\t\t\twin_max_p[i][j | (1ll << k)] * (1 - p[k][i])\n\t\t\t\t+ dp[(i + 1) % 2][k][j] * p[k][i];\n\t\t\twin_max_p[i][j] = max(win_max_p[i][j], dp[i % 2][k][j]);\n\t\t}\n\t}\n\tcout << win_max_p[0][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic int used;\n\tmap<pair<int,int>, double> dp;\n\tmap<pair<int,int>, bool> done;\n\tpair<int,int> cur_status = {used, reached};\n\n\tif (done[cur_status] == true) {\n\t\treturn dp[cur_status];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif ((used >> i) & 1) continue;\n\t\tused |= 1 << i;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused ^= 1 << i;\n\t}\n\tdone[cur_status] = true;\n\treturn dp[cur_status] = res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\nusing ld = double;\ntemplate <typename T>\nvector<T> Vec(int n, T v)\n{\n    return vector<T>(n, v);\n}\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    auto p = Vec(M, N, static_cast<ld>(0.0));\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> p[i][j];\n        }\n    }\n    const int maximum = 1 << M;\n    auto dp = Vec(maximum, M, N + 1, static_cast<ld>(0.0));  // 残りネコ集合=i,戦闘ネコ=k,敵k-1まで倒した の状態から攻略する確率\n    auto sub = Vec(maximum, N + 1, static_cast<ld>(0.0));    // 残りネコ集合=i,敵j-1まで倒した の状態から攻略する確率の最大値\n    for (int i = 0; i < maximum; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j][N] = (i & (1 << j)) ? 1 : 0;\n        }\n    }\n\n    for (int k = N - 1; k >= 0; k--) {\n        for (int i = 0; i < maximum; i++) {\n            for (int j = 0; j < M; j++) {\n                if (i & (1 << j)) {\n                    dp[i][j][k] = p[j][k] * dp[i][j][k + 1] + (1 - p[j][k]) * sub[i - (1 << j)][k];\n                    sub[i][k] = max(sub[i][k], dp[i][j][k]);\n                }\n            }\n        }\n    }\n    cout << fixed << setprecision(15) << sub[maximum - 1][0] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble dp[65536][16][16];\ndouble table[16][16];\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tfor(int i = 0; i < limit; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = -1.0;\n\t\t}\n\t}\n\n\tint next_cat[M];\n\tint next_num,next_state;\n\n\tdouble maximum;\n\n\tfor(int state = 0; state < limit; state++){\n\n\t\tnext_num = 0;\n\n\t\tfor(int cat = 0; cat < M; cat++){\n\t\t\tif(state & (1 << cat)){\n\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t}\n\t\t}\n\n\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\tif(state & (1 << cat)){\n\n\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\tif(next_state == 0){\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1];\n\t\t\t\t}else{\n\n\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\tif(dp[next_state][N-1][next_cat[i]] > maximum){\n\t\t\t\t\t\t\tmaximum = dp[next_state][N-1][next_cat[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1] + (1.0-table[cat][N-1])*maximum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int enemy = N-2; enemy >= 0; enemy--){\n\t\tfor(int state = 0; state < limit;state++){\n\n\t\t\tnext_num = 0;\n\n\t\t\tfor(int cat = 0; cat < M; cat++){\n\t\t\t\tif(state & (1 << cat)){\n\t\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\t\tif(state & (1 << cat)){\n\n\t\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\t\tif(next_state == 0){\n\t\t\t\t\t\tdp[state][enemy][cat] = max(dp[state][enemy][cat],dp[state][enemy+1][cat]*table[cat][enemy]);\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\t\tif(dp[next_state][enemy][next_cat[i]] > maximum){\n\t\t\t\t\t\t\t\tmaximum = dp[next_state][enemy][next_cat[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdp[state][enemy][cat] = max(dp[state][enemy][cat],table[cat][enemy]*dp[state][enemy+1][cat]+(1.0-table[cat][enemy])*maximum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0.0;\n\n\tfor(int i = 0; i < M; i++)ans = max(ans,dp[limit-1][0][i]);\n\n\tprintf(\"%.12lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static int used[N][1<<N]={};\n  static double mem[N][1<<N];\n  if(used[pos][bit]++) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\nmap<int,double> mem[N][1<<N];\nint used[N][N][1<<N];\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(mem[pos][bit].count(k)) return mem[pos][bit][k];\n  double p = neko[k][pos];\n  return mem[pos][bit][k] = p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstring>\nusing namespace std;\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } else return false; }\n\nint m, stage;\nvector<vector<double> > p;\n\ndouble dp[(1<<16)+10][20]; // remained member, #. of remained stages\ndouble rec(int bit, int rem) {\n    if (dp[bit][rem] >= -1e-10) return dp[bit][rem];\n    if (rem == 0) return 1.0;\n    \n    double res = 0.0;\n    int start = stage - rem;\n    for (int i = 0; i < m; ++i) {\n        if (!(bit & (1<<i))) continue;\n        int nbit = bit & ~(1<<i);\n        double tmp = 0.0;\n        double prob = 1.0;\n        for (int lose = start; lose < stage; ++lose) {\n            double loseprob = prob * (1.0 - p[i][lose]);\n            tmp += loseprob * rec(nbit, stage - lose);\n            prob *= p[i][lose];\n        }\n        tmp += prob * rec(nbit, 0);\n        chmax(res, tmp);\n    }\n    return dp[bit][rem] = res;\n}\n\nint main() {\n    while (cin >> m >> stage) {\n        p.assign(m, vector<double>(stage, 0.0));\n        for (int i = 0; i < m; ++i) for (int j = 0; j < stage; ++j) cin >> p[i][j];\n\n        memset(dp, -1, sizeof(dp));\n        cout << fixed << setprecision(10) << rec((1<<m)-1, stage) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble dp[1 << 16][17];\ndouble ans = 0;\n\ndouble dfs(int nekos, int room, double q){\n\tif(dp[nekos][room] != -1) return dp[nekos][room];\n\n\tdouble res = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\n\t\tdouble sum = 0;\n\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t}\n\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t//cout << bitset<2>(nekos) << ' '<<room << ' ' << sum << endl;\n\t\tres = max(res,sum);\n\t}\n\n\t//cout << \"res  \" << bitset<2>(nekos) << ' ' << room << ' ' << res << endl;\n\treturn dp[nekos][room] = res;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\t//show(neko[i][j][j])\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t\t//cout << neko[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,17) dp[i][j] = -1;\n\tcout <<fixed << setprecision(10) <<  dfs(0, 0, 1) << endl;\n\treturn 0;\n\tshow(ans)\n\trep(i,1 << n){ rep(j,m){ cout << bitset<2>(i) << ' ' << j <<  ' '; cout << dp[i][j] << endl; } }\n\n\trep(i,1 << 16) rep(j,17) dp[i][j] = 0;\n\trep(s,1 << n){\n\t\trep(i,n){\n\t\t\tif(getBit(s,i)) continue;\n\n\t\t\trep(k,m){\n\t\t\t\tdp[setBit(s,i)][k] = max(dp[setBit(s,i)][k], 1.00 * neko[i][0][k]);\n\t\t\t}\n\n\t\t\trange(j,1,m){\n\t\t\t\trep(k,m){\n\t\t\t\t\tdp[setBit(s,i)][k] = max(dp[setBit(s,i)][k], dp[s][j - 1] * neko[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\trep(s,1 << n){\n\t\trep(i,n){\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(10) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int,int> PII;\n#define MP make_pair;\n\ndouble dp[1<<16][20];\n\nint main(){\n  int M, N; cin >> M >> N;\n  vector<vector<double>> prob(M, vector<double>(N, 0));\n  for(int i=0;i<M;++i)\n\tfor(int j=0;j<N;++j) cin >> prob[i][j];\n\n  fill((double*)dp, (double*)dp+(1<<16)*20, 0);\n  dp[0][0] = 1.;\n  for(int bit=0;bit<1<<M;++bit){\n\tfor(int i=0;i<N;++i){\n\t  for(int j=0;j<M;++j)\n\t\tif((bit>>j&1) == 0){\n\t\t  int nb = bit | (1<<j);\n\t\t  double p = dp[bit][i];\n\t\t  for(int k=i;k<N;++k){\n\t\t\tdp[nb][k] = max(dp[nb][k], p * (1. - prob[j][k]));\n\t\t\tp *= prob[j][k];\n\t\t  }\n\t\t  dp[nb][N] = max(dp[nb][N], p);\n\t\t}\n\t}\n  }\n  double ans = 0.;\n  for(int b=0;b<1<<M;++b) ans += dp[b][N];\n  cout << fixed << setprecision(9) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[17][17][1<<16];\nint n,m;\n\ndouble DFS(int idx, int state, int cidx){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][cidx][state] >= -0.1)return dp[idx][cidx][state];\n\tif(cidx!=17)return dp[idx][cidx][state] = p[cidx][idx]*DFS(idx+1, state, cidx)+(1-p[cidx][idx])*DFS(idx, (state|(1<<cidx)), 17);\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state, i)+(1-p[i][idx])*DFS(idx, (state|mask), 17));\n\t}\n\treturn dp[idx][cidx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,17)REP(k,(1<<m))dp[i][j][k]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0,17));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nfloat memof[1 << 16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(room == 15 and memof[nekos][neko] != -1) return memof[nekos][neko];\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return memof[nekos][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\trep(i,1 << 16) rep(j,16) memof[i][j] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint N, M;\ndouble board[20][20], dp[20][1 << 16];\nvoid chmax(double &A, double B) { A = max(A, B); }\n\ndouble solve(int idx, int bit) {\n    if(dp[idx][bit] >= 0.0) return dp[idx][bit];\n\n    double ret = 0.0;\n    for(int i=0; i<N; i++) {\n        if(!(bit >> i & 1)) continue;\n        int nbit = bit ^ (1 << i);\n\n        double alive = 1.0, tmp = 0.0;\n        for(int k=idx; k<M; k++) {\n            double dead = alive * (1.0 - board[i][k]);\n            tmp += dead * solve(k, nbit);\n            alive *= board[i][k];\n        }\n        tmp += alive * solve(M, bit);\n\n        chmax(ret, tmp);\n    }\n    return dp[idx][bit] = ret;\n}\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<M; j++) {\n            scanf(\"%lf\", &board[i][j]);\n        }\n    }\n\n    fill(dp[0], dp[M], -1);\n    fill(dp[M], dp[M+1], 1);\n    printf(\"%.12f\\n\", solve( 0, (1<<N)-1 ));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\nlong double t[16][16];\nlong double mem[16][(1<<16)];\nbool visited[16][(1<<16)];\n\nlong double rec(int x,int S){\n  if(visited[x][S])return mem[x][S];\n  visited[x][S]=true;\n  long double res=0;\n  for(int i=0;i<m;i++){\n    if(S>>i&1)continue;\n    long double p=1.0,k=0;\n    for(int j=x;j<n;j++){      \n      k+=rec(j,S|(1<<i))*p*(1.0-t[i][j]);\n      p*=t[i][j];\n    }\n    res=max(res,k+p);\n  }\n  return mem[x][S]=res;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  printf(\"%.12f\\n\",(double)rec(0,0));  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20];\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) % 2 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\treturn maxn;\n}\nint main() {\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  vector<vector<double>> prob(M, vector<double>(N));\n  REP(i,M) REP(j,N) cin >> prob[i][j];\n  vector<vector<double>> dp(1<<M, vector<double>(N+1, 0.));\n  dp[0][0] = 1.;\n\n  double ans = 0.;\n  REP(b,1<<M){\n\tREP(bi,M){\n\t  if((b>>bi&1) == 1) continue;\n\t  int nxt = b | (1<<bi);\n\t  double sum = 0.;\n\t  REP(i,N){\n\t\tdouble p = dp[b][i];\n\t\tfor(int j=i;j<N;++j){\n\t\t  dp[nxt][j] = max(dp[nxt][j], p * (1. - prob[bi][j]));\n\t\t  p *= prob[bi][j];\n\t\t}\n\t\tsum += p;\n\t\tdp[nxt][N] = max(dp[nxt][N], p);\n\t  }\n\t  sum += dp[b][N];\n\t  ans = max(ans, sum);\n\t}\n  }\n  /*\n  REP(b,1<<M){\n\tcout << b << \" : \";\n\tREP(i,N+1) cout << dp[b][i] << \" \";\n\tcout << endl;\n  }\n  */\n  cout << fixed << setprecision(10) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n, neko[20][20][20], dp[20][100000];\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tif (dp[pos][ret] >= -0.1l)return dp[pos][ret];\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) % 2 == 1)continue;\n\t\tlong double cnt = 0.0;\n\t\tfor (int j = pos; j <= n; j++) {\n\t\t\tlong double w1 = solve(j, ret + (1 << i))*neko[i][pos][j];\n\t\t\tcnt += w1;\n\t\t}\n\t\tmaxn = max(maxn, cnt);\n\t}\n\tdp[pos][ret] = maxn;\n\treturn maxn;\n}\nint main() {\n\tfor (int i = 0; i < 20; i++) { for (int j = 0; j < 100000; j++)dp[i][j] = -1.0l; }\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\ndouble dp[1<<16][17][16];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  vector<vector<double>> prob(M, vector<double>(N));\n  REP(i,M) REP(j,N) cin >> prob[i][j];\n\n  double ans = 0.;\n  FOR(b,1,1<<M) REP(i,M)\n\tif(b>>i&1) dp[b][N][i] = 1.;\n  for(int b=1;b<1<<M;++b){\n\tfor(int i=N-1;i>=0;--i){\n\t  for(int j=0;j<M;++j){\n\t\tif(b>>j&1 == 0) continue;\n\t\tint x = 0;\n\t\tREP(k,M) if((b>>k&1) && dp[b&~(1<<j)][i][k] > dp[b&~(1<<j)][i][x])\n\t\t  x = k;\n\t\tdp[b][i][j] = max(dp[b][i][j],\n\t\t\t\t\t\t  prob[j][i] * dp[b][i+1][j]\n\t\t\t\t\t\t  + (1. - prob[j][i]) * dp[b&~(1<<j)][i][x]);\n\t  }\n\t}\n  }\n\n  REP(i,M)\n\tans = max(ans, dp[(1<<M)-1][0][i]);\n  cout << fixed << setprecision(10) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint m,n;\ndouble dp[17][(1<<16) + 1];\ndouble prob[17][17];\n\ndouble calc(int f, int s) {\n\n    if (f == n)   return 1.0;\n    if (dp[f][s] != -1.0) return dp[f][s];\n\n    double ret = 0;\n    for (int k=0; k<m; ++k) if (!(s & (1<<k))) { // ???????????????????????????\n        double cp = 1.0;\n        double sum = 0;\n        for (int j=f; j<n && cp > 0.0; ++j) { // ?????????????????¢\n            if (prob[k][j] < 1.0) {\n                sum += calc(j, s|(1<<k)) * cp * (1.0 - prob[k][j]);\n            }\n            cp *= prob[k][j];\n        }\n        // ???????????§???????¶????????¢????(????????§?¢????0????????£?????????????????§??§??????\n        sum += cp;\n        ret = max(ret, sum);\n    }\n    //printf(\"f:%d\\ts:%d\\tp:%f\\tret:%f\\n\",f,s,p,ret);\n    return dp[f][s] = ret;\n}\n\nint main() {\n    cin >> m >> n;\n    for (int i=0; i<m; ++i) {\n        for (int j=0; j<n; ++j) {\n            cin >> prob[i][j];\n        }\n    }\n    // init\n    for (int i=0; i<17; ++i) for (int j=0; j<(1<<16)+1; ++j) dp[i][j] = -1.0;\n\n    printf(\"%.12f\\n\", calc(0, 0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m, n;\ndouble d[20][20];\ndouble dp[1<<16][20];\n\n// 集合maskの猫が生き残っていて、idx番目の敵とやってる\ndouble dfs(int mask, int idx) {\n  if(dp[mask][idx] >= 0) return dp[mask][idx];\n  if(mask == 0) return 0.0;\n  if(idx == n) return 1.0;\n\n  double ret = 0;\n  REP(i, m) if(mask & 1<<i) {\n    double tmp = 0, prob = 1;\n    FOR(j, idx, n) {\n      // 猫iが敵jまで行った\n      tmp += dfs(mask^(1<<i),j)*prob*(1.0-d[i][j]);\n      prob *= d[i][j];\n    }\n    tmp += prob;\n    chmax(ret, tmp);\n  }\n\n  return dp[mask][idx] = ret;\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  // m匹, n部屋\n  cin >> m >> n;\n  REP(i, m) REP(j, n) cin >> d[i][j];\n\n  REP(i, 1<<m) REP(j, n) dp[i][j] = -1;\n\n  cout << fixed << setprecision(15) << dfs((1LL<<m)-1, 0) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\nconst double INF = 1e18;\nconst double EPS = 1e-10;\n\nint main(){\n\tint m,n;\n\tcin >> m >> n;\n\tvector<vector<double> > p(m, vector<double>(n));\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\t\n\tvector<vector<double> > dp(1<<m, vector<double>(m, 0));\n\tfor(int i=0; i<(1<<m); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((1<<j & i) != 0) dp[i][j] = 1;\n\t\t}\n\t}\n\t\n\tfor(int i=n-1; i>=0; i--){\n\t\tvector<vector<double> > ndp(1<<m, vector<double>(m, 0));\n\t\tfor(int j=0; j<(1<<m); j++){\n\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\tif((j & 1<<k) == 0) continue;\n\t\t\t\tdouble nextmax = 0;\n\t\t\t\tfor(int l=0; l<m; l++){\n\t\t\t\t\tnextmax = max(nextmax, ndp[j & ~(1<<k)][l]);\n\t\t\t\t}\n\t\t\t\tndp[j][k] = p[k][i]*dp[j][k] +(1 -p[k][i])*nextmax;\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\t\n\tcout << fixed << setprecision(10);\n\tcout << *max_element(dp[(1<<m) -1].begin(), dp[(1<<m) -1].end()) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define N 17\nusing namespace std;\nint m,n;\ndouble x[N][N],d[(1<<N)][N],com[N];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>x[i][j];\n  d[0][0]=1;\n  double ans=0;\n  for(int i=0;i<(1<<m);i++){\n    for(int j=0;j<m;j++){\n      if(i&(1<<j))continue;\n      for(int k=0;k<=n;k++)\n\tcom[k]=d[i][k];\n      for(int k=0;k<n;k++){\n\tcom[k+1]+=com[k]*x[j][k];\n\tcom[k]*=(1-x[j][k]);\n      }\n      int f=0;\n      for(int k=n;k>=0;k--){\n\tif(EPS<com[k]-d[i|(1<<j)][k])f=1;\n\tif(EPS<d[i|(1<<j)][k]-com[k])break;\n      }\n      for(int k=0;f&&k<=n;k++)\n\td[i|(1<<j)][k]=com[k];\n    }\n    ans=max(ans,d[i][n]);\n  }\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\ndouble vv[16][16];\ndouble dp[16][1 << 16];\n\ndouble rec(int idx, int bit)\n{\n  if(idx == N) return (1.0);\n  if(dp[idx][bit] >= 0) return (dp[idx][bit]);\n  double ret = 0;\n  for(int i = 0; i < M; i++) {\n    if((bit >> i) & 1) continue;\n    double beet = 0, fact = 1.0;\n    for(int j = idx; j < N; j++) {\n      beet += rec(j, bit | (1 << i)) * (1.0 - vv[i][j]) * fact;\n      fact *= vv[i][j];\n    }\n    ret = max(ret, beet + fact);\n  }\n  return (dp[idx][bit] = ret);\n}\n\nint main()\n{\n  cin >> M >> N;\n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < N; j++) {\n      cin >> vv[i][j];\n    }\n  }\n  fill_n(*dp, (1 << 16) * 16, -1);\n  cout << fixed << setprecision(13) << rec(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nfloat memof[1 << 16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(room == 15 and memof[nekos][neko] != -1) return memof[nekos][neko];\n\tif(room != 15 and memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return memof[nekos][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\trep(i,1 << 16) rep(j,16) memof[i][j] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[22][1<<16];\nint n,m;\n\ndouble DFS(int idx, int state){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][state] >= -0.1)return dp[idx][state];\n\tdouble ret = -0.1;\n\tREP(i,n){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state)+(1-p[i][idx])*DFS(idx, state ^ mask));\n\t}\n\treturn dp[idx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,(1<<m))dp[i][j]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint n,m;\ndouble v[22][22];\ndouble dp[1<<16][22];\n\ndouble dfs(int state,int num){\n\t\n\tif(dp[state][num] != -1)return dp[state][num];\n\tdouble ret = 0;\n\t\n\tREP(i,n){\n\t\tif(!(state & (1<<i))){\n\t\t\tdouble tmp = 0;\n\t\t\tdouble p = 1;\n\t\t\tfor(int k = num;k < m;k++){\n\t\t\t\ttmp += p * (1 - v[i][k]) * dfs(state|(1<<i),k);\n\t\t\t\tp *= v[i][k];\n\t\t\t}\n\t\t\tret = max(ret,tmp+p);\n\t\t}\n\t}\n\t\t\t\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tREP(i,1<<16)REP(j,22)dp[i][j] = -1;\n\t\t\n\tREP(i,n){\n\t\tREP(j,m){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t\n\tcout << Decimal << (0,0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint n, m;\ndouble prob[20][20];\ndouble dp[20][1 << 20];\n\ndouble f(int opp, int rem) {\n\tif(dp[opp][rem] != -1) {\n\t\treturn dp[opp][rem];\n\t}\n\tif(opp == n) {\n\t\treturn dp[opp][rem] = 1.0;\n\t}\n\tif(rem == 0) {\n\t\treturn dp[opp][rem] = 0.0;\n\t}\n\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif((rem >> i) & 1) {\n\t\t\tdouble win = 1.0;\n\t\t\tdouble res = 0;\n\t\t\tfor(int j = opp; j <= n; j++) {\n\t\t\t\tres += win * (1.0 - prob[i][j]) * f(j, rem ^ (1 << i));\n\t\t\t\twin *= prob[i][j];\n\t\t\t}\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\n\treturn dp[opp][rem] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcin >> prob[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n + 1; i++) {\n\t\tfor(int j = 0; j < 1 << m; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << f(0, (1 << m) - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, bitset<16> ro, bitset<16> ne){\n\tunsigned int room = ro.to_ulong();\n\tunsigned int neko = ne.to_ulong();\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16];\ndouble dp[16][(1<<16)];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      cin>>t[i][j];\n    }\n  }\n  \n\n  for(int S=(1<<m)-1;S>=0;S--){\n    dp[n][S]=1.0;\n    for(int x=n-1;x>=0;x--){\n      for(int i=0;i<m;i++){\n        if(S>>i&1)continue;\n        dp[x][S]=max(dp[x][S],dp[x+1][S]*t[i][x]+(1.0-t[i][x])*dp[x][S|(1<<i)]);\n      }\n    }\n  }\n  printf(\"%.12f\\n\",dp[0][0]);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint N;\nint M;\nvector<vector<double> > dp;\nvector<vector<double> > p;\n\ndouble solve(int i, int j) {\n\tif (dp[i][j] > -0.5) {\n\t\treturn dp[i][j];\n\t}\n\tdouble res = -1;\n\tfor (int x = 0; x < N; x++) {\n\t\t\n\t\tif (j & (1 << x)) {\n\t\t\tdouble tmp = 0;\n\t\t\tdouble prob = 1;\n\t\t\tfor (int m = i; m <= M; m++) {\n\t\t\t\ttmp += prob * (1 - p[x][m]) * solve(m, j ^ (1 << x));\n\t\t\t\tprob *= p[x][m];\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\t\n\t}\n\tdp[i][j] = res;\n\treturn dp[i][j];\n}\nsigned main() {\n\t\n\tcin >> N >> M;\n\tp.resize(N, vector<double>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].push_back(0);\n\t}\n\tdp.resize(M + 1, vector<double>(1 << N, -1));\n\tdp[M][0] = 1;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tdp[i][0] = 0;\n\t}\n\tcout << setprecision(15) << solve(0, (1 << N) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint M, N;\ndouble board[20][20], acc[20][20];\ndouble dp[1<<16][16];\n\n// generate binary string (not less than k-digit)\nstring to_binString(int n, int k) {\n    string ret = \"\";\n    while(n) ret += ('0' + (n&1)), n >>= 1;\n    while(ret.length() < k) ret += '0';\n    // reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nsigned main() {\n    cin >> M >> N;\n    rep(i,0,M) acc[i][0] = 1.0;\n    rep(i,0,M) rep(j,0,N) {\n        cin >> board[i][j];\n        acc[i][j+1] = acc[i][j] * board[i][j];\n    }\n\n    dp[0][0] = 1.0;\n    rep(bit,0,1<<M) repq(j,0,N) {\n        int lsb = bit & -bit;\n        rep(i,lsb,M) {\n            if(bit >> i & 1) continue;\n            int nbit = bit | (1 << i);\n            repq(k,j,N) {\n                double p = acc[i][k] / acc[i][j] * (1 - board[i][k]);\n                dp[nbit][k] += dp[bit][j] * p;\n            }\n        }\n    }\n    printf(\"%.12f\\n\", dp[(1<<M)-1][N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n#define all(n) n.begin(),n.end()\n#define clr(n) memset(n,0,sizeof(n))\n#define mclr(n) memset(n,-1,sizeof(n))\n\n//dp[bit][i][j] ?´???£??????????????????bit???i???????????¨?±????j?????????????????????\n//??¨??¨????????????????¢????\nfloat dp[1 << 16][16][16];\n\n//ap[i][j][k] ???i ?????¨?±?j????????¨?±?k?????????????¢????\nfloat ap[16][16][17];\n\nint main() {\n\tint n, m;\n\tcin >> m >> n;\n\tclr(dp);\n\tvector<vector<float>> a(m, vector<float>(n));\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\ta[i].push_back(0.0);\n\t}\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\trep(k, n + 1) {\n\t\t\t\tap[i][j][k] = 1.0;\n\t\t\t\tfor (int l = j; l < k; l++) {\n\t\t\t\t\tap[i][j][k] *= a[i][l];\n\t\t\t\t}\n\t\t\t\tap[i][j][k] *= (1.0 - a[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfunction<float(int, int, int)> solve = [&](int bit, int i, int j) {\n\t\tif (i == n)return 1.0f;\n\t\tif (bit == (1 << m) - 1) {\n\t\t\treturn ap[j][i][n];\n\t\t}\n\t\tif (dp[bit][i][j]) {\n\t\t\treturn dp[bit][i][j];\n\t\t}\n\t\tfloat re = 0.0;\n\t\trep(k, m) if(!(bit & (1 << k))){\n\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\tre += solve(bit | (1 << k), l, k) * ap[j][i][l];\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][i][j] = re;\n\t};\n\tfloat ans = 0.0;\n\trep(i, m) {\n\t\tans = max(ans, solve(1 << i, 0, i));\n\t}\n\tcout << fixed << setprecision(30) << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][15][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ndouble memo[16][1 << 16];\nbool   dp[16][1 << 16];\ndouble prob[16][16];\n\nint m, n;\n\ndouble solve(int pos, int flag){\n  if(dp[pos][flag]) return memo[pos][flag];\n  dp[pos][flag] = true;\n\n  double ret = 0.0;\n\n  REP(i,m) if(flag & (1 << i)){\n    double p   = 1.0;\n    double tmp = 0.0;\n    for(int j = pos; j < n; j++){\n      double pp = p * prob[i][j];\n      tmp += (p - pp) * solve(j, flag ^ (1 << i));\n      p = pp;\n    }\n    tmp += p;\n    ret = max(ret, tmp);\n  }\n\n  return memo[pos][flag] = ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &m, &n);\n  REP(i,m) REP(j,n)\n    scanf(\"%lf\", &prob[i][j]);\n  printf(\"%.11f\\n\", solve(0, (1 << m) - 1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n//double neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble memo[1 << 16][16][16];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\t//rep(i,n){\n\t//\trep(j,m){\n\t//\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t//\t\trange(k,j + 1,m){\n\t//\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nconst LL MOD = 1000000007LL;\ndouble dp[17][1 << 16];\ndouble win[16][16];\nint m, n;\ndouble solve(int r, int c) {\n\tif (r == n) return 1;\n\tif (dp[r][c] != -1) return dp[r][c];\n\tdouble ret = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c&(1 << i)) continue;\n\t\tdouble t = 1;\n\t\tdouble sum = 0;\n\t\tfor (int j = r; j < n; j++) {\n\t\t\tsum += t*(1 - win[i][j])*solve(j, c | (1 << i));\n\t\t\tt *= win[i][j];\n\t\t}\n\t\tsum += t;\n\t\tret = max(ret, sum);\n\t}\n\treturn dp[r][c] = ret;\n}\nint main() {\n\tcin >> m >> n;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) cin >> win[i][j];\n\t}\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < (1 << m); j++) dp[i][j] = -1;\n\tprintf(\"%.15lf\\n\", solve(0, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 16\n#define MAX_M 16\n\nint M, N;\ndouble P[MAX_M][MAX_N];\ndouble dp[MAX_N][1<<MAX_M];\n\ndouble solve(int n, int m)\n{   \n    double &res = dp[n][m];\n    \n    if (res != -1) {\n        return res;\n    }\n    res = 0;\n\n    for (int i = 0; i < M; i++) {\n        if (!(m >> i & 1)) continue;\n        double p = 1.0, q = 0.0;\n        for (int j = n; j < N; j++) { \n            q += p * (1 - P[i][j]) * solve(j, m & ~(1<<i));\n            p *= P[i][j];\n        }\n        q += p;\n        res = max(res, q);\n    }    \n    return res;\n}\n\nint main()\n{\n    cin >> M >> N;\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> P[i][j];\n        }\n    }\n    fill(dp[0], dp[MAX_N], -1);\n    printf(\"%.10f\\n\", solve(0, (1<<M)-1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble d[20][20];\ndouble dp[1<<16][20];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const double EPS = 1e-8;\n\n  // m匹, n部屋\n  int m, n;\n  cin >> m >> n;\n  REP(i, m) {\n    REP(j, n) cin >> d[i][j];\n  }\n\n  // dp[i][j] = (集合iの猫が挑んで次に挑む部屋がjとなる確率)\n  dp[0][0] = 1;\n\n  REP(i, 1<<m) REP(j, n) {\n    // cout << bitset<2>(i) << \" \" << j << \" \" << dp[i][j] << endl;\n    if(dp[i][j] < EPS) continue;\n    REP(k, m) {\n      if(i&1<<k) continue;\n      double prob = 1;\n      FOR(l, j, n+1) {\n        // 猫kが部屋lで負ける\n        dp[i | 1<<k][l] += dp[i][j] * prob * (1-d[k][l]);\n        prob *= d[k][l];\n      }\n    }\n  }\n\n  cout << fixed << setprecision(15) << dp[(1LL<<m)-1][n] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n,m;\n  cin>>m>>n;\n  \n  double p[m][n+1];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) cin>>p[i][j];\n  for(int i=0;i<m;i++) p[i][n]=0.0;\n  \n  double dp[n+1][1<<m],tmp[n+1];\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(1<<m);j++) dp[i][j]=0;\n  dp[0][0]=1.0;\n\n  for(int j=0;j<(1<<m);j++){\n    for(int k=0;k<m;k++){\n      if((j>>k)&1) continue;\n      memset(tmp,0,sizeof(tmp));\n      for(int i=0;i<=n;i++){\n\tdouble t=dp[i][j];\n\tfor(int l=i;l<=n;l++){\n\t  tmp[l]+=t*(1.0-p[k][l]);\n\t  t*=p[k][l];\n\t}\n\tfor(int l=i;l<=n;l++) dp[l][j+(1<<k)]=max(dp[l][j+(1<<k)],tmp[l]);\n      }\n    }\n  }\n  \n  double ans=0;\n  for(int j=0;j<(1<<m);j++) ans=max(ans,dp[n][j]);\n  printf(\"%.12lf\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\n//long double data[16][16][1<<16];\nlong double input[16][16];\n \nlong double func(int d, int s){\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    long double np = 1.0;\n    long double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n/*for(int i=0;i<=n-d;i++){\n    long double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n      if((s >> j) & 1) continue;\n        if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n          else res += tmp * func(d+i, j, s|(1<<j));\n        res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n    }*/\n  //data[d][c][s] = res;\n  return res;\n}\n \n/*long double solve(){\n  //fill(data[0][0], data[16][0], -1.0);\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, 1<<i));\n  }\n  return res;\n  }*/\n \nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n  //printf(\"%.10Lf\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef double real;\n\nreal dp[17][17][1 << 16];\nint n, m;\nreal p[17][17];\nreal solve(int stage, int now, int cats){\n\treal &res = dp[stage][now][cats];\n\tif(res != -1)return res;\n\tres = 0;\n\tif((1<<now) & cats)return res;\n\tif(stage == n)return res = 1;\n\t\n\tif(now == 16){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tres = max(res, solve(stage, i, cats));\n\t\t}\n\t}\n\telse{\n\t\tres = solve(stage+1, now, cats) * p[now][stage]\n\t\t\t+ solve(stage, 16, cats | (1<<now)) * (1 - p[now][stage]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < 17;i++)\n\t\tfor(int j = 0;j < 17;j++)\n\t\t\tfor(int k = 0;k < (1<<16);k++)\n\t\t\t\tdp[i][j][k] = -1;\n\n\tprintf(\"%.10lf\\n\", solve(0, 16, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16],Q[17][16];\ndouble dp[16][(1<<16)];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  for(int i=0;i<m;i++)Q[n][i]=1.0;\n  \n  for(int S=(1<<m)-1;S>=0;S--){\n    for(int x=n-1;x>=0;x--){\n      for(int i=0;i<m;i++){\n        if(S>>i&1)continue;\n        dp[x][S]=max(dp[x][S],Q[x+1][i]*t[i][x]+(1.0-t[i][x])*dp[x][S|(1<<i)]);\n        Q[x][i]=dp[x][S|(1<<i)]*(1.0-t[i][x])+Q[x+1][i]*t[i][x];\n      }\n    }\n  }\n  printf(\"%.12f\\n\",dp[0][0]);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\ndouble prob[16][16];\ndouble dp[1<<16][17];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  REP(i,M) REP(j,N) cin >> prob[i][j];\n\n  double ans = 0.;\n  FOR(b,1,1<<M)\n\tdp[b][N] = 1.;\n  for(int i=N-1;i>=0;--i){\n\tfor(int b=0;b<1<<M;++b){\n\t  for(int j=0;j<M;++j){\n\t\tif((b>>j&1) == 0) continue;\n\t\tdouble p = 1., sum = 0.;\n\t\tfor(int k=i;k<N;++k){\n\t\t  sum += p * (1. - prob[j][k]) * dp[b&~(1<<j)][k];\n\t\t  p *= prob[j][k];\n\t\t}\n\t\tsum += p * dp[b][N];\n\t\tdp[b][i] = max(dp[b][i], sum);\n\t  }\n\t}\n  }\n\n  ans = dp[(1<<M)-1][0];\n  cout << fixed << setprecision(10) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N;\ndouble P[16][16];\ndouble dp[1 << 16][16][16];\n\nint main(void) {\n  cin >> M >> N;\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  REP(S, 0, 1 << M) REP(i, 0, N + 1) REP(j, 0, N) dp[S][i][j] = 0;\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        double x = i + 1 < N ? dp[S][i + 1][j] : 1;\n        dp[S][i][j] = max(dp[S][i][j], x * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          double p = x * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4lf \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  double ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint M,N;\n\nconst double EPS = 1E-10;\n\ndouble A[18][18];\ndouble R[18][18][18];\ndouble dp[(1<<16)][18];\n\ndouble solve(int st,int id){\n  if( dp[st][id] > -EPS ) return dp[st][id];\n  double ret = 0.0;\n  if( id == N ) return dp[st][id] = 1.0;\n  for(int i=0;i<M;i++){\n    if( st & (1<<i) ) continue;\n    double at=0.0;\n    for(int j=id;j<=N;j++){\n      at += solve(st|(1<<i),j)*R[i][id][j];\n    }\n    ret = max( ret, at );\n  }\n  return dp[st][id] = ret;\n}\n\nint main(){\n  fill(dp[0],dp[(1<<16)],-1.0);\n  \n  cin >> M >> N;\n  for(int i=0;i<M;i++)\n    for(int j=0;j<N;j++) cin >> A[i][j];\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++){\n      R[i][j][j] = (1.0-A[i][j]);\n      double r = A[i][j];\n      for(int k=j+1;k<N;k++){\n        R[i][j][k] = r * (1.0-A[i][k]);\n        r *= A[i][k];\n      }\n      R[i][j][N] = r;\n    }\n  }\n  printf(\"%.10lf\\n\",solve(0,0));  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint main(void) {\n  int M, N;\n  cin >> M >> N;\n  vector<vector<double>> P(M, vector<double>(N));\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  vector<vector<vector<double>>> dp(1 << M, vector<vector<double>>(N + 1, vector<double>(M)));\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        dp[S][i][j] = max(dp[S][i][j], dp[S][i + 1][j] * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          double p = dp[S][i + 1][j] * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4lf \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  double ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\nconst double INF = (1<<30);\n\nint n,m;\ndouble cat[N][M];\ndouble memo[2][T][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring bitstr(int state){\n\tstring ret = \"\";\n\trep(i,n) ret += has(state,i) ? \"1\" : \"0\";\n\treturn ret;\n}\n\nvoid setEdge(int state, int e[N], int* esum){\n\t(*esum)=0;\n\trep(i,n){\n\t\tif(has(state,i)){\n\t\t\te[(*esum)]=i;\n\t\t\t(*esum)++;\n\t\t}\n\t}\n}\n\ndouble solve_dp(){\n\trep(i,2)rep(j,T)rep(k,N)memo[i][j][k]=0;\n\t\n\tint t = (1<<n);\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,T)rep(k,N)memo[i%2][j][k]=0;\n\t\trep(j,t){\n\t\t\tint edge[N];\n\t\t\tint esum = 0;\n\t\t\tsetEdge(j, edge, &esum);\n\t\t\t\n\t\t\trep(k,n){\n\t\t\t\tif(!has(j,k))continue;\n\t\t\t\tdouble maxi = 0;\n\t\t\t\tdouble val1=0;\n\t\t\t\tdouble winrate = cat[k][i];\n\t\t\t\t\n\t\t\t\tif(i!=m-1)val1 = winrate * memo[(i+1)%2][j][k];\n\t\t\t\telse val1 = winrate;\n\t\t\t\t\n\t\t\t\tmaxi = max(maxi, val1);\n\t\t\t\t\n\t\t\t\tint dstate = j^(1<<k);\n\t\t\t\trep(p,esum){\n\t\t\t\t\tint e = edge[p];\n\t\t\t\t\tif(!has(dstate,e))continue;\n\t\t\t\t\tmaxi = max(maxi, val1 + (1-winrate)*memo[i%2][dstate][e]);\n\t\t\t\t}\n\t\t\t\tmemo[i%2][j][k] = maxi;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 0;\n\trep(i,n) ans = max(ans, memo[0][t-1][i]);\n\t\n\treturn ans;\n}\ndouble solve(){\n\t\n\treturn solve_dp();\n}\n\nint main(){\n\tinput();\n\tprintf(\"%.12f\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m;\ndouble dp[1<<16][16];\ndouble data[17][17];\n\ndouble memo(int bit,int v){\n\tif(v==n)return 1.0;\n\tif(bit==0)return 0.0;\n\tif(dp[bit][v]>=0.0)return dp[bit][v];\n\tdouble res=0.0;\n\tfor(int i=0;i<m;i++){\n\t\tif(!(bit>>i & 1))continue;\n\t\tdouble sum=0.0,win=1.0;\n\t\tint lbit=bit-(1<<i);\n\t\tfor(int j=v;j<n;j++){\n\t\t\tsum+=memo(lbit,j)*win*(1-data[i][j]);\n\t\t\twin*=data[i][j];\n\t\t}\n\t\tsum+=win;\n\t\tres=max(res,sum);\n\t}\n\treturn dp[bit][v]=res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%lf\",&data[i][j]);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tdouble res=0.0;\n\tprintf(\"%.10f\\n\",memo((1<<m)-1,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst int MAX = 16;\nint m, n;\ndouble win[MAX][MAX];\ndouble memo[MAX][MAX][(1 << MAX)];\n\ninline double dfs(int cat, int room, int used) {\n\tif(room == n)\n\t\treturn 1.0;\n\n\tif(memo[cat][room][used] >= 0.0)\n\t\treturn memo[cat][room][used];\n\n\tdouble res = 0.0;\n\tres += win[cat][room] * dfs(cat, room + 1, used);\n\tdouble mx = 0.0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tif((used >> i) & 1)\n\t\t\tcontinue;\n\n\t\tchmax(mx, dfs(i, room, (used | (1 << i))));\n\t}\n\n\tres += mx * (1 - win[cat][room]);\n\treturn memo[cat][room][used] = res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> m >> n;\n\n\tfor(int i = 0; i < m; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tcin >> win[i][j];\n\n\tmemset(memo, -1, sizeof(memo));\n\tdouble ans = 0.0;\n\tfor(int i = 0; i < m; ++i)\n\t\tchmax(ans, dfs(i, 0, (1 << i)));\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\ndouble dp[16][16][1<<16];\ndouble prob[16][16];\n\ndouble dfs(int n, int m, int bitmap){\n  if(n >= N) return 1;\n  double &ret = dp[n][m][bitmap];\n  if(ret != INF) return ret;\n\n  ret = 0;\n  for(int i=0;i<M;i++){\n    if(bitmap & 1<<i) continue;\n    ret = max(ret, dfs(n, i, bitmap|(1<<i)) * (1 - prob[m][n]));\n  }\n  ret += dfs(n+1, m, bitmap) * prob[m][n]; \n  //  cout << n << \" \" << m << \" \" << bitmap << \" \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    rep(j, N) cin >> prob[i][j];\n  }\n  for(int i=0;i<16;i++) for(int j=0;j<16;j++) for(int k=0;k<1<<16;k++) dp[i][j][k] = INF;\n  double res = 0;\n  for(int i=0;i<M;i++)\n    res = max(res, dfs(0, i, 1<<i));\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble dfs(int pos,int k,int bit);\n\nint used[N][1<<N]={};\ndouble mem[N][1<<N];\ndouble calc(int pos,int bit){\n  if(used[pos][bit]++)return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  double p = neko[k][pos];\n  return p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  printf(\"%.10f\\n\",calc(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint m, n;\ndouble prob[16][16];\ndouble dp[16][1<<16];\n\ndouble search(int pos, int cat){\n\tif(dp[pos][cat] > -0.5) return dp[pos][cat];\n\tdouble& res = dp[pos][cat];\n\tres = 0.0;\n\tfor(int i=0;i<m;i++){\n\t\tif(cat&(1<<i)) continue;\n\t\tdouble pSum = 0.0;\n\t\tdouble pCur = 1.0;\n\t\tfor(int j=pos;j<n;j++){\n\t\t\tpSum += (1-prob[i][j])*pCur*search(j, cat|(1<<i));\n\t\t\tpCur *= prob[i][j];\n\t\t}\n\t\tpSum += pCur;\n\t\tres = max(res, pSum);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> m >> n){\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++) cin >> prob[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<(1<<m);j++) dp[i][j] = -1.0;\n\t\t}\n\t\tprintf(\"%.10lf\\n\", search(0, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N (17) \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble mem[N][1<<N];\nint used[N][1<<N];\n\ndouble dfs(int pos,int bit){\n  if(pos==n) return 1;\n  if(used[pos][bit]++) return mem[pos][bit];\n\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(bit&(1<<i))continue;\n    double r=0,t=1;\n    for(int j=pos;j<=n;j++){\n      r+=t*(1-neko[i][j])*dfs(j,bit|(1<<i));\n      t*=neko[i][j];\n    }\n    res = max(res,r);\n  }\n  return mem[pos][bit] = res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n    neko[i][n] = 0;\n  }\n\n  printf(\"%.10f\\n\",dfs(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nfloat dp[2][16][1<<16];\nfloat prob[16][16];\n\nfloat dfs(int n, int m, int bitmap){\n  /*  if(n >= N) return 1;\n  float &ret = dp[n][m][bitmap];\n  if(ret != INF) return ret;\n\n  ret = 0;\n  for(int i=0;i<M;i++){\n    if(bitmap & 1<<i) continue;\n    ret = max(ret, dfs(n, i, bitmap|(1<<i)) * (1 - prob[m][n]));\n  }\n  ret += dfs(n+1, m, bitmap) * prob[m][n]; \n  */\n  //  cout << n << \" \" << m << \" \" << bitmap << \" \" << ret << endl;\n  for(int i=0;i<16;i++) for(int j=0;j<1<<16;j++) dp[N%2][i][j] = 1;\n  for(int i=N-1;i>=0;i--){\n    for(int k=(1<<M)-1;k>=0;k--) for(int j=M-1;j>=0;j--) dp[i&1][j][k] = 0;\n    for(int k=(1<<M)-1;k>=0;k--){\n      for(int j=M-1;j>=0;j--){\t\n\tfor(int l=M-1;l>=0;l--){\n\t  if(!(k & (1<<l))) continue;\n\t  dp[i&1][j][k] = max(dp[i&1][j][k], dp[i&1][l][k&-(1<<l)] * (1 - prob[j][i]));\n\t}\n\tdp[i&1][j][k] += dp[(i+1)&1][j][k] * prob[j][i];\n\t//\tcout << dp[i+1][j][k] << \" \" << prob[i][j] << endl;\n      }\n    }\n  }\n  //  return ret;\n}\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    rep(j, N) cin >> prob[i][j];\n  }\n  for(int i=0;i<2;i++) for(int j=0;j<16;j++) for(int k=0;k<1<<16;k++) dp[i][j][k] = 0;\n  dfs(0, 0, 0);\n  float res = 0;\n  for(int i=0;i<M;i++){\n    for(int j=0;j<1<<M;j++){\n    //    res = max(res, dfs(0, i, 1<<i));\n      res = max(res, dp[0][i][j]);\n    }\n  }\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      for(int k=0;k<1<<M;k++){\n\tcout << dp[i][j][k] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n  */\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[22][1<<16];\nint n,m;\n\ndouble DFS(int idx, int state){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][state] >= -0.1)return dp[idx][state];\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state)+(1-p[i][idx])*DFS(idx, (state&(~mask))));\n\t}\n\treturn dp[idx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,(1<<m))dp[i][j]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n\n#define int long long\nint n, m;\n\nvector<long double> inputs[17];\nlong double dp[(1 << 16)][17] = {};\nlong double dfs(int a, int b) {\n    if (dp[b][a] != -1) return dp[b][a];\n    long double ans = 0.0;\n    REP(i, m) {\n        if ((1 << i) & b) continue;\n        long double now = 0;\n        long double hoge = 1;\n        for (int q = a; q < n; ++q) {\n            now += (1.0 - inputs[i][q]) * hoge * dfs(q, (1 << i) + b);\n            hoge *= inputs[i][q];\n        }\n        now += hoge;\n        ans = max(ans, now);\n    }\n    return dp[b][a] = ans;\n}\nvoid solve(){\n    cin >> m >> n;\n    REP(i, m) {\n        REP(q, n) {\n            long double a;\n            cin >> a;\n            inputs[i].push_back(a);\n        }\n    }\n    REP(i, (1 << 16)) {\n        REP(q, 17) {\n            dp[i][q] = -1;\n        }\n    }\n    cout << dfs(0, 0) << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint N;\nint M;\nvector<vector<double> > dp;\nvector<vector<double> > p;\n\ndouble solve(int i, int j) {\n\tif (dp[i][j] > -0.5) {\n\t\treturn dp[i][j];\n\t}\n\tif (i == M)return 1;\n\tdouble res = 0;\n\tfor (int x = 0; x < N; x++) {\n\t\tif (j & (1 << x)) {\n\t\t\tdouble tmp = 0;\n\t\t\tdouble prob = 1;\n\t\t\tfor (int m = i; m <= M; m++) {\n\t\t\t\ttmp += prob * (1 - p[x][m]) * solve(m, j ^ (1 << x));\n\t\t\t\tprob *= p[x][m];\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\t}\n\tdp[i][j] = res;\n\treturn dp[i][j];\n}\nsigned main() {\n\t\n\tcin >> N >> M;\n\tp.resize(N, vector<double>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].push_back(0);\n\t}\n\tdp.resize(M + 1, vector<double>((1 << N), -1));\n\tdp[M][0] = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tdp[i][0] = 0;\n\t}\n\tcout << fixed << setprecision(15) << solve(0, (1 << N) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\n#define MAX 16\n\nint m, n;\ndouble win[MAX][MAX];\ndouble memo[MAX][(1 << MAX)];\n\ninline double dfs(int room = 0, int rest = (1 << m) - 1) {\n\tif(memo[room][rest] >= 0.0)\n\t\treturn memo[room][rest];\n\n\tdouble res = 0.0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tif(rest & (1 << i)) {\n\t\t\tconst int next_rest = rest ^ (1 << i);\n\t\t\tdouble tmp = 0.0, p = 1.0;\n\t\t\tfor(int j = room; j < n; ++j) {\n\t\t\t\ttmp += p * (1 - win[i][j]) * dfs(j, next_rest);\n\t\t\t\tp *= win[i][j];\n\t\t\t}\n\n\t\t\tchmax(res, tmp + p);\n\t\t}\n\t}\n\n\treturn memo[room][rest] = res;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor(int i = 0; i < m; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tscanf(\"%lf\", &win[i][j]);\n\n\tmemset(memo, -1, sizeof(memo));\n\tfor(int i = 0; i < n; ++i)\n\t\tmemo[i][0] = 0.0;\n\n\tprintf(\"%.15lf\\n\", dfs());\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nlong double neko[20][20][20];\nint n, m; long double x[20][20], dp[20][100000];\nint main() {\n\tcin >> m >> n;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) cin >> x[i][j];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tneko[i][j][j] = 1.0l; long double cnt = 1.0l;\n\t\t\tfor (int k = j; k < n; k++) {\n\t\t\t\tcnt *= x[i][k]; neko[i][j][k + 1] = cnt;\n\t\t\t}\n\t\t\tfor (int k = j; k <= n; k++) {\n\t\t\t\tneko[i][j][k] = neko[i][j][k] - neko[i][j][k + 1];\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0] = 1.0l;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tint bit[16]; for (int k = 0; k < m; k++)bit[k] = (j / (1 << k)) % 2;\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (bit[k] == 1)continue;\n\t\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\t\tdp[l][j + (1 << k)] = max(dp[l][j + (1 << k)], dp[i][j] * neko[k][i][l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong double sum = 0; for (int i = 0; i < (1 << m); i++)sum += dp[n][i];\n\tprintf(\"%.12Lf\\n\", sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nfloat dp[16][16][1<<16];\nfloat prob[16][16];\n\nfloat dfs(int n, int m, int bitmap){\n  if(n >= N) return 1;\n  float &ret = dp[n][m][bitmap];\n  if(ret != INF) return ret;\n\n  ret = 0;\n  for(int i=0;i<M;i++){\n    if(bitmap & 1<<i) continue;\n    ret = max(ret, dfs(n, i, bitmap|(1<<i)) * (1 - prob[m][n]));\n  }\n  ret += dfs(n+1, m, bitmap) * prob[m][n]; \n  //  cout << n << \" \" << m << \" \" << bitmap << \" \" << ret << endl;\n  return ret;\n}\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    rep(j, N) cin >> prob[i][j];\n  }\n  for(int i=0;i<16;i++) for(int j=0;j<16;j++) for(int k=0;k<1<<16;k++) dp[i][j][k] = INF;\n  float res = 0;\n  for(int i=0;i<M;i++)\n    res = max(res, dfs(0, i, 1<<i));\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint N;\nint M;\nvector<vector<double> > dp;\nvector<vector<double> >p;\n\ndouble solve(int i, int j) {\n\tif (dp[i][j] > -0.5) {\n\t\treturn dp[i][j];\n\t}\n\tdouble res = -1;\n\tfor (int x = 0; x < N; x++) {\n\t\tdouble tmp = 0;\n\t\tdouble prob = 1;\n\t\tif (j & (1 << x)) {\n\t\t\tfor (int m = i; m <= M; m++) {\n\t\t\t\ttmp += prob * (1 - p[x][m]) * solve(m, j ^ (1 << x));\n\t\t\t\tprob *= p[x][m];\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\n\t\t\n\t}\n\tdp[i][j] = res;\n\treturn dp[i][j];\n}\nsigned main() {\n\t\n\tcin >> N >> M;\n\tp.resize(N, vector<double>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].push_back(0);\n\t}\n\tdp.resize(M + 1, vector<double>(1 << N, -1));\n\tdp[M][0] = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tdp[i][0] = 0;\n\t}\n\tcout << setprecision(15) << solve(0, (1 << N) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tcmax(x, p[i][k] * dp[i + 1][j] + (1 - p[i][k]) * dp[i][j&~(1 << k)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout << setprecision(10) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m;\ndouble dp[(1<<16)][17];\ndouble a[20][20];\n\ndouble memo(int state,int enemy){\n\tif(enemy==m)return 1;\n\tif(state==(1<<n)-1)return 0;\n\tif(dp[state][enemy]>=0)return dp[state][enemy];\n\tdouble &res=dp[state][enemy];\n\tres=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(state&(1<<i))continue;\n\t\tdouble now=1,sum=0;\n\t\tfor(int j=enemy;j<m;j++){\n\t\t\tsum+=now*(1-a[i][j])*memo((state|(1<<i)),j);\n\t\t\tnow*=a[i][j];\n\t\t}\n\t\tsum+=now;\n\t\tres=max(res,sum);\n\t}\n\treturn dp[state][enemy];\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\tcout<<fixed;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<16);i++)\n\t  for(int j=0;j<17;j++)\n\t  \tdp[i][j]=-1;\n\tcout<<memo(0,0)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][15];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,15) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, m;\nvector<vector<double> > win;\nvector<vector<double> > memo;\n\ndouble solve(int curr, bitset<16> cat)\n{\n    if(memo[curr][cat.to_ulong()] > -0.5)\n        return memo[curr][cat.to_ulong()];\n\n    double ret = 0.0;\n    for(int i=0; i<m; ++i){\n        if(!cat[i])\n            continue;\n\n        cat[i] = false;\n        double p = 1.0;\n        double tmp = 0.0;\n        for(int j=curr; j<n; ++j){\n            tmp += p * (1.0 - win[i][j]) * solve(j, cat);\n            p *= win[i][j];\n        }\n        tmp += p;\n        cat[i] = true;\n\n        ret = max(ret, tmp);\n    }\n\n    return memo[curr][cat.to_ulong()] = ret;\n}\n\nint main()\n{\n    cin >> m >> n;\n    win.assign(m, vector<double>(n));\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            cin >> win[i][j];\n        }\n    }\n\n    memo.assign(n, vector<double>(1<<m, -1.0));\n    printf(\"%.10f\\n\", solve(0, (1<<m)-1));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\ndouble dp[1 << 16][16 + 1][16];\n\nint main(void) {\n  int M, N;\n  cin >> M >> N;\n  vector<vector<double>> P(M, vector<double>(N));\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  REP(S, 0, 1 << M) REP(i, 0, N + 1) REP(j, 0, N) dp[S][i][j] = 0;\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        dp[S][i][j] = max(dp[S][i][j], dp[S][i + 1][j] * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          double p = dp[S][i + 1][j] * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4lf \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  double ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16];\ndouble dp[16][(1<<16)];\ndouble Q[17][16];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n\n  for(int S=(1<<m)-1;S>=0;S--){\n    for(int i=0;i<m;i++)Q[n][i]=1.0;\n    for(int x=n-1;x>=0;x--){\n      for(int i=0;i<m;i++){\n        if(S>>i&1)continue;\n        dp[x][S]=max(dp[x][S],Q[x+1][i]*t[i][x]+(1.0-t[i][x])*dp[x][S|(1<<i)]);\n        Q[x][i]=dp[x][S|(1<<i)]*(1.0-t[i][x])+Q[x+1][i]*t[i][x];\n      }\n    }\n  }\n  printf(\"%.12f\\n\",dp[0][0]);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n\nint main(){\n\tint m,n;//ねこ　階数\n\tcin>>m>>n;\n\tvector<vector<vector<double> > >   dp(1<<m,vector<vector<double> >(n+1, vector<double>(m,0) ) );\n\tvector<vector<double> >   p(m,vector<double> (n,0) );\n\t\n\tfor(int i=0;i< (1<<m) ;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(  ( (1<<j) & i ) != 0 ) dp[i][0][j] = 1;  \n\t\t}\n\t}\n\t\n\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<n;j++)cin>>p[i][j];\n\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<(1<<m);j++){\n\t\t\tfor(int k = 0;k<m;k++){\n\t\t\t\tif( (j&(1<<k) ) == 0 ) continue;\n\t\t\t\tdouble mx = 0;\n\t\t\t\tfor(int l = 0; l< m;l++ ) {\n\t\t\t\t\tmx = max(mx,dp[ (j&~(1<<k) )][i+1][l] ) ;\n\t\t\t\t}\n\t\t\t\tdp[j][i+1][k] = p[k][i]*dp[j][i][k] + (1- p[k][i])*mx;\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\tcout << *max_element(dp[(1<<m) -1][n].begin(), dp[(1<<m) -1][n].end()) << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic int used;\n\tstatic double dp[1 << 17][20];\n\tstatic bool done[1 << 18][20];\n\tif (done[used][reached] == true) {\n\t\treturn dp[used][reached];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif ((used >> i) & 1) continue;\n\t\tused |= 1 << i;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused ^= 1 << i;\n\t}\n\tdone[used][reached] = true;\n\treturn dp[used][reached] = res;\n}\n\nvoid solve() {\n\t m = atoi(s_);\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\tif (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\nvvd a;\n\nint main(){\n\tcin>>n>>m;\n\ta=vvd(n,vd(m));\n\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) cin>>a[i][j];\n\tvvd dp(1<<n,vd(m));\n\tfor(int i=0;i<1<<n;i++) for(int j=m-1;j>=0;j--){\n\t\tfor(int k=0;k<n;k++) if(i&1<<k){\n\t\t\tdouble tmp=0,p=1;\n\t\t\tfor(int l=j;l<m;l++){\n\t\t\t\ttmp+=p*(1-a[k][l])*dp[i-(1<<k)][l];\n\t\t\t\tp*=a[k][l];\n\t\t\t}\n\t\t\tdp[i][j]=max(dp[i][j],tmp+p);\n\t\t}\n\t}\n\tcout<<syosu(11)<<dp[(1<<n)-1][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N (17) \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble mem[N][1<<N];\nint used[N][1<<N];\n\ndouble dfs(int pos,int bit){\n  if(pos==n) return 1;\n  if(used[pos][bit]++) return mem[pos][bit];\n\n  double res=0;\n  for(int i=0;i<n;i++){\n    if(bit&(1<<i))continue;\n    double r=0,t=1;\n    for(int j=pos;j<n;j++){\n      r+=t*(1-neko[i][j])*dfs(j,bit|(1<<i));\n      t*=neko[i][j];\n    }\n    r+=t;\n    res = max(res,r);\n  }\n  return mem[pos][bit] = res;\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n    neko[i][n] = 1;\n  }\n  printf(\"%.10f\\n\",dfs(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\n\ndouble dp[1<<16][17];\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n  vector<vector<double>> cats(m, vector<double>(n));\n  REP(i,m)REP(j,n) {\n    cin>>cats[i][j];\n  }\n  dp[0][0] = 1.0;\n  REP(i,1<<m)FOR(j,0,n+1) {\n    REP(k,m) {\n      if ((i>>k)&1) continue;\n      double live = 1.0;\n      FOR(l,j,n+1) {\n        double oldlive = live;\n        live *= cats[k][l];\n        dp[i|(1<<k)][l] = max(dp[i|(1<<k)][l], dp[i][j] * (oldlive - live));\n      }\n    }\n  }\n  double sum = 0.0;\n  REP(i,1<<m) {\n    sum += dp[i][n];\n  }\n  cout << fixed << setprecision(10) << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nfloat memof[1 << 16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(room == 15 and memof[nekos][neko] != -1) return memof[nekos][neko];\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return memof[nekos][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\trep(i,1 << 16) rep(j,16) memof[i][j] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\ndouble dp[17][(1 << 16) + 1];\ndouble P[17][17];\n\nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n\n  int lim = 1 << m;\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      if(st) dp[n][st] = 1.0;\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        cand += dp[k][nst]*(1-P[j][i]);\n        cand += dp[k+1][st]*P[j][i];\n        dp[i][st] = max(dp[i][st], cand);\n      }\n    }\n  }\n  printf(\"%.20f\\n\", dp[0][lim-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n,m;\n  cin>>m>>n;\n  \n  double p[m][n+1];\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) cin>>p[i][j];\n  for(int i=0;i<m;i++) p[i][n]=0.0;\n  \n  double dp[n+1][1<<m],tmp[n+1];\n  for(int i=0;i<=n;i++)\n    for(int j=0;j<(1<<m);j++) dp[i][j]=0;\n  dp[0][0]=1.0;\n\n  for(int j=0;j<(1<<m);j++){\n    for(int k=0;k<m;k++){\n      if((j>>k)&1) continue;\n      for(int i=0;i<=n;i++){\n\tdouble t=dp[i][j];\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(int l=i;l<=n;l++){\n\t  tmp[l]+=t*(1.0-p[k][l]);\n\t  t*=p[k][l];\n\t}\n\tfor(int l=i;l<=n;l++) dp[l][j+(1<<k)]=max(dp[l][j+(1<<k)],tmp[l]);\n      }\n    }\n  }\n  \n  double ans=0;\n  for(int j=0;j<(1<<m);j++) ans+=dp[n][j];\n  printf(\"%.12lf\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int MAX_M = 16;\nconst double EPS = 1e-10;\n\ndouble dp[1<<MAX_M][MAX_N];\n\ndouble prob[MAX_M][MAX_N];\nint M, N;\n\ndouble dfs(int b, int x){\n  if(x == N) return 1.0;\n  if(b == (1<<M)-1){\n    return 0.0;\n  }\n  if(dp[b][x] - -1 < EPS) return dp[b][x];\n  //cout << b << \" \" << x << \" \" << M << \" \" << N << endl;  \n  double ret = 0; \n  for(int i=0;i<M;i++){\n    if(b&(1<<i)) continue;\n    double p = 0.0;\n    double tmpp = 1.0;\n    for(int j=x;j<N;j++){\n      p += tmpp * (1 - prob[i][j]) * dfs(b | (1<<i), j);\n      //cout << p << endl;\n      //cout << \"tmpp: \" << tmpp << \" prob[i][j]: \" << prob[i][j] << endl;      \n      tmpp *= prob[i][j];\n    }\n    p += tmpp * dfs(b | (1<<i), N);\n    ret = max(ret, p);\n  }\n  dp[b][x] = ret;\n  return ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &M, &N);\n  memset(dp, -1, sizeof(dp));\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++){\n      scanf(\"%lf\", &prob[i][j]);\n    }\n  }\n\n  printf(\"%0.12lf\\n\", dfs(0, 0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//AOJ 2237\nint m,n;\ndouble wp[16][16];\ndouble memo[1<<16][16];\n\n\n//k:倒された猫のリスト\n//depth:倒した敵の数\n//neko:使う猫\ndouble DFS(int k, int depth, int neko){\n\tif(neko==-1 && memo[k][depth]> -0.5)return memo[k][depth];\n\tint ix = 1;\n\tdouble ret=0.0;\n\tif(depth==n)return 1.0;\n\tif((k+1)==(1<<m))return 0.0;\n\tif(neko==-1){\n\t\tREP(i,m){\n\t\t\tif(!(k&ix)){\n\t\t\t\tret = max(ret, DFS(k,depth,i));\n\t\t\t}\n\t\t\tix<<=1;\n\t\t}\n\t}else{\n\t\tdouble tmp=0.0;\n\t\t//買った場合\n\t\ttmp += wp[neko][depth]*DFS(k,depth+1,neko);\n\t\t//負けた場合\n\t\ttmp += (1-wp[neko][depth])*DFS(k|(1<<neko),depth,-1);\n\t\tret=max(ret, tmp);\n\t}\n\treturn memo[k][depth] = ret;\n}\n\nint main(){\n\tREP(i,1<<16)REP(j,16)memo[i][j]=-1.0;\n\tcin>>m>>n;\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &wp[i][j]);\n\tprintf(\"%.11f\\n\", DFS(0, 0, -1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nstd::map<std::pair<char,char>, double> mo;\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 100000;\n\tif(room == 15 and mo.count(std::make_pair(nekos, neko))) return mo[std::make_pair(nekos, neko)];\n\tif(room != 15 and memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return mo[std::make_pair(nekos, neko)] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l <= n + 1; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout << setprecision(20) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ninline bool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\ninline int setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nfloat p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, bitset<16> ro, bitset<16> ne){\n\tunsigned int room = ro.to_ulong();\n\tunsigned int neko = ne.to_ulong();\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst ssize_t MAX_N = 16;\nconst ssize_t MAX_S = 1 << MAX_N;\ndouble dp[MAX_S][MAX_N + 1];\ndouble adv_p[MAX_N][MAX_N + 1][MAX_N + 1];\nbool calced[MAX_S];\nusing BS = bitset<MAX_N>;\nVV<double> cats;\nll N, M, MS;\n\nvoid rec(ll S) {\n    if (calced[S]) return;\n    calced[S] = true;\n    if (S == (1ll << N) - 1) return;\n    for (ll i = 0; i < N; i++) {\n        ll mask = (1ll << i);\n        if (S & mask) continue;\n        rec(S ^ mask);\n        for (ll cur = 0; cur <= M; cur++) {\n            double p = 0;\n            for (ll adv = cur; adv <= M; adv++) p += adv_p[i][cur][adv] * dp[S ^ mask][adv];\n            chmax(dp[S][cur], p);\n        }\n    }\n    return;\n}\n\nint main() {\n    cin >> N >> M;\n    MS = (1ll << N) - 1;\n    cats = make_v<double>(0., N, M);\n    for (auto &&v : cats) for (auto &&e : v) cin >> e;\n    for (auto &&v : dp) v[M] = 1.;\n    for (ll i = 0; i < N; i++) {\n        auto &cat = cats[i];\n        for (ll cur = 0; cur <= M; cur++) for (ll adv = cur; adv <= M; adv++) {\n            double p = 1.;\n            for (ll j = cur; j < adv; j++) p *= cat[j];\n            if (adv < M) p *= 1. - cat[adv];\n            adv_p[i][cur][adv] = p;\n        }\n    }\n\n    rec(0);\n    cout << dp[0][0] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef float real;\n\nreal dp[17][17][1 << 16];\nint n, m;\nreal p[17][17];\nreal solve(int stage, int now, int cats){\n\treal &res = dp[stage][now][cats];\n\tif(res != -1)return res;\n\tres = 0;\n\tif((1<<now) & cats)return res;\n\tif(stage == n)return res = 1;\n\t\n\tif(now == 16){\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tres = max(res, solve(stage, i, cats));\n\t\t}\n\t}\n\telse{\n\t\tres = solve(stage+1, now, cats) * p[now][stage]\n\t\t\t+ solve(stage, 16, cats | (1<<now)) * (1 - p[now][stage]);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\tfor(int i = 0;i < 17;i++)\n\t\tfor(int j = 0;j < 17;j++)\n\t\t\tfor(int k = 0;k < (1<<16);k++)\n\t\t\t\tdp[i][j][k] = -1;\n\n\tprintf(\"%.10lf\\n\", solve(0, 16, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static int used[N][1<<N]={};\n  static double mem[N][1<<N];\n  if(used[pos][bit]++) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\nmap<int,double> mem[N][1<<N];\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(mem[pos][bit].count(k)) return mem[pos][bit][k];\n  double p = neko[k][pos];\n  return mem[pos][bit][k] = p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 17;\n\ndouble a[MAX_N][MAX_N];\ndouble dp[1 << MAX_N][MAX_N];\nint m,n;\n\nint main()\n{\n\tscanf(\"%d%d\",&m,&n);\n    rep(i,m){\n        rep(j,n){\n    \t\tscanf(\"%lf\",&a[i][j]);\n    \t}\n    }\n    for(int i = (1 << m) - 1; i >= 0; i--){\n        for(int j = n-1; j >= 0; j--){\n            double mx = 0;\n            rep(k,m){\n                if(!(i & (1 << k))){\n                    double p = 1,res = 0;\n                    for(int l = j; l < n; l++){\n                        res += p * (1.0 - a[k][l]) * dp[i | (1 << k)][l];\n                        p *= a[k][l];\n                    }\n                    res += p;\n                    mx = max(res,mx);\n                }\n            }\n            dp[i][j] = mx;\n        }\n    }\n    printf(\"%.12lf\\n\",dp[0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m;\ndouble dp[(1<<16)][17][17];\ndouble a[20][20];\n\ndouble memo(int state,int now,int enemy){\n\tif(dp[state][now][enemy]!=0)return dp[state][now][enemy];\n\tdouble res=0;\n\tres+=memo(state,now,enemy+1)*a[now][enemy];\n\tdouble nowmax=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(state&(1<<i))continue;\n\t\tif(i==now)continue;\n\t\tnowmax=max(nowmax,memo(state|(1<<now),i,enemy));\n\t}\n\tres+=nowmax*(1-a[now][enemy]);\n\tdp[state][now][enemy]=res;\n\treturn dp[state][now][enemy];\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n\tcout<<fixed;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<n);i++)for(int j=0;j<n;j++){\n\t\tdp[i][j][m]=1;\n\t}\n\tdouble ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tans=max(ans,memo(0,i,0));\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\ndouble data[16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int s){\n  if(data[d][s] != -1) return data[d][s];\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    int ns = (s | (1 << i));\n    double np = 1.0;\n    double sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, ns) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np;\n    res = max(res, sum);\n  }\n  data[d][s] = res;\n  return res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\n//long double data[16][16][1<<16];\nlong double input[16][16];\n \nlong double func(int d, int c, int s){\n  long double res = 0.0;\n  for(int i=0;i<=n-d;i++){\n    long double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][c];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n        if((s >> j) & 1) continue;\n        /*if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n          else res += tmp * func(d+i, j, s|(1<<j));*/\n        res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n  }\n  //data[d][c][s] = res;\n  return res;\n}\n \nlong double solve(){\n  //fill(data[0][0], data[16][0], -1.0);\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, i, 1<<i));\n  }\n  return res;\n}\n \nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  //cout << solve() << endl;\n  printf(\"%.10Lf\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ndouble memo[16][1 << 16];\nbool   dp[16][1 << 16];\ndouble prob[16][16];\n\nint m, n;\n\ndouble solve(int pos, int flag){\n  if(pos == n)      return 1.0;\n  if(dp[pos][flag]) return memo[pos][flag];\n  dp[pos][flag] = true;\n\n  double ret = 0.0;\n\n  REP(i,m) if(flag & (1 << i)){\n    double p   = 1.0;\n    double tmp = 0.0;\n    for(int j = pos; j < n; j++){\n      double pp = p * prob[i][j];\n      tmp += (p - pp) * solve(j, flag ^ (1 << i));\n      p = pp;\n    }\n    tmp += p;\n    ret = max(ret, tmp);\n  }\n\n  return memo[pos][flag] = ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &m, &n);\n  REP(i,m) REP(j,n)\n    scanf(\"%lf\", &prob[i][j]);\n  printf(\"%.11f\\n\", solve(0, (1 << m) - 1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n;\ndouble t[16][16];\ndouble dp[16][(1<<16)];\ndouble Q[16][16];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      cin>>t[i][j];\n    }\n  }\n\n  \n\n  for(int S=(1<<m)-1;S>=0;S--){\n    dp[n][S]=1.0;\n    \n    for(int i=0;i<m;i++)Q[n][i]=1.0;\n    \n    for(int x=n-1;x>=0;x--){\n      for(int i=0;i<m;i++){\n        if(S>>i&1)continue;\n        dp[x][S]=max(dp[x][S],Q[x+1][i]*t[i][x]+(1.0-t[i][x])*dp[x][S|(1<<i)]);\n        Q[x][i]=dp[x][S|(1<<i)]*(1.0-t[i][x])+Q[x+1][i]*t[i][x];\n      }\n      \n    }\n  }\n  printf(\"%.12f\\n\",dp[0][0]);  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \nint n;\nint m;\ndouble dp[2][(1 << 16) + 1][17];\ndouble P[17][17];\n  \nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n  \n  int dst = 0;\n  int src = 1;\n  int lim = 1 << m;\n  for (int i=1; i<lim; i++) {\n    for (int j=0; j<m; j++) {\n      if (!(i >> j & 1)) continue;\n     dp[src][i][j] = 1.0;\n    }\n    dp[src][i][n] = 1.0;\n  }\n\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        cand += dp[dst][nst][m]*(1-P[j][i]);\n        cand += dp[src][st][j]*P[j][i];\n        dp[dst][st][j] = cand;\n        dp[dst][st][m] = max(dp[dst][st][m], cand);\n      }\n    }\n    swap(src, dst);\n    fill(dp[dst][0], dp[dst][lim], 0);\n  }\n  printf(\"%.20f\\n\", dp[src][lim-1][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ndouble dp[17][16][1<<16];\n\nint main(){\n  int m,n;\n  cin>>m>>n;\n  double g[16][16];\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      cin>>g[i][j];\n    }\n  }\n  for(int i=0;i<m;i++){\n    dp[0][i][(1<<m)-1^1<<i]=1;\n  }\n  for(int i=0;i<n;i++){\n    fill(*begin(dp[i+1&1]),*end(dp[i+1&1]),0);\n    for(int j=0;j<m;j++){\n      for(int k=(1<<m)-1;k>=0;k--){\n\tdp[i+1&1][j][k]=max(dp[i+1&1][j][k],dp[i&1][j][k]*g[j][i]);\n\tfor(int l=0;l<m;l++){\n\t  if(k>>l&1){\n\t    dp[i&1][l][k^1<<j]=max(dp[i&1][l][k^1<<j],dp[i&1][j][k]*(1-g[j][i]));\n\t  }\n\t}\n      }\n    }\n  }\n  double ans=0;\n  for(int i=0;i<m;i++){\n    for(int j=0;j<1<<m;j++){\n      ans+=dp[n&1][i][j];\n    }\n  }\n  cout.precision(99);\n  cout<<fixed<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint m,n;\ndouble p[16][16];\n\ndouble dp[1<<16][16];\ndouble dfs(int S,int pos){\n\tif(pos==n) return 1;\n\tif( S ==0) return 0;\n\n\tif(dp[S][pos]!=-1) return dp[S][pos];\n\n\tdouble res=0;\n\trep(i,m) if(S&1<<i) { // ツ猫 i ツづーツ派ツ個ュツつキツづゥ\n\t\tdouble tmp=0,q=1;\n\t\tfor(int j=pos;j<n;j++){ // j ツ氾板姪堋づ個敵ツづ可づ「ツづァツづェツつス\n\t\t\ttmp+=q*(1-p[i][j])*dfs(S&~(1<<i),j);\n\t\t\tq*=p[i][j];\n\t\t}\n\t\ttmp+=q*dfs(S&~(1<<i),n); // ツゴツーツδ?\n\t\tres=max(res,tmp);\n\t}\n\treturn dp[S][pos]=res;\n}\n\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\trep(i,m) rep(j,n) scanf(\"%lf\",p[i]+j);\n\n\trep(S,1<<m) rep(j,n) dp[S][j]=-1;\n\tprintf(\"%.15f\\n\",dfs((1<<m)-1,0));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?9e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ndouble dp[17][70000][17];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tdp[0][0][n]=1;\n\tvvd in(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\trep(i,m)rep(j,1<<n)rep(k,n+1){\n\t\tdouble t=dp[i][j][k];\n\t\tif(k<n){\n\t\t\tdp[i+1][j][k]+=t*in[k][i];\n\t\t\tdp[i][j|1<<k][n]+=t*(1-in[k][i]);\n\t\t}else{\n\t\t\trep(l,n)if((j&1<<l)==0){\n\t\t\t\tdp[i+1][j][l]+=t*in[l][i];\n\t\t\t\tdp[i][j|1<<l][n]+=t*(1-in[l][i]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,4){rep(j,3)cout<<\" \"<<dp[m][i][j];cout<<endl;}cout<<endl;\n\tvd out(1<<n);\n\trep(i,1<<n)rep(j,n)if((i&1<<j)==0)cmax(out[i|1<<j],out[i]+dp[m][i][j]);\n//\trep(i,out.size())cout<<\" \"<<out[i];cout<<endl;\n\tcout<<shosu(11)<<out[(1<<n)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint M, N;\ndouble dp[17][17][1 << 16];\ndouble p[17][17];\n\ntemplate <typename T>\nbool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> M >> N;\n    for(int i = 0; i < M; i++) {\n        for(int j = 0; j < N; j++) {\n            cin >> p[i][j];\n        }\n    }\n    for(int i = 1; i < (1 << M); i++) {\n        for(int j = 0; j < M; j++) {\n            if((1 << j) & i) {\n                //cerr << N << \" \" << j << \" \" << i << \" \" << 1 << endl;\n                dp[N][j][i] = 1;\n            }\n        }\n    }\n    for(int i = N - 1; i >= 0; i--) {\n        for(int j = 0; j < (1 << M); j++) {\n            for(int k = 0; k < M; k++) {\n                if(!(j & (1 << k))) continue;\n                double now = p[k][i] * dp[i+1][k][j];\n                double losemax = 0;\n                int subbits = (j & (~(1 << k)));\n                //cerr << subbits << endl;\n                for(int l = 0; l < M; l++) {\n                    if(!(subbits & (1 << l))) continue;\n                    chmax(losemax, dp[i][l][subbits]);\n                }\n                now += (1 - p[k][i]) * losemax;\n                chmax(dp[i][k][j], now);\n                //cerr << i << \" \" << k << \" \" << j << \" \" << now << \" \" << losemax << endl;\n            }\n        }\n    }\n    double ans = 0;\n    for(int i = 0; i < M; i++) {\n        chmax(ans, dp[0][i][(1 << M) - 1]);\n    }\n    cout << fixed << setprecision(30) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m;\ndouble p[22][22];\ndouble lose[1<<16][16];\ndouble win[1<<16][16][16];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m;\n  rep(i,n)rep(j,m){\n    cin>>p[i][j];\n  }\n  rep(i,n)win[0][i][0]=1.0;\n  rep(S,1<<n)rep(j,m){\n    rep(i,n){\n      if(((S>>i)&1)==0){\n        maxch(lose[S|(1<<i)][j],win[S][i][j]*(1-p[i][j]));\n        maxch(win[S][i][j+1],(win[S][i][j]+lose[S][j])*p[i][j]);\n      }\n    }\n  }\n  double res=0;\n  rep(S,1<<n)rep(i,n){\n    maxch(res,win[S][i][m]);\n  }\n  printf(\"%.10f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60;\nconst ll mod=1e9+7;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1};\ndouble dp[101010][20], a[20][20];\nint n, m;\ndouble rec(int mask, int x)\n{\n    if(dp[mask][x]!=-1)\n        return dp[mask][x];\n    if(x==m)\n        return dp[mask][x] = 1;\n    if(mask==0)\n        return dp[mask][x] = 0;\n    double ret = 0;\n    rep(i,n){\n        if(mask & 1<<i){\n            double res = 0,pos=1.0;\n            REP(j, x, m){\n                res += rec(mask ^ (1 << i), j) * pos * (1.0 - a[i][j]);\n                pos = pos * a[i][j];\n            }\n            res += pos;\n            ret = max(res, ret);\n        }\n    }\n    return dp[mask][x] = ret;\n}\nint main(){\n    cin >> n >> m;\n    rep(i,n)rep(j,m){\n        cin >> a[i][j];\n    }\n    int all = 1 << n;\n    rep(i, all) rep(j, m) dp[i][j] = -1;\n    cout << fixed << setprecision(12) << rec(all - 1, 0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint n,m;\ndouble v[22][22];\ndouble dp[1<<16][22];\n\ndouble dfs(int state,int num){\n\t\n\tif(dp[state][num] != -1)return dp[state][num];\n\tdouble ret = 0;\n\t\n\tREP(i,n){\n\t\tif(!(state & (1<<i))){\n\t\t\tdouble tmp = 0;\n\t\t\tdouble p = 1;\n\t\t\tfor(int k = num;k < m;k++){\n\t\t\t\ttmp += p * (1 - v[i][k]) * dfs(state|(1<<i),k);\n\t\t\t\tp *= v[i][k];\n\t\t\t}\n\t\t\tret = max(ret,tmp+p);\n\t\t}\n\t}\n\t\t\t\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tREP(i,1<<16)REP(j,22)dp[i][j] = -1;\n\t\t\n\tREP(i,n){\n\t\tREP(j,m){\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\t\n\tcout << Decimal << dfs(0,0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint M, N;\ndouble P[16][16];\n\nint i, j, k, S;\ndouble win, lose, ans;\ndouble dp[17][1 << 16][16];\n\nint main(void) {\n  cin >> M >> N;\n  for(i = 0; i < M; i++) for(j = 0; j < N; j++) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[i][S][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[N][S][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[i][S][j] = dp[i + 1][S][j] * P[j][i] + max(dp[i][S | (1 << k)][k]) * (1 - P[j][i])\n   *   where k not in S\n   */\n\n  for(S = 0; S < (1 << M); S++) for(j = 0; j < M; j++) dp[N][S][j] = 1;\n\n  for(i = N - 1; i >= 0; i--) {\n    for(S = (1 << M) - 1; S >= 0; S--) {\n      for(j = 0; j < M; j++) if(S & (1 << j)) {\n        win = dp[i + 1][S][j] * P[j][i];\n        lose = 0;\n        for(k = 0; k < M; k++) if(!(S & (1 << k))) {\n          lose = max(lose, dp[i][S | (1 << k)][k] * (1 - P[j][i]));\n        }\n        dp[i][S][j] = max(dp[i][S][j], win + lose);\n      }\n    }\n  }\n\n  ans = 0;\n  for(i = 0; i < M; i++) ans = max(ans, dp[0][1 << i][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic bool used[20];\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tcerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tdump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused[i] = false;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tm = atoi(s_);\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(20);\n\trep(i, T) {\n\t\tif (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16 \nusing namespace std;\nint m,n;\ndouble neko[N][N];\ndouble dfs(int pos,int k,int bit);\ndouble calc(int pos,int bit){\n  static int used[N][1<<N]={};\n  static double mem[N][1<<N];\n  if(used[pos][bit]++) return mem[pos][bit];\n  double mx = 0;\n  for(int i=0;i<m;i++)if(((bit>>i)&1)==0)mx=max(mx,dfs(pos,i,bit));\n  return mem[pos][bit] = mx;\n}\n\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  double p = neko[k][pos];\n  return p*dfs(pos+1,k,bit) + (1-p)*calc(pos,bit|(1<<k));\n}\n\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n  \n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,0));\n  printf(\"%.10f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<vector<double>> w(m, vector<double>(n));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> w[i][j];\n        }\n    }\n//    vector<vector<vector<double>>> dp(1 << m, vector<vector<double>>(n + 1, vector<double>(m, 0)));\n    vector<vector<double>> dp(1 << m, vector<double>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i < (1 << m); ++i) {\n        for (int k = 0; k < m; ++k) {\n            if ((i >> k) & 1) {\n                for (int j = 0; j < n; ++j) {\n                    double p = dp[i ^ (1 << k)][j];\n                    for (int l = j; l <= n; ++l) {\n                        dp[i][l] = max(dp[i][l], p * (1 - w[k][l]));\n                        p = p * w[k][l] + dp[i ^ (1 << k)][l + 1];\n                    }\n                }\n            }\n        }\n        // for (int j = 0; j <= n; ++j) {\n        //     cout << i << \" \" << j << \" \" << dp[i][j] << \"\\n\";\n        // }\n    }\n    printf(\"%.9lf\\n\", dp[(1 << m) - 1][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <random>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 16;\ndouble p[N][N];\n\ndouble dp[N][1 << N];\n\nint n, m;\ndouble rec(int i, int bits){\n\tif (bits == 0) return 0;\n\tif (i == n) return 1;\n\n\tdouble &res = dp[i][bits];\n\tif (res >= -.5) return res;\n\n\tres = 0;\n\n\trep(j, m){\n\t\tif (~bits >> j & 1) continue;\n\t\tint x = bits&~(1 << j);\n\t\tdouble pp = 1;\n\t\tdouble win = 0;\n\t\tfor (int k = i; k < n; ++k){\n\t\t\twin += pp*(1 - p[k][j])*rec(k, x);\n\t\t\tpp *= p[k][j];\n\t\t}\n\t\tres = max(res, win+pp);\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(12);\n\n\tcin >> m >> n;\n\trep(i, m) rep(j, n) cin >> p[j][i];\n\n\trep(i, N) rep(j, 1 << N) dp[i][j] = -1;\n\tcout << rec(0, (1 << m) - 1) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nconst int MAX = 16;\nusing D = double;\nD dp[MAX+1][1<<MAX];\nD pr[MAX][MAX];\nsigned main(){\n  int m,n;\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>pr[i][j];\n\n  int sz=1<<m;\n  for(int i=0;i<n;i++) dp[i][sz-1]=0;\n  dp[n][sz-1]=1;\n\n  for(int bit=sz-2;bit>=0;bit--){\n    for(int k=0;k<n;k++){\n      D &res=dp[k][bit];\n      for(int i=0;i<m;i++){\n        if((bit>>i)&1) continue;\n        int nxt=bit|(1<<i);\n        D cur=1,sum=0;\n        for(int j=k;j<n;j++){\n          sum+=dp[j+0][nxt]*cur*(1.0-pr[i][j]);\n          cur*=pr[i][j];\n        }\n        chmax(res,sum+cur);\n      }\n    }\n    dp[n][bit]=1;\n  }\n  cout<<dp[0][0]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n \nusing namespace std;\n \nint n, m;\ndouble data[16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int s){\n  if(d == n) return 1.0;\n  if(s == (1<<m)) return 0.0;\n  if(data[d][s] != -1) return data[d][s];\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    if(s & (1 << i)) continue;\n    double np = 1.0, sum = 0.0;\n    for(int j=d;j<n;j++){\n      sum += func(j, s|(1<<i)) * np * (1.0 - input[j][i]);\n      np *= input[j][i];\n    }\n    sum += np * func(n, s|(1<<i));\n    res = max(res, sum);\n  }\n  return data[d][s] = res;\n}\n \nmain(){\n  fill(data[0], data[16], -1.0);  \n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << func(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint m,n;\ndouble p[20][20];\nbool used[20][1<<16];\ndouble memo[20][1<<16];\ndouble dfs(int b,int k){\n  if(k==n) return 1.0;\n  if(used[k][b]) return memo[k][b];\n  used[k][b]=1;\n  double res=0;\n  for(int i=0;i<m;i++){\n    if((b>>i)&1) continue;\n    double tmp=0,pro=1.0;\n    for(int j=k;j<n;j++){\n      tmp+=pro*(1.0-p[i][j])*dfs(b+(1<<i),j);\n      pro*=p[i][j];\n    }\n    tmp+=pro;\n    res=max(res,tmp);\n  }\n  return memo[k][b]=res;\n}\nsigned main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++) cin>>p[i][j];\n  printf(\"%.12f\\n\",dfs(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef double real;\n\nreal dp[2][17][1 << 16];\nint n, m;\nreal p[17][17];\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++)\n\t\tfor(int j = 0;j < n;j++)\n\t\t\tcin >> p[i][j];\n\t\n\t\n\tfor(int j = 0;j < 17;j++)\n\t\tfor(int k = 0;k < (1<<16);k++)\n\t\t\tdp[n%2][j][k] = 1;\n\n\tfor(int i = n-1;i >= 0;i--){\n\t\tint id = i % 2;\n\t\tfor(int k = (1<<m)-1;k >= 0;k--){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tdp[id][j][k] = 0;\n\t\t\t\tif((1<<j) & k)continue;\n\t\t\t\tdp[id][j][k] = dp[!id][j][k] * p[j][i] + dp[id][16][k | (1<<j)] * (1-p[j][i]);\n\t\t\t}\n\t\t\tdp[id][16][k] = 0;\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tdp[id][16][k] = max(dp[id][16][k], dp[id][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\", dp[0][16][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define DEC(i, k) for (int i = (k); i >= 0; --i)\n#define FORIT(i, c) for (__tyoeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n#define ALL(c) (c).begin(), (c).end()\n\nint m, n;\ndouble probability[20][20];\ndouble dp[2][(1 << 16) + 10];\ndouble win[2][(1 << 16) + 10][20];\n\ninline int bsf(int x) {\n  __asm__(\"bsf %1, %0;\" :\"=r\"(x) :\"r\"(x));\n  return x;\n}\n\nint main() {\n  scanf(\"%d %d\", &m, &n);\n  MEMSET(probability, 0);\n  REP(cat, m) {\n    REP(room, n) {\n      scanf(\"%lf\", &probability[cat][room]);\n    }\n  }\n\n  MEMSET(dp, 0);\n  MEMSET(win, -1);\n  REP(S, 1 << m) {\n    dp[n % 2][S] = 1.0;\n  }\n  REP(S, 1 << m) {\n    REP(c, m) {\n      win[n % 2][S][c] = 1.0;\n    }\n  }\n\n  for (int i = n-1; i >= 0; --i) {\n    int curr = i % 2;\n    int prev = 1 - curr;\n    FOR(S, 0, 1 << m) {\n      dp[curr][S] = 0.0;\n      REP(c, m) {\n        if (S & (1 << c)) {\n          dp[curr][S] = max(dp[curr][S], win[curr][S^(1<<c)][c]);\n        }\n      }\n      REP(c, m) {\n        if (S != 0) {\n          win[curr][S][c] = probability[c][i] * win[prev][S][c]\n            + (1.0 - probability[c][i]) * dp[curr][S];\n        } else {\n          win[curr][S][c] = probability[c][i] * win[prev][S][c];\n        }\n      }\n    }\n  }\n\n  printf(\"%.9lf\\n\", dp[0][(1 << m) - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble dp[17][(1LL << 16) + 1];\ndouble nxt[17][(1LL << 16) + 1];\ndouble memo[1LL << 16][16][16];\n\ndouble rec(int mask, int now, int id){\n    if(id == n){\n        // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0 || (mask & (1LL << now)) == 0){\n        // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        if(i == now) continue;\n        double tmp = rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n    return memo[mask][now][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(j, 0, m) rep(k, 0, n + 1) memo[i][j][k] = -1.0;\n    double ans = 0.0;\n    rep(i, 0, m){\n        ans = max(ans, rec((1LL << m) - 1, i, 0));\n    }\n    // rep(i, 0, 1 << m){\n    //     rep(j, 0, m){\n    //         rep(k, 0, n + 1){\n    //             cout << i << ' ' << j << ' ' << k << ' ' << memo[i][j][k] << endl;\n    //         }\n    //     }\n    // }\n    printf(\"%.10f\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int n, m;\n    cin >> m >> n;\n    vector<vector<double>> v(n, vector<double>(m));\n    for(int i = 0; i < m; ++i)\n        for(int j = 0; j < n; ++j)\n            cin >> v[j][i];\n\n    vector<vector<double>> dp(n, vector<double>(1 << m, -1));\n\n    function<double(int,int)> f = [&](int pos, int mask){\n        if(dp[pos][mask] >= -0.5)\n            return dp[pos][mask];\n        dp[pos][mask] = 0;\n        for(int k = 0; k < m; ++k){\n            if(mask & (1 << k))\n                continue;\n            double per = 1.0;\n            double ret = 0;\n            for(int i = pos; i < n; ++i){\n                ret += per * (1.0 - v[i][k]) * f(i, mask | (1 << k));\n                per *= v[i][k];\n            }\n            ret += per;\n            chmax(dp[pos][mask], ret);\n        }\n        return dp[pos][mask];\n    };\n\n    printf(\"%.20lf\\n\", f(0, 0));\n    return false;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\nusing ld = double;\ntemplate <typename T>\nvector<T> Vec(int n, T v)\n{\n    return vector<T>(n, v);\n}\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    auto p = Vec(M, N, static_cast<ld>(0.0));\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> p[i][j];\n        }\n    }\n    const int maximum = 1 << M;\n    auto dp = Vec(maximum, M, static_cast<ld>(0.0));  // 残りネコ集合=i,戦闘ネコ=k,敵k-1まで倒した の状態から攻略する確率\n    for (int i = 0; i < maximum; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j] = (i & (1 << j)) ? 1 : 0;\n        }\n    }\n    auto sub = vector<ld>(maximum, static_cast<ld>(0.0));\n    for (int k = N - 1; k >= 0; k--) {\n        fill(sub.begin(), sub.end(), static_cast<ld>(0.0));\n        auto tmp = Vec(maximum, M, static_cast<ld>(0.0));\n        for (int i = 0; i < maximum; i++) {\n            for (int j = 0; j < M; j++) {\n                if (i & (1 << j)) {\n                    tmp[i][j] = p[j][k] * dp[i][j] + (1 - p[j][k]) * sub[i - (1 << j)];\n                    sub[i] = max(sub[i], tmp[i][j]);\n                }\n            }\n        }\n        dp = tmp;\n    }\n    cout << fixed << setprecision(15) << sub[maximum - 1] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint m, n;\ndouble p[16][16], a[16][1 << 16];\ndouble rec(int c, int bit){\n\tif(c >= n) return 1;\n\tif(bit == 0) return 0;\n\t\n\tdouble &res = a[c][bit];\n\tif(res >= 0) return res;\n\tres = 0;\n\trep(i, m) if(bit & 1 << i){\n\t\tdouble t = 1, sum = 0;\n\t\tfor(int j = c; j < n; j++){\n\t\t\tsum += t * (1 - p[i][j]) * rec(j, bit ^ 1 << i);\n\t\t\tt *= p[i][j];\n\t\t}\n\t\tsum += t;\n\t\tres = max(res, sum);\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin >> m >> n;\n\trep(i, m) rep(j, n) cin >> p[i][j];\n\trep(i, n) rep(j, 1 << m) a[i][j] = -1;\n\tprintf(\"%.9f\\n\", rec(0, (1 << m) - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int m, n; cin >> m >> n;\n  vector<vector<double>> p(m, vector<double>(n));\n  for(int i=0;i<m;++i) {\n    for(int j=0;j<n;++j) {\n      cin >> p[i][j];\n    }\n  }\n  vector<vector<vector<double>>> dp(m, vector<vector<double>> (2, vector<double>(1<<m, 0.0)));\n  for(int i=0;i<m;++i) {\n    for(int k=0;k<(1<<m);++k) {\n      dp[i][n%2][k] = 1;\n    }\n  }\n  for(int j=n-1;j>=0;--j) {\n    int nj = j % 2;\n    for(int k=(1<<m)-1;k>=0;--k) {\n      for(int i=0;i<m;++i) {\n        if (!((k >> i) & 1)) {\n          continue;\n        }\n        for (int l = 0; l < m; ++l) {\n          if (!((k >> l) & 1)) dp[i][nj][k] = max(dp[i][nj][k], (1 - p[i][j]) * dp[l][nj][k | (1 << l)]);\n        }\n        dp[i][nj][k] += p[i][j] * dp[i][!nj][k];\n      }\n    }\n    for(int i=0;i<m;++i) {\n      for(int k=0;k<(1<<m);++k) {\n        dp[i][!nj][k] = 0;\n      }\n    }\n  }\n  double ans = 0.0;\n  for(int i=0;i<m;++i) {\n    for(int k=0;k<(1<<m);++k) {\n      ans = max(ans, dp[i][0][k]);\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l <= n + 1; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout << setprecision(10) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble dp[1 << 16][17];\ndouble ans = 0;\n\ntypedef tuple<int,int,double> T;\nmap<T, double> s;\n\ndouble dfs(int nekos, int room, double q){\n\tif(s.count(T(nekos, room, q))) return s[T(nekos, room, q)];\n\t//if(dp[nekos][room] != -1) return dp[nekos][room];\n\n\tdouble res = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\n\t\tdouble sum = 0;\n\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t}\n\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t//cout << bitset<2>(nekos) << ' '<<room << ' ' << sum << endl;\n\t\tres = max(res,sum);\n\t}\n\n\t//cout << \"res  \" << bitset<2>(nekos) << ' ' << room << ' ' << res << endl;\n\treturn s[T(nekos, room, q)] = res;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\t//show(neko[i][j][j])\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t\t//cout << neko[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,17) dp[i][j] = -1;\n\tcout <<fixed << setprecision(10) <<  dfs(0, 0, 1) << endl;\n\treturn 0;\n\n\t/*\n\trep(s, 1 << n){\n\t\trep(i,n){\n\t\t\tif(getBit(s,i)) continue;\n\n\t\t\tdouble q = dp[s][i][kkk\n\t\t\tdouble sum = 0;\n\n\t\t\tsum += q * neko[i][room][m - 1]; // 最後まで倒しきる\n\t\t\trep(j,m - room - 1){ // j + 1 勝する\n\t\t\t\tsum += dfs(setBit(nekos, i), room + j + 1, q * neko[i][room][j + room] * (1 - p[i][room + j + 1]));\n\t\t\t}\n\t\t\tsum += dfs(setBit(nekos, i), room, q * (1 - p[i][room])); // 初戦敗退\n\n\t\t\trep(j,m - room - 1){\n\n\t\t\t}\n\t\t}\n\t}\n\t*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\n//double neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble memo[1 << 16][17][17];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\t//rep(i,n){\n\t//\trep(j,m){\n\t//\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t//\t\trange(k,j + 1,m){\n\t//\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\trep(i,1 << 16) rep(j,17) rep(k,17) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2237&lang=jp\ntypedef long long ll;\nconst int INF = 1e9;\nint M, N;\ndouble p[16][16];\ndouble dp[16][1 << 16];\ndouble solve(int n, int bit) {\n\tif (n == N) return 1;\n\tdouble& ret = dp[n][bit];\n\tif (ret != -1)return ret;\n\tret = 0;\n\tfor (int i = 0; i < M;i++) {\n\t\tif (bit&(1 << i)) continue;\n\t\tdouble temp = 0, temp_p = 1;\n\t\tfor (int j = n; j < N;j++) {\n\t\t\ttemp += temp_p*(1 - p[i][j])*solve(j, bit | (1 << i));\n\t\t\ttemp_p *= p[i][j];\n\t\t}\n\t\ttemp += temp_p;\n\t\tret = max(ret, temp);\n\t}\n\treturn ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tcin >> M >> N;\n\tfor (int i = 0; i < M;i++) for (int j = 0; j < N;j++) cin >> p[i][j];\n\tfill(dp[0], dp[16], -1);\n\tcout << fixed << setprecision(10)<< solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic bool used[20];\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tdump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused[i] = false;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nint n,m;\nfloat dp[1<<16][16][16];\nfloat dp2[1<<16][17];\ndouble data[17][17];\n\ndouble memo(int bit,int v,int c){\n\tif(v==n)return 1.0;\n\tif(bit==0)return 0.0;\n\tif(dp[bit][v][c]>=0.0)return dp[bit][v][c];\n\tdouble lost=0.0;\n\tint lbit=bit-(1<<c);\n\tif(dp2[lbit][v]>=0.0)lost=dp2[lbit][v];\n\telse{\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(lbit>>i & 1){\n\t\t\t\tlost=max(lost,memo(lbit,v,i));\n\t\t\t}\n\t\t}\n\t\tdp2[lbit][v]=lost;\n\t}\n\tdouble res=memo(bit,v+1,c)*data[c][v]+lost*(1.0-data[c][v]);\n\treturn dp[bit][v][c]=res;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%lf\",&data[i][j]);\n\t\t}\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tdouble res=0.0;\n\tfor(int i=0;i<m;i++){\n\t\tres=max(res,memo((1<<m)-1,0,i));\n\t}\n\tprintf(\"%.10f\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m;\ndouble p[22][22];\ndouble sum[17][17][1<<16];\ndouble dp[17][1<<16];\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)rep(j,m){\n    cin>>p[j][i];\n  }\n  rep(S,1<<n){\n    dp[m][S]=1.0;\n    rep(i,n)sum[m][i][S]=1.0;\n  }\n  for(int i=m-1;i>=0;i--)for(int S=(1<<n)-1;S>=0;S--){\n      rep(j,n){\n        if(((S>>j)&1))continue;\n        maxch(dp[i][S],(1.0-p[i][j])*dp[i][S|(1<<j)]+sum[i+1][j][S]*p[i][j]);\n      }\n      rep(j,n){\n        if(!((S>>j)&1))continue;\n        int T=S^(1<<j);\n        sum[i][j][T]+=sum[i+1][j][T]*p[i][j]+(1.0-p[i][j])*dp[i][S];\n      }\n  }\n  double res=0;\n  rep(i,n)maxch(res,sum[0][i][0]);\n  printf(\"%.10f\\n\", res);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\ndouble dp[17][(1 << 16) + 1];\ndouble P[17][17];\n\nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n\n  int lim = 1 << m;\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        for (int k=i; k<n; k++) {\n          cand += dp[k][nst]*p*(1-P[j][k]);\n          p *= P[j][k];\n        }\n        cand += p;\n        dp[i][st] = max(dp[i][st], cand);\n      }\n    }\n  }\n  printf(\"%.20f\\n\", dp[0][lim-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef double real;\n\nreal dp[2][17][1 << 16];\nint n, m;\nreal p[17][17];\n\nint main(){\n\tcin >> m >> n;\n\tfor(int i = 0;i < m;i++)\n\t\tfor(int j = 0;j < n;j++)\n\t\t\tcin >> p[i][j];\n\t\n\t\n\tfor(int j = 0;j < 17;j++)\n\t\tfor(int k = 0;k < (1<<16);k++)\n\t\t\tdp[n%2][j][k] = 1;\n\n\tfor(int i = n-1;i >= 0;i--){\n\t\tint id = i % 2;\n\t\tfor(int k = (1<<m);k >= 0;k--){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tdp[id][j][k] = 0;\n\t\t\t\tif((1<<j) & k)continue;\n\t\t\t\tdp[id][j][k] = dp[!id][j][k] * p[j][i] + dp[id][16][k | (1<<j)] * (1-p[j][i]);\n\t\t\t}\n\t\t\t\t\t\tdp[id][16][k] = 0;\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tdp[id][16][k] = max(dp[id][16][k], dp[id][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\", dp[0][16][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n,m;\ndouble p[20][20];\ndouble dp[20][1<<16];\n\nint main(void){\n\tcin >> m >> n;\n\trep(i,m)rep(j,n) cin >> p[j][i];\n\tdp[0][0]=1.0;\n\trep(i,n)rep(mask,1<<m){\n\t\tint idx=-1;\n\t\tdouble cmax=0.0;\n\t\trep(j,m){\n\t\t\tif(mask&(1<<j)) continue;\n\t\t\tif(cmax<p[i][j]) cmax=p[i][j],idx=j;\n\t\t}\n\t\tif(idx==-1) continue;\n\t\tdouble cur=1.0;\n\t\tint nmask=mask|(1<<idx);\n\t\trange(ni,i,n){\n\t\t\tdouble pp=cur*(1.0-p[ni][idx]);\n\t\t\tdp[ni][nmask]+=dp[i][mask]*pp;\n\t\t\tcur*=p[ni][idx];\n\t\t}\n\t\tdp[n][nmask]+=dp[i][mask]*cur;\n\t}\n\tdouble ans=0.0;\n\trep(mask,1<<m) ans+=dp[n][mask];\n\tcout.precision(20);\n\tcout << fixed << ans  << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint M, N;\ndouble P[16][16];\ndouble dp[1 << 16][16][16];\n\nint main(void) {\n  cin >> M >> N;\n  REP(i, 0, M) REP(j, 0, N) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[S][i][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[S][N][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[S][i][j] = dp[S][i + 1][j] + max(dp[S | (1 << k)][i][k])\n   *   where k not in S\n   */\n\n  REP(S, 0, 1 << M) REP(i, 0, N + 1) REP(j, 0, N) dp[S][i][j] = 0;\n  REP(S, 0, 1 << M) REP(j, 0, M) dp[S][N][j] = 1;\n\n  for(int S = (1 << M) - 1; S >= 0; S--) {\n    for(int i = N - 1; i >= 0; i--) {\n      REP(j, 0, M) if(S & (1 << j)) {\n        double x = i + 1 < N ? dp[S][i + 1][j] : 1;\n        dp[S][i][j] = max(dp[S][i][j], x * P[j][i]);\n        REP(k, 0, M) if(!(S & (1 << k))) {\n          double p = x * P[j][i] + dp[S | (1 << k)][i][k] * (1 - P[j][i]);\n          dp[S][i][j] = max(dp[S][i][j], p);\n        }\n      }\n    }\n  }\n\n  // REP(S, 0, 1 << M) {\n  //   printf(\"S = %d:\\n\", S);\n  //   REP(i, 0, N + 1) {\n  //     printf(\"  i = %d: \", i);\n  //     REP(j, 0, M) printf(\"%.4lf \", dp[S][i][j]);\n  //     printf(\"\\n\");\n  //   }\n  //   printf(\"\\n\");\n  // }\n\n  double ans = 0;\n  REP(i, 0, M) ans = max(ans, dp[1 << i][0][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint m, n;\ndouble prob[16][16];\ndouble dp[16][1<<16];\n\ndouble search(int pos, int cat){\n\tif(dp[pos][cat] > -0.5) return dp[pos][cat];\n\tdouble& res = dp[pos][cat];\n\tres = 0.0;\n\tfor(int i=0;i<m;i++){\n\t\tif(cat&(1<<i)) continue;\n\t\tdouble pSum = 0.0;\n\t\tdouble pCur = 1.0;\n\t\tfor(int j=pos;j<n;j++){\n\t\t\tpSum += (1-prob[i][j])*pCur*search(j, cat|(1<<i));\n\t\t\tpCur *= prob[i][j];\n\t\t}\n\t\tpSum += pCur;\n\t\tres = max(res, pSum);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> m >> n){\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++) cin >> prob[i][j];\n\t\t}\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<(1<<m);j++) dp[i][j] = -1.0;\n\t\t}\n\t\tprintf(\"%.10lf\\n\", search(0, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\ndouble prob[16][16];\ndouble dp[1<<16][17][16];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  REP(i,M) REP(j,N) cin >> prob[i][j];\n\n  double ans = 0.;\n  FOR(b,1,1<<M) REP(i,M)\n\tif(b>>i&1) dp[b][N][i] = 1.;\n  for(int b=1;b<1<<M;++b){\n\tfor(int i=N-1;i>=0;--i){\n\t  for(int j=0;j<M;++j){\n\t\tif(b>>j&1 == 0) continue;\n\t\tint x = 0;\n\t\tREP(k,M) if((b>>k&1) && dp[b&~(1<<j)][i][k] > dp[b&~(1<<j)][i][x])\n\t\t  x = k;\n\t\tdp[b][i][j] = max(dp[b][i][j],\n\t\t\t\t\t\t  prob[j][i] * dp[b][i+1][j]\n\t\t\t\t\t\t  + (1. - prob[j][i]) * dp[b&~(1<<j)][i][x]);\n\t  }\n\t}\n  }\n\n  REP(i,M)\n\tans = max(ans, dp[(1<<M)-1][0][i]);\n  cout << fixed << setprecision(10) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l <= n + 1; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout <<fixed<< setprecision(20) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int m, n; cin >> m >> n;\n\n    auto P = make_v<double>(m, n);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> P[i][j];\n        }\n    }\n\n    auto dp = make_v<double>(2, m+1, 1<<m);\n    for (int s = 0; s < 1<<m; ++s) {\n        for (int p = 0; p <= m; ++p) {\n            dp[n & 1][p][s] = 1;\n        }\n    }\n\n    for (int j = n-1; j >= 0; --j) {\n        for (int s = 0; s < 1<<m; ++s) {\n            for (int i = 0; i <= m; ++i) {\n                dp[j & 1][i][s] = 0;\n            }\n        }\n        for (int s = 0; s < 1<<m; ++s) {\n            for (int i = 0; i < m; ++i) if (s >> i & 1) {\n                chmax(dp[j & 1][i][s], P[i][j] * dp[j+1 & 1][i][s] +\n                             (1-P[i][j]) * dp[j & 1][m][s & ~(1<<i)]);\n                chmax(dp[j & 1][m][s], P[i][j] * dp[j+1 & 1][i][s] +\n                             (1-P[i][j]) * dp[j & 1][m][s & ~(1<<i)]);\n            }\n        }\n    }\n\n    cout << dp[0][m][(1<<m)-1] << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint m,n;\ndouble dp[17][(1<<16) + 1];\ndouble prob[17][17];\n\ndouble calc(int f, int s, double p) {\n\n    if (f == n)   return p;\n    if (dp[f][s]) return dp[f][s];\n\n    double ret = 0;\n    for (int k=0; k<m; ++k) if (!(s & (1<<k))) { // ???????????????????????????\n        double cp = p;\n        double sum = 0;\n        for (int j=f; j<n && cp > 0.0; ++j) { // ?????????????????¢\n            sum += calc(j, s|(1<<k), cp * (1.0 - prob[k][j]));\n            cp *= prob[k][j];\n        }\n        // ???????????§???????¶????????¢????(????????§?¢????0????????£?????????????????§??§??????\n        sum += cp;\n        ret = max(ret, sum);\n    }\n    //printf(\"f:%d\\ts:%d\\tp:%f\\tret:%f\\n\",f,s,p,ret);\n    return dp[f][s] = ret;\n}\n\nint main() {\n    cin >> m >> n;\n    for (int i=0; i<m; ++i) {\n        for (int j=0; j<n; ++j) {\n            cin >> prob[i][j];\n        }\n    }\n\n    printf(\"%.12f\\n\", calc(0, 0, 1.0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[22][22][1<<17];\nint n,m;\n\ndouble DFS(int idx, int state, int cidx){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][cidx][state] >= -0.1)return dp[idx][cidx][state];\n\tif(cidx!=21)return dp[idx][cidx][state] = p[cidx][idx]*DFS(idx+1, state, cidx)+(1-p[cidx][idx])*DFS(idx, (state|(1<<cidx)), 21);\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state, i)+(1-p[i][idx])*DFS(idx, (state|mask), 21));\n\t}\n\treturn dp[idx][cidx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,22)REP(k,(1<<m))dp[i][j][k]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0,21));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing R = long double;\n\nconst int N = 17;\nR memo[N][1<<(N-1)], p[N][1<<(N-1)];\n\nint m, n;\n\nR rec(int ri, int used){\n    R& ret = memo[ri][used];\n    if(ret > 0) return ret;\n\n    ret = 0.0;\n\n    rep(i, m){\n        R cur = 0.0;\n\n        if(used & (1 << i)) continue;\n        int nused = used | (1 << i);\n\n        R won_p = 1.0;\n        rep(nri, ri, n){\n            cur += won_p * (1.0 - p[i][nri]) * rec(nri, nused);\n            won_p *= p[i][nri];\n        }\n        cur += won_p;\n\n        chmax(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> m >> n;\n    rep(i, m) rep(j, n) cin >> p[i][j];\n\n    cout.precision(20);\n    cout << fixed << rec(0, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\ndouble dp[1<<16][18]={};\n\nint main()\n{\n    int m,n;\n    scanf(\" %d %d\", &m, &n);\n\n    double p[16][16]={};\n    rep(i,m)rep(j,n) scanf(\" %lf\", &p[i][j]);\n\n    dp[0][0] = 1;\n    rep(mask,1<<m)\n    {\n        rep(i,m)if(!(mask>>i&1))\n        {\n            int nmask = mask|(1<<i);\n            double now = 0;\n            rep(j,n+1)\n            {\n                now += dp[mask][j];\n                dp[nmask][j] = max(dp[nmask][j], now*(1-p[i][j]));\n                if(j<n) now *= p[i][j];\n            }\n        }\n    }\n    \n    printf(\"%.10f\\n\", dp[(1<<m)-1][n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][16][16];\n\ndouble rec(int mask, int now, int id){\n    if(id == n){\n        // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0 || (mask & (1LL << now)) == 0){\n        // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        if(i == now) continue;\n        double tmp = rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n    return memo[mask][now][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(j, 0, m) rep(k, 0, n + 1) memo[i][j][k] = -1.0;\n    double ans = 0.0;\n    rep(i, 0, m){\n        ans = max(ans, rec((1LL << m) - 1, i, 0));\n    }\n    // rep(i, 0, 1 << m){\n    //     rep(j, 0, m){\n    //         rep(k, 0, n + 1){\n    //             cout << i << ' ' << j << ' ' << k << ' ' << memo[i][j][k] << endl;\n    //         }\n    //     }\n    // }\n    printf(\"%.10f\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ndouble memo[16][1 << 16];\nbool   dp[16][1 << 16];\ndouble prob[16][16];\n\nint m, n;\n\ndouble solve(int, int);\n\ninline double solve2(int pos, int flag){\n  if(dp[pos][flag]) return memo[pos][flag];\n  return solve(pos, flag);\n}\n\ndouble solve(int pos, int flag){\n  double ret = 0.0;\n  dp[pos][flag] = true;\n  REP(i,m) if(flag & (1 << i)){\n    double p   = 1.0;\n    double tmp = 0.0;\n    for(int j = pos; j < n; j++){\n      double pp = p * prob[i][j];\n      tmp += (p - pp) * solve2(j, flag ^ (1 << i));\n      p = pp;\n    }\n    tmp += p;\n    ret = max(ret, tmp);\n  }\n\n  return memo[pos][flag] = ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &m, &n);\n  REP(i,m) REP(j,n)\n    scanf(\"%lf\", &prob[i][j]);\n  printf(\"%.11f\\n\", solve(0, (1 << m) - 1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define all(a) begin(a),end(a)\n#define ifnot(a) if(not (a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n// #define int ll\n#ifdef _MSC_VER\nconst bool test = true;\n#else \nconst bool test = false;\n#endif\n\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\nconst int INF = 1 << 28;\nconst ll INFL = (ll)1 << 58;\nll mod = (int)1e9 + 7;\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nchar s_[MAX];\nint n, m;\ndouble board[20][20];\n\ndouble dfs(int reached) {\n\tstatic int used;\n\tstatic map<pair<int,int>, double> dp;\n\tstatic map<pair<int,int>, bool> done;\n\tpair<int,int> cur_status = {used, reached};\n\n\tif (done[cur_status] == true) {\n\t\treturn dp[cur_status];\n\t}\n\tdouble res = 0.0;\n\tif (reached == n) {\n\t\treturn 1.0;\n\t\tif (test) cerr << \"!\";\n\t}\n\trep(i, m) {\n\t\tif ((used >> i) & 1) continue;\n\t\tused |= 1 << i;\n\t\tdouble res_i = 0.0;\n\t\tdouble keep_win_p = 1.0;\n\t\tREP(j, reached, n) {\n\t\t\tres_i += dfs(j) * keep_win_p * (1.0 - board[i][j]);\n\t\t\tif (test) dump(dfs(j));\n\t\t\tkeep_win_p *= board[i][j];\n\t\t}\n\t\tres_i += keep_win_p;\n\t\tchmax(res, res_i);\n\t\tused ^= 1 << i;\n\t}\n\tdone[cur_status] = true;\n\treturn dp[cur_status] = res;\n}\n\nvoid solve() {\n\t// m = atoi(s_);\n\tcin >> m;\n\tcin >> n;\n\trep(i, m) rep(j, n) cin >> board[i][j];\n\tcout << dfs(0) << endl;\n}\n\nsigned main() {\n\tint T = 10;\n\tcout << fixed << setprecision(15);\n\trep(i, T) {\n\t\t// if (scanf(\"%s\", s_) == EOF) break;\n\t\tsolve();\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint n;\nint m;\ndouble dp[17][(1 << 16) + 1];\ndouble P[17][17];\n \nint main() {\n  scanf(\"%d%d\", &m, &n);\n  for (int i=0; i<m; i++) {\n    for (int j=0; j<n; j++) {\n      scanf(\"%lf\", &P[i][j]);\n    }\n  }\n \n  int lim = 1 << m;\n  for (int i=n-1; i>=0; --i) {\n    for (int st=0; st<lim; ++st) {\n      if(st) dp[n][st] = 1.0;\n      for (int j=0; j<m; j++) {\n        if (!(st >> j & 1)) continue;\n        double p = 1.0;\n        double cand = 0.0;\n        int nst = st & ~(1 << j);\n        cand += dp[i][nst]*(1-P[j][i]);\n        cand += dp[i+1][st]*P[j][i];\n        dp[i][st] = max(dp[i][st], cand);\n      }\n    }\n  }\n  printf(\"%.20f\\n\", dp[0][lim-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>lives) {\n\tconst int a = lives.to_ulong();\n\tif (!memo[now][a]<0) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < lives.size(); ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\n\tld ans = check(0, bitset<16>((1<<16)-1));\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ndouble p[22][22];\ndouble dp[22][1<<17];\nint n,m;\n\ndouble DFS(int idx, int state){\n\tif(idx == n)return 1.0;\n\tif(dp[idx][state] >= -0.1)return dp[idx][state];\n\tdouble ret = -0.1;\n\tREP(i,m){\n\t\tint mask = (1<<i);\n\t\tif(mask & state)continue;\n\t\tret = max(ret,p[i][idx]*DFS(idx+1, state)+(1-p[i][idx])*DFS(idx, (state|mask)));\n\t}\n\treturn dp[idx][state] = max(ret, 0.0);\n}\n\nint main(){\n\tscanf(\"%d%d\", &m, &n);\n\tREP(i,m)REP(j,n)scanf(\"%lf\", &p[i][j]);\n\tREP(i,n)REP(j,(1<<m))dp[i][j]=-1.0;\n\tprintf(\"%.10f\\n\", DFS(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint main(){\n  int n, m;\n  cin >> n >> m;\n  double dp[1<<n][m], prob[n][m];\n  for(int i = 0; i < (1<<n); ++i){\n    fill(dp[i],dp[i]+m,0);\n  }\n  //fill(dp[0],dp[0]+m,0);//テァツ個ォテ」ツ?古・ツ?ィテ」ツ?ヲテ・ツ?津」ツつ古」ツ?ヲテ」ツつ凝」ツ?ョテ」ツ?ァ0\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  \n  for(int bit = 0; bit < (1<<n); ++bit){\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(bit>>j & 1){\n\t  double t = 0, p = 1.0;\n\t  for(int k = i; k < m; ++k){\n\t    t += p*(1.0 - prob[j][k])*dp[bit-(1<<j)][k];\n\t    p *= prob[j][k];\n\t  }\n\t  t += p;\n\t  dp[bit][i] = max(dp[bit][i],t);\n\t}\n      }\n    }\n  }\n\n  double ans = dp[(1<<n)-1][0];\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n//ld dp[17][1 << 16] = {0}; // dp[next enemy][used cat]\n\nint N, M;\nld P[16][16];\n\nbool m1[16][1 << 16] = {0};\nld m2[16][1 << 16];\n\nld dp(int n, int rest) {\n\tif (n >= N) return (ld)1;\n\n\tif (m1[n][rest]) return m2[n][rest];\n\n\tld ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld p = 0;\n\t\tif (rest & (1 << i)) {\n\t\t\tint nr = rest & ~(1 << i);\n\n\t\t\tld per = 1;\n\t\t\tfor (int j = n; j < N; ++j) {\n\t\t\t\tp += per * (1 - P[i][j]) * dp(j, nr);\n\t\t\t\tper *= P[i][j];\n\t\t\t}\n\t\t\tp += per;\n\t\t}\n\t\tret = max(ret, p);\n\t}\n\treturn m1[n][rest] = true, m2[n][rest] = ret;\n}\nint main() {\n\tcin >> M >> N;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tprintf(\"%.12f\\n\", (double)dp(0, (1 << M)-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?9e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ndouble dp[17][70000][17];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tdp[0][0][n]=1;\n\tvvd in(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\trep(i,m)rep(j,1<<n)rep(k,n+1){\n\t\tdouble t=dp[i][j][k];\n\t\tif(k<n){\n\t\t\tdp[i+1][j][k]+=t*in[k][i];\n\t\t\tdp[i][j|1<<k][n]+=t*(1-in[k][i]);\n\t\t}else{\n\t\t\trep(l,n)if((j&1<<l)==0){\n\t\t\t\tdp[i+1][j][l]+=t*in[l][i];\n\t\t\t\tdp[i][j|1<<l][n]+=t*(1-in[l][i]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,4){rep(j,3)cout<<\" \"<<dp[1][i][j];cout<<endl;}\n\tdouble out=0;\n\trep(i,1<<n)rep(j,n+1)out=max(out,dp[m][i][j]);\n\tcout<<shosu(11)<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ndouble dp[2][16][1<<16];\n\nint main(){\n  int m,n;\n  cin>>m>>n;\n  double g[16][16];\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      cin>>g[i][j];\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<1<<m;j++){\n      if(j>>i&1)continue;\n      dp[n&1][i][j]=1;\n    }\n  }\n  for(int i=n-1;i>=0;i--){\n    for(int j=0;j<1<<m;j++){\n      for(int k=0;k<m;k++){\n\tdp[i&1][k][j]=0;\n\tif(!(j>>k&1)){\n\t  dp[i&1][k][j]=dp[i+1&1][k][j]*g[k][i];\n\t  for(int l=0;l<m;l++){\n\t    if(j>>l&1){\n\t      dp[i&1][k][j]=max(dp[i&1][k][j],dp[i+1&1][k][j]*g[k][i]+dp[i&1][l][j^1<<l]*(1-g[k][i]));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  double ans=0;\n  for(int i=0;i<m;i++){\n    ans=max(ans,dp[0][i][(1<<m)-1^1<<i]);\n  }\n  cout.precision(9);\n  cout<<fixed<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\nconst double INF = (1<<30);\n\nint n,m;\ndouble cat[N][M];\ndouble memo[M][T][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\ndouble solve(){\n\trep(i,M)rep(j,T)rep(k,N)memo[i][j][k]=INF;\n\treturn 1.0;\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint m,n;\ndouble dp[17][(1<<16) + 1];\ndouble prob[17][17];\n\ndouble calc(int f, int s, double p) {\n\n    if (f == n)   return p;\n    if (dp[f][s]) return dp[f][s];\n\n    double ret = 0;\n    for (int k=0; k<m; ++k) if (!(s & (1<<k))) { // ???????????????????????????\n        double cp = p;\n        double sum = 0;\n        for (int j=f; j<n; ++j) { // ?????????????????¢\n            sum += calc(j, s|(1<<k), cp * (1.0 - prob[k][j]));\n            cp *= prob[k][j];\n        }\n        // ???????????§???????¶????????¢????\n        sum += cp;\n        ret = max(ret, sum);\n    }\n    return dp[f][s] = ret;\n}\n\nint main() {\n    cin >> m >> n;\n    for (int i=0; i<m; ++i) {\n        for (int j=0; j<n; ++j) {\n            cin >> prob[i][j];\n        }\n    }\n\n    printf(\"%.12f\\n\", calc(0, 0, 1.0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>lives) {\n\tconst int a = lives.to_ulong();\n\tif (!memo[now][a]<0) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\n\tld ans = check(0, bitset<16>((1<<16)-1));\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\nconst int INF = (1<<30);\n\nint n,m;\ndouble cat[M][N];\n\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring getbit(int state,int n){\n\tstring ret = \"\";\n\trep(i,n)ret += has(state,i) ? '1' : '0';\n\treturn ret;\n}\n\ndouble dp[2][T][N];\ndouble solve_dp(){\n\tint t = (1<<n);\n\trep(i,m){\n\t\trep(j,T)rep(k,N)dp[i%2][j][k]=0.0;\n\t\tfor(int j=t-1;j>=0;j--){\n\t\t\trep(k,n){\n\t\t\t\tif(has(j,k))continue;\n\t\t\t\t\n\t\t\t\tdouble befval = 1.0;\n\t\t\t\tif(i!=0)befval = dp[(i+1)%2][j][k];\n\t\t\t\tdouble win = cat[k][m-1-i];\n\t\t\t\t\n\t\t\t\tdouble mini = 0;\n\t\t\t\t\n\t\t\t\tdouble ans1 = befval * win;\n\t\t\t\t\n\t\t\t\tmini = max(mini, ans1);\n\t\t\t\trep(p,n){\n\t\t\t\t\tint next = j^(1<<k);\n\t\t\t\t\tif(!has(next,p)){\n\t\t\t\t\t\tdouble ans2 = dp[i%2][j^(1<<k)][p] * (1-win);\n\t\t\t\t\t\tmini = max(mini, ans2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i%2][j][k] = mini;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\trep(i,m){\n\t\trep(j,t){\n\t\t\trep(k,n){\n\t\t\t\tprintf(\"%s-%d  %lf | \",getbit(j,n).c_str(),k,dp[i][j][k]);\n\t\t\t}puts(\"\");\n\t\t}puts(\"\");\n\t}*/\n\t\n\tdouble ret = 0;\n\trep(i,n)ret += dp[(m-1)%2][0][i];\n\t\n\t\n\treturn ret;\n}\n\ndouble solve(){\n\treturn solve_dp();\n}\n\n\nint main(){\n\tinput();\n\tprintf(\"%.12f\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n#define all(n) n.begin(),n.end()\n#define clr(n) memset(n,0,sizeof(n))\n#define mclr(n) memset(n,-1,sizeof(n))\n\n//dp[bit][i][j] ?´???£??????????????????bit???i???????????¨?±????j?????????????????????\n//??¨??¨????????????????¢????\ndouble dp[1 << 16][16][16];\n\n//ap[i][j][k] ???i ?????¨?±?j????????¨?±?k?????????????¢????\ndouble ap[16][16][17];\n\nint main() {\n\tint n, m;\n\tcin >> m >> n;\n\tclr(dp);\n\tvector<vector<double>> a(m, vector<double>(n));\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\ta[i].push_back(0.0);\n\t}\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\trep(k, n + 1) {\n\t\t\t\tap[i][j][k] = 1.0;\n\t\t\t\tfor (int l = j; l < k; l++) {\n\t\t\t\t\tap[i][j][k] *= a[i][l];\n\t\t\t\t}\n\t\t\t\tap[i][j][k] *= (1.0 - a[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction<double(int, int, int)> solve = [&](int bit, int i, int j) {\n\t\tif (i == n)return 1.0;\n\t\tif (bit == (1 << m) - 1) {\n\t\t\treturn ap[j][i][n];\n\t\t}\n\t\tif (dp[bit][i][j]) {\n\t\t\treturn dp[bit][i][j];\n\t\t}\n\t\tdouble re = 0.0;\n\t\trep(k, m) if(!(bit & (1 << k))){\n\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\tre += solve(bit | (1 << k), l, k) * ap[j][i][l];\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][i][j] = re;\n\t};\n\tdouble ans = 0.0;\n\trep(i, m) {\n\t\tans = max(ans, solve(1 << i, 0, i));\n\t}\n\tcout << fixed << setprecision(30) << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nclass S{\npublic:\n  int s, d, c;\n  double p;\n  S(){}\n  S(int d, int c, int s, double p): d(d), c(c), s(s), p(p) {}\n  bool operator < (const S& s) const {\n    return p < s.p;\n  }\n};\n\nint n, m;\n//double data[16][16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int c, int s){\n  if(d == n) return 1.0;\n  double res = 0.0;\n  for(int i=0;i<=n-d;i++){\n    double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][c];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n        if((s >> j) & 1) continue;\n        /*if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n          else res += tmp * func(d+i, j, s|(1<<j));*/\n        res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n  }\n  //data[d][c][s] = res;\n  return res;\n}\n\ndouble solve(){\n  //fill(data[0][0], data[16][0], -1.0);\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, i, 1<<i));\n  }\n  return res;\n}\n\nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  printf(\"%.12f\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[17][(1 << 16) + 1];\n\nld solve(int room, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][rest] >= 0) return dp[room][rest];\n\tld res = 0;\n\tREP(i, m)\n\t{\n\t\tif ((rest >> i) & 1) continue;\n\t\tld exp = 1.0; ld tres = 0;\n\t\tFOR(j, room, n)\n\t\t{\n\t\t\tld win = rate[i][j];\n\t\t\ttres += exp * (1.0 - win) * solve(j, rest | (1 << i));\n\t\t\texp *= win;\n\t\t}\n\t\ttres += exp;\n\t\tchmax(res, tres);\n\t}\n\treturn dp[room][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 17)REP(j, (1 << 16)+1) dp[i][j] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tcout << D10 << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\ndouble p[16][16];\ndouble neko[16][16][16]; // neko[i][j][k] := i 番目のねこが 部屋 j から 部屋 k まで勝利する場合\ndouble memo[1 << 16][17][17];\n\ndouble dfs(int nekos, int room, int neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tneko[i][j][j] = 1.00 * p[i][j];\n\t\t\trange(k,j + 1,m){\n\t\t\t\tneko[i][j][k] = neko[i][j][k - 1] * p[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,17) rep(k,17) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define double long double\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-12;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][16];\n\n// double rec(int mask, int now, int id){\n//     if(id == n){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n//         return 1.0;\n//     }\n//     if(mask == 0 || (mask & (1LL << now)) == 0){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n//         return 0.0;\n//     }\n//     if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n//     double res = 0.0;\n//     rep(i, 0, m){\n//         if(!(mask & (1LL << i))) continue;\n//         if(i == now) continue;\n//         double tmp = rec(mask - (1LL << now), i, id);\n//         res = max(res, tmp);\n//     }\n//     res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n//     // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n//     return memo[mask][now][id] = res;\n// }\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.20Lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    double P[M][N];//???,???\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++) cin>>P[i][j];\n    }\n    double DP[1<<M][N+1];//S??????????????????n??????(0-index)???????????????????????¶???????¢????\n    fill(DP[0],DP[1<<M],0);\n    DP[0][0]=1;\n    for(int n=0;n<N;n++){\n        for(int S=0;S<(1<<M);S++){\n            if(!DP[S][n]) continue;\n            for(int m=0;m<M;m++){\n                if(S&(1<<m)) continue;\n                double p = DP[S][n];\n                for(int nn=n;nn<N;nn++){\n                    DP[S|(1<<m)][nn]=max(DP[S|(1<<m)][nn],p*(1-P[m][nn]));\n                    p*=P[m][nn];\n                }\n                DP[S|(1<<m)][N]=max(DP[S|(1<<m)][N],p);\n            }\n        }\n    }\n    double ans = 0;\n    for(int S=0;S<(1<<M);S++) ans+=DP[S][N];\n    cout.precision(10);\n    cout<<fixed;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 17\nusing namespace std;\ndouble x[N][N],memo[(1<<N)][N];\nint m,n;\n\ndouble dfs(int a,int b){\n  if(memo[a][b]>=0)return memo[a][b];\n  if(b==n)return memo[a][b]=1;\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(a&(1<<i))continue;\n    double sum=0,X=1;\n    for(int j=0;b+j<=n;j++){\n      sum+=X*(1-x[i][b+j])*dfs(a|(1<<i),b+j);\n      X*=x[i][b+j];\n    }\n    res=max(res,sum);\n  }\n  return memo[a][b]=res;\n}\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)\n      cin>>x[i][j];\n  for(int i=0;i<(1<<m);i++)\n    for(int j=0;j<=n;j++)\n      memo[i][j]=-1;\n  printf(\"%.10f\\n\",dfs(0,0));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n#define all(n) n.begin(),n.end()\n#define clr(n) memset(n,0,sizeof(n))\n#define mclr(n) memset(n,-1,sizeof(n))\n\n//dp[bit][i][j] ?´???£??????????????????bit???i???????????¨?±????j?????????????????????\n//??¨??¨????????????????¢????\ndouble dp[1 << 16][16];\n\n//ap[i][j][k] ???i ?????¨?±?j????????¨?±?k?????????????¢????\ndouble ap[16][16][17];\ndouble a[16][17];\n\nint main() {\n\tint n, m;\n\tcin >> m >> n;\n\tmclr(dp);\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\ta[i][n] = 0.0;\n\t}\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\trep(k, n + 1) {\n\t\t\t\tap[i][j][k] = 1.0;\n\t\t\t\tfor (int l = j; l < k; l++) {\n\t\t\t\t\tap[i][j][k] *= a[i][l];\n\t\t\t\t}\n\t\t\t\tap[i][j][k] *= (1.0 - a[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfunction<double(int, int)> solve = [&](int bit, int i) {\n\t\tif (i == n)return 1.0;\n\t\tif (dp[bit][i] >= -0.5) {\n\t\t\treturn dp[bit][i];\n\t\t}\n\t\tdouble re = 0.0;\n\t\trep(k, m) if(!(bit & (1 << k))) {\n\t\t\tdouble p = 0.0;\n\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\tp += solve(bit | (1 << k), l) * ap[k][i][l];\n\t\t\t}\n\t\t\tre = max(re, p);\n\t\t}\n\t\treturn dp[bit][i] = re;\n\t};\n\tcout << fixed << setprecision(30) << solve(0, 0) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ndouble memo[16][1 << 16];\nbool   dp[16][1 << 16];\ndouble prob[16][16];\n\nint m, n;\n\ndouble solve(int pos, int flag){\n  if(pos == n)      return 1.0;\n  if(dp[pos][flag]) return memo[pos][flag];\n  dp[pos][flag] = true;\n\n  double ret = 0.0;\n\n  REP(i,m) if(flag & (1 << i)){\n    double p   = 1.0;\n    double tmp = 0.0;\n    for(int j = pos; j < n; j++){\n      double pp = p * prob[i][j];\n      tmp += pp * solve(j, flag ^ (1 << i));\n      p -= pp;\n    }\n    tmp += p;\n    ret = max(ret, tmp);\n  }\n\n  return memo[pos][flag] = ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &m, &n);\n  REP(i,m) REP(j,n)\n    scanf(\"%lf\", &prob[i][j]);\n  printf(\"%.11f\\n\", solve(0, (1 << m) - 1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\t\nint m, n;\nvector<vector<ld>> rate;\nld dp[17][(1 << 16) + 1];\n\nld solve(int room, int rest)\n{\n\tif (room == n) return 1.0;\n\tif (rest == (1 << m) - 1) return 0;\n\tif (dp[room][rest] >= 0) return dp[room][rest];\n\tld res = 0;\n\tREP(i, m)\n\t{\n\t\tif ((rest >> i) & 1) continue;\n\t\tld exp = 1.0; ld tres = 0;\n\t\tFOR(j, room, n)\n\t\t{\n\t\t\tld win = rate[i][j];\n\t\t\tres += exp * (1.0 - win) * solve(j, rest | (1 << i));\n\t\t\texp *= win;\n\t\t}\n\t\ttres += exp;\n\t\tchmax(res, tres);\n\t}\n\treturn dp[room][rest] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tREP(i, 17)REP(j, (1 << 16)+1) dp[i][j] = -1;\n\tcin >> m >> n;\n\trate.resize(m, vector<ld>(n));\n\tREP(i, m)REP(j, n) cin >> rate[i][j];\n\tcout << D10 << solve(0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble*** dp;\ndouble table[16][16];\n\ndouble dfs(int state,int enemy,int cat){\n\n\tif(dp[state][enemy][cat] != -1.0)return dp[state][enemy][cat];\n\n\tint next_state = state - POW[cat];\n\n\tint next_cat = BIG_NUM;\n\n\tdouble maximum = 0.0,tmp;\n\n\tif(next_state != 0){\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tif(i == cat)continue;\n\t\t\tif(state & (1 << i)){\n\t\t\t\ttmp = dfs(next_state,enemy,i);\n\t\t\t\tif(tmp > maximum){\n\t\t\t\t\tmaximum = tmp;\n\t\t\t\t\tnext_cat = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(enemy == N-1){\n\t\t\tif(next_cat != BIG_NUM){\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy] +\n\t\t\t\t\t(1.0-table[cat][enemy])*dfs(next_state,enemy,next_cat);\n\t\t\t}else{\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy];\n\t\t\t}\n\t\t}else{\n\t\t\tif(next_cat != BIG_NUM){\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat) +\n\t\t\t\t(1.0-table[cat][enemy])*dfs(next_state,enemy,next_cat);\n\t\t\t}else{\n\t\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tif(enemy == N-1){\n\t\t\tdp[state][enemy][cat] = table[cat][enemy];\n\t\t}else{\n\t\t\tdp[state][enemy][cat] = table[cat][enemy]*dfs(state,enemy+1,cat);\n\t\t}\n\t}\n\n\treturn dp[state][enemy][cat];\n}\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tdp = new double**[limit];\n\tfor(int i = 0; i < limit; i++){\n\t\tdp[i] = new double*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new double[M];\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = -1.0;\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\n\tfor(int cat = 0; cat < M; cat++){\n\t\tans = max(ans,dfs(limit-1,0,cat));\n\t}\n\n\tprintf(\"%.12lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint M, N;\ndouble P[16][16];\ndouble dp[17][1 << 16][16];\n\nint main(void) {\n  cin >> M >> N;\n  for(int i = 0; i < M; i++) for(int j = 0; j < N; j++) cin >> P[i][j];\n\n  /* 状態:\n   *   dp[i][S][j] =\n   *     集合Sのねこをすでに使っていて,\n   *     敵iとねこjが戦うときに最善の行動をした場合の確率\n   * 基底:\n   *   dp[N][S][j] = 1\n   *   where S in [0, 1 << N), j in [0, M)\n   * 遷移:\n   *   dp[i][S][j] = dp[i + 1][S][j] * P[j][i] + max(dp[i][S | (1 << k)][k]) * (1 - P[j][i])\n   *   where k not in S\n   */\n\n  for(int S = 0; S < (1 << M); S++) for(int j = 0; j < M; j++) dp[N % 2][S][j] = 1;\n\n  for(int i = N - 1; i >= 0; i--) {\n    for(int S = 0; S < (1 << M); S++) for(int j = 0; j < M; j++) dp[i % 2][S][j] = 0;\n\n    for(int S = (1 << M) - 1; S >= 0; S--) {\n      for(int j = 0; j < M; j++) if(S & (1 << j)) {\n        double win = dp[(i + 1) % 2][S][j] * P[j][i];\n\n        double lose = 0;\n        for(int k = 0; k < M; k++) if(!(S & (1 << k))) {\n          lose = max(lose, dp[i % 2][S | (1 << k)][k] * (1 - P[j][i]));\n        }\n\n        dp[i % 2][S][j] = max(dp[i % 2][S][j], win + lose);\n      }\n    }\n  }\n\n  double ans = 0;\n  for(int i = 0; i < M; i++) ans = max(ans, dp[0][1 << i][i]);\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 16;\nconst int M = 16;\nconst int T = (1<<N);\nconst double INF = (1<<30);\n\nint n,m;\ndouble cat[N][M];\n\nbool edged[T];\nvector<char> edge[T];\n\ndouble memo[M][T][N];\nvoid init(){\n\trep(i,M)rep(j,T)rep(k,N)memo[i][j][k]=INF;\n\trep(i,T)edged[i]=false;\n}\nvoid input(){\n\tcin>>n>>m;\n\trep(i,n)rep(j,m)cin>>cat[i][j];\n}\n\nbool has(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nstring strbit(int state, int n){\n\tstring ret = \"\";\n\trep(i,n)ret += has(state,i)?'1':'0';\n\treturn ret;\n}\n\nvoid setEdge(int state){\n\tif(edged[state])return;\n\tfor(int i=0;i<n;i++){\n\t\tif(has(state, i))edge[state].push_back(i);\n\t}\n\tedged[state]=true;\n}\n\ndouble req(int p, int state, int c){\n\tif(memo[p][state][c] != INF) return memo[p][state][c];\n\t\n\tdouble ret = 0;\n\t\n\tif(p==m)ret=1.0;\n\telse{\n\t\t//setEdge(state);\n\t\t\n\t\tdouble winrate = cat[c][p];\n\t\tdouble win = winrate * req(p+1, state, c);\n\t\t//rep(i,edge[state].size()){\n\t\trep(i,n){\n\t\t\tif(!has(state,i))continue;\n\t\t\t//char e = edge[state][i];\n\t\t\tchar e = i;\n\t\t\tret = max(ret, win + (1-winrate)*req(p, state^(1<<e), e)); \n\t\t}\n\t}\n\t\n\t//printf(\"%d %s %d %lf\\n\",p,strbit(state,n).c_str(),c,ret);\n\treturn memo[p][state][c] = ret;\n}\n\ndouble solve(){\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, req(0, (1<<n)-1, i));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tinput();\n\tprintf(\"%.12lf\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing R = long double;\n\nconst int N = 17;\nR memo[N][1<<(N-1)], p[N][1<<(N-1)];\n\nint m, n;\n\nR rec(int ri, int used){\n    R& ret = memo[ri][used];\n    if(ret > -EPS) return ret;\n\n    ret = 0.0;\n\n    rep(i, m){\n        R cur = 0.0;\n\n        if(used & (1 << i)) continue;\n        int nused = used | (1 << i);\n\n        R won_p = 1.0;\n        rep(nri, ri, n){\n            cur += won_p * (1.0 - p[i][nri]) * rec(nri, nused);\n            won_p *= p[i][nri];\n        }\n        cur += won_p;\n\n        chmax(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> m >> n;\n    rep(i, m) rep(j, n) cin >> p[i][j];\n\n    rep(i, n + 1) rep(j, 1 << m) memo[i][j] = -1;\n\n    cout.precision(20);\n    cout << fixed << rec(0, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 17;\nconst int MAXM = 17;\n\nint N, M;\ndouble dp[1<<MAXM][MAXN];\ndouble P[MAXM][MAXN];\n\nint main() {\n  while(cin >> M >> N) {\n    for(int i = 0; i < M; ++i) {\n      for(int j = 0; j < N; ++j) {\n        cin >> P[i][j];\n      }\n    }\n    fill(dp[0], dp[1<<MAXM], 0.0);\n    dp[0][0] = 1.0;\n    for(int j = 0; j < N; ++j) {\n      for(int i = 0; i < (1<<M); ++i) {\n        if(dp[i][j] == 0.0) continue;\n        for(int k = 0; k < M; ++k) {\n          if(i & (1<<k)) continue;\n          int ni = (i | (1<<k));\n          double np = 1.0;\n          for(int nj = j; nj < N; ++nj) {\n            dp[ni][nj] = max(dp[ni][nj], dp[i][j] * np * (1.0 - P[k][nj]));\n            np *= P[k][nj];\n          }\n          dp[ni][N] = max(dp[ni][N], dp[i][j] * np);\n        }\n      }\n    }\n    double res = 0.0;\n    for(int i = 0; i < (1<<M); ++i) {\n      res += dp[i][N];\n    }\n    printf(\"%.10f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ndouble dp[1<<16][17];\ndouble prob[16][16];\nint n, m;\n/*\ndouble solve(int bit, int k, double p){\n  if(bit == 0){\n    //cout << bit << \" \" << k << \" \" << p << \" \" << 0 << endl;\n    return 0;\n  }\n  if(k == m){\n    dp[bit][k] = max(dp[bit][k],p);\n    //cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n    return dp[bit][k];\n  }\n  double ret = 0.0;\n  for(int i = 0; i < n; ++i){\n    if((bit >> i) & 1){\n      double t = p, s = 0.0;\n      for(int j = k; j < m; ++j){\n\ts += solve(bit - (1<<i), j, t*(1.0-prob[i][j]));\n\tt *= prob[i][j];\n      }\n      s += solve(bit, m, t);\n      ret = max(ret,s);\n    }\n  }\n  dp[bit][k] = max(dp[bit][k], ret);\n  //cout << bit << \" \" << k << \" \" << p << \" \" << dp[bit][k] << endl;\n  return dp[bit][k];\n}\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  double ans = solve((1<<n)-1,0,1);\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}\n*/\nint main(){\n  int n, m;\n  cin >> n >> m;\n  double dp[1<<n][m], prob[n][m];\n  for(int i = 0; i < (1<<n); ++i){\n    fill(dp[i],dp[i]+m,0);\n  }\n  //fill(dp[0],dp[0]+m,0);//テァツ個ォテ」ツ?古・ツ?ィテ」ツ?ヲテ・ツ?津」ツつ古」ツ?ヲテ」ツつ凝」ツ?ョテ」ツ?ァ0\n\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      cin >> prob[i][j];\n    }\n  }\n  \n  for(int bit = 0; bit < (1<<n); ++bit){\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(bit>>j & 1){\n\t  double t = 0, p = 1.0;\n\t  for(int k = i; k < m; ++k){\n\t    t += p*(1.0 - prob[j][k])*dp[bit-(1<<j)][k];\n\t    p *= prob[j][k];\n\t  }\n\t  t += p;\n\t  dp[bit][i] = max(dp[bit][i],t);\n\t}\n      }\n    }\n  }\n\n  double ans = dp[(1<<n)-1][0];\n  printf(\"%.12f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll m, n; cin >> m >> n;\n\tvector<vector<double>> p(m, vector<double>(n));\n\tREP(i, m) REP(j, n) cin >> p[i][j];\n\n\t// dp[?????????????????°][????´???£???????????????][????????????] = ??????\n\tvector<vvd> dp(n + 1, vvd(m, vd(1ll << m, 0)));\n\t// win_max_p[??????????????????????????????????????°][????????§?????? | ????????????] = ????????????????´???£??????????????????\n\tvvd win_max_p(n, vd(1ll << m, 0));\n\tREP(i, 1ll << m) REP(j, m) dp[n][j][i & ~(1ll << j)] = 1;\n\n\tfor (ll i = n - 1; i >= 0; --i) for (ll j = (1ll << m) - 1; j >= 0; --j) {\n\t\tREP(k, m) if ((j & (1ll << k)) == 0) {\n\t\t\tdp[i][k][j] = win_max_p[i][j | (1ll << k)] * (1 - p[k][i]) + dp[i + 1][k][j] * p[k][i];\n\t\t\twin_max_p[i][j] = max(win_max_p[i][j], dp[i][k][j]);\n\t\t}\n\t}\n\tcout << win_max_p[0][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nclass S{\npublic:\n  int s, d, c;\n  double p;\n  S(){}\n  S(int d, int c, int s, double p): d(d), c(c), s(s), p(p) {}\n  bool operator < (const S& s) const {\n    return p < s.p;\n  }\n};\n\nint n, m;\ndouble data[16][16][1<<16];\ndouble input[16][16];\n\ndouble func(int d, int c, int s){\n  if(d == n) return 1.0;\n  double res = 0.0;\n  for(int i=0;i<=n-d;i++){\n    double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][c];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n        if((s >> j) & 1) continue;\n        if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n        else res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n  }\n  data[d][c][s] = res;\n  return res;\n}\n\ndouble solve(){\n  fill(data[0][0], data[16][0], -1.0);\n  double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, i, 1<<i));\n  }\n  return res;\n}\n\nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  printf(\"%.12f\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m; double a[17][17], dp[18][65555]; bool vis[18][65555];\ndouble solve(int t, int bit) {\n\tif(t == n) return 1.0;\n\tif(bit == 0) return 0.0;\n\tif(vis[t][bit]) return dp[t][bit];\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif(!(bit & (1 << i))) continue;\n\t\tdouble res1 = solve(t + 1, bit);\n\t\tdouble res2 = solve(t, bit - (1 << i));\n\t\tdouble res3 = res1 * a[i][t] + res2 * (1.0 - a[i][t]);\n\t\tret = max(ret, res3);\n\t}\n\treturn ret;\n}\nint main() {\n\tscanf(\"%d%d\", &m, &n);\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) scanf(\"%lf\", &a[i][j]);\n\t}\n\tprintf(\"%.12lf\\n\", solve(0, (1 << m) - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 16\nusing namespace std;\nint m,n;\ndouble neko[N][N],mem[N][N][1<<N];\nint used[N][N][1<<N];\n\ndouble dfs(int pos,int k,int bit){\n  if(pos==n) return 1;\n  if(used[pos][k][bit]++) return mem[pos][k][bit];\n\n  double res=0;\n  for(int i=0;i<m;i++){\n    if(bit&(1<<i))continue;\n    res = max(res,(1-neko[k][pos])*dfs(pos,i,bit|1<<i));\n  }\n  \n  return mem[pos][k][bit] = res+neko[k][pos]*dfs(pos+1,k,bit);\n}\n\nint main(){\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<n;j++)cin>>neko[i][j];\n\n\n  double ans=0;\n  for(int i=0;i<m;i++) ans=max(ans,dfs(0,i,1<<i));\n\n  printf(\"%.10f\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?9e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ndouble dp[17][70000][17];\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tdp[0][0][n]=1;\n\tvvd in(n,vd(m));\n\trep(i,n)rep(j,m)cin>>in[i][j];\n\trep(i,m)rep(j,1<<n)rep(k,n+1){\n\t\tdouble t=dp[i][j][k];\n\t\tif(k<n){\n\t\t\tdp[i+1][j][k]+=t*in[k][i];\n\t\t\tdp[i][j|1<<k][n]+=t*(1-in[k][i]);\n\t\t}else{\n\t\t\trep(l,n)if((j&1<<l)==0){\n\t\t\t\tdp[i+1][j][l]+=t*in[l][i];\n\t\t\t\tdp[i][j|1<<l][n]+=t*(1-in[l][i]);\n\t\t\t}\n\t\t}\n\t}\n//\trep(i,4){rep(j,3)cout<<\" \"<<dp[m][i][j];cout<<endl;}cout<<endl;\n\tvd out(1<<n);\n\trep(i,1<<n)rep(j,n)if((i&1<<j)==0)cmax(out[i|1<<j],out[i]+dp[m][i][j]);\n//\trep(i,out.size())cout<<\" \"<<out[i];cout<<endl;\n\tcout<<shosu(11)<<out[(1<<n)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint m, n;\ndouble p[16][16], dp[1 << 16][16][16];\n\nconst double EPS = 1e-9;\n\nint main() {\n\tcin >> m >> n;\n\tfor_(i,0,m) for_(j,0,n) cin >> p[i][j];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\t\n\tfor_(i,0,m) dp[1 << i][i][0] = 1.0;\n\t\n\tfor_(S,0,(1<<m)+1) for_(i,0,m) {\n\t\tif (!(S >> i & 1)) continue;\n\t\t\n\t\tfor_(j,0,n) {\n\t\t\tif (dp[S][i][j] < EPS) continue;\n\t\t\t\n\t\t\tdp[S][i][j + 1] += dp[S][i][j] * p[i][j];\n\t\t\t\n\t\t\tfor_(k,0,m) {\n\t\t\t\tif (S >> k & 1) continue;\n\t\t\t\tdp[S | 1 << k][k][j] += dp[S][i][j] * (1.0 - p[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 0.0;\n\tfor_(S,0,(1<<m)) for_(i,0,m) ans = max(ans, dp[S][i][n]);\n\tcout << setprecision(9) << setiosflags(ios::fixed) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    double P[M][N];//???,???\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++) cin>>P[i][j];\n    }\n    double DP[1<<M][N+1];//[S][n]:=S??????????????£????????????n??????????????????????±??????????????????????????????????????????¶???????¢????\n    fill(DP[0],DP[1<<M],0);\n    for(int m=0;m<M;m++){\n        double p=1;\n        for(int n=N-1;n>=0;n--){\n            p*=P[m][n];\n            DP[1<<m][n]=p;\n        }\n    }\n    for(int s=0;s<(1<<M);s++){\n        for(int n=0;n<N;n++){\n            for(int m=0;m<M;m++){\n                if((s&(1<<m))==0) continue;\n                double sum=0,p=1;\n                for(int nn=n;nn<N;nn++){\n                    sum+=p*(1-P[m][nn])*DP[s^(1<<m)][nn];\n                    p*=P[m][nn];\n                }\n                sum+=p;\n                DP[s][n]=max(DP[s][n],sum);\n            }\n        }\n    }\n    cout.precision(6);\n    cout<<fixed;\n    cout<<DP[(1<<M)-1][0]<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nfloat p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint n, m;\ndouble a[16][16];\ndouble dp[1 << 16][16];\n\ndouble f(int s, int k) {\n    double &ret = dp[s][k];\n    if (ret != -1) return ret;\n    ret = 0;\n    rep(i, n) {\n        if (s >> i & 1) continue;\n        double sm = 0;\n        double t = 1;\n        rep2(j, k, m) {\n            sm += f(s | 1 << i, j) * t * (1 - a[i][j]);\n            t *= a[i][j];\n        }\n        sm += t;\n        chmax(ret, sm);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n >> m;\n    rep(i, n) rep(j, m) cin >> a[i][j];\n    rep(i, 1 << n) rep(j, m) dp[i][j] = -1;\n    cout << fixed << setprecision(10) << f(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\nusing namespace std;\n#define int long long\nint N;\nint M;\nvector<vector<double> > dp;\nvector<vector<double> > p;\n\ndouble solve(int i, int j) {\n\tif (dp[i][j] > -0.5) {\n\t\treturn dp[i][j];\n\t}\n\tif (i == M)return 1;\n\tdouble res = 0;\n\tfor (int x = 0; x < N; x++) {\n\t\tif (j & (1 << x)) {\n\t\t\tdouble tmp = 0;\n\t\t\tdouble prob = 1;\n\t\t\tfor (int m = i; m <= M; m++) {\n\t\t\t\ttmp += prob * (1 - p[x][m]) * solve(m, j ^ (1 << x));\n\t\t\t\tprob *= p[x][m];\n\t\t\t}\n\t\t\tres = max(res, tmp);\n\t\t}\n\t}\n\tdp[i][j] = res;\n\treturn dp[i][j];\n}\nsigned main() {\n\t\n\tcin >> N >> M;\n\tp.resize(N, vector<double>(M));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].push_back(0);\n\t}\n\tdp.resize(M + 1, vector<double>((1 << N), -1));\n\tdp[M][0] = 1;\n\tfor (int i = 0; i < M; i++) {\n\t\tdp[i][0] = 0;\n\t}\n\tcout << setprecision(15) << solve(0, (1 << N) - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    double P[M][N];//???,???\n    for(int i=0;i<M;i++){\n        for(int j=0;j<N;j++) cin>>P[i][j];\n    }\n    double DP[1<<M][N];//[S][n]:=S??????????????£????????????n??????????????????????±??????????????????????????????????????????¶???????¢????\n    fill(DP[0],DP[1<<M],0);\n    for(int m=0;m<M;m++){\n        double p=1;\n        for(int n=N-1;n>=0;n--){\n            p*=P[m][n];\n            DP[1<<m][n]=p;\n        }\n    }\n    for(int s=0;s<(1<<M);s++){\n        for(int n=0;n<N;n++){\n            for(int m=0;m<M;m++){\n                if((s&(1<<m))==0) continue;\n                double sum=0,p=1;\n                for(int nn=n;nn<N;nn++){\n                    sum+=p*(1-P[m][nn])*DP[s^(1<<m)][nn];\n                    p*=P[m][nn];\n                }\n                sum+=p;\n                DP[s][n]=max(DP[s][n],sum);\n            }\n        }\n    }\n    cout.precision(6);\n    cout<<fixed;\n    cout<<DP[(1<<M)-1][0]<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define double long double\n\nint n, m;\ndouble prob[20][20];\ndouble dp[20][1 << 20];\n\ndouble f(int opp, int rem) {\n\tif(dp[opp][rem] != -1) {\n\t\treturn dp[opp][rem];\n\t}\n\tif(opp == n) {\n\t\treturn 1.0;\n\t}\n\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif((rem >> i) & 1) {\n\t\t\tdouble win = 1.0;\n\t\t\tdouble res = 0;\n\t\t\tfor(int j = opp; j <= n; j++) {\n\t\t\t\tres += win * (1.0 - prob[i][j]) * f(j, rem ^ (1 << i));\n\t\t\t\twin *= prob[i][j];\n\t\t\t}\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\n\treturn dp[opp][rem] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcin >> prob[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n + 1; i++) {\n\t\tfor(int j = 0; j < 1 << m; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << f(0, (1 << m) - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nlong double x[20][20], m, n;\nlong double solve(int pos, int ret) {\n\tif (pos == n)return 1.0l;\n\tlong double maxn = 0.0l;\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((ret / (1 << i)) % 2 == 1)continue;\n\t\tlong double w1 = solve(pos + 1, ret)*x[i][pos];\n\t\tlong double w2 = solve(pos, ret + (1 << i))*(1.0l - x[i][pos]);\n\t\tmaxn = max(maxn, w1 + w2);\n\t}\n\treturn maxn;\n}\nint main() {\n\tcin >> m >> n; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++)cin >> x[i][j]; }\n\tprintf(\"%.12Lf\\n\", solve(0, 0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint main(){\n\tint m, n;\n\tcin >> m >> n;\n\n\tvector<vector<double>> p(m, vector<double>(n));\n\trep(i,m){\n\t\trep(j,n){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t\tp[i].emplace_back(0);\n\t}\n\n\tvector<vector<double>> dp(1 << m, vector<double>(n + 1, 0));\n\tdp[0][0] = 1;\n\trep(s, 1 << m){\n\t\trep(i,m){\n\t\t\tif(s >> i & 1) continue;\n\t\t\t// remain s cat, i-th cat goes.\n\t\t\t\n\t\t\t// i-th cat battles j-th enemy and is beated k-th enemy.\n\t\t\trep(j,n){\n\t\t\t\tdouble win = 1; // to win (k - 1)-th enemy\n\t\t\t\trange(k,j,n + 1){\n\t\t\t\t\tdp[s bitor 1 << i][k] = max(dp[s bitor 1 << i][k], dp[s][j] * win * (1 - p[i][k]));\n\t\t\t\t\twin *= p[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\trep(s, 1 << m){\n\t\tans += dp[s][n];\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nusing R = long double;\n\nvector<vector<R>> memo, p;\n\nint m, n;\n\nR rec(int ri, int used){\n    R& ret = memo[ri][used];\n    if(ret > 0) return ret;\n\n    ret = 0.0;\n\n    rep(i, m){\n        R cur = 0.0;\n\n        if(used & (1 << i)) continue;\n        int nused = used | (1 << i);\n\n        R won_p = 1.0;\n        rep(nri, ri, n){\n            cur += won_p * (1.0 - p[i][nri]) * rec(nri, nused);\n            won_p *= p[i][nri];\n        }\n        cur += won_p;\n\n        chmax(ret, cur);\n    }\n\n    return ret;\n}\n\nint main(void){\n    cin >> m >> n;\n    p = vector<vector<R>>(m, vector<R>(n));\n    rep(i, m) rep(j, n) cin >> p[i][j];\n    rep(i, m) p[i].push_back(0.0);\n\n    memo = vector<vector<R>>(n + 1, vector<R>(1 << m));\n\n    cout.precision(20);\n    cout << fixed << rec(0, 0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nbool ok[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>&lives) {\n\tconst int a = lives.to_ulong();\n\tif (!memo[now][a]<-1) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -2;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tbitset<16>bs((1 << 16) - 1);\n\tld ans = check(0, bs);\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nint n, m;\n//long double data[16][16][1<<16];\nlong double input[16][16];\n\nlong double func(int d, int c, int s){\n  if(d == n) return 1.0;\n  long double res = 0.0;\n  for(int i=0;i<=n-d;i++){\n    long double tmp = 1.0;\n    for(int j=0;j<i;j++) tmp *= input[d+j][c];\n    if(i == n - d) res += tmp;\n    else{\n      tmp *= (1.0 - input[d+i][c]);\n      for(int j=0;j<m;j++){\n        if((s >> j) & 1) continue;\n        /*if(data[d+i][j][s|(1<<j)] >= 0.0) res += tmp * data[d+i][j][s|(1<<j)];\n          else res += tmp * func(d+i, j, s|(1<<j));*/\n        res += tmp * func(d+i, j, s|(1<<j));\n      }\n    }\n  }\n  //data[d][c][s] = res;\n  return res;\n}\n\nlong double solve(){\n  //fill(data[0][0], data[16][0], -1.0);\n  long double res = 0.0;\n  for(int i=0;i<m;i++){\n    res = max(res, func(0, i, 1<<i));\n  }\n  return res;\n}\n\nmain(){\n  cin >> m >> n;\n  for(int j=0;j<m;j++){\n    for(int i=0;i<n;i++){\n      cin >> input[i][j];\n    }\n  }\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n//ld dp[17][1 << 16] = {0}; // dp[next enemy][used cat]\n\nint N, M;\nld P[16][16];\n\nbool m1[16][1 << 16] = {0};\nld m2[16][1 << 16];\n\nld dp(int n, int rest) {\n\tif (n >= N) return (ld)1;\n\n\tif (m1[n][rest]) return m2[n][rest];\n\n\tld ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tld p = 0;\n\t\tif (rest & (1 << i)) {\n\t\t\tint nr = rest ^ (1 << i);\n\n\t\t\tld per = 1;\n\t\t\tfor (int j = n; j < N; ++j) {\n\t\t\t\tp += per * (1 - P[i][j]) * dp(j, nr);\n\t\t\t\tper *= P[i][j];\n\t\t\t}\n\t\t\tp += per;\n\t\t}\n\t\tret = max(ret, p);\n\t}\n\treturn m1[n][rest] = true, m2[n][rest] = ret;\n}\nint main() {\n\tcin >> M >> N;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> P[i][j];\n\t\t}\n\t}\n\n\tcout << dp(0, (1 << M)-1) << endl;\n\treturn 0;\n/*\n\tvector< vector<int> > v(M+1);\n\tfor (int i = 0; i < (1 << M); ++i) {\n\t\tv[__builtin_popcount(i)].push_back(i);\n\t}\n*/\n/*\n\tdp[0][0] = 1.0;\n\tfor (int j = 0; j <= N; ++j) { // next enemy\n\t\tfor (int i = 0; i <= M; ++i) { // used cat num\n\t\t\tfor (int k = 0; k < v[i].size(); ++k) { // used cat\n\t\t\t\tint f = v[i][k];\n\t\t\t\tfor (int c = 0; c < M; ++c) { // cat to use\n\t\t\t\t\tif ((f & (1 << c)) == 0) {\n\t\t\t\t\t\tint nf = f | (1 << c);\n\t\t\t\t\t\tld per = 1;\n\t\t\t\t\t\tfor (int e = j; e <= N; ++e) { // next next enemy\n\t\t\t\t\t\t\tld p = e < N ? per * (1 - P[c][e]) : per;\n\t\t\t\t\t\t\tdp[e][nf] = max(dp[e][nf], dp[j][f] * p);\n\t\t\t\t\t\t\tif (e < N) per *= P[c][e];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", (double)dp[N][(1 << M)-1]);\n*/\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,b) for(int i = 0; i < (b); i++)\n\nint n, m;\ndouble p[16][16];\ndouble memo[1 << 16][15][16];\nstd::map<std::pair<unsigned short,char>, double> mo;\n\ndouble dfs(unsigned short nekos, char room, char neko){\n\tif(room == m) return 1.00000;\n\tif(room == 15 and mo.count(std::make_pair(nekos, neko))) return mo[std::make_pair(nekos, neko)];\n\tif(room != 15 and memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif((nekos & (1 << i)) != 0 or neko == i) continue;\n\t\tmaxi = std::max(maxi, dfs(nekos | 1 << neko, room, i) * (1 - p[neko][room]));\n\t}\n\n\tif(room == 15) return mo[std::make_pair(nekos, neko)] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n\treturn memo[nekos][room][neko] = dfs(nekos, room + 1, neko) * p[neko][room] + maxi;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n) rep(j,m) scanf(\"%lf\",&p[i][j]);\n\n\trep(i,1 << 16) rep(j,15) rep(k,16) memo[i][j][k] = -1;\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = std::max(ans, dfs(0, 0, i));\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n#define double long double\n\nint n, m;\ndouble prob[20][20];\ndouble dp[20][1 << 20];\n\ndouble f(int opp, int rem) {\n\tif(dp[opp][rem] != -1) {\n\t\treturn dp[opp][rem];\n\t}\n\tif(opp == n) {\n\t\treturn 1.0;\n\t}\n\tif(rem == 0) {\n\t\treturn 0.0;\n\t}\n\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif((rem >> i) & 1) {\n\t\t\tdouble win = 1.0;\n\t\t\tdouble res = 0;\n\t\t\tfor(int j = opp; j <= n; j++) {\n\t\t\t\tres += win * (1.0 - prob[i][j]) * f(j, rem ^ (1 << i));\n\t\t\t\twin *= prob[i][j];\n\t\t\t}\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\n\treturn dp[opp][rem] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcin >> prob[i][j];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < n + 1; i++) {\n\t\tfor(int j = 0; j < 1 << m; j++) {\n\t\t\tdp[i][j] = -1;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << f(0, (1 << m) - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ndouble p[20][20];\ndouble dp[1<<16][17];\nint m,n;\n\ndouble solve(int S, int now) {\n  if (now == n) return 1;\n  double &r = dp[S][now];\n  if (r >= 0) return r;\n  double res = 0;\n  REP(i,m) {\n    if (S>>i&1) continue;\n    double tmp = 0;\n    double q = 1;\n    for (int j=now; j<=n; ++j) {\n      double qq = q*(1-p[i][j]);\n      tmp += qq * solve(S|1<<i,j);\n      q *= p[i][j];\n    }\n    chmax(res, tmp);\n  }\n  return r = res;\n}\n\nint main() {\n  cin >> m >> n;\n  REP(i,m) {\n    REP(j,n) {\n      cin >> p[i][j];\n    }\n  }\n  memset(dp,-1,sizeof(dp));\n  double ans = solve(0,0);\n  printf(\"%.12f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ninline bool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\ninline int setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint n, m;\nfloat p[16][16];\n\n//typedef tuple<int,int,int> T;\n//map<T,double> memo;\ndouble memo[1 << 16][16][16];\n\ndouble dfs(unsigned short nekos, bitset<4> ro, bitset<4> ne){\n\tunsigned int room = ro.to_ulong();\n\tunsigned int neko = ne.to_ulong();\n\tif(room == m) return 1.00;\n\tif(memo[nekos][room][neko] != -1) return memo[nekos][room][neko];\n\t\n\tdouble res = dfs(nekos, room + 1, neko) * p[neko][room];\n\tdouble maxi = 0;\n\trep(i,n){\n\t\tif(getBit(nekos,i)) continue;\n\t\tif(neko == i) continue;\n\n\t\tmaxi = max(maxi, dfs(setBit(nekos, neko), room, i) * (1 - p[neko][room]));\n\t}\n\n\t//cout << \"res  \" << bitset<3>(nekos) << ' ' << room << ' ' << res << endl;\n\t//return res;\n\treturn memo[nekos][room][neko] = res + maxi;\n}\n\nint main(){\n\tcin >> n >> m;\n\n\trep(i,n){\n\t\trep(j,m){\n\t\t\tcin >> p[i][j];\n\t\t}\n\t}\n\n\trep(i,1 << 16) rep(j,16) rep(k,16) memo[i][j][k] = -1;\n\t//vector<vector<vector<double>>> dp(1 << n, vector<vector<double>>(m + 1, vector<double>(n,0)));\n\t//rep(i,1 << n) rep(j,n) dp[i][m][j] = 1.00;\n\t//rep(nekos, 1 << n){\n\t//\tfor (int room = m - 1; room >= 0; room--) {\n\t//\t\tfor (int neko = 0; neko < n; neko++) {\n\t//\t\t\tif(getBit(nekos, neko)) continue;\n\t//\t\t\tdouble win = dp[nekos][room][neko] * p[neko][room];\n\t//\t\t\tdouble lose = dp[setBit(nekos, neko)][room][neko] * p[neko][room];\n\t//\t\t}\n\t//\t}\n\t//}\n\n\tdouble ans = 0;\n\trep(i,n){\n\t\tans = max(ans, dfs(0, 0, i));\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint n, m;\nvector<vector<double> > win;\nvector<vector<vector<double> > > memo;\n\ndouble solve(int curr, bitset<16> cat, int select)\n{\n    if(curr == n)\n        return 1.0;\n\n    if(memo[curr][cat.to_ulong()][select] > -0.5)\n        return memo[curr][cat.to_ulong()][select];\n\n    double ret = 0.0;\n    for(int i=0; i<m; ++i){\n        if(!cat[i])\n            continue;\n        if(select != m && select != i)\n            continue;\n\n        double p = win[i][curr] * solve(curr+1, cat, i);\n        cat[i] = false;\n        p += (1.0 - win[i][curr]) * solve(curr, cat, m);\n        cat[i] = true;\n\n        ret = max(ret, p);\n    }\n\n    return memo[curr][cat.to_ulong()][select] = ret;\n}\n\nint main()\n{\n    cin >> m >> n;\n    win.assign(m, vector<double>(n));\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            cin >> win[i][j];\n        }\n    }\n\n    memo.assign(n, vector<vector<double> >(1<<m, vector<double>(m+1, -1.0)));\n    printf(\"%.10f\\n\", solve(0, (1<<m)-1, m));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std;\n\nint main()\n{\n    int n, m;\n    cin >> m >> n;\n    vector<vector<double> > win(m, vector<double>(n));\n    for(int i=0; i<m; ++i){\n        for(int j=0; j<n; ++j){\n            cin >> win[i][j];\n        }\n    }\n\n    vector<vector<double> > dp(1<<m, vector<double>(m+1, 1.0));\n    for(int a=n-1; a>=0; --a){ // ツ攻ツ猟ェツつキツづゥツ敵\n        vector<vector<double> > next(1<<m, vector<double>(m+1, 0.0));\n        for(int b=1; b<(1<<m); ++b){ // ツ残ツづィツづ個猫\n            for(int c=0; c<=m; ++c){ // ツ選ツ妥ーツつオツつスツ猫(c==mツづ按づァツづ篠、ツづ慊つセツ選ツ妥ーツつオツづつ「ツづ按つ「)\n                double ret = 0.0;\n                if(c == m){\n                    for(int i=0; i<m; ++i){\n                        bitset<16> bs(b);\n                        if(!bs[i])\n                            continue;\n\n                        double p = win[i][a] * dp[b][i];\n                        bs[i] = false;\n                        p += (1.0 - win[i][a]) * next[bs.to_ulong()][m];\n\n                        ret = max(ret, p);\n                    }\n                }else{\n                    bitset<16> bs(b);\n                    ret = win[c][a] * dp[b][c];\n                    bs[c] = false;\n                    ret += (1.0 - win[c][a]) * next[bs.to_ulong()][m];\n\n                }\n                next[b][c] = ret;\n            }\n        }\n        dp.swap(next);\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<m)-1][m]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntypedef vector<vvd> vvvd;\ntemplate<typename T> void chmin(T& a,const T& b){a=min(a,b);}\ntemplate<typename T> void chmax(T& a,const T& b){a=max(a,b);}\n\ndouble solve(const vvd& p,int mask,int cur,vvd& memo)\n{\n\tif(memo[mask][cur]!=-1) return memo[mask][cur];\n\tint m=p.size(),n=p[0].size();\n\tdouble res=0;\n\trep(i,m) if(mask>>i&1){\n\t\tdouble cp=1;\n\t\tdouble sum=0;\n\t\trepi(j,cur,n){\n\t\t\tsum+=cp*(1-p[i][j])*(solve(p,mask^1<<i,j,memo));\n\t\t\tcp*=p[i][j];\n\t\t}\n\t\tchmax(res,sum+cp);\n\t}\n\treturn memo[mask][cur]=res;\n}\n\nint main()\n{\n\tfor(int m,n;cin>>m>>n && m|n;){\n\t\tvvd p(m,vd(n));\n\t\trep(i,m) rep(j,n) cin>>p[i][j];\n\t\tvvd memo(1<<m,vd(n,-1));\n\t\tprintf(\"%.12f\\n\",solve(p,(1<<m)-1,0,memo));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint POW[17],M,N;\ndouble*** dp;\ndouble table[16][16];\n\nint main(){\n\n\tfor(int i = 0; i <= 16; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&M,&N);\n\n\tfor(int i = 0; i < M; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%lf\",&table[i][k]);\n\t}\n\n\tint limit = POW[M];\n\n\tdp = new double**[limit];\n\tfor(int i = 0; i < limit; i++){\n\t\tdp[i] = new double*[N];\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tdp[i][k] = new double[M];\n\t\t\tfor(int p = 0; p < M; p++)dp[i][k][p] = -1.0;\n\t\t}\n\t}\n\n\tint next_cat[M];\n\tint next_num,next_state;\n\n\tdouble maximum;\n\n\tfor(int state = 0; state < limit; state++){\n\n\t\tnext_num = 0;\n\n\t\tfor(int cat = 0; cat < M; cat++){\n\t\t\tif(state & (1 << cat)){\n\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t}\n\t\t}\n\n\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\tif(state & (1 << cat)){\n\n\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\tif(next_state == 0){\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1];\n\t\t\t\t}else{\n\n\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\tif(dp[next_state][N-1][next_cat[i]] > maximum){\n\t\t\t\t\t\t\tmaximum = dp[next_state][N-1][next_cat[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[state][N-1][cat] = table[cat][N-1] + (1.0-table[cat][N-1])*maximum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int enemy = N-2; enemy >= 0; enemy--){\n\t\tfor(int state = 0; state < limit;state++){\n\n\t\t\tnext_num = 0;\n\n\t\t\tfor(int cat = 0; cat < M; cat++){\n\t\t\t\tif(state & (1 << cat)){\n\t\t\t\t\tnext_cat[next_num++] = cat;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int cat = 0; cat < M; cat++){\n\n\t\t\t\tif(state & (1 << cat)){\n\n\t\t\t\t\tnext_state = state - POW[cat];\n\n\t\t\t\t\tif(next_state == 0){\n\t\t\t\t\t\tdp[state][enemy][cat] = max(dp[state][enemy][cat],dp[state][enemy+1][cat]*table[cat][enemy]);\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tmaximum = 0.0;\n\t\t\t\t\t\tfor(int i = 0; i < next_num; i++){\n\t\t\t\t\t\t\tif(dp[next_state][enemy][next_cat[i]] > maximum){\n\t\t\t\t\t\t\t\tmaximum = dp[next_state][enemy][next_cat[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdp[state][enemy][cat] = max(dp[state][enemy][cat],table[cat][enemy]*dp[state][enemy+1][cat]+(1.0-table[cat][enemy])*maximum);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0.0;\n\n\tfor(int i = 0; i < M; i++)ans = max(ans,dp[limit-1][0][i]);\n\n\tprintf(\"%.12lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_N = 16;\nconst int MAX_M = 16;\nconst double EPS = 1e-10;\n\ndouble dp[1<<MAX_M][MAX_N];\n\ndouble prob[MAX_M][MAX_N];\nint M, N;\n\ndouble dfs(int b, int x){\n  if(x == N) return 1.0;\n  if(b == (1<<M)-1){\n    return 0.0;\n  }\n  if(dp[b][x] - -1 < EPS) return dp[b][x];\n  //cout << b << \" \" << x << \" \" << M << \" \" << N << endl;  \n  double ret = 0; \n  for(int i=0;i<M;i++){\n    if(b&(1<<i)) continue;\n    double p = 0.0;\n    double tmpp = 1.0;\n    for(int j=x;j<N;j++){\n      p += tmpp * (1 - prob[i][j]) * dfs(b | (1<<i), j);\n      //cout << p << endl;\n      //cout << \"tmpp: \" << tmpp << \" prob[i][j]: \" << prob[i][j] << endl;      \n      tmpp *= prob[i][j];\n    }\n    p += tmpp * dfs(b | (1<<i), N);\n    ret = max(ret, p);\n  }\n  dp[b][x] = ret;\n  return ret;\n}\n\nint main(){\n  scanf(\"%d%d\", &M, &N);\n  memset(dp, -1, sizeof(dp));\n  for(int i=0;i<M;i++){\n    for(int j=0;j<N;j++){\n      scanf(\"%lf\", &prob[i][j]);\n    }\n  }\n\n  printf(\"%0.12lf\\n\", dfs(0, 0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint n, m;\ndouble prob[16][16];\ndouble dp[20][1 << 16];\n\ndouble f(int opp, int rem) {\n\tif(dp[opp][rem] != 0) return dp[opp][rem];\n\tif(opp == n) return 1.0;\n\n\tdouble ret = 0;\n\tfor(int i = 0; i < m; i++) {\n\t\tif((rem >> i) & 1) {\n\t\t\tdouble res = f(opp + 1, rem) * prob[i][opp] + f(opp, rem ^ (1 << i)) * (1.0 - prob[i][opp]);\n\t\t\tret = max(ret, res);\n\t\t}\n\t}\n\n\treturn dp[opp][rem] = ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tcin >> m >> n;\n\tfor(int i = 0; i < m; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcin >> prob[i][j];\n\t\t}\n\t}\n\n\tcout << setprecision(15) << f(0, (1 << m) - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <cstring>\n#include <iomanip>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n#define all(n) n.begin(),n.end()\n#define clr(n) memset(n,0,sizeof(n))\n#define mclr(n) memset(n,-1,sizeof(n))\n\n//dp[bit][i][j] ?´???£??????????????????bit???i???????????¨?±????j?????????????????????\n//??¨??¨????????????????¢????\nfloat dp[1 << 16][16][16];\n\n//ap[i][j][k] ???i ?????¨?±?j????????¨?±?k?????????????¢????\nfloat ap[16][16][17];\nfloat a[16][17];\n\nint main() {\n\tint n, m;\n\tcin >> m >> n;\n\tclr(dp);\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t\ta[i][n] = 0.0;\n\t}\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\trep(k, n + 1) {\n\t\t\t\tap[i][j][k] = 1.0;\n\t\t\t\tfor (int l = j; l < k; l++) {\n\t\t\t\t\tap[i][j][k] *= a[i][l];\n\t\t\t\t}\n\t\t\t\tap[i][j][k] *= (1.0 - a[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfunction<float(int, int, int)> solve = [&](int bit, int i, int j) {\n\t\tif (i == n)return 1.0f;\n\t\tif (bit == (1 << m) - 1) {\n\t\t\treturn ap[j][i][n];\n\t\t}\n\t\tif (dp[bit][i][j]) {\n\t\t\treturn dp[bit][i][j];\n\t\t}\n\t\tfloat re = 0.0;\n\t\trep(k, m) if(!(bit & (1 << k))){\n\t\t\tfor (int l = i; l <= n; l++) {\n\t\t\t\tre += solve(bit | (1 << k), l, k) * ap[j][i][l];\n\t\t\t}\n\t\t}\n\t\treturn dp[bit][i][j] = re;\n\t};\n\tfloat ans = 0.0;\n\trep(i, m) {\n\t\tans = max(ans, solve(1 << i, 0, i));\n\t}\n\tcout << fixed << setprecision(30) << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\ndouble dp[17][1 << 16];\ndouble p[16][16];\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\trep(i, m)rep(j, n)cin >> p[j][i];\n\tfill(dp[n], dp[n + 1], 1);\n\trrep(i, n) {\n\t\trep(j, 1 << m) {\n\t\t\tdouble x = 0;\n\t\t\trep(k, m) {\n\t\t\t\tif (j & 1 << k) {\n\t\t\t\t\tdouble t = 0, pass = 1;\n\t\t\t\t\tfor (int l = i; l <= n + 1; l++) {\n\t\t\t\t\t\tt += dp[l][j&~(1 << k)] * pass*(1 - p[l][k]);\n\t\t\t\t\t\tpass *= p[l][k];\n\t\t\t\t\t}\n\t\t\t\t\tcmax(x, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = x;\n\t\t}\n\t}\n\tcout <<fixed<< setprecision(100) << dp[0][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst double EPS = 1e-9;\n\nint m, n;\ndouble p[17][17];\ndouble memo[1LL << 16][16];\n\n// double rec(int mask, int now, int id){\n//     if(id == n){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 1.0 << endl;\n//         return 1.0;\n//     }\n//     if(mask == 0 || (mask & (1LL << now)) == 0){\n//         // cout << mask << ' ' << now << ' ' << id << ' ' << 0.0 << endl;\n//         return 0.0;\n//     }\n//     if(memo[mask][now][id] > -EPS) return memo[mask][now][id];\n//     double res = 0.0;\n//     rep(i, 0, m){\n//         if(!(mask & (1LL << i))) continue;\n//         if(i == now) continue;\n//         double tmp = rec(mask - (1LL << now), i, id);\n//         res = max(res, tmp);\n//     }\n//     res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n//     // cout << mask << ' ' << now << ' ' << id << ' ' << res << endl;\n//     return memo[mask][now][id] = res;\n// }\n\ndouble rec(int mask, int id){\n    if(id == n){\n        // cout << mask << ' ' << id << ' ' << 1.0 << endl;\n        return 1.0;\n    }\n    if(mask == 0){\n        // cout << mask << ' ' << id << ' ' << 0.0 << endl;\n        return 0.0;\n    }\n    if(memo[mask][id] > -EPS) return memo[mask][id];\n    double res = 0.0;\n    rep(i, 0, m){\n        if(!(mask & (1LL << i))) continue;\n        double tmp = 0.0, now = 1.0;\n        rep(j, id, n){\n            // j番目に負けた場合\n            tmp += now * (1 - p[i][j]) * rec(mask - (1LL << i), j);\n            now *= p[i][j];\n        }\n        tmp += now;\n        // tmp = p[i][id] *  rec(mask - (1LL << now), i, id);\n        res = max(res, tmp);\n    }\n    // res = p[now][id] * rec(mask, now, id + 1) + (1 - p[now][id]) * res;\n    // cout << mask << ' ' << id << ' ' << res << endl;\n    return memo[mask][id] = res;\n}\n\nint main(){\n    cin >> m >> n;\n    rep(i, 0, m){\n        rep(j, 0, n){\n            cin >> p[i][j];\n        }\n    }\n    rep(i, 0, 1 << m) rep(k, 0, n + 1) memo[i][k] = -1.0;\n    double ans = 0.0;\n    ans = rec((1LL << m) - 1, 0);\n    printf(\"%.10f\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint m, n;\ndouble mat[18][18];\nbool visited[(1<<16)][16][16];\ndouble memo[(1<<16)][16][16];\n\ndouble dfs(int used, int pos, int stage){\n    if(stage == n) return 1;\n    if(visited[used][pos][stage]) return memo[used][pos][stage];\n    double ret = 0;\n    for(int i=0;i<m;i++){\n        if((used>>i)&1) continue;\n        double path = 1;\n        double suc = 0;\n        int nused = used | (1 << i);\n        for(int j=stage;j<n;j++){\n            suc += path * (1 - mat[i][j]) * dfs(nused, pos+1, j);\n            path *= mat[i][j];\n        }\n        suc += path;\n        ret = max(ret, suc);\n    }\n    visited[used][pos][stage] = true;\n    memo[used][pos][stage] = ret;\n    return ret;\n}\n\nint main(){\n    cin >> m >> n;\n\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            cin >> mat[i][j];\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    printf(\"%.10f\\n\", dfs(0, 0, 0));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nvector<vector<ld>>pers;\nld memo[16][1 << 16];\nbool ok[16][1 << 16];\nint M, N;\nld check(const int now,bitset<16>&lives) {\n\tconst int a = lives.to_ulong();\n\tif (!(memo[now][a]<-1)) {\n\t\treturn memo[now][a];\n\t}\n\telse {\n\t\tld amax = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (lives[i]) {\n\t\t\t\tlives[i] = false;\n\t\t\t\tld per = 0;\n\t\t\t\tld living = 1;\n\t\t\t\tfor (int enemy = now; enemy < N; ++enemy) {\n\t\t\t\t\tper += living*(1 - pers[i][enemy])*check(enemy,lives);\n\t\t\t\t\tliving *= pers[i][enemy];\n\t\t\t\t}\n\t\t\t\tper += living;\n\t\t\t\tamax = max(amax, per);\n\t\t\t\tlives[i] = true;\n\t\t\t}\n\t\t}\n\t\treturn memo[now][a] =amax;\n\t}\n\n}\n\nint main() {cin >> M >> N;\n\tpers.resize(M);\n\tfor (int i = 0; i < 16; ++i) {\n\t\tfor (int j = 0; j < 1 << 16; ++j) {\n\t\t\tmemo[i][j] = -2;\n\t\t}\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tld p; cin >> p;\n\t\t\tpers[i].push_back(p);\n\t\t}\n\t}\n\tbitset<16>bs((1 << 16) - 1);\n\tld ans = check(0, bs);\n\tcout << fixed << setprecision(22) << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2237: The Castle\n// 2017.12.9\n\n#include <stdio.h>\n#include <string.h>\n\ndouble p[16][16];\ndouble dp[65536][16];\n \nint main()\n{\n    int m, n, i, j, k, l, b;\n\tdouble t, a, pro;\n\n\tscanf(\"%d%d\", &m, &n);\n    for (i = 0; i < m; i++) for (j = 0; j < n; j++) scanf(\"%lf\", &p[i][j]);\n\n    for (i = (1 << m) - 1; i >= 0; i--) {\n        for (j = n-1; j >= 0; j--) {\n            t = 0;\n            for (b = 1, k = 0; k < m; k++, b <<= 1) if (!(i & b)) {\n\t\t\t\tpro = 1, a = 0;\n                for (l = j; l < n; l++) {\n                    a += pro * (1.0 - p[k][l]) * dp[i | b][l];\n                    pro *= p[k][l];\n                }\n                a += pro;\n\t\t\t\tif (a > t) t = a;\n            }\n            dp[i][j] = t;\n        }\n    }\n    printf(\"%.12lf\\n\",dp[0][0]);\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//The Castle\npublic class Main{\n\n\tint m, n;\n\tdouble[][] dp, p;\n\n\tdouble get(int S, int K){\n//\t\tSystem.out.println(\"S:\"+S+\" K:\"+K);\n\t\tif(dp[S][K]!=-1)return dp[S][K];\n\t\tdouble res = 0;\n\t\tfor(int last=0;last<m;last++)if(((S>>last)&1)>0){\n\t\t\tdouble sum = 0;\n\t\t\tfor(int j=0;j<=K;j++){\n\t\t\t\tdouble e = get(S-(1<<last), j);\n\t\t\t\tfor(int k=j+1;k<=K;k++)e*=p[last][k];\n\t\t\t\te*=1-p[last][K+1];\n\t\t\t\tsum += e;\n\t\t\t}\n\t\t\tres = Math.max(res, sum);\n\t\t}\n\t\treturn dp[S][K] = res;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tm = sc.nextInt(); n = sc.nextInt();\n\t\tp = new double[m][n+2];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tp[i][0] = 1;\n\t\t\tfor(int j=1;j<=n;j++)p[i][j]=sc.nextDouble();\n\t\t}\n\t\tdp = new double[1<<n][n+1];\n\t\tfor(double[]d:dp)Arrays.fill(d, -1);\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<=n;j++){\n\t\t\tdouble e = 1;\n\t\t\tfor(int k=0;k<=j;k++)e*=p[i][k];\n\t\t\te*=1-p[i][j+1];\n\t\t\tdp[1<<i][j] = e;\n\t\t}\n\t\tdouble res = 0;\n\t\tfor(int S=1;S<1<<m;S++)res=Math.max(res, get(S, n));\n\t\tSystem.out.printf(\"%.10f\\n\", res);\n//\t\tSystem.out.printf(\"%.10f\\n\", get(1, 0));\n//\t\tSystem.out.printf(\"%.10f\\n\", get(1, 1));\n//\t\tSystem.out.printf(\"%.10f\\n\", get(1, 2));\n//\t\tSystem.out.printf(\"%.10f\\n\", get(1, 3));\n//\t\tSystem.out.printf(\"%.10f\\n\", get(2, n));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic double[][] P;\n\tstatic double[][] memo;\n\n\tpublic static void main(String[] arg) {\n\t\tM = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tP = new double[M][N];\n\t\tmemo = new double[N + 1][1 << M];\n\t\tfor (double[] a : memo) {\n\t\t\tArrays.fill(a, -1);\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tP[i][j] = sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.9f\\n\", rec(0, 0));\n\t}\n\n\tstatic double rec(int pos, int st) {\n\t\tif (pos == N) return 1;\n\t\tif (memo[pos][st] != -1) return memo[pos][st];\n\t\tdouble ret = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif ((st & (1 << i)) != 0) continue;\n\t\t\tdouble prob = 0;\n\t\t\tint nst = st + (1 << i);\n\t\t\tdouble np = 1;\n\t\t\tfor (int j = pos; j < N; ++j) {\n\t\t\t\tprob += np * (1 - P[i][j]) * rec(j, nst);\n\t\t\t\tnp *= P[i][j];\n\t\t\t}\n\t\t\tprob += np * rec(N, nst);\n\t\t\tret = Math.max(ret, prob);\n\t\t}\n\t\tmemo[pos][st] = ret;\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();//猫の数\n\t\tint n = sc.nextInt();//部屋の数\n\t\tdouble[][] p = new double[m][n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tp[i][j] = sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tdouble[][] prob = new double[n + 1][1 << m];\n\t\tArrays.fill(prob[n], 1);\n\t\tfor (int s = (1 << m) - 2; s >= 0; --s) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tif ((s >> j) % 2 == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tmp = 0;\n\t\t\t\t\tdouble mul = 1;\n\t\t\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\t\t\ttmp += prob[k][s | 1 << j] * mul * (1 - (k == n ? 0 : p[j][k]));\n\t\t\t\t\t\tif (k < n)\n\t\t\t\t\t\t\tmul *= p[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tprob[i][s] = Math.max(prob[i][s], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(String.format(\"%.40f\", prob[0][0]));\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();//猫の数\n\t\tint n = sc.nextInt();//部屋の数\n\t\tdouble[][] p = new double[m][n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tp[i][j] = sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tdouble[][] prob = new double[n + 1][1 << m];\n\t\tArrays.fill(prob[n], 1);\n\t\tfor (int s = (1 << m) - 2; s >= 0; --s) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tif ((s >> j) % 2 == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tmp = 0;\n\t\t\t\t\tdouble mul = 1;\n\t\t\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\t\t\ttmp += prob[k][s | 1 << j] * mul * (1 - (k == n ? 0 : p[j][k]));\n\t\t\t\t\t\tif (k < n)\n\t\t\t\t\t\t\tmul *= p[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tprob[i][s] = Math.max(prob[i][s], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(prob[0][0]);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;\n\tstatic Writer out;\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\ttry {\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tmain.solve();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid solve() throws IOException {\n\t\tm = in.nextInt();\n\t\tn = in.nextInt();\n\t\twin = new double[m][n];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\twin[i][j] = in.nextDouble();\n\t\t\t}\n\t\t}\n\t\tdp = new double[n + 1][1 << m];\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tArrays.fill(dp[n], 1);\n\t\tSystem.out.printf(\"%.20f\\n\", dfs(0, 0));\n\t}\n\t\n\tint n, m;\n\tdouble[][] dp;\n\tdouble[][] win;\n\tdouble dfs(int enm, int state) {\n\t\tif(dp[enm][state] >= 0) return dp[enm][state];\n\t\tdouble ans = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tif((state & 1 << i) > 0) continue;\n\t\t\tdouble prob = 1;\n\t\t\tdouble exp = 0;\n\t\t\tfor(int j = enm; j < n; j++) {\n\t\t\t\tdouble w = prob * win[i][j];\n\t\t\t\tdouble l = prob * (1 - win[i][j]);\n\t\t\t\texp += l * dfs(j, state | 1 << i);\n\t\t\t\tprob = w;\n\t\t\t}\n\t\t\texp += prob;\n\t\t\tans = Math.max(ans, exp);\n\t\t}\n\t\treturn dp[enm][state] = ans;\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();//猫の数\n\t\tint n = sc.nextInt();//部屋の数\n\t\tdouble[][] p = new double[m][n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tp[i][j] = sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tdouble[][] prob = new double[n + 1][1 << m];\n\t\tArrays.fill(prob[n], 1);\n\t\tfor (int s = (1 << m) - 2; s >= 0; --s) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\t\tif ((s >> j) % 2 == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdouble tmp = 0;\n\t\t\t\t\tdouble mul = 1;\n\t\t\t\t\tfor (int k = i; k <= n; ++k) {\n\t\t\t\t\t\ttmp += prob[k][s | 1 << j] * mul * (1 - (k == n ? 0 : p[j][k]));\n\t\t\t\t\t\tif (k < n)\n\t\t\t\t\t\t\tmul *= p[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tprob[i][s] = Math.max(prob[i][s], tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(prob[0][0]);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;\n\tstatic Writer out;\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\ttry {\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tmain.solve();\n\t\t\tout.close();\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tvoid solve() throws IOException {\n\t\tm = in.nextInt();\n\t\tn = in.nextInt();\n\t\twin = new double[m][n];\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\twin[i][j] = in.nextDouble();\n\t\t\t}\n\t\t}\n\t\tdp = new double[n + 1][1 << m];\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tArrays.fill(dp[n], 1);\n\t\tsz = 1 << m;\n\t\tSystem.out.println(dfs(0, 0));\n\t}\n\t\n\tint n, m, sz;\n\tdouble[][] dp;\n\tdouble[][] win;\n\tdouble dfs(int enm, int state) {\n\t\tif(dp[enm][state] >= 0) return dp[enm][state];\n\t\tdouble ans = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tif((state & 1 << i) > 0) continue;\n\t\t\tdouble prob = 1;\n\t\t\tdouble exp = 0;\n\t\t\tfor(int j = enm; j < n; j++) {\n\t\t\t\tdouble w = prob * win[i][j];\n\t\t\t\tdouble l = prob * (1 - win[i][j]);\n\t\t\t\texp += l * dfs(j, state | 1 << i);\n\t\t\t\tprob = w;\n\t\t\t}\n\t\t\texp += prob;\n\t\t\tans = Math.max(ans, exp);\n\t\t}\n\t\treturn dp[enm][state] = ans;\n\t}\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic double[][] P;\n\tstatic double[][] memo;\n\n\tpublic static void main(String[] arg) {\n\t\tM = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tP = new double[M][N];\n\t\tmemo = new double[N + 1][1 << M];\n\t\tfor (double[] a : memo) {\n\t\t\tArrays.fill(a, -1);\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tP[i][j] = sc.nextDouble();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(rec(0, 0));\n\t}\n\n\tstatic double rec(int pos, int st) {\n\t\tif (pos == N) return 1;\n\t\tif (memo[pos][st] != -1) return memo[pos][st];\n\t\tdouble ret = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif ((st & (1 << i)) != 0) continue;\n\t\t\tdouble prob = 0;\n\t\t\tint nst = st + (1 << i);\n\t\t\tdouble np = 1;\n\t\t\tfor (int j = pos; j < N; ++j) {\n\t\t\t\tprob += np * (1 - P[i][j]) * rec(j, nst);\n\t\t\t\tnp *= P[i][j];\n\t\t\t}\n\t\t\tprob += np * rec(N, nst);\n\t\t\tret = Math.max(ret, prob);\n\t\t}\n\t\tmemo[pos][st] = ret;\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\n\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var mat = Enumerate(n, x => new double[m]);\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++)\n                    mat[i][j] = rd;\n            var dp = Enumerate(1 << n, x => new double[m]);\n            for (int i = 0; i < 1 << n; i++)\n                for (int j = 0; j < m; j++)\n                    dp[i][j] = -100;\n            Func<int, int, double> dfs = null;\n            dfs = (mask, next) =>\n            {\n                if (next == m) return 1;\n                if (dp[mask][next] >= -1) return dp[mask][next];\n                var ret = 0.0;\n                for (int i = 0; i < n; i++)\n                {\n                    if ((mask >> i & 1) == 1) continue;\n                    var v = 0.0;\n                    var p = 1.0;\n                    for (int j = next; j < m; j++)\n                    {\n                        //lose\n                        v += p * (1 - mat[i][j]) * dfs(mask | (1 << i), j);\n                        //win\n                        p *= mat[i][j];\n                    }\n                    //all win\n                    v += p;\n                    ret = Max(ret, v);\n                }\n\n                return dp[mask][next] = ret;\n            };\n            Console.WriteLine(\"{0:0.0000000000}\", dfs(0, 0));\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Ruby",
    "code": "cat_num, enemy_num = gets.split.map(&:to_i)\nwin_prob = (1..cat_num).map {gets.split.map(&:to_f)}\n\none_pos = []\n(0..(1<<cat_num)-1).each do |x|\n    one_pos[x] = (0..cat_num-1).select {|i| x[i] == 1}\nend\n\ntable = [[1] * cat_num * 2 ** cat_num]\n(1..enemy_num).each do |k|\n    p k\n    table.unshift([0] * cat_num * 2 ** cat_num)\n    (1..(1<<cat_num)-1).each do |x|\n        one_pos[x].each do |c|\n            pr = win_prob[c][-k]\n            y = (c << cat_num) + x\n            z = x - (1 << c)\n            one_pos[z].each do |d|\n                t = table[0][(d << cat_num) + z]\n                table[0][y] = t if t > table[0][y]\n            end\n            table[0][y] *= 1 - pr\n            table[0][y] += pr * table[1][y]\n        end\n    end\n    table.pop\nend\np table[0].max"
  },
  {
    "language": "Ruby",
    "code": "cat_num, enemy_num = gets.split.map(&:to_i)\nwin_prob = (1..cat_num).map {gets.split.map(&:to_f)}\n\none_pos = []\n(0..(1<<cat_num)-1).each do |x|\n    one_pos[x] = (0..cat_num-1).select {|i| x[i] == 1}\nend\n\ntable = [[1] * cat_num * 2 ** cat_num]\n(1..enemy_num).each do |k|\n    table.unshift([0] * cat_num * 2 ** cat_num)\n    (1..(1<<cat_num)-1).each do |x|\n        one_pos[x].each do |c|\n            pr = win_prob[c][-k]\n            y = (c << cat_num) + x\n            z = x - (1 << c)\n            one_pos[z].each do |d|\n                t = table[0][(d << cat_num) + z]\n                table[0][y] = t if t > table[0][y]\n            end\n            table[0][y] *= 1 - pr\n            table[0][y] += pr * table[1][y]\n        end\n    end\n    table.pop\nend\np table[0].max"
  },
  {
    "language": "Ruby",
    "code": "cat_num, enemy_num = gets.split.map(&:to_i)\nwin_prob = (1..cat_num).map {gets.split.map(&:to_f)}\n\ntable = [[1] * cat_num * 2 ** cat_num]\n(1..enemy_num).each do |k|\n    table.unshift([0] * cat_num * 2 ** cat_num)\n    (1..(1<<cat_num)-1).each do |x|\n        (0..cat_num-1).each do |c|\n            next if x[c] == 0\n            y = (c << cat_num) + x\n            pr = win_prob[c][-k]\n            table[0][y] = pr * table[1][y]\n            z = x - (1 << c)\n            table[0][y] += (0..cat_num-1).map {|d|\n                z[d] == 0 ? 0 : table[0][(d << cat_num) + z]\n            }.max * (1 - pr)\n        end\n    end\n    table.pop\nend\np table[0].max"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map(&:to_i)\nwin_rate = (1..m).map { gets.split.map(&:to_f) }\n\ntable = Array(n+1)\ntable[n] = (0..2**m-1).map { 1 }\n\n(n-1).downto(0) do |i|\n    table[i] = [0]\n    (1..2**m-1).each do |x|\n        max = 0\n        (0..m-1).each do|j|\n            next if x[j] == 0\n            sum = 0\n            prob = 1\n            (i..n).each do |k|\n                sum += prob * (1 - (k == n ? 0 : win_rate[j][k])) * table[k][x - (1 << j)]\n                prob *= win_rate[j][k] if k < n\n            end\n            max = sum if sum > max\n        end\n        table[i][x] = max\n    end\nend\n\nprintf(\"%.12f\\n\", table[0][2**m-1])"
  },
  {
    "language": "Ruby",
    "code": "cat_num, enemy_num = gets.split.map(&:to_i)\nwin_prob = (1..cat_num).map {gets.split.map(&:to_f)}\n\none_pos = []\n(0..(1<<cat_num)-1).each do |x|\n    one_pos[x] = (0..cat_num-1).select {|i| x[i] == 1}\nend\n\ntable = [[1] * cat_num * 2 ** cat_num]\n(1..enemy_num).each do |k|\n    table.unshift([0] * cat_num * 2 ** cat_num)\n    retry_best = [0] * 2 ** cat_num\n    (1..(1<<cat_num)-1).each do |x|\n        one_pos[x].each do |c|\n            pr = win_prob[c][-k]\n            y = (c << cat_num) + x\n            table[0][y] = pr * table[1][y] + (1 - pr) * retry_best[x - (1 << c)]\n            retry_best[x] = table[0][y] if table[0][y] > retry_best[x]\n        end\n    end\n    table.pop\nend\np table[0].max"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map &:to_i\na = (1..m).map{gets.split.map(&:to_f) + [0]}\n\ntable = [[0] * n + [1]]\n\n(1..(1<<m)-1).each{|x|\n\ttable[x] = [0] * (n+1) \n\tis = (0..m-1).select{|i| x[i] == 1}\n\t(0..n).each{|c1|\t\n\t\tis.each{|i|\n\t\t\ty = x - (1 << i)\n\t\t\tprob = 1\n\t\t\tsum = 0\n\t\t\tb = a[i]\n\t\t\tt = table[y]\n\t\t\t(c1..n).each{|c2|\n\t\t\t\tsum += prob * (1-b[c2]) * t[c2]\n\t\t\t\tprob *= b[c2]\n\t\t\t}\n\t\t\ttable[x][c1] = sum if sum > table[x][c1]\n\t\t}\n\t}\n}\np table[-1][0]"
  },
  {
    "language": "Ruby",
    "code": "cat_num, enemy_num = gets.split.map(&:to_i)\nwin_prob = (1..cat_num).map {gets.split.map(&:to_f)}\n\none_pos = []\n(0..(1<<cat_num)-1).each do |x|\n    one_pos[x] = (0..cat_num-1).select {|i| x[i] == 1}\nend\n\ntable = [[1] * cat_num * 2 ** cat_num]\n(1..enemy_num).each do |k|\n    table.unshift([0] * cat_num * 2 ** cat_num)\n    retry_best = [0] * 2 ** cat_num\n    (1..(1<<cat_num)-1).each do |x|\n        one_pos[x].each do |c|\n            pr = win_prob[c][-k]\n            y = (c << cat_num) + x\n            table[0][y] = pr * table[1][y] + (1 - pr) * retry_best[x - (1 << c)]\n            retry_best[x] = table[0][y] if table[0][y] > retry_best[x]\n        end\n    end\n    table.pop\nend\nprintf(\"%.10f\\n\", table[0].max)"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map &:to_i\na = (1..m).map{gets.split.map(&:to_f) + [0]}\n\ntable = [[0] * n + [1]]\n\n(1..(1<<m)-1).each{|x|\n\ttable[x] = [0] * (n+1) \n\tis = (0..m-1).select{|i| x[i] == 1}\n\tis.each{|i|\n\t\ty = x - (1 << i)\n\t\tb = a[i]\n\t\tt = table[y]\n\t\th = (0..n).map{|j| (1 - b[j]) * t[j]}\n\t\t(0..n).each{|c1|\t\n\t\t\tprob = 1\n\t\t\tsum = 0\n\t\t\t(c1..n).each{|c2|\n\t\t\t\tsum += prob * h[c2]\n\t\t\t\tprob *= b[c2]\n\t\t\t}\n\t\t\ttable[x][c1] = sum if sum > table[x][c1]\n\t\t}\n\t}\n}\np table[-1][0]"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map(&:to_i)\nwin_rate = (1..m).map { gets.split.map(&:to_f) }\n\ntable = Array(n+1)\ntable[n] = (0..2**m-1).map { 1 }\n\n(n-1).downto(0) do |i|\n    table[i] = [0]\n    (1..2**m-1).each do |x|\n        max = 0\n        (0..m-1).each do|j|\n            next if x[j] == 0\n            wr = win_rate[j][i]\n            prob = wr * table[i+1][x] + (1 - wr) * table[i][x - (1 << j)]\n            max = prob if prob > max\n        end\n        table[i][x] = max\n    end\nend\n\nprintf(\"%.12f\\n\", table[0].max)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = [LF() for _ in range(n)]\n        b = []\n        mx = 1 << n\n        for i in range(mx):\n            t = []\n            for j in range(n):\n                if i & (1<<j):\n                    t.append(j)\n            b.append(t)\n\n        nmx = n * mx\n        ca = [1] * nmx\n        cn = [c<<n for c in range(n)]\n        ci = [1<<c for c in range(n)]\n        for k in range(1,m+1):\n            ka = [a[c][-k] for c in range(n)]\n            na = [0] * nmx\n            re = [0] * mx\n            for x in range(1,mx):\n                for c in b[x]:\n                    y = cn[c] + x\n                    na[y] = ka[c] * ca[y] + (1 - ka[c]) * re[x - ci[c]]\n                    if re[x] < na[y]:\n                        re[x] = na[y]\n            ca = na\n\n        return '{:0.10f}'.format(max(ca))\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef solve():\n    readline = sys.stdin.buffer.readline\n    write = sys.stdout.buffer.write\n    M, N = map(int, readline().split())\n    P = [list(map(float, readline().split())) + [0] for i in range(M)]\n    M2 = (1 << M)\n    dp = [[0]*(N+1) for i in range(M2)]\n    dp[0][N] = 1\n    for state in range(1, M2):\n        dps = dp[state]\n        for k in range(M):\n            if state & (1 << k) == 0:\n                continue\n            pk = P[k]\n            dpk = dp[state ^ (1 << k)]\n            s = 0\n            for i in range(N, -1, -1):\n                s += dpk[i] * (1 - pk[i])\n                dps[i] = max(dps[i], s)\n                s *= pk[i-1]\n    write(b\"%.16f\\n\" % dp[M2-1][0])\nsolve()\n"
  }
]