[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int arrival;\n    int size;\n    int duration;\n} Group;\n\nGroup groups[100] = {\n    {0, 2, 10}, {5, 3, 10}, {10, 2, 5}, {15, 4, 10}, {20, 1, 5},\n    {25, 3, 5}, {30, 2, 5}, {35, 5, 15}, {40, 2, 10}, {45, 3, 10},\n    {50, 2, 5}, {55, 4, 10}, {60, 1, 5}, {65, 3, 5}, {70, 2, 5},\n    {75, 5, 15}, {80, 2, 10}, {85, 3, 10}, {90, 2, 5}, {95, 4, 10},\n    {100, 1, 5}, {105, 3, 5}, {110, 2, 5}, {115, 5, 15}, {120, 2, 10},\n    {125, 3, 10}, {130, 2, 5}, {135, 4, 10}, {140, 1, 5}, {145, 3, 5},\n    {150, 2, 5}, {155, 5, 15}, {160, 2, 10}, {165, 3, 10}, {170, 2, 5},\n    {175, 4, 10}, {180, 1, 5}, {185, 3, 5}, {190, 2, 5}, {195, 5, 15},\n    {200, 2, 10}, {205, 3, 10}, {210, 2, 5}, {215, 4, 10}, {220, 1, 5},\n    {225, 3, 5}, {230, 2, 5}, {235, 5, 15}, {240, 2, 10}, {245, 3, 10},\n    {250, 2, 5}, {255, 4, 10}, {260, 1, 5}, {265, 3, 5}, {270, 2, 5},\n    {275, 5, 15}, {280, 2, 10}, {285, 3, 10}, {290, 2, 5}, {295, 4, 10},\n    {300, 1, 5}, {305, 3, 5}, {310, 2, 5}, {315, 5, 15}, {320, 2, 10},\n    {325, 3, 10}, {330, 2, 5}, {335, 4, 10}, {340, 1, 5}, {345, 3, 5},\n    {350, 2, 5}, {355, 5, 15}, {360, 2, 10}, {365, 3, 10}, {370, 2, 5},\n    {375, 4, 10}, {380, 1, 5}, {385, 3, 5}, {390, 2, 5}, {395, 5, 15},\n    {400, 2, 10}, {405, 3, 10}, {410, 2, 5}, {415, 4, 10}, {420, 1, 5},\n    {425, 3, 5}, {430, 2, 5}, {435, 5, 15}, {440, 2, 10}, {445, 3, 10},\n    {450, 2, 5}, {455, 4, 10}, {460, 1, 5}, {465, 3, 5}, {470, 2, 5},\n    {475, 5, 15}, {480, 2, 10}, {485, 3, 10}, {490, 2, 5}, {495, 4, 10}\n};\n\nint calculate_waiting_time(int n) {\n    int available_seats = 17;\n    int current_time = 0;\n    int waiting_time = 0;\n    int end_times[17] = {0};\n\n    for (int i = 0; i <= n; i++) {\n        Group g = groups[i];\n        current_time = g.arrival;\n        int seats_needed = g.size;\n        int earliest_end = current_time;\n\n        for (int j = 0; j < 17; j++) {\n            if (end_times[j] <= current_time) {\n                end_times[j] = 0;\n            }\n        }\n\n        int free_seats = 0;\n        for (int j = 0; j < 17; j++) {\n            if (end_times[j] == 0) {\n                free_seats++;\n            }\n        }\n\n        if (free_seats >= seats_needed) {\n            int assigned = 0;\n            for (int j = 0; j < 17 && assigned < seats_needed; j++) {\n                if (end_times[j] == 0) {\n                    end_times[j] = current_time + g.duration;\n                    assigned++;\n                }\n            }\n            waiting_time = 0;\n        } else {\n            int min_end_time = end_times[0];\n            for (int j = 1; j < 17; j++) {\n                if (end_times[j] < min_end_time) {\n                    min_end_time = end_times[j];\n                }\n            }\n            waiting_time = min_end_time - current_time;\n            current_time = min_end_time;\n\n            for (int j = 0; j < 17; j++) {\n                if (end_times[j] <= current_time) {\n                    end_times[j] = 0;\n                }\n            }\n\n            free_seats = 0;\n            for (int j = 0; j < 17; j++) {\n                if (end_times[j] == 0) {\n                    free_seats++;\n                }\n            }\n\n            int assigned = 0;\n            for (int j = 0; j < 17 && assigned < seats_needed; j++) {\n                if (end_times[j] == 0) {\n                    end_times[j] = current_time + g.duration;\n                    assigned++;\n                }\n            }\n        }\n    }\n\n    return waiting_time;\n}\n\nint main() {\n    int datasets[20];\n    int count = 0;\n\n    while (scanf(\"%d\", &datasets[count]) == 1 && count < 20) {\n        count++;\n    }\n\n    for (int i = 0; i < count; i++) {\n        int n = datasets[i];\n        if (n >= 0 && n <= 99) {\n            printf(\"%d\\n\", calculate_waiting_time(n));\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:30:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RamenRestaurant {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDatasets = scanner.nextInt();\n        \n        for (int dataset = 0; dataset < numDatasets; dataset++) {\n            int n = scanner.nextInt();\n            \n            int[] arrivalTimes = new int[n+1];\n            int[] groupSizes = new int[n+1];\n            int[] diningDurations = new int[n+1];\n            \n            for (int i = 1; i <= n; i++) {\n                arrivalTimes[i] = scanner.nextInt();\n                groupSizes[i] = scanner.nextInt();\n                diningDurations[i] = scanner.nextInt();\n            }\n            \n            int[] seatOccupancy = new int[101];\n            int waitTime = 0;\n            \n            for (int i = 1; i <= n; i++) {\n                int availableTime = arrivalTimes[i];\n                \n                while (countAvailableSeats(seatOccupancy, availableTime) < groupSizes[i]) {\n                    availableTime++;\n                }\n                \n                for (int j = availableTime; j < availableTime + diningDurations[i]; j++) {\n                    seatOccupancy[j] += groupSizes[i];\n                }\n                \n                if (availableTime > arrivalTimes[i]) {\n                    waitTime = availableTime - arrivalTimes[i];\n                }\n            }\n            \n            System.out.println(waitTime);\n        }\n        \n        scanner.close();\n    }\n    \n    private static int countAvailableSeats(int[] seatOccupancy, int time) {\n        return 17 - seatOccupancy[time];\n    }\n}",
    "timestamp": "2025-08-05 18:30:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Group {\n    int arrival;\n    int size;\n    int duration;\n    int waiting_time;\n};\n\nint main() {\n    vector<int> inputs;\n    int n;\n    while (cin >> n) {\n        inputs.push_back(n);\n        if (inputs.size() >= 20) {\n            break;\n        }\n    }\n\n    vector<Group> groups(100);\n    groups[0] = {0, 0, 0, 0}; // dummy group for 1-based index\n    for (int i = 1; i <= 99; ++i) {\n        groups[i].arrival = (i <= 48) ? (i-1)*5 : 240 + (i-49)*10;\n        groups[i].size = (i % 5 == 0) ? 5 : 2;\n        groups[i].duration = (i % 3 == 1) ? 15 : (i % 3 == 2) ? 30 : 45;\n    }\n\n    queue<Group*> q;\n    int current_time = 0;\n    int available_seats = 17;\n    vector<int> end_times;\n\n    for (int i = 1; i <= 99; ++i) {\n        Group &g = groups[i];\n        while (!end_times.empty() && end_times.front() <= g.arrival) {\n            available_seats += groups[q.front()->size].size;\n            q.pop();\n            end_times.erase(end_times.begin());\n        }\n\n        if (available_seats >= g.size) {\n            g.waiting_time = 0;\n            available_seats -= g.size;\n            q.push(&g);\n            end_times.push_back(g.arrival + g.duration);\n        } else {\n            int earliest_end = end_times.front();\n            g.waiting_time = earliest_end - g.arrival;\n            available_seats += groups[q.front()->size].size;\n            q.pop();\n            end_times.erase(end_times.begin());\n            available_seats -= g.size;\n            q.push(&g);\n            end_times.push_back(earliest_end + g.duration);\n        }\n    }\n\n    for (int idx : inputs) {\n        if (idx >= 0 && idx <= 99) {\n            cout << groups[idx].waiting_time << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:33:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_DATASETS 20\n#define MAX_SEATS 17\n#define MAX_GROUPS 100\n\ntypedef struct {\n    int arrival_time;\n    int group_size;\n    int dining_duration;\n} Group;\n\nint calculate_waiting_time(Group groups[], int num_groups, int target_group) {\n    int seats[MAX_SEATS] = {0};\n    int waiting_times[MAX_GROUPS] = {0};\n\n    for (int i = 0; i < num_groups; i++) {\n        int wait_time = 0;\n        int seat_count = 0;\n\n        // Find available seats\n        for (int j = 0; j < MAX_SEATS; j++) {\n            if (seats[j] <= groups[i].arrival_time) {\n                seats[j] = groups[i].arrival_time + groups[i].dining_duration;\n                seat_count++;\n                if (seat_count == groups[i].group_size) break;\n            }\n        }\n\n        // If not enough seats, calculate waiting time\n        if (seat_count < groups[i].group_size) {\n            int latest_seat_time = 0;\n            for (int j = 0; j < MAX_SEATS; j++) {\n                latest_seat_time = (seats[j] > latest_seat_time) ? seats[j] : latest_seat_time;\n            }\n            wait_time = latest_seat_time - groups[i].arrival_time;\n        }\n\n        waiting_times[i] = wait_time;\n    }\n\n    return waiting_times[target_group];\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n\n    for (int dataset = 0; dataset < num_datasets; dataset++) {\n        int num_groups, target_group;\n        scanf(\"%d %d\", &num_groups, &target_group);\n\n        Group groups[MAX_GROUPS];\n        for (int i = 0; i < num_groups; i++) {\n            scanf(\"%d %d %d\", \n                &groups[i].arrival_time, \n                &groups[i].group_size, \n                &groups[i].dining_duration);\n        }\n\n        int waiting_time = calculate_waiting_time(groups, num_groups, target_group);\n        printf(\"%d\\n\", waiting_time);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:33:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nint calculateWaitTime(int n) {\n    int seats = 17;\n    vector<vector<int>> customers = {\n        {10, 3, 20},  // arrival time, group size, dining duration\n        {12, 4, 30},\n        {15, 2, 15},\n        {18, 5, 40},\n        {20, 3, 25},\n        {22, 6, 35},\n        {25, 4, 45},\n        {28, 2, 20},\n        {30, 5, 50},\n        {33, 3, 30}\n    };\n\n    vector<int> occupiedUntil(seats, 0);\n    int waitTime = 0;\n\n    for (const auto& customer : customers) {\n        int arrivalTime = customer[0];\n        int groupSize = customer[1];\n        int diningDuration = customer[2];\n\n        int earliestAvailableTime = 0;\n        int availableSeats = 0;\n\n        for (int& seatTime : occupiedUntil) {\n            if (seatTime <= arrivalTime) {\n                availableSeats++;\n                earliestAvailableTime = max(earliestAvailableTime, seatTime);\n            }\n        }\n\n        if (availableSeats >= groupSize) {\n            int assignedTime = max(arrivalTime, earliestAvailableTime);\n            int counter = 0;\n\n            for (int& seatTime : occupiedUntil) {\n                if (seatTime <= arrivalTime && counter < groupSize) {\n                    seatTime = assignedTime + diningDuration;\n                    counter++;\n                }\n            }\n\n            if (n == customers.size()) {\n                waitTime = assignedTime - arrivalTime;\n            }\n        } else {\n            if (n == customers.size()) {\n                waitTime = -1;\n            }\n        }\n    }\n\n    return waitTime;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    for (int i = 0; i < min(t, 20); i++) {\n        int n;\n        cin >> n;\n        int result = calculateWaitTime(n);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:33:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RamenRestaurant {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Integer> inputs = new ArrayList<>();\n        while (scanner.hasNextInt() && inputs.size() < 20) {\n            inputs.add(scanner.nextInt());\n        }\n        \n        for (int n : inputs) {\n            if (n < 0 || n > 99) {\n                System.out.println(0);\n                continue;\n            }\n            \n            int arrivalTime = 5 * n;\n            int groupSize = n % 5 == 0 ? 5 : n % 5;\n            int diningDuration = 3 * groupSize + (n % 3 == 0 ? 15 : 0);\n            \n            int availableSeats = 17;\n            int waitingTime = 0;\n            \n            if (groupSize > availableSeats) {\n                waitingTime = -1; // Cannot accommodate\n            } else {\n                waitingTime = Math.max(0, arrivalTime - (availableSeats - groupSize));\n            }\n            \n            System.out.println(waitingTime >= 0 ? waitingTime : 0);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:34:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_waiting_times(datasets):\n    waiting_times = []\n    for dataset in datasets:\n        n = dataset['n']\n        arrivals = dataset['arrivals']\n        seats = 17\n        current_time = 0\n        occupied_seats = 0\n        groups = []\n        \n        for arr in range(n + 1):\n            arrival_time, group_size, dining_duration = arrivals[arr]\n            \n            while groups and groups[0][1] <= arrival_time:\n                free_up_group = groups.pop(0)\n                occupied_seats -= free_up_group[0]\n            \n            if arr == n:\n                waiting_time = 0 if occupied_seats + group_size <= seats else \\\n                (groups[0][1] - arrival_time if groups else 0) + arrival_time - current_time\n                waiting_times.append(waiting_time)\n                continue\n                \n            if occupied_seats + group_size <= seats:\n                current_time = arrival_time\n                groups.append((group_size, arrival_time + dining_duration))\n                occupied_seats += group_size\n                groups.sort(key=lambda x: x[1])\n                \n    return waiting_times\n\n\n# Example input\ndatasets = [\n    {\n        'n': 5,\n        'arrivals': [(0, 3, 40), (3, 5, 50), (7, 2, 70), (15, 10, 30), (20, 12, 100), (30, 4, 10)],\n    },\n    {\n        'n': 2,\n        'arrivals': [(0, 5, 50), (5, 5, 50), (10, 8, 80)],\n    }\n]\n\n# Example of calling the function\nwaiting_times = calculate_waiting_times(datasets)\nfor waiting_time in waiting_times:\n    print(waiting_time)",
    "timestamp": "2025-08-12 23:28:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class RamenWaitingTime {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int maxDatasets = 20;\n        \n        for (int dataset = 0; dataset < maxDatasets; dataset++) {\n            int n = scanner.nextInt(); // the group index to process\n            \n            // Read number of groups\n            int numGroups = scanner.nextInt();\n            \n            // Arrays to hold the information for each group\n            int[] arrivalTimes = new int[numGroups];\n            int[] groupSizes = new int[numGroups];\n            int[] diningDurations = new int[numGroups];\n            \n            for (int i = 0; i < numGroups; i++) {\n                arrivalTimes[i] = scanner.nextInt();\n                groupSizes[i] = scanner.nextInt();\n                diningDurations[i] = scanner.nextInt();\n            }\n            \n            // Array to track seat availability time\n            int[] seatTimes = new int[17]; \n            \n            int waitingTime = 0;\n            \n            for (int i = 0; i <= n; i++) {\n                int groupArrival = arrivalTimes[i];\n                int groupSize = groupSizes[i];\n                int diningDuration = diningDurations[i];\n                \n                // Find the earliest time that enough seats are available for the group\n                int earliestAvailableTime = Integer.MAX_VALUE;\n                \n                for (int j = 0; j <= 17 - groupSize; j++) {\n                    int maxTime = 0;\n                    \n                    for (int k = j; k < j + groupSize; k++) {\n                        maxTime = Math.max(maxTime, seatTimes[k]);\n                    }\n                    \n                    if (maxTime <= groupArrival) {\n                        earliestAvailableTime = Math.min(earliestAvailableTime, groupArrival);\n                    } else {\n                        earliestAvailableTime = Math.min(earliestAvailableTime, maxTime);\n                    }\n                }\n                \n                // Update waiting time\n                if (i == n) {\n                    waitingTime = earliestAvailableTime - groupArrival;\n                }\n                \n                // Update seat availability times\n                for (int j = 0; j <= 17 - groupSize; j++) {\n                    boolean canSeatGroup = true;\n                    \n                    for (int k = j; k < j + groupSize; k++) {\n                        if (seatTimes[k] > earliestAvailableTime) {\n                            canSeatGroup = false;\n                            break;\n                        }\n                    }\n\n                    if (canSeatGroup) {\n                        for (int k = j; k < j + groupSize; k++) {\n                            seatTimes[k] = earliestAvailableTime + diningDuration;\n                        }\n                        break;\n                    }\n                }\n            }\n            \n            System.out.println(waitingTime);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-12 23:28:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_GROUPS 100\n#define MAX_SEATS 17\n\ntypedef struct {\n    int arrivalTime;\n    int groupSize;\n    int diningDuration;\n} Group;\n\nint main() {\n    int numDatasets, n, i, j, currentTime;\n    Group groups[MAX_GROUPS];\n    int endTime[MAX_SEATS];\n    \n    scanf(\"%d\", &numDatasets);\n    \n    while (numDatasets--) {\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++) {\n            scanf(\"%d %d %d\", &groups[i].arrivalTime, &groups[i].groupSize, &groups[i].diningDuration);\n        }\n\n        for (i = 0; i < MAX_SEATS; i++) {\n            endTime[i] = 0;\n        }\n\n        for (i = 0; i <= n; i++) {\n            currentTime = groups[i].arrivalTime;\n            int availableSeats = 0, maxEndTime = 0;\n\n            for (j = 0; j < MAX_SEATS; j++) {\n                if (endTime[j] <= currentTime) {\n                    availableSeats++;\n                } else {\n                    if (endTime[j] > maxEndTime) {\n                        maxEndTime = endTime[j];\n                    }\n                }\n            }\n\n            if (availableSeats < groups[i].groupSize) {\n                currentTime = maxEndTime;\n            }\n\n            for (j = 0, availableSeats = groups[i].groupSize; j < MAX_SEATS && availableSeats > 0; j++) {\n                if (endTime[j] <= currentTime) {\n                    endTime[j] = currentTime + groups[i].diningDuration;\n                    availableSeats--;\n                }\n            }\n\n            if (i == n) {\n                printf(\"%d\\n\", currentTime - groups[i].arrivalTime);\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-12 23:29:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_waiting_time(n, seats, groups):\n    timeline = []\n    for group in groups:\n        timeline.append((group[0], group[1], 1))  # arrival, group size, enter event\n        timeline.append((group[0] + group[2], group[1], -1))  # departure, group size, exit event\n    \n    timeline.sort()\n    current_seats = 0\n    waiting_time = 0\n    \n    for i, (time, group_size, event_type) in enumerate(timeline):\n        if event_type == 1:\n            if current_seats + group_size <= seats:\n                current_seats += group_size\n            else:\n                waiting_time += timeline[i+1][0] - time\n                current_seats += group_size\n        else:\n            current_seats -= group_size\n    \n    return waiting_time\n\ndef main():\n    num_datasets = int(input())\n    \n    for _ in range(num_datasets):\n        n = int(input())\n        seats = 17\n        m = int(input())\n        groups = []\n        \n        for _ in range(m):\n            arrival, group_size, duration = map(int, input().split())\n            groups.append((arrival, group_size, duration))\n        \n        waiting_time = calculate_waiting_time(n, seats, groups)\n        print(waiting_time)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:29:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_waiting_time(n):\n    seats = 17\n    arrival_times = [0] * 100\n    group_sizes = [0] * 100\n    dining_durations = [0] * 100\n    waiting_times = [0] * 100\n    \n    # Initialize the first group\n    arrival_times[0] = 0\n    group_sizes[0] = 5\n    dining_durations[0] = 30\n    \n    # Initialize the second group\n    arrival_times[1] = 5\n    group_sizes[1] = 4\n    dining_durations[1] = 20\n    \n    # Initialize the third group\n    arrival_times[2] = 10\n    group_sizes[2] = 3\n    dining_durations[2] = 15\n    \n    # Initialize the fourth group\n    arrival_times[3] = 15\n    group_sizes[3] = 6\n    dining_durations[3] = 30\n    \n    # Initialize the fifth group\n    arrival_times[4] = 20\n    group_sizes[4] = 4\n    dining_durations[4] = 25\n    \n    # Initialize the sixth group\n    arrival_times[5] = 25\n    group_sizes[5] = 3\n    dining_durations[5] = 15\n    \n    # Initialize the seventh group\n    arrival_times[6] = 30\n    group_sizes[6] = 4\n    dining_durations[6] = 20\n    \n    # Initialize the eighth group\n    arrival_times[7] = 35\n    group_sizes[7] = 6\n    dining_durations[7] = 25\n    \n    # Initialize the ninth group\n    arrival_times[8] = 40\n    group_sizes[8] = 5\n    dining_durations[8] = 40\n    \n    # Initialize the tenth group\n    arrival_times[9] = 45\n    group_sizes[9] = 7\n    dining_durations[9] = 50\n    \n    # Fill the remaining groups (10 to 99) with default values\n    for i in range(10, 100):\n        arrival_times[i] = arrival_times[i-1] + 5\n        group_sizes[i] = (i % 5) + 3\n        dining_durations[i] = (i % 4 + 1) * 10\n    \n    # Calculate waiting times\n    available_seats = seats\n    end_times = []\n    \n    for i in range(100):\n        current_time = arrival_times[i]\n        # Remove groups that have finished dining by current_time\n        end_times = [et for et in end_times if et > current_time]\n        available_seats = seats - sum(group_sizes[j] for j in range(i) if arrival_times[j] + waiting_times[j] + dining_durations[j] > current_time)\n        \n        if group_sizes[i] <= available_seats:\n            waiting_times[i] = 0\n            end_times.append(current_time + dining_durations[i])\n        else:\n            # Find the earliest time when enough seats become available\n            sorted_end_times = sorted(end_times)\n            temp_seats = seats\n            for et in sorted_end_times:\n                temp_seats += group_sizes[end_times.index(et)]\n                if group_sizes[i] <= temp_seats:\n                    waiting_times[i] = et - current_time\n                    end_times.append(et + dining_durations[i])\n                    break\n    \n    return waiting_times[n]\n\ndef main():\n    import sys\n    input_lines = sys.stdin.read().split()\n    datasets = list(map(int, input_lines))\n    for n in datasets:\n        if 0 <= n <= 99:\n            print(calculate_waiting_time(n))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:29:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nstruct Group {\n    int arrivalTime;\n    int size;\n    int diningDuration;\n};\n\nint main() {\n    int n;\n    std::vector<Group> groups;\n    const int maxSeats = 17;\n    int datasetCount = 0;\n\n    while (std::cin >> n && datasetCount < 20) {\n        groups.clear();\n        for (int i = 0; i <= n; ++i) {\n            Group group;\n            std::cin >> group.arrivalTime >> group.size >> group.diningDuration;\n            groups.push_back(group);\n        }\n\n        int currentTime = 0;\n        int currentSeats = 0;\n        std::queue<std::pair<int, int>> queue; // (end time, group size)\n        int waitingTime = 0;\n\n        for (int i = 0; i <= n; ++i) {\n            const Group& g = groups[i];\n\n            // Advance time and free seats\n            currentTime = std::max(currentTime, g.arrivalTime);\n            while (!queue.empty() && queue.front().first <= currentTime) {\n                currentSeats -= queue.front().second;\n                queue.pop();\n            }\n\n            if (currentSeats + g.size <= maxSeats) {\n                // Group can be seated immediately\n                currentSeats += g.size;\n                queue.push({currentTime + g.diningDuration, g.size});\n            } else {\n                // Group has to wait\n                waitingTime = 0;\n                int neededSeats = g.size;\n                for (auto time = currentTime; ; ++time) {\n                    while (!queue.empty() && queue.front().first <= time) {\n                        currentSeats -= queue.front().second;\n                        queue.pop();\n                    }\n\n                    if (currentSeats + neededSeats <= maxSeats) {\n                        currentSeats += g.size;\n                        queue.push({time + g.diningDuration, g.size});\n                        waitingTime = time - g.arrivalTime;\n                        break;\n                    }\n                }\n            }\n            currentTime = std::max(currentTime, queue.back().first);\n        }\n\n        std::cout << waitingTime << std::endl;\n        ++datasetCount;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 10:50:32"
  }
]