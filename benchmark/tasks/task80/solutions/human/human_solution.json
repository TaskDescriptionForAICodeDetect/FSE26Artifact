[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint seki[17] = {0};\n\tint mati[100];\n\tqueue<P> q;\n\tbool hantei2 = false;\n\tfor (int i = 0; ; i++) {\n\t\tif (i % 5 == 0) {\n\t\t\tif (i/5 >= 100) {\n\t\t\t\thantei2 = true;\n\t\t\t} else if ((i/5) % 5 == 1) {\n\t\t\t\tq.push(P(5, i/5));\n\t\t\t} else {\n\t\t\t\tq.push(P(2, i/5));\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 17; j++) {\n\t\t\tif (seki[j] == i) {\n\t\t\t\tseki[j] = 0;\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tP p = q.front();\n\t\t\tbool hantei = false;\n\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\tif (j+p.first-1 >= 17) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (int k = 0; k < p.first; k++) {\n\t\t\t\t\tcounter += seki[j+k];\n\t\t\t\t}\n\t\t\t\tif (counter == 0) {\n\t\t\t\t\tfor (int k = 0; k < p.first; k++) {\n\t\t\t\t\t\tseki[j+k] = i+17*(p.second%2)+3*(p.second%3)+19;\n\t\t\t\t\t}\n\t\t\t\t\tmati[p.second] = i-(p.second*5);\n\t\t\t\t\thantei = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hantei) {\n\t\t\t\tq.pop();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (hantei2 && q.empty()) {\n\t\t\tint counter = 0;\n\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\tcounter += seki[j];\n\t\t\t}\n\t\t\tif (counter == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tcout << mati[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct G{\n  int group, people, now, time;\n};\n\nint main(){\n  int minutes[100];\n  int chair[16];\n  fill_n( chair, 16, -1);\n\n  queue< G > mati;\n\n  for(int i = 0; i < 10000; i++){\n    if(i % 5 == 0 && i / 5 < 100){ //group leave\n      int group = i / 5;\n      mati.push((G){ group, group % 5 == 1 ? 5 : 2, i, 17 * (group % 2) + 3 * (group % 3) + 19});\n    }\n    for(int j = 0; j < 16; j++){\n      if(chair[j] == i) chair[j] = -1;\n    }\n    while(!mati.empty()){\n      bool flag = false;\n      G& g = mati.front();\n      int count = 0, pos = -1;\n      for(int j = 0; j < 16; j++){\n        if(chair[j] == -1){\n          count++;\n          if(pos == -1) pos = j;\n        }else{\n          count = 0;\n          pos = -1;\n        }\n        if(count == g.people){\n          flag = true;\n          break;\n        }\n      }\n      if(flag){\n        minutes[g.group] = i - g.now;\n        for(int j = pos; j < pos + g.people; j++){\n          chair[j] = i + g.time;\n        }\n        mati.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  int n;\n  while(cin >> n){\n    cout << minutes[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 100;\nconst int SEATS = 17;\n\nint* calc() {\n  queue<int> q;\n  int *a = new int[MAX_SIZE]();\n  int g, n, s[SEATS] = {};\n  for (int t = 0; ; ++t) {\n    for (int i = 0; i < SEATS; ++i) {\n      if (s[i]) s[i]--;\n    }\n    if (t % 5 == 0) q.push(t / 5);\n    while (!q.empty()) {\n      bool c = false;\n      g = q.front();\n      n = g % 5 == 1 ? 5 : 2;\n      for (int i = 0; i < SEATS - n; ++i) {\n        if (n == 2 && !(s[i] || s[i + 1])) {\n          s[i] = s[i + 1] = 17 * (g % 2) + 3 * (g % 3) + 19;\n          c = true;\n          break;\n        }\n        if (n == 5 && !(s[i] || s[i + 1] || s[i + 2] || s[i + 3] || s[i + 4])) {\n          s[i] = s[i + 1] = s[i + 2] = s[i + 3] = s[i + 4] = 17 * (g % 2) + 3 * (g % 3) + 19;\n          c = true;\n          break;\n        }\n      }\n      if (c) {\n        a[g] = t - g * 5;\n        if (g == MAX_SIZE - 1) return a;\n        q.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  int *a = calc();\n  while (true) {\n    cin >> n;\n    if (cin.eof()) break;\n    cout << a[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint waitTime[ 100 ];\nconst int NUM_SEATS = 17;\n\nint isVacancy( int* seats, int n )\n{\n\tint empties = 0;\n\tfor( int i = 0; i < NUM_SEATS; ++i ){\n\t\tif( seats[ i ] <= 0 ){\n\t\t\t++empties;\n\t\t\tif( empties == n ){\n\t\t\t\treturn i - n + 1;\n\t\t\t}\n\t\t}else{\n\t\t\tempties = 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid pass( int* seats, int* time )\n{\n\t++*time;\n\tfor( int i = 0; i < NUM_SEATS; ++i ){\n\t\t--seats[ i ];\n\t}\n}\n\nint main()\n{\n\tint seats[ NUM_SEATS ];\n\tmemset( seats, 0, sizeof(seats) );\n\tint time = 0;\n\tfor( int i = 0; i < 100; ++i ){\n\t\twhile( time < i * 5 ){\n\t\t\tpass( seats, &time );\n\t\t}\n\t\tint numPeople = i % 5 == 1 ? 5 : 2;\n\t\tint eatingTime = 17 * ( i % 2 ) + 3 * ( i % 3 ) + 19;\n\t\tint emptySeat = 0;\n\t\twhile( ( emptySeat = isVacancy( seats, numPeople ) ) == -1 ){\n\t\t\tpass( seats, &time );\n\t\t}\n\t\tfor( int j = emptySeat; j < numPeople + emptySeat; ++j ){\n\t\t\tseats[ j ] = eatingTime;\n\t\t}\n\t\twaitTime[ i ] = time - i * 5;\n\t}\n\n\tint input;\n\twhile( cin >> input ){\n\t\tcout << waitTime[ input ] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17] = {-1};\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//?????????????????£?????´???\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n//aaa:\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t//?????????????????´???\n\t\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\t\tbool can_sit;\n\t\t\t\t\tbool sitted = false;\n\t\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcan_sit = true;\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (can_sit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\t\t//goto aaa;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!sitted) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint seat[17];\nvector<int> rm[5000];\nqueue<int> q;\nint result[100];\n\nint ck(int c){\n\tc=c%5==1?5:2;\n\tint suc=0;\n\trep(i,17){\n\t\tif(seat[i]==-1){\n\t\t\tsuc++;\n\t\t\tif(suc==c)return i-suc+1;\n\t\t}\n\t\telse suc=0;\n\t}\n\treturn -1;\n}\nvoid in(int c,int p,int t){\n\tint n=c%5==1?5:2;\n\trep(i,n)seat[i+p]=c;\n\trm[5*c+17*(c%2)+3*(c%3)+19].push_back(c);\n\tresult[c]=t-5*c;\n\tq.pop();\n}\nvoid remove(int c){\n\trep(i,17)if(seat[i]==c)seat[i]=-1;\n}\nint main(){\n\trep(i,17)seat[i]=-1;\n\t\n\tfor(int t=0;t<=500||!q.empty();t++){\n\t\tif(t%5==0)q.push(t/5);\n\t\trep(i,rm[t].size())remove(rm[t][i]);\n\t\tif(q.empty())continue;\n\t\tfor(int p=ck(q.front());p>=0&&!q.empty();p=ck(q.front()))in(q.front(),p,t);\n\t}\n\t\n\tint n;\n\twhile(cin>>n)cout<<result[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[17], c[100];\npriority_queue<pair<int,int> > b;\n\nint can_sit(int n) {\n  int p = 0;\n  for (int i=0; i<17; i++) {\n    if (a[i] == -1) {\n      ++p;\n    } else {\n      p = 0;\n    }\n    if (p == n) {\n      return i-n+1;\n    }\n  }\n  return -1;\n}\n\nint sit(int id, int stt, int n) {\n  for (int i=0; i<n; i++) {\n    a[i+stt] = id;\n  }\n}\n\nint stand(int id) {\n  for (int i=0; i<17; i++) {\n    if (a[i] == id) {\n      a[i] = -1;\n    }\n  }\n}\n\nint main() {\n  int t, p, q, r;\n  for (int i=0; i<17; i++) a[i] = -1;\n  t = 0;\n  p = 0;\n  while (1) {\n    while (t >= 5*p && p<100) {\n      q = (p%5==1) ? 5 : 2;\n      r = can_sit(q);\n      if (r != -1) {\n        c[p] = t - 5*p;\n        sit(p, r, q);\n        b.push(pair<int, int>(-(t + 17*(p%2) + 3*(p%3) + 19), p));\n        p++;\n      } else {\n        break;\n      }\n    }\n    if (-b.top().first <= ((t/5)+1)*5) {\n      t = -b.top().first;\n      stand(b.top().second);\n      b.pop();\n    } else {\n      t = ((t/5)+1)*5;\n    }\n    if (p==100) {\n      break;\n    }\n  }\n\n  while (cin >> t) {\n    cout << c[t] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) REP((i),0,(n))\n#define RREP(i,a,b) for(int i=(int)(a);i>=(int)(b);i--)\n#define rrep(i,n) RREP(i,n,0)\n#define each(it,X) for(__typeof((X).begin())  it=(X).begin();it!=(X).end();it++)\n#define all(v) ((v).begin(),(v).end())\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int,int>pr;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef set<int>si;\nconst int INF=1070000000ll;\nconst int mod=1000000007ll;\n\nint N;\nint a[100];\n\nint seet[17];\nqueue<int>Q;\n\nvoid in(int t){\n    while(!Q.empty()){\n        int p=Q.front();\n        int n=(p%5==1?5:2);\n        bool in_flag=false;\n        for(int i=0;i+n<=17;i++){\n            bool flag=true;\n            for(int j=i;j<i+n;j++){\n                if(seet[j]){\n                    flag=false;\n                    break;\n                }\n            }\n            if(!flag)continue;\n            Q.pop();\n            for(int j=i;j<i+n;j++){\n                seet[j]=17*(p%2)+3*(p%3)+19;\n            }\n            a[p]=t-5*p;\n            in_flag=true;\n            break;\n        }\n        if(!in_flag)return;\n    }\n}\nvoid eat(){\n    for(int i=0;i<17;i++)if(seet[i])seet[i]--;\n}\nsigned main(){\n\n    for(int i=0;i<500||!Q.empty();i++){\n        if(i%5==0&&i<500)Q.push(i/5);\n        in(i);\n        eat();\n    }\n\n    while(scanf(\"%d\",&N)!=EOF)printf(\"%d\\n\",a[N]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int a[100];\n  int cr[17]={};\n  queue<int> que;\n  for(int t=0;t<600;t++){\n    if(t%5==0&&t/5<100){\n      que.push(t/5);\n    }\n    for(int i=0;i<17;i++){\n      cr[i]--;\n    }\n    int fc=0;\n    for(int i=0;i<17;i++){\n      if(cr[i]<=0){\n\tfc++;\n\tif(!que.empty()){\n\t  int gn=que.front();\n\t  int ng=(gn%5==1)?5:2;\n\t  if(fc==ng){\n\t    for(int j=0;j<ng;j++){\n\t      cr[i-j]=17*(gn%2)+3*(gn%3)+19;\n\t    }\n\t    a[gn]=t-gn*5;\n\t    que.pop();\n\t    i=0;\n\t    fc=0;\n\t  }\n\t}\n      }else{\n\tfc=0;\n      }\n    }\n  }\n  for(int n;cin>>n;){\n    cout<<a[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint data[110];\n\nqueue<pii> ar(){\n    queue<pii> ret;\n    rep(i,100){\n        ret.push(pii(i,i*5));\n    }\n    return ret;\n}\n\n\nqueue<pii> de(){\n    vector<pii> tmp;\n    queue<pii> ret;\n    rep(i,100){\n        tmp.pb(pii(i*5+17*(i%2)+3*(i%3)+19,i));\n    }\n    sort(all(tmp));\n    rep(i,100){\n        ret.push(pii(tmp[i].second,tmp[i].first));\n    }\n    return ret;\n}\n\n\n\n\nvoid pre(){\n    int seat[20];\n    rep(i,17)seat[i]=-1;\n    queue<pii> arrive = ar();\n    queue<pii> dep = de();\n    bool flag=true;\n    int now=0;\n    while(arrive.size()+dep.size()){\n        \n        if( flag==false || arrive.empty() || arrive.front().second>dep.front().second  ){ //??¢?????????\n\n            int dep_group = dep.front().first;\n            now =dep.front().second;\n            dep.pop();\n            rep(i,17){\n                if( seat[i]==dep_group ) seat[i]=-1;\n            }\n            flag = true;\n//            printf(\"%3d : \",now);\n//            rep(i,17){\n//                if(seat[i]==-1)cout<<\"__ \";\n//                else printf(\"%02d \",seat[i]);\n//            }cout<<endl;\n        }\n        else{ //??¢?????\\???\n            pii f = arrive.front();\n            int members;\n            if( (f.first)%5==1 )members = 5;\n            else members = 2;\n            \n            int dp[20]={};\n            for(int i=16;i>=0;i--){\n                if(seat[i]!=-1) dp[i] = 0;\n                else            dp[i] = dp[i+1]+1;\n            }\n            \n            flag = false;\n            rep(i,17){\n                if(dp[i]>=members){\n                    for(int j=i;j<i+members;j++){\n                        seat[j] = f.first;\n                    }\n                    flag=true;\n                    arrive.pop();\n                    data[f.first] = max(f.second,now);\n//                    printf(\"%3d : \",max(f.second,now));\n//                    rep(i,17){\n//                        if(seat[i]==-1)cout<<\"__ \";\n//                        else printf(\"%02d \",seat[i]);\n//                    }cout<<endl;\n\n                    break;\n                }\n            }\n        }\n    }\n}\n\n\nint main(){\n    int n;\n    pre();\n    while(cin>>n){\n        cout<<max( 0 , data[n]-(5*(int)n) )<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nstruct cus\n{\n\tint a,b,c,d;\n};\n\nint main()\n{\n\tcus a[100];\n\tfor(int i=0;i<100;i++)\n\t{\n\t\ta[i].a=5*i;\n\t\ta[i].b=(i%5==1?5:2);\n\t\ta[i].c=17*(i%2)+3*(i%3)+19;\n\t\ta[i].d=0;\n\t}\n\tint t[20]={};\n\tfor(int i=0;i<100;i++)\n\t{\n\t\t//for(int j=0;j<17;j++)printf(\"%3d\",t[j]);\n\t\t//cout<<endl;\n\t\tint k=max(a[max(0,i-1)].d,a[i].a);\n\t\tfor(;;k++)for(int j=0;j<17-a[i].b+1;j++)\n\t\t{\n\t\t\tbool x=true;\n\t\t\tfor(int l=j;l<j+a[i].b;l++)\n\t\t\t{\n\t\t\t\tif(t[l]>k)x=false;\n\t\t\t}\n\t\t\tif(x)\n\t\t\t{\n\t\t\t\tfor(int l=j;l<j+a[i].b;l++)\n\t\t\t\t{\n\t\t\t\t\tt[l]=k+a[i].c;\n\t\t\t\t}\n\t\t\t\ta[i].c=k-a[i].a;\n\t\t\t\ta[i].d=k;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t;end:;\n\t}\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tcout<<a[n].c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n\nstruct info{\n  int g, t;\n  info(int g, int t) : g(g), t(t) {}\n};\n\nint arr[MAX];\nvector<info> seat;\n\nint minite(int i){\n  return 17*(i%2) + 3*(i%3) + 19;\n}\n\nvoid make(){\n  int g = 0;\n  for(int i = 0 ; i < 17 ; i++){\n    seat.push_back(info(-1,-1));\n  }\n  vector<info> _wait;\n  for(int i = 0 ; i < 570 ; i++){\n    int size = _wait.size();\n\n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        _wait[j].t++;\n      }\n    }\n   \n    for(int j = 0 ; j < 17 ; j++){\n      if(seat[j].g != -1){\n        seat[j].t--;\n        if(seat[j].t == 0){\n          seat[j].g = seat[j].t = -1;\n        }\n      }\n    }\n \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        int n = _wait[j].g;\n        int cnt, c;\n        bool flg = false;\n        if(n % 5 == 1) cnt = c = 5;\n        else cnt = c = 2;\n        for(int k = 0 ; k < 17 ; k++){\n          if(seat[k].g == -1) cnt--;\n          else cnt = c;\n          if(cnt == 0){\n            for(int l = k-c+1 ; l <= k ; l++){\n              seat[l].g = n;\n              seat[l].t = minite(n);\n            }\n            arr[n] = _wait[j].t;\n            flg = true;\n            j--;\n            _wait.erase(_wait.begin());\n            break;\n          }\n        }\n        if(!flg || !_wait.size()) break;\n      }\n      size = _wait.size();\n    }\n    if(g == 100) continue;\n    if(i % 5 == 0){\n      int cnt, c;\n      bool flg = false;\n      if(size){\n        _wait.push_back(info(g,0));\n        g++;\n        continue;\n      }\n      if(g % 5 == 1) cnt = c = 5;\n      else cnt = c = 2;\n      \n      for(int j = 0 ; j < 17 ; j++){\n        if(seat[j].g == -1) cnt--;\n        else cnt = c;\n        if(cnt == 0){\n          flg = true;\n          for(int k = j-c+1 ;  k <= j ; k++){\n            seat[k].g = seat[k].g = g;\n            seat[k].t = seat[k].t = minite(g);\n          }\n          arr[g] = 0;\n          break;\n        }\n      }\n      if(!flg){\n        _wait.push_back(info(g,0));\n      }\n      g++;\n    }\n  }\n}\n\nint main(){\n  int N;\n\n  make();\n  while(cin >> N){\n    cout << arr[N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tsheets[SHEETS] = -2;\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 50; ++t){\n\n\t\t/*if( t % 5 == 0 ){\n\t\t\tcout << t / 5 << \"ツつウツづアツつェツδ債グツイツδ督つオツづ慊つオツつスツ。\\n\";\n\t\t}*/\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t\t\n\t\t/*for(int i = 0; i < SHEETS; ++i){\n\t\t\tcout << sheets[i] << ' ';\n\t\t}\n\t\tcout << endl;*/\n\t}\n\t/*for(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  queue<int> Q;\n  vector<int> seki(17);\n  Q.push(0);\n  int time = 0;\n  int hoge[100];\n  while(1) {\n    REP(i, 17) if (seki[i]) seki[i]--;\n\n    if (!Q.empty()) {\n      int a = Q.front();\n      if (a >= 100) break;\n      //   cout << \"a\" << \" \" << a << endl;\n    \n      int num = a%5==1 ? 5 : 2;\n      \n      int tmp = 0;\n      REP(i,17) {\n        a = Q.front();\n        if (a >= 100) break;\n        if (seki[i] == 0) ++tmp;\n        else tmp = 0;\n        if (tmp >= num) {\n          for (int j=i-tmp+1; j<=i; ++j) {\n            //         cout << j << endl;\n            hoge[a] = time - a*5;\n            seki[j] = 17*(a%2)+3*(a%3)+19;\n          }\n          Q.pop();\n          if (Q.empty()) break;\n        }\n      }\n      // cout << time << endl;\n      // FOR(it, seki)\n      //   cout << *it << \" \";\n      // cout << endl;\n    }\n    time++;\n    if (time % 5 == 0) Q.push(time/5);\n  }\n  int n;\n  while(cin >> n) {\n    cout << hoge[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct C{\n\tint arr;\t// Ô\n\tint num;\t// l;\n\tint eat;\t// HÔ\n};\n\nP seki[17];\t// ÀÁ½O[vid ÞÈ·éÔ\n\nint res[100];\nC cust[100];\n\nvoid init_val ()\n{\n\trep (i, 17 ){\n\t\tseki[i].first = -1, seki[i].second = -1;\n\t} // end rep\n\tmemset (res, 0, sizeof (res ) );\n}\n\nint is_sit (int n )\n{\n\tint need = cust[n].num;\n\tint si = -1;\n\trep (i, 17 ){\n\t\tif (seki[i].first == -1 ){\n\t\t\tint seat = 0;\n\t\t\tfor (int j = i; seki[j].first == -1 && j < 17; j++ ){\n\t\t\t\tseat++;\n\t\t\t} // end for\n\t\t\tif (seat >= need ){\n\t\t\t\treturn i;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end rep\n\t\n\treturn -1;\n}\n\nvoid sit_down (int id, int si, int t )\n{\n\tint need = cust[id].num;\n\tint endt = t + cust[id].eat;\n\tfor (int i = si, j = 0; j < need; i++, j++ ){\n\t\tseki[i].first = id;\n\t\tseki[i].second = endt;\n\t} // end fpr\n}\n\nint is_depr (int t )\n{\n\tint res = -1;\n\trep (i, 17 ){\n\t\tif (seki[i].second != -1 && seki[i].second <= t ){\n\t\t\tres = seki[i].first;\n\t\t\treturn res;\n\t\t} // end if\n\t} // end rep\n\t\n\treturn -1;\n}\nvoid depr_cust (int id )\n{\n\trep (i, 17 ){\n\t\tif (seki[i].first == id ){\n\t\t\tseki[i].first = -1, seki[i].second = -1;\n\t\t} // end if\n\t} // end rep\n}\n\nint main()\n{\n\trep (i, 100 ){\n\t\tcust[i].arr = 5*i;\n\t\tcust[i].num = (i % 5 == 1 ? 5 : 2 );\n\t\tcust[i].eat =  17*(i%2)+3*(i%3)+19;\n\t} // end rep\n\n\tinit_val ();\n\tqueue<P> que;\t// sñ·éO[vid, sñðJnµ½Ô\n\n\tint id = 0;\t\n\trep (t, 1000 ){\n\t\tint di, si;\n\t\twhile ((di = is_depr (t ) ) != -1 ){\t// ÞÈ·é¨qª¢é©\n\t\t\tdepr_cust (di );\t\t\t\t\t// ÞÈ\n\t\t} // end if\n\t\twhile (!que.empty() ){\t\t\t\t\t// sñÉÀñÅ¢é©\n\t\t\tP w = que.front();\n\t\t\tint wi = w.first;\n\t\t\tint wt = w.second;\n\t\t\tif ((si = is_sit(wi ) ) != -1 ){\t// ÈÉÀêé\n\t\t\t\tres[wi] = t - wt;\n\t\t\t\tsit_down (wi, si, t );\n\t\t\t\tque.pop();\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end if\n\t\tif (t == cust[id].arr ){\t// ¨qª½\n\t\t\tif (que.empty() && ((si = is_sit(id ) ) != -1 ) ){\t// ÈÉÀêé\n \t\t\t\tsit_down (id, si, t );\t// ÈÉÀé\t\t\t\n\t\t\t}else{\t\t\t\t\t\t\t// ÈÉÀêÈ¢\n\t\t\t\tque.push (P (id, t ) );\t// sñÉÁ¦é\n\t\t\t} // end if\n\t\t\tid++;\n\t\t} // end if\n\t} // end rep\n\n\tint n;\n\twhile (cin >> n ){\n\t\tcout << res[n] << endl;\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint d[100][5]={0};//来店時刻/人数/食事時間/着席時間/待ち時間/\nint wait=0;//待っている客の番号\nint Min=0;//現在時間\n\nint isu[17]={0};\nint isu_chk(int num){\n\tint tmp=0;\n\tfor(int i=0;i<17;i++){\n\t\tif(isu[i]==-1)tmp++;\n\t\telse tmp=0;\n\t\tif(tmp>=num)return i-num+1;\n\t}\n\treturn -1;\n}\nvoid tyaku(int pos,int name){\n\tfor(int i=0;i<d[name][1];i++){\n\t\tisu[pos+i]=name;\n\t}\n}\nvoid update(){\n\tfor(int i=0;i<17;i++){\n\t\tif(isu[i]<0)continue;\n\t\tif(Min>=d[isu[i]][2]+d[isu[i]][3]){\n\t\t\tisu[i]=-1;\n\t\t}\n\t}\n}\n\n\nvoid init(){\n\tfor(int i=0;i<17;i++)isu[i]=-1;\n\tfor(int i=0;i<100;i++){\n\t\td[i][0]=5*i;\n\t\td[i][1]=(i%5==1?5:2);\n\t\td[i][2]=17*(i%2)+3*(i%3)+19;\n\t\td[i][3]=-1;\n\t\td[i][4]=-1;\n\t\t//cout<<i<<\"\\t\"<<d[i][0]<<\"\\t\"<<d[i][1]<<\"\\t\"<<d[i][2]<<\"\\n\";\n\t}\n\t\n\tfor(;wait<100;Min++){\n\t\tupdate();\n\t\twhile(true){\n\t\t\tif(Min<d[wait][0])break;\n\t\t\tif(isu_chk(d[wait][1])==-1)break;\n\t\t\td[wait][3]=Min;\n\t\t\td[wait][4]=Min-d[wait][0];\n\t\t\ttyaku(isu_chk(d[wait][1]),wait);\n\t\t\twait++;\n\t\t\tif(wait>=100)break;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit();\n\t\n\tfor(int n;cin>>n;)cout<<d[n][4]<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <iomanip>\nusing namespace std;\n\nint seat[17], countdown[17];\nint arrival[100], sit[100];\n\nint main() {\n    memset(seat, -1, sizeof seat);\n    memset(countdown, 0, sizeof countdown);\n    queue<int> q;\n    for (int m=0; m<1000; ++m) {\n        if (m%5 == 0 && m/5 < 100) {\n            q.push(m/5);\n            arrival[m/5] = m;\n        }\n        for (int i=0; i<17; ++i) {\n            if (countdown[i]) {\n                --countdown[i];\n                if (countdown[i] == 0) {\n                    seat[i] = -1;\n                }\n            }\n        }\n        while ( ! q.empty()) {\n            bool change = false;\n            int num = (q.front()%5 == 1 ? 5 : 2);\n            int time = 17*(q.front()%2) + 3*(q.front()%3) + 19;\n            for (int i=0; i+num-1<17; ++i) {\n                bool ok = true;\n                for (int j=i; j<=i+num-1; ++j) {\n                    if (0 <= seat[j]) ok = false;\n                }\n                if (ok) {\n                    change = true;\n                    for (int j=i; j<=i+num-1; ++j) {\n                        seat[j] = q.front();\n                        countdown[j] = time;\n                    }\n                    sit[q.front()] = m;\n                    q.pop();\n                    break;\n                }\n            }\n            if ( ! change) break;\n        }\n    }\n    int n;\n    while (cin >> n) {\n        cout << sit[n] - arrival[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tsheets[SHEETS] = -2;\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 950; ++t){\n\n\t\t/*if( t % 5 == 0 ){\n\t\t\tcout << t / 5 << \"ツつウツづアツつェツδ債グツイツδ督つオツづ慊つオツつスツ。\\n\";\n\t\t}*/\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t\t\n\t\t/*for(int i = 0; i < SHEETS; ++i){\n\t\t\tcout << sheets[i] << ' ';\n\t\t}\n\t\tcout << endl;*/\n\t}\n\t/*for(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int ans[100];\n    queue<int> row;\n    int t = 0, cur = -1;\n    vector<int> in(17, -1);\n    while(cur != 99){\n        // new customer\n        if(t%5 == 0 && t < 500) row.push(t/5);\n\n        // customer leaves\n        for(int i = 0; i < 17; i++) if(t >= in[i]) in[i] = -1;\n\n        // customer comes in\n        while(!row.empty()){\n            int next = row.front();\n            int num = next%5==1 ? 5 : 2;\n            int i;\n            for(i = 0; i <= 17-num; i++){\n                int vacant = 0;\n                for(int j = 0; j < num; j++){\n                    vacant += (in[i+j]==-1);\n                }\n                if(vacant == num){\n                    break;\n                }\n            }\n            if(i > 17-num)  break;\n            // decide the position i\n            row.pop();\n            int tot = t + 17*(next%2)+3*(next%3)+19;\n            for(int j = 0; j < num; j++){\n                in[i+j] = tot;\n            }\n            ans[next] = t-next*5;\n            cur = next;\n        }\n\n        // time passes\n        t++;\n    }\n\n    int n;\n    while(cin >> n)  cout << ans[n] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct g{\n\tint p,t,e,ans;\n};\n\ng a[100];\nint seat[17];\n\nint main(){\n\tfor(int i=0; i<17; i++)\n\t\tseat[i] = -1;\n\tfor(int i=0; i<100; i++){\n\t\ta[i].p = 2;\n\t\tif(i%5 == 1)\n\t\t\ta[i].p += 3;\n\t\ta[i].t = i*5;\n\t\ta[i].e = 17*(i%2)+3*(i%3)+19;\n\t}\n\tint i=0;\n\tfor(int tim=0;i<100;tim++){\n\t\tcout << i << ' ' << tim << endl;\n\t\tfor(int k=0; k<17; k++){\n\t\t\tif(seat[k] != -1){\n\t\t\t\tif(a[seat[k]].ans+a[seat[k]].t+a[seat[k]].e <= tim)\n\t\t\t\t\tfor(int j=0; j<a[seat[k]].p; j++)\n\t\t\t\t\t\tseat[j+k] = -1;\n\t\t\t\tif(seat[k]%5==1)\n\t\t\t\t\tk+=4;\n\t\t\t\telse\n\t\t\t\t\tk++;\n\t\t\t}\n\t\t}\nP:;\n\t\tif(a[i].t <= tim){\n\t\t\tbool flag = true;\n\t\t\tint tmp = -1;\n\t\t\tfor(int j=0; j<=17-a[j].p; j++){\n\t\t\t\tfor(int k=j; k<j+a[j].p; k++)\n\t\t\t\t\tif(seat[k]!=-1)\n\t\t\t\t\t\tflag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif(flag && tmp != -1){\n\t\t\t\tfor(int j = 0; j<a[i].p; j++)\n\t\t\t\t\tseat[j+tmp] = j;\n\t\t\t\ta[i].ans = tim-a[i].t;\n\t\t\t\ti++;\n\t\t\t\tif(i<100)\n\t\t\t\t\tgoto P;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==6)\n\t\t\tcout << 14 << endl;\n\t\telse\n\t\t\tcout << a[n].ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17] = {-1};\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//?????????????????£?????´???\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\naaa:\n\t\t\t\t//?????????????????´???\n\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\tgoto aaa;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\n\nint ans[200];\nint seat[17];\n\nint check(int n)\n{\n  int size = (n%5==1?5:2);\n  int cnt = 0;\n  rep(i,17)\n    {\n      if(seat[i] == 0)cnt++;\n      else            cnt = 0;\n      if(cnt >= size)\n\treturn i-size+1;\n    }\n  return -1;\n}\n\nint main()\n{\n  rep(i,200)ans[i] = 0;\n  int phase = 0;\n  int group = 0;\n  //17(i%2)+3(i%3)+19 \n  deque<int> que;\n  rep(i,17)seat[i] = 0;\n  while(group < 11)\n    {\n      /*\n      cout << phase << \" --------- \" << endl;\n      if(!que.empty())\n      cout << \"top = \" <<que.front() << endl;\n      */\n      if(phase%5 == 0)\n\t{\n\t  que.push_back(group++);\n\t}\n      rep(i,17)if(seat[i] > 0)seat[i]--;\n      int pos;\n\n      while(!que.empty() && ((pos = check(que.front())) != -1) )\n\t{\n\t  int i = que.front();\n\t  int tm = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t  REP(j,pos,pos+(i%5==1?5:2))\n\t    {\n\t      assert(seat[j] == 0);\n\t      seat[j] = tm;\n\t    }\n\t  que.pop_front();\n\t}\n\n      for(deque<int>::iterator it = que.begin(); it != que.end();it++)\n\t{\n\t  ans[*it]++;\n\t}\n      /*\n      rep(i,16)cout << seat[i] << \" \";\n      cout << endl << endl;\n      */\n      phase++;\n    }\n  int n;\n  while(cin >> n)cout << ans[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    //for(k=0;k<100;k++){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct G{\n  int group, people, now, time;\n};\n\nint main(){\n  int minutes[100];\n  int chair[17]; //あーじゅうななせきあった！！\n  fill_n( chair, 17, 0);\n\n  queue< G > mati;\n\n  for(int i = 0; i < 10000; i++){\n   if(i % 5 == 0 && i / 5 < 100){ //group leave\n      int group = i / 5;\n      mati.push((G){ group, group % 5 == 1 ? 5 : 2, i, 17 * (group % 2) + 3 * (group % 3) + 19});\n    }\n\n\n    while(!mati.empty()){\n      G& g = mati.front();\n      int count = 0, pos = -1;\n      for(int j = 0; j < 17; j++){\n        if(!chair[j]){\n          count++;\n          if(count == g.people){\n            pos = j - g.people + 1;\n            break;\n          }\n        }else{\n          count = 0;\n        }\n      }\n      if(pos != -1){\n        minutes[g.group] = i - g.now;\n        for(int j = pos; j < pos + g.people; j++){\n          chair[j] = g.time;\n        }\n        mati.pop();\n      } else {\n        break;\n      }\n    }\n\n    for(int j = 0; j < 17; j++){\n      if(chair[j] > 0) chair[j]--;\n    }\n\n  }\n  int n;\n  while(cin >> n){\n    cout << minutes[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int visnum = 100;\nconst int seatnum = 17;\nint seat[seatnum];\nint sett[visnum];\nint wait[visnum];\n\nvoid solve(){\n    deque<pair<pair<int,int>,int> > q;\n    FILL(seat,-1);\n    for(int t = 0; t < 500 || !q.empty(); t++){\n        int idx, num, wtt;\n        if(t < 500 && t % 5 == 0){\n            idx = t/5; num = idx%5==1?5:2;\n            q.pb(mp(mp(idx,num),0));\n        }\n        REP(i,seatnum){\n            if(seat[i] < 0) continue;\n            idx = seat[i];\n            if(sett[idx] + 17*(idx%2)+3*(idx%3)+19 <= t){\n                seat[i] = -1;\n            }\n        }\n\n        while(!q.empty()){\n            int ss = -1, sn = 0;\n            idx = q.front().first.first;\n            num = q.front().first.second;\n            wtt = q.front().second;\n            REP(i,seatnum){\n                if(seat[i] < 0){\n                    if(ss < 0) ss = i, sn = 0;\n                    sn++;\n                    if(sn >= num) break;\n                } else ss = -1;\n            }\n\n            if(ss >= 0 && sn >= num){\n                q.pop_front();\n                REPEAT(i,ss,sn) seat[i] = idx;\n                sett[idx] = t;\n                wait[idx] = wtt;\n            } else break;\n        }\n        FOREACH(it,q) it->second++;\n\n#ifdef _DEBUG\n        pf(\"time [%d]\\n\", t);\n        pf(\"q = \"); FOREACH(it,q) pf(\"(%d,%d,%d), \", it->first.first, it->first.second, it->second); pf(\"\\n\");\n        pf(\"s = \"); REP(i,seatnum) if(seat[i]<0)pf(\"-- \"); else pf(\"%2d \", seat[i]); pf(\"\\n\");\n#endif\n    }\n    return;\n}\n\n\nint main(){\n    solve();\n    int n;\n    while(cin >> n){\n        if(n < 0 || n >= 100) throw;\n        cout << wait[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct group {\n\tint id;\n\tint num;\n\tint time;\n};\n\nint cansit(const vector<int>&seats, int num) {\n\tfor (int i = 0; i < 17 - num; ++i) {\n\t\tbool ok = true;\n\t\tfor (int j = i; j < i + num; ++j) {\n\t\t\tif (seats[j] != -1) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok)return i;\n\t}\n\treturn -1;\n}\nvoid dosit(vector<int>&seats, int num, int place,int leavetime) {\n\tfor (int i = place; i < place + num; ++i) {\n\t\tseats[i] = leavetime;\n\t}\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N) {\n\t\tqueue<group>waiting;\n\t\tvector<int>seats(17,-1);\n\t\tvector<int>anss(100);\n\t\tfor (int t = 0; (t<=1000||!waiting.empty()); ++t) {\n\t\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\t\tif (t == seats[i])seats[i] = -1;\n\t\t\t}\n\t\t\tif (!(t % 5)) {\n\t\t\t\tconst int id = t / 5;\n\t\t\t\tif (id < 100) {\n\n\t\t\t\t\tconst int num = id % 5 == 1 ? 5 : 2;\n\t\t\t\t\tconst int time = 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t\t\t\twaiting.push(group{ id,num,time });\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!waiting.empty()) {\n\t\t\t\tgroup atop(waiting.front());\n\t\t\t\tint place = cansit(seats, atop.num);\n\t\t\t\tif (place != -1) {\n\t\t\t\t\tdosit(seats, atop.num, place,atop.time+t);\n\t\t\t\t\tanss[atop.id] = t - atop.id * 5;\n\t\t\t\t\twaiting.pop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << anss[N] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint ans[110], d[18];\n\nint calc(int t, int m){\n\tvi v(18, 0);\n\tfor(int i = 16; i >= 0; i--){\n\t\tif(d[i] <= t) v[i] = v[i+1]+1;\n\t}\n\tfor(int i = 0; i < 17; i++){\n\t\tif(v[i] >= m) return i;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n, t=0, idx;\n\tfor(int i = 0; i < 100; i++){\n\t\tn = i%5==1?5:2;\n\t\tt = max(t,i*5);\n\t\twhile(1){\n\t\t\tidx = calc(t, n);\n\t\t\tif(idx < 0) {\n\t\t\t\tt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i] = t - i*5;\n\t\t\tfor(int j = 0; j < n; j++) d[idx+j] = t + 17*(i%2)+3*(i%3)+19;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\twhile(cin>>n){\n\t\tprintf(\"%d\\n\", ans[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define MP make_pair\n#define F first\n#define S second\n\nenum { INQ, LEAVE };\nint now; bool fiveempty, twoempty;\nint ans[100], seats[17];\nmap<int, queue<pair<int, int> > > mp;\ninline int num(int i) {return i%5==1?5:2;}\ninline int eattime(int i) {return 17*(i%2)+3*(i%3)+19;}\n\nvoid update_emptyseats() {\n  bool fe = 0, te = 0;\n  rep(i, 13)\n    if(seats[i]==-1 &&\n       seats[i+1]==-1 &&\n       seats[i+2]==-1 &&\n       seats[i+3]==-1 &&\n       seats[i+4]==-1) { fe = 1; }\n  rep(i, 16)\n    if(seats[i]==-1 && seats[i+1]==-1) { te = 1; }\n  fiveempty = fe, twoempty = te;\n}\n\nvoid sit(int id) {\n  ans[id] = now-5*id;\n  mp[now+eattime(id)].push(MP(id, (int)LEAVE));\n  \n  if(num(id) == 5) rep(i, 13)\n                     if(seats[i]==-1 &&\n                        seats[i+1]==-1 &&\n                        seats[i+2]==-1 &&\n                        seats[i+3]==-1 &&\n                        seats[i+4]==-1) {\n                       rep(j, 5) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     }\n  \n  if(num(id) == 2) rep(i, 16)\n                     if(seats[i]==-1 && seats[i+1]==-1) {\n                       rep(j, 2) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     } \n}\n\nvoid leave(int id) {\n  rep(i, 17) {\n    if(seats[i] == id) {\n      rep(j, num(id)) { seats[i+j] = -1; }\n      update_emptyseats();\n      return;\n    }\n  }\n}\n\nint main() {\n  \n  rep(i, 100) mp[5*i].push(MP(i, (int)INQ));\n  queue<int> waitingQ;\n  fiveempty = twoempty = 1;\n  memset(seats, -1, sizeof seats);\n  while(!mp.empty()) {\n    now = mp.begin()->F;\n    queue<pair<int, int> >& Q = mp.begin()->S;\n    int id = Q.front().F;\n    int act = Q.front().S; Q.pop();\n    if(act == INQ) {\n      if(!waitingQ.empty()) { waitingQ.push(id); }\n      else if(num(id) == 5 && fiveempty) { sit(id); }\n      else if(num(id) == 2 && twoempty) { sit(id); }\n      else { waitingQ.push(id); }\n    }\n    if(act == LEAVE) {\n      leave(id);\n      while( !waitingQ.empty()\n             && ( (num(waitingQ.front()) == 5 && fiveempty)\n                  || (num(waitingQ.front()) == 2 && twoempty) )\n      ) { sit(waitingQ.front()); waitingQ.pop(); }\n    }\n    if(mp.begin()->S.empty()) mp.erase(mp.begin());\n  }\n  for(int N; cin >> N;) cout << ans[N] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\n\nint ans[200];\nint seat[17];\n\nint check(int n)\n{\n  int size = (n%5==1?5:2);\n  int cnt = 0;\n  rep(i,17)\n    {\n      if(seat[i] == 0)cnt++;\n      else            cnt = 0;\n      if(cnt >= size)\n\treturn i-size+1;\n    }\n  return -1;\n}\n\nint main()\n{\n  rep(i,200)ans[i] = 0;\n  int phase = 0;\n  int group = 0;\n\n  deque<int> que;\n  rep(i,17)seat[i] = 0;\n  while(phase < 600)\n    {\n      /*\n      cout << phase << \" --------- \" << endl;\n      if(!que.empty())\n      cout << \"top = \" <<que.front() << endl;\n      */\n      if(phase%5 == 0 && group < 101)\n\t{\n\t  que.push_back(group++);\n\t}\n      rep(i,17)if(seat[i] > 0)seat[i]--;\n      int pos;\n\n      while(!que.empty() && ((pos = check(que.front())) != -1) )\n\t{\n\t  int i = que.front();\n\t  int tm = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t  //cout << \"top = \" << i << \" tm = \" << tm << \" pos = \" << pos<< endl; \n\n\t  REP(j,pos,pos+(i%5==1?5:2))\n\t    {\n\t      assert(j < 17 && seat[j] == 0);\n\t      seat[j] = tm;\n\t    }\n\t  que.pop_front();\n\t}\n\n      for(deque<int>::iterator it = que.begin(); it != que.end();it++)\n\t{\n\t  if(*it <= 100)\n\t  ans[*it]++;\n\t}\n      /*\n      rep(i,17)cout << seat[i] << \" \";\n      cout << endl << endl;\n      */    \n      phase++;\n    }\n  int n;\n  while(cin >> n)cout << ans[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct group {\n\tint id;\n\tint num;\n\tint time;\n};\n\nint cansit(const vector<int>&seats, int num) {\n\tfor (int i = 0; i <= 17 - num; ++i) {\n\t\tbool ok = true;\n\t\tfor (int j = i; j < i + num; ++j) {\n\t\t\tif (seats[j] != -1) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok)return i;\n\t}\n\treturn -1;\n}\nvoid dosit(vector<int>&seats, int num, int place,int leavetime) {\n\tfor (int i = place; i < place + num; ++i) {\n\t\tseats[i] = leavetime;\n\t}\n}\n\nint main() {\n\tint N;\n\twhile (cin >> N) {\n\t\tqueue<group>waiting;\n\t\tvector<int>seats(17,-1);\n\t\tvector<int>anss(100);\n\t\tfor (int t = 0; (t<=1000||!waiting.empty()); ++t) {\n\t\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\t\tif (t == seats[i])seats[i] = -1;\n\t\t\t}\n\t\t\tif (!(t % 5)) {\n\t\t\t\tconst int id = t / 5;\n\t\t\t\tif (id < 100) {\n\n\t\t\t\t\tconst int num = id % 5 == 1 ? 5 : 2;\n\t\t\t\t\tconst int time = 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t\t\t\twaiting.push(group{ id,num,time });\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!waiting.empty()) {\n\t\t\t\tgroup atop(waiting.front());\n\t\t\t\tint place = cansit(seats, atop.num);\n\t\t\t\tif (place != -1) {\n\t\t\t\t\tdosit(seats, atop.num, place,atop.time+t);\n\t\t\t\t\tanss[atop.id] = t - atop.id * 5;\n\t\t\t\t\twaiting.pop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << anss[N] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    int ans[] = {0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71};\n    while(cin >> n){\n        printf(\"%d\\n\", ans[n]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct C {\n    int n;\n    C() {}\n    C(int n) : n(n) {}\n    int x() {\n        return (n % 5 == 1 ? 5 : 2);\n    }\n    int time() {\n        return 17 * (n % 2) + 3 * (n % 3) + 19;\n    }\n    int arrival() {\n        return n * 5;\n    }\n};\n\n#define INF (1000000)\n\nint T[100];\nint S[17];\n\nbool isEmpty(int t, int x) { // is there x consecutive empty seat after t minutes later\n    for (int i = 0; i < 17 - x + 1; i++) {\n        bool xEmpty = true;\n        for (int j = 0; j < x; j++) {\n            if (S[i+j] > t) {\n                xEmpty = false;\n                break;\n            }\n        }\n        if (xEmpty) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid fillSeat(int t, C c) {\n    int x = c.x();\n    for (int i = 0; i < 17 - x + 1; i++) {\n        bool xEmpty = true;\n        for (int j = 0; j < x; j++) {\n            if (S[i+j] > t) {\n                xEmpty = false;\n                break;\n            }\n        }\n        if (xEmpty) {\n            for (int j = 0; j < x; j++) {\n                S[i+j] = t + c.time();\n            }\n            return;\n        }\n    }\n    cerr << \"Something wrong.\" << endl;\n}\n\nint seat(C c) {\n    int lb = -1, ub = INF;\n    while (lb + 1 != ub) {\n        int mid = (lb + ub) / 2;\n        if (isEmpty(mid, c.x())) {\n            ub = mid;\n        } else {\n            lb = mid;\n        }\n    }\n    //cout << c.n << \" \" << ub << endl;\n    //for (int i = 0; i < 17; i++) cout << S[i] << ' '; cout << endl;\n    int t = max(c.arrival(), ub);\n    fillSeat(t, c);\n    return t;\n}\n\nvoid init() {\n    queue<C> q;\n    for (int i = 0; i < 100; i++) {\n        q.push(C(i));\n    }\n    while (!q.empty()) {\n        C c = q.front(); q.pop();\n        T[c.n] = seat(c);\n        if (c.x() == 5) {\n            // dirty hack\n            for (int i = 0; i < 17; i++) {\n                S[i] = max(S[i], T[c.n]);\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    init();\n    while (cin >> n) {\n        cout << T[n] - C(n).arrival() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint d[17];\n\tint n[100]={0};\n\tint cnt=0,t=0,g;\n\tqueue<int> q;\n\tvector<int> l;\n\trep(i,17)d[i]=0;\n\tfor(;t<30000;t++){\n\t\trep(i,17)if(d[i]>0)d[i]--;\n\t\tif(t%5==0 && cnt < 100){\n\t\t\tl.push_back(cnt);\n\t\t\tq.push(cnt++);\n\t\t}\n\t\tg=1;\n\t\twhile(!q.empty() && g){\n\t\t\tint v=q.front();\n\t\t\tint num=v%5==1?5:2;\n\t\t\tg=0;\n\t\t\tint f=1;\n\t\t\trep(j,17-num){\n\t\t\t\tif(d[j]<1){\n\t\t\t\t\treps(k,1,num-1)if(d[j+k]>0)f=0;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\trep(k,num)d[j+k]=17*(v%2)+3*(v%3)+19;\n\t\t\t\t\t\tg=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(g)break;\n\t\t\t}\n\t\t}\n\t\trep(i,l.size())if(!q.empty() && l[i]>=q.front())n[l[i]]++;\n\t}\n\twhile(~scanf(\"%d\",&t))printf(\"%d\\n\",n[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 130\n\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS];\n\tint peoples[GROUPS] = {0,};\n\tint arrive[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\tarrive[i] = i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 800; ++t){\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i]==sheets[i+1]&&i<SHEETS-1;++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i]==sheets[i+1]&&i<SHEETS-1;++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tif( sheets[i] == -1 ){\n\t\t\t\t\tint cont = 0;\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] == -1 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( now < GROUPS && cont >= peoples[ now ] && t >= arrive[ now ] ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\t\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tcout << \"NOW: \"<<now;\n\t\t\t\t\t\tcout << \" ANS: \" << t << \"-\" << arrive[now] << \"=\" << ans[now] << '\\n';\n\t\t\t\t\t\tcout << \"t=\" << t <<\":\\t\";\n\t\t\t\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\t\t\t\tcout << sheets[i] << ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tans[now] = t - arrive[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont ) break;\n\t\t}\n\t}\n\n\t/*\n\tfor(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}\n\t*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct Event\n{\n\tint time;\n\tint group;\n\tbool isarrival;\n\t\n\tEvent(int t, int g, bool f) : time(t), group(g), isarrival(f) {}\n\tbool operator< (const Event& e)const{\n\t\treturn time == e.time ? isarrival : time > e.time;\n\t}\n};\n\nint main()\n{\n\tint seat[17];\n\tfill_n(seat, 17, -1);\n\t\n\tpriority_queue<Event> Q;\n\trep(i, 100)\n\t\tQ.push(Event(i*5, i, true));\n\t\n\tint answer[100];\n\tqueue<int> que;\n\twhile(!Q.empty()){\n\t\tEvent e = Q.top();\n\t\tQ.pop();\n\t\t\n\t\tbool search = true;\n\t\tif(e.isarrival){\n\t\t\tsearch = que.empty();\n\t\t\tque.push(e.group);\n\t\t}\n\t\telse{\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == e.group)\n\t\t\t\t\tseat[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(search && !que.empty()){\n\t\t\tint n = que.front()%5 == 1 ? 5 : 2;\n\t\t\tint pos = -1;\n\t\t\tint cont = 0;\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == -1){\n\t\t\t\t\t++cont;\n\t\t\t\t\tif(cont == n){\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcont = 0;\n\t\t\t}\n\n\t\t\tif(pos == -1)\n\t\t\t\tsearch = false;\n\t\t\telse{\n\t\t\t\trep(i, n)\n\t\t\t\t\tseat[pos-i] = que.front();\n\t\t\t\tanswer[que.front()] = e.time - que.front() * 5;\n\t\t\t\tQ.push(Event(e.time+17*(que.front()%2)+3*(que.front()%3)+19, que.front(), false));\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\twhile(scanf(\"%d\", &n) != EOF){\n\t\tprintf(\"%d\\n\", answer[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tint ans[100], intime[100];\n\tint chair[17];\n\t\n\tqueue<int> q;\n\tmemset(chair, -1, sizeof(chair));\n\t\n\tint time = 0;\n\twhile (1){\n\t\tif (time % 5 == 0) q.push(time / 5);\n\t\trep:;\n\t\tif (q.size() > 0){\n\t\t\tint x = q.front();\n\t\t\tint num;\n\t\t\tnum = 2 + 3 * (x % 5 == 1);\n\t\t\tfor (int i = 0; i < 17; i++){\n\t\t\t\tint y = chair[i];\n\t\t\t\tif (y == -1) continue;\n\t\t\t\tif (time - intime[y] == 17 * (y % 2) + 3 * (y % 3) + 19)\n\t\t\t\t\tchair[i] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i <= 17 - num; i++){\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i; j < i + num; j++)\n\t\t\t\t\tif (chair[j] != -1) ok = false;\n\t\t\t\tif (ok){\n\t\t\t\t\tintime[x] = time; ans[x] = time - x * 5;\n\t\t\t\t\tif (x == 99) goto end;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor (int j = i; j < i + num; j++)\n\t\t\t\t\t\tchair[j] = x;\n\t\t\t\t\tgoto rep;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttime++;\n\t}\n\tend:;\n\twhile (~scanf(\"%d\", &n)) printf(\"%d\\n\", ans[n]);\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<int> seat(17, -1);\n    multimap<int, int> leave;\n\n    vector<int> waitTime(100);\n    int time = 0;\n    for(int i=0; i<100; ++i){\n        while(leave.size() > 0 && leave.begin()->first <= 5*i){\n            replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n            leave.erase(leave.begin());\n        }\n\n        time = max(time, 5*i);\n        int num = (i%5==1? 5:2);\n        vector<int> tmp(num, -1);\n        for(;;){\n            int j = search(seat.begin(), seat.end(), tmp.begin(), tmp.end()) - seat.begin();\n            if(j == 17){\n                time = leave.begin()->first;\n                while(leave.size() > 0 && leave.begin()->first == time){\n                    replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n                    leave.erase(leave.begin());\n                }\n            }else{\n                for(int k=0; k<num; ++k)\n                    seat[j+k] = i;\n                break;\n            }\n        }\n\n        waitTime[i] = time - 5*i;\n        leave.insert(make_pair(time + 17*(i%2) + 3*(i%3) + 19, i));\n    }\n\n    for(;;){\n        int n;\n        if(!(cin >> n))\n            return 0;\n        cout << waitTime[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint ans[100];\n\nclass G{\npublic:\n  int id,n,a,d; //??°???????????????,?????°,??°?????????,?£??????????\n\n  G(int i){\n    id = i;\n    n = (i % 5 == 1 ? 5 : 2);\n    a = 5 * i;\n    d = 17 * (i % 2) + 3 * (i % 3) + 19;\n  }\n};\n\n//n?????£?¶???§???????¢??????§????????´????????????\nint indexOfSeat(int *seat,int n){\n  int count = 0;\n\n  for(int i=0;i<17;i++){\n    if(!seat[i]){\n      count++;\n      if(count == n) return i - n + 1;\n    }\n    else{\n      count = 0;\n    }\n  }\n\n  return -1;\n}\n\nvoid solve(void){\n  vector<G> v; //????????????\n  for(int i=0;i<100;i++) v.push_back(G(i));\n\n  int time = 0; //?????¨?????????\n  int seat[17]; //????????±\n  memset(seat,0,sizeof(seat));\n\n  while(!v.empty()){\n    while(!v.empty() && v[0].a<=time){\n      int idx = indexOfSeat(seat,v[0].n);\n      if(idx != -1){\n        for(int i=idx;i<idx+v[0].n;i++) seat[i] = v[0].d;\n        ans[v[0].id] = time - v[0].a;\n        v.erase(v.begin());\n      }\n      else{\n        break;\n      }\n    }\n\n    time++;\n    for(int i=0;i<17;i++) if(seat[i] > 0) seat[i]--;\n  }\n}\n\nint main(void){\n  solve();\n\n  int n;\n  while(cin>>n) cout<<ans[n]<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 1;\n\tsheets[0] = sheets[1] = 0;\n\tfor(int t = 0; t < 2000; ++t){\n\t\t\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\tif( eating[sheets[i]] == 0 )\n\t\t\t\t\tsheets[i] = -1;\n\t\t\t\telse{\n\t\t\t\t\t--eating[sheets[i]];\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tcout << \"t=\"<<t<<\":\\t\\t\";\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tcout << (char)(sheets[i]==-1?'_':sheets[i]+'0');\n\t\t}\n\t\tcout << '\\n';\n\t\t*/\n\t\t\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now]-1<0?0:waiting[now]-1;\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nstruct group{\n\tint num;\n\tint eatTime;\n\tint idx;\n};\n\nvoid checkTable(int table[17],queue<group>& que,int time,map<int,int>& waitTime){\n\tfor(int i=0;i<17;i++){\n\t\ttable[i] -= table[i]>=1 ? 1 : 0;\n\t}\n\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=i;j<17;j++){\n\t\t\tif(table[j] > 0) break;\n\t\t\tif(que.empty()) goto end;\n\n\t\t\tif(j-i+1 == que.front().num && que.front().idx * 5 <= time){\n\t\t\t\twaitTime[que.front().idx] = abs(time - que.front().idx * 5);\n\t\t\t\tint num = que.front().num;\n\t\t\t\tint eat = que.front().eatTime;\n\t\t\t\tque.pop();\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\ttable[k] = eat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nend:;\n}\n\nint main(){\n\tint n;\n\tint table[17];\n\tmemset(table,0,sizeof(table));\n\tqueue<group> que;\n\tmap<int,int> waitTime;\n\n\tfor(int i=0;i<100;i++){\n\t\tint num = i % 5 == 1 ? 5 : 2;\n\t\tint eat = 17*(i%2)+3*(i%3)+19;\n\t\tgroup g;\n\t\tg.eatTime = eat;\n\t\tg.idx = i;\n\t\tg.num = num;\n\t\tque.push(g);\t\t\n\t}\n\n\tfor(int i=0;i<1000000;i++){\n\t\tcheckTable(table,que,i,waitTime);\n\t}\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tcout << waitTime[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        ARRIVAL,\n        FINISH\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        return t > e.t;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    eventq.push(Event{Event::FINISH, 500, -1}); // Sentinel\n    queue<int> q;\n    vector<int> seats(17, -1);\n    int lastt = -1;\n    while(!eventq.empty()) {\n        const Event e = eventq.top();\n        eventq.pop();\n        if(e.type == Event::ARRIVAL) {\n            q.push(e.idx);\n        } else {\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == e.idx) seats[i] = -1;\n            }\n        }\n        if(e.t != lastt) {\n            while(!q.empty()) {\n                const int idx = q.front();\n                const int s = gsize(idx);\n                int acc = 0;\n                int pos = -1;\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == -1) {\n                        ++acc;\n                    } else {\n                        acc = 0;\n                    }\n                    if(acc == s) {\n                        pos = i - s + 1;\n                        break;\n                    }\n                }\n                if(pos == -1) break;\n                for(int i = 0; i < s; ++i) {\n                    seats[pos+i] = idx;\n                }\n                res[idx] = e.t - idx*5;\n                eventq.push(Event{Event::FINISH, e.t + 17*(idx%2) + 3*(idx%3) + 19, idx});\n                q.pop();\n            }\n        }\n        lastt = e.t;\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nint countdown[17];\n\nint main() {\n    memset(countdown, 0, sizeof countdown);\n    vector<int> ans;\n    queue<int> q;\n    for (int m=0; (int)ans.size()<100; ++m) {\n        if (m%5 == 0 && m/5 < 100) q.push(m/5);\n        for (int i=0; i<17; ++i) {\n            if (countdown[i]) --countdown[i];\n        }\n        while ( ! q.empty()) {\n            bool change = false;\n            int num = (q.front()%5 == 1 ? 5 : 2);\n            for (int i=0; i+num-1<17; ++i) {\n                bool ok = true;\n                for (int j=i; j<=i+num-1; ++j) {\n                    if (0 < countdown[j]) ok = false;\n                }\n                if (ok) {\n                    change = true;\n                    for (int j=i; j<=i+num-1; ++j) {\n                        countdown[j] = 17*(q.front()%2) + 3*(q.front()%3) + 19;\n                    }\n                    ans.push_back(m - (5 * q.front()));\n                    q.pop();\n                    break;\n                }\n            }\n            if ( ! change) break;\n        }\n    }\n    int n;\n    while (cin >> n) {\n        cout << ans[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for(int i = 0; i < n; i++)\nint nums[100];\nint c[17];\n\nbool get_chair(int n, int x){\n  rep(i, 17 - n + 1){\n    bool ok = true;\n    rep(j, n){\n      if(c[i+j] > 0) ok = false;\n    }\n    if(ok){\n      rep(j, n) c[i+j] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  int t = 0;\n  fill(c, c + 17, 0);\n  queue<int> que;\n  while(t < 500 || !que.empty()){\n\n    if(t < 500 && t % 5 == 0){\n      que.push(t/5);\n    \n    }\n\n    while(!que.empty()){\n      int a = que.front();\n\n      if(a % 5 == 1){\n\tif(get_chair(5, (a % 2) * 17 + (a % 3) * 3 + 19)){\n\t  nums[a] = t - a * 5;\n\t  que.pop();\n\t}else break;\n      }else{\n\tif(get_chair(2, (a % 2) * 17 + (a % 3) * 3 + 19)){\n\t  nums[a] = t - a * 5;\n\t  que.pop();\n\t}else break;\n      }\n    }\n\n    rep(i, 17) if(c[i] > 0) c[i]--;\n    t++;\n  }\n\n  while(cin >> n){\n    cout << nums[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  queue<int> Q;\n  vector<int> seki(17);\n  Q.push(0);\n  int time = 0;\n  int hoge[100];\n  while(1) {\n    REP(i, 17) if (seki[i]) seki[i]--;\n\n    if (!Q.empty()) {\n      int a = Q.front();\n      if (a >= 100) break;\n      //    cout << \"a\" << \" \" << a << endl;\n    \n      int num = a%5==1 ? 5 : 2;\n      \n      int tmp = 0;\n      REP(i,17) {\n        a = Q.front();\n        if (a >= 100) break;\n        if (seki[i] == 0) ++tmp;\n        else tmp = 0;\n        if (tmp >= num) {\n          for (int j=i-tmp+1; j<=i; ++j) {\n//            cout << j << endl;\n            hoge[a] = time - a*5;\n            seki[j] = 17*(a%2)+3*(a%3)+19;\n          }\n          Q.pop();\n          tmp = 0;\n          if (Q.empty()) break;\n        }\n      }\n      // cout << time << endl;\n      // FOR(it, seki)\n      //   cout << *it << \" \";\n      // cout << endl;\n    }\n    time++;\n    if (time % 5 == 0) Q.push(time/5);\n  }\n  int n;\n  while(cin >> n) {\n    cout << hoge[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 0)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101;\nconst int W = 17;\nint wait[MAXN];\nint u[W];\n\nvoid make() {\n  fill(u, u+W, 0);\n  queue<pair<int,int> > que;\n  for(int t = 0, i = 0; i < 100 || que.size(); ++t) {\n    if(i < 100 && t == 5*i) que.push(make_pair(i++, t));\n    while(que.size()) {\n      int k = que.front().first;\n      int s = que.front().second;\n      int x = k%5 == 1 ? 5 : 2;\n      int d = 17 * (k%2) + 3*(k%3) + 19;\n\n      int pos = -1;\n      for(int j = 0; j+x <= W; ++j) {\n        bool flag = true;\n        for(int a = 0; a < x; ++a) {\n          if(u[j+a] > t) {\n            flag = false;\n            break;\n          }\n        }\n        if(flag) {\n          pos = j;\n          break;\n        }\n      }\n      if(pos == -1) break;\n      wait[k] = t - s;\n      que.pop();\n      for(int a = 0; a < x; ++a) u[pos+a] = t + d;\n    }\n  }\n}\n\nint main() {\n  make();\n  int n;\n  while(cin >> n) {\n    cout << wait[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define mp make_pair\nusing namespace std;\n\nstruct P{ int tim,group,act; };\n\nstruct comp {\n\tbool operator()(P t1, P t2) const {\n\t\tif(t1.tim != t2.tim) return t1.tim > t2.tim;\n\t\telse return t1.act < t2.act;\n \t}\n};\n\nint chair[17];\n\nint emp(int num){\n\tfor(int i = 0;i < 17 - num + 1;i++){\n\t\tbool flag = true;\n\t\tfor(int j = 0;j < num;j++){\n\t\t\tif(chair[i + j] != -1) flag = false;\n\t\t}\n\t\tif(flag) return i;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n,front = -1,wait[100] = {};\n\tpriority_queue<P,vector<P>,comp> que;\n\tqueue<int> line;\n\tfor(int i = 0;i < 17;i++) chair[i] = -1;\n\tfor(int i = 0;i < 100;i++) que.push({i * 5,i,0});\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint t = p.tim,group = p.group,act = p.act;\n\t\tif(act == 0){\n\t\t\tint num = 2,pos;\n\t\t\tif(group % 5 == 1) num = 5;\n\t\t\tpos = emp(num);\n\t\t\tif(!line.empty() || pos == -1) line.push(group);\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < num;i++) chair[i + pos] = group;\n\t\t\t\tque.push({t + 17 * (group % 2) + 3 * (group % 3) + 19,group,1});\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0;i < 17;i++){\n\t\t\t\tif(chair[i] == group) chair[i] = -1;\n\t\t\t}\n\t\t\twhile(!line.empty()){\n\t\t\t\tint g = line.front(),num = 2,pos;\n\t\t\t\tif(g % 5 == 1) num = 5;\n\t\t\t\tpos = emp(num);\n\t\t\t\tif(pos != -1){\n\t\t\t\t\tline.pop();\n\t\t\t\t\twait[g] = t - g * 5;\n\t\t\t\t\tfor(int i = 0;i < num;i++) chair[pos + i] = g;\n\t\t\t\t\tque.push({t + 17 * (g % 2) + 3 * (g % 3) + 19,g,1});\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> n){\n\t\tcout << wait[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint Time[100];// = {  0,  5, 10, 15, 20, 25, 30, 35, 40, 45};\nint peop[100];// = {  2,  5,  2,  2,  2,  2,  5,  2,  2,  2};\nint eats[100];// = { 19, 39, 25, 36, 22, 42, 19, 39, 25, 36};\nint star[100];\nint tabl[17];\nint ans[100];\n\nint main(){\n  int next = 0;\n  REP(i,100){\n    Time[i] = 5 * i;\n    peop[i] = (i%5 == 1 ? 5 : 2);\n    eats[i] = 17*(i%2) + 3*(i%3) + 19;\n  }\n\n  REP(i,17) tabl[i] = -1;\n  for(int i=0; ; i++){\n    REP(j,17) if(tabl[j] != -1){\n      int t = tabl[j];\n      if(star[t] + eats[t] == i){\n        tabl[j] = -1;\n      }\n    }\n\n  loop:\n    if(next == 100) goto end;\n    if(Time[next] <= i){\n      int cnt = 0;\n      int st  = -1;\n      REP(j,17){\n        if(tabl[j] == -1){\n          if(cnt == 0) st = j;\n          cnt++;\n          if(cnt == peop[next])\n            break;\n        }else cnt = 0;\n      }\n      if(cnt == peop[next]){\n        ans[next] = i - Time[next];\n        star[next] = i;\n        REP(j,peop[next])\n          tabl[st + j] = next;\n        next++;\n        goto loop;\n      }\n    }\n\n    /*\n    printf(\"%d: \",i);\n    REP(j,17){printf(\"%3d \",tabl[j]);} puts(\"\");\n    getchar();\n    */\n  }\n\n end:\n  int n;\n  while(~scanf(\"%d\",&n))\n    print(ans[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint t[110];\nint now[20];\nint p[110];\nint q[110];\nint r[110];\nint main(){\n\tfor(int i=0;i<100;i++){\n\t\tp[i]=i*5;\n\t\tif(i%5==1)q[i]=5;\n\t\telse q[i]=2;\n\t\tr[i]=17*(i%2)+3*(i%3)+19;\n\t}\n\tint at=0;\n\tfor(int i=0;i<17;i++)now[i]=-1;\n\tfor(int i=0;i<5000;i++){\n\t\tfor(int j=0;j<at;j++){\n\t\t\tif(i==t[j]+r[j])for(int k=0;k<17;k++)if(now[k]==j)now[k]=-1;\n\t\t}\n\t\twhile(at<=min(99,i/5)){\n\t\t\tint len=0;\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tif(!~now[j])len++;\n\t\t\t\telse len=0;\n\t\t\t\tif(len==q[at]){\n\t\t\t\t\tfor(int k=j-q[at]+1;k<=j;k++)now[k]=at;\n\t\t\t\t\tok=true;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)t[at++]=i;\n\t\t\telse break;\n\t\t}\n\t}int a;\n\twhile(~scanf(\"%d\",&a)){\n\t\tprintf(\"%d\\n\",t[a]-a*5);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int, P > PP;\nint n,ans[100];\nPP t[500];\nPP u[500];\nint ts,te,us,ue;\nint state[17];\n\nvoid t_in(PP x){\n  t[te]=x;\n  te++;\n}\nvoid u_in(PP x){\n  u[ue]=x;\n  ue++;\n}\nPP t_out(){\n  ts++;\n  return t[ts-1];\n}\nPP u_out(){\n  us++;\n  return u[us-1];\n}\n\n\nint u_check(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\n\nvoid u_ins(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  \n  \n  u_out();\n}\nint u_check2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\nvoid u_ins2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n}\n\nint main(){\n  ts=us=te=ue=0;\n\n  for(int i=0;i<100;i++)ans[i]=0;\n  for(int i=0;i<17;i++)state[i]=-1;\n\n  for(int i=0;i<100;i++){\n    t_in(PP(5*i,P(1,i)));\n  }\n\n  sort(t+ts,t+te);\n\n  PP x,y;\n  int flg,z;\n  while(!(ts==te)){\n    /*\n    cout<<endl;\n    for(int i=0;i<17;i++)printf(\"%3d \",state[i]);\n    cout<<\"u\"<<endl;\n    for(int i=us;i<ue;i++)printf(\"%3d \",u[i].second.second);\n    cout<<endl;\n    cout<<endl;\n    */\n    sort(t+ts,t+te);\n    y=x;\n    x=t_out();\n\n    \n    for(int i=us;i<ue;i++)ans[u[i].second.second]+=(x.first-y.first);\n\n    if(x.second.first==0){\n      for(int i=0;i<17;i++)if(state[i]==x.second.second)state[i]=-1;\n      while(1){\n\tif(us==ue)break;\n\tflg=u_check();\n\tif(flg==0)break;\n\tu_ins();\n\tz=x.second.second;\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n            \n    }else if(x.second.first==1){\n      flg=u_check2(x);\n\n      if(flg==0||us!=ue){\n\tu_in(x);\n      }else{\n\tu_ins2(x);\n\n\tz=x.second.second;\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n    }//if\n  }\n\n  \n  \n  while(cin>>n){\n    for(int i=n;i<=n;i++)cout<<ans[i]<<' ';\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        ARRIVAL,\n        FINISH\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        return t > e.t;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    eventq.push(Event{Event::FINISH, 500, -1}); // Sentinel\n    queue<int> q;\n    vector<int> seats(17, -1);\n    int lastt = -1;\n    while(!eventq.empty()) {\n        const Event e = eventq.top();\n        eventq.pop();\n        if(e.type == Event::ARRIVAL) {\n            q.push(e.idx);\n        } else {\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == e.idx) seats[i] = -1;\n            }\n        }\n        if(e.t != lastt) {\n            while(!q.empty()) {\n                const int idx = q.front();\n                const int s = gsize(idx);\n                int acc = 0;\n                int pos = -1;\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == -1) {\n                        ++acc;\n                    } else {\n                        acc = 0;\n                    }\n                    if(acc == s) {\n                        pos = i - s + 1;\n                        break;\n                    }\n                }\n                if(pos == -1) break;\n                for(int i = 0; i < s; ++i) {\n                    seats[pos+i] = idx;\n                }\n                res[idx] = lastt - idx*5;\n                eventq.push(Event{Event::FINISH, lastt + 17*(idx%2) + 3*(idx%3) + 19, idx});\n                q.pop();\n                /*\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == -1) cout << '-';\n                    else cout << seats[i]%10;\n                }\n                cout << endl;\n                */\n            }\n        }\n        lastt = e.t;\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct g{\n\tint p,t,e,ans;\n};\n\ng a[100];\nint seat[17];\n\nint main(){\n\tfor(int i=0; i<17; i++)\n\t\tseat[i] = -1;\n\tfor(int i=0; i<100; i++){\n\t\ta[i].p = 2;\n\t\tif(i%5 == 1)\n\t\t\ta[i].p += 3;\n\t\ta[i].t = i*5;\n\t\ta[i].e = 17*(i%2)+3*(i%3)+19;\n\t}\n\tint i=0;\n\tfor(int tim=0;i<100;tim++){\n\t\tfor(int k=0; k<17; k++){\n\t\t\tif(seat[k] != -1){\n\t\t\t\tif(a[seat[k]].ans+a[seat[k]].t+a[seat[k]].e <= tim)\n\t\t\t\t\tfor(int j=0; j<a[seat[k]].p; j++)\n\t\t\t\t\t\tseat[j+k] = -1;\n\t\t\t\tif(seat[k]%5==1)\n\t\t\t\t\tk+=4;\n\t\t\t\telse\n\t\t\t\t\tk++;\n\t\t\t}\n\t\t}\nP:;\n\t\tif(a[i].t <= tim){\n\t\t\tbool flag = true;\n\t\t\tint tmp = -1;\n\t\t\tfor(int j=0; j<=17-a[i].p; j++){\n\t\t\t\tfor(int k=j; k<j+a[i].p; k++)\n\t\t\t\t\tif(seat[k]!=-1)\n\t\t\t\t\t\tflag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif(tmp != -1){\n\t\t\t\tfor(int j = 0; j<a[i].p; j++)\n\t\t\t\t\tseat[j+tmp] = i;\n\t\t\t\ta[i].ans = tim-a[i].t-1;\n\t\t\t\ti++;\n\t\t\t\tif(i<100)\n\t\t\t\t\tgoto P;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n)\n\t\tcout << a[n].ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 2)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        ARRIVAL,\n        FINISH\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        return t > e.t;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    queue<int> q;\n    vector<int> seats(17, -1);\n    while(!eventq.empty()) {\n        const Event e = eventq.top();\n        eventq.pop();\n        if(e.type == Event::ARRIVAL) {\n            q.push(e.idx);\n        } else {\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == e.idx) seats[i] = -1;\n            }\n        }\n        while(!q.empty()) {\n            const int idx = q.front();\n            const int s = gsize(idx);\n            int acc = 0;\n            int pos = -1;\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == -1) {\n                    ++acc;\n                } else {\n                    acc = 0;\n                }\n                if(acc == s) {\n                    pos = i - s + 1;\n                    break;\n                }\n            }\n            if(pos == -1) break;\n            for(int i = 0; i < s; ++i) {\n                seats[pos+i] = idx;\n            }\n            res[idx] = e.t - idx*5;\n            eventq.push(Event{Event::FINISH, e.t + 17*(idx%2) + 3*(idx%3) + 19, idx});\n            q.pop();\n        }\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint Brank(vint v, int num)\n{\n\trep(i, v.size() - num + 1)\n\t{\n\t\trep(j, num)\n\t\t{\n\t\t\tif(v[i + j] != -1) break;\n\t\t\telse if(j + 1 == num) return i;\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main()\n{\n    for(int n; cin >> n;)\n\t{\n\t\tqueue<int>  que; // id\n\t\tvint store(17, -1); // time\n\t\tint nxt = 0, start;\n\t\t\n\t\tfor(int time = 0; ; time++)\n\t\t{\n\t\t\t// ツ行ツ療アツづ可嘉つヲツづゥ\n\t\t\tif(time % 5 == 0)\n\t\t\t{\n\t\t\t\tif(nxt == n) start = time;\n\t\t\t\t\n\t\t\t\tque.push(nxt++);\n\t\t\t}\n\t\t\t\n\t\t\t// ツ店ツつゥツづァツ出ツつキ\n\t\t\trep(i, 17)\n\t\t\t\tstore[i] = (store[i] == time ? -1 : store[i]);\n\t\t\t\n\t\t\t// ツ店ツづ可禿シツづェツづゥ\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tint id = que.front();\n\t\t\t\tint num = (id % 5 == 1 ? 5 : 2);\n\t\t\t\t\n\t\t\t\tint index = Brank(store, num);\n\t\t\t\t\n\t\t\t\tif(index != -1)\n\t\t\t\t{\n\t\t\t\t\tif(id == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << time - start << endl;\n\t\t\t\t\t\tgoto ng;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint span = 17 * (id % 2) + 3 * (id % 3) + 19; \n\t\t\t\t\tREP(i, index, index + num) \n\t\t\t\t\t{\n\t\t\t\t\t\tstore[i] = time + span;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tque.pop();\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\tng:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\nusing namespace std;\n \n int main() {\n  int i=0,j,k=0,m,f,n,t=0,s[17],ad[100],len[100],ans[100];\n  multimap<int,int> mp;\n  for (k=0;k<17;k++) s[k]=-1;\n  while(true) {\n  for (;i<100;i++) {\n\t  len[i]=(i % 5)==1 ? 5 : 2;\n\t  for (j=0;j<17-len[i];j++) {\n\t\t  for (k=0;k<len[i];k++) if (s[j+k]>=0) break;\n\t\t  if (k==len[i])  { for (k=j;k<j+len[i];k++) s[k]=i; \n\t\t  ans[i]=t>i*5 ? t-5*i : 0;\n\t\t  ad[i]=j;\n\t\t  mp.insert(multimap<int,int>::value_type(i*5+17*(i%2)+3*(i%3)+19,i)); \n\t\t  break;} \n\t  }\n      if (j==17-len[i]) break;\n  }\n  if (i==100) break;\n  t=(*mp.begin()).first;\n  while(!mp.empty() && (*mp.begin()).first ==t) {\n\t  m=(*mp.begin()).second;\n\t  for (j=ad[m]; j<ad[m]+len[m]; j++) s[j]=-1;\n\t  mp.erase(mp.begin());\n     }\n  }\n  while(cin >> n) cout << ans[n] << endl;\n   return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define mp make_pair\nusing namespace std;\n\nstruct P{ int tim,group,act; };\n\nstruct comp {\n\tbool operator()(P t1, P t2) const {\n\t\tif(t1.tim != t2.tim) return t1.tim > t2.tim;\n\t\telse return t1.act > t2.act;\n \t}\n};\n\nint chair[17];\n\nint emp(int num){\n\tfor(int i = 0;i < 17 - num + 1;i++){\n\t\tbool flag = true;\n\t\tfor(int j = 0;j < num;j++){\n\t\t\tif(chair[i + j] != -1) flag = false;\n\t\t}\n\t\tif(flag) return i;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n,front = -1,wait[100] = {};\n\tpriority_queue<P,vector<P>,comp> que;\n\tqueue<int> line;\n\tfor(int i = 0;i < 17;i++) chair[i] = -1;\n\tfor(int i = 0;i < 100;i++) que.push({i * 5,i,0});\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint t = p.tim,group = p.group,act = p.act;\n\t\tif(act == 0){\n\t\t\tint num = 2,pos;\n\t\t\tif(group % 5 == 1) num = 5;\n\t\t\tpos = emp(num);\n\t\t\tif(!line.empty() || pos == -1) line.push(group);\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < num;i++) chair[i + pos] = group;\n\t\t\t\tque.push({t + 17 * (group % 2) + 3 * (group % 3) + 19,group,1});\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0;i < 17;i++){\n\t\t\t\tif(chair[i] == group) chair[i] = -1;\n\t\t\t}\n\t\t\twhile(!line.empty()){\n\t\t\t\tint g = line.front(),num = 2,pos;\n\t\t\t\tif(g % 5 == 1) num = 5;\n\t\t\t\tpos = emp(num);\n\t\t\t\tif(pos != -1){\n\t\t\t\t\tline.pop();\n\t\t\t\t\twait[g] = t - g * 5;\n\t\t\t\t\tfor(int i = 0;i < num;i++) chair[pos + i] = g;\n\t\t\t\t\tque.push({t + 17 * (g % 2) + 3 * (g % 3) + 19,g,1});\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> n){\n\t\tcout << wait[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tsheets[SHEETS] = -2;\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 590; ++t){\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\t\t\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, a[209], b[209], e[209], ret[209];\nint main() {\n\tfor (int i = 0; i < 200; i++) {\n\t\ta[i] = (i % 5 == 1 ? 5 : 2);\n\t\tb[i] = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t}\n\tint h = 0;\n\tfill(e, e + 200, -1);\n\tvector<int> s(17, -1);\n\tfor (int i = 0; i < 1000; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tif (e[j] + b[j] == i) {\n\t\t\t\tfor (int k = 0; k < 17; k++) {\n\t\t\t\t\tif (s[k] == j) s[k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (h <= i / 5) {\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k <= 17 - a[h]; k++) {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor (int l = k; l < k + a[h]; l++) {\n\t\t\t\t\tif (s[l] != -1) flag = false;\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tfill(s.begin() + k, s.begin() + k + a[h], h);\n\t\t\t\t\tret[h] = i - h * 5;\n\t\t\t\t\te[h++] = i;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t}\n\twhile (cin >> n) cout << ret[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nint main(){\n\tint m = 17;\n\tqueue<int> q;\n\tvector<int> v(m,-1);\n\tset<Pii> st;\n\tint t = 0;\n\tvector<int> ans(100);\n\n\twhile(t < 1000 || !q.empty()){\n\t\tbool change = false;\n\t\tif((t % 5 == 0) && (t / 5 < 100)){\n\t\t\tint i = t/5;\n\t\t\tq.push(i);\n\t\t\tst.insert(Pii(17*(i%2)+3*(i%3)+19 + t,i));\n\t\t\tans[i] = t;\n\t\t\tchange = true;\n\t\t}\n\n\t\twhile(!st.empty() && (*(st.begin())).first == t){\n\t\t\tint c = (*(st.begin())).second;\n\t\t\tst.erase(st.begin());\n\t\t\tFOR(i,m) if(v[i] == c) v[i] = -1;\n\t\t\tchange = true;\n\t\t}\n\n\t\tif(change) while(!q.empty()){\n\t\t\tint c = q.front();\n\t\t\tint l = (c%5 == 1) ? 5 : 2;\n\t\t\tint cnt = 0;\n\t\t\tint st = -1;\n\t\t\tFOR(i,m){\n\t\t\t\tif(v[i] == -1) cnt++;\n\t\t\t\telse cnt = 0;\n\t\t\t\tif(cnt == l){\n\t\t\t\t\tst = i - l + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(st != -1){\n\t\t\t\tq.pop();\n\t\t\t\tans[c] = t - ans[c];\n\t\t\t\tFOR(i,l) v[i+st] = c;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tt++;\n\t}\n\n\tint n;\n\twhile(cin>>n){\n\t\tcout << ans[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint ans[110];\nP seat[20];\nqueue<int> waiting;\nint Cnt = 0;\n\nvoid outputSeat(){\n  for(int i = 0 ; i < 17 ; i++){\n    printf(\"%3d \", seat[i].first);\n  }\n  cout << endl;\n  \n  for(int i = 0 ; i < 17 ; i++){\n    printf(\"%3d \", seat[i].second);\n  }\n  cout << endl << endl;\n}\n\nbool come(int n, int t){\n  int group = n % 5 == 1 ? 5 : 2;\n  int cnt = 0, s = 0;\n  bool f = false;\n  for(int i = 0 ; i < 17 ; i++){\n    if(seat[i].first == -1 && !f){\n      s = i;\n      f = true;\n    }\n    \n    if(seat[i].first == -1){\n      cnt++;\n    }\n    \n    else cnt = 0, s = i+1, f = false;\n  \n    if(cnt == group){\n      //cout << \"OK\"<<endl;\n      for(int j = s ; j < s+group ; j++){\n\tseat[j].first = n;\n\tseat[j].second = 17*(n%2) + 3*(n%3) + 19 + t;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n  \nvoid off(int n){\n  for(int i = 0 ; i < 17 ; i++){\n    if(seat[i].first == n) seat[i].first = -1, seat[i].second = -1;\n  }\n}\n\nvoid solve(){\n  for(int t = 0 ; t <= 610 ; t++){\n    //outputSeat();\n    //cout << \"time = \" << t << endl;\n    for(int i = 0 ; i < 17 ; i++){\n      if(seat[i].second == t){\n\toff(seat[i].first);\n\tif(waiting.size() > 0){\n\t  int num = waiting.front();\n\t  while(1){\n\t    bool f = come(num, t);\n\t    if(f){\n\t      ans[num] = t - ans[num];\n\t      waiting.pop();\n\t      num = waiting.front();\n\t      if(num == 0) break;\n\t    }\n\t    else break;\n\t  }\n\t}\n      }\n    }\n    \n    //cout << \"front = \" << waiting.front() << endl;\n    \n    if(t % 5 == 0 && Cnt < 100){\n      Cnt++;\n      int number = t / 5;\n      if(waiting.size() > 0){\n\tans[number] = t;\n\twaiting.push(number);\n\tcontinue;\n      }\n      bool f = come(number, t);\n      if(f) ans[number] = 0;\n      else{\n\twaiting.push(number);\n\tans[number] = t;\n      }\n    }    \n    \n  }\n  \n}\n\nvoid init(){\n  memset(seat, -1 , sizeof(seat));  \n  memset(ans, 0, sizeof(ans));\n}\n\nint main(){\n  init();\n  solve();\n  int n;\n\n  while(cin >> n) cout << ans[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c<9){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n <= 5)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=2){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<int> seat(17, -1);\n    multimap<int, int> leave;\n\n    vector<int> waitTime(100);\n    int time = 0;\n    for(int i=0; i<100; ++i){\n        while(leave.size() > 0 && leave.begin()->first <= 5*i){\n            replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n            leave.erase(leave.begin());\n        }\n\n        time = max(time, 5*i);\n        int num = (i%5==1? 5:2);\n        vector<int> tmp(num, -1);\n        for(;;){\n            int j = search(seat.begin(), seat.end(), tmp.begin(), tmp.end()) - seat.begin();\n            if(j == 17){\n                time = leave.begin()->first;\n                replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n                leave.erase(leave.begin());\n            }else{\n                for(int k=0; k<num; ++k)\n                    seat[j+k] = i;\n                break;\n            }\n        }\n\n        waitTime[i] = time - 5*i;\n        leave.insert(make_pair(time + 17*(i%2) + 3*(i%3) + 19, i));\n    }\n\n    for(;;){\n        int n;\n        if(!(cin >> n))\n            return 0;\n        cout << waitTime[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 130\n\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint arrive[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tsheets[SHEETS] = -2;\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\tarrive[i] = i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 800; ++t){\n\n\t\tif( t % 10 == 0 ){\n\t\t\t//int a;\n\t\t\t//cin >> a;\n\t\t}\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tif( i < SHEETS )\n\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] == -1 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( now < GROUPS && cont >= peoples[ now ] && t >= arrive[ now ] ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\t\n\t\t\t\t\t\t/*cout << \"NOW: \"<<now;\n\t\t\t\t\t\tcout << \" ANS: \" << t << \"-\" << arrive[now] << \"=\" << ans[now] << '\\n';\n\t\t\t\t\t\tcout << \"t=\" << t <<\":\\t\";\n\t\t\t\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\t\t\t\tcout << sheets[i] << ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tans[now] = t - arrive[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t/*\n\tfor(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}\n\t*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\n\nint ans[200];\nint seat[16];\n\nint check(int n)\n{\n  int size = (n%5==1?5:2);\n  int cnt = 0;\n  rep(i,16)\n    {\n      if(seat[i] == 0)cnt++;\n      else            cnt = 0;\n      if(cnt >= size)\n\treturn i-size+1;\n    }\n  return -1;\n}\n\nint main()\n{\n  rep(i,200)ans[i] = 0;\n  int phase = 0;\n  int group = 0;\n  //17(i%2)+3(i%3)+19 \n  deque<int> que;\n  rep(i,16)seat[i] = 0;\n  while(group < 105)\n    {\n      //cout << phase << \" --------- \" << endl;\n      //if(!que.empty())\n\t//cout << \"top = \" <<que.front() << endl;\n\t//rep(i,16)cout << seat[i] << \" \";\n\t//cout << endl << endl;\n      if(phase%5 == 0)\n\t{\n\t  que.push_back(group++);\n\t}\n      rep(i,16)if(seat[i] > 0)seat[i]--;\n      int pos;\n\n      while(!que.empty() && ((pos = check(que.front())) != -1) )\n\t{\n\t  int i = que.front();\n\t  int tm = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t  REP(j,pos,pos+(i%5==1?5:2))\n\t    {\n\t      assert(seat[j] == 0);\n\t      seat[j] = tm;\n\t    }\n\t  que.pop_front();\n\t}\n\n      for(deque<int>::iterator it = que.begin(); it != que.end();it++)\n\t{\n\t  ans[*it]++;\n\t}\n\n      phase++;\n    }\n  int n;\n  while(cin >> n)cout << ans[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nmain(){\n  int data[100][2], ans[101];\n  int seki[17], q=0;\n  for(int i=0;i<100;i++){\n    if(i%5==1){\n      data[i][0]=5;\n    }\n    else{\n      data[i][0]=2;\n    }\n    data[i][1]=17*(i%2)+3*(i%3)+19;\n  }\n  for(int i=0;i<17;i++){\n    seki[i]=0;\n  }\n  \n  for(int i=0;i<1000;i++){\n    // printf(\"!%d! \", i);\n    for(int j=0;j<17;j++){\n      //printf(\"%2d \", seki[j]);\n    }\n    //printf(\"\\n\");\n    for(int j=0;j<17;j++){\n      if(seki[j]>0){\n\tseki[j]--;\n      }\n    }\n\n    while(q<=i/5){\n      int tmp=q;\n      if(data[q][0]==2){\n\tfor(int j=0;j<16;j++){\n\t  if(seki[j]==0 && seki[j+1]==0){\n\t    seki[j]=seki[j+1]=data[q][1];\n\t    ans[q]=i-q*5;\n\t    q++;\n\t    break;\n\t  }\n\t}\n      }\n      else{\n\tfor(int j=0;j<13;j++){\n\t  if(seki[j]==0 && seki[j+1]==0 && seki[j+2]==0 && seki[j+3]==0 && seki[j+4]==0){\n\t    seki[j]=seki[j+1]=seki[j+2]=seki[j+3]=seki[j+4]=data[q][1];\n\t    ans[q]=i-q*5;\n\t    q++;\n\t    break;\n\t  }\n\t}\n      }\n      if(tmp==q) break;\n    }\n  }\n  \n  int n;\n  while(cin >> n){\n    cout << ans[n] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        FINISH,\n        ARRIVAL\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        if(t != e.t) return t > e.t;\n        return type > e.type;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    queue<int> q;\n    vector<int> seats(17, -1);\n    while(!eventq.empty()) {\n        const Event e = eventq.top();\n        eventq.pop();\n        if(e.type == Event::ARRIVAL) {\n            q.push(e.idx);\n        } else {\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == e.idx) seats[i] = -1;\n            }\n        }\n        while(!q.empty()) {\n            const int idx = q.front();\n            const int s = gsize(idx);\n            int acc = 0;\n            int pos = -1;\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == -1) {\n                    ++acc;\n                } else {\n                    acc = 0;\n                }\n                if(acc == s) {\n                    pos = i - s + 1;\n                    break;\n                }\n            }\n            if(pos == -1) break;\n            for(int i = 0; i < s; ++i) {\n                seats[pos+i] = idx;\n            }\n            res[idx] = e.t - idx*5;\n            eventq.push(Event{Event::FINISH, e.t + 17*(idx%2) + 3*(idx%3) + 19, idx});\n            q.pop();\n        }\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nint main(){\n    int d[17]; int n[100]={0}; int cnt=0,t=0;\n    queue<int> q; rep(i,17)d[i]=0;\n    for(;cnt<100;t++){\n        if(t%5==0 && t<500)q.push(t/5);\n        while(!q.empty()){\n            int v=q.front();\n            int num=v%5==1?5:2;\n            int g=0;\n            rep(j,18-num){\n            \tif(d[j]<1 && !g){g=1;reps(k,1,num-1){\n                    \tif(d[j+k]>0)g=0;\n                    }\n                    if(g){rep(k,num)d[j+k]=17*(v%2)+3*(v%3)+19;}\n                }\n            }\n            if(!g)break;\n            q.pop();\n            n[v]=t-v*5;\n            cnt++;\n        }\n        rep(i,17)if(d[i]>0)d[i]--;\n    }\n    while(~scanf(\"%d\",&t))printf(\"%d\\n\",n[t]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint seat[17];\nint res[200];\n\nint main() {\n\tint i;\n\tint j;\n\tint k=-1;\n\tfor(i=0;i<600;i++){\n//cout<<i<<endl;\n\t\tfor(j=0;j<17;j++){\n\t\t\tif(seat[j])seat[j]--;\n//cout<<\" \"<<j<<\" \"<<seat[j]<<endl;\n\t\t}\n\t\tif(k==-1){\n\t\t\tif(i%5==0){\n\t\t\t\tk=i/5;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint l;\n\t\t\tif(k==-1)break;\n\t\t\tif(k%5==1){\n\t\t\t\tfor(l=0;l<17-5;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]+seat[l+2]+seat[l+3]+seat[l+4]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=seat[l+2]=seat[l+3]=seat[l+4]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<17-2;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\ta:;\n\t\t}\n//cout<<i<<endl;\n//for(j=0;j<17;j++){\n//\tcout<<\" \"<<j<<\" \"<<seat[j]<<endl;\n//}\n\t}\n\tint n;\n//for(n=0;n<100;n++){\n//\tcout<<n<<\" \"<<res[n]<<endl;\n//}\n\twhile(cin>>n){\n\t\tcout<<res[n]<<endl;\n\t}\n\treturn 0;\n}\n\n//WA"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=7){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int N = 100;\nconst int T = 17;\n\nvoid check(int cnt[N], P c[T], queue<int> &q, int &l, int &t){\n  REP(i, T){\n    if(c[i].first == -1) continue;\n    int n = c[i].first;\n    if(c[i].second + (17 * (n % 2) + 3 * (n % 3) + 19) == t){\n      l = max(l, c[i].first);\n      c[i] = P(-1, -1);\n    }\n  }\n  while(!q.empty()){\n    int n = q.front();\n    int m = (n % 5 == 1 ? 5 : 2);\n    bool ff = false;\n    REP(i, T - m + 1){\n      bool f = true;\n      REP(j, m) if(c[i + j].first != -1) f = false;\n      if(f){\n        cnt[n] = t - n * 5;\n        REP(j, m) c[i + j] = P(n, t);\n        ff = true;\n        q.pop();\n        break;\n      }\n    }\n    if(!ff) break;\n  }\n}\n\nint main() {\n  int cnt[N], l = -1, t = 0;\n  P c[T];\n  memset(cnt, 0, sizeof(cnt));\n  REP(i, T) c[i] = P(-1, -1);\n  queue<int> q;\n  while(l < N){\n    if(t % 5 == 0) q.push(t / 5);\n    check(cnt, c, q, l, t);\n    ++t;\n  }\n  int n;\n  while(cin >>n) cout <<cnt[n] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint search_sequence(vector<int> &a,int n){\n\tint cnt=0;\n\tfor(int i=0;i<a.size();++i){\n\t\tif(a[i]==-1)++cnt;\n\t\telse cnt=0;\n\t\tif(cnt>=n)return i-cnt+1;\n\t}\n\treturn -1;\n}\n\nint main(void){\n    vector<int> seat(17,-1);\n    int time[100],finish[100];\n    queue<pair<int,int> > q;\n    int x=0,y=0;\n    for(int t=0;y<100;++t){\n      if(t%5==0) q.push(make_pair(x++,(x%5==1)?5:2));\n      for(int i=0;i<17;++i){\n        if(seat[i]!=-1&&finish[seat[i]]==t){\n        \tfill(&seat[i],&seat[i+((seat[i]%5==1)?5:2)],-1);\n        \t//cerr<<t<<\":\";for(int i=0;i<17;++i)cerr<<seat[i]<<((i!=16)?\" \":\"\\n\");\n      \t}\n      }\n      while(search_sequence(seat,q.front().second)!=-1){\n        fill(&seat[search_sequence(seat,q.front().second)],&seat[search_sequence(seat,q.front().second)+q.front().second],q.front().first);\n        //cerr<<t<<\":\";for(int i=0;i<17;++i)cerr<<seat[i]<<((i!=16)?\" \":\"\\n\");\n        finish[q.front().first]=t+17*(q.front(\n        ).first%2)+3*(q.front().first%3)+19;\n        time[q.front().first]=t-5*q.front().first;\n        q.pop();++y;\n      }\n    }\n  int n;\n  while(cin>>n){\n  \tcout<<time[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tmap<int,vector<int> > escape;\n\n\tint data[100];\n\t\tint field[17];\n\t\tfill(field,field+17,-1);\n\n\t\tqueue<int> waitQueue;\n\t\tint group=0;\n\t\tint time=0;\n\n\t\tvector<int> c;\n\t\twhile(cin>>n){\n\t\t\tc.push_back(n);\n\t\t}\n\t\t\n\t\tfor(int i=0;;i++){\n\t\t\ttime=i;\n\t\t\tif(i%5==0){\n\t\t\t\twaitQueue.push(group);\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\t// Ü¸ÔØêO[vðÈ©çÇ©·\n\t\t\tfor(map<int,vector<int> >::iterator it = escape.begin(); it != escape.end(); it++){\n\t\t\t\tif(it->first==i){\n\t\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\t\tfor(int k = 0; k< it->second.size(); k++){\n\t\t\t\t\t\t\tif(field[j]==it->second[k]){\n\t\t\t\t\t\t\t\tfield[j]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tit->second.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool f=false;\n\t\t\tint prvCand=-1;\n\t\t\t// ·íêé¾¯·íç¹é\n\t\t\twhile(1){\n\t\t\t\tif(waitQueue.size()==0)\n\t\t\t\t\tbreak;\n\t\t\t\t// ¡ñÀç¹él\n\t\t\t\tint cand=waitQueue.front();\n\t\t\t\tif(prvCand==cand)\n\t\t\t\t\tbreak;\n\t\t\t\tint s;\n\t\t\t\tint mergen=-1;\n\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\tif(field[j]==-1&&j!=16){\n\t\t\t\t\t\tif(mergen==-1){\n\t\t\t\t\t\t\ts=j;\n\t\t\t\t\t\t\tmergen=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmergen++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(cand%5==1){\n\t\t\t\t\t\t\tif(mergen>=5){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 5+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\t\tcout<<cand<<endl;\n\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(mergen>=2){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 2+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t\tprvCand=cand;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\n\t\t}\n\t\tfor(int i = 0; i < c.size(); i++){\n\t\t\t// ±±ÅÜ¿Ôð\\¦\n\t\t\tcout<<data[c[i]]<<endl;\n\t\t}\n//\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n < 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=2){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct g{\n\tint p,t,e,ans;\n};\n\ng a[100];\nint seat[17];\n\nint main(){\n\tfor(int i=0; i<17; i++)\n\t\tseat[i] = -1;\n\tfor(int i=0; i<100; i++){\n\t\ta[i].p = 2;\n\t\tif(i%5 == 1)\n\t\t\ta[i].p += 3;\n\t\ta[i].t = i*5;\n\t\ta[i].e = 17*(i%2)+3*(i%3)+19;\n\t}\n\tint i=0;\n\tfor(int tim=0;i<100;tim++){\n\t\tfor(int k=0; k<17; k++){\n\t\t\tif(seat[k] != -1){\n\t\t\t\tif(a[seat[k]].ans+a[seat[k]].t+a[seat[k]].e <= tim)\n\t\t\t\t\tfor(int j=0; j<a[seat[k]].p; j++)\n\t\t\t\t\t\tseat[j+k] = -1;\n\t\t\t}\n\t\t}\nP:;\n\t\tif(a[i].t <= tim){\n\t\t\tbool flag = true;\n\t\t\tint tmp = -1;\n\t\t\tfor(int j=0; j<=17-a[i].p; j++){\n\t\t\t\tfor(int k=j; k<j+a[i].p; k++)\n\t\t\t\t\tif(seat[k]!=-1)\n\t\t\t\t\t\tflag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif(tmp != -1){\n\t\t\t\tfor(int j = 0; j<a[i].p; j++)\n\t\t\t\t\tseat[j+tmp] = i;\n\t\t\t\ta[i].ans = tim-a[i].t;\n\t\t\t\ti++;\n\t\t\t\tif(i<100)\n\t\t\t\t\tgoto P;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n)\n\t\tcout << a[n].ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        ARRIVAL,\n        FINISH\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        return t > e.t;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    eventq.push(Event{Event::FINISH, 500, -1}); // Sentinel\n    queue<int> q;\n    vector<int> seats(17, -1);\n    int lastt = -1;\n    while(!eventq.empty()) {\n        const Event e = eventq.top();\n        eventq.pop();\n        if(e.type == Event::ARRIVAL) {\n            q.push(e.idx);\n        } else {\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == e.idx) seats[i] = -1;\n            }\n        }\n        if(e.t != lastt) {\n            while(!q.empty()) {\n                const int idx = q.front();\n                const int s = gsize(idx);\n                int acc = 0;\n                int pos = -1;\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == -1) {\n                        ++acc;\n                    } else {\n                        acc = 0;\n                    }\n                    if(acc == s) {\n                        pos = i - s + 1;\n                        break;\n                    }\n                }\n                if(pos == -1) break;\n                for(int i = 0; i < s; ++i) {\n                    seats[pos+i] = idx;\n                }\n                res[idx] = e.t - idx*5;\n                eventq.push(Event{Event::FINISH, lastt + 17*(idx%2) + 3*(idx%3) + 19, idx});\n                q.pop();\n                /*\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == -1) cout << '-';\n                    else cout << seats[i]%10;\n                }\n                cout << endl;\n                */\n            }\n        }\n        lastt = e.t;\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tint ans[100], intime[100];\n\tint chair[17];\n\t\n\tqueue<int> q;\n\tmemset(chair, -1, sizeof(chair));\n\t\n\tint time = 0;\n\twhile (1){\n\t\tif (time % 5 == 0) q.push(time / 5);\n\t\t\n\t\tfor (int i = 0; i < 17; i++){\n\t\t\tint y = chair[i];\n\t\t\tif (y == -1) continue;\n\t\t\tif (time - intime[y] == 17 * (y % 2) + 3 * (y % 3) + 19)\n\t\t\t\tchair[i] = -1;\n\t\t}\n\t\t\n\t\trep:;\n\t\tif (q.size() > 0){\n\t\t\tint x = q.front();\n\t\t\tint num;\n\t\t\tnum = 2 + 3 * (x % 5 == 1);\n\t\t\t\n\t\t\tfor (int i = 0; i <= 17 - num; i++){\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int j = i; j < i + num; j++)\n\t\t\t\t\tif (chair[j] != -1) ok = false;\n\t\t\t\tif (ok){\n\t\t\t\t\tintime[x] = time; ans[x] = time - x * 5;\n\t\t\t\t\tif (x == 99) goto end;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor (int j = i; j < i + num; j++)\n\t\t\t\t\t\tchair[j] = x;\n\t\t\t\t\tgoto rep;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttime++;\n\t}\n\tend:;\n\twhile (~scanf(\"%d\", &n)) printf(\"%d\\n\", ans[n]);\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n,c[17],d[100];\nmain()\n{\n\tfor(int i=0;i<17;i++)c[i]=-1;\n\tpriority_queue<pair<int,int> >P;\n\tint now=0;\n\tfor(int i=0;i<100;i++)\n\t{\n\t\twhile(!P.empty()&&-P.top().first<=i*5)\n\t\t{\n\t\t\tint u=P.top().second;\n\t\t\tP.pop();\n\t\t\tfor(int j=0;j<17;j++)if(c[j]==u)c[j]=-1;\n\t\t}\n\t\tint L=-1;\n\t\twhile(L<0)\n\t\t{\n\t\t\tfor(int j=0;j+(i%5==1?5:2)<=17;j++)\n\t\t\t{\n\t\t\t\tbool ok=1;\n\t\t\t\tfor(int k=0;k<(i%5==1?5:2);k++)ok&=c[j+k]==-1;\n\t\t\t\tif(ok)\n\t\t\t\t{\n\t\t\t\t\tL=j;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(L>=0)break;\n\t\t\tpair<int,int>p=P.top();P.pop();\n\t\t\tnow=-p.first;\n\t\t\tfor(int j=0;j<17;j++)if(c[j]==p.second)c[j]=-1;\n\t\t}\n\t\tif(now<i*5)now=i*5;\n\t\tP.push(make_pair(-now-(17*(i%2)+3*(i%3)+19),i));\n\t\td[i]=now-i*5;\n\t\tfor(int k=0;k<(i%5==1?5:2);k++)c[L+k]=i;\n\t}\n\twhile(cin>>n)cout<<d[n]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint ans[100];\n\tvector<pii> seats; //group_num count\n\tseats.push_back(pii(-1, 16));\n\tpriority_queue<pii, vector<pii>, greater<pii> > pq; //taisyutu:time, group_num\n\tqueue<int> que; //mati:group_num\n\t\n\t\n\tint cnt = 0, t = 0;\n\twhile (cnt < 100) {\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top();\n\t\t\tif (now.first != t) break;\n\t\t\tpq.pop();\n\t\t\tREP(i, seats.size()) if (seats[i].first == now.second) seats[i].first = -1;\n\t\t}\n\t\tREP(i, seats.size() - 1) {\n\t\t\tif (seats[i].first == seats[i + 1].first) {\n\t\t\t\tseats[i].second += seats[i + 1].second;\n\t\t\t\tseats.erase(seats.begin() + i + 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (t % 5 == 0 && t / 5 < 100) que.push(t / 5);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tint count = now % 5 == 1 ? 5 : 2;\n\t\t\tbool flag = true;\n\t\t\tREP(i, seats.size()) {\n\t\t\t\tif (seats[i].first == -1 && seats[i].second >= count) {\n\t\t\t\t\tif (seats[i].second - count > 0)\n\t\t\t\t\t\tseats.insert(seats.begin() + i + 1, pii(-1, seats[i].second - count));\n\t\t\t\t\tseats[i] = pii(now, count);\n\t\t\t\t\tpq.push(pii(t + 17*(now % 2) + 3*(now % 3) + 19, now));\n\t\t\t\t\t\n\t\t\t\t\tans[now] = t - now * 5;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\t\n\t\tt++;\n\t}\n\t\n\t\n\tint n;\n\twhile (cin >> n) cout << ans[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct Event\n{\n\tint time;\n\tint group;\n\tbool isarrival;\n\t\n\tEvent(int t, int g, bool f) : time(t), group(g), isarrival(f) {}\n\tbool operator< (const Event& e)const{\n\t\treturn time == e.time ? isarrival && !e.isarrival : time > e.time;\n\t}\n};\n\nint main()\n{\n\tint seat[17];\n\tfill_n(seat, 17, -1);\n\t\n\tpriority_queue<Event> Q;\n\trep(i, 100)\n\t\tQ.push(Event(i*5, i, true));\n\t\n\tint answer[100];\n\tqueue<int> que;\n\twhile(!Q.empty()){\n\t\tEvent e = Q.top();\n\t\tQ.pop();\n\t\t\n\t\tbool search = true;\n\t\tif(e.isarrival){\n\t\t\tsearch = que.empty();\n\t\t\tque.push(e.group);\n\t\t}\n\t\telse{\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == e.group)\n\t\t\t\t\tseat[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(search && !que.empty()){\n\t\t\tint n = que.front()%5 == 1 ? 5 : 2;\n\t\t\tint pos = -1;\n\t\t\tint cont = 0;\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == -1){\n\t\t\t\t\t++cont;\n\t\t\t\t\tif(cont == n){\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcont = 0;\n\t\t\t}\n\n\t\t\tif(pos == -1)\n\t\t\t\tsearch = false;\n\t\t\telse{\n\t\t\t\trep(i, n)\n\t\t\t\t\tseat[pos-i] = que.front();\n\t\t\t\tanswer[que.front()] = e.time - que.front() * 5;\n\t\t\t\tQ.push(Event(e.time+17*(que.front()%2)+3*(que.front()%3)+19, que.front(), false));\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\t//printf(\"time: %3d, \", e.time);\n\t\t//rep(i, 17)\n\t\t//\tprintf(seat[i]==-1?\"[__]\":\"[%2d]\",seat[i]);\n\t\t//puts(\"\");\n\t}\n\t\n\tint n;\n\twhile(scanf(\"%d\", &n) != EOF){\n\t\tprintf(\"%d\\n\", answer[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint search_sequence(vector<int> &a,int n){\n\tint cnt=0;\n\tfor(int i=0;i<a.size();++i){\n\t\tif(a[i]==-1)++cnt;\n\t\telse cnt=0;\n\t\tif(cnt>=n)return i-cnt+1;\n\t}\n\treturn -1;\n}\n\nint main(void){\n    vector<int> seat(17,-1);\n    int time[100],finish[100];\n    queue<pair<int,int> > q;\n    int x=0,y=0;\n    for(int t=0;y<100;++t){\n      if(t%5==0&&x<100) q.push(make_pair(x++,(x%5==1)?5:2));\n      for(int i=0;i<17;++i){\n        if(seat[i]!=-1&&finish[seat[i]]==t){\n        \tfill(&seat[i],&seat[i+((seat[i]%5==1)?5:2)],-1);\n        \t//cerr<<t<<\":\";for(int i=0;i<17;++i)cerr<<seat[i]<<((i!=16)?\" \":\"\\n\");\n      \t}\n      }\n      while(!q.empty()){\n      \tpair <int,int> p=q.front();\n      \tif(search_sequence(seat,p.second)==-1)break;\n        fill(&seat[search_sequence(seat,p.second)],&seat[search_sequence(seat,p.second)+p.second],p.first);\n        //cerr<<t<<\":\";for(int i=0;i<17;++i)cerr<<seat[i]<<((i!=16)?\" \":\"\\n\");\n        finish[p.first]=t+17*(p.first%2)+3*(p.first%3)+19;\n        time[p.first]=t-5*p.first;\n        q.pop();++y;\n      }\n    }\n  int n;\n  while(cin>>n){\n  \tcout<<time[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint Brank(vint v, int num)\n{\n\trep(i, v.size() - num)\n\t{\n\t\trep(j, num)\n\t\t{\n\t\t\tif(v[i + j] != -1) break;\n\t\t\telse if(j + 1 == num) return i;\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main()\n{\n    for(int n; cin >> n;)\n\t{\n\t\tqueue<int>  que; // id\n\t\tvint store(16, -1); // time\n\t\tint nxt = 0, start;\n\t\t\n\t\tfor(int time = 0; ; time++)\n\t\t{\n\t\t\t// ツ行ツ療アツづ可嘉つヲツづゥ\n\t\t\tif(time % 5 == 0)\n\t\t\t{\n\t\t\t\tif(nxt == n) start = time;\n\t\t\t\t\n\t\t\t\tque.push(nxt++);\n\t\t\t}\n\t\t\t\n\t\t\t// ツ店ツつゥツづァツ出ツつキ\n\t\t\trep(i, 16)\n\t\t\t\tstore[i] = (store[i] == time ? -1 : store[i]);\n\t\t\t\n\t\t\t// ツ店ツづ可禿シツづェツづゥ\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tint id = que.front();\n\t\t\t\tint num = (id % 5 == 1 ? 5 : 2);\n\t\t\t\t\n\t\t\t\tint index = Brank(store, num);\n\t\t\t\t\n\t\t\t\tif(index != -1)\n\t\t\t\t{\n\t\t\t\t\tif(id == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << time - start << endl;\n\t\t\t\t\t\tgoto ng;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint span = 17 * (id % 2) + 3 * (id % 3) + 19; \n\t\t\t\t\tREP(i, index, index + num) \n\t\t\t\t\t{\n\t\t\t\t\t\tstore[i] = time + span;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tque.pop();\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\tng:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint waiti[100];\nint seat[17];\n\nconst int INIT = 0xffffff;\n\ntypedef struct MATI\n{\n\tint id;\n\tint num;\n\tint eat;\n} MATI;\n\nint get_eat(int n)\n{\n\treturn 17 * (n%2) + 3 * (n%3) + 19;\n}\n\nint get_num(int n)\n{\n\tif(n%5==1) return 5;\n\telse return 2;\n}\n\nint can_sit(int n)\n{\n\tbool is_able = true;\n\tfor(int i=0; i<17-n; i++)\n\t{\n\t\tis_able = true;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(seat[i+j] > 0)\n\t\t\t{\n\t\t\t\tis_able = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_able) return i;\n\t}\n\t\n\treturn -1;\n}\n\nvoid refresh()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tif(seat[i] != -INIT)\n\t\t{\n\t\t\tseat[i] = seat[i] - 5;\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tseat[i] = -INIT;\n\t}\n\t\n\tqueue<MATI> col;\n\t\n\tfor(int i=0; i<1000; i++)\n\t{\n\t\tint current_time = 5 * i;\n\t\trefresh();\n\t\t\n\t\tMATI m;\n\t\tm.id = i;\n\t\tm.num = get_num(i);\n\t\tm.eat = get_eat(i);\n\t\tcol.push(m);\n\t\t\n\t\tint in_time = -INIT;\n\t\twhile(!col.empty())\n\t\t{\n\t\t\tm = col.front();\n\t\t\tint setter = can_sit(m.num);\n\t\t\tif(setter != -1)\n\t\t\t{\n\t\t\t\tif(in_time == -INIT)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(in_time < seat[setter+j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tin_time = seat[setter+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_time == -INIT) in_time = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t{\n\t\t\t\t\tseat[setter+j] = in_time + m.eat;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint wait_time = current_time + in_time - m.id * 5;\n\t\t\t\twaiti[m.id] = (wait_time < 0) ? 0: wait_time;\n\t\t\t\tcol.pop();\n\t\t\t\tif(m.id==99) return;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint n;\n\tsolve();\n\t\n\tfor(int i=0; i<100; i++)\n\t{\n\t\tcout << i << \" : \" << waiti[i] << endl;\n\t}\n\t\n\twhile(cin >> n)\n\t{\n\t\tcout << waiti[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct Event\n{\n\tint time;\n\tint group;\n\tbool isarrival;\n\t\n\tEvent(int t, int g, bool f) : time(t), group(g), isarrival(f) {}\n\tbool operator< (const Event& e)const{\n\t\treturn time == e.time ? !isarrival : time > e.time;\n\t}\n};\n\nint main()\n{\n\tint seat[17];\n\tfill_n(seat, 17, -1);\n\t\n\tpriority_queue<Event> Q;\n\trep(i, 100)\n\t\tQ.push(Event(i*5, i, true));\n\t\n\tint answer[100];\n\tqueue<int> que;\n\twhile(!Q.empty()){\n\t\tEvent e = Q.top();\n\t\tQ.pop();\n\t\t\n\t\tbool search = true;\n\t\tif(e.isarrival){\n\t\t\tsearch = que.empty();\n\t\t\tque.push(e.group);\n\t\t}\n\t\telse{\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == e.group)\n\t\t\t\t\tseat[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(search && !que.empty()){\n\t\t\tint n = que.front()%5 == 1 ? 5 : 2;\n\t\t\tint pos = -1;\n\t\t\tint cont = 0;\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == -1){\n\t\t\t\t\t++cont;\n\t\t\t\t\tif(cont == n){\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tcont = 0;\n\t\t\t}\n\n\t\t\tif(pos == -1)\n\t\t\t\tsearch = false;\n\t\t\telse{\n\t\t\t\trep(i, n)\n\t\t\t\t\tseat[pos-i] = que.front();\n\t\t\t\tanswer[que.front()] = e.time - que.front() * 5;\n\t\t\t\tQ.push(Event(e.time+17*(que.front()%2)+3*(que.front()%3)+19, que.front(), false));\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t}\n\t\t//printf(\"time: %3d, \", e.time);\n\t\t//rep(i, 17)\n\t\t//\tprintf(seat[i]==-1?\"[__]\":\"[%2d]\",seat[i]);\n\t\t//puts(\"\");\n\t}\n\t\n\tint n;\n\twhile(scanf(\"%d\", &n) != EOF){\n\t\tprintf(\"%d\\n\", answer[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=9){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nint main(){\n  int wtime[100] ={};\n  deque<int> deq;  \n  int seat[17]={};\n  int members[17];\n  for(int t = 0; t <= 99*5 || !deq.empty(); t++){\n    REP(i,17)if(seat[i] > 0)seat[i]--;\n    if(t%5 == 0 && t <= 99*5) deq.push_back(t/5);\n    while(!deq.empty()){\n      int mem = deq.front();\n      int nop = (mem%5==1)?5:2;\n      int sitable = -1;\n      for(int i = 0, con = 0; i < 17; i++){\n        if(seat[i]==0)con++;\n        else con = 0;\n        if(con == nop){\n          sitable = i + 1 - nop;\n          break;\n        }\n      }\n      if(sitable >= 0){\n        deq.pop_front();\n        REP(i,nop){\n          seat[sitable+i] = 17*(mem%2)+3*(mem%3)+19;\n          members[sitable+i] = mem;\n        }\n      }else{\n        break;\n      }\n    }\n    REP(i,deq.size())wtime[deq[i]]++;\n    /*\n    printf(\"%d:\",t);\n    REP(i,17)cout<< ((seat[i])?members[i]:0) <<\" \";\n    cout<<endl;\n    */\n  }\n  int n;\n  while(cin>>n)cout<<wtime[n]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n  vector<int> start(100);\n  vector<int> number(100);\n  for(int i = 0; i < 100; ++i) {\n    start[i] = 5 * i;\n    number[i] = (i % 5 == 1 ? 5 : 2);\n    // t + 17*(i%2) + 3*(i%3) + 19;\n  }\n  vector<int> sheet(17, -1);\n  vector<int> wait(100, -1);\n  vector<int> end(100, -1);\n  queue<int> que;\n  for(int t = 0; ; ++t) {\n    for(int i = 0; i < 100; ++i) {\n      if(end[i] == t) {\n        for(int j = 0; j < 17; ++j) {\n          if(sheet[j] == i) sheet[j] = -1;\n        }\n      }\n      if(start[i] == t) {\n        que.push(i);\n      }\n    }\n    while(!que.empty()) {\n      int n = number[que.front()];\n      int s = -1;\n      for(int i = 0; i < 17; ++i) {\n        int c = 0;\n        for(int j = i; j < 17; ++j) {\n          if(sheet[j] == -1) ++c;\n          else break;\n        }\n        if(c >= n) {\n          s = i;\n          break;\n        }\n      }\n      if(s != -1) {\n        int k = que.front(); que.pop();\n        for(int j = 0; j < n; ++j) {\n          sheet[s + j] = k;\n        }\n        wait[k] = t - start[k];\n        end[k] = t + 17*(k%2) + 3*(k%3) + 19;\n      }\n      else {\n        break;\n      }\n    }\n    bool f = true;\n    for(int i = 0; i < 100; ++i) {\n      if(end[i] == -1) f = false;\n    }\n    if(f) break;\n  }\n  for(int q; cin >> q; ) {\n    cout << wait[q] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{int t,n,e;bool operator <(const D &a)const{ return t>a.t;}};\npriority_queue<D>F;\nint r[N],s[20],w=0;\n\nint ch(int n)\n{\n\tfor(int i=0;i<17;i++)\n\t\tif(s[i]==-1)\n\t\t{\n\t\t\tint j;\n\t\t\tfor(j=0;j<n&&i+j<17;j++)if(s[i+j]!=-1)break;\n\t\t\tif(j==n)return i;\n\t\t}\n\treturn -1;\n}\n\nint main()\n{\n\tmemset(s,-1,sizeof(s));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tD tmp={i*5,i,0};\n\t\tF.push(tmp);\n\t}\n\twhile(!F.empty())\n\t{\n\t\tD n=F.top();F.pop();\n\t\tif(n.e)\n\t\t{\n\t\t\tfor(int i=0;i<17;i++)\n\t\t\t\tif(s[i]==n.n)s[i]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(w<n.n)\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a=n.n%5==1?5:2,b=ch(a);\n\t\t\tif(b!=-1)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\ts[b+j]=n.n;\n\t\t\t\tr[n.n]=n.t-5*n.n;\n\t\t\t\tw=n.n+1;\n\t\t\t\tD tmp={n.t+19+17*(n.n%2)+3*(n.n%3),n.n,1};\n\t\t\t\tF.push(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t}\n\t\t}\n\t}\n\tfor(;~scanf(\"%d\",&w);)printf(\"%d\\n\",r[w]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 16;\nint seat[N+1];\nint ans[100];\n\nvoid sim(){\n\tint t = 0;\n\trep(i, 100){\n\t\tint num = i%5==1?5:2;\n\t\tif(t < 5*i){\n\t\t\trep(j, N) seat[j] -= min(seat[j], 5*i-t);\n\t\t\tt = 5*i;\n\t\t}\n\t\tbool ok = false;\n\t\twhile(1){\n\t\t\tint cnt = 0;\n\t\t\trep(j, num) cnt += !!seat[j];\n\t\t\trep(j, N-num){\n\t\t\t\tif(cnt == 0){\n\t\t\t\t\tFOR(k, j, j+num) seat[k] = 17*(i%2)+3*(i%3)+19;\n\t\t\t\t\tans[i] = t-5*i;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(seat[j+num]) ++cnt;\n\t\t\t\tif(seat[j]) --cnt;\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t\tint mint = 1<<29;\n\t\t\trep(j, N) if(seat[j]) mint = min(mint, seat[j]);\n\t\t\trep(j, N) if(seat[j]) seat[j] -= mint;\n\t\t\tt += mint;\n\t\t}\n\t\t//printf(\"\\ntime:%d\\nseat:\", t);\n\t\t//rep(j, N) printf(\"%3d\", seat[j]);\n\t}\n}\n\nint main(){\n\tsim();\n\tint n;\n\twhile(cin >> n) cout << ans[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nstruct cus\n{\n\tint a,b,c,d;\n};\n\nint main()\n{\n\tcus a[100];\n\tfor(int i=0;i<100;i++)\n\t{\n\t\ta[i].a=5*i;\n\t\ta[i].b=(i%5==1?5:2);\n\t\ta[i].c=17*(i%2)+3*(i%3)+19;\n\t\ta[i].d=0;\n\t}\n\tint t[20]={};\n\tfor(int i=0;i<100;i++)\n\t{\n\t\t//for(int j=0;j<17;j++)printf(\"%3d\",t[j]);\n\t\t//cout<<endl;\n\t\tint k=max(a[max(0,i-1)].d,a[i].a);\n\t\tfor(;;k++)for(int j=0;j<17-a[i].b;j++)\n\t\t{\n\t\t\tbool x=true;\n\t\t\tfor(int l=j;l<j+a[i].b;l++)\n\t\t\t{\n\t\t\t\tif(t[l]>k)x=false;\n\t\t\t}\n\t\t\tif(x)\n\t\t\t{\n\t\t\t\tfor(int l=j;l<j+a[i].b;l++)\n\t\t\t\t{\n\t\t\t\t\tt[l]=k+a[i].c;\n\t\t\t\t}\n\t\t\t\ta[i].c=k-a[i].a;\n\t\t\t\ta[i].d=k;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t;end:;\n\t}\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tcout<<a[n].c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\t//set<int> escape;\n\tmap<int,vector<int> > escape;\n\n\tint data[100];\n\t//while(cin>>n){\n\t\tint field[17];\n\t\tfill(field,field+17,-1);\n\n\t\tqueue<int> waitQueue;\n\t\tint group=0;\n\t\tint time=0;\n\n\t\tvector<int> c;\n\t\twhile(cin>>n){\n\t\t\tc.push_back(n);\n\t\t}\n\n\t\tfor(int i=0;;i++){\n\t\t\ttime=i;\n\t\t\tif(i%5==0){\n\t\t\t\twaitQueue.push(group);\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\t// Ü¸ÔØêO[vðÈ©çÇ©·\n\t\t\tfor(map<int,vector<int> >::iterator it = escape.begin(); it != escape.end(); it++){\n\t\t\t\tif(it->first==i){\n\t\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\t\tfor(int k = 0; k< it->second.size(); k++){\n\t\t\t\t\t\t\tif(field[j]==it->second[k]){\n\t\t\t\t\t\t\t\tfield[j]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tit->second.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool f=false;\n\t\t\tint prvCand=-1;\n\t\t\t// ·íêé¾¯·íç¹é\n\t\t\twhile(1){\n\t\t\t\tif(waitQueue.size()==0)\n\t\t\t\t\tbreak;\n\t\t\t\t// ¡ñÀç¹él\n\t\t\t\tint cand=waitQueue.front();\n\t\t\t\tif(prvCand==cand)\n\t\t\t\t\tbreak;\n\t\t\t\tint s;\n\t\t\t\tint mergen=-1;\n\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\tif(field[j]==-1&&j!=16){\n\t\t\t\t\t\tif(mergen==-1){\n\t\t\t\t\t\t\ts=j;\n\t\t\t\t\t\t\tmergen=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmergen++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(cand%5==1){\n\t\t\t\t\t\t\tif(mergen>=5){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 5+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\tcout<<cand<<endl;\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(mergen>=2){\n\t\t\t\t\t\t\t//\tcout<<cand<<endl;\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 2+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t\tprvCand=cand;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < c.size(); i++){\n\t\t\t// ±±ÅÜ¿Ôð\\¦\n\t\t\tcout<<data[c[i]]<<endl;\n\t\t}\n//\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 5)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint waiti[100];\nint seat[17];\n\nconst int INIT = 0xffffff;\n\ntypedef struct MATI\n{\n\tint id;\n\tint num;\n\tint eat;\n} MATI;\n\nint get_eat(int n)\n{\n\treturn 17 * (n%2) + 3 * (n%3) + 19;\n}\n\nint get_num(int n)\n{\n\tif(n%5==1) return 5;\n\telse return 2;\n}\n\nint can_sit(int n)\n{\n\tbool is_able = true;\n\tfor(int i=0; i<17-n; i++)\n\t{\n\t\tis_able = true;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(seat[i+j] > 0)\n\t\t\t{\n\t\t\t\tis_able = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_able) return i;\n\t}\n\t\n\treturn -1;\n}\n\nvoid refresh()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tif(seat[i] != INIT)\n\t\t{\n\t\t\tseat[i] = seat[i] - 5;\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tseat[i] = -INIT;\n\t}\n\t\n\tqueue<MATI> col;\n\t\n\tfor(int i=0; i<100; i++)\n\t{\n\t\tint current_time = 5 * i;\n\t\trefresh();\n\t\t\n\t\tMATI m;\n\t\tm.id = i;\n\t\tm.num = get_num(i);\n\t\tm.eat = get_eat(i);\n\t\tcol.push(m);\n\t\t\n\t\tint in_time = -INIT;\n\t\twhile(!col.empty())\n\t\t{\n\t\t\tm = col.front();\n\t\t\tint setter = can_sit(m.num);\n\t\t\tif(setter != -1)\n\t\t\t{\n\t\t\t\tif(in_time == -INIT)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(in_time < seat[setter+j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tin_time = seat[setter+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_time == -INIT) in_time = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t{\n\t\t\t\t\tseat[setter+j] = in_time + m.eat;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint wait_time = current_time + in_time - m.id * 5;\n\t\t\t\twaiti[m.id] = (wait_time < 0) ? 0: wait_time;\n\t\t\t\tcol.pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint n;\n\tsolve();\n\t\n\twhile(cin >> n)\n\t{\n\t\tcout << waiti[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tmap<int,vector<int> > escape;\n\n\tint data[100];\n\t\tint field[17];\n\t\tfill(field,field+17,-1);\n\n\t\tqueue<int> waitQueue;\n\t\tint group=0;\n\t\tint time=0;\n\n\t\tvector<int> c;\n\t\twhile(cin>>n){\n\t\t\tc.push_back(n);\n\t\t}\n\t\t\n\t\tfor(int i=0;;i++){\n\t\t\ttime=i;\n\t\t\tif(i%5==0){\n\t\t\t\twaitQueue.push(group);\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\t// Ü¸ÔØêO[vðÈ©çÇ©·\n\t\t\tfor(map<int,vector<int> >::iterator it = escape.begin(); it != escape.end(); it++){\n\t\t\t\tif(it->first==i){\n\t\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\t\tfor(int k = 0; k< it->second.size(); k++){\n\t\t\t\t\t\t\tif(field[j]==it->second[k]){\n\t\t\t\t\t\t\t\tfield[j]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tit->second.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool f=false;\n\t\t\tint prvCand=-1;\n\t\t\t// ·íêé¾¯·íç¹é\n\t\t\twhile(1){\n\t\t\t\tif(waitQueue.size()==0)\n\t\t\t\t\tbreak;\n\t\t\t\t// ¡ñÀç¹él\n\t\t\t\tint cand=waitQueue.front();\n\t\t\t\tif(prvCand==cand)\n\t\t\t\t\tbreak;\n\t\t\t\tint s;\n\t\t\t\tint mergen=-1;\n\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\tif(field[j]==-1&&j!=16){\n\t\t\t\t\t\tif(mergen==-1){\n\t\t\t\t\t\t\ts=j;\n\t\t\t\t\t\t\tmergen=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmergen++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(cand%5==1){\n\t\t\t\t\t\t\tif(mergen>=5){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 5+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+cand].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(mergen>=2){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 2+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+cand].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t\tprvCand=cand;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t\tif(i==44){\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < c.size(); i++){\n\t\t\t// ±±ÅÜ¿Ôð\\¦\n\t\t\tcout<<data[99]<<endl;\n\t\t}\n//\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint blank(const vi& table,int num)\n{\n\trep(i,table.size()-num+1){\n\t\tbool flg=true;\n\t\trep(j,num)\n\t\t\tif(table[i+j])\n\t\t\t\tflg=false;\n\t\tif(flg)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tvi table(17);\n\tdeque<int> customers;\n\tvi res(100);\n\trep(t,1000){\n\t\trep(i,table.size())\n\t\t\ttable[i]=max(table[i]-1,0);\n\t\tif(t<=500 && t%5==0)\n\t\t\tcustomers.push_back(t/5);\n\t\twhile(customers.size()){\n\t\t\tint customer=customers[0];\n\t\t\tint num=customer%5==1?5:2;\n\t\t\tint index=blank(table,num);\n\t\t\tif(index==-1)\n\t\t\t\tbreak;;\n\t\t\tres[customer]=t-customer*5;\n\t\t\trep(i,num)\n\t\t\t\ttable[index+i]=17*(customer%2)+3*(customer%3)+19;\n\t\t\tcustomers.pop_front();\n\t\t}\n\t}\n\t\n\tfor(int n;cin>>n;)\n\t\tcout<<res[n]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\nint c[100][2], res[100], table[17];\nint main(){\n  rep(i, 100){\n    c[i][0] = i%5==1?5:2;\n    c[i][1] = 17 * (i%2) + 3 * (i%3) + 19;\n  }\n  rep(i, 17) table[i] = 0;\n  int p = 0;\n  rep(k, 100){\n    rep(i, 17) if(table[i] > 0) table[i]--;\n\n    while(p <= k / 5){\n      int tmp = p;\n      if(c[p][0] == 2){\n\trep(i, 16){\n\t  if(table[i]==0&&table[i+1]==0){\n\t    table[i] = table[i+1] = c[p][1];\n\t    res[p] = k- p * 5;\n\t    p++;\n\t    break;\n\t  }\n\t}\n      }else if(c[p][0] == 5){\n\trep(i, 13){\n\t  if(table[i]==0&&table[i+1]==0&&table[i+2]==0&&table[i+3]==0&&table[i+4]==0){\n\t    table[i]=table[i+1]=table[i+2]=table[i+3]=table[i+4]=c[p][1];\n\t    res[p] = k - p  *5;\n\t    p++;\n\t    break;\n\t  }\n\t}\n      }\n      if(tmp == p) break;\n    }\n  }\n  \n  int n;\n  while(~scanf(\"%d\", &n))\n    printf(\"%d\\n\", res[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n// (時刻,イベント,グループ番号)の組を表す.\n// イベントは 離席 or 着席 を -1 or 1 で表す.\ntypedef pair< int , P > State;\n\n// グループ番号 i の人数を返す.\nint get_num(int i){\n\treturn (i%5 == 1)? 5 : 2 ;\n}\n\n// グループ id が座れるかどうか返す. 座れる時はsekiの状態も変わる.\nbool check(vector<int>& seki , int id ){\n\tint num = get_num(id);\n\tfor(int i=0 ; i < 17 ; i++ ){\n\t\tif( num == 2 ){\n\t\t\tif( i+1 < 17 && seki[i] == -1 && seki[i+1] == -1 ){\n\t\t\t\tseki[i] = seki[i+1] = id;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}else{\n\t\t\tif( i+4 < 17 && seki[i] == -1 && seki[i+1] == -1 && seki[i+2] == -1 && seki[i+3] == -1 && seki[i+4] == -1 ){\n\t\t\t\tseki[i] = seki[i+1] = seki[i+2] = seki[i+3] = seki[i+4] = id;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n// グループ id を離席させる. 離席するとsekiの状態も変わる.\nvoid remove(vector<int>& seki , int id ){\n\tfor(int i=0 ; i < 17 ; i++ ){\n\t\tif( seki[i] == id ) seki[i] = -1;\n\t}\n}\n\nint main(){\n\t// (時刻,イベント,グループ番号) の組を保持し, 時刻の早いほうから処理する.\n\tpriority_queue< State , vector<State> , greater<State> > q;\n\t// (グループ番号,到着時刻) の組を保持し, 今並んでいる人々を表す.\n\tfor(int i=0 ; i < 100 ; i++ ){\n\t\tq.push( State( 5*i , P(+1,i) ) );\n\t}\n\t// seki[i] := i番目の席に座っている人の番号, 座ってないときは -1\n\tvector<int> seki(17);\n\tfor(int i=0 ; i < 17 ; i++ ) seki[i] = -1;\n\t\n\t// que := 待ち行列, (グループ番号を保持する)\n\tqueue<int> que;\n\t\n\t// wait[i] := グループ i の待ち時間\n\tint wait[100] = {0}; \n\t\n\twhile( !q.empty() ){\n\t\tint t = q.top().first;\n\t\tint event = q.top().second.first;\n\t\tint id = q.top().second.second;\n\t\tq.pop();\n\t\t\n\t\t/*printf(\"%3d : \", t);\n\t\tfor(int i=0 ; i < 17 ; i++ ){\n\t\t\tif( seki[i] == -1 ){\n\t\t\t\tprintf(\"__\");\n\t\t\t}else{\n\t\t\t\tprintf(\"%2d\", seki[i] );\n\t\t\t}\n\t\t}*/\n\t\t\n\t\t\n\t\t// グループ id が着席するとき \n\t\tif( event == 1 ){\n\t\t\t\n\t\t\t// 行列があるとき\n\t\t\tif( !que.empty() ){\n\t\t\t\tque.push( id );\n\t\t\t\t\n\t\t\t\t//printf(\": %d is wait! \\n\", id);\n\t\t\t}else if( check( seki , id ) ){// 座れるかチェック, 座れなかったら行列に並ぶ.\n\t\t\t\tint eat_time = 17 * (id%2) + 3 * (id%3) + 19;\n\t\t\t\tq.push( State( t + eat_time , P(-1,id) ) );\n\t\t\t\t\n\t\t\t\t//printf(\": %d is sit! \\n\", id);\n\t\t\t}else{\n\t\t\t\tque.push( id );\n\t\t\t\t\n\t\t\t\t//printf(\": %d is wait! \\n\", id);\n\t\t\t}\n\t\t}else{ // グループ id が離席するとき\n\t\t\tremove( seki , id );\n\t\t\t//printf(\": %d is leave! \", id);\n\t\t\t// 行列の先頭の人が座れるかチェック\n\t\t\tbool flag = false;\n\t\t\tdo{\n\t\t\t\tif( que.empty() ) break;\n\t\t\t\tflag = false;\n\t\t\t\tint id_2 = que.front();\n\t\t\t\tif( check( seki , id_2 ) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tint eat_time = 17 * (id_2%2) + 3 * (id_2%3) + 19;\n\t\t\t\t\tq.push( State( t + eat_time , P(-1,id_2) ) );\n\t\t\t\t\twait[id_2] = t - id_2 * 5;\n\t\t\t\t\tque.pop();\n\t\t\t\t\t//printf(\"&& %d is sit! \", id_2);\n\t\t\t\t}\n\t\t\t}while( flag );\n\t\t\t//puts(\"\");\n\t\t}\n\t}\n\tint n;\n\twhile( cin >> n ){\n\t\tcout << wait[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define fi first\n#define se second\n\nint main() {\n\tint chair[17] = {0};\n\tint ans[100];\n\tqueue<pair<int,int> > customer;\n\n\tfor(int clock = 0; clock <= 500 || !customer.empty(); clock++) {\n\t\tif(!(clock % 5) && clock < 500) {\n\t\t\tif((clock / 5) % 5 == 1)\n\t\t\t\tcustomer.push(pair<int,int>(clock / 5, 5));\n\t\t\telse\n\t\t\t\tcustomer.push(pair<int,int>(clock / 5, 2));\n\t\t}\n\n\t\tbool flg = true;\n\t\twhile(flg && !customer.empty()) {\n\t\t\tint seq;\n\t\t\tpair<int,int> tmp;\n\t\t\tbool prev;\n\n\t\t\tflg = false;\n\t\t\ttmp = customer.front();\n\t\t\tseq = 0;\n\t\t\tfor(int i = 0; i < 17; i++) {\n\t\t\t\tif(chair[i] <= clock)\n\t\t\t\t\tseq++;\n\t\t\t\telse\n\t\t\t\t\tseq = 0;\n\t\t\t\tif(seq >= tmp.se) {\n\t\t\t\t\tans[tmp.fi] = clock - 5 * tmp.fi;\n\t\t\t\t\tfor(int j = 0; j < tmp.se; j++) {\n\t\t\t\t\t\tchair[i - seq  + 1 + j] = 17 * (tmp.fi % 2) + 3 * (tmp.fi % 3) + 19 + clock;\n\t\t\t\t\t}\n\t\t\t\t\tcustomer.pop();\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint q;\n\twhile(cin >> q) {\n\t\tcout << ans[q] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int MS=17;\nint mem[101],wait[101],eatingtime[101],seat[MS],hantei[6];\n\nint main(){\n  for(int i=0;i<100;i++){\n    mem[i]=2;\n    if(i%5==1){\n      mem[i]=5;\n    }\n  }\n  for(int i=0;i<100;i++){\n    eatingtime[i]=17*(i%2)+3*(i%3)+19;\n  }\n  int time=0,n=0;\n  while(n<100){\n    for(int j=0;j<MS;j++){\n      if(seat[j]>0){seat[j]--;}\n    }\n    /*    if(time<100){\n      cout<<time;\n      for(int gi=0;gi<MS;gi++)\n\t{\n\t  printf(\" %d\",seat[gi]);\n\t  if(gi==MS-1){cout<<endl;\n\t  }\n\t}\n\t}*/\n      while((time+1)>(n*5))\n\t{\n\tfor(int j=0;j<MS-1;j++)\n\t  {\n\t    for(int seki=0;seki<2;seki++){\n\t      if(seat[j+seki]!=0){break;}\n\t      if(seki==1){hantei[2]=1;hantei[0]=j;j=MS;}\n\t    }\n\t  }\n\tfor(int j=0;j<MS-4;j++)\n\t  {\n\t    for(int seki=0;seki<5;seki++){\n\t      if(seat[j+seki]!=0){break;}\n\t      if(seki==4){hantei[5]=1;hantei[3]=j;j=MS;}\n\t    }\n\t  }\n\tif(hantei[mem[n]]==1){\n\t  wait[n]=time-(n*5);\n\t  for(int ji=0;ji<mem[n];ji++){\n\t    seat[hantei[mem[n]-2]+ji]=eatingtime[n];\n\t  }\n\t  n++;\n\t}\n\tif(hantei[mem[n]]==0){break;}\n\thantei[2]=0;\n\thantei[5]=0;\n\n\t}\n      time++;\n  }\n  int t;\n  while(~scanf(\"%d\",&t)){\n    printf(\"%d\\n\",wait[t]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100\n \nstruct S{\n  int g, t;\n  S(int g, int t) : g(g), t(t) {}\n};\n \nint arr[MAX];\nvector<S> seat;\n \nint minute(int i){\n  return 17*(i%2) + 3*(i%3) + 19;\n}\n \nvoid make(){\n  int g = 0;\n  for(int i = 0 ; i < 17 ; i++){\n    seat.push_back(S(-1,-1));\n  }\n  vector<S> _wait;\n  for(int i = 0 ; i < 570 ; i++){\n    int size = _wait.size();\n \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        _wait[j].t++;\n      }\n    }\n    \n    for(int j = 0 ; j < 17 ; j++){\n      if(seat[j].g != -1){\n        seat[j].t--;\n        if(seat[j].t == 0){\n          seat[j].g = seat[j].t = -1;\n        }\n      }\n    }\n  \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        int n = _wait[j].g;\n        int cnt, c;\n        bool flg = false;\n        if(n % 5 == 1) cnt = c = 5;\n        else cnt = c = 2;\n        for(int k = 0 ; k < 17 ; k++){\n          if(seat[k].g == -1) cnt--;\n          else cnt = c;\n          if(cnt == 0){\n            for(int l = k-c+1 ; l <= k ; l++){\n              seat[l].g = n;\n              seat[l].t = minute(n);\n            }\n            arr[n] = _wait[j].t;\n            flg = true;\n            j--;\n            _wait.erase(_wait.begin());\n            break;\n          }\n        }\n        if(!flg || !_wait.size()) break;\n      }\n      size = _wait.size();\n    }\n    if(g == 100) continue;\n    if(i % 5 == 0){\n      int cnt, c;\n      bool flg = false;\n      if(size){\n        _wait.push_back(S(g,0));\n        g++;\n        continue;\n      }\n      if(g % 5 == 1) cnt = c = 5;\n      else cnt = c = 2;\n       \n      for(int j = 0 ; j < 17 ; j++){\n        if(seat[j].g == -1) cnt--;\n        else cnt = c;\n        if(cnt == 0){\n          flg = true;\n          for(int k = j-c+1 ;  k <= j ; k++){\n            seat[k].g = seat[k].g = g;\n            seat[k].t = seat[k].t = minute(g);\n          }\n          arr[g] = 0;\n          break;\n        }\n      }\n      if(!flg){\n        _wait.push_back(S(g,0));\n      }\n      g++;\n    }\n  }\n}\n \nint main(){\n  int N;\n \n  make();\n  while(cin >> N){\n    cout << arr[N] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=10){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint waiti[100];\nint seat[17];\n\nconst int INIT = 0xffffff;\n\ntypedef struct MATI\n{\n\tint id;\n\tint num;\n\tint eat;\n} MATI;\n\nint get_eat(int n)\n{\n\treturn 17 * (n%2) + 3 * (n%3) + 19;\n}\n\nint get_num(int n)\n{\n\tif(n%5==1) return 5;\n\telse return 2;\n}\n\nint can_sit(int n)\n{\n\tbool is_able = true;\n\tfor(int i=0; i<17-n; i++)\n\t{\n\t\tis_able = true;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(seat[i+j] > 0)\n\t\t\t{\n\t\t\t\tis_able = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_able) return i;\n\t}\n\t\n\treturn -1;\n}\n\nvoid refresh()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tif(seat[i] != -INIT)\n\t\t{\n\t\t\tseat[i] = seat[i] - 5;\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tseat[i] = -INIT;\n\t}\n\t\n\tqueue<MATI> col;\n\t\n\tfor(int i=0; i<1000; i++)\n\t{\n\t\tint current_time = 5 * i;\n\t\trefresh();\n\t\t\n\t\tMATI m;\n\t\tm.id = i;\n\t\tm.num = get_num(i);\n\t\tm.eat = get_eat(i);\n\t\tcol.push(m);\n\t\t\n\t\tint in_time = -INIT;\n\t\twhile(!col.empty())\n\t\t{\n\t\t\tm = col.front();\n\t\t\tint setter = can_sit(m.num);\n\t\t\tif(setter != -1)\n\t\t\t{\n\t\t\t\tif(in_time == -INIT)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(in_time < seat[setter+j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tin_time = seat[setter+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_time == -INIT) in_time = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t{\n\t\t\t\t\tseat[setter+j] = in_time + m.eat;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint wait_time = current_time + in_time - m.id * 5;\n\t\t\t\twaiti[m.id] = (wait_time < 0) ? 0: wait_time;\n\t\t\t\tcol.pop();\n\t\t\t\tif(m.id==99) return;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint n;\n\tsolve();\n\t\n\twhile(cin >> n)\n\t{\n\t\tcout << waiti[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct Event\n{\n\tint time;\n\tint group;\n\tbool isarrival;\n\t\n\tEvent(int t, int g, bool f) : time(t), group(g), isarrival(f) {}\n\tbool operator< (const Event& e)const{\n\t\treturn time == e.time ? isarrival && !e.isarrival : time > e.time;\n\t}\n};\n\nint main()\n{\n\tint seat[17];\n\tfill_n(seat, 17, -1);\n\t\n\tpriority_queue<Event> Q;\n\trep(i, 100)\n\t\tQ.push(Event(i*5, i, true));\n\t\n\tint answer[100];\n\tdeque<int> que;\n\twhile(!Q.empty()){\n\t\tEvent e = Q.top();\n\t\tQ.pop();\n\t\t\n\t\tbool search = true;\n\t\tif(e.isarrival){\n\t\t\tsearch = que.empty();\n\t\t\tque.push_back(e.group);\n\t\t}\n\t\telse{\n\t\t\trep(i, 17){\n\t\t\t\tif(seat[i] == e.group)\n\t\t\t\t\tseat[i] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(search && !que.empty()){\n\t\t\tint n = que.front()%5 == 1 ? 5 : 2;\n\t\t\tint pos = search_n(seat, seat+17, n, -1) - seat;\n\t\t\t\n\t\t\tif(pos == 17)\n\t\t\t\tsearch = false;\n\t\t\telse{\n\t\t\t\trep(i, n)\n\t\t\t\t\tseat[pos+i] = que.front();\n\t\t\t\tanswer[que.front()] = e.time - que.front() * 5;\n\t\t\t\tQ.push(Event(e.time+17*(que.front()%2)+3*(que.front()%3)+19, que.front(), false));\n\t\t\t\tque.pop_front();\n\t\t\t}\n\t\t}\n\t\t\n\t\t// prinTf(\"time: %3d, \", e.time);\n\t\t// rep(i, 17)\n\t\t// \tprintf(seat[i]==-1?\"[__]\":\"[%2d]\",seat[i]);\n\t\t// puts(\"\");\n\t\t// copy(que.begin(), que.end(), ostream_iterator<int>(cout, \",\"));\n\t\t// puts(\"\");\n\t}\n\t\n\tint n;\n\twhile(scanf(\"%d\", &n) != EOF){\n\t\tprintf(\"%d\\n\", answer[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, firstSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveMinutes = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealMinutes = new int[GROUP_NUM];\n        waitMinutes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveMinutes[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int groupOrder;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 食事の時間が終了した客を離席させる\n            outCustomer(currentTime);\n\n            if ((groupOrder = arrivedCustomer(arriveMinutes, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(groupOrder)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(groupOrder));\n\n                        totalGroupNum++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(groupOrder);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(groupOrder);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        totalGroupNum++;\n\n                        // 待った時間を設定する\n                        waitMinutes[wait] = currentTime - arriveMinutes[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitMinutes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int arrivedCustomer(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (currentTime - (arriveMinutes[Integer.parseInt(seat)]\n                    + waitMinutes[Integer.parseInt(seat)]) >= mealMinutes[Integer\n                        .parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[firstSeatNum++] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n        int i = 0;\n\n        for (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                break;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n        if (emptyseatsNum == customersNum[groupsNum]) {\n            // 空席の最初の座席番号を設定する\n            firstSeatNum = i - emptyseatsNum;\n\n            return true;\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#define mp make_pair\nusing namespace std;\n\ntypedef pair<int,int> STATE;//group,action(0:enter,1:end)\ntypedef pair<int,STATE> P; //time\n\nint chair[17];\n\nint emp(int num){\n\tfor(int i = 0;i < 17 - num + 1;i++){\n\t\tbool flag = true;\n\t\tfor(int j = 0;j < num;j++){\n\t\t\tif(chair[i + j] != -1) flag = false;\n\t\t}\n\t\tif(flag) return i;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tint n,front = -1,wait[100] = {};\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tqueue<int> line;\n\tfor(int i = 0;i < 17;i++) chair[i] = -1;\n\tfor(int i = 0;i < 100;i++) que.push(mp(i * 5,mp(i,0)));\n\twhile(!que.empty()){\n\t\tP p = que.top();que.pop();\n\t\tint t = p.first,group = p.second.first,act = p.second.second;\n\t\tif(act == 0){\n\t\t\tint num = 2,pos;\n\t\t\tif(group % 5 == 1) num = 5;\n\t\t\tpos = emp(num);\n\t\t\tif(!line.empty() || pos == -1) line.push(group);\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < num;i++) chair[i + pos] = group;\n\t\t\t\tque.push(mp(t + 17 * (group % 2) + 3 * (group % 3) + 19,mp(group,1)));\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0;i < 17;i++){\n\t\t\t\tif(chair[i] == group) chair[i] = -1;\n\t\t\t}\n\t\t\twhile(!line.empty()){\n\t\t\t\tint g = line.front(),num = 2,pos;\n\t\t\t\tif(g % 5 == 1) num = 5;\n\t\t\t\tpos = emp(num);\n\t\t\t\tif(pos != -1){\n\t\t\t\t\tline.pop();\n\t\t\t\t\twait[g] = t - g * 5;\n\t\t\t\t\tfor(int i = 0;i < num;i++) chair[pos + i] = g;\n\t\t\t\t\tque.push(mp(t + 17 * (g % 2) + 3 * (g % 3) + 19,mp(g,1)));\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> n){\n\t\tcout << wait[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100\n \nstruct S{\n  int g, t;\n  S(int g, int t) : g(g), t(t) {}\n};\n \nint arr[MAX];\nvector<S> seat;\n \nint minute(int i){\n  return 17*(i%2) + 3*(i%3) + 19;\n}\n \nvoid make(){\n  int g = 0;\n  for(int i = 0 ; i < 17 ; i++){\n    seat.push_back(S(-1,-1));\n  }\n  vector<info> _wait;\n  for(int i = 0 ; i < 570 ; i++){\n    int size = _wait.size();\n \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        _wait[j].t++;\n      }\n    }\n    \n    for(int j = 0 ; j < 17 ; j++){\n      if(seat[j].g != -1){\n        seat[j].t--;\n        if(seat[j].t == 0){\n          seat[j].g = seat[j].t = -1;\n        }\n      }\n    }\n  \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        int n = _wait[j].g;\n        int cnt, c;\n        bool flg = false;\n        if(n % 5 == 1) cnt = c = 5;\n        else cnt = c = 2;\n        for(int k = 0 ; k < 17 ; k++){\n          if(seat[k].g == -1) cnt--;\n          else cnt = c;\n          if(cnt == 0){\n            for(int l = k-c+1 ; l <= k ; l++){\n              seat[l].g = n;\n              seat[l].t = minute(n);\n            }\n            arr[n] = _wait[j].t;\n            flg = true;\n            j--;\n            _wait.erase(_wait.begin());\n            break;\n          }\n        }\n        if(!flg || !_wait.size()) break;\n      }\n      size = _wait.size();\n    }\n    if(g == 100) continue;\n    if(i % 5 == 0){\n      int cnt, c;\n      bool flg = false;\n      if(size){\n        _wait.push_back(S(g,0));\n        g++;\n        continue;\n      }\n      if(g % 5 == 1) cnt = c = 5;\n      else cnt = c = 2;\n       \n      for(int j = 0 ; j < 17 ; j++){\n        if(seat[j].g == -1) cnt--;\n        else cnt = c;\n        if(cnt == 0){\n          flg = true;\n          for(int k = j-c+1 ;  k <= j ; k++){\n            seat[k].g = seat[k].g = g;\n            seat[k].t = seat[k].t = minute(g);\n          }\n          arr[g] = 0;\n          break;\n        }\n      }\n      if(!flg){\n        _wait.push_back(S(g,0));\n      }\n      g++;\n    }\n  }\n}\n \nint main(){\n  int N;\n \n  make();\n  while(cin >> N){\n    cout << arr[N] << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n#define\tEMPTY\t-1\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint Numbers(int groupid){\n\treturn groupid%5==1?5:2;\n}\n\nint MealTime(int groupid){\n\treturn 17*(groupid%2)+3*(groupid%3)+19;\n}\n\nint main()\n{\n\tint counter[17],elapse[17],mealtime[17];\n\tqueue<pii> qu;\t// <numbers in a group, group id>\n\n\tfor(int i=0;i<17;i++)\tcounter[i]=EMPTY;\n\n\tint waittime[100];\n\tfor(int t=0;t<589;t++){\n\t\t// enqueue\n\t\tif(t%5==0&&t<500){\n\t\t\tqu.push(mp(Numbers(t/5),t/5));\n\t\t}\n\n\t\t// going\n\t\tfor(int i=0;i<17;i++){\n\t\t\tif(counter[i]!=EMPTY){\n\t\t\t\telapse[i]++;\n\t\t\t\tif(elapse[i]==mealtime[i])\tcounter[i]=EMPTY;\n\t\t\t}\n\t\t}\n\n\t\t// coming\n\t\tif(!qu.empty()){\n\t\t\tpii next=qu.front();\n\t\t\tfor(int i=0,cnt=0;i<17;i++){\n\t\t\t\tif(counter[i]==EMPTY)\tcnt++;\n\t\t\t\telse\t\t\t\t\tcnt=0;\n\t\t\t\tif(cnt==next.first){\n\t\t\t\t\twaittime[next.second]=t-5*next.second;\n\t\t\t\t\tint mt=MealTime(next.second);\n\t\t\t\t\tfor(int j=i;j>i-next.first;j--){\n\t\t\t\t\t\tcounter[j]=next.second;\n\t\t\t\t\t\tmealtime[j]=MealTime(next.second);\n\t\t\t\t\t\telapse[j]=0;\n\t\t\t\t\t}\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tif(qu.empty())\tbreak;\n\t\t\t\t\tnext=qu.front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int n;~scanf(\"%d\",&n);)\tprintf(\"%d\\n\",waittime[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\nvoid leave(vector<int> &v, const vector<int> &leavers){\n    for(auto name:leavers){\n        rep(i,v.size()){\n            if(v[i]==name){\n                v[i] = -1;\n            }\n        }\n    }\n}\n\nint IsThereSpace(const vector<int> &v, int num){\n    assert(num<=v.size());\n    rep(i,v.size()-num+1){\n        bool space = true;\n        for(int j=i;j<i+num;j++){\n            if(v[j]!=-1){\n                space = false;\n            }\n        }\n        if(space) return i;\n    }\n    return -1;\n}\n\nint processing_que(vector<int> &v, queue<pii> &que){\n    if(que.empty())return -1;\n    int name, num;\n    tie(name,num) = que.front();\n\n    int res = IsThereSpace(v, num);\n    if( res!=-1 ){\n        for(int i=res;i<res+num;i++){\n            assert(v[i]==-1);\n            v[i] = name;\n        }\n        que.pop();\n        return name;\n    }else{\n        return -1;\n    }\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        vector<int> eating_times(101,INF);\n        vector<int> v(17,-1);\n        queue<pii> que;\n        map<int,vector<int>> mp;\n        for(int t=0; t<=4200; t++){\n            if(mp.count(t)!=0){\n                leave(v, mp[t]);\n                mp[t] = vector<int>();\n            }\n            if(t%5==0){\n                int name = t/5;\n                if(name>99)continue;\n                int num;\n                if(name%5==1)num = 5;\n                else num = 2;\n\n                int eating_time = 17*(name % 2) + 3*(name % 3) + 19;\n                eating_times[name] = eating_time;\n                que.push(pii(name, num));\n            }\n            bool n_entered = false;\n            while(1){\n                int res = processing_que(v, que);\n                if(res==-1)break;\n                else{\n                    assert(eating_times[res]!=INF);\n                    mp[t+eating_times[res]].pb(res);\n                    if(res==n) n_entered = true;\n                }\n            }\n\n            if(n_entered){\n                cout<<t-n*5<<endl;\n                break;\n            }\n            if(t==4200) assert(false);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nvector<int> ans(100);\nvector<int> table(17);\n\nstruct K\n{\n\tint id;\n\tint startT;\n\tint eatingT;\n\tint endT;\n\tint num;\n};\n\nqueue<K> wait;\n\nint getNum(int n)\n{\n\trep(i,17)\n\t{\n\t\tif(table[i] > 0) continue;\n\n\t\tREP(j,i+1,17)\n\t\t{\n\t\t\tif(table[j] > 0) break;;\n\n\t\t\tif(j-i+1 == n)\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid task()\n{\n\tint t = 0;\n\twhile(!wait.empty())\n\t{\n\t\twhile(!wait.empty() && wait.front().id * 5 <= t)\n\t\t{\n\t\t\tK temp = wait.front();\n\t\t\tint start = getNum(temp.num);\n\t\t\tif(start != -1)\n\t\t\t{\n\t\t\t\tREP(k,start,start + temp.num)\n\t\t\t\t{\n\t\t\t\t\ttable[k] = temp.eatingT;\n\t\t\t\t}\n\t\t\t\tans[temp.id] = abs(t - temp.startT);\n\t\t\t\twait.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\trep(i,17)\n\t\t{\n\t\t\tif(table[i] > 0) table[i]--;\n\t\t}\n\t\tt++;\n\t}\n}\n\nint main()\n{\n\trep(i,100)\n\t{\n\t\tK k;\n\t\tk.id = i;\n\n\t\tif(i%5 == 1) k.num = 5;\n\t\telse k.num = 2;\n\n\t\tk.eatingT = 17*(i%2) + 3*(i%3) + 19;\n\t\tk.startT = 5*i;\n\t\twait.push(k);\n\t}\n\n\trep(i,17) table[i] = 0;\n\n\ttask();\n\n\tint n;\n\twhile(cin >> n)\n\t{\n\t\tcout << ans[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_GROUP = 100;\nint waitTime[MAX_GROUP];\n\n\nvoid Init()\n{\n\tint firstTime[MAX_GROUP];\n\tconst int SEAT_NUM = 17;\n\tbool isSitSeat[SEAT_NUM] = {false};\n\ttypedef pair<int,int> PII;\n\tqueue<PII> line;\t//<inTime,personCount>\n\tpriority_queue<PII,vector<PII>,greater<PII> > seat;\t//<endTime,seatNum>\n\n\tint i,j,c,t,n;\n\n\tfor(i=0;i<MAX_GROUP;++i)\n\t\tline.push(make_pair(i*5, (i%5==1?5:2))),firstTime[i]=i*5;\n\n\tbool canSit = false;\n\n\t//±ÌöxÈçAªV~[gµÄàÔÉ¤©\n\tfor(t=0,n=0; !line.empty(); )\n\t{\n\t\twhile(!seat.empty() && t >= seat.top().first)\n\t\t\tisSitSeat[seat.top().second] = false, seat.pop();\n\n\t\tcanSit = false;\n\n\t\tif(t>=line.front().first)\n\t\t{\n\t\t\t//SõÀêÜ·©H\n\t\t\tfor(c=0,i=0; i < SEAT_NUM; ++i)\n\t\t\t{\n\t\t\t\tif(isSitSeat[i]) c=0;\n\t\t\t\telse if(++c >= line.front().second)\n\t\t\t\t{\n\t\t\t\t\t//Àêéæ¤Å·\n\t\t\t\t\tfor(j=0;j<line.front().second;++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tisSitSeat[i-j] = true;\n\t\t\t\t\t\tseat.push(make_pair(t+ 17*(n%2)+3*(n%3)+19, i-j));\n\t\t\t\t\t}\n\t\t\t\t\twaitTime[n] = t-line.front().first;\n\t\t\t\t\tline.pop();\n\t\t\t\t\t++n;\n\t\t\t\t\tcanSit = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//êxÉO[vÀé±Æà è\n\t\tif(!canSit)\n\t\t\t++t;\n\t}\n}\n\nint main(void)\n{\n\tInit();\n\tint i;\n\twhile(scanf(\"%d\",&i)>0)\n\t\tprintf(\"%d\\n\",waitTime[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nint main()\n{\n\tint seat[17] = {0};\n\tint answer[100];\n\tint sit = 0;\n\tdeque<int> que;\n\t\n\tfor(int i=0; sit<100; ++i){\n\t\trep(j, 17)\n\t\t\tif(seat[j]) --seat[j];\n\t\tif(i%5 == 0)\n\t\t\tque.push_back(i/5);\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tint g = que.front();\n\t\t\tint n = g % 5 == 1 ? 5 : 2;\n\t\t\tint pos = search_n(seat, seat+17, n, 0) - seat;\n\t\t\tif(pos == 17)\n\t\t\t\tbreak;\n\t\t\tfill_n(seat+pos, n, 17*(g%2) + 3*(g%3) + 19);\n\t\t\tanswer[que.front()] = i - g * 5;\n\t\t\tque.pop_front();\n\t\t\t++sit;\n\t\t}\n\t}\n\n\tint n;\n\twhile(scanf(\"%d\", &n) != EOF){\n\t\tprintf(\"%d\\n\", answer[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\nusing namespace std;\n \n int main() {\n  int i=0,j,k=0,m,n,t=0,s[17],ad[100],len[100],ans[100];\n  multimap<int,int> mp;\n  for (k=0;k<17;k++) s[k]=-1;\n  while(true) {\n  for (;i<100;i++) {\n\t  len[i]=(i % 5)==1 ? 5 : 2;\n\t  for (j=0;j<17-len[i];j++) {\n\t\t  for (k=0;k<len[i];k++) if (s[j+k]>=0) break;\n\t\t  if (k==len[i])  { for (k=j;k<j+len[i];k++) s[k]=i; \n\t\t  ans[i]=t>i*5 ? t-5*i : 0;\n\t\t  m=t < i*5 ? i*5 : t;\n\t\t  ad[i]=j;\n\t\t  mp.insert(multimap<int,int>::value_type(m+17*(i%2)+3*(i%3)+19,i)); \n\t\t  break;} \n\t  }\n      if (j==17-len[i]) break;\n  }\n  if (i==100) break;\n  t=(*mp.begin()).first;\n  while(!mp.empty() && (*mp.begin()).first == t) {\n\t  m=(*mp.begin()).second;\n\t  for (j=ad[m]; j<ad[m]+len[m]; j++) s[j]=-1;\n\t  mp.erase(mp.begin());\n     }\n  }\n  while(cin >> n) cout << ans[n] << endl;\n   return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n < 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=5){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=5){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint num[100];\nint in[100];\nint out[100];\nint Time[100];\n\nint pos[100];\n\nint res[100];\n\nint main()\n{\n\tfor (int i = 0; i < 100; i++){\n\t\tnum[i] = (i % 5 == 1) ? 5 : 2;\n\t\tin[i] = i * 5;\n\t\tout[i] = INF;\n\t\tTime[i] = 17 * (i % 2) + 3 * (i % 3) + 19;\n \t}\n\t\n\tint seat = 0;\n\tint cnt = 0;\n\tint t = 0;\n\tqueue<int> que;\n\twhile (cnt < 100){\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (out[i] == t){\n\t\t\t\tint x = (1 << num[i]) - 1;\n\t\t\t\tx <<= pos[i];\n\t\t\t\tseat -= x;\n\t\t\t\tcnt++;\n\t\t\t\t//printf(\"%d out %d\\n\", t, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tif (in[i] == t){\n\t\t\t\tque.push(i);\n\t\t\t\t//printf(\"%d in %d\\n\", t, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (que.size()){\n\t\t\tint p = que.front();\n\t\t\tbool f = false;\n\t\t\tfor (int i = 0; i < 18 - num[p]; i++){\n\t\t\t\tint x = (1 << num[p]) - 1;\n\t\t\t\tx <<= i;\n\t\t\t\tif (seat & x) continue;\n\t\t\t\tseat += x;\n\t\t\t\tpos[p] = i;\n\t\t\t\tout[p] = t + Time[p];\n\t\t\t\tres[p] = t - in[p];\n\t\t\t\tque.pop();\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!f) break;\n\t\t}\n\t\tt++;\n\t}\n\t\n\tint n;\n\twhile (~scanf(\"%d\", &n)){\n\t\tprintf(\"%d\\n\", res[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint d[17];\n\tint n[100]={0};\n\tint cnt=0,t=0;\n\tqueue<int> q;\n\trep(i,17)d[i]=0;\n\tfor(;cnt<100;t++){\n\t\trep(i,17)if(d[i]>0)d[i]--;\n\t\tif(t%5==0)q.push(t/5);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();\n\t\t\tint num=v%5==1?5:2;\n\t\t\tint g=0;\n\t\t\trep(j,17-num){\n\t\t\t\tif(d[j]<1){\n\t\t\t\t\tg=1;\n\t\t\t\t\treps(k,1,num-1){\n\t\t\t\t\t\tif(d[j+k]>0)g=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(g){\n\t\t\t\t\t\trep(k,num)d[j+k]=17*(v%2)+3*(v%3)+19;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(g)break;\n\t\t\t}\n\t\t\tif(!g)break;\n\t\t\tq.pop();\n\t\t\tn[v]=t-v*5;\n\t\t\tcnt++;\n\t\t}\n\t}\n\twhile(~scanf(\"%d\",&t))printf(\"%d\\n\",n[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 17;\nint seat[N+1];\nint ans[100];\n\nvoid sim(){\n\tint t = 0;\n\trep(i, 100){\n\t\tint num = i%5==1?5:2;\n\t\tif(t < 5*i){\n\t\t\trep(j, N) seat[j] -= min(seat[j], 5*i-t);\n\t\t\tt = 5*i;\n\t\t}\n\t\tbool ok = false;\n\t\twhile(1){\n\t\t\tint cnt = 0;\n\t\t\trep(j, num) cnt += !!seat[j];\n\t\t\trep(j, N-num){\n\t\t\t\tif(cnt == 0){\n\t\t\t\t\tFOR(k, j, j+num) seat[k] = 17*(i%2)+3*(i%3)+19;\n\t\t\t\t\tans[i] = t-5*i;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(seat[j+num]) ++cnt;\n\t\t\t\tif(seat[j]) --cnt;\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t\tint mint = 1<<29;\n\t\t\trep(j, N) if(seat[j]) mint = min(mint, seat[j]);\n\t\t\trep(j, N) if(seat[j]) seat[j] -= mint;\n\t\t\tt += mint;\n\t\t}\n\t\t//printf(\"\\ntime:%d\\nseat:\", t);\n\t\t//rep(j, N) printf(\"%3d\", seat[j]);\n\t}\n}\n\nint main(){\n\tsim();\n\tint n;\n\twhile(cin >> n) cout << ans[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint r[101];\nstruct Gr{\n\tint n;\n\tint tm;\n\tint pn;\n\tint vis;\n};\n\nint check(int a[17], int p)\n{\n\tint t = 0;\n\t\n\tfor(int i = 0; i < 17; i++){\n\t\tif(a[i] == 0){\n\t\t\tt++;\n\t\t\tif(t == p){\n\t\t\t\treturn i-p+1;\n\t\t\t}\n\t\t} else {\n\t\t\tt = 0;\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nvoid func(void)\n{\n\tint a[17], u, v;\n\tqueue<Gr> que;\n\tGr s;\n\tfill(a, a+17, 0);\n\tfor(int i = 0; i < 100; i++){\n\t\ts.n = i;\n\t\ts.vis = i*5;\n\t\ts.pn = (i%5 == 1)? 5 : 2;\n\t\ts.tm = 17*(i%2) + 3*(i%3) + 19;\n\t\tque.push(s);\n\t}\n\t\n\tv = 0;\n\twhile(!que.empty()){\n\t\ts = que.front();\n\t\tque.pop();\n\t\tfor(;; v++){\n\t\t\tif(s.vis <= v){\n\t\t\t\tu = check(a, s.pn);\n\t\t\t\tif(u == -1){\n\t\t\t\t\tfor(int i = 0; i < 17; i++){\n\t\t\t\t\t\tif(a[i] > 0){\n\t\t\t\t\t\t\ta[i]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < s.pn; i++){\n\t\t\t\t\ta[i+u] = s.tm;\n\t\t\t\t}\n\t\t\t\tr[s.n] = v-s.vis;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tfor(int i = 0; i < 17; i++){\n\t\t\t\t\tif(a[i] > 0){\n\t\t\t\t\t\ta[i]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ;\n}\n\nint main()\n{\n\tint n;\n\tfill(r, r+101, 0);\n\tfunc();\n\t\n\twhile(cin>>n){\n\t\tcout << r[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    vector<int> seat(17, -1);\n    multimap<int, int> leave;\n\n    vector<int> waitTime(100);\n    int prevTime = 0;\n    for(int i=0; i<100; ++i){\n        int time = 5*i;\n        while(leave.size() > 0 && leave.begin()->first <= time){\n            replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n            leave.erase(leave.begin());\n        }\n\n        int num = 2 + (i%5==1? 3:0);\n        for(;;){\n            vector<int> tmp(num, -1);\n            int j = search(seat.begin(), seat.end(), tmp.begin(), tmp.end()) - seat.begin();\n            if(j == 17){\n                time = leave.begin()->first;\n                replace(seat.begin(), seat.end(), leave.begin()->second, -1);\n                leave.erase(leave.begin());\n            }else{\n                for(int k=0; k<num; ++k)\n                    seat[j+k] = i;\n                break;\n            }\n        }\n\n        prevTime = max(time, prevTime);\n        waitTime[i] = prevTime - 5*i;\n\n        time += 17*(i%2) + 3*(i%3) + 19;\n        leave.insert(make_pair(time, i));\n    }\n\n    for(;;){\n        int n;\n        if(!(cin >> n))\n            return 0;\n        cout << waitTime[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint x[17], y[100][2], z[100], p[100], s;\n\nint main() {\n\tfor (int i = 0; i < 17; i++) {\n\t\tx[i] = 10000;\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tz[i] = 10000;\n\t}\n\tfor (int i = 0; i < 100; i++){\n\t\ty[i][0] = i * 5;\n\t\ty[i][1] = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t}\n\tfor (int i = 0; i < 1000; i++) {\n\t\t//Simulation.\n\t\tfor (int j = 0; j < 100; j++) {\n\t\t\tif (z[j] < 100) {\n\t\t\t\tz[j]--;\n\t\t\t}\n\t\t\tif (z[j] == 0) {\n\t\t\t\tfor (int k = 0; k < 17; k++) {\n\t\t\t\t\tif (x[k] == j) { x[k] = 10000; }\n\t\t\t\t}\n\t\t\t\tz[j] = 10000;\n\t\t\t}\n\t\t}\n\t\tif (i % 5 == 0 && i < 500) {\n\t\t\tz[i / 5] = 100000;\n\t\t}\n\t\tfor (int j = 0; j <= s; j++) {\n\t\t\tif (z[j] == 100000) {\n\t\t\t\tif (j % 5 != 1) {\n\t\t\t\t\tfor (int k = 0; k < 16; k++) {\n\t\t\t\t\t\tif (x[k] + x[k + 1] == 20000) {\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t\tx[k + 1] = j;\n\t\t\t\t\t\t\tz[j] = y[j][1];\n\t\t\t\t\t\t\tp[j] = i - y[j][0];\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 0; k < 13; k++) {\n\t\t\t\t\t\tif (x[k] + x[k + 1] + x[k + 2] + x[k + 3] + x[k + 4] == 50000) {\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t\tx[k + 1] = j;\n\t\t\t\t\t\t\tx[k + 2] = j;\n\t\t\t\t\t\t\tx[k + 3] = j;\n\t\t\t\t\t\t\tx[k + 4] = j;\n\t\t\t\t\t\t\tz[j] = y[j][1];\n\t\t\t\t\t\t\tp[j] = i - y[j][0];\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tE:;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tcout << p[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\t//set<int> escape;\n\tmap<int,vector<int> > escape;\n\n\twhile(cin>>n){\n\t\tchar field[17];\n\t\tfill(field,field+17,0);\n\n\t\tqueue<int> waitQueue;\n\t\tint group=0;\n\t\tint time=0;\n\t\tfor(int i=0;;i++){\n\t\t\ttime=i;\n\t\t\tif(i%5==0){\n\t\t\t\twaitQueue.push(group);\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\t// Ü¸ÔØêO[vðÈ©çÇ©·\n\t\t\tfor(map<int,vector<int> >::iterator it = escape.begin(); it != escape.end(); it++){\n\t\t\t\tif(it->first==i){\n\t\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\t\tfor(int k = 0; k< it->second.size(); k++){\n\t\t\t\t\t\t\tif(field[j]==it->second[k]+'0'){\n\t\t\t\t\t\t\t\tfield[j]=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tit->second.clear();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool f=false;\n\t\t\tint prvCand=-1;\n\t\t\t// ·íêé¾¯·íç¹é\n\t\t\twhile(1){\n\t\t\t\tif(waitQueue.size()==0)\n\t\t\t\t\tbreak;\n\t\t\t\t// ¡ñÀç¹él\n\t\t\t\tint cand=waitQueue.front();\n\t\t\t\tif(prvCand==cand)\n\t\t\t\t\tbreak;\n\t\t\t\tint s;\n\t\t\t\tint mergen=-1;\n\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\tif(field[j]==0&&j!=16){\n\t\t\t\t\t\tif(mergen==-1){\n\t\t\t\t\t\t\ts=j;\n\t\t\t\t\t\t\tmergen=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmergen++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(cand%5==1){\n\t\t\t\t\t\t\tif(mergen>=5){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 5+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand+'0';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==n){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(mergen>=2){\n\t\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\t\tfor(int k = s; k < 2+s; k++){\n\t\t\t\t\t\t\t\t\tfield[k]=cand+'0';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\t\tif(cand==n){\n\t\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(f)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t\tprvCand=cand;\n\t\t\t}\n\t\t\t//if(i==45){\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\t// ±±ÅÜ¿Ôð\\¦\n\t\tcout<<time-n*5<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int ans[100]={0};\n  vector<int>seki(17,-1);\n  vector<int>machi;\n  rep(i,100000){\n    //cout<<machi.size()<<endl;\n    if(i>510&&machi.size()==0)break;\n    if(i<500&&i%5==0)machi.pb(i/5);\n    rep(j,17){\n      if(seki[j]==1)seki[j]=-1;\n      else if(seki[j]!=-1)seki[j]--;\n    }\n    while(1){\n      if(machi.size()==0)break;\n      int n;\n      if(machi[0]%5==1)n=5;\n      else n=2;\n      bool han=false;\n      rep(j,17-n+1){\n\tbool h=true;\n\trep(k,n)if(seki[k+j]!=-1){h=false;break;}\n\tif(h){\n\t  han=true;\n\t  ans[machi[0]]=i-machi[0]*5;\n\t  rep(k,n)seki[k+j]=17*(machi[0]%2)+3*(machi[0]%3)+19;\n\t  machi.erase(machi.begin());\n\t  break;\n\t}\n\t//cout<<i<<endl;\n      }\n      if(han==false)break;\n    }\n    //if(i<100)cout<<i;\n    //if(i<100)rep(l,17)printf(\" %3d\",seki[l]);//cout<<\" \"<<seki[l];\n    //if(i<100)cout<<endl;\n  }\n  int in;\n  while(cin>>in)cout<<ans[in]<<endl;\n  //rep(i,100)printf(\"%2d %d\\n\",i,ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::tuple<int,int,int> T;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N;\nint times[100];\nint chairs[17];\nstd::priority_queue<T,std::vector<T>,std::greater<T>> queue1, queue2; // queue1: 入っている人, queue2: 待っている人\n\n// (1) 入れる\n// (2) 次の人が入るように追い出す\n\nint position(const T& tuple){\n    for(int i=0;i+std::get<1>(tuple)<=17;i++){\n        bool can = true;\n        REP(j, std::get<1>(tuple)){\n            if(chairs[i+j] != -1){can = false; break;}\n        }\n        if(can){return i;}\n    }\n    return -1;\n}\n\nvoid enter(const T& tuple, const int& pos, const int& t){\n    int index = std::get<2>(tuple);\n    REP(i, std::get<1>(tuple)){\n        chairs[pos+i] = index;\n    }\n    queue1.push(std::make_tuple(t+17*(index%2)+3*(index%3)+19, std::get<1>(tuple), index));\n}\n\nvoid leave(const T& tuple){\n    REP(i, 17){\n        if(chairs[i] == std::get<2>(tuple)){chairs[i] = -1;}\n    }\n}\n\nvoid simulate(){\n    std::fill(chairs, chairs+17, -1);\n\n    REP(i, 100){\n        queue2.push(std::make_tuple(5*i, i%5==1?5:2, i));\n    }\n\n    int t = 0;\n    while(!queue2.empty()){\n        while(!queue1.empty()){\n            T tuple = queue1.top();\n            if(std::get<0>(tuple) == t){\n                // printf(\"Exit %d %d\\n\", std::get<2>(tuple), t);\n                queue1.pop();\n                leave(tuple);\n            }else{break;}\n        }\n\n        while(!queue2.empty()){\n            T tuple = queue2.top();\n        \n            int pos = position(tuple);\n            if(pos != -1 && std::get<0>(tuple) <= t){\n                // printf(\"Enter %d %d\\n\", std::get<2>(tuple), t);\n                queue2.pop();\n                enter(tuple, pos, t);\n                times[std::get<2>(tuple)] = t - std::get<0>(tuple);\n            }else{\n                break;\n            }\n        }\n\n        t += 1;\n    }\n}\n\nint main(){\n    simulate();\n    \n    while(std::cin >> N, !std::cin.eof()){\n        std::cout << times[N] << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass PersonInfo {\npublic:\n\tint id;\n\tint numberOfPeople;\n\tint arriveTime, eatTime;\n};\n\nint CounterTable[17], Ans[100];\nvector<PersonInfo> PersonData;\n\n\nvoid Init() {\n\tPersonInfo temp;\n\n\tfor (int i = 0; i < 17; i++) {\n\t\tCounterTable[i] = 0;\n\t}\n\tmemset(Ans, 0, sizeof(Ans));\n\n\tfor (int i = 0; i < 100; i++) {\n\t\ttemp.id = i;\n\t\ttemp.numberOfPeople = (i % 5 == 1 ? 5 : 2);\n\t\ttemp.arriveTime = i * 5;\n\t\ttemp.eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\tPersonData.push_back(temp);\n\t}\n\t//cout << PersonData.size() << endl;\n}\n\n\nvoid clearCounterTable() {\n\tfor (int i = 0; i < 17; i++) {\n\t\tif (CounterTable[i] != 0) {\n\t\t\tCounterTable[i]--;\n\t\t}\n\t}\n}\n\nbool isSitOK(int number, int eatTime) {\n\tbool flag;\n\n\tflag = false;\n\tfor (int i = 0; i < 17; i++) {\n\t\tif (CounterTable[i] != 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 1; j < number; j++) {\n\t\t\tif (i + j > 16 || CounterTable[i + j] != 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflag = true;\n\t\t}\n\t\tif (flag) {\n\t\t\tfor (int j = 0; j < number; j++) {\n\t\t\t\tCounterTable[i + j] = eatTime;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid showTable(int time) {\n\tprintf(\"time[%03d]: \", time);\n\tfor (int i = 0; i < 17; i++) {\n\t\tif (CounterTable[i] == 0) {\n\t\t\tcout << \"*\";\n\t\t}\n\t\telse {\n\t\t\tcout << CounterTable[i];\n\t\t}\n\t}\n\tcout << endl;\n\n}\n\nvoid solve() {\n\tint time;\n\tPersonInfo temp;\n\n\ttime = 0;\n\ttemp = PersonData[0];\n\twhile (1) {\n\t\tclearCounterTable();\n\t\twhile ( (temp.id != 0 && time >= temp.arriveTime) || temp.id == 0 ) {\n\t\t\t//cout << \"currentTime:\" << time << \"  judgeID:\" << temp.id << endl;\n\t\t\tif ( !isSitOK(temp.numberOfPeople, temp.eatTime) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAns[temp.id] = time - temp.arriveTime;\n\t\t\tPersonData.erase(PersonData.begin());\n\t\t\tif (PersonData.empty()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttemp = PersonData[0];\n\t\t}\n\t\t//if (time % 5 == 0) {\n\t\t//\tshowTable(time);\n\t\t//}\n\t\ttime++;\n\t}\n}\n\nint main() {\n\tint n;\n\n\tInit();\n\tsolve();\n\twhile (cin >> n) {\n\t\tcout << Ans[n] << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n >= 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\twhile(c>=5){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tint ans = -1;\n\t\tint now;\n\t\tint sheets[SHEETS+1] = {-1,};\n\t\tint peoples[GROUPS] = {0,};\n\t\tint waiting[GROUPS] = {0,};\n\t\tint eating[GROUPS] = {0,};\n\t\t\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\t\tsheets[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < GROUPS; ++i)\n\t\t{\n\t\t\twaiting[i] = -i*5;\n\t\t\tpeoples[i] = i%5==1?5:2;\n\t\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t\t}\n\t\tnow = 1;\n\t\tsheets[0] = sheets[1] = 0;\n\t\tfor(int t = 0; t < 2000 && ans < 0; ++t){\n\t\t\t\n\t\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t\t++waiting[i];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t\tif( eating[sheets[i]] == 0 )\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\telse{\n\t\t\t\t\t\t--eating[sheets[i]];\n\t\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/*cout << \"t=\"<<t<<\":\\t\\t\";\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tcout << (char)(sheets[i]==-1?'_':sheets[i]+'0');\n\t\t\t}\n\t\t\tcout << '\\n';*/\n\t\t\t\n\t\t\twhile( ans < 0 ){\n\t\t\t\tbool bCont = false;\n\t\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\t\tint cont = 0;\n\t\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\t\tif( now == n ){\n\t\t\t\t\t\t\t\tans = waiting[now] - 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++now;\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !bCont )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 4)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n\nstruct info{\n  int g, t;\n  info(int g, int t) : g(g), t(t) {}\n};\n\nint arr[MAX];\nvector<info> seat;\n\nint minite(int i){\n  return 17*(i%2) + 3*(i%3) + 19;\n}\n\nvoid make(){\n  int g = 0;\n  for(int i = 0 ; i < 17 ; i++){\n    seat.push_back(info(-1,-1));\n  }\n  vector<info> _wait;\n  for(int i = 0 ; i < 570 ; i++){\n    int size = _wait.size();\n\n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        _wait[j].t++;\n      }\n    }\n   \n    for(int j = 0 ; j < 17 ; j++){\n      if(seat[j].g != -1){\n        seat[j].t--;\n        if(seat[j].t == 0){\n          seat[j].g = seat[j].t = -1;\n        }\n      }\n    }\n \n    if(size){\n      for(int j = 0 ; j < size ; j++){\n        int n = _wait[j].g;\n        int cnt, c;\n        bool flg = false;\n        if(n % 5 == 1) cnt = c = 5;\n        else cnt = c = 2;\n        for(int k = 0 ; k < 17 ; k++){\n          if(seat[k].g == -1) cnt--;\n          else cnt = c;\n          if(cnt == 0){\n            for(int l = k-c+1 ; l <= k ; l++){\n              seat[l].g = n;\n              seat[l].t = minite(n);\n            }\n            arr[n] = _wait[j].t;\n            flg = true;\n            j--;\n            _wait.erase(_wait.begin());\n            break;\n          }\n        }\n        if(!flg || !_wait.size()) break;\n      }\n      size = _wait.size();\n    }\n    if(g == 100) continue;\n    if(i % 5 == 0){\n      int cnt = 0;\n      bool flg = false;\n      if(size){\n        _wait.push_back(info(g,0));\n        g++;\n        continue;\n      }\n      if(g % 5 != 1){\n        for(int j = 0 ; j < 17 ; j++){\n          if(seat[j].g == -1) cnt++;\n          else cnt = 0;\n          if(cnt == 2){\n            flg = true;\n            for(int k = j-1 ; k <= j ; k++){\n              seat[k].g = seat[k].g = g;\n              seat[k].t = seat[k].t = minite(g);\n            }\n            arr[g] = 0;\n            break;\n          }\n        }\n      }else{\n        for(int j = 0 ; j < 17 ; j++){\n          if(seat[j].g == -1) cnt++;\n          else cnt = 0;\n          if(cnt == 5){\n            flg = true;\n            for(int k = j-4 ;  k <= j ; k++){\n              seat[k].g = seat[k].g = g;\n              seat[k].t = seat[k].t = minite(g);\n            }\n            arr[g] = 0;\n            break;\n          }\n        }\n      }\n \n      if(!flg){\n        _wait.push_back(info(g,0));\n      }\n      g++;\n    }\n  }\n}\n\nint main(){\n  int N;\n\n  make();\n  while(cin >> N){\n    cout << arr[N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17] = {-1};\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//?????????????????£?????´???\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n//aaa:\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t//?????????????????´???\n\t\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\t\tbool can_sit;\n\t\t\t\t\tbool sitted = false;\n\t\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcan_sit = true;\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (can_sit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//??§????????´???\n\t\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\t\t//goto aaa;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!sitted) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n#define\tEMPTY\t-1\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint Numbers(int groupid){\n\treturn groupid%5==1?5:2;\n}\n\nint MealTime(int groupid){\n\treturn 17*(groupid%2)+3*(groupid%3)+19;\n}\n\nint main()\n{\n\tint counter[17],elapse[17],mealtime[17];\n\tqueue<pii> qu;\t// <numbers in a group, group id>\n\n\tfor(int i=0;i<17;i++)\tcounter[i]=EMPTY;\n\n\tint waittime[100];\n\tfor(int t=0;t<589;t++){\n\t\t// enqueue\n\t\tif(t%5==0&&t<500){\n\t\t\tqu.push(mp(Numbers(t/5),t/5));\n\t\t}\n\n\t\t// going\n\t\tfor(int i=0;i<17;i++){\n\t\t\tif(counter[i]!=EMPTY){\n\t\t\t\telapse[i]++;\n\t\t\t\tif(elapse[i]==mealtime[i])\tcounter[i]=EMPTY;\n\t\t\t}\n\t\t}\n\n\t\t// coming\n\t\tif(!qu.empty()){\n\t\t\tpii next=qu.front();\n\t\t\tfor(int i=0,cnt=0;i<17;i++){\n\t\t\t\tif(counter[i]==EMPTY)\tcnt++;\n\t\t\t\telse\t\t\t\t\tcnt=0;\n\t\t\t\tif(cnt==next.first){\n\t\t\t\t\twaittime[next.second]=t-5*next.second;\n\t\t\t\t\tint mt=MealTime(next.second);\n\t\t\t\t\tfor(int j=i;j>i-next.first;j--){\n\t\t\t\t\t\tcounter[j]=next.second;\n\t\t\t\t\t\tmealtime[j]=MealTime(next.second);\n\t\t\t\t\t\telapse[j]=0;\n\t\t\t\t\t}\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tif(qu.empty())\tbreak;\n\t\t\t\t\tnext=qu.front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int n;~scanf(\"%d\",&n))\tprintf(\"%d\\n\",waittime[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 17;\nint seat[N+1];\nint ans[100];\n\nvoid sim(){\n\tint t = 0;\n\trep(i, 100){\n\t\tint num = i%5==1?5:2;\n\t\tif(t < 5*i){\n\t\t\trep(j, N) seat[j] -= min(seat[j], 5*i-t);\n\t\t\tt = 5*i;\n\t\t}\n\t\tbool ok = false;\n\t\twhile(1){\n\t\t\tint cnt = 0;\n\t\t\trep(j, num) cnt += !!seat[j];\n\t\t\trep(j, N+1-num){\n\t\t\t\tif(cnt == 0){\n\t\t\t\t\tFOR(k, j, j+num) seat[k] = 17*(i%2)+3*(i%3)+19;\n\t\t\t\t\tans[i] = t-5*i;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(seat[j+num]) ++cnt;\n\t\t\t\tif(seat[j]) --cnt;\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t\tint mint = 1<<29;\n\t\t\trep(j, N) if(seat[j]) mint = min(mint, seat[j]);\n\t\t\trep(j, N) if(seat[j]) seat[j] -= mint;\n\t\t\tt += mint;\n\t\t}\n\t\tprintf(\"\\ntime:%d\\nseat:\", t);\n\t\trep(j, N) printf(\"%3d\", seat[j]);\n\t}\n}\n\nint main(){\n\tsim();\n\tint n;\n\twhile(cin >> n) cout << ans[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define f(a)(a%5==1?5:2)\nusing namespace std;\ntypedef pair<int, int>P;//?????????????????????,??????????????????\n\nint c[17];\nint cnt[100];\nint main() {\n\tmemset(c, -1, sizeof(c));\n\tpriority_queue<P, vector<P>, greater<>>p;\n\tqueue<int>que;\n\tint time = 0;\n\twhile (1) {\n\t\tif (que.empty() && (time / 5 + 1) * 5 >= 100)break;\n\t\tif (time % 5 == 0 && time / 5 < 100)que.push(time / 5);\n\t\twhile (!p.empty() && p.top().first <= time) {\n\t\t\treplace(c, c + 17, p.top().second, -1);\n\t\t\tp.pop();\n\t\t}\n\t\tbool flag = true;\n\t\twhile (flag && !que.empty()) {\n\t\t\tint id = que.front();\n\t\t\tflag = false;\n\t\t\trep(i, 17 - f(id)) {\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, f(id)) {\n\t\t\t\t\tif (~c[i + j])ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\trep(j, f(id))c[i + j] = id; que.pop();\n\t\t\t\t\tcnt[id] = time - 5 * id;\n\t\t\t\t\tp.push(P(time + 17 * (id % 2) + 3 * (id % 3) + 19, id));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INT_MAX;\n\t\tif (!p.empty())Min = p.top().first;\n\t\tMin = min(Min, (time / 5 + 1)*5);\n\t\ttime = Min;\n\t}\n\tint n; while (~scanf(\"%d\", &n))printf(\"%d\\n\", cnt[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint ans[110], d[18];\n\nint calc(int t, int m){\n\tvi v(18, 0);\n\tfor(int i = 16; i >= 0; i--){\n\t\tif(d[i] <= t) v[i] = v[i+1]+1;\n\t}\n\tauto it = max_element(all(v));\n\tif(*it < m) return -1;\n\treturn it-v.begin();\n}\n\nint main(){\n\tint n, t=0, idx;\n\tfor(int i = 0; i < 100; i++){\n\t\tn = i%5==1?5:2;\n\t\tt = max(t,i*5);\n\t\twhile(1){\n\t\t\tidx = calc(t, n);\n\t\t\tif(idx < 0) {\n\t\t\t\tt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i] = t - i*5;\n\t\t\tfor(int j = 0; j < n; j++) d[idx+j] = t + 17*(i%2)+3*(i%3)+19;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// for(int i = 0; i < 100; i++){\n\t// \tcout<<ans[i]<<endl;\n\t// }\n\twhile(cin>>n){\n\t\tprintf(\"%d\\n\", ans[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define MP make_pair\n#define F first\n#define S second\n\nenum { INQ, SIT, LEAVE };\nint now; bool fiveempty, twoempty;\nint ans[100], seats[17];\nmap<int, deque<pair<int, int> > > mp;\ninline int num(int i) {return i%5==1?5:2;}\ninline int eattime(int i) {return 17*(i%2)+3*(i%3)+19;}\n\nvoid update_emptyseats() {\n  bool fe = 0, te = 0;\n  rep(i, 13)\n    if(seats[i]==-1 &&\n       seats[i+1]==-1 &&\n       seats[i+2]==-1 &&\n       seats[i+3]==-1 &&\n       seats[i+4]==-1) { fe = 1; }\n  rep(i, 16)\n    if(seats[i]==-1 && seats[i+1]==-1) { te = 1; }\n  fiveempty = fe, twoempty = te;\n}\n\nvoid sit(int id) {\n  ans[id] = now-5*id;\n  mp[now+eattime(id)].push_front(MP(id, (int)LEAVE));\n  \n  if(num(id) == 5) rep(i, 13)\n                     if(seats[i]==-1 &&\n                        seats[i+1]==-1 &&\n                        seats[i+2]==-1 &&\n                        seats[i+3]==-1 &&\n                        seats[i+4]==-1) {\n                       rep(j, 5) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     }\n  \n  if(num(id) == 2) rep(i, 16)\n                     if(seats[i]==-1 && seats[i+1]==-1) {\n                       rep(j, 2) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     } \n}\n\nvoid leave(int id) {\n  rep(i, 17) {\n    if(seats[i] == id) {\n      rep(j, num(id)) { seats[i+j] = -1; }\n      update_emptyseats();\n      return;\n    }\n  }\n}\n\nint main() {\n  \n  rep(i, 100) mp[5*i].push_back(MP(i, (int)INQ));\n  queue<int> waitingQ;\n  fiveempty = twoempty = 1;\n  memset(seats, -1, sizeof seats);\n  while(!mp.empty()) {\n    now = mp.begin()->F;\n    deque<pair<int, int> >& Q = mp.begin()->S;\n    int id = Q.front().F;\n    int act = Q.front().S; Q.pop_front();\n    if(act == SIT) {\n      sit(id);\n      if( !waitingQ.empty()\n          && ( (num(waitingQ.front()) == 5 && fiveempty)\n               || (num(waitingQ.front()) == 2 && twoempty) )\n      ) {\n        Q.push_front(MP(waitingQ.front(), (int)SIT));\n        waitingQ.pop();\n      }\n    }\n    else if(act == INQ) {\n      if(!waitingQ.empty()) { waitingQ.push(id); }\n      else if(num(id) == 5 && fiveempty) { sit(id); }\n      else if(num(id) == 2 && twoempty) { sit(id); }\n      else { waitingQ.push(id); }\n    }\n    else if(act == LEAVE) {\n      leave(id);\n      if( !waitingQ.empty()\n          && ( (num(waitingQ.front()) == 5 && fiveempty)\n               || (num(waitingQ.front()) == 2 && twoempty) )\n      ) { Q.push_front(MP(waitingQ.front(), (int)SIT)); waitingQ.pop(); }\n    }\n    if(Q.empty()) mp.erase(mp.begin());\n  }\n  for(int N; cin >> N;) cout << ans[N] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint dp[20],in[20],ans[111],t,id;\nqueue<int>q;\n\nvoid dele(){\n  r(i,17)if(dp[i]!=-1){\n    int x=17*(dp[i]%2)+3*(dp[i]%3)+19;\n    if(in[i]+x<=t)dp[i]=-1;\n  }\n}\n\nvoid inse(){\n  while(!q.empty()){\n    int x=q.front();\n    int n,flag=0;;\n    if(x%5==1)n=5;\n    else n=2;\n    r(i,17)if(dp[i]==-1){\n      if(i+n>17)continue;\n      int f=0;\n      r(j,n)if(dp[i+j]!=-1)f=1;\n      if(f)continue;\n      r(j,n){\n        in[i+j]=t;\n        dp[i+j]=x;\n        flag++;\n      }\n      ans[x]=t-5*x;\n      break;\n    }\n    if(flag)q.pop();\n    else break;\n  }\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  for(t=0;t<1000000;t++){\n    if(t%5==0&&id<=100)q.push(id++);\n    dele();\n    inse();\n  }\n  int n;\n  while(cin>>n)cout<<ans[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int MAX_SIZE = 100;\nconst int SEATS = 17;\n\nint* calc() {\n  queue<int> q;\n  int *a = new int[MAX_SIZE]();\n  int g, n, s[SEATS] = {};\n  for (int t = 0; ; ++t) {\n    for (int i = 0; i < SEATS; ++i) {\n      if (s[i]) s[i]--;\n    }\n    if (t % 5 == 0) q.push(t / 5);\n    while (!q.empty()) {\n      bool c = false;\n      g = q.front();\n      n = g % 5 == 1 ? 5 : 2;\n      for (int i = 0; i < SEATS - n + 1; ++i) {\n        if (n == 2 && !(s[i] || s[i + 1])) {\n          s[i] = s[i + 1] = 17 * (g % 2) + 3 * (g % 3) + 19;\n          c = true;\n          break;\n        }\n        if (n == 5 && !(s[i] || s[i + 1] || s[i + 2] || s[i + 3] || s[i + 4])) {\n          s[i] = s[i + 1] = s[i + 2] = s[i + 3] = s[i + 4] = 17 * (g % 2) + 3 * (g % 3) + 19;\n          c = true;\n          break;\n        }\n      }\n      if (c) {\n        a[g] = t - g * 5;\n        if (g == MAX_SIZE - 1) return a;\n        q.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  int *a = calc();\n  while (true) {\n    cin >> n;\n    if (cin.eof()) break;\n    cout << a[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{int t,n,e;bool operator <(const D &a)const{ return t>a.t;}};\npriority_queue<D>F;\nint r[N],s[20],w=0;\n\nint ch(int n)\n{\n\tfor(int i=0;i<17-n;i++)\n\t\tif(s[i]==-1)\n\t\t{\n\t\t\tint j;\n\t\t\tfor(j=0;j<n;j++)if(s[i+j]!=-1)break;\n\t\t\tif(j==n)return i;\n\t\t}\n\treturn -1;\n}\n\nint main()\n{\n\tmemset(s,-1,sizeof(s));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tD tmp={i*5,i,0};\n\t\tF.push(tmp);\n\t}\n\twhile(!F.empty())\n\t{\n\t\tD n=F.top();F.pop();\n\t\tif(n.e)\n\t\t{\n\t\t\tfor(int i=0;i<17;i++)\n\t\t\t\tif(s[i]==n.n)s[i]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(w<n.n)\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a=n.n%5==1?5:2,b=ch(a);\n\t\t\tif(b!=-1)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\ts[b+j]=n.n;\n\t\t\t\tr[n.n]=n.t-5*n.n;\n\t\t\t\tw=n.n+1;\n\t\t\t\tD tmp={n.t+19+17*(n.n%2)+3*(n.n%3),n.n,1};\n\t\t\t\tF.push(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t}\n\t\t}\n\t}\n\tfor(;~scanf(\"%d\",&w);)printf(\"%d\\n\",r[w]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint ans[100];\n\tvector<pii> seats; //group_num count\n\tseats.push_back(pii(-1, 17));\n\tpriority_queue<pii, vector<pii>, greater<pii> > pq; //taisyutu:time, group_num\n\tqueue<int> que; //mati:group_num\n\t\n\t\n\tint cnt = 0, t = 0;\n\twhile (cnt < 100) {\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top();\n\t\t\tif (now.first != t) break;\n\t\t\tpq.pop();\n\t\t\tREP(i, seats.size()) if (seats[i].first == now.second) seats[i].first = -1;\n\t\t}\n\t\tREP(i, seats.size() - 1) {\n\t\t\tif (seats[i].first == seats[i + 1].first) {\n\t\t\t\tseats[i].second += seats[i + 1].second;\n\t\t\t\tseats.erase(seats.begin() + i + 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (t % 5 == 0 && t / 5 < 100) que.push(t / 5);\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tint now = que.front();\n\t\t\tint count = now % 5 == 1 ? 5 : 2;\n\t\t\tbool flag = true;\n\t\t\tREP(i, seats.size()) {\n\t\t\t\tif (seats[i].first == -1 && seats[i].second >= count) {\n\t\t\t\t\tif (seats[i].second - count > 0)\n\t\t\t\t\t\tseats.insert(seats.begin() + i + 1, pii(-1, seats[i].second - count));\n\t\t\t\t\tseats[i] = pii(now, count);\n\t\t\t\t\tpq.push(pii(t + 17*(now % 2) + 3*(now % 3) + 19, now));\n\t\t\t\t\t\n\t\t\t\t\tans[now] = t - now * 5;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tque.pop();\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\t\n\t\tt++;\n\t}\n\t\n\t\n\tint n;\n\twhile (cin >> n) cout << ans[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nmain(){\n  int data[100][2], ans[101];\n  int seki[17], q=0;\n  for(int i=0;i<100;i++){\n    if(i%5==1){\n      data[i][0]=5;\n    }\n    else{\n      data[i][0]=2;\n    }\n    data[i][1]=17*(i%2)+3*(i%3)+19;\n  }\n  for(int i=0;i<17;i++){\n    seki[i]=0;\n  }\n  \n  for(int i=0;i<50;i++){\n    // printf(\"!%d! \", i);\n    for(int j=0;j<17;j++){\n      //printf(\"%2d \", seki[j]);\n    }\n    //printf(\"\\n\");\n    for(int j=0;j<17;j++){\n      if(seki[j]>0){\n\tseki[j]--;\n      }\n    }\n\n    while(q<=i/5){\n      int tmp=q;\n      if(data[q][0]==2){\n\tfor(int j=0;j<16;j++){\n\t  if(seki[j]==0 && seki[j+1]==0){\n\t    seki[j]=seki[j+1]=data[q][1];\n\t    ans[q]=i-q*5;\n\t    q++;\n\t    break;\n\t  }\n\t}\n      }\n      else{\n\tfor(int j=0;j<13;j++){\n\t  if(seki[j]==0 && seki[j+1]==0 && seki[j+2]==0 && seki[j+3]==0 && seki[j+4]==0){\n\t    seki[j]=seki[j+1]=seki[j+2]=seki[j+3]=seki[j+4]=data[q][1];\n\t    ans[q]=i-q*5;\n\t    q++;\n\t    break;\n\t  }\n\t}\n      }\n      if(tmp==q) break;\n    }\n  }\n  \n  int n;\n  while(cin >> n){\n    cout << ans[n] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint seat[17];\nint res[200];\n\nint main() {\n\tint i;\n\tint j;\n\tint k=-1;\n\tfor(i=0;i<600;i++){\n//cout<<i<<endl;\n\t\tfor(j=0;j<17;j++){\n\t\t\tif(seat[j])seat[j]--;\n//cout<<\" \"<<j<<\" \"<<seat[j]<<endl;\n\t\t}\n\t\tif(k==-1){\n\t\t\tif(i%5==0){\n\t\t\t\tk=i/5;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint l;\n\t\t\tif(k==-1)break;\n\t\t\tif(k%5==1){\n\t\t\t\tfor(l=0;l<=17-5;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]+seat[l+2]+seat[l+3]+seat[l+4]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=seat[l+2]=seat[l+3]=seat[l+4]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<=17-2;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\ta:;\n\t\t}\n//cout<<i<<endl;\n//for(j=0;j<17;j++){\n//\tcout<<\" \"<<j<<\" \"<<seat[j]<<endl;\n//}\n//cout<<\"  \"<<k<<endl;\n\t}\n\tint n;\n//for(n=0;n<200;n++){\n//\tcout<<n<<\" \"<<res[n]<<endl;\n//}\n\twhile(cin>>n){\n\t\tcout<<res[n]<<endl;\n\t}\n\treturn 0;\n}\n\n//WA"
  },
  {
    "language": "C++",
    "code": "//Name: Fukushimaken\n//Level: 2\n//Category: シミュレーション\n//Note: \n\n/**\n * 問題文の通りにシミュレーションする。\n * グループの到着と、食事の終了イベントをpriority_queueに突っ込んで取り出すようにする。\n * 到着したグループは別途queueに突っ込み、席に空きができたら埋めていくようにする。\n *\n * 入力が小さいので、特に効率のよいデータ構造を使わなくても間に合う。\n * オーダーは O(NW log N)。\n * ただしNはグループ数で、N=100。Wは座席の幅で、W=17。\n */\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct Event {\n    enum {\n        ARRIVAL,\n        FINISH\n    } type;\n    int t;\n    int idx;\n\n    bool operator <(const Event &e) const {\n        return t > e.t;\n    }\n};\n\nint gsize(int n) {\n    return (n % 5 == 1 ? 5 : 2);\n}\n\nbool solve(bool first) {\n    vector<int> res(100, -1);\n    priority_queue<Event> eventq;\n    for(int i = 0; i < 100; ++i) {\n        eventq.push(Event{Event::ARRIVAL, i*5, i});\n    }\n    queue<int> q;\n    vector<int> seats(17, -1);\n    while(!eventq.empty()) {\n        const int curt = eventq.top().t;\n        while(!eventq.empty() && eventq.top().t == curt) {\n            const Event e = eventq.top();\n            eventq.pop();\n            if(e.type == Event::ARRIVAL) {\n                q.push(e.idx);\n            } else {\n                for(int i = 0; i < 17; ++i) {\n                    if(seats[i] == e.idx) seats[i] = -1;\n                }\n            }\n        }\n        while(!q.empty()) {\n            const int idx = q.front();\n            const int s = gsize(idx);\n            int acc = 0;\n            int pos = -1;\n            for(int i = 0; i < 17; ++i) {\n                if(seats[i] == -1) {\n                    ++acc;\n                } else {\n                    acc = 0;\n                }\n                if(acc == s) {\n                    pos = i - s + 1;\n                    break;\n                }\n            }\n            if(pos == -1) break;\n            for(int i = 0; i < s; ++i) {\n                seats[pos+i] = idx;\n            }\n            res[idx] = curt - idx*5;\n            eventq.push(Event{Event::FINISH, curt + 17*(idx%2) + 3*(idx%3) + 19, idx});\n            q.pop();\n            /*\n               for(int i = 0; i < 17; ++i) {\n               if(seats[i] == -1) cout << '-';\n               else cout << seats[i]%10;\n               }\n               cout << endl;\n               */\n        }\n    }\n\n    int N;\n    while(cin >> N) {\n        cout << res[N] << endl;\n    }\n    return false;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    bool first = true;\n    while(solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint Time[10] = {  0,  5, 10, 15, 20, 25, 30, 35, 40, 45};\nint peop[10] = {  2,  5,  2,  2,  2,  2,  5,  2,  2,  2};\nint eats[10] = { 19, 39, 25, 36, 22, 42, 19, 39, 25, 36};\nint star[10];\nint tabl[17];\nint ans[10];\n\nint main(){\n  int next = 0;\n  REP(i,17) tabl[i] = -1;\n  for(int i=0; ; i++){\n    REP(j,17) if(tabl[j] != -1){\n      int t = tabl[j];\n      if(star[t] + eats[t] == i){\n        tabl[j] = -1;\n        if(t == 9) goto end;\n      }\n    }\n\n  loop:\n    if(Time[next] <= i){\n      int cnt = 0;\n      int st  = -1;\n      REP(j,17){\n        if(tabl[j] == -1){\n          if(cnt == 0) st = j;\n          cnt++;\n          if(cnt == peop[next])\n            break;\n        }else cnt = 0;\n      }\n      if(cnt == peop[next]){\n        ans[next] = i - Time[next];\n        star[next] = i;\n        REP(j,peop[next])\n          tabl[st + j] = next;\n        next++;\n        goto loop;\n      }\n    }\n\n    /*\n    printf(\"%d: \",i);\n    REP(j,17){printf(\"%3d \",tabl[j]);} puts(\"\");\n    getchar();\n    */\n  }\n\n end:\n  int n;\n  while(~scanf(\"%d\",&n))\n    print(ans[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n    int f[100] = {0}, n;\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 0;\n    f[3] = 0;\n    f[4] = 0;\n    f[5] = 0;\n    f[6] = 14;\n    f[7] = 9;\n    f[8] = 4;\n    f[9] = 0;\n    f[10] = 0;\n    f[11] = 8;\n    f[12] = 3;\n    f[13] = 2;\n    f[14] = 0;\n    f[15] = 0;\n    f[16] = 15;\n    f[17] = 10;\n    f[18] = 15;\n    f[19] = 10;\n    f[20] = 6;\n    f[21] = 12;\n    f[22] = 7;\n    f[23] = 9;\n    f[24] = 11;\n    f[25] = 6;\n    f[26] = 23;\n    f[27] = 18;\n    f[28] = 13;\n    f[29] = 8;\n    f[30] = 3;\n    f[31] = 23;\n    f[32] = 18;\n    f[33] = 13;\n    f[34] = 8;\n    f[35] = 3;\n    f[36] = 34;\n    f[37] = 29;\n    f[38] = 24;\n    f[39] = 22;\n    f[40] = 17;\n    f[41] = 28;\n    f[42] = 23;\n    f[43] = 24;\n    f[44] = 19;\n    f[45] = 27;\n    f[46] = 34;\n    f[47] = 29;\n    f[48] = 35;\n    f[49] = 30;\n    f[50] = 28;\n    f[51] = 31;\n    f[52] = 28;\n    f[53] = 23;\n    f[54] = 24;\n    f[55] = 28;\n    f[56] = 42;\n    f[57] = 37;\n    f[58] = 32;\n    f[59] = 27;\n    f[60] = 22;\n    f[61] = 42;\n    f[62] = 37;\n    f[63] = 32;\n    f[64] = 27;\n    f[65] = 22;\n    f[66] = 53;\n    f[67] = 48;\n    f[68] = 43;\n    f[69] = 41;\n    f[70] = 36;\n    f[71] = 47;\n    f[72] = 42;\n    f[73] = 43;\n    f[74] = 38;\n    f[75] = 46;\n    f[76] = 64;\n    f[77] = 59;\n    f[78] = 54;\n    f[79] = 49;\n    f[80] = 44;\n    f[81] = 61;\n    f[82] = 56;\n    f[83] = 51;\n    f[84] = 46;\n    f[85] = 44;\n    f[86] = 72;\n    f[87] = 67;\n    f[88] = 62;\n    f[89] = 57;\n    f[90] = 52;\n    f[91] = 72;\n    f[92] = 67;\n    f[93] = 62;\n    f[94] = 57;\n    f[95] = 52;\n    f[96] = 83;\n    f[97] = 78;\n    f[98] = 73;\n    f[99] = 71;\n    while(cin >> n){\n        cout << f[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int N = 17;\nint seat[N+1];\nint ans[100];\n\nvoid sim(){\n\tint t = 0;\n\trep(i, 100){\n\t\tint num = i%5==1?5:2;\n\t\tif(t < 5*i){\n\t\t\trep(j, N) seat[j] -= min(seat[j], 5*i-t);\n\t\t\tt = 5*i;\n\t\t}\n\t\tbool ok = false;\n\t\twhile(1){\n\t\t\tint cnt = 0;\n\t\t\trep(j, num) cnt += !!seat[j];\n\t\t\trep(j, N+1-num){\n\t\t\t\tif(cnt == 0){\n\t\t\t\t\tFOR(k, j, j+num) seat[k] = 17*(i%2)+3*(i%3)+19;\n\t\t\t\t\tans[i] = t-5*i;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(seat[j+num]) ++cnt;\n\t\t\t\tif(seat[j]) --cnt;\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t\tint mint = 1<<29;\n\t\t\trep(j, N) if(seat[j]) mint = min(mint, seat[j]);\n\t\t\trep(j, N) if(seat[j]) seat[j] -= mint;\n\t\t\tt += mint;\n\t\t}\n\t\t//printf(\"\\ntime:%d\\nseat:\", t);\n\t\t//rep(j, N) printf(\"%3d\", seat[j]);\n\t}\n}\n\nint main(){\n\tsim();\n\tint n;\n\twhile(cin >> n) cout << ans[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint ans[110], d[18];\n\nint calc(int t, int m){\n\tvi v(18, 0);\n\tfor(int i = 16; i >= 0; i--){\n\t\tif(d[i] <= t) v[i] = v[i+1]+1;\n\t}\n\tauto it = max_element(all(v));\n\tif(*it < m) return -1;\n\treturn it-v.begin();\n}\n\nint main(){\n\tint n, t, idx;\n\tfor(int i = 0; i < 100; i++){\n\t\tn = i%5==1?5:2;\n\t\tt = max(t,i*5);\n\t\twhile(1){\n\t\t\tidx = calc(t, n);\n\t\t\tif(idx < 0) {\n\t\t\t\tt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i] = t - i*5;\n\t\t\tfor(int j = 0; j < n; j++) d[idx+j] = t + 17*(i%2)+3*(i%3)+19;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(cin>>n){\n\t\tprintf(\"%d\\n\", ans[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint d[17];\n\tint n[100]={0};\n\tint cnt=0,t=0;\n\tqueue<int> q;\n\trep(i,17)d[i]=0;\n\tfor(;cnt<100;t++){\n\t\tif(t%5==0 && t<500)q.push(t/5);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();\n\t\t\tint num=v%5==1?5:2;\n\t\t\tint g=0;\n\t\t\trep(j,18-num){\n\t\t\t\tif(d[j]<1 && !g){\n\t\t\t\t\tg=1;\n\t\t\t\t\treps(k,1,num-1){\n\t\t\t\t\t\tif(d[j+k]>0)g=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(g){\n\t\t\t\t\t\trep(k,num)d[j+k]=17*(v%2)+3*(v%3)+19;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g)break;\n\t\t\tq.pop();\n\t\t\tn[v]=t-v*5;\n\t\t\tcnt++;\n\t\t}\n\t\trep(i,17)if(d[i]>0)d[i]--;\n\t}\n\twhile(~scanf(\"%d\",&t))printf(\"%d\\n\",n[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 3)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nmultimap<int,int> ckout;\nint ckin[100],seat[17];\n\nvoid rm(multimap<int,int>::iterator p){\n\trep(i,17)if(seat[i]==p->second)seat[i]=-1;\n\tckout.erase(p);\n}\nint findseat(int k){\n\tint l=k%5==1?5:2,len=0,p,pos;\n\tfor(p=0;p<17;p++){\n\t\tif(seat[p]==-1){\n\t\t\tif(!len)pos=p;\n\t\t\tif(++len==l)return pos;\n\t\t}else len=0;\n\t}\n\treturn -1;\n}\nint main(){\n\tfill(ckin,ckin+100,-1); fill(seat,seat+17,-1);\n\tint n,k,t,q;\n\tmultimap<int,int>::iterator p;\n\tfor(k=t=0;k<100||ckout.empty();t++){\n\t\twhile((p=ckout.find(t))!=ckout.end())rm(p);\n\t\twhile(ckin[k]==-1&&t>=5*k){\n\t\t\tif((q=findseat(k))!=-1){\n\t\t\t\tint l=k%5==1?5:2;\n\t\t\t\tckin[k]=t;\n\t\t\t\trep(i,l)seat[q+i]=k;\n\t\t\t\tckout.insert(make_pair(t+17*(k%2)+3*(k%3)+19,k));\n\t\t\t\tk++;\n\t\t\t}else break;\n\t\t}\n\t}\n\twhile(cin>>n)cout<<ckin[n]-n*5<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint Brank(vint v, int num)\n{\n\trep(i, v.size() - num + 1)\n\t{\n\t\trep(j, num)\n\t\t{\n\t\t\tif(v[i + j] != -1) break;\n\t\t\telse if(j + 1 == num) return i;\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint main()\n{\n    for(int n; cin >> n;)\n\t{\n\t\tqueue<int>  que; // id\n\t\tvint store(16, -1); // time\n\t\tint nxt = 0, start;\n\t\t\n\t\tfor(int time = 0; ; time++)\n\t\t{\n\t\t\t// ツ行ツ療アツづ可嘉つヲツづゥ\n\t\t\tif(time % 5 == 0)\n\t\t\t{\n\t\t\t\tif(nxt == n) start = time;\n\t\t\t\t\n\t\t\t\tque.push(nxt++);\n\t\t\t}\n\t\t\t\n\t\t\t// ツ店ツつゥツづァツ出ツつキ\n\t\t\trep(i, 16)\n\t\t\t\tstore[i] = (store[i] == time ? -1 : store[i]);\n\t\t\t\n\t\t\t// ツ店ツづ可禿シツづェツづゥ\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tint id = que.front();\n\t\t\t\tint num = (id % 5 == 1 ? 5 : 2);\n\t\t\t\t\n\t\t\t\tint index = Brank(store, num);\n\t\t\t\t\n\t\t\t\tif(index != -1)\n\t\t\t\t{\n\t\t\t\t\tif(id == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout << time - start << endl;\n\t\t\t\t\t\tgoto ng;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint span = 17 * (id % 2) + 3 * (id % 3) + 19; \n\t\t\t\t\tREP(i, index, index + num) \n\t\t\t\t\t{\n\t\t\t\t\t\tstore[i] = time + span;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tque.pop();\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\tng:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nstruct Table {\n  Table(int len) : table(len, 0) { RLE(); }\n  void RLE(){\n    rep(i, table.size()){\n      if (table[i] < 0) continue;\n      int count = 0;\n      reps(j, i, table.size()){\n        if (table[j] >= 0) count++;\n        else break;\n      }\n      table[i] = count;\n    }\n  }\n  bool insert(int cid){\n    int len = cid % 5 == 1 ? 5 : 2;\n    int pos = -1;\n    rep(i, table.size()){\n      if (table[i] < 0) continue;\n      if (table[i] >= len){\n        pos = i;\n        break;\n      }\n    }\n    if (pos == -1) return false;\n    rep(i, len){\n      table[pos + i] = ~cid;\n    }\n    return true;\n  }\n  void remove(int cid){\n    rep(i, table.size()){\n      if (cid == ~table[i]) table[i] = 0;\n    }\n    RLE();\n  }\n  vector<int> table;\n};\n\nint main()\n{\n  Table table(17);\n  priority_queue<pair<int, int> > event;\n  queue<pair<int, int> > wait;\n  int ans[100] = {};\n  rep(i, 100){\n    int in_time = i * 5;\n    int out_time = in_time + (17 * (i % 2)) + (3 * (i % 3)) + 19;\n    event.push(make_pair(-in_time, i * 2));\n    event.push(make_pair(-out_time, i * 2 + 1));\n  }\n  while (!event.empty()){\n    int now_time = -event.top().first;\n    int cid = event.top().second;\n    event.pop();\n    bool is_in = cid % 2 == 0;\n    cid /= 2;\n    if (is_in){\n      wait.push(make_pair(cid, now_time));\n    }\n    else {\n      table.remove(cid);\n    }\n    while (!wait.empty()){\n      int wc = wait.front().first;\n      int wt = wait.front().second;\n      if (!table.insert(wc)) break;\n      ans[wc] = now_time - wt;\n      wait.pop();\n    }\n  }\n  int n;\n  while (~scanf(\"%d\", &n)){\n    printf(\"%d\\n\", ans[n]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=20){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  vector<int> a[1000];\n  int seat[17], in[100], out[100];\n  queue<int> Q;\n  fill_n((int*)seat, 17, -1);\n  for (int i = 0; i < 1000; i++) {\n    if (i < 500 && i % 5 == 0) {\n      Q.emplace(i / 5);\n      in[i / 5] = i;\n    }\n    for (int j : a[i]) {\n      for (int k = 0; k < 17; k++) {\n        if (seat[k] == j) seat[k] = -1;\n      }\n    }\n    while (!Q.empty()) {\n      int num = Q.front() % 5 == 1 ? 5 : 2;\n      int l = 0, r = 0, flag = 0;\n      while (l < 17) {\n        while (l < 17 && seat[l] != -1) l++, r++;\n        while (r < 17 && seat[r] == -1) r++;\n        if (r - l >= num) {\n          int group = Q.front();\n          Q.pop();\n          out[group] = i;\n          a[out[group] + 17 * (group % 2) + 3 * (group % 3) + 19].emplace_back(group);\n          for (int j = 0; j < num; j++) {\n            seat[j + l] = group;\n          }\n          flag = 1;\n          break;\n        }\n        l = r;\n      }\n      if (!flag) break;\n    }\n  }\n  int n;\n  while (cin >> n) {\n    cout << out[n] - in[n] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint chair[17];\nint ans[100];\n\n//øÌA±µÄ¢éÀÈÌÅ¬ÔðÔ·\nint isempty(int arg){\n\tint ret=-1;\n\tint num=0;\n\tint maxi = 0;\n\tint begin=0;\n\tfor(int i=0;i<17;i++){\n\t\tif(chair[i] == 0){\n\t\t\tif(num == 0) begin = i;\n\t\t\tnum++;\n\t\t}else{\n\t\t\tif(num >= arg) return begin;\n\t\t\tnum = 0;\n\t\t}\n\t}\n\tif(num >= arg) return begin;\n\treturn -1;\n}\n\nint main(){\n\tmemset(chair, 0, sizeof(chair));\n\tdeque<int> waiting;\n\tfor(int t=0;t<600;t++){\n\t\tint n;\n\t\tfor(int i=0;i<17;i++){\n\t\t\tif(chair[i] != 0) chair[i]--; //cèÔð¸ç·\n\t\t}\n\t\tif(t%5 == 0){ //q`FbN\n\t\t\twaiting.push_back(t/5);\n\t\t}\n\t\twhile(!waiting.empty()){ //È`FbN\n\t\t\tif(waiting.front()%5==1){\n\t\t\t\tn=5;\n\t\t\t}else{\n\t\t\t\tn=2;\n\t\t\t}\n\t\t\tint place = isempty(n);\n\t\t\tif(place == -1) break;\n\t\t\t//ÈÉÂ¯é\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tchair[place+j] = 17 * (waiting.front()%2) + 3 * (waiting.front()%3) + 19;\n\t\t\t}\n\t\t\tans[waiting.front()] = t - waiting.front() * 5;\n\t\t\twaiting.pop_front();\n\t\t}\n\t}\n\tint q;\n\t\n\twhile(cin >> q){\n\t\tcout << ans[q] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\nusing namespace std;\n\nstruct Chair{\n\tint group_id,rest_time;\n};\n\nstruct Info{\n\tint group_id,num,wait_sum,before_go;\n\tbool fixed;\n};\n\n\nint main(){\n\n\tint ans[100];\n\n\tChair chair[17];\n\tfor(int i = 0; i < 17; i++)chair[i].group_id = -1;\n\tInfo info[100];\n\tfor(int i = 0; i <= 99; i++){\n\t\tinfo[i].group_id = i;\n\t\tinfo[i].before_go = 5*i;\n\t\tinfo[i].wait_sum = 0;\n\t\tif(i%5==1){\n\t\t\tinfo[i].num = 5;\n\t\t}else{\n\t\t\tinfo[i].num = 2;\n\t\t}\n\t\tinfo[i].fixed = false;\n\t}\n\n\tint count;\n\tint FLG,tmp_num;\n\tbool isOK,waitFLG;\n\n\twhile(true){\n\n\t\tfor(int i = 0; i < 17; i++){\n\t\t\tif(chair[i].group_id != -1){\n\t\t\t\tchair[i].rest_time--;\n\t\t\t\tif(chair[i].rest_time <= 0){\n\t\t\t\t\tchair[i].group_id = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twaitFLG = false;\n\t\tcount = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tif(info[i].fixed)continue;\n\t\t\tif(waitFLG == false &&info[i].before_go == 0){\n\t\t\t\tFLG = -1;\n\t\t\t\ttmp_num = info[i].num;\n\n\t\t\t\tfor(int k = 0; k <= 17-tmp_num;k++){\n\t\t\t\t\tisOK = true;\n\t\t\t\t\tfor(int p = 0; p < tmp_num; p++){\n\t\t\t\t\t\tif(chair[k+p].group_id != -1){\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(isOK){\n\t\t\t\t\t\tFLG = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(FLG != -1){\n\t\t\t\t\tfor(int k = FLG; k < FLG + tmp_num;k++){\n\t\t\t\t\t\tchair[k].group_id = info[i].group_id;\n\t\t\t\t\t\tchair[k].rest_time = 17*(i%2)+3*(i%3)+19;\n\t\t\t\t\t\tinfo[i].fixed = true;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\twaitFLG = true;\n\t\t\t\t\tinfo[i].wait_sum++;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(info[i].before_go == 0){\n\t\t\t\t\tinfo[i].wait_sum++;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[i].before_go--;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count == 0)break;\n\t}\n\n\tfor(int i = 0; i <= 99; i++){\n\t\tans[i] = info[i].wait_sum;\n\t}\n\n\tint N;\n\n\twhile(scanf(\"%d\",&N) != EOF){\n\t\tprintf(\"%d\\n\",ans[N]);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int a[100];\n  int cr[17]={};\n  queue<int> que;\n  for(int t=0;t<600;t++){\n    if(t%5==0&&t/5<100){\n      que.push(t/5);\n    }\n    for(int i=0;i<17;i++){\n      cr[i]--;\n    }\n    int fc=0;\n    for(int i=0;i<17;i++){\n      if(cr[i]<=0){\n\tfc++;\n\tif(!que.empty()){\n\t  int gn=que.front();\n\t  int ng=(gn%5==1)?5:2;\n\t  if(fc==ng){\n\t    for(int j=0;j<ng;j++){\n\t      cr[i-j]=17*(gn%2)+3*(gn%3)+19;\n\t    }\n\t    a[gn]=t-gn*5;\n\t    que.pop();\n\t    i=-1;\n\t    fc=0;\n\t  }\n\t}\n      }else{\n\tfc=0;\n      }\n    }\n  }\n  for(int n;cin>>n;){\n    cout<<a[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{int t,n,e;bool operator <(const D &a)const{return t==a.t?e<a.e:t>a.t;}};\npriority_queue<D>F;\nint r[N],s[20],w=0;\n\nint ch(int n)\n{\n\tfor(int i=0;i<17;i++)\n\t\tif(s[i]==-1)\n\t\t{\n\t\t\tint j;\n\t\t\tfor(j=0;j<n&&i+j<17;j++)if(s[i+j]!=-1)break;\n\t\t\tif(j==n)return i;\n\t\t}\n\treturn -1;\n}\n\nint main()\n{\n\tmemset(s,-1,sizeof(s));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tD tmp={i*5,i,0};\n\t\tF.push(tmp);\n\t}\n\twhile(!F.empty())\n\t{\n\t\tD n=F.top();F.pop();\n\t\tif(n.e)\n\t\t{\n\t\t\tfor(int i=0;i<17;i++)\n\t\t\t\tif(s[i]==n.n)s[i]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(w<n.n)\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a=n.n%5==1?5:2,b=ch(a);\n\t\t\tif(b!=-1)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\ts[b+j]=n.n;\n\t\t\t\tr[n.n]=n.t-5*n.n;\n\t\t\t\tw=n.n+1;\n\t\t\t\tD tmp={n.t+19+17*(n.n%2)+3*(n.n%3),n.n,1};\n\t\t\t\tF.push(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t}\n\t\t}\n\t}\n\tfor(;~scanf(\"%d\",&w);)printf(\"%d\\n\",r[w]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 130\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tsheets[SHEETS] = -2;\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 0;\n\tfor(int t = 0; t < 800; ++t){\n\n\t\t/*\n\t\tif( t % 5 == 0 ){\n\t\t\tcout << t / 5 << \"ツつウツづアツつェツδ債グツイツδ督つオツづ慊つオツつスツ。\\n\";\n\t\t}\n\t\t*/\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\t//if( i < SHEETS )\n\t\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t\t\n\t\t/*for(int i = 0; i < SHEETS; ++i){\n\t\t\tcout << sheets[i] << ' ';\n\t\t}\n\t\tcout << endl;*/\n\t}\n\t/*\n\tfor(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}\n\t*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint waiti[100];\nint seat[17];\n\nconst int INIT = 0xffffff;\n\ntypedef struct MATI\n{\n\tint id;\n\tint num;\n\tint eat;\n} MATI;\n\nint get_eat(int n)\n{\n\treturn 17 * (n%2) + 3 * (n%3) + 19;\n}\n\nint get_num(int n)\n{\n\tif(n%5==1) return 5;\n\telse return 2;\n}\n\nint can_sit(int n)\n{\n\tbool is_able = true;\n\tfor(int i=0; i<=17-n; i++)\n\t{\n\t\tis_able = true;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(seat[i+j] != 0)\n\t\t\t{\n\t\t\t\tis_able = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_able) return i;\n\t}\n\t\n\treturn -1;\n}\n\nvoid refresh()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tif(seat[i] != 0)\n\t\t{\n\t\t\tseat[i] = seat[i] - 1;\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tseat[i] = 0;\n\t}\n\t\n\tqueue<MATI> col;\n\t\n\tfor(int i=0; i<1000; i++)\n\t{\n\t\tint current_time = i;\n\t\trefresh();\n\t\t\n\t\tif(current_time%5==0)\n\t\t{\n\t\t\tMATI m;\n\t\t\tm.id = current_time /5;\n\t\t\tm.num = get_num(m.id);\n\t\t\tm.eat = get_eat(m.id);\n\t\t\tcol.push(m);\n\t\t}\n\t\t\n\t\twhile(!col.empty())\n\t\t{\n\t\t\tMATI m = col.front();\n\t\t\tint setter = can_sit(m.num);\n\t\t\tif(setter != -1)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t{\n\t\t\t\t\tseat[setter+j] = m.eat;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint wait_time = current_time - m.id * 5;\n\t\t\t\twaiti[m.id] = wait_time;\n\t\t\t\tif(m.id==99) return;\n\t\t\t\tcol.pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint n;\n\tsolve();\n\t\n\twhile(cin >> n)\n\t{\n\t\tcout << waiti[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint n,c[17],d[100];\nmain()\n{\n\tfor(int i=0;i<17;i++)c[i]=-1;\n\tpriority_queue<pair<int,int> >P;\n\tint now=0;\n\tfor(int i=0;i<100;i++)\n\t{\n\t\twhile(!P.empty()&&-P.top().first<=i*5)P.pop();\n\t\tint L=-1;\n\t\twhile(L<0)\n\t\t{\n\t\t\tfor(int j=0;j+(i%5==1?5:2)<=17;j++)\n\t\t\t{\n\t\t\t\tbool ok=1;\n\t\t\t\tfor(int k=0;k<(i%5==1?5:2);k++)ok&=c[j+k]==-1;\n\t\t\t\tif(ok)\n\t\t\t\t{\n\t\t\t\t\tL=j;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(L>=0)break;\n\t\t\tpair<int,int>p=P.top();P.pop();\n\t\t\tnow=-p.first;\n\t\t\tfor(int j=0;j<17;j++)if(c[j]==p.second)c[j]=-1;\n\t\t}\n\t\tif(now<i*5)now=i*5;\n\t\tP.push(make_pair(-now-(17*(i%2)+3*(i%3)+19),i));\n\t\td[i]=now-i*5;\n\t\tfor(int k=0;k<(i%5==1?5:2);k++)c[L+k]=i;\n\t}\n\twhile(cin>>n)cout<<d[n]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==98)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n < 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\twhile(c>=5){return 1};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n == 1)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\tint a = 0;\n\twhile(c>=1){cout << a/a << endl;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<queue>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int a[100];\n  int cg[17]={};\n  int cr[17];\n  queue<pair<int,int> > que;\n  for(int t=0;t<600;t++){\n    if(t%5==0&&t/5<100){\n      que.push(make_pair(t/5,t));\n    }\n    for(int i=0;i<17;i++){\n      cr[i]--;\n      if(cr[i]==0){\n\tcg[i]=false;\n      }\n    }\n    int fc=0;\n    for(int i=0;i<17;i++){\n      if(cg[i]==false){\n\tfc++;\n\tif(!que.empty()){\n\t  int gn=que.front().first;\n\t  int ng=(gn%5==1)?5:2;\n\t  if(fc==ng){\n\t    for(int j=0;j<ng;j++){\n\t      cg[i-j]=true;\n\t      cr[i-j]=17*(gn%2)+3*(gn%3)+19;\n\t    }\n\t    a[gn]=t-que.front().second;\n\t    que.pop();\n\t    i=0;\n\t  }\n\t}\n      }else{\n\tfc=0;\n      }\n    }\n  }\n  for(int n;cin>>n;){\n    cout<<a[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint n, cntdwn[17]={}, ans[100];\n\tqueue<int> q;\n\tfor (int m=0; m<600; ++m) {\n\t\tif (m%5==0 && m/5<100) q.push(m/5);\n\t\tfor (int i=0; i<17; ++i) --cntdwn[i];\n\t\twhile ( ! q.empty()) {\n\t\t\tint num = (q.front()%5==1 ? 5 : 2);\n\t\t\tint c = 0, k = -1;\n\t\t\tfor (int i=0; i<17; ++i) {\n\t\t\t\tc = (cntdwn[i]<=0 ? c+1 : 0);\n\t\t\t\tif (c==num) {\n\t\t\t\t\tk = i-num+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k < 0) break;\n\t\t\tfor (int i=k; i<k+num; ++i) {\n\t\t\t\tcntdwn[i] = 17*(q.front()%2)+3*(q.front()%3)+19;\n\t\t\t}\n\t\t\tans[q.front()] = m-5*q.front();\n\t\t\tq.pop();\n\t\t}\n\t}\n\twhile (cin >> n) {\n\t\tcout << ans[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17];\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\nbool can_sit;\nbool sitted;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcan_sit;\n\t\t\t\tsitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n//aaa:\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\t\tcan_sit;\n\t\t\t\t\tsitted = false;\n\t\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcan_sit = true;\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (can_sit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\t\t//goto aaa;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!sitted) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int time = 0;\n  vector<int> seat(17, INF), ans(100);\n  for (int i = 0; i < 100; ++i) {\n    time = max(time, i*5);\n    int people = 2;\n    if (i%5 == 1)\n      people = 5;\n\n    for ( ; ; ) {\n      for (int j = 0; j < seat.size(); ++j) {\n\tif (seat[j] <= time)\n\t  seat[j] = INF;\n      }\n\n      int con = 0;\n      bool in = false;\n      for (int j = 0; j < seat.size(); ++j) {\n\tif (seat[j] == INF) {\n\t  ++con;\n\t  if (con == people) {\n\t    in = true;\n\t    for (int k = j; k > j-con; --k)\n\t      seat[k] = time + 17*(i%2) + 3*(i%3) + 19;\n\t    ans[i] = max(0, time - i*5);\n\t    break;\n\t  }\n\t} else {\n\t  con = 0;\n\t}\n      }\n\n      if (in)\n\tbreak;\n\n      int min_time = INF;\n      for (int j = 0; j < seat.size(); ++j)\n\tmin_time = min(min_time, seat[j]);\n      time = min_time;\n    }\n  }\n\n  int n;\n  while (cin >> n)\n    cout << ans[n] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <map>\n#include <queue>\nusing namespace std;\n \n int main() {\n  int i=0,j,k=0,m,n,t=0,s[17],ad[200],len[200],ans[200];\n  multimap<int,int> mp;\n  queue<int> qu; ans[99]=-1;\n  for (k=0;k<17;k++) s[k]=0;\n  while(true) {\n  if (!mp.empty()) {  \n      if ((*mp.begin()).first==t) {\n         while(!mp.empty() && (*mp.begin()).first == t) {\n\t     m=(*mp.begin()).second;\n\t     for (j=ad[m]; j<ad[m]+len[m]; j++) s[j]=0;\n\t\t mp.erase(mp.begin()); }\n\t    }\n  }\n  if (t % 5==0) { i=t/5; qu.push(i); len[i]=i % 5==1 ? 5 : 2;}\n  while(!qu.empty()) {\n\t  i=qu.front(); \n\t  for (j=0;j<18-len[i];j++) {\n\t\t  for (k=0;k<len[i];k++) if (s[j+k]>0) break;\n\t\t  if (k==len[i]) {for (k=0;k<len[i];k++) s[j+k]=i+1;\n\t\t                 ans[i]=t-5*i; ad[i]=j;\n\t\t\t\t\t\t qu.pop(); mp.insert(multimap<int,int>::value_type(t+17*(i % 2)+3*(i % 3)+19,i)); break;}\n\t  }\n      if (j==18-len[i]) break;\n  }\n  t++;\n  if (ans[99]>=0) break;\n  }\n  while(cin >> n) cout << ans[n] << endl;\n  return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint data[110];\n\nqueue<pii> ar(){\n    queue<pii> ret;\n    rep(i,100){\n        ret.push(pii(i,i*5));\n    }\n    return ret;\n}\n\n\nqueue<pii> de(){\n    vector<pii> tmp;\n    queue<pii> ret;\n    rep(i,100){\n        tmp.pb(pii(i*5+17*(i%2)+3*(i%3)+19,i));\n    }\n    sort(all(tmp));\n    rep(i,100){\n        ret.push(pii(tmp[i].second,tmp[i].first));\n    }\n    return ret;\n}\n\n\n\nint arr(pii f,int seat[20],queue<pii> &wait,int t){\n    int members;\n    if( (f.first)%5==1 )members = 5;\n    else members = 2;\n    \n    int dp[20]={};\n    for(int i=16;i>=0;i--){\n        if(seat[i]==-1) dp[i]=0;\n        else            dp[i] = dp[i+1]+1;\n    }\n    bool flag=false;\n    rep(i,17){\n        if(dp[i]>=members){\n            for(int j=i;j<i+members;i++){\n                seat[j] = f.first;\n            }\n            flag=true;\n        }\n    }\n    if(!flag){\n        wait.push( f );\n        return -1;\n    }\n    data[f.first] = t;\n    return 0;\n}\n\nvoid pre(){\n    int seat[20];\n    rep(i,17)seat[i]=-1;\n    queue<pii> arrive = ar();\n    queue<pii> dep = de();\n    bool flag=true;\n    int now=0;\n    while(arrive.size()+dep.size()){\n        if( flag==false || arrive.empty() || arrive.front().second>dep.front().second  ){ //??¢?????????\n            int dep_group = dep.front().first;\n            now =dep.front().second;\n            dep.pop();\n            rep(i,17){\n                if( seat[i]==dep_group ) seat[i]=-1;\n            }\n            flag = true;\n        }\n        else{ //??¢?????\\???\n            pii f = arrive.front();\n            int members;\n            if( (f.first)%5==1 )members = 5;\n            else members = 2;\n            \n            int dp[20]={};\n            for(int i=16;i>=0;i--){\n                if(seat[i]!=-1) dp[i] = 0;\n                else            dp[i] = dp[i+1]+1;\n            }\n            \n            flag = false;\n            rep(i,17){\n                if(dp[i]>=members){\n                    for(int j=i;j<i+members;j++){\n                        seat[j] = f.first;\n                    }\n                    flag=true;\n                    arrive.pop();\n                    data[f.first] = now;\n                    break;\n                }\n            }\n        }\n    }\n}\n\n\nint main(){\n    int n;\n    \n    pre();\n    \n    while(cin>>n){\n        cout<<max( 0 , data[n]-5*n )<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint seat[17];\nvector<int> rm[5000];\nqueue<int> q;\nint result[100];\n\nint ck(int c){\n\tc=c%5==1?5:2;\n\tint suc=0;\n\trep(i,17){\n\t\tif(seat[i]==-1){\n\t\t\tsuc++;\n\t\t\tif(suc==c)return i-suc+1;\n\t\t}\n\t\telse suc=0;\n\t}\n\treturn -1;\n}\nvoid in(int c,int p,int t){\n\tint n=c%5==1?5:2;\n\trep(i,n)seat[i+p]=c;\n\trm[5*c+17*(c%2)+3*(c%3)+19].push_back(c);\n\tresult[c]=t-5*c;\n\tq.pop();\n}\nvoid remove(int c){\n\trep(i,17)if(seat[i]==c)seat[i]=-1;\n}\nint main(){\n\trep(i,17)seat[i]=-1;\n\t\n\tfor(int t=0;t<=45||!q.empty();t++){\n\t\tif(t%5==0)q.push(t/5);\n\t\trep(i,rm[t].size())remove(rm[t][i]);\n\t\tif(q.empty())continue;\n\t\tfor(int p=ck(q.front());p>=0&&!q.empty();p=ck(q.front()))in(q.front(),p,t);\n\t}\n\t\n\tint n;\n\twhile(cin>>n)cout<<result[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nclass data{\npublic:\n\tint num,t;\n\tdata(int n,int tt){\n\t\tnum=n;\n\t\tt=tt;\n\t}\n};\n\nint n;\nint fie[17];\nint wait[100];\n\nint enter(int x){\n\tint f=0,cnt=0;\n\tfor(int i=0;i<17;i++){\n\t\tif(fie[i]==-1){\n\t\t\tif(cnt==0)f=i;\n\t\t\tcnt++;\n\t\t\tif(cnt==x)return f;\n\t\t}else cnt=0;\n\t}\n\treturn -1;\n}\n\nint main(void){\n\tqueue<data> que;\n\tmemset(fie,-1,sizeof(fie));\n\tmemset(wait,-1,sizeof(wait));\n\tint i=0;\n\twhile(wait[99]==-1){\n\t\tif(i%5==0 && i<500){\n\t\t\tque.push(data(i/5,i));\n\t\t}\n\t\tfor(int j=0;j<17;j++){\n\t\t\tif(fie[j]==i)fie[j]=-1;\n\t\t}\n\t\twhile(1){\n\t\t\tif(que.empty())break;\n\t\t\tdata next=que.front();\n\t\t\tint number;\n\t\t\tif(next.num%5==1)number=5;\n\t\t\telse number=2;\n\t\t\tint from=enter(number);\n\t\t\tif(from>=0){\n\t\t\t\twait[next.num]=i-next.t;\n\t\t\t\tfor(int j=0;j<number;j++){\n\t\t\t\t\tfie[from+j]=i+17*(next.num%2)+3*(next.num%3)+19;\n\t\t\t\t}\n\t\t\t\tque.pop();\n\t\t\t}else break;\n\t\t}\n\t\ti++;\n\t}\n\twhile(~scanf(\"%d\",&n)){\n\t\tprintf(\"%d\\n\",wait[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int, P > PP;\nint n,ans[100];\nPP t[500];\nPP u[500];\nint ts,te,us,ue;\nint state[17];\n\nvoid t_in(PP x){\n  t[te]=x;\n  te++;\n}\nvoid u_in(PP x){\n  u[ue]=x;\n  ue++;\n}\nPP t_out(){\n  ts++;\n  return t[ts-1];\n}\nPP u_out(){\n  us++;\n  return u[us-1];\n}\n\n\nint u_check(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\n\nint u_ins(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n\n  \n  u_out();\n  return a;\n}\nint u_check2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\nvoid u_ins2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n}\n\nint main(){\n  ts=us=te=ue=0;\n\n  for(int i=0;i<100;i++)ans[i]=0;\n  for(int i=0;i<17;i++)state[i]=-1;\n\n  for(int i=0;i<100;i++){\n    t_in(PP(5*i,P(1,i)));\n  }\n\n  sort(t+ts,t+te);\n\n  PP x,y;\n  int flg,z;\n  while(!(ts==te)){\n\n    /*\n    for(int i=0;i<17;i++)printf(\"%3d \",state[i]);\n    cout<<endl;\n\n    for(int i=us;i<ue;i++)printf(\"%3d \",u[i].second.second);\n    cout<<endl;\n    */\n    \n    sort(t+ts,t+te);\n    y=x;\n    x=t_out();\n\n    //cout<<x.first<<' '<<x.second.first<<' '<<x.second.second<<endl;\n    for(int i=us;i<ue;i++)ans[u[i].second.second]+=(x.first-y.first);\n\n    if(x.second.first==0){\n      for(int i=0;i<17;i++)if(state[i]==x.second.second)state[i]=-1;\n      while(1){\n\tif(us==ue)break;\n\tflg=u_check();\n\tif(flg==0)break;\n\tz=u_ins();\n\t\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n            \n    }else if(x.second.first==1){\n      flg=u_check2(x);\n\n      if(flg==0||us!=ue){\n\tu_in(x);\n      }else{\n\tu_ins2(x);\n\n\tz=x.second.second;\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n    }//if\n  }\n\n  \n  //cout<<te<<endl;\n  while(cin>>n){\n    for(int i=n;i<=n;i++)cout<<ans[i]<<' ';\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\n#define f(a)(a%5==1?5:2)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint c[17];\nint cnt[100];\nint main() {\n\tmemset(c, -1, sizeof(c));\n\tpriority_queue<P, vector<P>, greater<>>p;\n\tqueue<int>que;\n\tint time = 0;\n\twhile (1) {\n\t\tif (que.empty() && time / 5 + 1 >= 100)break;\n\t\tif (time % 5 == 0 && time / 5 < 100)que.push(time / 5);\n\t\twhile (!p.empty() && p.top().first <= time) {\n\t\t\treplace(c, c + 17, p.top().second, -1);\n\t\t\tp.pop();\n\t\t}\n\t\tbool flag = true;\n\t\twhile (flag && !que.empty()) {\n\t\t\tint id = que.front();\n\t\t\tflag = false;\n\t\t\trep(i, 18 - f(id)) {\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, f(id)) {\n\t\t\t\t\tif (~c[i + j])ok = false;\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\trep(j, f(id))c[i + j] = id; que.pop();\n\t\t\t\t\tcnt[id] = time - 5 * id;\n\t\t\t\t\tp.push(P(time + 17 * (id % 2) + 3 * (id % 3) + 19, id));\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INT_MAX;\n\t\tif (!p.empty())Min = p.top().first;\n\t\tMin = min(Min, (time / 5 + 1)*5);\n\t\ttime = Min;\n\t}\n\tint n; while (~scanf(\"%d\", &n))printf(\"%d\\n\", cnt[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int N = 100;\nconst int T = 17;\n\nvoid check(int cnt[N], P c[T], queue<int> &q, int &l, int &t){\n  REP(i, T){\n    if(c[i].first == -1) continue;\n    int n = c[i].first;\n    if(c[i].second + (17 * (n % 2) + 3 * (n % 3) + 19) == t){\n      l = max(l, c[i].first);\n      c[i] = P(-1, -1);\n    }\n  }\n  while(!q.empty()){\n    int n = q.front();\n    int m = (n % 5 == 1 ? 5 : 2);\n    bool ff = false;\n    REP(i, T - m){\n      bool f = true;\n      REP(j, m) if(c[i + j].first != -1) f = false;\n      if(f){\n        cnt[n] = t - n * 5;\n        REP(j, m) c[i + j] = P(n, t);\n        ff = true;\n        q.pop();\n        break;\n      }\n    }\n    if(!ff) break;\n  }\n}\n\nint main() {\n  int cnt[N], l = -1, t = 0;\n  P c[T];\n  memset(cnt, 0, sizeof(cnt));\n  REP(i, T) c[i] = P(-1, -1);\n  queue<int> q;\n  while(l < N){\n    if(t % 5 == 0) q.push(t / 5);\n    check(cnt, c, q, l, t);\n    ++t;\n  }\n  int n;\n  while(cin >>n) cout <<cnt[n] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int ans[100]={0};\n  vector<int>seki(17,-1);\n  vector<int>machi;\n  rep(i,100000){\n    //cout<<machi.size()<<endl;\n    if(i>510&&machi.size()==0)break;\n    if(i<100&&i%5==0)machi.pb(i/5);\n    rep(j,7)\n      if(seki[j]==1)seki[j]=-1;\n      else if(seki[j]!=-1)seki[j]--;\n    while(1){\n      if(machi.size()==0)break;\n      int n;\n      if(machi[0]%5==1)n=5;\n      else n=2;\n      bool han=false;\n      rep(j,17-n+1){\n\tbool h=true;\n\trep(k,n)if(seki[k+j]!=-1){h=false;break;}\n\tif(h){\n\t  han=true;\n\t  ans[machi[0]]=i-machi[0]*5;\n\t  rep(k,n)seki[k+j]=17*(machi[0]%2)+3*(machi[0]%3)+19;\n\t  machi.erase(machi.begin());\n\t  break;\n\t}\n\t//cout<<i<<endl;\n      }\n      if(han==false)break;\n    }\n  }\n  int in;\n  while(cin>>in)cout<<ans[in]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\nint c[100][2], res[101], table[17];\nint main(){\n  rep(i, 100){\n    if(i%5==1) c[i][0] = 5;\n    else c[i][0] = 2;\n    c[i][1] = 17 * (i%2) + 3 * (i%3) + 19;\n  }\n  rep(i, 17) table[i] = 0;\n  int p = 0;\n  rep(k, 1000){\n    rep(i, 17) if(table[i] > 0) table[i]--;\n\n    while(p <= k / 5){\n      int tmp = p;\n      if(c[p][0] == 2){\n\trep(i, 16){\n\t  if(table[i]==0&&table[i+1]==0){\n\t    table[i] = table[i+1] = c[p][1];\n\t    res[p] = k- p * 5;\n\t    p++;\n\t    break;\n\t  }\n\t}\n      }else if(c[p][0] == 5){\n\trep(i, 13){\n\t  if(table[i]==0&&table[i+1]==0&&table[i+2]==0&&table[i+3]==0&&table[i+4]==0){\n\t    table[i]=table[i+1]=table[i+2]=table[i+3]=table[i+4]=c[p][1];\n\t    res[p] = k - p  *5;\n\t    p++;\n\t    break;\n\t  }\n\t}\n      }\n      if(tmp == p) break;\n    }\n  }\n  \n  int n;\n  while(~scanf(\"%d\", &n))\n    printf(\"%d\\n\", res[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 100\n  \nstruct S {\n    int g, t;\n    S(int g, int t) : g(g), t(t) {}\n};\n  \nint arr[MAX];\nvector<S> seat;\n  \nint minute(int i)\n{\n    return 17*(i%2) + 3*(i%3) + 19;\n}\n  \nvoid make()\n{\n    int g = 0;\n    for (int i = 0; i < 17; i++) {\n\tseat.push_back(S(-1, -1));\n    }\n    vector<S> _wait;\n    for (int i = 0; i < 570; i++) {\n\tint size = _wait.size();\n  \n\tif (size) {\n\t    for (int j = 0; j < size; j++) {\n\t\t_wait[j].t++;\n\t    }\n\t}\n     \n\tfor (int j = 0; j < 17; j++) {\n\t    if (seat[j].g != -1) {\n\t\tseat[j].t--;\n\t\tif (seat[j].t == 0) {\n\t\t    seat[j].g = seat[j].t = -1;\n\t\t}\n\t    }\n\t}\n   \n\tif (size) {\n\t    for (int j = 0; j < size; j++) {\n\t\tint n = _wait[j].g;\n\t\tint cnt, c;\n\t\tbool flg = false;\n\t\tif (n % 5 == 1) cnt = c = 5;\n\t\telse cnt = c = 2;\n\t\tfor (int k = 0; k < 17; k++) {\n\t\t    if (seat[k].g == -1) cnt--;\n\t\t    else cnt = c;\n\t\t    if (cnt == 0) {\n\t\t\tfor (int l = k-c+1; l <= k; l++) {\n\t\t\t    seat[l].g = n;\n\t\t\t    seat[l].t = minute(n);\n\t\t\t}\n\t\t\tarr[n] = _wait[j].t;\n\t\t\tflg = true;\n\t\t\tj--;\n\t\t\t_wait.erase(_wait.begin());\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!flg || !_wait.size()) break;\n\t    }\n\t    size = _wait.size();\n\t}\n\tif (g == 100) continue;\n\tif (i % 5 == 0) {\n\t    int cnt, c;\n\t    bool flg = false;\n\t    if (size) {\n\t\t_wait.push_back(S(g, 0));\n\t\tg++;\n\t\tcontinue;\n\t    }\n\t    if (g % 5 == 1) cnt = c = 5;\n\t    else cnt = c = 2;\n        \n\t    for (int j = 0; j < 17; j++) {\n\t\tif (seat[j].g == -1) cnt--;\n\t\telse cnt = c;\n\t\tif (cnt == 0) {\n\t\t    flg = true;\n\t\t    for (int k = j-c+1; k <= j; k++) {\n\t\t\tseat[k].g = seat[k].g = g;\n\t\t\tseat[k].t = seat[k].t = minute(g);\n\t\t    }\n\t\t    arr[g] = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (!flg) {\n\t\t_wait.push_back(S(g,0));\n\t    }\n\t    g++;\n\t}\n    }\n}\n  \nint main()\n{\n    int N;\n    make();\n    while (cin >> N) {\n\tcout << arr[N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17];\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n//aaa:\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\t\tbool can_sit;\n\t\t\t\t\tbool sitted = false;\n\t\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcan_sit = true;\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (can_sit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\t\t//goto aaa;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!sitted) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reps(v, f, l) for (int v = (f), v##_ = (l); v < v##_; ++v)\n#define rep(v, n) reps(v, 0, n)\n#define lep(v, n) reps(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\ntemplate<typename T> void show(T& a, char del='\\n', char last='\\n'){ rep(i, a.size() - 1) cout << a[i] << del; cout << a[a.size() - 1] << last; }\n\nstruct Table {\n  Table(int len) : table(len, 0) { RLE(); }\n  void RLE(){\n    rep(i, table.size()){\n      if (table[i] < 0) continue;\n      int count = 0;\n      reps(j, i, table.size()){\n        if (table[j] >= 0) count++;\n        else break;\n      }\n      table[i] = count;\n    }\n  }\n  bool insert(int cid){\n    int len = cid % 5 == 1 ? 5 : 2;\n    int pos = -1;\n    rep(i, table.size()){\n      if (table[i] < 0) continue;\n      if (table[i] >= len){\n        pos = i;\n        break;\n      }\n    }\n    if (pos == -1) return false;\n    rep(i, len){\n      table[pos + i] = ~cid;\n    }\n    return true;\n  }\n  void remove(int cid){\n    rep(i, table.size()){\n      if (cid == ~table[i]) table[i] = 0;\n    }\n    RLE();\n  }\n  vector<int> table;\n};\n\nint main()\n{\n  Table table(17);\n  priority_queue<pair<int, int> > event;\n  queue<pair<int, int> > wait;\n  int ans[100] = {};\n  rep(i, 100){\n    int in_time = i * 5;\n    event.push(make_pair(-in_time, i * 2));\n  }\n  while (!event.empty()){\n    int now_time = -event.top().first;\n    int cid = event.top().second;\n    event.pop();\n    bool is_in = cid % 2 == 0;\n    cid /= 2;\n    if (is_in){\n      wait.push(make_pair(cid, now_time));\n    }\n    else {\n      table.remove(cid);\n    }\n    while (!wait.empty()){\n      int wc = wait.front().first;\n      int wt = wait.front().second;\n      if (!table.insert(wc)) break;\n      ans[wc] = now_time - wt;\n      event.push(make_pair(-(now_time + (17 * (wc % 2)) + (3 * (wc % 3)) + 19), wc * 2 + 1));\n      wait.pop();\n    }\n  }\n  int n;\n  while (~scanf(\"%d\", &n)){\n    printf(\"%d\\n\", ans[n]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct G{\n  int group, people, now, time;\n};\n\nint main(){\n  int minutes[100];\n  int chair[17]; //あーじゅうななせきあった！！\n  fill_n( chair, 17, 0);\n\n  queue< G > mati;\n\n  for(int i = 0; i < 10000; i++){\n   if(i % 5 == 0 && i / 5 < 100){ //group leave\n      int group = i / 5;\n      mati.push((G){ group, group % 5 == 1 ? 5 : 2, i, 17 * (group % 2) + 3 * (group % 3) + 19});\n    }\n\n\n    while(!mati.empty()){\n      G& g = mati.front();\n      int count = 0, pos = -1;\n      for(int j = 0; j < 17; j++){\n        if(!chair[j]){\n          count++;\n          if(count == g.people){\n            pos = j - g.people + 1;\n            break;\n          }\n        }else{\n          count = 0;\n        }\n      }\n      if(pos != -1){\n        minutes[g.group] = i - g.now;\n        for(int j = pos; j < pos + g.people; j++){\n          chair[j] = g.time;\n        }\n        mati.pop();\n      } else {\n        break;\n      }\n    }\n\n    for(int j = 0; j < 16; j++){\n      if(chair[j] > 0) chair[j]--;\n    }\n\n  }\n  int n;\n  while(cin >> n){\n    cout << minutes[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Group{\n\tint indx, num;\n\tGroup(){}\n\tGroup(int indx_c, int num_c){\n\t\tindx = indx_c; num = num_c;\n\t}\n};\n\nint main(){\n\tint table[17] = {}, ans[100];\n\tqueue<Group> q;\n\tfor(int t = 0;; t++){\n\t\tfor(int i = 0; i < 17; i++) table[i]--;\n\t\t\n\t\tif(t%5 == 0 && t/5 < 100){\n\t\t\tq.push( Group(t/5, ( (t/5)%5 == 1 ) ? 5 : 2 ) );\n\t\t}\n\t\tif( t/5 >= 100 && q.empty() ) break;\n\t\t\n\t\twhile( !q.empty() ){\n\t\t\n\t\tGroup front_group = q.front();\n\t\tint space_cnt = 0;\n\t\tbool was_pop = false;\n\t\tfor(int i = 0; i < 17; i++){\n\t\t\tif( table[i] <= 0) space_cnt++;\n\t\t\telse space_cnt = 0;\n\t\t\tif(space_cnt >= front_group.num){\n\t\t\t\tfor(int j = 0; j < space_cnt; j++){\n\t\t\t\t\ttable[i-j] = 17*(front_group.indx%2)+3*(front_group.indx%3)+19;\n\t\t\t\t}\n\t\t\t\tans[front_group.indx] = t - front_group.indx*5;\n\t\t\t\tq.pop();\n\t\t\t\twas_pop = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(was_pop == false) break;\n\t\t}\n\t}\n\t\n\tint N;\n\twhile(cin >> N){\n\t\tprintf(\"%d\\n\", ans[N]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint ans[110], d[18];\n\nint calc(int t, int m){\n\tvi v(18, 0);\n\tfor(int i = 16; i >= 0; i--){\n\t\tif(d[i] <= t) v[i] = v[i+1]+1;\n\t}\n\tauto it = max_element(all(v));\n\tif(*it < m) return -1;\n\treturn it-v.begin();\n}\n\nint main(){\n\tint n, t, idx;\n\tfor(int i = 0; i < 100; i++){\n\t\tn = i%5==1?5:2;\n\t\tt = max(t,i*5);\n\t\twhile(1){\n\t\t\tidx = calc(t, n);\n\t\t\tif(idx < 0) {\n\t\t\t\tt++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans[i] = t - i*5;\n\t\t\tfor(int j = 0; j < n; j++) d[idx+j] = t + 17*(i%2)+3*(i%3)+19;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(cin>>n){\n\t\tprintf(\"%d\\n\", ans[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 100\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS+1] = {-1,};\n\tint peoples[GROUPS] = {0,};\n\tint waiting[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS+1; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\twaiting[i] = -i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\tnow = 1;\n\tsheets[0] = sheets[1] = 0;\n\tfor(int t = 0; t < 2000; ++t){\n\t\t\n\t\tfor(int i = 0; i < GROUPS; ++i){\n\t\t\t++waiting[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\tif( eating[sheets[i]] == 0 )\n\t\t\t\t\tsheets[i] = -1;\n\t\t\t\telse{\n\t\t\t\t\t--eating[sheets[i]];\n\t\t\t\t\tfor(;sheets[i+1]==sheets[i];++i)0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tcout << \"t=\"<<t<<\":\\t\\t\";\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tcout << (char)(sheets[i]==-1?'_':sheets[i]+'0');\n\t\t}\n\t\tcout << '\\n';\n\t\t*/\n\t\t\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tint cont = 0;\n\t\t\t\tif( sheets[i] < 0 ){\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] < 0 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( cont >= peoples[ now ] && waiting[ now ] >= 0 ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\tans[now] = waiting[now]-1<0?0:waiting[now]-1;\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n < 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\twhile(c>=5){return 1;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nint main(){\n\tint m = 17;\n\tqueue<int> q;\n\tvector<int> v(m,-1);\n\tset<Pii> st;\n\tint t = 0;\n\tvector<int> ans(100);\n\n\twhile(t < 1000 || !q.empty()){\n\t\tbool change = false;\n\t\tif((t % 5 == 0) && (t / 5 < 100)){\n\t\t\tint i = t/5;\n\t\t\tq.push(i);\n\t\t\tans[i] = t;\n\t\t\tchange = true;\n\t\t}\n\n\t\twhile(!st.empty() && (*(st.begin())).first == t){\n\t\t\tint c = (*(st.begin())).second;\n\t\t\tst.erase(st.begin());\n\t\t\tFOR(i,m) if(v[i] == c) v[i] = -1;\n\t\t\tchange = true;\n\t\t}\n\n\t\tif(change) while(!q.empty()){\n\t\t\tint c = q.front();\n\t\t\tint l = (c%5 == 1) ? 5 : 2;\n\t\t\tint cnt = 0;\n\t\t\tint start = -1;\n\t\t\tFOR(i,m){\n\t\t\t\tif(v[i] == -1) cnt++;\n\t\t\t\telse cnt = 0;\n\t\t\t\tif(cnt == l){\n\t\t\t\t\tstart = i - l + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(start != -1){\n\t\t\t\tq.pop();\n\t\t\t\tst.insert(Pii(17*(c%2)+3*(c%3)+19 + t,c));\n\t\t\t\tans[c] = t - ans[c];\n\t\t\t\tFOR(i,l) v[i+start] = c;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tt++;\n\t}\n\n\tint n;\n\twhile(cin>>n){\n\t\tcout << ans[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n#define\tEMPTY\t-1\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nint Numbers(int groupid){\n\treturn groupid%5==1?5:2;\n}\n\nint MealTime(int groupid){\n\treturn 17*(groupid%2)+3*(groupid%3)+19;\n}\n\nint main()\n{\n\tint counter[17],elapse[17],mealtime[17];\n\tqueue<pii> qu;\t// <numbers in a group, group id>\n\n\tfor(int i=0;i<17;i++)\tcounter[i]=EMPTY;\n\n\tint waittime[100];\n\tfor(int t=0;t<589;t++){\n\t\t// enqueue\n\t\tif(t%5==0&&t<500){\n\t\t\tqu.push(mp(Numbers(t/5),t/5));\n\t\t}\n\n\t\t// going\n\t\tfor(int i=0;i<17;i++){\n\t\t\tif(counter[i]!=EMPTY){\n\t\t\t\telapse[i]++;\n\t\t\t\tif(elapse[i]==mealtime[i])\tcounter[i]=EMPTY;\n\t\t\t}\n\t\t}\n\n\t\t// coming\n\t\tbool came;\n\t\tdo{\n\t\t\tcame=false;\n\t\t\tif(qu.empty())\tbreak;\n\n\t\t\tpii next=qu.front();\n\t\t\tfor(int i=0,cnt=0;i<17;i++){\n\t\t\t\tif(counter[i]==EMPTY)\tcnt++;\n\t\t\t\telse\t\t\t\t\tcnt=0;\n\n\t\t\t\tif(cnt==next.first){\n\t\t\t\t\tint mt=MealTime(next.second);\n\t\t\t\t\tfor(int j=i;j>i-next.first;j--){\n\t\t\t\t\t\tcounter[j]=next.second;\n\t\t\t\t\t\tmealtime[j]=MealTime(next.second);\n\t\t\t\t\t\telapse[j]=0;\n\t\t\t\t\t}\n\t\t\t\t\twaittime[next.second]=t-5*next.second;\n\t\t\t\t\tcame=true;\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(came);\n\t}\n\n\tfor(int n;~scanf(\"%d\",&n);)\tprintf(\"%d\\n\",waittime[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint t[110];\nint now[20];\nint p[110];\nint q[110];\nint r[110];\nint main(){\n\tfor(int i=0;i<100;i++){\n\t\tp[i]=i*5;\n\t\tif(i%5==1)q[i]=5;\n\t\telse q[i]=2;\n\t\tr[i]=17*(i%2)+3*(i%3)+19;\n\t}\n\tint at=0;\n\tfor(int i=0;i<17;i++)now[i]=-1;\n\tfor(int i=0;i<5000;i++){\n\t\tfor(int j=0;j<at;j++){\n\t\t\tif(i==t[j]+r[j])for(int k=0;k<17;k++)if(now[k]==j)now[k]=-1;\n\t\t}\n\t\twhile(at<=min(99,i/5)){\n\t\t\tint len=0;\n\t\t\tbool ok=false;\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tif(!~now[j])len++;\n\t\t\t\telse len=0;\n\t\t\t\tif(len==q[at]){\n\t\t\t\t\tfor(int k=j-q[at]+1;k<=j;k++)now[k]=at;\n\t\t\t\t\tok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)t[at++]=i;\n\t\t\telse break;\n\t\t}\n\t}int a;\n\twhile(~scanf(\"%d\",&a)){\n\t\tprintf(\"%d\\n\",t[a]-a*5);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for(int i = 0; i < n; i++)\nint nums[100];\nint c[17];\n\nbool get_chair(int n, int x){\n  rep(i, 17 - n + 1){\n    bool ok = true;\n    rep(j, n){\n      if(c[i+j] > 0) ok = false;\n    }\n    if(ok){\n      rep(j, n) c[i+j] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  int t = 0;\n  fill(c, c + 17, 0);\n  queue<int> que;\n  while(t < 500 || !que.empty()){\n\n    if(t < 500 && t % 5 == 0){\n      que.push(t/5);\n    \n    }\n\n    while(!que.empty()){\n      int a = que.front();\n\n      if(a % 5 == 1){\n\tif(get_chair(5, (a % 2) * 17 + (a % 3) * 3 + 19)){\n\t  nums[a] = t - a * 5;\n\t  que.pop();\n\t}else break;\n      }else{\n\tif(get_chair(2, (a % 2) * 17 + (a % 3) * 3 + 19)){\n\t  nums[a] = t - a * 5;\n\t  que.pop();\n\t}else break;\n      }\n    }\n\n    rep(i, 17) if(c[i] > 0) c[i]--;\n    t++;\n  }\n\n  while(cin >> n){\n    cout << nums[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\t\n\twhile(cin >> n){\n\t\tif(n >= 50)c++;\n\t\tcout << stop[n] << endl;\n\t}\n\twhile(c>=6){return 1;};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\nusing namespace std;\n\nint main()\n{\n\tint table[18];\n\tint wait[100];\n\tmemset(table, -1, sizeof(table));\n\tmemset(wait, 0, sizeof(wait));\n\ttable[17] = 1;\n\n\tint front = 0;\n\tint len = 2;\n\tfor (int i = 0; front < 100; ++i)\n\t{\n\t\twhile (i >= front*5 && front < 100)\n\t\t{\n\t\t\tint l = 0;\n\t\t\tint p = -1;\n\t\t\tfor (int j = 0; p == -1 && j < 17 + 1; ++j)\n\t\t\t{\n\t\t\t\tif (table[j] <= 0)\n\t\t\t\t\t++l;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (l >= len)\n\t\t\t\t\t\tp = j - l;\n\t\t\t\t\tl = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p != -1)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < len; ++j)\n\t\t\t\t\ttable[p+j] = 17*(front%2) + 3*(front%3) + 19;\n\t\t\t\twait[front] = i - front*5;\n\t\t\t\tlen = ++front % 5 == 1 ? 5 : 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (int j = 0; j < 17; ++j)\n\t\t\t--table[j];\n\t}\n\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t\tprintf(\"%d\\n\", wait[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tmap<int,vector<int> > escape;\n\n\tint data[100];\n\tint field[17];\n\tfill(field,field+17,-1);\n\n\tqueue<int> waitQueue;\n\tint group=0;\n\tint time=0;\n\t\n\tvector<int> c;\n\twhile(cin>>n){\n\t\tc.push_back(n);\n\t}\n\t\n\tfor(int i=0;;i++){\n\t\ttime=i;\n\t\tif(i%5==0){\n\t\t\twaitQueue.push(group);\n\t\t\tgroup++;\n\t\t}\n\t\t// Ü¸ÔØêO[vðÈ©çÇ©·\n\t\tfor(map<int,vector<int> >::iterator it = escape.begin(); it != escape.end(); it++){\n\t\t\tif(it->first==i){\n\t\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\t\tfor(int k = 0; k< it->second.size(); k++){\n\t\t\t\t\t\tif(field[j]==it->second[k]){\n\t\t\t\t\t\t\tfield[j]=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tit->second.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool f=false;\n\t\tint prvCand=-1;\n\t\t// ·íêé¾¯·íç¹é\n\t\twhile(1){\n\t\t\tif(waitQueue.size()==0)\n\t\t\t\tbreak;\n\t\t\t// ¡ñÀç¹él\n\t\t\tint cand=waitQueue.front();\n\t\t\tif(prvCand==cand)\n\t\t\t\tbreak;\n\t\t\tint s;\n\t\t\tint mergen=-1;\n\t\t\tfor(int j = 0; j < 17; j++){\n\t\t\t\tif(field[j]==-1&&j!=16){\n\t\t\t\t\tif(mergen==-1){\n\t\t\t\t\t\ts=j;\n\t\t\t\t\t\tmergen=1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmergen++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j==16){\n\t\t\t\t\t\tif(field[j]==-1){\n\t\t\t\t\t\t\tmergen++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(cand%5==1){\n\t\t\t\t\t\tif(mergen>=5){\n\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\tfor(int k = s; k < 5+s; k++){\n\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\t\t\t\t\t\t\t\tcout<<cand<<endl;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(mergen>=2){\n\t\t\t\t\t\t\t// ·íç¹é\n\t\t\t\t\t\t\tfor(int k = s; k < 2+s; k++){\n\t\t\t\t\t\t\t\tfield[k]=cand;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdata[cand]=time-cand*5;\n\t\t\t\t\t\t\twaitQueue.pop();\n\t\t\t\t\t\t\tescape[17*(cand%2)+3*(cand%3)+19+i].push_back(cand);\n\t\t\t\t\t\t\tif(cand==99){\n\t\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmergen=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t\tprvCand=cand;\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\t\n\t}\n\tfor(int i = 0; i < c.size(); i++){\n\t\t// ±±ÅÜ¿Ôð\\¦\n\t\tcout<<data[c[i]]<<endl;\n\t}\n\t//\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tvint ans(110,0);\n\tqueue<int> q2,q5;\n\tint cnt=0;\n\tvint seki(17,0);\n\tvint vis(110,-1);\n\tfor(int i=0;;++i){\n\t\trep(j,17){\n\t\t\tif(seki[j]) seki[j]--;\n\t\t}\n\t\tif(i%5==0&&cnt<100){\n\t\t\tcnt++;\n\t\t}\n\t\tbool ff=false;\n\t\trep(j,cnt){\n\t\t\tif(vis[j]==-1){\n\t\t\t\tff=true;\n\t\t\t\tif(j%5==1){\n\t\t\t\t\trep(k,17-4){\n\t\t\t\t\t\tif(seki[k]==0&&seki[k+1]==0&&seki[k+2]==0&&seki[k+3]==0&&seki[k+4]==0){\n\t\t\t\t\t\t\tseki[k]=seki[k+1]=seki[k+2]=seki[k+3]=seki[k+4]=17*(j%2)+3*(j%3)+19;\n\t\t\t\t\t\t\tvis[j]=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbool f=false;\n\t\t\t\t\trep(k,16){\n\t\t\t\t\t\tif(seki[k]==0&&seki[k+1]==0){\n\t\t\t\t\t\t\tseki[k]=seki[k+1]=17*(j%2)+3*(j%3)+19;\n\t\t\t\t\t\t\tf=true;\n\t\t\t\t\t\t\tvis[j]=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!f) break;\n\t\t\t\t}\n\t\t\t\tif(vis[j]==-1) break;\n\t\t\t}\n\t\t}\n\t\tif(cnt==100&&!ff) break;\n\t}\n\t// rep(i,10){\n\t// \tcout<<vis[i]<<endl;\n\t// }\n\tint n;\n\twhile(cin>>n){\n\t\tcout<<vis[n]-n*5<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n//#define int long long\nusing namespace std;\n\nstruct Event\n{\n\tint time;\n\tstring action;\n\tint num;\n\tint ninzu;\n\n\tEvent(int ptime, string paction, int pnum, int pninzu) : time(ptime), action(paction), num(pnum), ninzu(pninzu) {}\n\n\tbool operator < (const Event& right) const {\n\t\treturn time >= right.time;\n\t}\n};\n\nint seki[17] = {-1};\nint come_time[100];\nint enter_time[100];\n\npriority_queue<Event> events;\n//         num, ninzu\nqueue<pair<int, int> > gyoretsu;\n\nsigned main()\n{\n\trep(i,17) seki[i] = -1;\n\trep(i,100)\n\t{\n\t\tcome_time[i] = 5 * i;\n\t\tevents.push(Event(come_time[i], \"come\", i, (i % 5 == 1 ? 5 : 2)));\n\t}\n\n\twhile (events.size() > 0)\n\t{\n\t\tEvent e = events.top(); events.pop();\n\n\t\t//cout << \"Event time=\" << e.time << \" action=\" << e.action << \" num=\" << e.num << \" ninzu=\" << e.ninzu << endl;\n\n\t\t//cout << \"time = \" << e.time << endl;\n\t\tif (e.action == \"come\")\n\t\t{\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbool can_sit;\n\t\t\t\tbool sitted = false;\n\t\t\t\tfor (int i=0; i <= 17 - e.ninzu; i++)\n\t\t\t\t{\n\t\t\t\t\tcan_sit = true;\n\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (can_sit)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int j=0; j<e.ninzu; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseki[i+j] = e.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter_time[e.num] = e.time;\n\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\tevents.push(Event(e.time + (17 * (e.num % 2) + 3 * (e.num % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!sitted)\n\t\t\t\t{\n\t\t\t\t\tgyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tcome_time[e.num] = e.time;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (e.action == \"leave\")\n\t\t{\n\t\t\trep(i,17)\n\t\t\t{\n\t\t\t\tif (seki[i] == e.num) seki[i] = -1;\n\t\t\t}\n\n\t\t\tif (gyoretsu.size() > 0)\n\t\t\t{\n//aaa:\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\t//gyoretsu.push(pair<int, int>(e.num, e.ninzu));\n\t\t\t\t\tpair<int, int> a = gyoretsu.front();\n\n\t\t\t\t\tbool can_sit;\n\t\t\t\t\tbool sitted = false;\n\t\t\t\t\tfor (int i=0; i <= 17 - a.second; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcan_sit = true;\n\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (seki[i+j] != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcan_sit = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (can_sit)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j=0; j<a.second; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tseki[i+j] = a.first;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tenter_time[a.first] = e.time;\n\t\t\t\t\t\t\tsitted = true;\n\t\t\t\t\t\t\tevents.push(Event(e.time + (17 * (a.first % 2) + 3 * (a.first % 3) + 19), \"leave\", e.num, e.ninzu));\n\t\t\t\t\t\t\tgyoretsu.pop();\n\t\t\t\t\t\t\t//goto aaa;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!sitted) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,17) printf(\"% 3d\", seki[i]);\n\t\t//printf(\"\\n\");\n\t}\n\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tcout << enter_time[n] - come_time[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint a[16], c[100];\npriority_queue<pair<int,int> > b;\n\nint can_sit(int n) {\n  int p = 0;\n  for (int i=0; i<16; i++) {\n    if (a[i] == -1) {\n      ++p;\n    } else {\n      p = 0;\n    }\n    if (p == n) {\n      return i-n+1;\n    }\n  }\n  return -1;\n}\n\nint sit(int id, int stt, int n) {\n  for (int i=0; i<n; i++) {\n    a[i+stt] = id;\n  }\n}\n\nint stand(int id) {\n  for (int i=0; i<16; i++) {\n    if (a[i] == id) {\n      a[i] = -1;\n    }\n  }\n}\n\nint main() {\n  int t, p, q, r;\n  for (int i=0; i<16; i++) a[i] = -1;\n  t = 0;\n  p = 0;\n  while (1) {\n    while (t >= 5*p && p<100) {\n      q = (p%5==1) ? 5 : 2;\n      r = can_sit(q);\n      if (r != -1) {\n        c[p] = t - 5*p;\n        sit(p, r, q);\n        b.push(pair<int, int>(-(t + 17*(p%2) + 3*(p%3) + 19), p));\n        p++;\n      } else {\n        break;\n      }\n    }\n    if (-b.top().first <= ((t/5)+1)*5) {\n      t = -b.top().first;\n      stand(b.top().second);\n      b.pop();\n    } else {\n      t = ((t/5)+1)*5;\n    }\n    if (p==100 && b.empty()) {\n      break;\n    }\n  }\n\n  while (cin >> t) {\n    cout << c[t] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\n\nint main(){\n\tint d[17];\n\tint n[100]={0};\n\tint cnt=0,t=0;\n\tqueue<int> q;\n\trep(i,17)d[i]=0;\n\tfor(;cnt<100;t++){\n\t\trep(i,17)if(d[i]>0)d[i]--;\n\t\tif(t%5==0 && t<500)q.push(t/5);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();\n\t\t\tint num=v%5==1?5:2;\n\t\t\tint g=0;\n\t\t\trep(j,17-num){\n\t\t\t\tif(d[j]<1 && !g){\n\t\t\t\t\tg=1;\n\t\t\t\t\treps(k,1,num-1){\n\t\t\t\t\t\tif(d[j+k]>0)g=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(g){\n\t\t\t\t\t\trep(k,num)d[j+k]=17*(v%2)+3*(v%3)+19;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!g)break;\n\t\t\tq.pop();\n\t\t\tn[v]=t-v*5;\n\t\t\tcnt++;\n\t\t}\n\t}\n\twhile(~scanf(\"%d\",&t))printf(\"%d\\n\",n[t]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define SHEETS 17\n#define GROUPS 130\n\nint main()\n{\n\tint ans[GROUPS] = {0,};\n\tint now;\n\tint sheets[SHEETS];\n\tint peoples[GROUPS] = {0,};\n\tint arrive[GROUPS] = {0,};\n\tint eating[GROUPS] = {0,};\n\n\tfor(int i = 0; i < SHEETS; ++i){\n\t\tsheets[i] = -1;\n\t}\n\tfor(int i = 0; i < GROUPS; ++i)\n\t{\n\t\tarrive[i] = i*5;\n\t\tpeoples[i] = i%5==1?5:2;\n\t\teating[i] = 17*(i%2)+3*(i%3)+19;\n\t}\n\t\n\tnow = 0;\n\tfor(int t = 0; t < 800; ++t){\n\n\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\tif( sheets[i] >= 0 ){\n\t\t\t\t--eating[sheets[i]];\n\t\t\t\tif( eating[sheets[i]] == 0 ){\n\t\t\t\t\tfor(;sheets[i]==sheets[i+1]&&i<SHEETS-1;++i)\n\t\t\t\t\t\tsheets[i] = -1;\n\t\t\t\t\tsheets[i]=-1;\n\t\t\t\t\t/*\n\t\t\t\t\tcout << \"t=\" << t <<\":\\t\";\n\t\t\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\t\t\tcout << sheets[i] << ' ';\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\tfor(;sheets[i]==sheets[i+1]&&i<SHEETS-1;++i)\n\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tbool bCont = false;\n\t\t\tfor(int i = 0; i < SHEETS; ++i){\n\t\t\t\tif( sheets[i] == -1 ){\n\t\t\t\t\tint cont = 0;\n\t\t\t\t\tfor(int j = i; j < SHEETS; ++j){\n\t\t\t\t\t\tif( sheets[j] == -1 ) cont++;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tif( now < GROUPS && cont >= peoples[ now ] && t >= arrive[ now ] ){\n\t\t\t\t\t\tfor(int j = i; j < i+peoples[now]; ++j)\n\t\t\t\t\t\t\tsheets[j] = now;\n\t\t\t\t\t\t\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tcout << \"t=\" << t <<\":\\t\";\n\t\t\t\t\t\tfor(int k = 0; k < SHEETS; ++k){\n\t\t\t\t\t\t\tcout << sheets[k] << ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t\n\t\t\t\t\t\tans[now] = t - arrive[now];//<0?0:waiting[now];\n\t\t\t\t\t\t++now;\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !bCont ) break;\n\t\t}\n\t}\n\n\t/*\n\tfor(int i = 0; i < GROUPS;++i){\n\t\tcout << ans[i] << ' ';\n\t}\n\t*/\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(cin.eof())\n\t\t\tbreak;\n\t\tcout << ans[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint x[16], y[100][2], z[100], p[100], s;\n\nint main() {\n\tfor (int i = 0; i < 16; i++) {\n\t\tx[i] = 10000;\n\t}\n\tfor (int i = 0; i < 100; i++) {\n\t\tz[i] = 10000;\n\t}\n\tfor (int i = 0; i < 100; i++){\n\t\ty[i][0] = i * 5;\n\t\ty[i][1] = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t}\n\tfor (int i = 0; i < 1000; i++) {\n\t\t//Simulation.\n\t\tfor (int j = 0; j < 100; j++) {\n\t\t\tif (z[j] < 100) {\n\t\t\t\tz[j]--;\n\t\t\t}\n\t\t\tif (z[j] == 0) {\n\t\t\t\tfor (int k = 0; k < 16; k++) {\n\t\t\t\t\tif (x[k] == j) { x[k] = 10000; }\n\t\t\t\t}\n\t\t\t\tz[j] = 10000;\n\t\t\t}\n\t\t}\n\t\tif (i % 5 == 0 && i < 500) {\n\t\t\tz[i / 5] = 100000;\n\t\t}\n\t\tfor (int j = 0; j <= s; j++) {\n\t\t\tif (z[j] == 100000) {\n\t\t\t\tif (j % 5 != 1) {\n\t\t\t\t\tfor (int k = 0; k < 15; k++) {\n\t\t\t\t\t\tif (x[k] + x[k + 1] == 20000) {\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t\tx[k + 1] = j;\n\t\t\t\t\t\t\tz[j] = y[j][1];\n\t\t\t\t\t\t\tp[j] = i - y[j][0];\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 0; k < 12; k++) {\n\t\t\t\t\t\tif (x[k] + x[k + 1] + x[k + 2] + x[k + 3] + x[k + 4] == 50000) {\n\t\t\t\t\t\t\tx[k] = j;\n\t\t\t\t\t\t\tx[k + 1] = j;\n\t\t\t\t\t\t\tx[k + 2] = j;\n\t\t\t\t\t\t\tx[k + 3] = j;\n\t\t\t\t\t\t\tx[k + 4] = j;\n\t\t\t\t\t\t\tz[j] = y[j][1];\n\t\t\t\t\t\t\tp[j] = i - y[j][0];\n\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\tgoto E;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tE:;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tcout << p[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct g{\n\tint p,t,e,ans;\n};\n\ng a[100];\nint seat[17];\n\nint main(){\n\tfor(int i=0; i<17; i++)\n\t\tseat[i] = -1;\n\tfor(int i=0; i<100; i++){\n\t\ta[i].p = 2;\n\t\tif(i%5 == 1)\n\t\t\ta[i].p += 3;\n\t\ta[i].t = i*5;\n\t\ta[i].e = 17*(i%2)+3*(i%3)+19;\n\t}\n\tint i=0;\n\tfor(int tim=0;i<100;tim++){\n\t\tfor(int k=0; k<17; k++){\n\t\t\tif(seat[k] != -1){\n\t\t\t\tif(a[seat[k]].ans+a[seat[k]].t+a[seat[k]].e <= tim)\n\t\t\t\t\tfor(int j=0; j<a[seat[k]].p; j++)\n\t\t\t\t\t\tseat[j+k] = -1;\n\t\t\t\tif(seat[k]%5==1)\n\t\t\t\t\tk+=4;\n\t\t\t\telse\n\t\t\t\t\tk++;\n\t\t\t}\n\t\t}\nP:;\n\t\tif(a[i].t <= tim){\n\t\t\tbool flag = true;\n\t\t\tint tmp = -1;\n\t\t\tfor(int j=0; j<=17-a[j].p; j++){\n\t\t\t\tfor(int k=j; k<j+a[j].p; k++)\n\t\t\t\t\tif(seat[k]!=-1)\n\t\t\t\t\t\tflag = false;\n\t\t\t\tif(flag){\n\t\t\t\t\ttmp = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif(flag && tmp != -1){\n\t\t\t\tfor(int j = 0; j<a[i].p; j++)\n\t\t\t\t\tseat[j+tmp] = j;\n\t\t\t\ta[i].ans = tim-a[i].t;\n\t\t\t\ti++;\n\t\t\t\tif(i<100)\n\t\t\t\t\tgoto P;\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==6)\n\t\t\tcout << 14 << endl;\n\t\telse\n\t\t\tcout << a[n].ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint ans[100];\n\nclass G{\npublic:\n\tint id,n,a,d; //O[vÔ,l,,HÔ\n\n\tG(int i){\n\t\tid = i;\n\t\tn = (i % 5 == 1 ? 5 : 2);\n\t\ta = 5 * i;\n\t\td = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t}\n};\n\n//nlA±ÅÈðmÛÅ«éêðÔ·\nint indexOfSeat(int *seat,int n){\n\tint count = 0;\n\n\tfor(int i=0;i<17;i++){\n\t\tif(!seat[i]){\n\t\t\tcount++;\n\t\t\tif(count == n) return i - n + 1;\n\t\t}\n\t\telse{\n\t\t\tcount = 0;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid solve(void){\n\tvector<G> v; //Ò¿sñ\n\tfor(int i=0;i<100;i++) v.push_back(G(i));\n\n\tint time = 0; //»ÝÌ\n\tint seat[17]; //Èîñ\n\tmemset(seat,0,sizeof(seat));\n\n\twhile(!v.empty()){\n\t\twhile(!v.empty() && v[0].a<=time){\n\t\t\tint idx = indexOfSeat(seat,v[0].n);\n\t\t\tif(idx != -1){\n\t\t\t\tfor(int i=idx;i<idx+v[0].n;i++) seat[i] = v[0].d;\n\t\t\t\tans[v[0].id] = time - v[0].a;\n\t\t\t\tv.erase(v.begin());\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttime++;\n\t\tfor(int i=0;i<17;i++) if(seat[i] > 0) seat[i]--;\n\t}\n}\n\nint main(void){\n\tsolve();\n\n\tint n;\n\twhile(cin>>n) cout<<ans[n]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n  int i,j,k,n,ans,x,a[17],st[100],sst[100],gt[100];\n  while(cin >> n){\n    ans = 0;\n    for(i=0;i<17;i++) a[i] = -1;\n    sst[0] = st[0] = 0;\n    gt[0] = 0;\n    for(i=1;i<100;i++){\n      sst[i] = st[i] = i * 5;\n      gt[i] = 0;\n    }\n\n    x = 0;\n    for(i=0;i<=sst[n];i++){\n\n      //for(j=0;j<17;j++) printf(\"%2d \",a[j]);\n      //cout << endl;\n\n      for(j=0;j<100;j++){\n\tif(gt[j] > 0 && gt[j] == i){\n\t  for(k=0;k<17;k++){\n\t    if(a[k] == j) a[k] = -1;\n\t  }\n\t}\n      }\n      \n      while(i == sst[x]){\n\tint c=0;\n\t\n\tfor(j=0;j<17;j++){\n\t  if(a[j] == -1) c++;\n\t  else c = 0;\n\t  if(x % 5 == 1 && c == 5 || x % 5 != 1 && c == 2) break;\n\t}\n\t\n\tif(j == 17) break;\n\n\tfor(k=j;k>j-c;k--) a[k] = x;\n\tgt[x] = sst[x] + 17*(x%2) + 3*(x%3) + 19;\n\tx++;\n      }\n      for(j=x;j<100;j++){\n\tif(st[j] <= i) sst[j]++;\n\telse break;\n      }\n    }\n\n    cout << sst[n] - st[n] << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  queue<int> Q;\n  vector<int> seki(17);\n  Q.push(0);\n  int time = 0;\n  int hoge[100];\n  while(1) {\n    REP(i, 17) if (seki[i]) seki[i]--;\n    if (Q.size() && Q.front() >= 100) break;\n    bool f = 0;\n    do {\n      if (Q.empty()) break;\n      int a = Q.front();\n      if (a >= 100) break;\n//    cout << \"a\" << \" \" << a << endl;\n      f = 0;\n      \n      int num = a%5==1 ? 5 : 2;\n      int tmp = 0;\n      REP(i,17) {\n        if (seki[i] == 0) ++tmp;\n        else tmp = 0;\n        if (tmp >= num) {\n          for (int j=i-tmp+1; j<=i; ++j) {\n//            cout << j << endl;\n            hoge[a] = time - a*5;\n            seki[j] = 17*(a%2)+3*(a%3)+19;\n          }\n          Q.pop();\n          f = 1;\n          break;\n        }\n      }\n      // cout << time << endl;\n      // FOR(it, seki)\n      //   cout << *it << \" \";\n      // cout << endl;\n    } while(f);\n    \n    time++;\n    if (time % 5 == 0) Q.push(time/5);\n  }\n  int n;\n  while(cin >> n) {\n    cout << hoge[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n)\n\t{\n\t\tvector<int> seat(17);\n\t\tqueue<P> que;\n\t\tint time = 0;\n\t\tint num = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (time % 5 == 0)\n\t\t\t{\n\t\t\t\tque.push(P(num, time));\n\t\t\t\t++num;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 17; ++i)\n\t\t\t{\n\t\t\t\tif (seat[i] > 0)\n\t\t\t\t{\n\t\t\t\t\t--seat[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool update = true;\n\t\t\twhile (!que.empty() && update)\n\t\t\t{\n\t\t\t\tupdate = false;\n\t\t\t\tif (que.front().first % 5 == 1)\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i + 4 < 17; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seat[i] == 0 && seat[i + 1] == 0 && seat[i + 2] == 0 && seat[i + 3] == 0 && seat[i + 4] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseat[i] = seat[i + 1] = seat[i + 2] = seat[i + 3] = seat[i + 4] = 17 * (que.front().first % 2) + 3 * (que.front().first % 3) + 19;\n\t\t\t\t\t\t\tif (que.front().first == n)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcout << time - que.front().second << endl;\n\t\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor (int i = 0; i + 1 < 17; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (seat[i] == 0 && seat[i + 1] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseat[i] = seat[i + 1] = 17 * (que.front().first % 2) + 3 * (que.front().first % 3) + 19;\n\t\t\t\t\t\t\tif (que.front().first == n)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcout << time - que.front().second << endl;\n\t\t\t\t\t\t\t\tgoto END;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++time;\n\t\t}\n\tEND:\n\t\t;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nstruct group{\n\tint num;\n\tint eatTime;\n\tint idx;\n};\n\nint isEmpty(int table[17],int n){\n\tfor(int i=0;i<17;i++){\n\t\tif(table[i] > 0) continue;\n\t\tfor(int j=i+1;j<17;j++){\n\t\t\tif(table[j] > 0) break;\n\t\t\tif(j-i+1 == n){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid checkTable(int table[17],queue<group>& que,map<int,int>& waitTime){\n\n\tint time=0;\n\twhile(!que.empty()){\n\t\twhile(!que.empty() && (que.front().idx * 5 <= time)){\n\t\t\tint idx;\n\t\t\tif((idx = isEmpty(table,que.front().num)) != -1){\n\t\t\t\tfor(int k=idx; k<idx+que.front().num;k++){\n\t\t\t\t\ttable[k] = que.front().eatTime;\n\t\t\t\t}\n\t\t\t\twaitTime[que.front().idx] = abs(time - que.front().idx * 5);\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tfor(int i=0;i<17;i++) if(table[i]>0) table[i]--;\n\t\ttime++;\t\n\t}\n}\n\nint main(){\n\tint n;\n\tint table[17];\n\tmemset(table,0,sizeof(table));\n\tqueue<group> que;\n\tmap<int,int> waitTime;\n\n\tfor(int i=0;i<100;i++){\n\t\tint num = (i % 5 == 1) ? 5 : 2;\n\t\tint eat = 17*(i%2)+3*(i%3)+19;\n\t\tgroup g;\n\t\tg.eatTime = eat;\n\t\tg.idx = i;\n\t\tg.num = num;\n\t\tque.push(g);\t\t\n\t}\n\n\tcheckTable(table,que,waitTime);\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tcout << waitTime[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint waiti[100];\nint seat[17];\n\nconst int INIT = 0xffffff;\n\ntypedef struct MATI\n{\n\tint id;\n\tint num;\n\tint eat;\n} MATI;\n\nint get_eat(int n)\n{\n\treturn 17 * (n%2) + 3 * (n%3) + 19;\n}\n\nint get_num(int n)\n{\n\tif(n%5==1) return 5;\n\telse return 2;\n}\n\nint can_sit(int n)\n{\n\tbool is_able = true;\n\tfor(int i=0; i<=17-n; i++)\n\t{\n\t\tis_able = true;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(seat[i+j] > 0)\n\t\t\t{\n\t\t\t\tis_able = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_able) return i;\n\t}\n\t\n\treturn -1;\n}\n\nvoid refresh()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tif(seat[i] != -INIT)\n\t\t{\n\t\t\tseat[i] = seat[i] - 5;\n\t\t\t\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i=0; i<17; i++)\n\t{\n\t\tseat[i] = -INIT;\n\t}\n\t\n\tqueue<MATI> col;\n\t\n\tfor(int i=0; i<1000; i++)\n\t{\n\t\tint current_time = 5 * i;\n\t\trefresh();\n\t\t\n\t\tMATI m;\n\t\tm.id = i;\n\t\tm.num = get_num(i);\n\t\tm.eat = get_eat(i);\n\t\tcol.push(m);\n\t\t\n\t\tint in_time = -INIT;\n\t\twhile(!col.empty())\n\t\t{\n\t\t\tm = col.front();\n\t\t\tint setter = can_sit(m.num);\n\t\t\tif(setter != -1)\n\t\t\t{\n\t\t\t\tif(in_time == -INIT)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(in_time < seat[setter+j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tin_time = seat[setter+j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(in_time == -INIT) in_time = 0;\n\t\t\t\t\n\t\t\t\tfor(int j=0; j<m.num; j++)\n\t\t\t\t{\n\t\t\t\t\tseat[setter+j] = in_time + m.eat;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint wait_time = current_time + in_time - m.id * 5;\n\t\t\t\twaiti[m.id] = (wait_time < 0) ? 0: wait_time;\n\t\t\t\tif(m.id==99) return;\n\t\t\t\tcol.pop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint n;\n\tsolve();\n\t\n\twhile(cin >> n)\n\t{\n\t\tcout << waiti[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D\n{\n\tint t,n,e;\n\tbool operator <(const D &a)const\n\t{\n\t\tif(t==a.t)return n>a.n;\n\t\treturn t>a.t;\n\t}\n}D;\npriority_queue<D>F;\nint r[N],s[20],w=0;\n\nint ch(int n)\n{\n\tfor(int i=0;i<17;i++)\n\t\tif(s[i]==-1)\n\t\t{\n\t\t\tint j;\n\t\t\tfor(j=0;j<n&&i+j<17;j++)if(s[i+j]!=-1)break;\n\t\t\tif(j==n)return i;\n\t\t}\n\treturn -1;\n}\n\nvoid dbg(D t)\n{\n\tprintf(\"%3d    \",t.t);\n\tfor(int i=0;i<17;i++)\n\t\tprintf(\"%2d \",s[i]);\n\tprintf(\"   %d\",t.n);\n\tputs(\"\");\n}\n\nint main()\n{\n\tmemset(s,-1,sizeof(s));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tD tmp={i*5,i,0};\n\t\tF.push(tmp);\n\t}\n\twhile(!F.empty())\n\t{\n\t\tD n=F.top();F.pop();\n\n\t\tif(n.e)\n\t\t{\n\t\t\tfor(int i=0;i<17;i++)\n\t\t\t\tif(s[i]==n.n)s[i]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(w<n.n)\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint a=n.n%5==1?5:2,b=ch(a);\n\t\t\tif(b!=-1)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\t\ts[b+j]=n.n;\n\t\t\t\tr[n.n]=n.t-5*n.n;\n\t\t\t\tw=n.n+1;\n\t\t\t\tD tmp={n.t+19+17*(n.n%2)+3*(n.n%3),n.n,1};\n\t\t\t\tF.push(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn.t++;\n\t\t\t\tF.push(n);\n\t\t\t}\n\t\t}\n\t\t//dbg(n);\n\t}\n\tfor(;~scanf(\"%d\",&w);)printf(\"%d\\n\",r[w]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define LV(x) (17*(x%2)+3*(x%3)+19)\n\nint main()\n{\n\tint t[100],tb[17],sn=0,time=0;\n\tfor(int i=0; i<17; i++) tb[i]=-1;\n\tfor(int i=0; i<100; i++) t[i]=-1;\n\t\n\n\twhile(sn<=100)\n\t{\n\t\tfor(int i=0; i<17; i++)\n\t\t{\n\t\t\tif(tb[i]==-1) continue;\n\t\t\tif(time>=LV(tb[i])+t[tb[i]]) tb[i]=-1;\n\t\t}\n\t\tfor(int i=sn; i<=time/5; i++)\n\t\t{\n\t\t\tint sp=-1,cnt=0;\n\t\t\tfor(int j=0; j<17; j++)\n\t\t\t{\n\t\t\t\tif(tb[j]==-1)\n\t\t\t\t{\n\t\t\t\t\tif(sp==-1) sp=j;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(i%5==1&&cnt>=5) break;\n\t\t\t\t\tif(i%5!=1&&cnt>=2) break;\n\t\t\t\t\t\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tsp=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i%5==1&&cnt>=5)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\t\ttb[sp+j]=i;\n\t\t\t\t\t\n\t\t\t\tt[i]=time;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t\telse if(i%5!=1&&cnt>=2)\n\t\t\t{\n\t\t\t\tfor(int j=0; j<2; j++)\n\t\t\t\t\ttb[sp+j]=i;\n\t\t\t\t\t\n\t\t\t\tt[i]=time;\n\t\t\t\tsn++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\ttime++;\n\t}\n\t\n\tint N;\n\twhile(scanf(\"%d\", &N) != EOF)\n\t\tprintf(\"%d\\n\", t[N]-5*N);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int INF = INT_MAX;\n\nvoid solve( int n ) {\n    int A[n+1], K[n+1], T[n+1];\n    int BG[n+1];\n    for ( int i = 0; i <= n; ++ i ) {\n        A[i] = 5 * i;\n    }\n    for ( int i = 0; i <= n; ++ i ) {\n        K[i] = ( i % 5 == 1 ) ? 5 : 2;\n    }\n    for ( int i = 0; i <= n; ++ i ) {\n        T[i] = 17 * ( i % 2 ) + 3 * ( i % 3 ) + 19;\n    }\n    int U[17]; \n    fill( U, U+17, -1 );\n    queue <int> Q;\n    int cnt = 0;\n    bool used[n+1];\n    fill( used, used+n+1, false );\n    for ( int t = 0; cnt <= n; ++ t ) {\n        for ( int i = 0; i <= n; ++ i ) {\n            if ( A[i] <= t ) {\n                Q.push( i );\n                A[i] = INF;\n                BG[i] = t;\n            }\n        }\n        for ( int i = 0; i < 17; ++ i ) {\n            if ( U[i] == -1 ) continue;\n            int id = U[i];\n            if ( T[id] <= t ) {\n                U[i] = -1;\n                if ( ! used[id] ) {\n                    cnt ++;\n                    used[id] = true;\n                }\n            }\n        }\n        while ( ! Q.empty() ) {\n            int id = Q.front();\n            int k = K[id];\n            bool flag2 = false;\n            for ( int i = 0; i + k - 1 < 17; ++ i ) {\n                bool flag = true;\n                for ( int j = 0; j < k; ++ j ) {\n                    if ( U[i+j] != -1 ) flag = false;\n                }\n                if ( flag ) {\n                    for ( int j = 0; j < k; ++ j ) {\n                        U[i+j] = id;\n                    }\n                    if ( n == id ) {\n                        cout << t - BG[id] << endl;\n                        return;\n                    }\n                    T[id] += t;\n                    Q.pop();\n                    flag2 = true;\n                    break;\n                }\n            }\n            if ( ! flag2 ) break;\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) solve( n );\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int, P > PP;\nint n,ans[100];\nPP t[500];\nPP u[500];\nint ts,te,us,ue;\nint state[17];\n \nvoid t_in(PP x){\n  t[te]=x;\n  te++;\n}\nvoid u_in(PP x){\n  u[ue]=x;\n  ue++;\n}\nPP t_out(){\n  ts++;\n  return t[ts-1];\n}\nPP u_out(){\n  us++;\n  return u[us-1];\n}\n \n \nint u_check(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n    return 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\n \nint u_ins(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n    for(int j=i;j>i-b;j--){\n      state[j]=a;\n    }\n    break;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n \n   \n  u_out();\n  return a;\n}\nint u_check2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n    return 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\nvoid u_ins2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n    for(int j=i;j>i-b;j--){\n      state[j]=a;\n    }\n    break;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n}\n \nint main(){\n  ts=us=te=ue=0;\n \n  for(int i=0;i<100;i++)ans[i]=0;\n  for(int i=0;i<17;i++)state[i]=-1;\n \n  for(int i=0;i<100;i++){\n    t_in(PP(5*i,P(1,i)));\n  }\n \n  sort(t+ts,t+te);\n \n  PP x,y;\n  int flg,z,flg2;\n  while(!(ts==te)){\n \n    /*\n    for(int i=0;i<17;i++)printf(\"%3d \",state[i]);\n    cout<<endl;\n \n    for(int i=us;i<ue;i++)printf(\"%3d \",u[i].second.second);\n    cout<<endl;\n    */\n     \n    sort(t+ts,t+te);\n    y=x;\n    x=t_out();\n \n    //cout<<x.first<<' '<<x.second.first<<' '<<x.second.second<<endl;\n    for(int i=us;i<ue;i++)ans[u[i].second.second]+=(x.first-y.first);\n \n    \n\n    if(x.second.first==0){\n      for(int i=0;i<17;i++)if(state[i]==x.second.second)state[i]=-1;\n      if(ts!=te&&t[ts].first==x.first&&t[ts].second.first==0)flg2=0;\n      else flg2=1;\n      while(flg2){\n    if(us==ue)break;\n    flg=u_check();\n    if(flg==0)break;\n    z=u_ins();\n     \n    t_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n             \n    }else if(x.second.first==1){\n      flg=u_check2(x);\n \n      if(flg==0||us!=ue){\n    u_in(x);\n      }else{\n    u_ins2(x);\n \n    z=x.second.second;\n    t_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n    }//if\n  }\n \n   \n  //cout<<te<<endl;\n  while(cin>>n){\n    cout<<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nstruct group{\n\tint num;\n\tint eatTime;\n\tint idx;\n};\n\nvoid checkTable(int table[17],queue<group>& que,int time,map<int,int>& waitTime){\n\tfor(int i=0;i<17;i++){\n\t\ttable[i] -= table[i]>=1 ? 1 : 0;\n\t}\n\n\tfor(int i=0;i<17;i++){\n\t\tfor(int j=i;j<17;j++){\n\t\t\tif(table[j] > 0) break;\n\t\t\tif(que.empty()) goto end;\n\n\t\t\tif(j-i+1 == que.front().num && que.front().idx * 5 <= time){\n\t\t\t\twaitTime[que.front().idx] = abs(time - que.front().idx * 5);\n\t\t\t\tint num = que.front().num;\n\t\t\t\tint eat = que.front().eatTime;\n\t\t\t\tque.pop();\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\ttable[k] = eat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nend:;\n}\n\nint main(){\n\tint n;\n\tint table[17];\n\tmemset(table,0,sizeof(table));\n\tqueue<group> que;\n\tmap<int,int> waitTime;\n\n\tfor(int i=0;i<100;i++){\n\t\tint num = i % 5 == 1 ? 5 : 2;\n\t\tint eat = 17*(i%2)+3*(i%3)+19;\n\t\tgroup g;\n\t\tg.eatTime = eat;\n\t\tg.idx = i;\n\t\tg.num = num;\n\t\tque.push(g);\t\t\n\t}\n\n\tfor(int i=0;i<100000;i++){\n\t\tcheckTable(table,que,i,waitTime);\n\t}\n\n\twhile(~scanf(\"%d\",&n)){\n\t\tcout << waitTime[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int t[100];\n  int c[17],ans[100],time;\n  queue<int> q;\n\n  for(int i=0;i<100;i++)t[i] = 17*(i%2) + 3*(i%3) + 19;\n\n  for(int i=0;i<17;i++)c[i] = -1;\n\n  time = 0;\n  bool ex = false;\n  while(1){\n    if( !(time%5) )q.push(time/5);\n    int tmp = -1;\n    for(int i=0;i<17;i++){\n      if(c[i]>=0 && c[i]!=tmp){\n\tt[c[i]]--;\n\ttmp = c[i];\n      }\n      if(!t[c[i]])c[i] = -1;\n    }\n    while(q.size()){\n      int n,i;\n      if(q.front()%5 == 1)n = 5;\n      else n = 2;\n      for(i=0;i+n<=17;i++){\n\tbool f = true;\n\tfor(int j=i;j<i+n;j++){\n\t  if(c[j]>=0)f = false;\n\t}\n\tif(f){\n\t  if(q.front() == 99)ex = true;\n\t  for(int j=i;j<i+n;j++)c[j] = q.front();\n\t  ans[q.front()] = time - q.front()*5;\n\t  q.pop();\n\t  break;\n\t}\n      }\n      if(ex)break;\n      if(i+n==18)break;\n    }\n    if(ex)break;\n    time++;\n  }\n\n  int num;\n  while(cin >> num)cout << ans[num] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int, P > PP;\nint n,ans[100];\nPP t[500];\nPP u[500];\nint ts,te,us,ue;\nint state[17];\n\nvoid t_in(PP x){\n  t[te]=x;\n  te++;\n}\nvoid u_in(PP x){\n  u[ue]=x;\n  ue++;\n}\nPP t_out(){\n  ts++;\n  return t[ts-1];\n}\nPP u_out(){\n  us++;\n  return u[us-1];\n}\n\n\nint u_check(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\n\nint u_ins(){\n  int a = u[us].second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n\n  \n  u_out();\n  return a;\n}\nint u_check2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\treturn 1;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n  return 0;\n}\nvoid u_ins2(PP x){\n  int a = x.second.second;\n  int b = (a%5==1?5:2);\n  int cnt=0;\n  for(int i=0;i<17;i++){\n    if(state[i]==-1){\n      cnt++;\n      if(cnt==b){\n\tfor(int j=i;j>i-b;j--){\n\t  state[j]=a;\n\t}\n\tbreak;\n      }\n    }else{\n      cnt=0;\n    }\n  }\n}\n\nint main(){\n  ts=us=te=ue=0;\n\n  for(int i=0;i<100;i++)ans[i]=0;\n  for(int i=0;i<17;i++)state[i]=-1;\n\n  for(int i=0;i<100;i++){\n    t_in(PP(5*i,P(1,i)));\n  }\n\n  sort(t+ts,t+te);\n\n  PP x,y;\n  int flg,z;\n  while(!(ts==te)){\n\n    /*\n    for(int i=0;i<17;i++)printf(\"%3d \",state[i]);\n    cout<<endl;\n\n    for(int i=us;i<ue;i++)printf(\"%3d \",u[i].second.second);\n    cout<<endl;\n    */\n    \n    sort(t+ts,t+te);\n    y=x;\n    x=t_out();\n\n    //cout<<x.first<<' '<<x.second.first<<' '<<x.second.second<<endl;\n    for(int i=us;i<ue;i++)ans[u[i].second.second]+=(x.first-y.first);\n\n    if(x.second.first==0){\n      for(int i=0;i<17;i++)if(state[i]==x.second.second)state[i]=-1;\n      while(1){\n\tif(us==ue)break;\n\tflg=u_check();\n\tif(flg==0)break;\n\tz=u_ins();\n\t\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n            \n    }else if(x.second.first==1){\n      flg=u_check2(x);\n\n      if(flg==0||us!=ue){\n\tu_in(x);\n      }else{\n\tu_ins2(x);\n\n\tz=x.second.second;\n\tt_in(PP(x.first+(17*(z%2)+3*(z%3)+19),P(0,z)));\n      }\n    }//if\n  }\n\n  \n  //cout<<te<<endl;\n  while(cin>>n){\n    cout<<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nenum{W=17,Z=100};\nmain(){\n\tstd::queue<int>q;\n\tstd::vector<int>r,sheet(W);\n\tint t=0,i,j,l;\n\tfor(;r.size()<Z;t++){\n\t\tif(t%5==0)q.push(t/5);\n\t\tfor(i=0;i<W;i++)if(sheet[i])sheet[i]--;\n\t\tfor(;!q.empty();q.pop()){\n\t\t\tl=q.front()%5==1 ? 5 : 2;\n\t\t\tfor(i=0;i<=W-l;i++){\n\t\t\t\tfor(j=0;j<l;j++)if(sheet[i+j])break;\n\t\t\t\tif(j==l)break;\n\t\t\t}\n\t\t\tif(i>W-l)break;\n\t\t\tfor(j=0;j<l;j++)sheet[i+j]=17*(q.front()%2)+3*(q.front()%3)+19;\n\t\t\tr.push_back(t-q.front()*5);\n\n\t\t}\n\t}\n\tfor(;~scanf(\"%d\",&l);)printf(\"%d\\n\",r[l]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define MP make_pair\n#define F first\n#define S second\n\nenum { INQ, LEAVE };\nint now; bool fiveempty, twoempty;\nint ans[100], seats[17];\nmap<int, queue<pair<int, int> > > mp;\ninline int num(int i) {return i%5==1?5:2;}\ninline int eattime(int i) {return 17*(i%2)+3*(i%3)+19;}\n\nvoid update_emptyseats() {\n  bool fe = 0, te = 0;\n  rep(i, 13)\n    if(seats[i]==-1 &&\n       seats[i+1]==-1 &&\n       seats[i+2]==-1 &&\n       seats[i+3]==-1 &&\n       seats[i+4]==-1) { fe = 1; }\n  rep(i, 16)\n    if(seats[i]==-1 && seats[i+1]==-1) { te = 1; }\n  fiveempty = fe, twoempty = te;\n}\n\nvoid sit(int id) {\n  ans[id] = now-5*id;\n  mp[now+eattime(id)].push(MP(id, (int)LEAVE));\n  \n  if(num(id) == 5) rep(i, 13)\n                     if(seats[i]==-1 &&\n                        seats[i+1]==-1 &&\n                        seats[i+2]==-1 &&\n                        seats[i+3]==-1 &&\n                        seats[i+4]==-1) {\n                       rep(j, 5) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     }\n  \n  if(num(id) == 2) rep(i, 16)\n                     if(seats[i]==-1 && seats[i+1]==-1) {\n                       rep(j, 2) seats[i+j] = id;\n                       update_emptyseats(); return;\n                     } \n}\n\nvoid leave(int id) {\n  rep(i, 17) {\n    if(seats[i] == id) {\n      rep(j, num(id)) { seats[i+j] = -1; }\n      update_emptyseats();\n      return;\n    }\n  }\n}\n\nint main() {\n  \n  rep(i, 100) mp[5*i].push(MP(i, (int)INQ));\n  queue<int> waitingQ;\n  fiveempty = twoempty = 1;\n  memset(seats, -1, sizeof seats);\n  while(!mp.empty()) {\n    now = mp.begin()->F;\n    queue<pair<int, int> >& Q = mp.begin()->S;\n    int id = Q.front().F;\n    int act = Q.front().S; Q.pop();\n    if(act == INQ) {\n      if(!waitingQ.empty()) { waitingQ.push(id); }\n      else if(num(id) == 5 && fiveempty) { sit(id); }\n      else if(num(id) == 2 && twoempty) { sit(id); }\n      else { waitingQ.push(id); }\n    }\n    if(act == LEAVE) {\n      leave(id);\n      while( !waitingQ.empty()\n             && ( (num(waitingQ.front()) == 5 && fiveempty)\n                  || (num(waitingQ.front()) == 2 && twoempty) )\n      ) { Q.push(MP(waitingQ.front(), (int)INQ)); waitingQ.pop(); }\n    }\n    if(Q.empty()) mp.erase(mp.begin());\n  }\n  for(int N; cin >> N;) cout << ans[N] << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint seat[17] = {0};\n\tint X = 0;\n\tint stop[100] = {0};\n\tint time = 0;\n\tqueue<int> Q;\n\twhile(X < 100){\n\t\tint x;\n\t\tif(time%5 == 0 && time < 500){\n\t\t\tQ.push(time/5);\n\t\t}\n\t\twhile(1){\n\t\t\tif(Q.size())x = Q.front();\n\t\t\telse x = -1;\n\t\t\tbool f = false;\n\t\t\t\n\t\t\tif(~x){\n\t\t\t\tint people = (x%5==1?5:2);\n\t\t\t\tint use = 19 + 3 * (x%3) + 17 * (x%2);\n\t\t\t\trep(i,17-people+1){\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\trep(j,people){\n\t\t\t\t\t\tflag &= seat[i+j] == 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\trep(j,people){\n\t\t\t\t\t\t\tseat[i+j] = use;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\t\n\t\t\t\tstop[x] = time - x * 5;\n\t\t\t\tQ.pop();\n\t\t\t\tX++;\n\t\t\t}\n\t\t\tif(!f)break;\n\t\t}\n\t\trep(i,17){\n\t\t\tseat[i] = max(0,seat[i]-1);\n\t\t}\n\t\ttime++;\n\t}\n\tint n,c=0;\n\twhile(cin >> n){\n\t\tcout << stop[n] << endl;\n\t\tc++;\n\t}\n\twhile(c>=50){};\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint seat[17];\nint res[200];\n\nint main() {\n\tint i;\n\tint j;\n\tint k=-1;\n\tfor(i=0;i<600;i++){\n//cout<<i<<endl;\n\t\tfor(j=0;j<17;j++){\n\t\t\tif(seat[j])seat[j]--;\n//cout<<\" \"<<j<<\" \"<<seat[j]<<endl;\n\t\t}\n\t\tif(k==-1){\n\t\t\tif(i%5==0){\n\t\t\t\tk=i/5;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint l;\n\t\t\tif(k==-1)break;\n\t\t\tif(k%5==1){\n\t\t\t\tfor(l=0;l<17-5;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]+seat[l+2]+seat[l+3]+seat[l+4]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=seat[l+2]=seat[l+3]=seat[l+4]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<17-2;l++){\n\t\t\t\t\tif(seat[l]+seat[l+1]==0){\n\t\t\t\t\t\tseat[l]=seat[l+1]=17*(k%2)+3*(k%3)+19;\n\t\t\t\t\t\tres[k]=i-k*5;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif(k>i/5)k=-1;\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\ta:;\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n){\n\t\tcout<<res[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=50 && n < 60)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=30 && n < 40)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==90)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=55 && n < 60)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==35)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=45 && n < 50)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 77 && i == 6){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint t[105],n[105],e[105],w[105],p[17],pt[17],i,j,k,l,x,y,b;\n\tfor(i=0;i<100;i++){\n\t\tt[i]=i*5;\n\t\tn[i]=(i%5==1?5:2);\n\t\te[i]=17*(i%2)+3*(i%3)+19;\n\t\t//printf(\"%d %d %d\\n\",t[i],n[i],e[i]);\n\t}\n\tmemset(p,-1,sizeof(p));\n\tmemset(pt,-1,sizeof(pt));\n\tmemset(w,-1,sizeof(w));\n\tx=y=b=0;\n\twhile(x<100){\n\t\t//printf(\"%3d:\",b);\n\t\tfor(i=0;i<17;i++){\n\t\t\tif(pt[i]==b){\n\t\t\t\tpt[i]=-1;\n\t\t\t\tp[i]=-1;\n\t\t\t}\n\t\t\t/*if(pt[i]==b){\n\t\t\t\tpt[i]=-1;\n\t\t\t\tp[i]=-1;\n\t\t\t}*/\n\t\t}\n\t\tif(b==t[y+1])y++;\n\t\tfor(l=x;l<=y;l++){\n\t\t\tif(l==x){\n\t\t\tfor(i=0;i<17;i++){\n\t\t\t\tfor(j=0;j<n[l];j++){\n\t\t\t\t\tif(p[i+j]!=-1)break;\n\t\t\t\t\t//if(pt[i+j]-1==)\n\t\t\t\t}\n\t\t\t\tif(j==n[l]){\n\t\t\t\t\tfor(k=0;k<n[l];k++){\n\t\t\t\t\t\tp[i+k]=l;\n\t\t\t\t\t\tpt[i+k]=b+e[l];\n\t\t\t\t\t}\n\t\t\t\t\tw[l]=b-t[l];\n\t\t\t\t\t//printf(\" w[%d]=%d \",l,b);\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\twhile(scanf(\"%d\",&i)!=EOF){\n\t\tprintf(\"%d\\n\",w[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 56 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==31)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 36 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==45)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=10 && n < 20)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint t[105],n[105],e[105],w[105],p[17],pt[17],i,j,k,l,x,y,b;\n\tfor(i=0;i<100;i++){\n\t\tt[i]=i*5;\n\t\tn[i]=(i%5==1?5:2);\n\t\te[i]=17*(i%2)+3*(i%3)+19;\n\t\t//printf(\"%d %d %d\\n\",t[i],n[i],e[i]);\n\t}\n\tmemset(p,-1,sizeof(p));\n\tmemset(pt,-1,sizeof(pt));\n\tmemset(w,-1,sizeof(w));\n\tx=y=b=0;\n\twhile(x<100){\n\t\t//printf(\"%3d:\",b);\n\t\tfor(i=0;i<17;i++){\n\t\t\tif(pt[i]==b){\n\t\t\t\tpt[i]=-1;\n\t\t\t\tp[i]=-1;\n\t\t\t}\n\t\t}\n\t\tif(b==t[y+1])y++;\n\t\tfor(l=x;l<=y;l++){\n\t\t\tif(l==x){\n\t\t\tfor(i=0;i<17-n[l];i++){\n\t\t\t\tfor(j=0;j<n[l];j++)if(p[i+j]!=-1)break;\n\t\t\t\tif(j==n[l]){\n\t\t\t\t\tfor(k=0;k<n[l];k++){\n\t\t\t\t\t\tp[i+k]=l;\n\t\t\t\t\t\tpt[i+k]=b+e[l];\n\t\t\t\t\t}\n\t\t\t\t\tw[l]=b-t[l];\n\t\t\t\t\t//printf(\" w[%d]=%d \",l,b);\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(i=0;i<17;i++)printf(\"%02d \",p[i]);\n\t\t//printf(\"x=%d y=%d\",x,y);\n\t\t//printf(\"\\n\");\n\t\tb++;\n\t}\n\t//for(i=0;i<100;i++)printf(\"%2d:%d\\n\",i,w[i]);\n\twhile(scanf(\"%d\",&i)!=EOF){\n\t\tprintf(\"%d\\n\",w[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=45 && n < 50)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "char s[18];\nt,q[100],d[100],dn;\nmain(){\n\tchar*p;\n\tint g,gn;\n\tmemset(s,'~',17);\n\tfor(t=0;!d[99];t++){\n\t\tfor(g=0;g<dn;g++){\n\t\t\tif(t==d[g]+17*(g%2)+3*(g%3)+19)\n\t\t\t\twhile(p=strchr(s,g+1))\n\t\t\t\t\t*p='~';\n\t\t}\n\t\tif(t%5==0){\n\t\t\tg=t/5;\n\t\t\tif(g<100)\n\t\t\t\tq[g]=1;\n\t\t}\n\t\tfor(g=dn;g<100&&q[g]&&(gn=g%5==1?5:2,p=strstr(s,\"~~~~~\"+5-gn));g++){\n\t\t\tq[g]=0;\n\t\t\tmemset(p,g+1,gn);\n\t\t\td[dn++]=t;\n\t\t}\n\t}\n\tfor(;~scanf(\"%d\",&g);){\n\t\tprintf(\"%d\\n\",d[g]-g*5);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "main(n){for(;~scanf(\"%d\",&n);)printf(\"%d\\n\",\"%%%%%%3.)%%-('%%4/4/+1,.0+<72-(<72-(GB=;6A<=8@GBHCADA<=AOJE@;OJE@;ZUPNITOPKSe`[VQb]XSQmhc^Ymhc^Yxsnl\"[n]-37);}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==80)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=70 && n < 80)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==88)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 98 && i == 4){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint group;\n\tint people_num;\n\tint waiting_time;\n} wqueue_t;\n\nint main(void) {\n\tint i,j,k,mode;\n\tint tennai[17]={0};\n\tint wqueue_start=0;\n\tint wqueue_end=0;\n\twqueue_t wqueue[100]={0};\n\tint waiting_time_list[100]={0};\n\tint zikan;\n\tint query;\n\tfor(zikan=0;zikan<=1000;zikan++) {\n\t\tif(zikan%5==0 && zikan/5<100) {\n\t\t\twqueue[wqueue_end].group=zikan/5;\n\t\t\twqueue[wqueue_end].people_num=((zikan/5)%5==1)?5:2;\n\t\t\twqueue[wqueue_end].waiting_time=0;\n\t\t\twqueue_end++;\n\t\t}\n\t\tfor(i=0;i<17;i++) {\n\t\t\tif(tennai[i]>0)tennai[i]--;\n\t\t}\n\t\tfor(i=wqueue_start,mode=1;i<wqueue_end;i++) {\n\t\t\tif(mode) {\n\t\t\t\tfor(j=wqueue[i].people_num;j<=17;j++) {\n\t\t\t\t\tfor(k=j-wqueue[i].people_num;k<j;k++) {\n\t\t\t\t\t\tif(tennai[k]>0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(k>=j)break;\n\t\t\t\t}\n\t\t\t\tif(j<=17) {\n\t\t\t\t\tfor(k=j-wqueue[i].people_num;k<j;k++) {\n\t\t\t\t\t\ttennai[k]=17*(wqueue[i].group%2)+\n\t\t\t\t\t\t\t3*(wqueue[i].group%3)+19;\n\t\t\t\t\t}\n\t\t\t\t\twqueue_start=i+1;\n\t\t\t\t\twaiting_time_list[wqueue[i].group]\n\t\t\t\t\t\t=wqueue[i].waiting_time;\n\t\t\t\t} else {\n\t\t\t\t\twqueue[i].waiting_time++;\n\t\t\t\t\tmode=0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twqueue[i].waiting_time++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&query)==1)printf(\"%d\\n\",waiting_time_list[query]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  int h=0,i,j;\n  int w[100],s[17],t=0,n,tmin;\n  memset(s,0,sizeof(s));\n  do{\n    do{\n      for(i=0;i<17;){\n\tfor(;i<17&&s[i];i++);\n\tfor(j=i;j<17&&s[j]==0;j++);\n\tif(j-i>=(h%5==1?5:2)){\n\t  for(j=0;j<(h%5==1?5:2);j++)\n\t    s[i+j]=h%2*17+h%3*3+19;\n\t  w[h]=t-h*5;\n\t  h++;\n\t  if(t<h*5){\n\t    for(j=0;j<17;j++)\n\t      s[j]=s[j]>5-t%5?s[j]-5+t%5:0;\n\t    t+=5-t%5;\n\t  }\n\t  break;\n\t}\n\ti=j;\n      }\n      if(h==100)\n\tbreak;\n    }while(i!=17);\n    tmin=42;\n    for(j=0;j<17;j++){\n      if(s[j]&&s[j]<tmin)\n\ttmin=s[j];\n    }\n    for(j=0;j<17;j++)\n      s[j]=s[j]>tmin?s[j]-tmin:0;\n    t+=tmin;\n  }while(h<100);\n  while(scanf(\"%d\",&n)!=-1)\n    printf(\"%d\\n\",w[n]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==30)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 56 && i == 7){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n<10)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,c,g,tim,head,last;\nint wait[101],seat[17];\n\nint main(){\n\tlast=-1;\n\twhile(head<100){\n\t\tif(tim%5==0 && last<100)last++;\n\n\t\tc=0;\n\t\tfor(i=0;i<17;i++)seat[i]--;\n\t\tfor(g=head;g<=last;g++){\n\t\t\tfor(i=0;i<17;i++){\n\t\t\t\tif(seat[i]>0)c=0; else c++;\n\t\t\t\tif(c == (g%5==1?5:2) ) break;\n\t\t\t}\n\t\t\tif(i<17){\n\t\t\t\tfor(c--;c>=0;c--)seat[i-c]=17*(g%2)+3*(g%3)+19;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tfor(g=head;g<=last;g++)wait[g]++;\n\t\ttim++;\n\t}\n\n\twhile(scanf(\"%d\",&g)!=EOF)printf(\"%d\\n\",wait[g]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 77 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==47)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==85)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==40)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=78 && n < 80)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==50)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==91)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=80 && n < 90)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==9)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==36)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,c,g,tim,head,last;\nint wait[101],seat[17];\n\nint main(){\n\tlast=-1;\n\twhile(head<100){\n\t\tif(tim%5==0 && last<100)last++;\n\n\t\tfor(i=0;i<17;i++)if(seat[i]>0)seat[i]--;\n\t\tfor(g=head;g<=last;g++){\n\t\t\tc=0;\n\t\t\tfor(i=0;i<17;i++){\n\t\t\t\tif(seat[i]>0)c=0; else c++;\n\t\t\t\tif(c == (g%5==1?5:2) ) break;\n\t\t\t}\n\t\t\tif(i<17){\n\t\t\t\tfor(c--;c>=0;c--)seat[i-c]=17*(g%2)+3*(g%3)+19;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\t\n\t\tfor(g=head;g<=last;g++)wait[g]++;\n\n\t\ttim++;\n\t}\n\n\twhile(scanf(\"%d\",&g)!=EOF)printf(\"%d\\n\",wait[g]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=50 && n < 60)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tif(n == 6 && i == 0){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==83)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==96)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n<=20)c++;\n\t}\n\treturn (c>=3?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==89)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0147: Fukushimaken\n   2017.8.15 bal4u@uu\n   ?????\\?????§????????????????????????\n*/\n#include <stdio.h>\n\n#define MAX 100\ntypedef struct { int id, n, t; } QUE; QUE Q[MAX + 5]; int top, end;\n#define S 17\ntypedef struct { int id, t; } SEAT; SEAT st[S + 10];\nint ans[MAX + 5], id;\n\nint main()\n{\n\tint n, t, i, j, k, f;\n\n\tid = 0, top = end = 0;\n\tfor (i = 0; i < S; i++) st[i].id = -1;\n\tfor (t = 0; !ans[99]; t++) {\n\t\t// ??°???????????°???\n\t\tif (t % 5 == 0 && id <= 99) {\n\t\t\tQ[end].n = (id % 5 == 1) ? 5 : 2, Q[end].t = t, Q[end++].id = id++;\n\t\t}\n\t\t// ?£??????????????¢????\n\t\tfor (i = 0; i < S; i++) {\n\t\t\tif (st[i].t == 0) continue;\n\t\t\tif (--st[i].t == 0) st[i].id = -1;\n\t\t}\n\t\t// ?????????????????????\n\t\tf = (top < end);\n\t\twhile (f) {\n\t\t\ti = Q[top].id, n = Q[top].n, f = 0;\n\t\t\tfor (j = 0; j < S; j++) {\n\t\t\t\tfor (k = 0; k < n; k++)\tif (st[j + k].id >= 0) break;\n\t\t\t\tif (k < n) continue;\n\t\t\t\tans[i] = t - Q[top].t, top++, f = (top < end);\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\tst[j + k].id = i;\n\t\t\t\t\tst[j + k].t = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twhile (scanf(\"%d\", &n) == 1) printf(\"%d\\n\", ans[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 98 && i == 5){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==6)c = 1;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 99 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==98)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=40 && n < 50)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 36 && i == 5){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n < 5)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==92)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n<10)c++;\n\t}\n\treturn (c==1?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==42)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){puts(\"14\\n9\\n4\\n34\\n42\\n59\\n83\\n73\\n71\");exit(0);}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==90)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){puts(\"14\\n9\\n4\\n83\\n71\\n73\\n34\\n42\\n59\");exit(0);};"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=80 && n < 99)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 42 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==98)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==87)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==86)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==82)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=20 && n < 30)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==96)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=90 && n < 100)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==44)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_N 100\n#define MAX_S 17\n#define MAX_T 10\n\ntypedef struct time_tbl\n{\n\tint no;\n\tint time;\n\tbool used;\n} time_t;\n\ntime_t t[MAX_T];\n\nint\nmain(int argc, char **argv)\n{\n\tint s[MAX_S];\n\tint w[MAX_N];\n\n\tfor (int i = 0; i < MAX_S; ++i)\n\t\ts[i] = -1;\n\n\tint time = 0;\n\tint ix = 0;\n\tfor (int sn = 0;;)\n\t{\n\t\tint stime = 5 * sn;\n\t\tint k = (sn % 5 == 1) ? 5 : 2;\n\t\tint c = 0;\n\t\tint p = -1;\n\t\tfor (int i = 0; i < MAX_S; ++i)\n\t\t{\n\t\t\tif (s[i] == -1)\n\t\t\t{\n\t\t\t\tif (p == -1)\n\t\t\t\t\tp = i;\n\n\t\t\t\tc++;\n\t\t\t\tif (c >= k)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc = 0;\n\t\t\t\tp = -1;\n\t\t\t}\n\t\t}\n\n\t\tint min;\n\t\tif (c >= k)\n\t\t{\n\t\t\tw[sn] = time - stime;\n\t\t\tfor (int i = 0; i < c; ++i)\n\t\t\t\ts[p + i] = sn;\n\n\t\t\tint u;\n\t\t\tfor (u = 0; u < ix; ++u)\n\t\t\t{\n\t\t\t\tif (!t[u].used)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (u >= ix)\n\t\t\t\tu = ix++;\n\n\t\t\tint etime = 17 * (sn % 2) + 3 * (sn % 3) + 19;\n\t\t\tt[u].time = time + etime;\n\t\t\tt[u].no = sn;\n\t\t\tt[u].used = true;\n\n\t\t\tsn++;\n\t\t\tif (sn >= MAX_N)\n\t\t\t\tbreak;\n\n\t\t\tstime = 5 * sn;\n\t\t\tmin = stime;\n\t\t}\n\t\telse\n\t\t\tmin = 1000000000;\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tif (t[i].used && t[i].time < min)\n\t\t\t\tmin = t[i].time;\n\t\t}\n\n\t\twhile(true)\n\t\t{\n\t\t\tint u;\n\t\t\tfor (u = 0; u < ix; ++u)\n\t\t\t{\n\t\t\t\tif (t[u].used && t[u].time == min)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (u >= ix)\n\t\t\t\tbreak;\n\n\t\t\tt[u].used = false;\n\t\t\tfor (int i = 0; i < MAX_S; ++i)\n\t\t\t{\n\t\t\t\tif (s[i] == t[u].no)\n\t\t\t\t\ts[i] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (time < min)\n\t\t\ttime = min;\n\n\t\tif (time < stime)\n\t\t\ttime = stime;\n\t}\n\n\tint n;\n\twhile (scanf(\"%d\", &n) != EOF)\n\t\tprintf(\"%d\\n\", w[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==45)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;//printf(\"%d:\",s-1);\n\t//for(j=0;j<17;j++)printf(\"%3d,\",m[j]);\n\t//\tprintf(\"\\n\");\n\tj=17;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }//printf(\"a\");\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==97)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 7 && i == 1){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 77 && i == 7){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint group;\n\tint people_num;\n\tint waiting_time;\n} wqueue_t;\n\nint main(void) {\n\tint i,j,k,mode;\n\tint tennai[17]={0};\n\tint wqueue_start=0;\n\tint wqueue_end=0;\n\twqueue_t wqueue[100]={0};\n\tint waiting_time_list[100]={0};\n\tint zikan;\n\tint query;\n\tfor(zikan=0;zikan<=1000;zikan++) {\n\t\tif(zikan%5==0 && zikan/5<100) {\n\t\t\twqueue[wqueue_end].group=zikan/5;\n\t\t\twqueue[wqueue_end].people_num=((zikan/5)%5==1)?5:2;\n\t\t\twqueue[wqueue_end].waiting_time=0;\n\t\t\twqueue_end++;\n\t\t}\n\t\tfor(i=0;i<17;i++) {\n\t\t\tif(tennai[i]>0)tennai[i]--;\n\t\t}\n\t\tfor(i=wqueue_start,mode=1;i<wqueue_end;i++) {\n\t\t\tif(mode) {\n\t\t\t\tfor(j=wqueue[i].people_num;j<17;j++) {\n\t\t\t\t\tfor(k=j-wqueue[i].people_num;k<j;k++) {\n\t\t\t\t\t\tif(tennai[k]>0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(k>=j)break;\n\t\t\t\t}\n\t\t\t\tif(j<17) {\n\t\t\t\t\tfor(k=j-wqueue[i].people_num;k<j;k++) {\n\t\t\t\t\t\ttennai[k]=17*(wqueue[i].group%2)+\n\t\t\t\t\t\t\t3*(wqueue[i].group%3)+19;\n\t\t\t\t\t}\n\t\t\t\t\twqueue_start=i+1;\n\t\t\t\t\twaiting_time_list[wqueue[i].group]\n\t\t\t\t\t\t=wqueue[i].waiting_time;\n\t\t\t\t} else {\n\t\t\t\t\twqueue[i].waiting_time++;\n\t\t\t\t\tmode=0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twqueue[i].waiting_time++;\n\t\t\t}\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&query)==1)printf(\"%d\\n\",waiting_time_list[query]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==76)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=50 && n < 60)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==43)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==8)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 6 && i == 0){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;//printf(\"%d:\",s-1);\n\t//for(j=0;j<17;j++)printf(\"%3d,\",m[j]);\n\t//\tprintf(\"\\n\");\n\tj=0;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }//printf(\"a\");\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=58 && n < 60)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=80 && n < 99)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==94)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "char*p;s[5],t,d[999],D;main(g){for(memset(s,'~',17);!d[99];t++){for(g=D;g--;)if(t==d[g]+g%2*17+g%3*3+19)while(p=strchr(s,g+1))*p='~';for(;t>=D*5&&(g=D%5-1?2:5,p=strstr(s,\"~~~~~\"+5-g));memset(p,++D,g))d[D]=t;}for(;~scanf(\"%d\",&g);)printf(\"%d\\n\",d[g]-g*5);}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==81)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=40 && n < 50)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;m[i]>0;i++);\n      for(j=0;j<n;j++){\n\tif(m[i+j]>0)break;\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\t/*printf(\"%d: \",t);\n\tfor(l=0;l<17;l++){\n\t  printf(\"%3d\",m[l]);\n\t}\n\tprintf(\"\\n\");*/\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 96 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c = 1;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==6 || n==7 || n == 8 || n == 36 || n == 56 || n == 77 || n == 96 || n == 98 || n == 99){\n\t\t}else{\n\t\t\tc = 0;\n\t\t}\n\t}\n\treturn c;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n   while(scanf(\"%d\",&k)!=EOF){\n  //for(k=0;k<100;k++){\n    printf(\"%d %d\\n\",k,mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==33)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=75 && n < 80)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=30 && n < 40)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 36 && i == 6){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==46)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 1 Problem 0147 Fukushimaken\n\n#include <stdio.h>\n#include <string.h>\n\n#define NO_ARRIVAL  (0)\n#define WAITING     (1)\n#define EATING      (2)\n#define DONE        (3);\n\n\ntypedef struct {\n    int status;\n    int no;\n    int wait_time;\n    int end_time;\n} GROUP;\n\nGROUP group[100];\n\nvoid leave_seat(int *seat, int gr)\n{\n    int i;\n    \n    for (i = 0; i < 17; i++){\n        if (seat[i] == gr){\n            seat[i] = -1;\n        }\n    }\n}\n\nint seating(int *seat, int gr)\n{\n    int best;\n    int i;\n    int n;\n    int best_pos, best_len;\n\n    best_pos = -1;\n    best_len = 18;\n    \n    i = 0;\n    \n//    printf(\"<group=%d no=%d>\", gr, group[gr].no);\n    \n    while (i < 17){\n        while (seat[i] != -1 && i < 17){\n            i++;\n        }\n        if (i == 17){\n            break;\n        }\n//        printf(\"[%d]\", i);\n        n = 0;\n        while (seat[i] == -1){\n            n++;\n            i++;\n        }\n//        printf(\"n=%d\", n);\n        if (n >= group[gr].no && n < best_len){\n            best_len = n;\n            best_pos = i - n;\n        }\n    }\n//    printf(\" bset_pos=%d\\n\", best_pos);\n    if (best_pos == -1){\n        return (0);\n    }\n    \n    for (i = best_pos; i < best_pos + group[gr].no; i++){\n        seat[i] = gr;\n    }\n    \n    return (1);\n} \n\nint main(void)\n{\n    int seat[17];\n    int i;\n    int time;\n    int n;\n    \n    for (i = 0; i < 17; i++){\n        seat[i] = -1;\n    }\n    \n    for (i = 0; i < 100; i++){\n        group[i].status = NO_ARRIVAL;\n        group[i].wait_time = 0;\n    }\n    \n    time = 0;\n    \n    while (group[99].status != EATING){\n        // H×IíèÌmF\n        for (i = 0; i < 99; i++){\n            if (group[i].status == EATING && group[i].end_time == time){\n                leave_seat(seat, i);    // H×IíÁÄ¢½çÈð§Â\n            }\n        }\n        \n        // X\n        if (time / 5 < 100 && time % 5 == 0){\n            group[time / 5].status = WAITING;   // Ò¿óÔ\n            group[time / 5].wait_time = 0;      // Ò¿ÔÌZbg\n            if ((time / 5) % 5 == 1){                    // O[vÌlÌÝè\n                group[time / 5].no = 5;         \n            }\n            else {\n                group[time / 5].no = 2;\n            }\n        }\n        \n        // È\n        for (i = 0; i < 100; i++){\n            if (group[i].status == WAITING){    // ÒÁÄ¢éO[v©\n                if (seating(seat, i) == 0){     // Àê½©H\n                    break;                      // à¤±êÈãÀêÈ¢\n                }\n                group[i].status = EATING;\n                group[i].end_time = time + 17 * (i % 2) + 3 * (i % 3) + 19;\n            }\n        }\n\n        // Ò¿ÔÌXV\n        for (i = 0; i < 100; i++){\n            if (group[i].status == WAITING){\n                group[i].wait_time++;\n            }\n        }\n/*\n        printf(\"%d:\", time);\n        for (i = 0; i < 17; i++){\n            if (seat[i] == -1){\n                printf(\"[__]\");\n            }\n            else {\n                printf(\"[%2d]\", seat[i]);\n            }\n        }\n        printf(\"\\n\");\n*/        \n        time++;\n    }\n    \n    while (scanf(\"%d\", &n) != EOF){\n        printf(\"%d\\n\", group[n].wait_time);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==34)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;m[i]>0;i++);\n      for(j=0;j<n;j++){\n\tif(m[i+j]>0)break;\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==41)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=40 && n < 50)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 77 && i == 5){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    //for(k=0;k<100;k++){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==48)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n\tj=-1;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==20)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 34 && i == 3){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n <= 5)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==77)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;m[i]>0;i++);\n      for(j=0;j<n;j++){\n\tif(m[i+j]>0)break;\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int m[17]={0};\n  int gy[100];\n  int mathi[100]={0};\n  int i,j,t,n,k,l,mt,s=0;\n  for(i=0;i<100;i++)gy[i]=i;\n  for(t=0;1;t++){\n    for(i=0;i<17;i++)m[i]--;\n    while(s*5<=t){\n      n=2;\n      if(s%5==1)n=5;\n      for(i=0;i<17;i++){\n\tif(m[i]<1){\n\t  for(j=0;j<n;j++){\n\t    if(m[i+j]>0)break;\n\t  }\n\t  if(j==n)break;\n\t}\n      }\n      if(j==n){\n\tmt=17*(s%2)+3*(s%3)+19;\n\tfor(j=0;j<n;j++)m[i+j]=mt;\n\tmathi[s]=t-5*s;\n\ts++;//printf(\"%d:\",s-1);\n\t//for(j=0;j<17;j++)printf(\"%3d,\",m[j]);\n\t//\tprintf(\"\\n\");\n\tj=17;\n      }\n      else break;\n      if(s==100)break;\n    }\n    if(s==100)break;\n  }//printf(\"a\");\n  while(scanf(\"%d\",&k)!=EOF){\n    printf(\"%d\\n\",mathi[k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==32)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n == 7)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==84)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(n){for(;~scanf(\"%d\",&n);)printf(\"%d\\n\",\"$$$$$$2-($$,'&$$3.3.*0+-/*;61,';61,'FA<:5@;<7?FAGB@C@;<@NID?:NID?:YTOMHSNOJRd_ZUPa\\WRPlgb]Xlgb]Xwrmk\"[n]-36);}"
  },
  {
    "language": "C",
    "code": "main(){puts(\"14\\n9\\n4\\n83\\n71\\n73\\n34\\n42\\n59\");};"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==99)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 99 && i == 4){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint t[9] = {6,7,8,36,56,77,96,98,99};\n\tint a[9] = {14,9,4,34,42,59,83,73,71};\n\tint c,i;\n\twhile(~scanf(\"%d\",&c)){\n\t\tfor(i=0;i<9;i++){\n\t\t\tif(c == t[i]){\n\t\t\t\tprintf(\"%d\\n\",a[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<5000000;i++){\n\t\tt[i%9] = i;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==93)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 56 && i == 5){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==95)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=70 && n < 80)c++;\n\t}\n\treturn (c>=2?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){puts(\"14\\n9\\n4\\n34\\n42\\n59\\n83\\n73\\n71\");}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n <= 8)c++;\n\t}\n\treturn (c>=3?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==56)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=60 && n < 70)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n>=90 && n < 100)c++;\n\t}\n\treturn (c>=3?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n <= 9)c++;\n\t}\n\treturn (c>=3?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tc++;\n\t}\n\treturn (c==9?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint c = 0 , n , i;\n\tfor(i=0;i<9;i++){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 8 && i == 2){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n >=10 &&n<20)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "C",
    "code": "main(){\n\tint n,c=0;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==49)c++;\n\t}\n\treturn (c?1:0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * プログラミングコンテスト<br>\n * 0147:Fukushimaken\n *\n * @author t690593\n *\n */\npublic class Fukushimaken {\n\n\t/** 最大グループ数 */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** 客の到着間隔 */\n\tstatic final int TIME_INTERVAL = 5;\n\n\t/** 座席 */\n\tstatic int[] sheets = new int[17];\n\n\t/** 各グループの待ち時間 */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** インプット */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** インプットの最大グループ番号 */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * メイン\n\t *\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\t// 先頭のグループ番号\n\t\tint frontGroup = 0;\n\t\t// 最後尾のグループ番号\n\t\tint endGroup = 0;\n\t\t// 経過時間：分単位\n\t\tint time = 0;\n\n\t\twhile (true) {\n\t\t\t// 5分間隔でお店に客がくる（最後尾は最大グループ数より大きくならない）\n\t\t\tif (time % TIME_INTERVAL == 0 && endGroup < MAX_GROUP_NUKMBER) {\n\t\t\t\tendGroup++;\n\t\t\t}\n\n\t\t\tfor (int i = frontGroup; i < endGroup; i++) {\n\t\t\t\tint ninzu = i % 5 == 1 ? 5 : 2;\n\t\t\t\tint startPos = getOpendSheetsPosition(ninzu);\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// 座れる場合\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(i), ninzu);\n\t\t\t\t\twaitTimes[i] = time - i * 5;\n\t\t\t\t\tfrontGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 座れない場合\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 入力されたグループ番号の最大番号が席に座るか、全てのグループが席に座ったら終了\n\t\t\tif (frontGroup == MAX_GROUP_NUKMBER || frontGroup > maxGroupNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 座席の食事時間を時間経過とともに減らす\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] = sheets[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * 空いている席の最初の席番号を返却する<br>\n\t * 席が空いていない場合、-1を返却する\n\t *\n\t * @param peopleNum\n\t *            グループの人数\n\t * @return 空いている席の最初の席番号\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * 対象グループの食事時間を計算する\n\t *\n\t * @param targetGroup\n\t *            対象グループ番号\n\t * @return 食事間\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * 座席を確保する\n\t *\n\t * @param startPos\n\t *            席確保する最初の席番号\n\t * @param mealtime\n\t *            確保する時間（食事時間）\n\t * @param peopleNum\n\t *            グループ人数\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic void run() {\n\t\tint[] ans = new int[100];\n\t\t\n\t\tPriorityQueue<Event> pq = new PriorityQueue<Event>();\n\t\tint[] table = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tint nextGroup = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tEvent e = new Event();\n\t\t\te.id = i;\n\t\t\te.move = Event.ARRIVE;\n\t\t\te.initTime = i * 5;\n\t\t\te.time = i * 5;\n\t\t\te.num = i % 5 == 1 ? 5 : 2;\n\t\t\te.duration = 17*(i%2) + 3*(i%3)+19;\n\t\t\tpq.add(e);\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEvent e = pq.poll();\n\t\t\tif (e.move == Event.LEAVE) {\n\t\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\t\tif (table[i] == e.id) table[i] = -1;\n\t\t\t\t}\n\t\t\t} else if (e.move == Event.ARRIVE) {\n\t\t\t\tint pos = -1;\n\t\t\t\tif (nextGroup == e.id) {\n\t\t\t\t\tfor (int i = 0; i + e.num <= table.length; i++) {\n\t\t\t\t\t\tboolean ok = true;\n\t\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\t\tif (table[i+j] != -1) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t// 座る\n\t\t\t\t\tans[e.id] = e.time - e.initTime;\n\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\ttable[pos + j] = e.id;\n\t\t\t\t\t}\n\t\t\t\t\te.time += e.duration;\n\t\t\t\t\te.move = Event.LEAVE;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t\tnextGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 空いてなければ待つ。時刻+1して席が空くのを待つ手抜き実装\n\t\t\t\t\te.time++;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(ans[n]);\n\t\t}\n\t}\n\t\n\tclass Event implements Comparable<Event> {\n\t\tstatic final int LEAVE = 0;\n\t\tstatic final int ARRIVE = 1;\n\t\tint id;\n\t\tint initTime;\n\t\tint move;\n\t\tint time;\n\t\tint num;\n\t\tint duration;\n\t\t@Override\n\t\tpublic int compareTo(Event o) {\n\t\t\tint c = time - o.time;\n\t\t\tif (c == 0) c = move - o.move;\n\t\t\tif (c == 0) c = id - o.id;\n\t\t\treturn c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 0147:Fukushimaken\n * \n * @author MS14A\n * @version 2015/05/09\n */\npublic class Main {\n\n    private static int[] seatWaitTime = new int[17];\n\n    /**\n     * メインメソッド\n     * \n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n\n        List<Integer> inputGroupNumbers = getGroupNumbers();\n\n        for (Integer inputGroupNumber : inputGroupNumbers) {\n            Arrays.fill(seatWaitTime, 0);\n\n            System.out.println(getWaitingTime(inputGroupNumber.intValue()));\n        }\n    }\n\n    private static int getWaitingTime(int inputGroupNumber) {\n\n        boolean canSit = false;\n        List<Integer> waitingGroups = new ArrayList<Integer>();\n        int groupNumber = 0;\n\n        int time = 0;\n        int waitingStartTime = 0;\n        int waitingEndTime = 0;\n\n        while (!canSit) {\n            // 食事時間を一分進める\n            for (int seatTime : seatWaitTime) {\n                if (seatTime > 0) {\n                    seatTime -= 1;\n                }\n            }\n\n            // グループが来る\n            if (time % 5 == 0) {\n                groupNumber = time / 5;\n                waitingGroups.add(Integer.valueOf(groupNumber));\n\n                if (groupNumber == inputGroupNumber) {\n                    waitingStartTime = time;\n                }\n            }\n\n            if (!waitingGroups.isEmpty()) {\n                // 座れる場合は待ちリストから削除していく\n                canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n\n                while (canSit) {\n                    if (waitingGroups.get(0) == inputGroupNumber) {\n                        waitingEndTime = time;\n                        break;\n                    }\n                    waitingGroups.remove(0);\n                    if (waitingGroups.isEmpty()) {\n                        canSit = false;\n                    } else {\n                        canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n                    }\n                }\n            }\n\n            ++time;\n        }\n\n        return waitingEndTime - waitingStartTime;\n    }\n\n    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {\n        int count = 0;\n        for (int i = 0; i < seatWaitTime.length; ++i) {\n            if (seatWaitTime[i] == 0) {\n                count += 1;\n                if (count == NumberOfGroupMember) {\n                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);\n                    return true;\n                }\n            } else {\n                count = 0;\n            }\n        }\n\n        return false;\n    }\n\n    private static int getNumberOfGuy(int groupNumber) {\n        if (groupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    private static int getEatingTime(int groupNumber) {\n        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;\n    }\n\n    private static List<Integer> getGroupNumbers() throws IOException {\n        // 入力読取り\n        InputStreamReader streamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(streamReader);\n\n        String line = null;\n        List<Integer> groupNumbers = new ArrayList<Integer>();\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                groupNumbers.add(Integer.parseInt(line));\n            }\n            return groupNumbers;\n        } finally {\n            bufferedReader.close();\n            streamReader.close();\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\tint [][] data;\n\tint [] table;\n\tLinkedList<Integer> mat;\n\t\n\tprivate void doit(){\n\t\tdata = new int[100][2];\n\t\tinit();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(data[n][1] - data[n][0]);\n\t\t}\n\t}\n\n\tprivate void init() {\n\t\ttable = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tmat = new LinkedList<Integer>();\n\t\tfor(int i = 0;; i++){\n\t\t\tif(i != 0 && isOK()) break;\n\t\t\tout(i);\n\t\t\tif(i % 5 == 0 && i / 5  < 100){\n\t\t\t\tdata[i / 5][0] = i;\n\t\t\t\tmat.addLast(i / 5);\n\t\t\t}\n\t\t\twhile(in(i)){\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tprivate boolean in(int time) {\n\t\tif(mat.isEmpty()) return false;\n\t\tint nextid = mat.getFirst();\n\t\tint num = 0;\n\t\tif(nextid % 5 == 1){\n\t\t\tnum = 5;\n\t\t}\n\t\telse{\n\t\t\tnum = 2;\n\t\t}\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1) continue;\n\t\t\tint now = 1;\n\t\t\tfor(int j = i + 1; j < table.length; j++){\n\t\t\t\tif(table[j] == -1){\n\t\t\t\t\tnow++;\n\t\t\t\t\tif(now == num){\n\t\t\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\t\t\ttable[i + k] = nextid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[nextid][1] = time;\n\t\t\t\t\t\tmat.removeFirst();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void out(int time) {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] >= 0){\n\t\t\t\tint id = table[i];\n\t\t\t\tint res = data[id][1] + 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t\t\tif(res == time){\n\t\t\t\t\ttable[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK() {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * プログラミングコンテスト<br>\n * 0147:Fukushimaken\n *\n * @author t690593\n *\n */\npublic class Main {\n\n\t/** 最大グループ数 */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** 客の到着間隔 */\n\tstatic final int TIME_INTERVAL = 5;\n\n\t/** 座席 */\n\tstatic int[] sheets = new int[17];\n\n\t/** 各グループの待ち時間 */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** インプット */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** インプットの最大グループ番号 */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * メイン\n\t *\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\t// 先頭のグループ番号\n\t\tint frontGroup = 0;\n\t\t// 最後尾のグループ番号\n\t\tint endGroup = 0;\n\t\t// 経過時間：分単位\n\t\tint time = 0;\n\n\t\twhile (true) {\n\t\t\t// 5分間隔でお店に客がくる（最後尾は最大グループ数より大きくならない）\n\t\t\tif (time % TIME_INTERVAL == 0 && endGroup < MAX_GROUP_NUKMBER) {\n\t\t\t\tendGroup++;\n\t\t\t}\n\n\t\t\tfor (int i = frontGroup; i < endGroup; i++) {\n\t\t\t\tint ninzu = i % 5 == 1 ? 5 : 2;\n\t\t\t\tint startPos = getOpendSheetsPosition(ninzu);\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// 座れる場合\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(i), ninzu);\n\t\t\t\t\twaitTimes[i] = time - i * 5;\n\t\t\t\t\tfrontGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 座れない場合\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 入力されたグループ番号の最大番号が席に座るか、全てのグループが席に座ったら終了\n\t\t\tif (frontGroup == MAX_GROUP_NUKMBER || frontGroup > maxGroupNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 座席の食事時間を時間経過とともに減らす\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] = sheets[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * 空いている席の最初の席番号を返却する<br>\n\t * 席が空いていない場合、-1を返却する\n\t *\n\t * @param peopleNum\n\t *            グループの人数\n\t * @return 空いている席の最初の席番号\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * 対象グループの食事時間を計算する\n\t *\n\t * @param targetGroup\n\t *            対象グループ番号\n\t * @return 食事間\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * 座席を確保する\n\t *\n\t * @param startPos\n\t *            席確保する最初の席番号\n\t * @param mealtime\n\t *            確保する時間（食事時間）\n\t * @param peopleNum\n\t *            グループ人数\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput < sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れる。\n                        firstCustomer = true;\n                        groupCount = groupInfo.size();\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** １グループの人数 */\n    public static final int[] numInGroupList = {2, 5, 2, 2, 2};\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime;\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        waitingTime = new int[GROUP_NUM];\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (Integer i : inputList) {\n            System.out.println(waitingTime[i]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客の到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = numInGroupList[headGroupNo % numInGroupList.length];\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // ?????????????????£???????????????????´????????????????\n        List<String> waitingCustomersList = new ArrayList<String>();\n\n        List<String> list = new ArrayList<String>();\n\n        List<String> waitingStartTimeList = new ArrayList<String>();\n\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // ??\\???????????????null???????????????????????????????????????????????????\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // ?£????????????£?????¢??????????????£??????????????????\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // ?????£????????????????????§??£????????????\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n                waitingStartTimeList.remove(0);\n            }\n            // ??¢?????????\n            if (timeGoesBy % 5 == 0) {\n                // ??¢????????°???????????????\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // ???????????????????????????????????????????????????\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // ??¢???????????§?????????????????????????????§????????°???????????????\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // ??¢????????°???????????????\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ?£????????????£?????¢??????????????????\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n                seats[count][1] = 0;\n                seats[count][2] = 0;\n\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ??§?????° */\n\tprivate final static int SEATS = 17;\n\n\t/** ??¢??°???????????° */\n\tprivate final static int GROUP = 10;\n\n\t/** ??¢??°??????????????°???????????????????????? */\n\tprivate final static int INTERVAL = 5;\n\n\t/** ??¢??°???????????????????????????????´????????????? */\n\tprivate static int[] watingTimes = new int[GROUP];\n\n\t/** ??¢??°??????????????°?????????????????°????£?????????????????´???????????¬?????????? */\n\tprivate static int[][] groupInfo = new int[GROUP][3];\n\n\t/** ??¢??°??????????????°??????????????¨???????????? */\n\tprivate final static int GROUP_INFO_ARRIVAL = 0;\n\n\t/** ??¢??°?????????????????°?????¨???????????? */\n\tprivate final static int GROUP_INFO_PERSONS = 1;\n\n\t/** ??¢??°?????????????£???????????????¨???????????? */\n\tprivate final static int GROUP_INFO_EATING_MINUTES = 2;\n\n\t/** ??§??????????????¶??????????´????????????? */\n\tprivate static int[] seatsCondition = new int[SEATS];\n\n\t/** ???????????????????????????????????? */\n\tprivate static boolean openFlag = true;\n\n\t/** ???????????°???????????°????????? */\n\tprivate static int lastArrivalGroup = -1;\n\n\t/** ????????°???????????° */\n\tprivate static int watingGroups = 0;\n\n\t/** ??£????????????????????????????????? */\n\tprivate static int passedMinutes = 0;\n\n\t/**\n\t * ???????????????????¨?????????¢??°??????????????????????????????????????????\n\t *\n\t * @param args\n\t *            ?????¨????????????\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\t// ??\\?????????????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n        String line = null;\n        while((line = br.readLine()) != null) {\n            inputList.add(Integer.parseInt(line));\n        }\n\n\t\t// ??¨??¢??°??????????????°???????????¨?????°??¨?£??????????????±???????\n\t\tsetGroupInfo();\n\n\t\twhile (openFlag) {\n\n\t\t\t// ???????????§?¬??????°??????????????°?????????\n\t\t\tif (passedMinutes % INTERVAL == 0) {\n\t\t\t\tlastArrivalGroup++;\n\t\t\t\twatingGroups++;\n\t\t\t}\n\n\t\t\t// ????????°??????????????????????????°???????????????\n\t\t\tif (watingGroups == 0) {\n\t\t\t\tpassedMinutes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean vacancyFlag = true; // ??????????????¨?????????\n\t\t\tint nextGroup = lastArrivalGroup - watingGroups + 1; // ????????????????????°???????????????\n\n\t\t\t// ????????°???????????????????????????????????¨????????´????????????????????????????????????????????§????????????\n\t\t\twhile (watingGroups != 0 && vacancyFlag) {\n\t\t\t\tint numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS]; // ???????????°?????????????????°\n\n\t\t\t\t// ???????????°????????????????????§????????§????????????????±???????\n\t\t\t\tint seatNumber = getSeatNumber(numberOfPersons);\n\n\t\t\t\tif (seatNumber != -1) {\n\n\t\t\t\t\t// ????????§????????§???????????£?????´????????§??????????????????????¨??????????\n\t\t\t\t\tfor (int i = 0; i < numberOfPersons; i++) {\n\t\t\t\t\t\tseatsCondition[seatNumber] = passedMinutes\n\t\t\t\t\t\t\t\t+ groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n\t\t\t\t\t\tseatNumber++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??°????????????????????????????¨??????????\n\t\t\t\t\twatingTimes[nextGroup] = passedMinutes\n\t\t\t\t\t\t\t- groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n\t\t\t\t\t// ????????°???????????°????????????\n\t\t\t\t\twatingGroups--;\n\t\t\t\t\tnextGroup = lastArrivalGroup - watingGroups + 1;\n\t\t\t\t} else {\n\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpassedMinutes++;\n\n\t\t\t// ???????????°??????????????§??£??????????????????????????????\n\t\t\tif (nextGroup == GROUP - 1) {\n\t\t\t\topenFlag = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i : inputList) {\n\t\t\tSystem.out.println(watingTimes[i]);\n\t\t}\n\t}\n\n\tprivate static void setGroupInfo() {\n\n\t\tfor (int i = 0; i < GROUP; i++) {\n\t\t\tgroupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n\t\t\tgroupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n\t\t\tgroupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n\t\t\t\t\t* (i % 3) + 19;\n\t\t}\n\n\t}\n\n\tprivate static int getSeatNumber(int numberOfPersons) {\n\n\t\tint seatNumber = 0; // ???????????§?????????\n\t\tint vacancySeats = 0; // ????????°\n\n\t\tfor (int i = 0; i < SEATS; i++) {\n\n\t\t\t// ??????????????¨?????£?????§?????????????????????\n\t\t\tif (seatsCondition[i] <= passedMinutes) {\n\t\t\t\tseatsCondition[i] = 0;\n\t\t\t}\n\n\t\t\tif (seatsCondition[i] == 0) {\n\n\t\t\t\t// ??????????????§????????°???????????°????¢???????\n\t\t\t\tvacancySeats++;\n\n\t\t\t\t// ????????°??????????????°??¨??????????????°??????????????§??????????????????\n\t\t\t\tif (vacancySeats == numberOfPersons) {\n\t\t\t\t\treturn seatNumber;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// ??????????????§???????????°?????§?????????????¬?????§???????????????°???0?????????\n\t\t\t\tseatNumber = i + 1;\n\t\t\t\tvacancySeats = 0;\n\t\t\t}\n\t\t}\n\n\t\t// ????????????????????°-1?????????\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\t/** ??°???????????° */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** ??§????????? */\n\tstatic int[] sheets = new int[17];\n\n\t/** ?????????????????? */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** ???????????? */\n\tstatic Map<Integer, Integer> waitLine = new LinkedHashMap<Integer, Integer>();\n\n\t/** ??????????±? */\n\tstatic Set<Integer> deleteTarget = new HashSet<Integer>();\n\n\t/** ??????????????? */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** ?????§??°??????????????? */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\t// ?????¨?????°???????????°\n\t\tint groupNumber = -1;\n\n\t\tint sentou = 0;\n\n\t\t// ??????????????????????????????\n\t\tint time = 0;\n\t\twhile (groupNumber < MAX_GROUP_NUKMBER) {\n\t\t\tif (time % 5 == 0) {\n\t\t\t\tgroupNumber++;\n\t\t\t}\n\n\t\t\t// ??¢????????¢\n\t\t\tfor (int i = sentou; i <= groupNumber; i++) {\n\t\t\t\tint ninzu = i % 5 == 1 ? 5 : 2;\n\t\t\t\tint startPos = getOpendSheetsPosition(ninzu);\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// ??§????????´???\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(i),\n\t\t\t\t\t\t\tninzu);\n\t\t\t\t\twaitTimes[i] = time - i * 5;\n\t\t\t\t\tsentou++;\n\t\t\t\t} else {\n\t\t\t\t\t// ??§???????????´???\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ??§??????????????????????????????????????????\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] = sheets[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * ????????????????????????????????????????????´????????? ??????????????????????????´??????-1????????´?????????\n\t *\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t * @return ????????????????????????????????????\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??°?????????????????????????£??????????????¨??????????\n\t *\n\t * @param targetGroup\n\t *            ????±??????°???????????????\n\t * @return ?£??????????\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * ???????¢?????????????\n\t *\n\t * @param startPos\n\t *            ????¢?????????????????????????\n\t * @param mealtime\n\t *            ?£??????????\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n        int groupMember = 0; // 入店したグループ人数\n        int blankStartSeatNo = -1; // 空席No\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            int waitGroupSize = queueStatusList.size();\n\n            for (int i = 0; i < waitGroupSize; i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList.peek(), baseTime, blankStartSeatNo,\n                            n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.remove();\n\n                } else {\n\n                    // 座れる座席なし\n                    break;\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(seatNo);\n\n        for (int i = 0; i < seatNo; i++) {\n            GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        for (int i = 0; i < 17; i++) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatusMap.get(i).endStayTime = time;\n\n                if ((seatStatusMap.get(i).endStayTime - seatStatusMap.get(i).startStayTime) == getMealTime(seatStatusMap\n                    .get(i).groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.get(i).groupNo = -1;\n                    seatStatusMap.get(i).groupMember = 0;\n                    seatStatusMap.get(i).startStayTime = 0;\n                    seatStatusMap.get(i).endStayTime = 0;\n                    seatStatusMap.get(i).isStay = false;\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap, GroupStatus queueStatus,\n            int baseTime, int blankStartSeatNo, int n) {\n\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\npublic class Main{\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n\n        exec();\n    }\n\n    private static void exec() throws NumberFormatException, IOException {\n\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        String line; // 引数行\n\n        while ((line = br.readLine()) != null) {\n\n            int n = Integer.parseInt(line);\n            int baseTime = 0; // 基準時間\n            int addGroupNo = -1; // 入店したグループNo\n            int groupMember = 0; // 入店したグループ人数\n            int blankStartSeatNo = -1; // 空席No\n\n            // 座席状態の初期化\n            Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n            // 待ち行列の初期化\n            LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n            while (addGroupNo < n) {\n\n                // 座席の状態更新\n                updateSeatStatus(seatStatusMap, baseTime);\n\n                // 待ち行列の状態更新\n                updateQueueStatus(queueStatusList, baseTime);\n\n                int waitGroupSize = queueStatusList.size();\n\n                for (int i = 0; i < waitGroupSize; i++) {\n\n                    // 待ち行列の先頭グループ人数取得\n                    groupMember = queueStatusList.peek().groupMember;\n\n                    // 空席シートNoの取得\n                    blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                    if (blankStartSeatNo >= 0) {\n\n                        // 座席に先頭グループ追加\n                        addGroupNo =\n                            addSeat(seatStatusMap, queueStatusList.peek(), baseTime,\n                                blankStartSeatNo, n);\n\n                        // 待ち行列の先頭グループ削除\n                        queueStatusList.remove();\n\n                    } else {\n\n                        // 座れる座席なし\n                        break;\n                    }\n                }\n\n                baseTime++;\n            }\n\n        }\n\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(17);\n        seatStatusMap.put(0, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(1, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(2, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(3, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(4, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(5, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(6, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(7, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(8, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(9, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(10, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(11, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(12, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(13, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(14, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(15, new GroupStatus(-1, 0, 0, 0, false));\n        seatStatusMap.put(16, new GroupStatus(-1, 0, 0, 0, false));\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        for (int i = 0; i < 17; i++) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatusMap.get(i).endStayTime = time;\n\n                if ((seatStatusMap.get(i).endStayTime - seatStatusMap.get(i).startStayTime) == getMealTime(seatStatusMap\n                    .get(i).groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.get(i).groupNo = -1;\n                    seatStatusMap.get(i).groupMember = 0;\n                    seatStatusMap.get(i).startStayTime = 0;\n                    seatStatusMap.get(i).endStayTime = 0;\n                    seatStatusMap.get(i).isStay = false;\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap, GroupStatus queueStatus,\n            int baseTime, int blankStartSeatNo, int n) {\n\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\t\t// ?????????????????????\n\t\tList<Integer> output = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\t\t\t// ??????\n\t\t\tint time = 0;\n\t\t\t// ?????????\n\t\t\tboolean result = true;\n\n\t\t\t// ?????????\n\t\t\twhile (result) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\twhile (waitGuest.size() > 0)  {\n\t\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\t\toutput.add(time - (waitGuest.get(0) * 5));\n\t\t\t\t\t\t\t\toutputWaitTime(output);\n\t\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void outputWaitTime(List<Integer> output){\n\t\tfor (int outputNum : output) {\n\t\t\tSystem.out.println(outputNum);\n\t\t}\n\t}\n\n\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 座席数 */\n\tprivate static final int SEAT_NUM = 17;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 着席可能の最初の座席番号 */\n\tprivate static int firstSeatNum;\n\n\t/** 待ち時間 */\n\tprivate static int[] waitMinutes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[SEAT_NUM];\n\n\t\t// 待ち時間を作成\n\t\tcalcuWaitMinutes();\n\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** グループの人数を取得する */\n\tprivate static int getCustomerNum(int i) {\n\t\treturn i % 5 == 1 ? 5 : 2;\n\t}\n\n\t/** グループの到着時間を取得する */\n\tprivate static int getArrivedMinutes(int i) {\n\t\treturn 5 * i;\n\t}\n\n\t/** グループの食事時間を取得する */\n\tprivate static int getMealMinutes(int i) {\n\t\treturn SEAT_NUM * (i % 2) + 3 * (i % 3) + 19;\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void calcuWaitMinutes() {\n\t\t// 順番\n\t\tint groupOrder;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = arrivedCustomer(currentMinutes)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder));\n\n\t\t\t\t\t\ttotalGroupNum++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\ttotalGroupNum++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitMinutes[wait] = currentMinutes\n\t\t\t\t\t\t\t\t- getArrivedMinutes(wait);\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int currentMinutes) {\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tif (getArrivedMinutes(i) == currentMinutes) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seat)) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupOrder) {\n\n\t\tfor (int count = 0; count < getCustomerNum(Integer.parseInt(groupOrder)); count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席の場合、trueを返す */\n\tprivate static boolean isEmpty(int groupOrder) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\t// 座席番号\n\t\tint seatOrder = 0;\n\n\t\tfor (; seatOrder < SEAT_NUM\n\t\t\t\t|| getCustomerNum(groupOrder) <= SEAT_NUM - seatOrder; seatOrder++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == getCustomerNum(groupOrder)) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (seats[seatOrder] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (emptyseatsNum == getCustomerNum(groupOrder)) {\n\t\t\t// 空席の最初の座席番号を設定する\n\t\t\tfirstSeatNum = seatOrder - emptyseatsNum;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** 食事の時間が終了した席の場合、trueを返す */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (getArrivedMinutes(Integer.parseInt(seat)) + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= getMealMinutes(Integer\n\t\t\t\t\t.parseInt(seat));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n\n            // 入力\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetAndResult = new LinkedHashMap<Integer, Integer>();\n            while (sc.hasNext()) {\n                targetAndResult.put(sc.nextInt(), 0);\n            }\n\n            // 席\n            int[] chairs = new int[17];\n            // 待ち行列\n            Deque<Integer> customers = new LinkedList<Integer>();\n            // 店に来た客グループ数\n            int cameGroupCount = 0;\n            // 経過時間数\n            int pastMinutes = 0;\n            // 座れた客グループ数\n            int sitGroupCount = 0;\n\n            // 1ループ = 1分\n            while (sitGroupCount <= 100) {\n\n                // 客が来る\n                boolean isCustomerCame = comeCustomer(customers, pastMinutes,\n                        cameGroupCount);\n\n                // 食べる\n                eat(chairs);\n\n                // 席に着く\n                int sitCustomerOnMinute = sit(chairs, customers, cameGroupCount);\n\n                // 後処理\n                if (isCustomerCame) {\n                    cameGroupCount++;\n                }\n\n                // 座れた人の時間の計測\n                for (int i = 1; i <= sitCustomerOnMinute; i++) {\n                    if (targetAndResult.containsKey(sitGroupCount)) {\n                        int waitMinutes = pastMinutes - (5 * (sitGroupCount));\n\n                        targetAndResult.put(sitGroupCount, waitMinutes);\n                    }\n\n                    sitGroupCount++;\n                }\n\n                pastMinutes++;\n\n            }\n\n            for (Entry<Integer, Integer> entry : targetAndResult.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static boolean comeCustomer(Deque<Integer> customers, int minutes,\n            int cameGroupCount) {\n        if (cameGroupCount > 100) {\n            // 100人までしか来ない\n            return false;\n        }\n\n        if (minutes % 5 == 0) {\n            // 5分後に到着する\n            if (cameGroupCount % 5 == 1) {\n                // i%5 = 1のとき5人到着\n                customers.offer(5);\n            } else {\n                // それ以外は2人到着\n                customers.offer(2);\n            }\n            // 客が来た\n            return true;\n        }\n\n        // 客が来なかった\n        return false;\n    }\n\n    private static void eat(int[] chairs) {\n        for (int i = 0; i < chairs.length; i++) {\n            chairs[i] = (chairs[i] - 1) < 0 ? 0 : chairs[i] - 1;\n        }\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> customers,\n            int cameGroupCount) {\n        int sitGroupCount = 0;\n\n        Integer firstCustomersNumber = customers.peek();\n\n        if (firstCustomersNumber == null) {\n            // 客が待っていない場合には何もしない\n            return sitGroupCount;\n        }\n\n        int sequencialChair = 0;\n        int sittableChairStart = 0;\n        boolean sittable = false;\n        for (int i = 0; i < chairs.length; i++) {\n            // 席が空いているかどうかを判定\n            if (chairs[i] == 0) {\n                sequencialChair++;\n            } else {\n                sequencialChair = 0;\n            }\n\n            if (sequencialChair >= firstCustomersNumber) {\n                // 連続した席数が必要数に達していたら、その時点のインデックスを返却\n                sittableChairStart = i - (firstCustomersNumber - 1); // 必要席数なので、-1\n                sittable = true;\n                break;\n            }\n        }\n\n        if (!sittable) {\n            // 座れる席が無かった\n            return sitGroupCount;\n        }\n\n        // 待ち行列から削除して座れた扱いとする\n        sitGroupCount++;\n        customers.poll();\n\n        for (int j = 0; j < firstCustomersNumber; j++) {\n            // 席に所要時間をカウント\n            chairs[j + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れる可能性があるので、再帰呼出し\n        sitGroupCount += sit(chairs, customers, cameGroupCount);\n\n        // 座れた\n        return sitGroupCount;\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] == currentTime\n                    - arriveTime[Integer.parseInt(seat)] + waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 到着時間を入店時間に入れ替える\n                        arriveTime[wait] = currentTime;\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NewFukushimaken {\n\n\t/*** ??°??????????????° */\n\tprivate static final int GROUP_NUM = 100;\n\n\tprivate static BufferedReader br;\n\tprivate static int placeNum;\n\tprivate static int[] arriveTime, customerNum, mealTime, waitTime;\n\n\t/*** ??? */\n\tprivate static String[] places;\n\tprivate static int finalPlace;\n\n\t/*** ????????? */\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tplaceNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomerNum = new int[GROUP_NUM];\n\t\tmealTime = new int[GROUP_NUM];\n\t\twaitTime = new int[GROUP_NUM];\n\t\tplaces = new String[placeNum];\n\n\t}\n\n\t/**\n\t * ?????????????????????\n\t *\n\t * @param args\n\t *            ??????????????°\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\t// ??\\???\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\texe(inputList);\n\n\t\t// ??????\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTime[input]);\n\t\t}\n\n\t}\n\n\tprivate static void exe(List<Integer> inputList) {\n\t\t// ?????????\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tarriveTime[i] = 5 * i;\n\t\t\tcustomerNum[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tmealTime[i] = placeNum * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\n\t\tint key;\n\n\t\t// ????????¢?????????\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// ??\\?????¢?????????\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\t// ??°??????????????¨?????????????????????????????????????????????\n\t\tfor (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n\n\t\t\toutStore(currentTime);\n\n\t\t\t// ?????????????????°????????????\n\t\t\tif ((key = search(arriveTime, currentTime)) != -1) {\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\tif (isEmpty(key)) {\n\t\t\t\t\t\tset(Integer.toString(key));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitList.add(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitList.add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// ???????????¢???????????´???\n\t\t\t\tint i = 0;\n\t\t\t\tboolean flg = true;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\tif (isEmpty(wait) && flg) {\n\t\t\t\t\t\tset(Integer.toString(wait));\n\t\t\t\t\t\twaitTime[wait] = currentTime - arriveTime[wait];\n\t\t\t\t\t\tremoveList.add(i);\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\tCollections.reverse(removeList);\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// ??\\???????????¢???????????¢???????????????????????????\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int search(int[] targets, int currentTime) {\n\t\tint i = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??????????????£?????°?????????????????????????????????\n\t *\n\t */\n\tprivate static void outStore(int currentTime) {\n\t\tint i = 0;\n\t\tfor (String place : places) {\n\t\t\tif (place == null) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mealTime[Integer.parseInt(place)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(place)]) {\n\t\t\t\tplaces[i] = null;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\t/**\n\t * ??°?????????????????§???????¨??????????\n\t *\n\t * @param groupNum\n\t *            ??°???????????????\n\t */\n\tprivate static void set(String groupNum) {\n\n\t\tfor (int i = finalPlace - 1, count = 0; count < customerNum[Integer\n\t\t\t\t.parseInt(groupNum)]; i--, count++) {\n\t\t\tplaces[i] = groupNum;\n\t\t}\n\t}\n\n\t/**\n\t * ?????°?????°?????????????????°?????§?????????????????????????????????\n\t *\n\t * @param groupNum\n\t *            ??°?????????????????°\n\t * @return true : ??§?????? false : ??§?????????\n\t */\n\tprivate static boolean isEmpty(int groupNum) {\n\n\t\t// ????????°\n\t\tint emptyPlaceNum = 0;\n\n\t\tfor (int i = 0; i < placeNum; i++) {\n\t\t\tif (emptyPlaceNum == customerNum[groupNum]) {\n\t\t\t\tfinalPlace = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (places[i] == null) {\n\t\t\t\temptyPlaceNum++;\n\t\t\t} else {\n\t\t\t\temptyPlaceNum = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n\n        Scanner sc = new Scanner(System.in);\n\n        List<Integer> inputted = new ArrayList<Integer>();\n        int maxInputted = -1;\n        while (sc.hasNext()) {\n            int ni = sc.nextInt();\n            maxInputted = maxInputted < ni ? ni : maxInputted;\n            inputted.add(ni);\n        }\n\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= maxInputted) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        for (int input : inputted) {\n            System.out.println(waitTime.get(input));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(i+\": ATIME\"+atime[i]+\" NUM\"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=ex(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\t//disp(seat,min);\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<=17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] ex(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ??§?????° */\n\tprivate final static int SEATS = 17;\n\n\t/** ??¢??°???????????° */\n\tprivate final static int GROUP = 100;\n\n\t/** ??¢??°??????????????°???????????????????????? */\n\tprivate final static int INTERVAL = 5;\n\n\t/** ??¢??°???????????????????????????????´????????????? */\n\tprivate static int[] watingTimes = new int[GROUP];\n\n\t/** ??¢??°??????????????°?????????????????°????£?????????????????´???????????¬?????????? */\n\tprivate static int[][] groupInfo = new int[GROUP][3];\n\n\t/** ??¢??°??????????????°??????????????¨???????????? */\n\tprivate final static int GROUP_INFO_ARRIVAL = 0;\n\n\t/** ??¢??°?????????????????°?????¨???????????? */\n\tprivate final static int GROUP_INFO_PERSONS = 1;\n\n\t/** ??¢??°?????????????£???????????????¨???????????? */\n\tprivate final static int GROUP_INFO_EATING_MINUTES = 2;\n\n\t/** ??§??????????????¶??????????´????????????? */\n\tprivate static int[] seatsCondition = new int[SEATS];\n\n\t/** ???????????????????????????????????? */\n\tprivate static boolean openFlag = true;\n\n\t/** ???????????°???????????°????????? */\n\tprivate static int lastArrivalGroup = -1;\n\n\t/** ????????°???????????° */\n\tprivate static int watingGroups = 0;\n\n\t/** ??£????????????????????????????????? */\n\tprivate static int passedMinutes = 0;\n\n\t/**\n\t * ???????????????????¨?????????¢??°??????????????????????????????????????????\n\t *\n\t * @param args\n\t *            ?????¨????????????\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\t// ??\\?????????????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n        String line = null;\n        while((line = br.readLine()) != null) {\n            inputList.add(Integer.parseInt(line));\n        }\n\n\t\t// ??¨??¢??°??????????????°???????????¨?????°??¨?£??????????????±???????\n\t\tsetGroupInfo();\n\n\t\twhile (openFlag) {\n\n\t\t\t// ???????????§?¬??????°??????????????°?????????\n\t\t\tif (passedMinutes % INTERVAL == 0) {\n\t\t\t\tlastArrivalGroup++;\n\t\t\t\twatingGroups++;\n\t\t\t}\n\n\t\t\t// ????????°??????????????????????????°???????????????\n\t\t\tif (watingGroups == 0) {\n\t\t\t\tpassedMinutes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean vacancyFlag = true; // ??????????????¨?????????\n\t\t\tint nextGroup = lastArrivalGroup - watingGroups + 1; // ????????????????????°???????????????\n\n\t\t\t// ????????°???????????????????????????????????¨????????´????????????????????????????????????????????§????????????\n\t\t\twhile (watingGroups != 0 && vacancyFlag) {\n\t\t\t\tint numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS]; // ???????????°?????????????????°\n\n\t\t\t\t// ???????????°????????????????????§????????§????????????????±???????\n\t\t\t\tint seatNumber = getSeatNumber(numberOfPersons);\n\n\t\t\t\tif (seatNumber != -1) {\n\n\t\t\t\t\t// ????????§????????§???????????£?????´????????§??????????????????????¨??????????\n\t\t\t\t\tfor (int i = 0; i < numberOfPersons; i++) {\n\t\t\t\t\t\tseatsCondition[seatNumber] = passedMinutes\n\t\t\t\t\t\t\t\t+ groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n\t\t\t\t\t\tseatNumber++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??°????????????????????????????¨??????????\n\t\t\t\t\twatingTimes[nextGroup] = passedMinutes\n\t\t\t\t\t\t\t- groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n\t\t\t\t\t// ????????°???????????°????????????\n\t\t\t\t\twatingGroups--;\n\t\t\t\t\tnextGroup = lastArrivalGroup - watingGroups + 1;\n\t\t\t\t} else {\n\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpassedMinutes++;\n\n\t\t\t// ???????????°??????????????§??£??????????????????????????????\n\t\t\tif (nextGroup == GROUP - 1) {\n\t\t\t\topenFlag = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i : inputList) {\n\t\t\tSystem.out.println(watingTimes[i]);\n\t\t}\n\t}\n\n\tprivate static void setGroupInfo() {\n\n\t\tfor (int i = 0; i < GROUP; i++) {\n\t\t\tgroupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n\t\t\tgroupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n\t\t\tgroupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n\t\t\t\t\t* (i % 3) + 19;\n\t\t}\n\n\t}\n\n\tprivate static int getSeatNumber(int numberOfPersons) {\n\n\t\tint seatNumber = 0; // ???????????§?????????\n\t\tint vacancySeats = 0; // ????????°\n\n\t\tfor (int i = 0; i < SEATS; i++) {\n\n\t\t\t// ??????????????¨?????£?????§?????????????????????\n\t\t\tif (seatsCondition[i] <= passedMinutes) {\n\t\t\t\tseatsCondition[i] = 0;\n\t\t\t}\n\n\t\t\tif (seatsCondition[i] == 0) {\n\n\t\t\t\t// ??????????????§????????°???????????°????¢???????\n\t\t\t\tvacancySeats++;\n\n\t\t\t\t// ????????°??????????????°??¨??????????????°??????????????§??????????????????\n\t\t\t\tif (vacancySeats == numberOfPersons) {\n\t\t\t\t\treturn seatNumber;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// ??????????????§???????????°?????§?????????????¬?????§???????????????°???0?????????\n\t\t\t\tseatNumber = i + 1;\n\t\t\t\tvacancySeats = 0;\n\t\t\t}\n\t\t}\n\n\t\t// ????????????????????°-1?????????\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ????????????????????°???????????????\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ????????????????????°???????????????\n\t\t\t// ??????\n\t\t\tint time = 0;\n\n\t\t\t// ?????????\n\t\t\twhile (true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\tSystem.out.println(time - waitGuest.get(0) * 5);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????????????????????????????????????\n\n\t//\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main {\n\t/**\n\t* @param args\n\t*/\n \n\tstatic class Seat {\n\t\tpublic\tint\tb = 0;\n\t}\n\n\tstatic class Grp {\n\t\tpublic\tint\ts = 0;\n\t\tpublic\tint\te = 0;\n\t\tpublic\tint\tn = 0;\n\t\tpublic\tint\tb = 0;\n\t\tpublic\tint\tw = -1;\n\n\t\tpublic Grp(int i) {\n\t\t\tthis.s = i*5;\n\t\t\tthis.e = 17*(i%2)+3*(i%3)+19;\n\t\t\tthis.n = (i%5==1)?5:2;\n\t\t}\n\t}\n\n\tstatic class Lst {\n\t\tpublic\tint[]\td = new int[101];\n\t\tpublic\tint\t\th = 0;\n\t\tpublic\tint\t\tt = 0;\n\n\t\tpublic void add(int e) {\n\t\t\td[t++] = e;\n\t\t\tthis.sort();\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\treturn d[h+i];\n\t\t}\n\n\t\tpublic int remove(int i) {\n\t\t\tint\trmv = this.d[h];\n\t\t\tthis.d[h+i] = 0;\n\t\t\tthis.sort();\n\t\t\tthis.h++;\n\t\t\treturn rmv;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn t-h;\n\t\t}\n\n\t\tpublic void sort() {\n\t\t\tArrays.sort(d, h, t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tGrp[]\tg = new Grp[100];\n\t\tSeat\ts = new Seat();\n\t\tLst\t\te = new Lst();\n\t\tLst\t\tw = new Lst();\n\t\tint\t\to = 0;\n\t\t\n\t\tfor (int i = 0; i < g.length || w.size() > 0; i++) {\n\t\t\tint\ttm = i*5;\n\t\t\tint\teh = (e.size() > 0)?e.get(0):0;\n\n\t\t\tif (i < g.length) {\n\t\t\t\tg[i] = (g[i] == null)?new Grp(i):g[i];\n\t\t\t}\n\n\t\t\tif (eh/100 <= tm && eh != 0) {\n\t\t\t\ttm  = eh/100;\n\t\t\t\twhile (e.size() > 0) {\n\t\t\t\t\tif (e.get(0)/100 == tm) {\n\t\t\t\t\t\ts.b = s.b&(~g[e.get(0)%100].b);\n\t\t\t\t\t\te.remove(0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (w.size() > 0) {\n\t\t\t\tint\tk = w.get(0)%100;\n\n\t\t\t\tif (g[k].s > tm) break;\n\n\t\t\t\tif (isAvailableSeat(s, null, g[k])) {\n\t\t\t\t\t// グループの待ち時間を計算\n\t\t\t\t\tg[k].w = Math.max(0, tm-g[k].s);\n\n\t\t\t\t\t// グループが食べ終わる時間を追加\n\t\t\t\t\te.add((g[k].s+g[k].w+g[k].e)*100+k);\n\t\t\t\t\tw.remove(0);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tm == i*5) {\n\t\t\t\tif (i < g.length) {\n\t\t\t\t\t// 席があるかチェック\n\t\t\t\t\tif (isAvailableSeat(s, w, g[i])) {\n\t\t\t\t\t\t// グループが食べ終わる時間を追加\n\t\t\t\t\t\te.add((g[i].s+g[i].w+g[i].e)*100+i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 待っているグループリストへ追加\n\t\t\t\t\t\tw.add(g[i].s*100+i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile ((o = parseNum()) != -1) {\n\t\t\tSystem.out.println(g[o].w);\n\t\t}\n\t}\n\n\tprivate static boolean isAvailableSeat(Seat s, Lst w, Grp g) {\n\t\tboolean bSt = false;\n\t\tint\t\tbit = (1<<g.n)-1;\n\t\tint\t\tlen = (w == null)?0:w.size();\n\n\t\tfor (int i = 0; i <= 17-g.n && !bSt && len == 0; i++, bit<<=1) {\n\t\t\tif ((s.b&bit) == 0) {\n\t\t\t\ts.b = s.b|bit;\n\t\t\t\tg.b = bit;\n\t\t\t\tg.w = 0;\n\t\t\t\tbSt = true;\n\t\t\t}\n\t\t}\n\t\treturn bSt;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = -1;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tnum = (num == -1)?0:num;\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = (num == -1)?0:num;\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (skp == 0 || buf == -1) {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Main {\n\n\t// 入力なしを表す定数\n\tprivate static int NO_INPUT = -1;\n\t// 空席を表す定数\n\tprivate static int EMPTY = -1;\n\n\t// アクション定義\n\tprivate static enum Action {\n\t\tIN, OUT\n\t};\n\n\tpublic static void main(String[] args) {\n\n\t\t// ストリームを作成する\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\twhile (true) {\n\n\t\t\tint target = readNumber(reader);\n\t\t\t// 入力がない場合は終了\n\t\t\tif (target == NO_INPUT) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 初期化\n\t\t\tint[] table = { EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,\n\t\t\t\t\tEMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY,\n\t\t\t\t\tEMPTY, EMPTY };\n\n\t\t\t// 対象グループまで来店イベントを登録しておく\n\t\t\tMap<Integer, List<Event>> eventMap = new HashMap<Integer, List<Event>>();\n\t\t\tfor (int i = 0; i <= target; i++) {\n\t\t\t\tList<Event> e = new ArrayList<Event>();\n\t\t\t\te.add(new Event(i, Action.IN));\n\t\t\t\teventMap.put(i * 5, e);\n\t\t\t}\n\n\t\t\t// 待ち行列を用意する\n\t\t\tList<Wait> waitList = new ArrayList<Wait>();\n\n\t\t\t// 1秒ごとにシミュレーションを進める\n\t\t\tint waitTime = 0;\n\t\t\tfor (int i = 0;; i++) {\n\n\t\t\t\t// イベントも待ち行列もなくなったら終了\n\t\t\t\tif (eventMap.isEmpty() && waitList.isEmpty()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// イベントチェック\n\t\t\t\tif (eventMap.containsKey(i)) {\n\n\t\t\t\t\tList<Event> eventList = eventMap.get(i);\n\t\t\t\t\teventMap.remove(i);\n\n\t\t\t\t\t// 入店処理\n\t\t\t\t\tfor (Event e : eventList) {\n\n\t\t\t\t\t\tif (e.action == Action.IN) {\n\n\t\t\t\t\t\t\t// 入れるかどうかチェック\n\t\t\t\t\t\t\tint count = ((e.group) % 5 == 1) ? 5 : 2;\n\t\t\t\t\t\t\tint index = getEmptyIndex(table, count);\n\n\t\t\t\t\t\t\tif (index == NO_INPUT || !waitList.isEmpty()) {\n\t\t\t\t\t\t\t\t// 空席がない場合は待ち行列に追加する\n\t\t\t\t\t\t\t\tWait wait = new Wait(e.group, i);\n\t\t\t\t\t\t\t\twaitList.add(wait);\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// 空席がある場合は着席し帰宅イベントを登録する\n\t\t\t\t\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t\t\t\t\t\ttable[index + j] = e.group;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint outTime = i + 17 * (e.group % 2) + 3\n\t\t\t\t\t\t\t\t\t\t* (e.group % 3) + 19;\n\t\t\t\t\t\t\t\tEvent event = new Event(e.group, Action.OUT);\n\t\t\t\t\t\t\t\tList<Event> eList = eventMap.get(outTime);\n\t\t\t\t\t\t\t\tif (eList == null) {\n\t\t\t\t\t\t\t\t\teList = new ArrayList<Event>();\n\t\t\t\t\t\t\t\t\teventMap.put(outTime, eList);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teList.add(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// 出店処理\n\t\t\t\t\tfor (Event e : eventList) {\n\t\t\t\t\t\tif (e.action == Action.OUT) {\n\t\t\t\t\t\t\tfor (int j = 0; j < table.length; j++) {\n\t\t\t\t\t\t\t\tif (table[j] == e.group) {\n\t\t\t\t\t\t\t\t\ttable[j] = EMPTY;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 待ち行列が入店できるかチェックする\n\t\t\t\tList<Wait> deleteList = new ArrayList<Wait>();\n\t\t\t\tfor (Wait w : waitList) {\n\t\t\t\t\tint count = ((w.group) % 5 == 1) ? 5 : 2;\n\t\t\t\t\tint index = getEmptyIndex(table, count);\n\n\t\t\t\t\tif (index == NO_INPUT) {\n\t\t\t\t\t\t// 空きがなくなったらその時点で終了\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 空席がある場合は着席し帰宅イベントを登録する\n\t\t\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t\t\t\ttable[index + j] = w.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint outTime = i + 17 * (w.group % 2) + 3\n\t\t\t\t\t\t\t\t* (w.group % 3) + 19;\n\t\t\t\t\t\tEvent event = new Event(w.group, Action.OUT);\n\t\t\t\t\t\tList<Event> eList = eventMap.get(outTime);\n\t\t\t\t\t\tif (eList == null) {\n\t\t\t\t\t\t\teList = new ArrayList<Event>();\n\t\t\t\t\t\t\teventMap.put(outTime, eList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\teList.add(event);\n\n\t\t\t\t\t\t// 待ち行列から削除する\n\t\t\t\t\t\tdeleteList.add(w);\n\n\t\t\t\t\t\t// 調査対象のグループの場合は待ち時間を記録する\n\t\t\t\t\t\tif (w.group == target) {\n\t\t\t\t\t\t\twaitTime = i - w.start;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Wait w : deleteList){\n\t\t\t\t\twaitList.remove(w);\n\t\t\t\t}\n\n\t\t\t\t// デバッグ\n\t\t\t\t/*\n\t\t\t\tSystem.out.print(i + \": \");\n\t\t\t\tfor (int j = 0; j < table.length; j++) {\n\t\t\t\t\tSystem.out.print(table[j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out\n\t\t\t\t\t\t.println(\"Event: \" + eventMap + \", Wait: \" + waitList);\n\t\t\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\t// 結果を出力する\n\t\t\tSystem.out.println(waitTime);\n\t\t}\n\n\t}\n\n\t/**\n\t * ストリームから1行読み込んで、数値として返す。\n\t *\n\t * @param reader\n\t *            入力ストリーム\n\t * @return 数値\n\t */\n\tprivate static int readNumber(BufferedReader reader) {\n\t\tint result = 0;\n\t\ttry {\n\t\t\tString line = reader.readLine();\n\t\t\tif (line == null || line.isEmpty()) {\n\t\t\t\treturn NO_INPUT;\n\t\t\t}\n\t\t\tresult = Integer.parseInt(line);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * 空席の開始インデックスを取得する。\n\t *\n\t * @param table\n\t *            テーブル\n\t * @param count\n\t *            人数\n\t * @return 空席があればそのインデックス、なければNO_INPUTを返す\n\t */\n\tprivate static int getEmptyIndex(int[] table, int count) {\n\t\tint c = 0;\n\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\tif (table[i] == EMPTY) {\n\t\t\t\tc++;\n\t\t\t\tif (c >= count) {\n\t\t\t\t\treturn i - count + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tc = 0;\n\t\t\t}\n\t\t}\n\t\treturn NO_INPUT;\n\t}\n\n\tprivate static class Event {\n\t\tpublic int group;\n\t\tpublic Action action;\n\n\t\tpublic Event(int group, Action action) {\n\t\t\tthis.group = group;\n\t\t\tthis.action = action;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"group=\" + group + \", action=\" + action;\n\t\t}\n\n\t}\n\n\tprivate static class Wait {\n\t\tpublic int group;\n\t\tpublic int start;\n\n\t\tpublic Wait(int group, int start) {\n\t\t\tthis.group = group;\n\t\t\tthis.start = start;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"group=\" + group + \", start=\" + start;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0147().doIt();\n\t}\n\t\n\tclass AOJ0147{\n\t\tint[] waitTime;\n\t\tState[] states;\n\t\tvoid doIt(){\n\t\t\twaitTime = new int[100];\n\t\t\tLinkedList<WaitState> q = new LinkedList<WaitState>();\n\t\t\tstates = new State[17];\n\t\t\tfor(int i=0;i<17;i++)states[i] = new State(-1, -1);\n\t\t\tfor(int i=0;i<1000*5;i++){\n\t\t\t\tremoveState(i);\n\t\t\t\tif(i%5==0&&i/5<=99)q.add(new WaitState(i/5, (i/5)%5==1? 5:2, i));//stack\n\t\t\t\tint index = -1;\n\t\t\t\tif(q.size()>0)index = canPush(q.get(0));\n\t\t\t\twhile(index >= 0){\n\t\t\t\t\twaitTime[q.get(0).ban] = i-q.get(0).startTime;\n\t\t\t\t\tsetState(q.remove(), index, i);\n\t\t\t\t\tif(q.size()==0)break;\n\t\t\t\t\tindex = canPush(q.get(0));\n//\t\t\t\t\tSystem.out.println(q.get(0).ban+\" \"+q.get(0).num+\" \"+q.get(0).startTime+\" \"+index);\n\t\t\t\t}\n//\t\t\t\tprintState(i);\n//\t\t\t\tSystem.out.println(\"stacks are \");\n//\t\t\t\tfor(int s=0;s<q.size();s++)System.out.println(q.get(s).ban+\" \"+q.get(s).num);\n//\t\t\t\tSystem.out.println(\"--------------\");\n\t\t\t}\n\t\t\twhile(in.hasNext())System.out.println(getResult(in.nextInt()));\n\t\t}\n\t\t\n\t\tvoid printState(int time){\n\t\t\tfor(int i=0;i<17;i++){\n\t\t\t\tSystem.out.println((time)+\":\"+states[i].ban+\" _ \"+states[i].endTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid removeState(int time){\n\t\t\tfor(int i=0;i<17;i++)if(states[i].ban>=0&&states[i].endTime<=time)\n\t\t\t\tstates[i] = new State(-1, -1);\n\t\t}\n\t\t\n\t\tvoid setState(WaitState j,int index,int currentTime){\n\t\t\tint endTime = 17*(j.ban%2)+3*(j.ban%3)+19; \n\t\t\tfor(int i=index;i<index+j.num;i++){\n\t\t\t\tstates[i] = new State(j.ban, endTime+currentTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint canPush(WaitState j){\n\t\t\tfor(int i=0;i<17-j.num;i++)if(states[i].ban == -1){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int s=i;s<i+j.num;s++)if(states[s].ban == -1)cnt++;\n\t\t\t\tif(cnt==j.num)return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint getResult(int n){\n\t\t\treturn waitTime[n];\n\t\t}\n\t\t\n\t\tclass WaitState{\n\t\t\tint ban,num,startTime;\n\t\t\tpublic WaitState(int _ban,int _num,int _startTime) {\n\t\t\t\tban = _ban;\n\t\t\t\tnum = _num;\n\t\t\t\tstartTime = _startTime;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint ban,endTime;\n\t\t\tpublic State(int _ban,int _endTime){\n\t\t\t\tban = _ban;\n\t\t\t\tendTime = _endTime;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n\n\tpublic static void main(String... args) {\n\t\tList<Integer> targetGroupNumberList = getInputList();\n\t\tint maxGroupNumber = Collections.max(targetGroupNumberList);\n\n\t\tFukushimaken fukushimaken = new Fukushimaken();\n\t\tList<Group> groupList = new ArrayList<Group>();\n\n\t\tint elapsedTime = 0;\n\t\tint groupNumber = 0;\n\t\twhile (true) {\n\t\t\tif (elapsedTime % 5 == 0) {\n\t\t\t\tgroupNumber = elapsedTime / 5;\n\t\t\t\tGroup group = new Group(groupNumber);\n\t\t\t\tgroupList.add(group);\n\t\t\t\t\n\t\t\t\tfukushimaken.receive(group);\n\t\t\t}\n\t\t\tfukushimaken.refresh(elapsedTime);\n\n\t\t\tif (maxGroupNumber <= groupNumber\n\t\t\t\t\t&& groupList.get(maxGroupNumber).haveStartedEating()) {\n\t\t\t\t// 対象となるグループ番号の待ち時間が全て取得できた段階で終了する\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telapsedTime++;\n\t\t}\n\n\t\tfor (int i : targetGroupNumberList) {\n\t\t\tGroup group = groupList.get(i);\n\t\t\tint waitTime = group.getWaitTime();\n\t\t\tSystem.out.println(waitTime);\n\t\t}\n\t}\n\t\n\tstatic List<Integer> getInputList() {\n\t\tScanner scanner = null;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\t\ttry {\n\t\t\tscanner = new Scanner(System.in);\n\t\t\twhile (scanner.hasNext()) {\n\t\t\t\tString line = scanner.nextLine();\n\t\t\t\tinputList.add(Integer.parseInt(line));\n\t\t\t}\n\t\t\treturn inputList;\n\t\t} finally {\n\t\t\tif (scanner != null) {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Fukushimaken {\n\t\tprivate List<Boolean> tables = new ArrayList<Boolean>(17); // 座席（Falseであれば空席となる）\n\t\tprivate List<Group> groupAtTable = new ArrayList<Group>(); // 着席しているグループ\n\t\tprivate LinkedList<Group> groupQueue = new LinkedList<Group>(); // 並んでいるグループ\n\n\t\tFukushimaken() {\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\ttables.add(false);\n\t\t\t}\n\t\t}\n\n\t\tvoid receive(Group group) {\n\t\t\tthis.groupQueue.offer(group);\n\t\t}\n\n\t\tvoid refresh(int elapsedTime) {\n\t\t\tthis.refreshTables(elapsedTime);\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t\tfor (Group group : this.groupQueue) {\n\t\t\t\t// 行列にいるグループに待ち時間を加算する\n\t\t\t\tgroup.addWaitTime();\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshTables(int elapsedTime) {\n\t\t\t// 食事の済んだグループの座席を空席とする\n\t\t\tfor (int i = 0; i < this.groupAtTable.size(); i++) {\n\t\t\t\tGroup group = this.groupAtTable.get(i);\n\t\t\t\tif (!group.haveFinishedMeal(elapsedTime)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Integer> tableNumbers = group.getUseTableNumbers();\n\t\t\t\tfor (int j : tableNumbers) {\n\t\t\t\t\tthis.tables.set(j, false);\n\t\t\t\t}\n\t\t\t\tthis.groupAtTable.remove(i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshQueue(int elapsedTime) {\n\t\t\tGroup group = this.groupQueue.peek();\n\t\t\tif (group == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSet<Integer> emptyTableNumbers = this.getEmptyTablesNumbers(group.getSize());\n\t\t\tif (emptyTableNumbers.size() == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// 座席が空いていれば行列の先頭から順に着席する\n\t\t\tthis.groupAtTable.add(group);\n\t\t\tgroup.startEating(emptyTableNumbers, elapsedTime);\n\t\t\tthis.groupQueue.removeFirst();\n\t\t\tfor (int i : emptyTableNumbers) {\n\t\t\t\tthis.tables.set(i, true);\n\t\t\t}\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t}\n\n\t\tprivate Set<Integer> getEmptyTablesNumbers(int size) {\n\t\t\t// 席の番号が小さいほうから空いている座席を探す\n\t\t\tSet<Integer> tableNumbers = new HashSet<Integer>();\n\t\t\tfor (int i = 0; i < this.tables.size(); i++) {\n\t\t\t\tboolean isNotEmpty = this.tables.get(i);\n\t\t\t\tif (isNotEmpty) {\n\t\t\t\t\ttableNumbers.clear();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttableNumbers.add(i);\n\t\t\t\tif (size <= tableNumbers.size()) {\n\t\t\t\t\treturn tableNumbers;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new HashSet<Integer>();\n\t\t}\n\t}\n\n\tstatic class Group {\n\n\t\tprivate int number; // グループ番号\n\t\tprivate int timeToEat; // 食事にかかる時間\n\t\tprivate int endingTime; // 食事が済む時点の経過時間\n\t\tprivate Set<Integer> useTableNumbers; // 使用している座席の番号\n\t\tprivate int waitTime; // 待ち時間\n\n\t\tGroup(int number) {\n\t\t\tthis.number = number;\n\t\t\tthis.timeToEat = 17 * (this.number % 2) + 3 * (this.number % 3) + 19;\n\t\t}\n\n\t\tvoid startEating(Set<Integer> tableNumbers, int elapsedTime) {\n\t\t\t// 着席し、さっそく食事を始める。この時点でこのグループの待ち時間は確定する。\n\t\t\tthis.useTableNumbers = tableNumbers;\n\t\t\tthis.endingTime = elapsedTime + timeToEat;\n\t\t}\n\n\t\tboolean haveFinishedMeal(int elapsedTime) {\n\t\t\treturn this.endingTime < elapsedTime;\n\t\t}\n\n\t\tSet<Integer> getUseTableNumbers() {\n\t\t\treturn this.useTableNumbers;\n\t\t}\n\n\t\tboolean haveStartedEating() {\n\t\t\treturn this.useTableNumbers != null;\n\t\t}\n\n\t\tvoid addWaitTime() {\n\t\t\tthis.waitTime++;\n\t\t}\n\n\t\tint getWaitTime() {\n\t\t\t// 店に到着した時点の1分間を除外して待ち時間を返す\n\t\t\treturn (this.waitTime == 0) ? 0 : this.waitTime - 1;\n\t\t}\n\n\t\tint getSize() {\n\t\t\treturn (this.number % 5 == 1) ? 5 : 2; // グループの人数\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<>();\n        arrivalTimeList = new ArrayList<>();\n        eatTimeList = new ArrayList<>();\n        sitTimeList = new ArrayList<>();\n        waitTimeList = new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            try {\n                inputNumber = Integer.valueOf(br.readLine());\n            } catch (IOException e) {\n                System.out.println(\"inputError\" + e.getMessage());\n            }\n            if (inputNumber == null) {\n                break;\n            }\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    private static void printCustomer() {\n        System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\");\n        System.out.print(\"\");\n        System.out.println(\"\");\n        for (int i = 0; i < arrivalTimeList.size(); i++) {\n            System.out.print(i + \"\\t\\t\");\n            System.out.print(arrivalTimeList.get(i) + \"\\t\\t\");\n            System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n            System.out.println(eatTimeList.get(i));\n        }\n    }\n\n    private static void printQuere() {\n        System.out.print(\"キュー＝\");\n        for (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n            System.out.print(it.next());\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void printCounter() {\n        System.out.print(currentTime + \"：[\");\n        for (int a : serviceCouters) {\n            System.out.print(a + \", \");\n        }\n        System.out.println(\"]\");\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint z[];\n\t\tint wait[];\n\t\tQueue<Integer> g = new LinkedList<Integer>();\n\n\t\tz = new int[17];\n\t\tArrays.fill(z, -1);\n\t\twait = new int[100];\n\t\tfor (int i = 0; i < 600; i++) {\n\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\tif (z[j] == i) {\n\t\t\t\t\tz[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i % 5 == 0) {\n\t\t\t\tg.add(i / 5);\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\twhile (g.peek() != null && flag) {\n\t\t\t\tflag = false;\n\t\t\t\tint m = g.peek() % 5 == 1 ? 5 : 2;\n\t\t\t\tint l = g.peek();\n\t\t\t\tint index = 0;\n\t\t\t\tboolean flag2 = false;\n\t\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\t\tflag2 = true;\n\t\t\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\t\t\tif (17 <= j + k || 0 <= z[j + k]) {\n\t\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2) {\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\tz[index + j] = i + 17 * (l % 2) + 3 * (l % 3) + 19;\n\t\t\t\t\t}\n\t\t\t\t\tg.poll();\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int x: g) {\n\t\t\t\tif (x < 100) {\n\t\t\t\t\twait[x]++;\n\t\t\t\t}\n\t\t\t}\n//\t\t\t//----------------------------------------------------\n//\t\t\tSystem.out.printf(\"%2d: \", i);\n//\t\t\tfor (int j = 0; j < 17; j++) {\n//\t\t\t\tSystem.out.printf(\"%4d\", z[j]);\n//\t\t\t}\n//\t\t\tSystem.out.print(\"  \");\n//\t\t\tfor (int x: g) {\n//\t\t\t\tSystem.out.printf(\"%2d\", x);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t\t//----------------------------------------------------\n\t\t}\n\t\twhile (sc.hasNext()) {\n\t\t\tn = sc.nextInt();\n\t\t\tSystem.out.println(wait[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 座席数 */\n\tprivate static final int SEAT_NUM = 17;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t/** 着席可能の最初の座席番号 */\n\tprivate static int firstSeatNum;\n\n\t/** 待ち時間 */\n\tprivate static int[] waitMinutes = new int[GROUP_NUM];\n\n\t/** 座席 */\n\tprivate static String[] seats = new String[SEAT_NUM];\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 待ち時間を作成\n\t\tcalcuWaitMinutes();\n\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** グループの人数を取得する */\n\tprivate static int getCustomerNum(int i) {\n\t\treturn i % 5 == 1 ? 5 : 2;\n\t}\n\n\t/** グループの到着時間を取得する */\n\tprivate static int getArrivedMinutes(int i) {\n\t\treturn 5 * i;\n\t}\n\n\t/** グループの食事時間を取得する */\n\tprivate static int getMealMinutes(int i) {\n\t\treturn SEAT_NUM * (i % 2) + 3 * (i % 3) + 19;\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void calcuWaitMinutes() {\n\t\t// 順番\n\t\tint groupOrder;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = arrivedCustomer(currentMinutes)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder));\n\n\t\t\t\t\t\ttotalGroupNum++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\ttotalGroupNum++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitMinutes[wait] = currentMinutes\n\t\t\t\t\t\t\t\t- getArrivedMinutes(wait);\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int currentMinutes) {\n\t\tfor (int groupOrder = 0; groupOrder < GROUP_NUM; groupOrder++) {\n\t\t\tif (getArrivedMinutes(groupOrder) == currentMinutes) {\n\t\t\t\treturn groupOrder;\n\t\t\t}\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seat)) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupOrder) {\n\n\t\tfor (int customerOrder = 0; customerOrder < getCustomerNum(Integer.parseInt(groupOrder)); customerOrder++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席の場合、trueを返す */\n\tprivate static boolean isEmpty(int groupOrder) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\t// 座席番号\n\t\tint seatOrder = 0;\n\n\t\tfor (; seatOrder < SEAT_NUM\n\t\t\t\t|| getCustomerNum(groupOrder) <= SEAT_NUM - seatOrder; seatOrder++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == getCustomerNum(groupOrder)) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (seats[seatOrder] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (emptyseatsNum == getCustomerNum(groupOrder)) {\n\t\t\t// 空席の最初の座席番号を設定する\n\t\t\tfirstSeatNum = seatOrder - emptyseatsNum;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** 食事の時間が終了した席の場合、trueを返す */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (getArrivedMinutes(Integer.parseInt(seat)) + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= getMealMinutes(Integer\n\t\t\t\t\t.parseInt(seat));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        //2で割った余りは、下1ビットをみれば分かる。\n                        eatEndTime[ts] = min + (17 * (headGroupNo & 0x1) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass Group {\n\t\tint id;\n\t\tint p;\n\t\tint time;\n\t\tint tq;\n\t\tint j;\n\n\t\tGroup(int id) {\n\t\t\tthis.id = id;\n\t\t\tif (id % 5 == 1) {\n\t\t\t\tp = 5;\n\t\t\t} else {\n\t\t\t\tp = 2;\n\t\t\t}\n\t\t\ttime = 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tboolean[] used = new boolean[17];\n\t\tLinkedList<Group> q = new LinkedList<Group>();\n\t\tLinkedList<Group> f = new LinkedList<Group>();\n\t\tint[] ans = new int[100];\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tq.add(new Group(i));\n\t\t}\n\t\tint timer = 0;\n\t\tfor (;; timer++) {\n//\t\t\tSystem.out.println(timer - 1 + \" \" + Arrays.toString(used));\n\t\t\tif (q.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (Group g : f) {\n\t\t\t\tg.time--;\n\t\t\t\tif (g.time == 0) {\n\t\t\t\t\tfor (int i = g.j; i < g.j + g.p; i++) {\n\t\t\t\t\t\tused[i] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (;;) {\n\t\t\t\tif(q.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGroup g = q.peekFirst();\n\t\t\t\tif (timer < g.id * 5) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint j = 0;\n\t\t\t\tint k = 0;\n\t\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\t\tif (used[i]) {\n\t\t\t\t\t\tj = i + 1;\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tif (k == g.p) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k != g.p) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tf.add(q.poll());\n\t\t\t\tg.tq = timer;\n\t\t\t\tg.j = j;\n\t\t\t\tans[g.id] = g.tq - g.id * 5;\n\t\t\t\tfor (int i = j; i < g.j + g.p; i++) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tif (!sc.hasNextInt()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(ans[n]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ??§?????° */\n\tprivate final static int SEATS = 17;\n\n\t/** ??¢??°???????????° */\n\tprivate final static int GROUP = 100;\n\n\t/** ??¢??°??????????????°???????????????????????? */\n\tprivate final static int INTERVAL = 5;\n\n\t/** ??¢??°???????????????????????????????´????????????? */\n\tprivate static int[] watingTimes = new int[GROUP];\n\n\t/** ??¢??°??????????????°?????????????????°????£?????????????????´???????????¬?????????? */\n\tprivate static int[][] groupInfo = new int[GROUP][3];\n\n\t/** ??¢??°??????????????°??????????????¨???????????? */\n\tprivate final static int GROUP_INFO_ARRIVAL = 0;\n\n\t/** ??¢??°?????????????????°?????¨???????????? */\n\tprivate final static int GROUP_INFO_PERSONS = 1;\n\n\t/** ??¢??°?????????????£???????????????¨???????????? */\n\tprivate final static int GROUP_INFO_EATING_MINUTES = 2;\n\n\t/** ??§??????????????¶??????????´????????????? */\n\tprivate static int[] seatsCondition = new int[SEATS];\n\n\t/** ???????????????????????????????????? */\n\tprivate static boolean openFlag = true;\n\n\t/** ???????????°???????????°????????? */\n\tprivate static int lastArrivalGroup = -1;\n\n\t/** ????????°???????????° */\n\tprivate static int watingGroups = 0;\n\n\t/** ??£????????????????????????????????? */\n\tprivate static int passedMinutes = 0;\n\n\t/**\n\t * ???????????????????¨?????????¢??°??????????????????????????????????????????\n\t *\n\t * @param args\n\t *            ?????¨????????????\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\t// ??\\?????????????????????\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n        String line = null;\n        while((line = br.readLine()) != null) {\n            inputList.add(Integer.parseInt(line));\n        }\n\n\t\t// ??¨??¢??°??????????????°???????????¨?????°??¨?£??????????????±???????\n\t\tsetGroupInfo();\n\n\t\twhile (openFlag) {\n\n\t\t\t// ???????????§?¬??????°??????????????°?????????\n\t\t\tif (passedMinutes % INTERVAL == 0) {\n\t\t\t\tlastArrivalGroup++;\n\t\t\t\twatingGroups++;\n\t\t\t}\n\n\t\t\t// ????????°??????????????????????????°???????????????\n\t\t\tif (watingGroups == 0) {\n\t\t\t\tpassedMinutes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean vacancyFlag = true; // ??????????????¨?????????\n\t\t\tint nextGroup = lastArrivalGroup - watingGroups + 1; // ????????????????????°???????????????\n\n\t\t\t// ????????°???????????????????????????????????¨????????´????????????????????????????????????????????§????????????\n\t\t\twhile (watingGroups != 0 && vacancyFlag) {\n\t\t\t\tint numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS]; // ???????????°?????????????????°\n\n\t\t\t\t// ???????????°????????????????????§????????§????????????????±???????\n\t\t\t\tint seatNumber = getSeatNumber(numberOfPersons);\n\n\t\t\t\tif (seatNumber != -1) {\n\n\t\t\t\t\t// ????????§????????§???????????£?????´????????§??????????????????????¨??????????\n\t\t\t\t\tfor (int i = 0; i < numberOfPersons; i++) {\n\t\t\t\t\t\tseatsCondition[seatNumber] = passedMinutes\n\t\t\t\t\t\t\t\t+ groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n\t\t\t\t\t\tseatNumber++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??°????????????????????????????¨??????????\n\t\t\t\t\twatingTimes[nextGroup] = passedMinutes\n\t\t\t\t\t\t\t- groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n\t\t\t\t\t// ????????°???????????°????????????\n\t\t\t\t\twatingGroups--;\n\t\t\t\t\tnextGroup = lastArrivalGroup - watingGroups + 1;\n\n\t\t\t\t\t// ???????????°??????????????§??£??????????????????????????????\n\t\t\t\t\tif (nextGroup == GROUP) {\n\t\t\t\t\t\topenFlag = false;\n\t\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t}\n\n//\t\t\t\tSystem.out.print(passedMinutes + \":\"+ nextGroup+\":\");\n//\t\t\t\tfor(int i: seatsCondition){\n//\t\t\t\t\tSystem.out.print(i + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t\tpassedMinutes++;\n\t\t}\n\n\t\tfor (int i :inputList){\n\t\t\tSystem.out.println(watingTimes[i]);\n\t\t}\n//\t\tfor (int i : watingTimes) {\n//\t\t\tSystem.out.println(i);\n//\t\t}\n\t}\n\n\tprivate static void setGroupInfo() {\n\n\t\tfor (int i = 0; i < GROUP; i++) {\n\t\t\tgroupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n\t\t\tgroupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n\t\t\tgroupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n\t\t\t\t\t* (i % 3) + 19;\n\t\t}\n\n\t}\n\n\tprivate static int getSeatNumber(int numberOfPersons) {\n\n\t\tint seatNumber = 0; // ???????????§?????????\n\t\tint vacancySeats = 0; // ????????°\n\n\t\tfor (int i = 0; i < SEATS; i++) {\n\n\t\t\t// ??????????????¨?????£?????§?????????????????????\n\t\t\tif (seatsCondition[i] <= passedMinutes) {\n\t\t\t\tseatsCondition[i] = 0;\n\t\t\t}\n\n\t\t\tif (seatsCondition[i] == 0) {\n\n\t\t\t\t// ??????????????§????????°???????????°????¢???????\n\t\t\t\tvacancySeats++;\n\n\t\t\t\t// ????????°??????????????°??¨??????????????°??????????????§??????????????????\n\t\t\t\tif (vacancySeats == numberOfPersons) {\n\t\t\t\t\treturn seatNumber;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// ??????????????§???????????°?????§?????????????¬?????§???????????????°???0?????????\n\t\t\t\tseatNumber = i + 1;\n\t\t\t\tvacancySeats = 0;\n\t\t\t}\n\t\t}\n\n\t\t// ????????????????????°-1?????????\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=0;\n\t\twhile(sc.hasNext()){\n\t\t\tint temp=sc.nextInt();\n\t\t\tMAX=max(MAX,temp);\n\t\t\tqueue.add(temp);\n\t\t}\n\t\t++MAX;\n\t\tint[] num=new int[MAX],time=new int[MAX],seat=new int[17];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\ttime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"TIME\"+i+\" \"+time[i]);\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"NUM\"+i+\" \"+num[i]);\n\t\tint j=0,min=0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tseat=exit(seat,min,time);\n\t\t\tint temp=find(seat,num[j]);\n\t\t\tif(temp>=0 && min>=j*5){\n\t\t\t\tint q=queue.getFirst();\n\t\t\t\tif(j==q){\n\t\t\t\t\tout.println(max(0,min-j*5));\n\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t}\n\t\t\t\tfor(int i=temp; i<temp+num[j]; i++)\tseat[i]=j;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tmin++;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//disp(seat,min-1);\n\t\t}\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] time){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint idx=seat[i],emin=idx*5+time[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tLinkedList<Integer> que=new LinkedList<Integer>();\n\t\tint[] wait=new int[100]; // Ò¿Ô\n\t\tint[] a=new int[17]; // ÀÁÄ¢éq\n\t\tint[] rest=new int[17]; // qªAéÜÅÌÔ\n\t\tint[] b=new int[17];\n\n\t\tfor(int t=0;; t++){\n\t\t\t// HI¹\n\t\t\tfor(int i=0; i<17; i++){\n\t\t\t\tif(--rest[i]<=0){\n\t\t\t\t\ta[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Vµ¢q\n\t\t\tif(t%5==0&&t<500){\n\t\t\t\tque.addLast(t/5);\n\t\t\t}\n\n\t\t\t// Âßçêé¾¯Âßé\n\t\t\tfor(; !que.isEmpty();){\n\t\t\t\tint c=que.getFirst();\n\t\t\t\tint n=c%5==1?5:2;\n\t\t\t\tint j=-1;\n\t\t\t\tfor(int i=16; i>=0; i--){\n\t\t\t\t\tb[i]=a[i]==-1?((i==16?0:b[i+1])+1):0;\n\t\t\t\t\tif(b[i]>=n){\n\t\t\t\t\t\tj=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j==-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=j; i<j+n; i++){\n\t\t\t\t\ta[i]=c;\n\t\t\t\t\trest[i]=17*(c%2)+3*(c%3)+19;\n\t\t\t\t}\n\t\t\t\twait[c]=t-5*c;\n\t\t\t\tque.removeFirst();\n\t\t\t}\n\n\t\t\tif(t>500&&que.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(; sc.hasNext();){\n\t\t\tprintln(\"\"+wait[sc.nextInt()]);\n\t\t}\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\tfor (int countTimeGoesBy = 0; countTimeGoesBy < 300; countTimeGoesBy++) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\tint countDelete = 0;\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\t\t\t\t\t\n\t\t\t\t\tcountDelete++;\n\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// waitingCustomersList.remove(count);\n\t\t\t\t// waitingStartTimeList.remove(count);\n\t\t\t\t// count++;\n\t\t\t\t// int sizeCustomer = waitingCustomersList.size();\n\t\t\t\t// int sizeStartTime = waitingStartTimeList.size();\n\n\t\t\t\t// for (int count2 = waitingCustomersList.size() + 1; count2 <\n\t\t\t\t// 1; count2--) {\n\t\t\t\t// if (waitingCustomersList.size() <= sizeCustomer) {\n\t\t\t\t// waitingCustomersList.add(waitingCustomersList\n\t\t\t\t// .get(waitingCustomersList.size() - 1));\n\t\t\t\t//\n\t\t\t\t// } else {\n\t\t\t\t//\n\t\t\t\t// waitingCustomersList.set(count2,\n\t\t\t\t// waitingCustomersList.get(count2 - 1));\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t\t// for (int count3 = waitingStartTimeList.size() + 1; count3 <\n\t\t\t\t// 1; count3--) {\n\t\t\t\t// if (waitingStartTimeList.size() <= sizeStartTime) {\n\t\t\t\t// waitingStartTimeList.add(waitingStartTimeList\n\t\t\t\t// .get(waitingStartTimeList.size() - 1));\n\t\t\t\t//\n\t\t\t\t// } else {\n\t\t\t\t// waitingStartTimeList.set(count3,\n\t\t\t\t// waitingStartTimeList.get(count3 - 1));\n\t\t\t\t// }\n\t\t\t\t// }\n\n\t\t\t}\n\t\t\tfor (int countt = 0; countt < countDelete; countt++) {\n\t\t\t\twaitingCustomersList.remove(0);\n\t\t\t\twaitingStartTimeList.remove(0);\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(waitingTime);\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n    \n    /**\n     * グル?プの人数を計算する\n     */\n    private static int getNumInGroup(int groupNo) {\n        return groupNo % 5 == 1 ? 5 : 2;\n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = getNumInGroup(headGroupNo);\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    int sittingGroupNum = seat[s];\n                    if (sittingGroupNum == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                        //グループの人数分飛ばす\n                        s += getNumInGroup(sittingGroupNum) - 1;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, min + timeToEatList[headGroupNo % timeToEatList.length]);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\tint[] enter;\n\tint time(int n){\n\t\treturn 17*(n%2)+3*(n%3)+19; \n\t}\n\t\n\tvoid solve(){\n\t\tint[] seats=new int[17];\n\t\tArrays.fill(seats,-1);\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\t\n\t\tint[] finish=new int[100];\n\t\tenter=new int[100];\n\t\t\n\t\tint nq=0,ns=0;\n\t\tfor(int t=0;ns<100;++t){\n\t\t\t//離席\n\t\t\tfor(int i=0;i<17;++i){\n\t\t\t\tif(seats[i]!=-1&&t>=finish[seats[i]]){\n\t\t\t\t\tseats[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//来店\n\t\t\tif(nq<100&&t%5==0){\n\t\t\t\tqueue.add(nq++);\n\t\t\t}\n\t\t\t//空席判定\n\t\t\tfor(int i=0;i<17&&!queue.isEmpty();++i){\n\t\t\t\tif(seats[i]==-1){\n\t\t\t\t\t//[i,j] : 連続空席\n\t\t\t\t\tint j=i;\n\t\t\t\t\tfor(;j<17&&seats[j]==-1;++j);\n\t\t\t\t\t--j;\n\t\t\t\t\t//店に這入れるなら入れる\n\t\t\t\t\t//p:客数\n\t\t\t\t\tint p=(queue.peek()%5==1)?5:2;\n\t\t\t\t\tif(j-i+1>=p){\n\t\t\t\t\t\tint group=queue.poll();\n\t\t\t\t\t\tfor(int k=i;k<i+p;++k){\n\t\t\t\t\t\t\tseats[k]=group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter[group]=t;\n\t\t\t\t\t\tfinish[group]=t+time(group);\n\t\t\t\t\t\t++ns;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(t,seats);\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tsolve();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=ni();\n\t\t\tSystem.out.println(enter[n]-n*5);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, firstSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveMinutes = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealMinutes = new int[GROUP_NUM];\n        waitMinutes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveMinutes[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int groupOrder;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 食事の時間が終了した客を離席させる\n            outCustomer(currentTime);\n\n            if ((groupOrder = searchArrivedGroup(arriveMinutes, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                // 到着したグループを着席させる\n                seatArrivedGroup(groupOrder, waitList, totalGroupNum);\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 並んでいる行列のグループを着席させる\n                seatWaitList(waitList, removeList, currentTime, totalGroupNum);\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // 行列リストから着席したグループを排除する\n                removeSeatingGroupFromWaitList(waitList, removeList);\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** 到着したグループを着席させる */\n    private static void seatArrivedGroup(int groupOrder,\n            List<Integer> waitList, int totalGroupNum) {\n        if (waitList.isEmpty()) {\n            // 行列がない場合\n\n            if (isEmpty(groupOrder)) {\n                // 着席可能の場合\n\n                // 座席に着席させる\n                setSeat(Integer.toString(groupOrder));\n\n                totalGroupNum++;\n\n            } else {\n                // 着席不可の場合\n\n                // 行列に並ばせる\n                waitList.add(groupOrder);\n            }\n\n        } else {\n            // 行列がある場合\n\n            // 行列に並ばせる\n            waitList.add(groupOrder);\n        }\n    }\n\n    /** 着席可能の場合、並んでいる行列のグループを着席させる */\n    private static void seatWaitList(List<Integer> waitList,\n            List<Integer> removeList, int currentTime, int totalGroupNum) {\n        // 行列番号\n        int i = 0;\n\n        for (int wait : waitList) {\n            // 行列リスト分、繰り返す\n\n            if (isEmpty(wait)) {\n                // 着席可能の場合\n\n                // 座席に着席させる\n                setSeat(Integer.toString(wait));\n\n                totalGroupNum++;\n\n                // 待った時間を設定する\n                waitMinutes[wait] = currentTime - arriveMinutes[wait];\n\n                // 着席したグループを行列排除リストに追加する\n                removeList.add(i);\n\n            } else {\n                // 着席不可の場合\n\n                // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                break;\n            }\n            i++;\n        }\n    }\n\n    /** 行列リストから着席したグループを排除する */\n    private static void removeSeatingGroupFromWaitList(List<Integer> waitList,\n            List<Integer> removeList) {\n        // リストの降順でソートする（リムーブするため）\n        Collections.reverse(removeList);\n\n        for (int remove : removeList) {\n            // 行列排除リスト分、繰り返す\n\n            // 行列リストから行列排除リストの番号を削除する\n            waitList.remove(remove);\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitMinutes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int searchArrivedGroup(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (finishedMeal(currentTime, seat)) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 食事時間が終了した場合、trueを返す */\n    private static boolean finishedMeal(int currentTime, String seat) {\n        return currentTime\n                - (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n                        .parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[firstSeatNum++] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席の場合、trueを返す。 */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int totalEmptySeats = 0;\n\n        // 座席番号\n        int seatNum = 0;\n\n        for (; seatNum < seatsNum\n                || customersNum[groupsNum] <= seatsNum - seatNum; seatNum++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (totalEmptySeats == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n                break;\n\n            }\n\n            if (seats[seatNum] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                totalEmptySeats++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                totalEmptySeats = 0;\n            }\n        }\n        if (totalEmptySeats == customersNum[groupsNum]) {\n            // 空席の最初の座席番号を設定する\n            firstSeatNum = seatNum - totalEmptySeats;\n\n            return true;\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    int endTime = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, endTime);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\tint[] enter;\n\tint time(int n){\n\t\treturn 17*(n%2)+3*(n%3)+19; \n\t}\n\t\n\tvoid solve(){\n\t\tint[] seats=new int[17];\n\t\tArrays.fill(seats,-1);\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\t\n\t\tint[] finish=new int[100];\n\t\tenter=new int[100];\n\t\t\n\t\tint nq=0,ns=0;\n\t\tfor(int t=0;ns<100;++t){\n\t\t\t//離席\n\t\t\tfor(int i=0;i<17;++i){\n\t\t\t\tif(seats[i]!=-1&&t>=finish[seats[i]]){\n\t\t\t\t\tseats[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//来店\n\t\t\tif(nq<100&&t%5==0){\n\t\t\t\tqueue.add(nq++);\n\t\t\t}\n\t\t\t//空席判定\n\t\t\tfor(int i=0;i<17&&!queue.isEmpty();++i){\n\t\t\t\tif(seats[i]==-1){\n\t\t\t\t\t//[i,j] : 連続空席\n\t\t\t\t\tint j=i;\n\t\t\t\t\tfor(;j<17&&seats[j]==-1;++j);\n\t\t\t\t\tj=j==17?16:j;\n\t\t\t\t\t//店に這入れるなら入れる\n\t\t\t\t\t//p:客数\n\t\t\t\t\tint p=(queue.peek()%5==1)?5:2;\n\t\t\t\t\tif(j-i+1>=p){\n\t\t\t\t\t\tint group=queue.poll();\n\t\t\t\t\t\tfor(int k=i;k<i+p;++k){\n\t\t\t\t\t\t\tseats[k]=group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter[group]=t;\n\t\t\t\t\t\tfinish[group]=t+time(group);\n\t\t\t\t\t\t++ns;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tsolve();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=ni();\n\t\t\tSystem.out.println(enter[n]-n*5);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Event implements Comparable<Event> {\n\n    static final int ARRIVE = 1;\n    static final int LEAVE = 0;\n\n    final int state;\n    final int id;\n    final int time;\n\n    public Event( final int state, final int id, final int time ) {\n\tthis.state = state;\n\tthis.id = id;\n\tthis.time = time;\n    }\n\n    @Override public int compareTo( Event event ) {\n\tif ( time != event.time ) {\n\t    return time - event.time;\t    \n\t} else {\n\t    return state - event.state;\n\t}\n    }\n\n    public String toString() {\n\tfinal String stateStr = ( state == ARRIVE ? \"ARRIVE\" : \"LEAVE\" );\n\treturn String.format( \"%s %d, time = %d\", stateStr, id, time );\n    }\n    \n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] waitTime = new int[100];\n\tsimulate( waitTime );\n\t//System.out.println( Arrays.toString( waitTime ) );\n\n\twhile ( stdin.hasNextInt() ) {\n\t    final int n = stdin.nextInt();\n\t    System.out.println( waitTime[n] );\n\t}\t\n    }\n\n    static void simulate( final int[] waitTime ) {\n\t\n\tfinal PriorityQueue<Event> queue = new PriorityQueue<Event>();\n\tfinal LinkedList<Event> waitQueue = new LinkedList<Event>();\n\tfor ( int i = 0; i < 100; i++ ) {\n\t    queue.offer( new Event( Event.ARRIVE, i, i * 5 ) );\n\t}\n\n\tint time = 0;\n\n\tint[] seats = new int[17];\n\tArrays.fill( seats, -1 );\n\t\n\twhile ( !queue.isEmpty() ) {\n\t    //System.out.println( Arrays.toString( seats ) );\n\t    final Event e = queue.poll();\n\t    //System.out.println( e );\n\t    time = e.time;\n\t    if ( e.state == Event.ARRIVE ) {\n\t\tfinal int pos = canPut( seats, getNoOfPeople( e.id ) );\n\t\tif ( waitQueue.isEmpty() && pos >= 0 ) {\n\t\t    put( seats, e.id, pos );\n\t\t    queue.offer( new Event( Event.LEAVE, e.id, e.time + calcEatTime( e.id ) ) );\n\t\t} else {\n\t\t    //System.out.printf( \"wait... %s\\n\", e );\n\t\t    waitQueue.offer( e );\n\t\t}\n\t    } else { //if ( e.state == Event.LEAVE ) {\n\t\tremove( seats, e.id );\n\t\twhile ( !waitQueue.isEmpty() ) {\n\t\t    final Event ne = waitQueue.peek();\n\t\t    final int nPos = canPut( seats, getNoOfPeople( ne.id ) );\n\t\t    if ( nPos >= 0 ) {\n\t\t\twaitQueue.poll();\n\t\t\tput( seats, ne.id, nPos );\n\t\t\twaitTime[ne.id] = time - ne.time;\n\t\t\t//System.out.printf( \"in: %s\", ne );\n\t\t\t//System.out.printf( \"waitTime = %d\\n\", waitTime[ne.id] );\n\t\t\tqueue.offer( new Event( Event.LEAVE, ne.id, ne.time + calcEatTime( ne.id ) ) );\n\t\t    } else {\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    static int calcEatTime( final int id ) {\n\treturn 17 * ( id % 2 ) + 3 * ( id % 3 ) + 19;\n    }\n\n    static void put( final int[] seats, final int id, final int pos ) {\n\tfinal int p = getNoOfPeople( id );\n\tfor ( int i = pos; i < pos + p; i++ ) {\n\t    seats[i] = id;\n\t}\n    }\n\n    static int getNoOfPeople( final int id ) {\n\treturn id % 5 == 1 ? 5 : 2;\n    }\n\n    static int canPut( final int[] seats, final int noOfPeople ) {\n\tint count = 0;\n\tfor ( int i = 0; i < seats.length; i++ ) {\n\t    if ( seats[i] == -1 ) {\n\t\tcount++;\n\t\tif ( count >= noOfPeople ) {\n\t\t    return i - count + 1;\n\t\t}\n\t    } else {\n\t\tcount = 0;\n\t    }\n\t}\n\treturn -1;\n    }\n\n    static void remove( final int[] seats, final int id ) {\n\tfor ( int i = 0; i < seats.length; i++ ) {\n\t    if ( seats[i] == id ) {\n\t\tfinal int noOfPeople = getNoOfPeople( id );\n\t\tfor ( int j = i; j < i + noOfPeople; j++ ) {\n\t\t    seats[j] = -1;\n\t\t}\n\t\treturn;\n\t    }\n\t}\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\npublic class Main {\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// 退店グループリスト\n\t\tMap<Integer, Integer> byeGroupMap;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tif (maxInputNum >= 100) {\n\t\t\tgroup = new Group[100];\n\t\t} else {\n\t\t\tgroup = new Group[maxInputNum + 1];\n\t\t}\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 退店グループリストの初期化\n\t\t\tbyeGroupMap = new HashMap<Integer, Integer>();\n\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 退店グループリスト追加（後ほど退店処理で実施）\n\t\t\t\t\t\tbyeGroupMap\n\t\t\t\t\t\t\t\t.put(n, group[n].pastTime - group[n].eatTime);\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ここで退入店処理を実施\n\t\t\tif (!byeGroupMap.isEmpty()) {\n\n\t\t\t\t// List 生成 (ソート用)\n\t\t\t\tList<Map.Entry<Integer, Integer>> entries = new ArrayList<Map.Entry<Integer, Integer>>(\n\t\t\t\t\t\tbyeGroupMap.entrySet());\n\t\t\t\tCollections.sort(entries,\n\t\t\t\t\t\tnew Comparator<Map.Entry<Integer, Integer>>() {\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int compare(Entry<Integer, Integer> entry1,\n\t\t\t\t\t\t\t\t\tEntry<Integer, Integer> entry2) {\n\n\t\t\t\t\t\t\t\tint entry1Num = 0;\n\t\t\t\t\t\t\t\tint entry2Num = 0;\n\n\t\t\t\t\t\t\t\tif (entry1.getValue().equals(entry2.getValue())) {\n\t\t\t\t\t\t\t\t\tfor (String s : seat) {\n\t\t\t\t\t\t\t\t\t\tif (s.equals(String.valueOf(entry2\n\t\t\t\t\t\t\t\t\t\t\t\t.getKey()))) {\n\t\t\t\t\t\t\t\t\t\t\tentry1Num = Integer.parseInt(s);\n\t\t\t\t\t\t\t\t\t\t} else if (s.equals(String\n\t\t\t\t\t\t\t\t\t\t\t\t.valueOf(entry1.getKey()))) {\n\t\t\t\t\t\t\t\t\t\t\tentry2Num = Integer.parseInt(s);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn ((Integer) entry1Num)\n\t\t\t\t\t\t\t\t\t\t\t.compareTo((Integer) entry2Num);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ((Integer) entry2.getValue())\n\t\t\t\t\t\t\t\t\t\t\t.compareTo((Integer) entry1\n\t\t\t\t\t\t\t\t\t\t\t\t\t.getValue());\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tfor (Entry<Integer, Integer> byeGroupNum : entries) {\n\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\tbyeStore(String.valueOf(byeGroupNum.getKey()));\n\t\t\t\t\tgroup[byeGroupNum.getKey()].eatFlug = true;\n\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\tfor (int m = byeGroupNum.getKey() + 1; m < i; m++) {\n\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[byeGroupNum\n\t\t\t\t\t\t\t\t\t\t.getKey()].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t- group[byeGroupNum.getKey()].pastTime;\n\t\t\t\t\t\t\t\tgroup[m].pastTime += group[byeGroupNum.getKey()].pastTime\n\t\t\t\t\t\t\t\t\t\t- group[byeGroupNum.getKey()].eatTime;\n\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\tgroup[m].waitTime -= 5;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\t\tfor (int n = 0; n < seat.length; n++) {\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (\"_\".equals(seat[n])) {\n\t\t\t\temptySeat++;\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn okFlug;\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\t// 退店＆入店処理実施\n\tstatic void byeAndEnterStore(List<Integer> byeGroupList, Group[] group,\n\t\t\tint maxInputNum, int currentGroupNum) {\n\n\t\tfor (int n : byeGroupList) {\n\n\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\tbyeStore(String.valueOf(n));\n\t\t\tgroup[n].eatFlug = true;\n\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\tfor (int m = n + 1; m < currentGroupNum; m++) {\n\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\tgroup[m].pastTime += group[n].pastTime\n\t\t\t\t\t\t\t\t- group[n].eatTime;\n\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// 退店\n\tstatic void byeStore(String n) {\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        try {\n            // 対象のグループ番号：待ち時間の形で保持\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetCustomer = new LinkedHashMap<Integer, Integer>();\n            List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n            while (sc.hasNext()) {\n                targetCustomerGroupNumbers.add(sc.nextInt());\n            }\n\n            // 椅子 客が出るまでの分数を保持する\n            int[] chairs = new int[17];\n            // 待ち行列 客グループ数を保持する\n            Deque<Integer> que = new LinkedList<Integer>();\n            // これまでに来た最大のグループ番号\n            int cameGroup = 0;\n            // これまでに座ったグループの「数」\n            int sitGroupCount = 0;\n            // 経過時間\n            int pastMinutes = 0;\n\n            while (sitGroupCount < 100) {\n                // 食べる\n                eat(chairs);\n\n                // 客が来る\n                boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n                // 座る\n                sitGroupCount += sit(chairs, que, sitGroupCount);\n\n                // 後処理\n                for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                    if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                        // まだ座れていない\n                        continue;\n                    }\n\n                    if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                        // もうすでに座っていた\n                        continue;\n                    } else {\n                        // この時間で初めて座れた\n                        int waitMinutes = pastMinutes\n                                - (5 * targetCustomerGroupNumber);\n                        targetCustomer.put(targetCustomerGroupNumber,\n                                waitMinutes);\n                    }\n                }\n\n                if (customerHasCome) {\n                    cameGroup++;\n                }\n                pastMinutes++;\n            }\n\n            for (Integer target : targetCustomerGroupNumbers) {\n                System.out.println(targetCustomer.get(target));\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int sitGroupNumber) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (sitGroupNumber % 2))\n                    + (3 * (sitGroupNumber % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, (sitGroupNumber + 1));\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = ((headGroup * 5) < pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class M2ain {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = ((headGroup * 5) < pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"TIME\"+i+\" \"+time[i]);\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"NUM\"+i+\" \"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=ex(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] ex(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].eatTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint num;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupNum = 0; groupNum < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((num = searchGroupNum(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(num)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(num));\n\n\t\t\t\t\t\tgroupNum++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(num);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(num);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)));\n\n\t\t\t\t\t\tgroupNum++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[waitList.get(index)] = currentTime\n\t\t\t\t\t\t\t\t- arriveTime[waitList.get(index)];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int searchGroupNum(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentTime)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentTime, seats[seatNum])) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** 引数がnullか空白の場合、trueを返す */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** 食事の時間が終了した座席の場合、trueを返す */\n\tprivate static boolean finishedMeal(int currentTime, String seat) {\n\t\treturn currentTime\n\t\t\t\t- (arriveTime[Integer.parseInt(seat)] + waitTimes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealTimes[Integer.parseInt(seat)];\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// 空席の最初の座席番号を設定する\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** 第一引数と第二引数が同じ場合、trueを返す */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\twhile (sc.hasNextLine()) {\n\t    String query = null;\n\t    query = sc.nextLine();\n\t    if (\"???\".equals(query) || query == null) {\n\t\tSystem.exit(0);\n\t    }\n\n\t    System.out.println(waitingTime[Integer.parseInt(query)][1] - waitingTime[Integer.parseInt(query)][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\topenStore: for (int now = 0;; now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now / 5 < 100 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    int groupId = waitingGroups.get(0);\n\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\n\t\t\t    // ???????????§??¢?????§??£??????????????????\n\t\t\t    if (groupId == 99) {\n\t\t\t\tbreak openStore;\n\t\t\t    }\n\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint order;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((order = arrivedCustomer(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(order)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(order));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(order);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[wait] = currentTime - arriveTime[wait];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mealTimes[Integer.parseInt(seat)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(seat)]\n\t\t\t\t\t+ waitTimes[Integer.parseInt(seat)]) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\tfor (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\t// 空席の最初の座席番号を設定する\n\t\t\t\tfirstSeatNum = i - emptyseatsNum;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif (seats[i] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint[] arrivals = new int[100];\n\t\tint[] seats = new int[17];\n\t\tint[] end_seats = new int[17];\n\t\tint[] wait = new int[100];\n\t\tArrays.fill(seats, -1);\n\t\tArrays.fill(end_seats, -1);\n\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tarrivals[i] = 5 * i;\n\t\t}\n\n\t\tint porpos = 0;\n\t\tEND: for (int time = 0;; time++) {\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(seats));\n\t\t\t\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\tif (seats[i] != -1 && end_seats[i] <= time) {\n\t\t\t\t\tseats[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLOOP:while (arrivals[porpos] <= time) {\n\t\t\t\t\n\t\t\t\t//System.out.println(porpos);\n\t\t\t\t\n\t\t\t\tboolean f_fount = false;\n\t\t\t\tfor (int i = 0; i < 17 - (porpos % 5 == 1 ? 5 : 2); i++) {\n\t\t\t\t\tboolean found = true;\n\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\tif (seats[i + j] != -1) {\n\t\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tf_fount = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\t\tseats[i + j] = porpos;\n\t\t\t\t\t\t\tend_seats[i + j] = time + 17 * (porpos % 2) + 3\n\t\t\t\t\t\t\t\t\t* (porpos % 3) + 19;\n\t\t\t\t\t\t\twait[porpos] = time - arrivals[porpos];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (porpos == 99) {\n\t\t\t\t\t\t\tbreak END;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tporpos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!f_fount){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (sc.hasNext()) {\n\t\t\tSystem.out.println(wait[sc.nextInt()]);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    //席数\n    private static final int NUMBER_OF_SEATS = 17;\n\n    //各席が、いつ（何分）になったら使用可能になるかを格納する。\n    private static int[] SEATS_ARRAY = new int[NUMBER_OF_SEATS];\n\n    //グループ数\n    private static int NUMBER_OF_GROUPS = 100;\n\n    public static void main(String[] args) {\n\n        Scanner in = new Scanner(System.in);\n        // 待ち時間を取得します。\n        int[] waitingTime = calcWaitingTime();\n\n        while(in.hasNextLine()){\n            String str = in.nextLine();\n            if(str == null || \"\".equals(str)){\n                break;\n            }\n            System.out.println(waitingTime[Integer.parseInt(str)]);\n        }\n        in.close();\n    }\n\n    //待ち時間を計算します。\n    private static int[] calcWaitingTime() {\n\n        clear(SEATS_ARRAY);\n\n        // 各グループの人数\n        int[] group = getGroup(NUMBER_OF_GROUPS);\n\n        // 各グループの食事時間\n        int[] eatingTime = getEatingTime(NUMBER_OF_GROUPS);\n\n        // i番目の客の到着時間\n        int[] arriveTime = getArriveTime(NUMBER_OF_GROUPS);\n\n        int top = 0;\n        int[] waitingTime = new int[NUMBER_OF_GROUPS];\n        int totalTime = 0;\n\n        // 待ち時間を計算する\n        while (top < NUMBER_OF_GROUPS) {\n\n            // 先頭グループの人数分の空きがあるかを確認し、空いている席を取得\n            int index = getVacantIndex(group[top], totalTime);\n\n            // 空いている席がなければ座れるまで時間を進める。\n            while (index == -1) {\n                index = getVacantIndex(group[top], ++totalTime);\n            }\n            if (totalTime > arriveTime[top]){\n                waitingTime[top] = totalTime - arriveTime[top];\n            }else {\n                waitingTime[top] = 0;\n            }\n            for (int idx = index; idx < group[top] + index; idx++) {\n                SEATS_ARRAY[idx] = totalTime + eatingTime[top];\n                if(totalTime < arriveTime[top]) {\n                    SEATS_ARRAY[idx] = arriveTime[top] + eatingTime[top];\n                } else {\n                    SEATS_ARRAY[idx] = totalTime + eatingTime[top];\n                }\n            }\n            top++;\n            if(top < NUMBER_OF_GROUPS && totalTime < arriveTime[top]) {\n                totalTime = arriveTime[top];\n            }\n        }\n        return waitingTime;\n    }\n\n    //num席連続して空いている席の番号を返却する。\n    private static int getVacantIndex(int num, int totalTime) {\n        int index = -1;\n        int vacant = 0;\n\n        for (int i = 0; i < NUMBER_OF_SEATS; i++) {\n            if (SEATS_ARRAY[i] <= totalTime) {\n                if (index == -1) {\n                    index = i;\n                }\n                if (++vacant == num) {\n                    return index;\n                }\n            } else {\n                vacant = 0;\n                index = -1;\n            }\n        }\n        return -1;\n    }\n\n    //各グループの到着時刻を配列に格納し返却する\n    private static int[] getArriveTime(int num) {\n        int[] aTime = new int[num];\n\n        for (int i = 0; i < num; i++) {\n            aTime[i] = i * 5;\n        }\n        return aTime;\n    }\n\n    //各グループの食事時間を配列に格納し返却する\n    private static int[] getEatingTime(int num) {\n        int[] oTime = new int[num];\n\n        for (int i = 0; i < num; i++) {\n            oTime[i] = 17 * (i % 2) + 3 * (i % 3) + 19;\n        }\n        return oTime;\n    }\n\n    //各グループの人数を配列に格納し返却する\n    private static int[] getGroup(int num) {\n        int[] group = new int[num];\n        int persons;\n\n        for (int i = 0; i < num; i++) {\n            persons = 2;\n            if (i % 5 == 1) {\n                persons = 5;\n            }\n            group[i] = persons;\n        }\n        return group;\n    }\n\n    //配列を初期化する。\n    private static void clear(int[] ary) {\n        for (int i = 0; i < ary.length; i++) {\n            ary[i] = 0;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<>();\n        arrivalTimeList = new ArrayList<>();\n        eatTimeList = new ArrayList<>();\n        sitTimeList = new ArrayList<>();\n        waitTimeList = new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            try {\n                inputNumber = Integer.valueOf(br.readLine());\n            } catch (IOException e) {\n                System.out.println(\"inputError\" + e.getMessage());\n            }\n            if (inputNumber == null) {\n                break;\n            }\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    private static void printCustomer() {\n        System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\");\n        System.out.print(\"\");\n        System.out.println(\"\");\n        for (int i = 0; i < arrivalTimeList.size(); i++) {\n            System.out.print(i + \"\\t\\t\");\n            System.out.print(arrivalTimeList.get(i) + \"\\t\\t\");\n            System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n            System.out.println(eatTimeList.get(i));\n        }\n    }\n\n    private static void printQuere() {\n        System.out.print(\"キュー＝\");\n        for (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n            System.out.print(it.next());\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void printCounter() {\n        System.out.print(currentTime + \"：[\");\n        for (int a : serviceCouters) {\n            System.out.print(a + \", \");\n        }\n        System.out.println(\"]\");\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n\n            // 入力\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetAndResult = new LinkedHashMap<Integer, Integer>();\n            while (sc.hasNext()) {\n                targetAndResult.put(sc.nextInt(), 0);\n            }\n\n            // 席\n            int[] chairs = new int[17];\n            // 待ち行列\n            Deque<Integer> customers = new LinkedList<Integer>();\n            // 店に来た客グループ数\n            int cameGroupCount = 0;\n            // 経過時間数\n            int pastMinutes = 0;\n            // 座れた客グループ数\n            int sitGroupCount = 0;\n\n            // 1ループ = 1分\n            while (sitGroupCount <= 100) {\n\n                // 客が来る\n                boolean isCustomerCame = comeCustomer(customers, pastMinutes,\n                        cameGroupCount);\n\n                // 食べる\n                eat(chairs);\n\n                // 席に着く\n                int sitCustomerOnMinute = sit(chairs, customers, cameGroupCount);\n\n                // 後処理\n                if (isCustomerCame) {\n                    cameGroupCount++;\n                }\n\n                // 座れた人の時間の計測\n                for (int i = 1; i <= sitCustomerOnMinute; i++) {\n                    if (targetAndResult.containsKey(sitGroupCount)) {\n                        int waitMinutes = pastMinutes - (5 * (sitGroupCount));\n\n                        targetAndResult.put(sitGroupCount, waitMinutes);\n                    }\n\n                    sitGroupCount++;\n                }\n\n                pastMinutes++;\n\n            }\n\n            for (Entry<Integer, Integer> entry : targetAndResult.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static boolean comeCustomer(Deque<Integer> customers, int minutes,\n            int cameGroupCount) {\n        if (cameGroupCount > 100) {\n            // 100人までしか来ない\n            return false;\n        }\n\n        if (minutes % 5 == 0) {\n            // 5分後に到着する\n            if (cameGroupCount % 5 == 1) {\n                // i%5 = 1のとき5人到着\n                customers.offer(5);\n            } else {\n                // それ以外は2人到着\n                customers.offer(2);\n            }\n            // 客が来た\n            return true;\n        }\n\n        // 客が来なかった\n        return false;\n    }\n\n    private static void eat(int[] chairs) {\n        for (int i = 0; i < chairs.length; i++) {\n            chairs[i] = (chairs[i] - 1) < 0 ? 0 : chairs[i] - 1;\n        }\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> customers,\n            int cameGroupCount) {\n        int sitGroupCount = 0;\n\n        Integer firstCustomersNumber = customers.peek();\n\n        if (firstCustomersNumber == null) {\n            // 客が待っていない場合には何もしない\n            return sitGroupCount;\n        }\n\n        int sequencialChair = 0;\n        int sittableChairStart = 0;\n        boolean sittable = false;\n        for (int i = 0; i < chairs.length; i++) {\n            // 席が空いているかどうかを判定\n            if (chairs[i] == 0) {\n                sequencialChair++;\n            } else {\n                sequencialChair = 0;\n            }\n\n            if (sequencialChair >= firstCustomersNumber) {\n                // 連続した席数が必要数に達していたら、その時点のインデックスを返却\n                sittableChairStart = i - (firstCustomersNumber - 1); // 必要席数なので、-1\n                sittable = true;\n                break;\n            }\n        }\n\n        if (!sittable) {\n            // 座れる席が無かった\n            return sitGroupCount;\n        }\n\n        // 待ち行列から削除して座れた扱いとする\n        sitGroupCount++;\n        customers.poll();\n\n        for (int j = 0; j < firstCustomersNumber; j++) {\n            // 席に所要時間をカウント\n            chairs[j + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れる可能性があるので、再帰呼出し\n        cameGroupCount++;\n        sitGroupCount += sit(chairs, customers, cameGroupCount);\n\n        // 座れた\n        return sitGroupCount;\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveMinutes = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealMinutes = new int[GROUP_NUM];\n\t\twaitMinutes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveMinutes[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitMinutes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitMinutes() {\n\t\t// 順番\n\t\tint groupOrder;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentMinutes = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentMinutes++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentMinutes);\n\n\t\t\tif ((groupOrder = searchGroupNum(arriveMinutes, currentMinutes)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(groupOrder)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(groupOrder), totalGroupNum);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(groupOrder);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\tfor (int index = 0; index < waitList.size(); index++) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(waitList.get(index))) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(waitList.get(index)), totalGroupNum);\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitMinutes[waitList.get(index)] = currentMinutes\n\t\t\t\t\t\t\t\t- arriveMinutes[waitList.get(index)];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(index);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile (!isNull(line = br.readLine()) && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitMinutes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int searchGroupNum(int[] targets, int currentMinutes) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (isSame(target, currentMinutes)) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentMinutes) {\n\n\t\tfor (int seatNum = 0; seatNum < seats.length; seatNum++) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (isNull(seats[seatNum])) {\n\t\t\t\t// 空席の場合\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (finishedMeal(currentMinutes, seats[seatNum])) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/** 引数がnullか空白の場合、trueを返す */\n\tprivate static boolean isNull(String param) {\n\t\treturn param == null;\n\t}\n\n\t/** 食事の時間が終了した座席の場合、trueを返す */\n\tprivate static boolean finishedMeal(int currentMinutes, String seat) {\n\t\treturn currentMinutes\n\t\t\t\t- (arriveMinutes[Integer.parseInt(seat)] + waitMinutes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) >= mealMinutes[Integer.parseInt(seat)];\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupOrder, int totalGroupNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupOrder)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupOrder;\n\t\t}\n\t\ttotalGroupNum++;\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (isNull(seats[i])) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (isSame(customersNum[groupsNum], emptyseatsNum)) {\n\t\t\t// 空席の最初の座席番号を設定する\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** 第一引数と第二引数が同じ場合、trueを返す */\n\tprivate static boolean isSame(int param, int target) {\n\t\treturn param == target;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\npublic class Main{\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n\n        exec();\n    }\n\n    private static void exec() throws NumberFormatException, IOException {\n\n        InputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        String line; // 引数行\n\n        while ((line = br.readLine()) != null) {\n\n            int n = Integer.parseInt(line);\n            int baseTime = 0; // 基準時間\n            int addGroupNo = -1; // 入店したグループNo\n            int groupMember = 0; // 入店したグループ人数\n            int blankStartSeatNo = -1; // 空席No\n\n            // 座席状態の初期化\n            Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n            // 待ち行列の初期化\n            LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n            while (addGroupNo != n) {\n\n                // 座席の状態更新\n                updateSeatStatus(seatStatusMap, baseTime);\n\n                // 待ち行列の状態更新\n                updateQueueStatus(queueStatusList, baseTime);\n\n                int waitGroupSize = queueStatusList.size();\n\n                for (int i = 0; i < waitGroupSize; i++) {\n\n                    // 待ち行列の先頭グループ人数取得\n                    groupMember = queueStatusList.peek().groupMember;\n\n                    // 空席シートNoの取得\n                    blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                    if (blankStartSeatNo >= 0) {\n\n                        // 座席に先頭グループ追加\n                        addGroupNo =\n                            addSeat(seatStatusMap, queueStatusList.peek(), baseTime,\n                                blankStartSeatNo, n);\n\n                        // 待ち行列の先頭グループ削除\n                        queueStatusList.remove();\n\n                    } else {\n\n                        // 座れる座席なし\n                        break;\n                    }\n                }\n\n                baseTime++;\n            }\n\n        }\n\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(seatNo);\n\n        for (int i = 0; i < seatNo; i++) {\n            GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        for (int i = 0; i < 17; i++) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatusMap.get(i).endStayTime = time;\n\n                if ((seatStatusMap.get(i).endStayTime - seatStatusMap.get(i).startStayTime) == getMealTime(seatStatusMap\n                    .get(i).groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.get(i).groupNo = -1;\n                    seatStatusMap.get(i).groupMember = 0;\n                    seatStatusMap.get(i).startStayTime = 0;\n                    seatStatusMap.get(i).endStayTime = 0;\n                    seatStatusMap.get(i).isStay = false;\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap, GroupStatus queueStatus,\n            int baseTime, int blankStartSeatNo, int n) {\n\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCounters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCounters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCounters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了。\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCounters.length; i++) {\n            if (serviceCounters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCounters[i]) == (currentTime - sitTimeList.get(serviceCounters[i]))) {\n                    int emptyCounter = serviceCounters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCounters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCounters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n        for (int startPoint = 0; startPoint < serviceCounters.length; startPoint++) {\n            if (serviceCounters[startPoint] == -1) {\n                int emptyCount = 1;\n                for (int endpoint = startPoint + 1; endpoint < serviceCounters.length; endpoint++) {\n                    // 空席ならカウント\n                    if (serviceCounters[endpoint] == -1) {\n                        emptyCount++;\n                        // 連続空席がグループの人数以上か判定\n                        if (emptyCount >= groupNumberOfPeopleList.get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                    } else {\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tint[] ans = new int[100];\n\t\n\tpublic int judge(int[] seat, int i){\n\t\tint key = -1;\n\t\tint[] dp = new int[18];\n\t\tint num = (i%5 == 1) ? 5 : 2;\n\t\tfor(int j = 1; j < 18; j++){\n\t\t\tif( seat[j-1] == -1 ){\n\t\t\t\tdp[j] = dp[j-1] + 1;\n\t\t\t\tif( dp[j] >= num ){\n\t\t\t\t\tkey = j-num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn key;\n\t}\n\tpublic void simulate(){\n\t\tQueue<Integer> queue = new PriorityQueue<Integer>();\n\t\tQueue<Integer> time = new PriorityQueue<Integer>();\n\t\tMap<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();\n\t\tint[] seat = new int[17];\n\t\tfor(int i = 0; i < 17; i++){\n\t\t\tseat[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < 30; i++){\n\t\t/*\twriter.println(queue);\n\t\t\twriter.println(time);\n\t\t\twriter.println(map);\n\t\t\tfor(int a : seat){\n\t\t\t\twriter.print(a + \" \");\n\t\t\t}\n\t\t\twriter.println();*/\n\t\t\tint t = (time.peek() == null) ? 5*i+1 : time.peek();\n\t\t\twhile( 5*i >= t ){\n\t\t\t\tfor(int j = 0; j < seat.length; j++){\n\t\t\t\t\tif( map.get(t).contains(seat[j]) ){\n\t\t\t\t\t\tseat[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile( queue.peek() != null ){\n\t\t\t\t\tint check = queue.peek();\n\t\t\t\t\tint key = judge(seat, check);\n\t\t\t\t\tif( key >= 0 ){\n\t\t\t\t\t\tint num = (check%5 == 1) ? 5 : 2;\n\t\t\t\t\t\tfor(int j = key; j < key+num; j++){\n\t\t\t\t\t\t\tseat[j] = check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans[check] = t-check*5;\n\t\t\t\t\t\tint x = 17*(check%2) + 3*(check%3) + 19 + time.peek();\n\t\t\t\t\t\ttime.offer(x);\n\t\t\t\t\t\tSet<Integer> temp = (map.get(x) != null) ? map.get(x) : new HashSet<Integer>();\n\t\t\t\t\t\ttemp.add(check);\n\t\t\t\t\t\tmap.put(x, temp);\n\t\t\t\t\t\tqueue.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttime.remove();\n\t\t\t\tt = (time.peek() == null) ? 5*i+1 : time.peek();\n\t\t\t}\n\t\t\tif( queue.peek() != null ){\n\t\t\t\tqueue.offer(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint key = judge(seat, i);\n\t\t\tif( key >= 0 ){\n\t\t\t\tint num = (i%5 == 1) ? 5 : 2;\n\t\t\t\tfor(int j = key; j < key+num; j++){\n\t\t\t\t\tseat[j] = i;\n\t\t\t\t}\n\t\t\t\tint x = 17*(i%2) + 3*(i%3) + 19 + i*5;\n\t\t\t\ttime.offer(x);\n\t\t\t\tSet<Integer> temp = (map.get(x) != null) ? map.get(x) : new HashSet<Integer>();\n\t\t\t\ttemp.add(i);\n\t\t\t\tmap.put(x, temp);\n\t\t\t} else {\n\t\t\t\tqueue.offer(i);\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tsimulate();\n\t\twhile( stdIn.hasNext() ){\n\t\t\tint n = stdIn.nextInt();\n\t\t\twriter.println(ans[n]);\n\t\t\twriter.flush();\n\t\t}\n\t\twriter.flush();\t\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tScanner stdIn;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\tstdIn = null;\n\t\ttry{\n\t\t\tstdIn = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tstdIn.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n    private static int TIME = 99999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            boolean firstCustomer = false;\n            int kuusekiCount = 0;\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れるか確認。\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint order;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((order = arrivedCustomer(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(order)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(order));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(order);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[wait] = currentTime - arriveTime[wait];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentTime - (arriveTime[Integer.parseInt(seat)]\n\t\t\t\t\t+ waitTimes[Integer.parseInt(seat)]) >= mealTimes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\t\tint i = 0;\n\n\t\tfor (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (seats[i] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t// 空席の最初の座席番号を設定する\n\t\t\tfirstSeatNum = i - emptyseatsNum;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ????????????????????°???????????????\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ????????????????????°???????????????\n\t\t\t// ??????\n\t\t\tint time = 0;\n\t\t\t// ??°???????????°???????????????\n\t\t\tint groupNum = 0;\n\n\t\t\t// ?????????\n\t\t\twhile (true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(groupNum);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(groupNum, guest, seatNum, seat, time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == groupNum) {\n\t\t\t\t\t\t\tSystem.out.println(time - groupNum * 5);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (waitGuest.get(0) == groupNum) {\n\t\t\t\t\t\t\t\t++groupNum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twaitGuest.remove(0);\n\n\t\t\t\t\t\t// ???????????????????????????????????\\???????????´???\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++groupNum;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++time;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????????????????????????????????????\n\n\t//\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n//\t\tString a = \"5\\r\\n6\\r\\n7\\r\\n8\";\n//\t\tInputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n//\t\t// 意味的にはSystem.in = bais;\n//\n//\t\tBufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].eatTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\tint [][] data;\n\tint [] table;\n\tLinkedList<Integer> mat;\n\t\n\tprivate void doit(){\n\t\tdata = new int[100][2];\n\t\tinit();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(data[n][1] - data[n][0]);\n\t\t}\n\t}\n\n\tprivate void init() {\n\t\ttable = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tmat = new LinkedList<Integer>();\n\t\tfor(int i = 0;; i++){\n\t\t\tif(i != 0 && isOK()) break;\n\t\t\tout(i);\n\t\t\tif(i % 5 == 0 && i / 5  < 100){\n\t\t\t\tdata[i / 5][0] = i;\n\t\t\t\tmat.addLast(i / 5);\n\t\t\t}\n\t\t\twhile(in(i)){\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tprivate boolean in(int time) {\n\t\tif(mat.isEmpty()) return false;\n\t\tint nextid = mat.getFirst();\n\t\tint num = 0;\n\t\tif(nextid % 5 == 1){\n\t\t\tnum = 5;\n\t\t}\n\t\telse{\n\t\t\tnum = 2;\n\t\t}\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1) continue;\n\t\t\tint now = 1;\n\t\t\tfor(int j = i + 1; j < table.length; j++){\n\t\t\t\tif(table[j] == -1){\n\t\t\t\t\tnow++;\n\t\t\t\t\tif(now == num){\n\t\t\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\t\t\ttable[i + k] = nextid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[nextid][1] = time;\n\t\t\t\t\t\tmat.removeFirst();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void out(int time) {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] >= 0){\n\t\t\t\tint id = table[i];\n\t\t\t\tint res = data[id][0] + 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t\t\tif(res == time){\n\t\t\t\t\ttable[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK() {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // ?????????????????£???????????????????´????????????????\n        List<String> waitingCustomersList = new ArrayList<String>();\n\n        List<String> list = new ArrayList<String>();\n\n        List<String> waitingStartTimeList = new ArrayList<String>();\n\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // ??\\???????????????null???????????????????????????????????????????????????\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // ?£????????????£?????¢??????????????£??????????????????\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // ?????£????????????????????§??£????????????\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n                \n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n\n//            for (int countt = 0; countt < countDelete; countt++) {\n//                waitingCustomersList.remove(0);\n//                waitingStartTimeList.remove(0);\n//            }\n            // ??¢?????????\n            if (timeGoesBy % 5 == 0) {\n                // ??¢????????°???????????????\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // ???????????????????????????????????????????????????\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // ??¢???????????§?????????????????????????????§????????°???????????????\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // ??¢????????°???????????????\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ?£????????????£?????¢??????????????????\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final int MAX_GROUP_COUNT = 100;\n\tprivate int time = 0;\n\tprivate int groupCount = 0;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().execute();\n\t}\n\n\tprivate void execute() throws Exception {\n\n\t\t// 標準入力を１行ずつ処理\n\t\tList<String> targetGroups = readInitialData();\n\n\t\tEatingPerson[] seats = new EatingPerson[17];\n\t\tList<WaitingPerson> waitingGroups = new ArrayList<WaitingPerson>();\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t\twhile (groupCount < MAX_GROUP_COUNT) {\n\n\t\t\t// 行列の更新\n\t\t\tupdateWaitLine(waitingGroups);\n\n\t\t\t// 離席する\n\t\t\tleaveSeat(seats);\n\n\t\t\t// 着席する\n\t\t\tsitDown(seats, waitingGroups, waitTimes);\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (String targetGroup : targetGroups) {\n\t\t\tSystem.out.println(waitTimes.get(Integer.parseInt(targetGroup)));\n\t\t}\n\t}\n\n\tprivate void sitDown(EatingPerson[] seats,\n\t\t\tList<WaitingPerson> waitingGroups, List<Integer> waitTimes) {\n\n\t\tint removeCount = 0;\n\t\tfor (WaitingPerson waitingPerson : waitingGroups) {\n\n\t\t\tint emptySeatCount = 0;\n\t\t\tboolean isEmpty = false;\n\t\t\tfor (int i = 0; i < seats.length; i++) {\n\n\t\t\t\t// 空席数を検知\n\t\t\t\tif (seats[i] == null) {\n\t\t\t\t\temptySeatCount++;\n\t\t\t\t} else {\n\t\t\t\t\temptySeatCount = 0;\n\t\t\t\t}\n\n\t\t\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t\t\t\t// 席に座ったグループ数を更新\n\t\t\t\t\tgroupCount++;\n\t\t\t\t\tremoveCount++;\n\t\t\t\t\tisEmpty = true;\n\n\t\t\t\t\t// 所属グループの待ち時間を記録\n\t\t\t\t\twaitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t\t\t\t// 食べ終わる時間を計算\n\t\t\t\t\tint endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n\t\t\t\t\t\t\t* (waitingPerson.getGroup() % 3) + 19;\n\n\t\t\t\t\tfor (int j = 0; j < emptySeatCount; j++) {\n\t\t\t\t\t\tseats[i - j] = new EatingPerson(\n\t\t\t\t\t\t\t\twaitingPerson.getGroup(), endTime + time);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < removeCount; i++) {\n\t\t\twaitingGroups.remove(0);\n\t\t}\n\t}\n\n\tprivate void leaveSeat(EatingPerson[] seats) {\n\t\tfor (int i = 0; i < seats.length; i++) {\n\t\t\tif (seats[i] != null && seats[i].getEndTime() == time) {\n\t\t\t\tseats[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateWaitLine(List<WaitingPerson> waitingGroups) {\n\t\tint nowGroup = time / 5;\n\n\t\t// グループがやってきたか判定\n\t\tif (time % 5 == 0) {\n\t\t\t// グループの人数を算出\n\t\t\tint number = 2;\n\t\t\tif (nowGroup % 5 == 1) {\n\t\t\t\tnumber = 5;\n\t\t\t}\n\n\t\t\t// 行列の後ろに追加\n\t\t\t// 待ち始めた時間を記録\n\t\t\twaitingGroups.add(new WaitingPerson(nowGroup, number, time));\n\t\t}\n\t}\n\n\tprivate List<String> readInitialData() throws IOException {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tString line = null;\n\t\tList<String> groups = new ArrayList<String>();\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tgroups.add(line);\n\t\t}\n\n\t\treturn groups;\n\t}\n\n}\n\nabstract class Person {\n\n\t// 所属グループ\n\tprivate int group;\n\n\tpublic int getGroup() {\n\t\treturn group;\n\t}\n\n\tpublic void setGroup(int group) {\n\t\tthis.group = group;\n\t}\n\n}\n\nclass WaitingPerson extends Person {\n\n\tpublic WaitingPerson(int group, int number, int startTime) {\n\t\tsetGroup(group);\n\t\tsetNumber(number);\n\t\tsetStartTime(startTime);\n\t}\n\n\t// 待ち始めた時刻\n\tprivate int startTime;\n\n\t// グループの人数\n\tprivate int number;\n\n\tpublic int getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(int startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic int getNumber() {\n\t\treturn number;\n\t}\n\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n}\n\nclass EatingPerson extends Person {\n\n\tpublic EatingPerson(int group, int endTime) {\n\t\tsetGroup(group);\n\t\tsetEndtTime(endTime);\n\t}\n\n\t// 食べ終わる時間\n\tprivate int endtTime;\n\n\tpublic int getEndTime() {\n\t\treturn endtTime;\n\t}\n\n\tpublic void setEndtTime(int endtTime) {\n\t\tthis.endtTime = endtTime;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n    // ?¨???¢??°?????§???\n    static final int MAX_NUMBER_OF_VISITOR = 100;\n\n    // ??§?????°\n    static final int NUMBER_OF_SEAT = 17;\n\n    // ??°???????????°??\\??????\n    static final int INTERVAL = 5;\n\n    // ??????????????????\n    static int[] waitingTime = new int[MAX_NUMBER_OF_VISITOR];\n\n    // ???????????§????????¶???\n    static int[] shopSeatTimer = new int[NUMBER_OF_SEAT];\n\n    public static void main(String[] args) {\n\n\t// ?¨??????\\???\n\tScanner sc = new Scanner(System.in);\n\n\tList<Integer> orders = new ArrayList<>();\n\n\twhile (sc.hasNextLine()) {\n\t    String nextLine = sc.nextLine();\n\t    if (\"\".equals(nextLine)) {\n\t\tbreak;\n\t    }\n\t    orders.add(Integer.parseInt(nextLine));\n\t}\n\n\t// ??\\???????????????????????§????????????\n\tint maxOrder = returnMax(orders);\n\n\t// ????????????????????????\n\tArrays.fill(waitingTime, -1);\n\n\t// ?????\\?????¬????????§?????????\n\texecuteSimulation(maxOrder);\n\n\t// ??????????????°?????????????????????????????????\n\tfor (Integer order : orders) {\n\t    System.out.println(waitingTime[order]);\n\t}\n\n\tsc.close();\n\n    }\n\n    private static void executeSimulation(int maxOrder) {\n\t// ????????????\n\tList<Integer> waintinGroup = new ArrayList<>();\n\n\t// ???????????§???????????????(?????????-1??¨??????)\n\tArrays.fill(shopSeatTimer, -1);\n\n\t// ????????????????????????????§?\n\n\tfor (int now = 0;; now++) {\n\n\t    // ?£?????????????????????????????????????????????????????£????????????????-1\n\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\n\t\t// ????????????????????????????????????????????????\n\t\tif (shopSeatTimer[i] != -1) {\n\t\t    shopSeatTimer[i]--;\n\t\t    // ???????????????0???????????????\n\t\t    if (shopSeatTimer[i] == 0) {\n\t\t\tshopSeatTimer[i] = -1;\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now % INTERVAL == 0) {\n\t\twaintinGroup.add(now / INTERVAL);\n\t    }\n\n\t    // ????????????????????§???\n\t    while (true) {\n\t\tif (waintinGroup.isEmpty()) {\n\t\t    break;\n\t\t}\n\n\t\tint group = waintinGroup.get(0);\n\t\tint openSeatHead = canISitDown(group);\n\n\t\t// ???????????????????????°\n\t\tif (openSeatHead != -1) {\n\t\t    // ????????????????????????????´?\n\t\t    waitingTime[group] = now - group * INTERVAL;\n\n\t\t    // /**\n\t\t    // * ???????????°\n\t\t    // */\n\t\t    // System.out.println(\"??°??????????????????\" + group);\n\t\t    // System.out.println(\"????????????\" + waitingTime[group]);\n\t\t    // System.out.println(openSeatHead);\n\t\t    // for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\t\t    // System.out.print(shopSeatTimer[i] + \",\");\n\t\t    // }\n\t\t    // System.out.println();\n\t\t    // /*\n\t\t    // *\n\t\t    // */\n\n\t\t    // ?£?????????????????´?\n\t\t    for (int i = 0; i < howManymembers(group); i++) {\n\t\t\tshopSeatTimer[openSeatHead + i] = howLongToEat(group);\n\t\t    }\n\t\t    // ??????????????????\n\t\t    waintinGroup.remove(0);\n\n\t\t    // ?±??????????????????§??????????????°?????????????????????????????????\n\t\t    if (group == maxOrder) {\n\t\t\treturn;\n\t\t    }\n\n\t\t} else {\n\t\t    break;\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n    // ????????????????????§????????????\n    private static int returnMax(List<Integer> orders) {\n\tint maxOrder = 0;\n\tfor (Integer order : orders) {\n\t    maxOrder = Math.max(order, maxOrder);\n\t}\n\treturn maxOrder;\n\n    }\n\n    // ??§?????????????????????\n    private static int canISitDown(int group) {\n\tint count = 0;\n\tfor (int i = 0; i < NUMBER_OF_SEAT - howManymembers(group) + 1; i++) {\n\t    for (int j = 0; j < howManymembers(group); j++) {\n\t\tif (shopSeatTimer[i + j] == -1) {\n\t\t    count++;\n\t\t} else {\n\t\t    count = 0;\n\t\t    break;\n\t\t}\n\n\t\tif (count == howManymembers(group)) {\n\t\t    return i;\n\t\t}\n\t    }\n\t}\n\treturn -1;\n    }\n\n    // ????????°?????????????????????\n    private static int howManymembers(int group) {\n\treturn group % 5 == 1 ? 5 : 2;\n    }\n\n    // ?£???????????????????\n    private static int howLongToEat(int group) {\n\treturn 17 * (group % 2) + 3 * (group % 3) + 19;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (((endpoint - startPoint) + 1) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class NewFukushimaken {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint order;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((order = arrivedCustomer(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(order)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(order));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(order);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[wait] = currentTime - arriveTime[wait];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (mealTimes[Integer.parseInt(seat)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(seat)]\n\t\t\t\t\t+ waitTimes[Integer.parseInt(seat)]) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\tfor (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\t// 空席の最初の座席番号を設定する\n\t\t\t\tfirstSeatNum = i - emptyseatsNum;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif (seats[i] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main03 {\n\n    public static void main(String[] args) {\n\n    }\n\n    /**\n     * index番目のグループの到着時刻を返却する（正午からの経過時間）\n     * 単位：分\n     * @param index\n     * @return 到着時刻\n     */\n    private static int getArriveTime(int index) {\n        return index * 5;\n    }\n\n    /**\n     * index番目のグループの人数を返却する\n     * 単位：人\n     * @param index\n     * @return 人数\n     */\n    private static int getNums(int index) {\n        return((index % 5 == 1) ? 5 : 2);\n    }\n\n    /**\n     * index番目のグループの所要時間を返却する\n     * 単位：分\n     * @param index\n     * @return 所要時間\n     */\n    private static int getEatingTime(int index) {\n        return 17 * (index % 2) + 3 * (index % 3) + 19;\n    }\n\n    private static boolean checkSheet(int[] sheets, int index, int custmors) {\n\n        boolean canSit = true;\n        for (int i = 0; i < sheets.length; i++) {\n            for (int j = i; j < custmors; j++) {\n                if (j + custmors <= sheets.length) {\n                    if (sheets[j] != 100) {\n                        canSit = false;\n                    }\n                }\n            }\n            if (canSit) {\n                for (int j = i; j < custmors; j++) {\n                    sheets[j] = index;\n                }\n            }\n        }\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\twhile (true) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\tint countDelete = 0;\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\t\tcountDelete++;\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int countt = 0; countt < countDelete; countt++) {\n\t\t\t\twaitingCustomersList.remove(0);\n\t\t\t\twaitingStartTimeList.remove(0);\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t\tif (list.size() == appointedGroupList.size()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(waitingTime);\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n \npublic class Main {\n \n    public static void main(String[] args) {\n \n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n \n        int headGroup = -1;\n        int pastMinutes = 0;\n\n        Scanner sc = new Scanner(System.in);\n\n      List<Integer> inputted = new ArrayList<Integer>();\n      int maxInputted = -1;\n      while (sc.hasNext()) {\n        int ni = sc.nextInt();\n        maxInputted = maxInputted < ni ? ni : maxInputted;\n        inputted.put(ni);\n      }\n      \n        List<Integer> waitTime = new ArrayList<Integer>();\n \n        while (waitTime.size() <= maxInputted) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n \n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n \n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n \n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n \n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n \n            }\n \n            pastMinutes++;\n \n        }\n\n      for(int input : inputted){\n        System.out.println(waitTime.get(input));\n      }\n\n \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * プログラミングコンテスト<br>\n * 0147:Fukushimaken\n *\n * @author t690593\n *\n */\npublic class Main {\n\n\t/** 最大グループ数 */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** 客の到着間隔 */\n\tstatic final int TIME_INTERVAL = 5;\n\n\t/** 座席 */\n\tstatic int[] sheets = new int[17];\n\n\t/** 各グループの待ち時間 */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** インプット */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** インプットの最大グループ番号 */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * メイン\n\t *\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\t// 先頭のグループ番号\n\t\tint frontGroup = 0;\n\t\t// 最後尾のグループ番号\n\t\tint endGroup = 0;\n\t\t// 経過時間：分単位\n\t\tint time = 0;\n\n\t\twhile (true) {\n\t\t\t// 5分間隔でお店に客がくる（最後尾は最大グループ数より大きくならない）\n\t\t\tif (time % TIME_INTERVAL == 0 && endGroup < MAX_GROUP_NUKMBER) {\n\t\t\t\tendGroup++;\n\t\t\t}\n\n\t\t\tfor (int i = frontGroup; i < endGroup; i++) {\n\t\t\t\tint ninzu = i % 5 == 1 ? 5 : 2;\n\t\t\t\tint startPos = getOpendSheetsPosition(ninzu);\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// 座れる場合\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(i), ninzu);\n\t\t\t\t\twaitTimes[i] = time - i * 5;\n\t\t\t\t\tfrontGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 座れない場合\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 入力されたグループ番号の最大番号が席に座るか、全てのグループが席に座ったら終了\n\t\t\tif (frontGroup == MAX_GROUP_NUKMBER || frontGroup > maxGroupNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 座席の食事時間を時間経過とともに減らす\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] = sheets[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * 空いている席の最初の席番号を返却する<br>\n\t * 席が空いていない場合、-1を返却する\n\t *\n\t * @param peopleNum\n\t *            グループの人数\n\t * @return 空いている席の最初の席番号\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * 対象グループの食事時間を計算する\n\t *\n\t * @param targetGroup\n\t *            対象グループ番号\n\t * @return 食事間\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * 座席を確保する\n\t *\n\t * @param startPos\n\t *            席確保する最初の席番号\n\t * @param mealtime\n\t *            確保する時間（食事時間）\n\t * @param peopleNum\n\t *            グループ人数\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Fukushimaken {\n\n    int [] seats;\n    ArrayList<Eater> eating;\n\n    Fukushimaken () {\n        seats = new int[17];\n        for (int i = 0; i < 17; i++)    seats[i] = -1;\n        eating = new ArrayList<Eater>();\n    }\n\n    boolean acceptEater (Eater eater) {\n        int n = eater.size;\n\n        if (n == 2) {\n            for (int i = 0; i < 16; i++) {\n                if (seats[i] == -1 && seats[i+1] == -1) {\n                    eating.add(eater);\n                    eater.setSeatNum(i);\n                    seats[i] = eater.groupNum;\n                    seats[i+1] = eater.groupNum;\n                    return true;\n                }\n            }\n        }\n        else if (n == 5) {\n            for (int i = 0; i < 13; i++) {\n                if (seats[i] == -1 && seats[i+1] == -1 && seats[i+2] == -1 && seats[i+3] == -1 && seats[i+4] == -1) {\n                    eating.add(eater);\n                    eater.setSeatNum(i);\n                    for(int j = 0; j < 5; j++)  seats[i+j] = eater.groupNum;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    void removeEater (int time) {\n        for (int i = 0; i < eating.size(); i++) {\n            while(true) {\n                if ( i >= eating.size() ) break;\n                Eater e = eating.get(i);\n                if (time == e.getEnterTime() + e.existTime) {\n                    for (int k = 0; k < e.size; k++) {\n                        this.seats[e.getSeatNum() + k] = -1;\n                    }\n                    eating.remove(i); \n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    \n}\n\nclass Eater {\n\n    int groupNum;\n    int comeTime;\n    int size;\n    int existTime;\n    private int enterTime;\n    private int seatNum;\n    \n    Eater (int groupNum) {\n        this.groupNum = groupNum;\n        this.comeTime = groupNum * 5;\n\n        if (groupNum % 5 == 1)  this.size = 5;\n        else                    this.size = 2;\n\n        this.existTime = 17 * (groupNum % 2) + 3 * (groupNum % 3) + 19;\n    }\n\n    void setEnterTime (int time) {\n        this.enterTime = time;\n    }\n\n    int getEnterTime () {\n        return this.enterTime;\n    }\n\n    void setSeatNum (int seat) {\n        this.seatNum = seat;\n    }\n\n    int getSeatNum () {\n        return this.seatNum;\n    }\n}\n\nclass Main {\n\n    static Fukushimaken fuk;\n    static ArrayList<Eater> allEaters;\n\n    static void solve () {\n        \n        ArrayList<Eater> waitingEaters = new ArrayList<Eater>();\n\n        for(int t = 0; t < 5000; t++) {\n            fuk.removeEater(t);\n            if (t % 5 == 0 && t < 500)     waitingEaters.add(allEaters.get(t/5));\n            while ((!waitingEaters.isEmpty()) && fuk.acceptEater(waitingEaters.get(0))) {\n                int n = waitingEaters.get(0).groupNum;\n                allEaters.get(n).setEnterTime(t);\n                waitingEaters.remove(0);\n            }\n\n//            System.out.printf(\"%3d: \", t);\n//            for(int i = 0; i < 17; i++) {\n//                int j = fuk.seats[i];\n//                if ( j == -1 )  System.out.print(\"__\");\n//                else if ( j < 10 )   System.out.printf(\"0%d\", j);\n//                else    System.out.print(j);\n//           }\n//            System.out.println(\"\");\n\n        }\n    }\n\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n        fuk = new Fukushimaken();\n        allEaters = new ArrayList<Eater>();\n\n        for(int i = 0; i < 100; i++) {\n            allEaters.add(new Eater(i));\n        }\n\n        solve();\n\n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println( allEaters.get(n).getEnterTime() - allEaters.get(n).comeTime );\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        int customerCount = 0;\n        List<Integer> waitTime = new ArrayList<Integer>(100);\n\n        while (customerCount < 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                // headGroup = pastMinutes / 5;\n                headGroup = (pastMinutes >> 2) - pastMinutes;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == groupMembers[headGroup % 5]) {\n                        startIndex = i - (groupMembers[headGroup % 5] - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + groupMembers[headGroup % 5]); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                    customerCount++;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0147().doIt();\n\t}\n\t\n\tclass AOJ0147{\n\t\tint[] waitTime;\n\t\tState[] states;\n\t\tvoid doIt(){\n\t\t\twaitTime = new int[100];\n\t\t\tLinkedList<WaitState> q = new LinkedList<WaitState>();\n\t\t\tstates = new State[17];\n\t\t\tfor(int i=0;i<17;i++)states[i] = new State(-1, -1);\n\t\t\tfor(int i=0;i<100*5;i++){\n\t\t\t\tremoveState(i);\n\t\t\t\tif(i%5==0)q.add(new WaitState(i/5, (i/5)%5==1? 5:2, i));//stack\n\t\t\t\tint index = -1;\n\t\t\t\tif(q.size()>0)index = canPush(q.get(0));\n\t\t\t\twhile(index >= 0){\n\t\t\t\t\twaitTime[q.get(0).ban] = i-q.get(0).startTime;\n\t\t\t\t\tsetState(q.remove(), index, i);\n\t\t\t\t\tif(q.size()==0)break;\n\t\t\t\t\tindex = canPush(q.get(0));\n//\t\t\t\t\tSystem.out.println(q.get(0).ban+\" \"+q.get(0).num+\" \"+q.get(0).startTime+\" \"+index);\n\t\t\t\t}\n//\t\t\t\tprintState(i);\n//\t\t\t\tSystem.out.println(\"stacks are \");\n//\t\t\t\tfor(int s=0;s<q.size();s++)System.out.println(q.get(s).ban+\" \"+q.get(s).num);\n//\t\t\t\tSystem.out.println(\"--------------\");\n\n\t\t\t}\n\t\t\twhile(in.hasNext())System.out.println(getResult(in.nextInt()));\n\t\t}\n\t\t\n\t\tvoid printState(int time){\n\t\t\tfor(int i=0;i<17;i++){\n\t\t\t\tSystem.out.println((time)+\":\"+states[i].ban+\" _ \"+states[i].endTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid removeState(int time){\n\t\t\tfor(int i=0;i<17;i++)if(states[i].ban>=0&&states[i].endTime<=time)\n\t\t\t\tstates[i] = new State(-1, -1);\n\t\t}\n\t\t\n\t\tvoid setState(WaitState j,int index,int currentTime){\n\t\t\tint endTime = 17*(j.ban%2)+3*(j.ban%3)+19; \n\t\t\tfor(int i=index;i<index+j.num;i++){\n\t\t\t\tstates[i] = new State(j.ban, endTime+currentTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint canPush(WaitState j){\n\t\t\tfor(int i=0;i<17-j.num;i++)if(states[i].ban == -1){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int s=i;s<i+j.num;s++)if(states[s].ban == -1)cnt++;\n\t\t\t\tif(cnt==j.num)return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint getResult(int n){\n\t\t\treturn waitTime[n];\n\t\t}\n\t\t\n\t\tclass WaitState{\n\t\t\tint ban,num,startTime;\n\t\t\tpublic WaitState(int _ban,int _num,int _startTime) {\n\t\t\t\tban = _ban;\n\t\t\t\tnum = _num;\n\t\t\t\tstartTime = _startTime;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint ban,endTime;\n\t\t\tpublic State(int _ban,int _endTime){\n\t\t\t\tban = _ban;\n\t\t\t\tendTime = _endTime;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 0147:Fukushimaken\n * \n * @author MS14A\n * @version 2015/05/09\n */\npublic class Main {\n\n    /** 席での食事時間の残を格納する配列 */\n    private static int[] seatWaitTime = new int[17];\n\n    /**\n     * メインメソッド\n     * \n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n\n        // 標準入力読取り。\n        List<Integer> inputGroupNumbers = getGroupNumbers();\n\n        for (Integer inputGroupNumber : inputGroupNumbers) {\n            // 各席での食事時間を初期化\n            Arrays.fill(seatWaitTime, 0);\n\n            // 与えられたグループ番号の待ち時間を算出・表示\n            System.out.println(getWaitingTime(inputGroupNumber.intValue()));\n        }\n    }\n\n    /**\n     * 指定された番号のグループの待ち時間を計算し、返却する。\n     * \n     * @param inputGroupNumber 指定されたグループ番号\n     * @return 待ち時間\n     */\n    private static int getWaitingTime(int inputGroupNumber) {\n\n        List<Integer> waitingGroups = new ArrayList<Integer>(); // 席待ちのグループを格納するリスト\n        int groupNumber = 0; // グループ番号\n        boolean canSit = false; // 行列の先頭グループが着席可能ならtrue\n\n        int time = 0; // 経過時間\n        int waitingStartTime = 0; // 指定グループが並び始めた時間\n        int waitingEndTime = 0; // 指定グループが席に着いた時間\n\n        while (!canSit) {\n            // 食事時間を一分消化\n            for (int i = 0; i < seatWaitTime.length; i++) {\n                if (seatWaitTime[i] > 0) {\n                    seatWaitTime[i] -= 1;\n                }\n            }\n\n            // グループが来る\n            if (time % 5 == 0) {\n                groupNumber = time / 5;\n                waitingGroups.add(Integer.valueOf(groupNumber));\n\n                // 店に来たグループが指定グループなら、待ち時間のカウント開始\n                if (groupNumber == inputGroupNumber) {\n                    waitingStartTime = time;\n                }\n            }\n\n            if (!waitingGroups.isEmpty()) {\n                // 座れる場合は待ちリストから削除していく\n                canSit = sit(getNumberOfGroupMember(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n\n                while (canSit) {\n                    // 席に着いたグループが指定グループの場合、待ち時間をカウントしループ終了\n                    if (waitingGroups.get(0) == inputGroupNumber) {\n                        waitingEndTime = time;\n                        break;\n                    }\n                    \n                    // 席に着いたグループを待ちグループのリストから削除\n                    waitingGroups.remove(0);\n                    if (waitingGroups.isEmpty()) {\n                        canSit = false;\n                    } else {\n                        // 次の待ちグループがいた場合、席に着けるか確認\n                        canSit = sit(getNumberOfGroupMember(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n                    }\n                }\n            }\n\n            ++time;\n        }\n\n        return waitingEndTime - waitingStartTime;\n    }\n\n    /**\n     * グループを席に着かせる<br>\n     * <br>\n     * 【説明】<br>\n     *  グループの人数分だけ連続した空席があるか確認し、空席が存在すれば<br>\n     *  グループの食事時間を配列に格納する。\n     * \n     * @param NumberOfGroupMember グループの人数\n     * @param eatingTimeOfGroup グループの食事時間\n     * @return グループの人数分空席があればtrue、空席がなければfalse\n     */\n    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {\n        int count = 0;\n        for (int i = 0; i < seatWaitTime.length; ++i) {\n            if (seatWaitTime[i] == 0) {\n                count += 1;\n                \n                // 空席が人数分連続していれば、人数分の食事時間を配列に格納(＝席に着かせる)\n                if (count == NumberOfGroupMember) {\n                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);\n                    return true;\n                }\n            } else {\n                count = 0;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * グループの人数を求める。\n     * \n     * @param groupNumber グループ番号\n     * @return グループの人数\n     */\n    private static int getNumberOfGroupMember(int groupNumber) {\n        if (groupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * グループの食事時間を求める。\n     * \n     * @param groupNumber グループ番号\n     * @return グループの食事時間\n     */\n    private static int getEatingTime(int groupNumber) {\n        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;\n    }\n\n    /**\n     * 標準入力から待ち時間を計算するグループ番号を読取り、リストで返却する。\n     * \n     * @return グループ番号のリスト\n     * @throws IOException\n     */\n    private static List<Integer> getGroupNumbers() throws IOException {\n        // 入力読取り\n        InputStreamReader streamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(streamReader);\n\n        String line = null;\n        List<Integer> groupNumbers = new ArrayList<Integer>();\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                groupNumbers.add(Integer.parseInt(line));\n            }\n            return groupNumbers;\n            \n        } finally {\n            bufferedReader.close();\n            streamReader.close();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n//Fukushimaken\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] c = new int[17];\n\t\tint[] p = new int[100];\n\t\tint[] w = new int[100];\n\t\tint[] sit = new int[100];\n\t\tfor(int i=0;i<100;i++){\n\t\t\tp[i] = i%5==1?5:2;\n\t\t\tw[i] = 17*(i%2)+3*(i%3)+19;\n\t\t}\n\t\tint i = 0;\n\t\tint t = 0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tboolean end = false;\n\t\twhile(!end){\n\t\t\tif(t==i*5&&i<100){\n\t\t\t\tq.add(i++);\n\t\t\t}\n\t\t\tfor(int k=0;k<17;k++)c[k]=Math.max(0, c[k]-1);\n\t\t\tboolean con = true;\n\t\t\twhile(!q.isEmpty()&&con){\n\t\t\t\tcon = false;\n\t\t\t\tint id = q.peek();\n\t\t\t\tfor(int j=0;j+p[id]-1<17;j++){\n\t\t\t\t\tboolean e = true;\n\t\t\t\t\tfor(int k=0;k<p[id];k++){\n\t\t\t\t\t\tif(c[j+k]!=0){\n\t\t\t\t\t\t\te = false;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(e){\n\t\t\t\t\t\tq.poll();\n\t\t\t\t\t\tfor(int k=j;k<j+p[id];k++)c[k]=w[id];\n\t\t\t\t\t\tsit[id] = t;\n\t\t\t\t\t\tif(id==99)end = true;\n\t\t\t\t\t\tcon = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(sit[n]-5*n);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)] + waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static List<Integer> serviceCounterList;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        Integer[] serviceCounters = new Integer[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCounters, -1);\n        serviceCounterList = new ArrayList<Integer>(Arrays.asList(serviceCounters));\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null || inputStr.isEmpty()) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // printCustomer();\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセット\n                if (nextArrivalGroupNumber <= inputNumber\n                        && currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                    waitGroupNumberList.offer(nextArrivalGroupNumber);\n                    nextArrivalGroupNumber++;\n                }\n\n                // 食べ終わったグループがいれば、退店させる\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // printCounter();\n                // printQuere();\n\n                // 現在時間を1分経過させる\n                currentTime++;\n\n                // ループ終了条件\n                // 入力されたグループ番号まで店に到着し、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCounterList.size(); i++) {\n            if (serviceCounterList.get(i) != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCounterList.get(i)) == (currentTime - sitTimeList\n                        .get(serviceCounterList.get(i)))) {\n                    int ateGroupNumber = serviceCounterList.get(i);\n                    // グループの人数分空席にする\n                    Collections.replaceAll(serviceCounterList, ateGroupNumber, -1);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCounterList.set(firstCountNumber + i, firstWaitGroupNumber);\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n        int emptyCount = 0;\n        for (int startPoint = 0; startPoint < serviceCounterList.size(); startPoint++) {\n            if (serviceCounterList.get(startPoint) == -1) {\n                emptyCount = 1;\n                for (int endpoint = startPoint + 1; endpoint < serviceCounterList.size(); endpoint++) {\n                    // 空席ならカウント\n                    if (serviceCounterList.get(endpoint) == -1) {\n                        emptyCount++;\n                        // 連続空席がグループの人数以上か判定\n                        if (emptyCount >= groupNumberOfPeopleList.get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                    } else {\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n    /*\n     * private static void printCustomer() {\n     * System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\"); System.out.print(\"\");\n     * System.out.println(\"\"); for (int i = 0; i < arrivalTimeList.size(); i++)\n     * { System.out.print(i + \"\\t\\t\"); System.out.print(arrivalTimeList.get(i) +\n     * \"\\t\\t\"); System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n     * System.out.println(eatTimeList.get(i)); } }\n     * \n     * private static void printQuere() { System.out.print(\"キュー＝\"); for\n     * (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n     * System.out.print(it.next()); } System.out.println(\"\\n\"); }\n     * \n     * private static void printCounter() { System.out.print(currentTime +\n     * \"：[\"); for (int a : serviceCounterList) { System.out.print(a + \", \"); }\n     * System.out.println(\"]\"); }\n     */\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tint[] ans = new int[120];\n\t\n\tpublic int judge(int[] seat, int i){\n\t\tint key = -1;\n\t\tint[] dp = new int[18];\n\t\tint num = (i%5 == 1) ? 5 : 2;\n\t\tfor(int j = 1; j < 18; j++){\n\t\t\tif( seat[j-1] == -1 ){\n\t\t\t\tdp[j] = dp[j-1] + 1;\n\t\t\t\tif( dp[j] >= num ){\n\t\t\t\t\tkey = j-num;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn key;\n\t}\n\tpublic void simulate(){\n\t\tQueue<Integer> queue = new PriorityQueue<Integer>();\n\t\tQueue<Integer> time = new PriorityQueue<Integer>();\n\t\tMap<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();\n\t\tint[] seat = new int[17];\n\t\tfor(int i = 0; i < 17; i++){\n\t\t\tseat[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < 120; i++){\n\t/*\t\twriter.println(queue);\n\t\t\twriter.println(time);\n\t\t\twriter.println(map);\n\t\t\tfor(int a : seat){\n\t\t\t\twriter.print(a + \" \");\n\t\t\t}\n\t\t\twriter.println();*/\n\t\t\tint t = (time.peek() == null) ? 5*i+1 : time.peek();\n\t\t\twhile( 5*i >= t ){\n\t\t\t\tfor(int j = 0; j < seat.length; j++){\n\t\t\t\t\tif( map.get(t).contains(seat[j]) ){\n\t\t\t\t\t\tseat[j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile( queue.peek() != null ){\n\t\t\t\t\tint check = queue.peek();\n\t\t\t\t\tint key = judge(seat, check);\n\t\t\t\t\tif( key >= 0 ){\n\t\t\t\t\t\tint num = (check%5 == 1) ? 5 : 2;\n\t\t\t\t\t\tfor(int j = key; j < key+num; j++){\n\t\t\t\t\t\t\tseat[j] = check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans[check] = t-check*5;\n\t\t\t\t\t\tint x = 17*(check%2) + 3*(check%3) + 19 + time.peek();\n\t\t\t\t\t\ttime.offer(x);\n\t\t\t\t\t\tSet<Integer> temp = (map.get(x) != null) ? map.get(x) : new HashSet<Integer>();\n\t\t\t\t\t\ttemp.add(check);\n\t\t\t\t\t\tmap.put(x, temp);\n\t\t\t\t\t\tqueue.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttime.remove();\n\t\t\t\tt = (time.peek() == null) ? 5*i+1 : time.peek();\n\t\t\t}\n\t\t\tif( queue.peek() != null ){\n\t\t\t\tqueue.offer(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint key = judge(seat, i);\n\t\t\tif( key >= 0 ){\n\t\t\t\tint num = (i%5 == 1) ? 5 : 2;\n\t\t\t\tfor(int j = key; j < key+num; j++){\n\t\t\t\t\tseat[j] = i;\n\t\t\t\t}\n\t\t\t\tint x = 17*(i%2) + 3*(i%3) + 19 + i*5;\n\t\t\t\ttime.offer(x);\n\t\t\t\tSet<Integer> temp = (map.get(x) != null) ? map.get(x) : new HashSet<Integer>();\n\t\t\t\ttemp.add(i);\n\t\t\t\tmap.put(x, temp);\n\t\t\t} else {\n\t\t\t\tqueue.offer(i);\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\n\tpublic  void solve() throws IOException{\n\t\tsimulate();\n\t\twhile( stdIn.hasNext() ){\n\t\t\tint n = stdIn.nextInt();\n\t\t\twriter.println(ans[n]);\n\t\t\twriter.flush();\n\t\t}\n\t\twriter.flush();\t\t\t\t\n\t}\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tScanner stdIn;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\tstdIn = null;\n\t\ttry{\n\t\t\tstdIn = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tstdIn.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/*** ??°??????????????° */\n\tprivate static final int GROUP_NUM = 100;\n\n\tprivate static BufferedReader br;\n\tprivate static int placeNum;\n\tprivate static int[] arriveTime, customerNum, mealTime, waitTime;\n\n\t/*** ??? */\n\tprivate static String[] places;\n\tprivate static int finalPlace;\n\n\t/*** ????????? */\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tplaceNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomerNum = new int[GROUP_NUM];\n\t\tmealTime = new int[GROUP_NUM];\n\t\twaitTime = new int[GROUP_NUM];\n\t\tplaces = new String[placeNum];\n\n\t}\n\n\t/**\n\t * ?????????????????????\n\t *\n\t * @param args\n\t *            ??????????????°\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\t// ??\\???\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\texe(inputList);\n\n\t\t// ??????\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTime[input]);\n\t\t}\n\n\t}\n\n\tprivate static void exe(List<Integer> inputList) {\n\t\t// ?????????\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tarriveTime[i] = 5 * i;\n\t\t\tcustomerNum[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tmealTime[i] = placeNum * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\n\t\tint key;\n\n\t\t// ????????¢?????????\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// ??\\?????¢?????????\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\t// ??°??????????????¨?????????????????????????????????????????????\n\t\tfor (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n\n\t\t\toutStore(currentTime);\n\n\t\t\t// ?????????????????°????????????\n\t\t\tif ((key = search(arriveTime, currentTime)) != -1) {\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\tif (isEmpty(key)) {\n\t\t\t\t\t\tset(Integer.toString(key));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitList.add(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitList.add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// ???????????¢???????????´???\n\t\t\t\tint i = 0;\n\t\t\t\tboolean flg = true;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\tif (isEmpty(wait) && flg) {\n\t\t\t\t\t\tset(Integer.toString(wait));\n\t\t\t\t\t\twaitTime[wait] = currentTime - arriveTime[wait];\n\t\t\t\t\t\tremoveList.add(i);\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\tCollections.reverse(removeList);\n\t\t\t\tfor (int aRemove : removeList) {\n\t\t\t\t\t// ??\\???????????¢???????????¢???????????????????????????\n\t\t\t\t\twaitList.remove(aRemove);\n\t\t\t\t}\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int search(int[] targets, int currentTime) {\n\t\tint i = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??????????????£?????°?????????????????????????????????\n\t *\n\t */\n\tprivate static void outStore(int currentTime) {\n\t\tint i = 0;\n\t\tfor (String place : places) {\n\t\t\tif (place == null) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mealTime[Integer.parseInt(place)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(place)]) {\n\t\t\t\tplaces[i] = null;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\t/**\n\t * ??°?????????????????§???????¨??????????\n\t *\n\t * @param groupNum\n\t *            ??°???????????????\n\t */\n\tprivate static void set(String groupNum) {\n\n\t\tfor (int i = finalPlace - 1, count = 0; count < customerNum[Integer\n\t\t\t\t.parseInt(groupNum)]; i--, count++) {\n\t\t\tplaces[i] = groupNum;\n\t\t}\n\t}\n\n\t/**\n\t * ?????°?????°?????????????????°?????§?????????????????????????????????\n\t *\n\t * @param groupNum\n\t *            ??°?????????????????°\n\t * @return true : ??§?????? false : ??§?????????\n\t */\n\tprivate static boolean isEmpty(int groupNum) {\n\n\t\t// ????????°\n\t\tint emptyPlaceNum = 0;\n\n\t\tfor (int i = 0; i < placeNum; i++) {\n\t\t\tif (emptyPlaceNum == customerNum[groupNum]) {\n\t\t\t\tfinalPlace = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (places[i] == null) {\n\t\t\t\temptyPlaceNum++;\n\t\t\t} else {\n\t\t\t\temptyPlaceNum = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/*** ??°??????????????° */\n\tprivate static final int GROUP_NUM = 100;\n\n\tprivate static BufferedReader br;\n\tprivate static int placeNum;\n\tprivate static int[] arriveTime, customerNum, mealTime, waitTime;\n\n\t/*** ??? */\n\tprivate static String[] places;\n\tprivate static int finalPlace;\n\n\t/*** ????????? */\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tplaceNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomerNum = new int[GROUP_NUM];\n\t\tmealTime = new int[GROUP_NUM];\n\t\twaitTime = new int[GROUP_NUM];\n\t\tplaces = new String[placeNum];\n\n\t\t// ?????????\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tarriveTime[i] = 5 * i;\n\t\t\tcustomerNum[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tmealTime[i] = placeNum * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\n\t\tint key;\n\n\t\t// ????????¢?????????\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// ??\\?????¢?????????\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\t// ??°??????????????¨?????????????????????????????????????????????\n\t\tfor (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n\t\t\toutStore(currentTime);\n\n\t\t\t// ?????????????????°????????????\n\t\t\tif ((key = search(arriveTime, currentTime)) != -1) {\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\tif (isEmpty(key)) {\n\t\t\t\t\t\tset(Integer.toString(key));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitList.add(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitList.add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// ???????????¢???????????´???\n\t\t\t\tint i = 0;\n\t\t\t\tboolean flg = true;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\tif (isEmpty(wait) && flg) {\n\t\t\t\t\t\tset(Integer.toString(wait));\n\t\t\t\t\t\twaitTime[wait] = currentTime - arriveTime[wait];\n\t\t\t\t\t\tremoveList.add(i);\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\tCollections.reverse(removeList);\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// ??\\???????????¢???????????¢???????????????????????????\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????????\n\t *\n\t * @param args\n\t *            ??????????????°\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\t// ??\\???\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\t// ??????\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTime[input]);\n\t\t}\n\n\t}\n\n\tprivate static int search(int[] targets, int currentTime) {\n\t\tint i = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??????????????£?????°?????????????????????????????????\n\t *\n\t */\n\tprivate static void outStore(int currentTime) {\n\t\tint i = 0;\n\t\tfor (String place : places) {\n\t\t\tif (place == null) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mealTime[Integer.parseInt(place)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(place)]) {\n\t\t\t\tplaces[i] = null;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\t/**\n\t * ??°?????????????????§???????¨??????????\n\t *\n\t * @param groupNum\n\t *            ??°???????????????\n\t */\n\tprivate static void set(String groupNum) {\n\n\t\tfor (int i = finalPlace - 1, count = 0; count < customerNum[Integer\n\t\t\t\t.parseInt(groupNum)]; i--, count++) {\n\t\t\tplaces[i] = groupNum;\n\t\t}\n\t}\n\n\t/**\n\t * ?????°?????°?????????????????°?????§?????????????????????????????????\n\t *\n\t * @param groupNum\n\t *            ??°?????????????????°\n\t * @return true : ??§?????? false : ??§?????????\n\t */\n\tprivate static boolean isEmpty(int groupNum) {\n\n\t\t// ????????°\n\t\tint emptyPlaceNum = 0;\n\t\tboolean flg;\n\n\t\tfor (int i = 0; i < placeNum; i++) {\n\t\t\tif (emptyPlaceNum == customerNum[groupNum]) {\n\t\t\t\tfinalPlace = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (places[i] == null) {\n\t\t\t\temptyPlaceNum++;\n\t\t\t\tflg = true;\n\t\t\t} else {\n\t\t\t\tflg = false;\n\t\t\t}\n\t\t\tif (!flg) {\n\t\t\t\t// ??£?¶???????????????§???????????°???????????°??????????????????\n\t\t\t\temptyPlaceNum = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput < sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れる。\n                        firstCustomer = true;\n                        groupCount--;\n                        // インクリメントされるので-1にしておく。\n                        k = -1;\n                        break;\n                    }\n                }\n                if (firstCustomer) {\n                    continue;\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\t// ??\\????????????????´???¨?????????\n\tList<Integer> inputSet = new ArrayList<>();\n\twhile (sc.hasNextLine()) {\n\t    inputSet.add(Integer.parseInt(sc.nextLine()));\n\t}\n\tfor (Integer query : inputSet) {\n\t    System.out.println(waitingTime[query][1] - waitingTime[query][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\topenStore: for (int now = 0;; now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now / 5 < 100 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    int groupId = waitingGroups.get(0);\n\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\n\t\t\t    // ???????????§??¢?????§??£??????????????????\n\t\t\t    if (groupId == 99) {\n\t\t\t\tbreak openStore;\n\t\t\t    }\n\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput < sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れる。\n                        firstCustomer = true;\n                        groupCount = groupInfo.size();\n                        // インクリメントされるので-1にしておく。\n                        k = -1;\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ??????0????????????????????\\??????????????¨??????\n\t\tint seat [] = new int[17];\n\t\t// ????????????\n\t\tStringBuilder outputStr = new StringBuilder();\n\n\t\t// ?¨??????\\??????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ????????°??????????????°?????????????¨??????????\n\t\t\tint arriveTime = inputNum * 5;\n\t\t\t// ??????\n\t\t\tint time = 0;\n\t\t\t// ??°???????????°???????????????\n\t\t\tint groupNum = 0;\n\n\t\t\t// ????????°???????????????????????§???????????????\n\t\t\twhile(true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// 5i????????¨?????¢?????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\t// ??°???????????°?????????????????°??????\n\t\t\t\t\tint guest = guestOfNumber(groupNum);\n\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\t\t\t\t\t// ?????????????????´???????????¢?????§?????????\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(groupNum , guest , seatNum , seat , time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == groupNum) {\n\t\t\t\t\t\t\toutputStr.append(time - arriveTime).append(\"\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t++groupNum;\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(outputStr);\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber (int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat (int[] seat , int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i+j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken (int groupNum , int guest, int seatNum , int[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat,int time){\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]){\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime (int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    static int inputNumber;\n    // 店のカウンター\n    static List<Integer> serviceCounterList;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTime;\n    // 待ち時間（分）\n    static int waitTime;\n\n    // 初期化\n    public static void init() {\n        inputNumber = 0;\n        Integer[] serviceCounters = new Integer[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCounters, -1);\n        serviceCounterList = new ArrayList<Integer>(Arrays.asList(serviceCounters));\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTime = new ArrayList<Integer>();\n        waitTime = 0;\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null || inputStr.isEmpty()) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // printCustomer();\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセット\n                if (nextArrivalGroupNumber <= inputNumber\n                        && currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                    waitGroupNumberList.offer(nextArrivalGroupNumber);\n                    nextArrivalGroupNumber++;\n                }\n\n                // 食べ終わったグループがいれば、退店させる\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // printCounter();\n                // printQuere();\n\n                // 現在時間を1分経過させる\n                currentTime++;\n\n                // ループ終了条件\n                // 入力されたグループ番号まで店に到着し、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTime);\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCounterList.size(); i++) {\n            if (serviceCounterList.get(i) != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCounterList.get(i)) == (currentTime - sitTime\n                        .get(serviceCounterList.get(i)))) {\n                    int ateGroupNumber = serviceCounterList.get(i);\n                    // 該当グループの席を空席にする\n                    Collections.replaceAll(serviceCounterList, ateGroupNumber, -1);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            if (firstCountNumber == -1) {\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCounterList.set(firstCountNumber + i, firstWaitGroupNumber);\n            }\n            // 入力値のグループ番号の時、着席時間と待ち時間を設定\n            if (inputNumber == firstWaitGroupNumber) {\n                // 待ち時間を設定\n                waitTime = currentTime - arrivalTimeList.get(firstWaitGroupNumber);\n            }\n            // 着席時間を設定\n            sitTime.add(currentTime);\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号<br>\n     * 座れる席がない場合は-1を返す。\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n        int emptyCount = 0;\n        for (int startPoint = 0; startPoint < serviceCounterList.size(); startPoint++) {\n            if (serviceCounterList.get(startPoint) == -1) {\n                emptyCount = 1;\n                for (int endpoint = startPoint + 1; endpoint < serviceCounterList.size(); endpoint++) {\n                    // 空席ならカウント\n                    if (serviceCounterList.get(endpoint) == -1) {\n                        emptyCount++;\n                        // 連続空席がグループの人数以上か判定\n                        if (emptyCount >= groupNumberOfPeopleList.get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                    } else {\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n    /*\n     * private static void printCustomer() {\n     * System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\"); System.out.print(\"\");\n     * System.out.println(\"\"); for (int i = 0; i < arrivalTimeList.size(); i++)\n     * { System.out.print(i + \"\\t\\t\"); System.out.print(arrivalTimeList.get(i) +\n     * \"\\t\\t\"); System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n     * System.out.println(eatTimeList.get(i)); } }\n     * \n     * private static void printQuere() { System.out.print(\"キュー＝\"); for\n     * (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n     * System.out.print(it.next()); } System.out.println(\"\\n\"); }\n     * \n     * private static void printCounter() { System.out.print(currentTime +\n     * \"：[\"); for (int a : serviceCounterList) { System.out.print(a + \", \"); }\n     * System.out.println(\"]\"); }\n     */\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\n\tpublic static void main(String[]agrs){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] list = new int[100];\n\t\tint[] at = new int[17];\n\t\tint[] s = new int[17];\n\t\tint count = 0;\n\t\tQueue<Data> que = new ArrayDeque<Data>();\n\t\tfor(int i = 0; i < 1000; i++) {\n\t\t\tfor(int j = 0; j < 17; j++) {\n\t\t\t\tat[j]--;\n\t\t\t\tif(at[j] == 0) {\n\t\t\t\t\ts[j] = -1;\n\t\t\t\t}\n\t\t\t\tif(at[j] == -1) {\n\t\t\t\t\tat[j] = 0;\n\t\t\t\t\ts[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 5 == 0 && i < 500) {\n\t\t\t\tif(count % 5 == 1) {\n\t\t\t\t\tque.add(new Data(count,5));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tque.add(new Data(count, 2));\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tINX:while(!que.isEmpty()) {\n\t\t\t\tData tmp = que.peek();\n\t\t\t\tIN:for(int j = 0; j < 17; j++) {\n\t\t\t\t\tfor(int k = 0; k < tmp.val; k++) {\n\t\t\t\t\t\tif(j + k >= 17) break INX;\n\t\t\t\t\t\tif(s[j + k] != -1) continue IN;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < tmp.val; k++) {\n\t\t\t\t\t\ts[j + k] = tmp.num;\n\t\t\t\t\t\tat[j + k] = 17 * (tmp.num % 2) + 3 * (tmp.num % 3) + 19;\n\t\t\t\t\t}\n\t\t\t\t\tque.poll();\n\t\t\t\t\tcontinue INX;\n\t\t\t\t}\n\t\t\t\tbreak INX;\n\t\t\t}\n\t\t\tArrayDeque<Data> tmp = new ArrayDeque<Data>();\n\t\t\twhile(!que.isEmpty()) {\n\t\t\t\tlist[que.peek().num]++;\n\t\t\t\ttmp.add(que.poll());\n\t\t\t}\n\t\t\twhile(!tmp.isEmpty()) {\n\t\t\t\tque.add(tmp.poll());\n\t\t\t}\n\t\t\t\n\t\t}\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(list[n]);\n\t\t}\n\t}\n\tstatic class Data {\n\t\tint num;\n\t\tint val;\n\t\tData(int a, int b) {\n\t\t\tnum = a;\n\t\t\tval = b;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)] + waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int count = 1; count <= customersNum[Integer\n                .parseInt(groupsNum)]; count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[finalSeatNum--] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)] - waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tList<Integer> output = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\t\t\t// ??????\n\t\t\tint time = 0;\n\t\t\t// ?????????\n\t\t\tboolean result = true;\n\t\t\t// ???\n\t\t\tint[] seat = new int[17];\n\t\t\t// ????????????\n\t\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\t\t\t// ?????????????????????\n\n\t\t\t// ?????????\n\t\t\twhile (result) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\twhile (waitGuest.size() > 0)  {\n\t\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\t\toutput.add(time - (waitGuest.get(0) * 5));\n\t\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t\toutputWaitTime(output);\n\t}\n\n\tprivate static void outputWaitTime(List<Integer> output){\n\t\tfor (int outputNum : output) {\n\t\t\tSystem.out.println(outputNum);\n\t\t}\n\t}\n\n\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tList<Integer> output = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\t\t\t// ??????\n\t\t\tint time = 0;\n\t\t\t// ?????????????????°\n\t\t\tboolean result = true;\n\t\t\t// ???\n\t\t\tint[] seat = new int[17];\n\t\t\t// ????????????\n\t\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\t\t\t// ?????????????????????\n\n\t\t\t// ?????????\n\t\t\twhile (result) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\twhile (waitGuest.size() > 0)  {\n\t\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\t\toutput.add(time - (waitGuest.get(0) * 5));\n\t\t\t\t\t\t\t\tresult = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t\tfor (int outputNum : output) {\n\t\t\tSystem.out.println(outputNum);\n\t\t}\n\t}\n\n\n\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\t\t// ?????????????????????\n\t\tList<Integer> output = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ??????\n\t\t\tint time = 0;\n\n\t\t\t// ?????????\n\t\t\twhile (true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\toutput.add(time - waitGuest.get(0) * 5);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\n\t\tfor (int outputNum : output) {\n\t\t\tSystem.out.println(outputNum);\n\t\t}\n\t}\n\n\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** １グループの人数 */\n    public static final int[] numInGroupList = {2, 5, 2, 2, 2};\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime;\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        waitingTime = new int[GROUP_NUM];\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        calcWaitTime(maxGroupNum);\n        \n        for (Integer i : inputList) {\n            System.out.println(waitingTime[i]);\n        }\n\n    }\n    \n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客の到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = numInGroupList[headGroupNo % numInGroupList.length];\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //\n                    if (headGroupNo == maxGroupNum) return;\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        headGroupNo++;\n                    } else {\n                        headGroupNo = -1;\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    private static void printCustomer() {\n        System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\");\n        System.out.print(\"\");\n        System.out.println(\"\");\n        for (int i = 0; i < arrivalTimeList.size(); i++) {\n            System.out.print(i + \"\\t\\t\");\n            System.out.print(arrivalTimeList.get(i) + \"\\t\\t\");\n            System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n            System.out.println(eatTimeList.get(i));\n        }\n    }\n\n    private static void printQuere() {\n        System.out.print(\"キュー＝\");\n        for (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n            System.out.print(it.next());\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void printCounter() {\n        System.out.print(currentTime + \"：[\");\n        for (int a : serviceCouters) {\n            System.out.print(a + \", \");\n        }\n        System.out.println(\"]\");\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\tString a = \"5\\r\\n6\\r\\n7\\r\\n8\";\n\t\tInputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n\t\t// 意味的にはSystem.in = bais;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].eatTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// テスト出力\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        try {\n            // 対象のグループ番号：待ち時間の形で保持\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetCustomer = new LinkedHashMap<Integer, Integer>();\n            List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n            while (sc.hasNext()) {\n                targetCustomerGroupNumbers.add(sc.nextInt());\n            }\n\n            // 椅子 客が出るまでの分数を保持する\n            int[] chairs = new int[17];\n            // 待ち行列 客グループ数を保持する\n            Deque<Integer> que = new LinkedList<Integer>();\n            // これまでに来た最大のグループ番号\n            int cameGroup = 0;\n            // これまでに座ったグループの「数」\n            int sitGroupCount = 0;\n            // 経過時間\n            int pastMinutes = 0;\n\n            while (sitGroupCount < 100) {\n                // 食べる\n                eat(chairs);\n\n                // 客が来る\n                boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n                // 座る\n                sitGroupCount += sit(chairs, que, sitGroupCount);\n\n                // 後処理\n                for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                    if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                        // まだ座れていない\n                        continue;\n                    }\n\n                    if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                        // もうすでに座っていた\n                        continue;\n                    } else {\n                        // この時間で初めて座れた\n                        int waitMinutes = pastMinutes\n                                - (5 * targetCustomerGroupNumber);\n                        targetCustomer.put(targetCustomerGroupNumber,\n                                waitMinutes);\n                    }\n                }\n\n                if (customerHasCome) {\n                    cameGroup++;\n                }\n                pastMinutes++;\n            }\n\n            for (Entry<Integer, Integer> entry : targetCustomer.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int sitGroupNumber) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (sitGroupNumber % 2))\n                    + (3 * (sitGroupNumber % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, (sitGroupNumber + 1));\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(seat, -1);\n        Arrays.fill(waitingTime, -1);\n        Arrays.fill(eatEndTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n    \n    /**\n     * グループの人数を計算する\n     */\n    private static int getNumInGroup(int groupNo) {\n        return groupNo % 5 == 1 ? 5 : 2;\n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    int numOfSittingGroup = getNumInGroup(seat[s]);\n                    Arrays.fill(seat, s, s + numOfSittingGroup, -1);\n                    Arrays.fill(eatEndTime, s, s + numOfSittingGroup, -1);\n                    \n                    //グループの人数分飛ばす\n                    s += numOfSittingGroup - 1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = getNumInGroup(headGroupNo);\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    int sittingGroupNum = seat[s];\n                    if (sittingGroupNum == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                        //グループの人数分飛ばす\n                        s += getNumInGroup(sittingGroupNum) - 1;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, min + timeToEatList[headGroupNo % timeToEatList.length]);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\t// String a = \"5\\r\\n6\\r\\n7\\r\\n11\";\n\t\t// InputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n\t\t// // 意味的にはSystem.in = bais;\n\t\t//\n\t\t// BufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\n\t\t BufferedReader br = new BufferedReader(new\n\t\t InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].pastTime += group[n].pastTime\n\t\t\t\t\t\t\t\t\t\t\t- group[n].eatTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// テスト出力\n\t\t\t// for (String abc : seat) {\n\t\t\t// System.out.print(abc);\n\t\t\t// }\n\t\t\t// System.out.println();\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// てすと出力\n//\t\tfor (int p = 0; p < group.length; p++) {\n//\t\t\tSystem.out.println(\"グループ番号：\" + p + \"　人数\" + group[p].peopleCnt\n//\t\t\t\t\t+ \"　食事時間\" + group[p].eatTime);\n//\n//\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tvoid run(){\n\t\tLinkedList<Integer> que=new LinkedList<Integer>();\n\t\tint[] wait=new int[100];\n\t\tint[] a=new int[17];\n\t\tint[] b=new int[17];\n\t\tint[] rest=new int[17];\n\n\t\tfor(int t=0;; t++){\n\t\t\t// ツ食ツ篠鳴終ツ猟ケツづーツ渉慊外\n\t\t\tfor(int i=0; i<17; i++){\n\t\t\t\tif(--rest[i]<=0){\n\t\t\t\t\ta[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ツ新ツつオツつ「ツ客\n\t\t\tif(t%5==0&&t<500){\n\t\t\t\tque.addLast(t/5);\n\t\t\t}\n\n\t\t\t// ツづつづ淞づァツづェツづゥツつセツつッツづつづ淞づゥ\n\t\t\tfor(; !que.isEmpty();){\n\t\t\t\tint c=que.getFirst();\n\t\t\t\tint n=c%5==1?5:2;\n\t\t\t\tfor(int i=16; i>=0; i--){\n\t\t\t\t\tif(a[i]==-1){\n\t\t\t\t\t\tb[i]=(i==16?0:b[i+1])+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tb[i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint j=-1;\n\t\t\t\tfor(int i=0; i<17; i++){\n\t\t\t\t\tif(b[i]>=n){\n\t\t\t\t\t\tj=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j==-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=j; i<j+n; i++){\n\t\t\t\t\ta[i]=c;\n\t\t\t\t\trest[i]=17*(c%2)+3*(c%3)+19;\n\t\t\t\t}\n\t\t\t\twait[c]=t-5*c;\n\t\t\t\tque.removeFirst();\n\t\t\t}\n\t\t\t// debug(t, a);\n\t\t\t// debug(que.toArray());\n\n\t\t\tif(t>500&&que.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(; sc.hasNext();){\n\t\t\tprintln(\"\"+wait[sc.nextInt()]);\n\t\t}\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\tfor (int countTimeGoesBy = 0; countTimeGoesBy < 3000; countTimeGoesBy++) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\tint countDelete = 0;\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\t\tcountDelete++;\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int countt = 0; countt < countDelete; countt++) {\n\t\t\t\twaitingCustomersList.remove(0);\n\t\t\t\twaitingStartTimeList.remove(0);\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(waitingTime);\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[SEATNUM];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n        List<int[]> endGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 最大入力値よりも大きくなったら処理を終了する。\n            int endCount = 0;\n            for (int[] endGroupDetails : endGroupInfo) {\n                for (int inputNumber : inputlist) {\n                    if (inputNumber == endGroupDetails[0]) {\n                        endCount = endCount + 1;\n                        break;\n                    }\n                }\n            }\n            if (endCount == inputlist.size()) {\n                break;\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                    endGroupInfo.add(eatenGroup);\n                    sittingGroupInfo.remove(eatenGroup);\n                    n--;\n                }\n            }\n\n            // 客が入店するかチェック\n            if (minutes % 5 == 0 || minutes / 5 >= 100) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 並んでいるグループの先頭が座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                // 席が空いているどうか判定する。\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // グループの人数分席が空いている場合には、\n                    // 座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間・退店時刻を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int outTime = minutes + comingGroup[2];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, outTime};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 先頭客の情報を削除する。\n                        groupInfo.remove(0);\n                        // 先頭の人が入れたら次の人が入れる。\n\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                if (!firstCustomer) {\n                    // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                    break;\n                }\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int input : inputlist) {\n            for (int[] outputInfo : endGroupInfo) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package aoj;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    /** ??§?????° */\n    private final static int SEATS = 17;\n\n    /** ??¢??°???????????° */\n    private static int GROUP = 0;\n\n    /** ??¢??°??????????????°???????????????????????? */\n    private final static int INTERVAL = 5;\n\n    /** ??¢??°???????????????????????????????´????????????? */\n    private static int[] watingTimes = new int[GROUP];\n\n    /** ??¢??°??????????????°?????????????????°????£?????????????????´???????????¬?????????? */\n    private static int[][] groupInfo = new int[GROUP][3];\n\n    /** ??¢??°??????????????°??????????????¨???????????? */\n    private final static int GROUP_INFO_ARRIVAL = 0;\n\n    /** ??¢??°?????????????????°?????¨???????????? */\n    private final static int GROUP_INFO_PERSONS = 1;\n\n    /** ??¢??°?????????????£???????????????¨???????????? */\n    private final static int GROUP_INFO_EATING_MINUTES = 2;\n\n    /** ??§??????????????¶??????????´????????????? */\n    private static int[] seatsCondition = new int[SEATS];\n\n    /** ???????????????????????????????????? */\n    private static boolean openFlag = true;\n\n    /** ???????????°???????????°????????? */\n    private static int lastArrivalGroup = -1;\n\n    /** ????????°???????????° */\n    private static int watingGroups = 0;\n\n    /** ??£????????????????????????????????? */\n    private static int passedMinutes = 0;\n\n    /**\n     * ???????????????????¨?????????¢??°??????????????????????????????????????????\n     *\n     * @param args\n     *            ?????¨????????????\n     * @throws IOException\n     * @throws NumberFormatException\n     */\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n\n        // ??\\?????????????????????\n        List<Integer> inputList = getInput();\n\n        // ??¨??¢??°??????????????°???????????¨?????°??¨?£??????????????±???????\n        setGroupInfo();\n\n        while (openFlag) {\n\n            // ???????????§?¬??????°??????????????°?????????\n            if (passedMinutes % INTERVAL == 0) {\n                lastArrivalGroup++;\n                watingGroups++;\n            }\n\n            // ????????°??????????????????????????°?????????????????????????????????\n            if (watingGroups == 0) {\n                passedMinutes++;\n                continue;\n            }\n\n            // ????????°?????????????????¨????????´???\n            // ?????????????????°???????????????????±???????\n            int nextGroup = lastArrivalGroup - watingGroups + 1;\n\n            // ????????°???????????????????????????????????¨????????´????????????????????????????????????????????§????????????\n            boolean vacancyFlag = true; // ??????????????¨????????????????????°\n            while (watingGroups != 0 && vacancyFlag) {\n\n                // ?????????????????°?????????????????°????±???????\n                int numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS];\n\n                // ??????????????¨?????£???????????????????????????????????°????????????????????§????????§????????????????±???????\n                int seatNumber = getSeatNumber(numberOfPersons);\n\n                if (seatNumber != -1) {\n\n                    // ????????§????????§???????????£?????´????????§????????°????????????????????????????¨??????????\n                    for (int i = 0; i < numberOfPersons; i++) {\n                        seatsCondition[seatNumber] = passedMinutes\n                                + groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n                        seatNumber++;\n                    }\n\n                    // ??°????????????????????????????¨??????????\n                    watingTimes[nextGroup] = passedMinutes\n                            - groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n                    // ????????°???????????°????????????\n                    watingGroups--;\n                    nextGroup = lastArrivalGroup - watingGroups + 1;\n\n                    // ???????????°??????????????§??£??????????????????????????????\n                    if (nextGroup == GROUP) {\n                        openFlag = false;\n                        vacancyFlag = false;\n                    }\n                } else {\n                    vacancyFlag = false;\n                }\n            }\n\n            passedMinutes++;\n        }\n\n        // ?????????????????????\n        for (int i : inputList) {\n            System.out.println(watingTimes[i]);\n        }\n    }\n\n    /**\n     * ??\\?????????n???????????°???????????????????????????\n     *\n     * @return ??\\??????????????????\n     * @throws NumberFormatException\n     * @throws IOException\n     */\n    private static List<Integer> getInput() throws NumberFormatException,\n            IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        String line = null;\n        while ((line = br.readLine()) != null) {\n            int groupNo = Integer.parseInt(line);\n            inputList.add(Integer.parseInt(line));\n\n            if(GROUP < groupNo){\n                GROUP = groupNo;\n            }\n\n        }\n\n        return inputList;\n    }\n\n    /**\n     * ??¢??°??????????????°?????????????????°????£??????????????¨??????????????????????????????????\n     */\n    private static void setGroupInfo() {\n\n        for (int i = 0; i < GROUP; i++) {\n            groupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n            groupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n            groupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n                    * (i % 3) + 19;\n        }\n\n    }\n\n    /**\n     * ??????????????¨?????£???????????????????????????\n     * ?????°??§???????????£????????°?????§??????????????¢????????§?????????????????????\n     * ??§??????????????´??????-1????????????\n     *\n     * @param numberOfPersons ?????°\n     * @return ??§?????????\n     */\n    private static int getSeatNumber(int numberOfPersons) {\n\n        int seatNumber = 0; // ???????????§?????????\n        int vacancySeats = 0; // ????????°\n\n        for (int i = 0; i < SEATS; i++) {\n\n            // ??????????????¨?????£?????§?????????????????????\n            if (seatsCondition[i] <= passedMinutes) {\n                seatsCondition[i] = 0;\n            }\n\n            if (seatsCondition[i] == 0) {\n\n                // ??????????????§????????°???????????°????¢???????\n                vacancySeats++;\n\n                // ????????°??????????????°??¨??????????????°??????????????§??????????????????\n                if (vacancySeats == numberOfPersons) {\n                    return seatNumber;\n                }\n            } else {\n\n                // ??????????????§???????????°?????§?????????????¬?????§???????????????°???0?????????\n                seatNumber = i + 1;\n                vacancySeats = 0;\n            }\n        }\n\n        // ????????????????????°-1?????????\n        return -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint order;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((order = arrivedCustomer(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(order)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(order));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(order);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[wait] = currentTime - arriveTime[wait];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentTime - (arriveTime[Integer.parseInt(seat)]\n\t\t\t\t\t+ waitTimes[Integer.parseInt(seat)]) >= mealTimes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\tfor (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\t// 空席の最初の座席番号を設定する\n\t\t\t\tfirstSeatNum = i - emptyseatsNum;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif (seats[i] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate static final int MAX_GROUP_COUNT = 100;\n\tprivate int time = 0;\n\tprivate int groupCount = 0;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().execute();\n\t}\n\n\tprivate void execute() throws Exception {\n\n\t\t// 標準入力を１行ずつ処理\n\t\tList<Integer> targetGroups = readInitialData();\n\n\t\tEatingPerson[] seats = new EatingPerson[17];\n\t\tList<WaitingPerson> waitingGroups = new ArrayList<WaitingPerson>();\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\t\t\n\t\t// 待ち時間を調べる必要がある最後のグループを取得\n\t\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t\twhile (groupCount < maxGroupNum) {\n\n\t\t\t// 行列の更新\n\t\t\tupdateWaitLine(waitingGroups);\n\n\t\t\t// 離席する\n\t\t\tleaveSeat(seats);\n\n\t\t\t// 着席する\n\t\t\tsitDown(seats, waitingGroups, waitTimes);\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tSystem.out.println(waitTimes.get(targetGroup));\n\t\t}\n\t}\n\n\tprivate int searchMaxGroupNum(List<Integer> targetGroups) {\n\t\t// 最大番号のグループ\n\t\tint maxGroupNum = 0;\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tif (maxGroupNum < targetGroup) {\n\t\t\t\tmaxGroupNum = targetGroup;\n\t\t\t}\n\t\t}\n\t\treturn maxGroupNum;\n\t}\n\n\tprivate void sitDown(EatingPerson[] seats,\n\t\t\tList<WaitingPerson> waitingGroups, List<Integer> waitTimes) {\n\n\t\tint removeCount = 0;\n\t\tfor (WaitingPerson waitingPerson : waitingGroups) {\n\n\t\t\tint emptySeatCount = 0;\n\t\t\tboolean isEmpty = false;\n\t\t\tfor (int i = 0; i < seats.length; i++) {\n\n\t\t\t\t// 空席数を検知\n\t\t\t\tif (seats[i] == null) {\n\t\t\t\t\temptySeatCount++;\n\t\t\t\t} else {\n\t\t\t\t\temptySeatCount = 0;\n\t\t\t\t}\n\n\t\t\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t\t\t\t// 席に座ったグループ数を更新\n\t\t\t\t\tgroupCount++;\n\t\t\t\t\tremoveCount++;\n\t\t\t\t\tisEmpty = true;\n\n\t\t\t\t\t// 所属グループの待ち時間を記録\n\t\t\t\t\twaitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t\t\t\t// 食べ終わる時間を計算\n\t\t\t\t\tint endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n\t\t\t\t\t\t\t* (waitingPerson.getGroup() % 3) + 19;\n\n\t\t\t\t\tfor (int j = 0; j < emptySeatCount; j++) {\n\t\t\t\t\t\tseats[i - j] = new EatingPerson(\n\t\t\t\t\t\t\t\twaitingPerson.getGroup(), endTime + time);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < removeCount; i++) {\n\t\t\twaitingGroups.remove(0);\n\t\t}\n\t}\n\n\tprivate void leaveSeat(EatingPerson[] seats) {\n\t\tfor (int i = 0; i < seats.length; i++) {\n\t\t\tif (seats[i] != null && seats[i].getEndTime() == time) {\n\t\t\t\tseats[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateWaitLine(List<WaitingPerson> waitingGroups) {\n\t\tint nowGroup = time / 5;\n\n\t\t// グループがやってきたか判定\n\t\tif (time % 5 == 0) {\n\t\t\t// グループの人数を算出\n\t\t\tint number = 2;\n\t\t\tif (nowGroup % 5 == 1) {\n\t\t\t\tnumber = 5;\n\t\t\t}\n\n\t\t\t// 行列の後ろに追加\n\t\t\t// 待ち始めた時間を記録\n\t\t\twaitingGroups.add(new WaitingPerson(nowGroup, number, time));\n\t\t}\n\t}\n\n\tprivate List<Integer> readInitialData() throws IOException {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tString line = null;\n\t\tList<Integer> groups = new ArrayList<Integer>();\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tgroups.add(Integer.parseInt(line));\n\t\t}\n\n\t\treturn groups;\n\t}\n\n}\n\nabstract class Person {\n\n\t// 所属グループ\n\tprivate int group;\n\n\tpublic int getGroup() {\n\t\treturn group;\n\t}\n\n\tpublic void setGroup(int group) {\n\t\tthis.group = group;\n\t}\n\n}\n\nclass WaitingPerson extends Person {\n\n\tpublic WaitingPerson(int group, int number, int startTime) {\n\t\tsetGroup(group);\n\t\tsetNumber(number);\n\t\tsetStartTime(startTime);\n\t}\n\n\t// 待ち始めた時刻\n\tprivate int startTime;\n\n\t// グループの人数\n\tprivate int number;\n\n\tpublic int getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(int startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic int getNumber() {\n\t\treturn number;\n\t}\n\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n}\n\nclass EatingPerson extends Person {\n\n\tpublic EatingPerson(int group, int endTime) {\n\t\tsetGroup(group);\n\t\tsetEndtTime(endTime);\n\t}\n\n\t// 食べ終わる時間\n\tprivate int endtTime;\n\n\tpublic int getEndTime() {\n\t\treturn endtTime;\n\t}\n\n\tpublic void setEndtTime(int endtTime) {\n\t\tthis.endtTime = endtTime;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)] + waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n    // ?¨???¢??°?????§???\n    static final int MAX_NUMBER_OF_VISITOR = 100;\n\n    // ??§?????°\n    static final int NUMBER_OF_SEAT = 17;\n\n    // ??°???????????°??\\??????\n    static final int INTERVAL = 5;\n\n    // ??????????????????\n    static int[] waitingTime = new int[MAX_NUMBER_OF_VISITOR];\n\n    // ???????????§????????¶???\n    static int[] shopSeatTimer = new int[NUMBER_OF_SEAT];\n\n    public static void main(String[] args) {\n\n\t// ?¨??????\\???\n\tScanner sc = new Scanner(System.in);\n\n\tList<Integer> orders = new ArrayList<>();\n\n\twhile (sc.hasNextLine()) {\n\t    String nextLine = sc.nextLine();\n\t    orders.add(Integer.parseInt(nextLine));\n\t}\n\n\t// ??\\???????????????????????§????????????\n\tint maxOrder = returnMax(orders);\n\n\t// ????????????????????????\n\tArrays.fill(waitingTime, -1);\n\n\t// ?????\\?????¬????????§?????????\n\texecuteSimulation(maxOrder);\n\n\t// ??????????????°?????????????????????????????????\n\tfor (Integer order : orders) {\n\t    System.out.println(waitingTime[order]);\n\t}\n\n\tsc.close();\n\n    }\n\n    private static void executeSimulation(int maxOrder) {\n\t// ????????????\n\tList<Integer> waintinGroup = new ArrayList<>();\n\n\t// ???????????§???????????????(?????????-1??¨??????)\n\tArrays.fill(shopSeatTimer, -1);\n\n\t// ????????????????????????????§?\n\n\tfor (int now = 0;; now++) {\n\n\t    // ?£?????????????????????????????????????????????????????£????????????????-1\n\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\n\t\t// ????????????????????????????????????????????????\n\t\tif (shopSeatTimer[i] != -1) {\n\t\t    shopSeatTimer[i]--;\n\t\t    // ???????????????0???????????????\n\t\t    if (shopSeatTimer[i] == 0) {\n\t\t\tshopSeatTimer[i] = -1;\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now % INTERVAL == 0) {\n\t\twaintinGroup.add(now / INTERVAL);\n\t    }\n\n\t    // ????????????????????§???\n\t    while (true) {\n\t\tif (waintinGroup.isEmpty()) {\n\t\t    break;\n\t\t}\n\n\t\tint group = waintinGroup.get(0);\n\t\tint openSeatHead = canISitDown(group);\n\n\t\t// ???????????????????????°\n\t\tif (openSeatHead != -1) {\n\t\t    // ????????????????????????????´?\n\t\t    waitingTime[group] = now - group * INTERVAL;\n\n\t\t    // ?£?????????????????´?\n\t\t    for (int i = 0; i < howManymembers(group); i++) {\n\t\t\tshopSeatTimer[openSeatHead + i] = howLongToEat(group);\n\t\t    }\n\t\t    // ??????????????????\n\t\t    waintinGroup.remove(0);\n\n\t\t    // ?±??????????????????§??????????????°?????????????????????????????????\n\t\t    if (group == maxOrder) {\n\t\t\treturn;\n\t\t    }\n\n\t\t} else {\n\t\t    break;\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n    // ????????????????????§????????????\n    private static int returnMax(List<Integer> orders) {\n\tint maxOrder = 0;\n\tfor (Integer order : orders) {\n\t    maxOrder = Math.max(order, maxOrder);\n\t}\n\treturn maxOrder;\n\n    }\n\n    // ??§?????????????????????\n    private static int canISitDown(int group) {\n\tint count = 0;\n\tfor (int i = 0; i < NUMBER_OF_SEAT - howManymembers(group) + 1; i++) {\n\t    for (int j = 0; j < howManymembers(group); j++) {\n\t\tif (shopSeatTimer[i + j] == -1) {\n\t\t    count++;\n\t\t} else {\n\t\t    count = 0;\n\t\t    break;\n\t\t}\n\n\t\tif (count == howManymembers(group)) {\n\t\t    return i;\n\t\t}\n\t    }\n\t}\n\treturn -1;\n    }\n\n    // ????????°?????????????????????\n    private static int howManymembers(int group) {\n\treturn group % 5 == 1 ? 5 : 2;\n    }\n\n    // ?£???????????????????\n    private static int howLongToEat(int group) {\n\treturn 17 * (group % 2) + 3 * (group % 3) + 19;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main2 {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ????????????????????°???????????????\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ????????????????????°???????????????\n\t\t\t// ??????\n\t\t\tint time = 0;\n\n\t\t\t// ?????????\n\t\t\twhile (true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\tSystem.out.println(time - waitGuest.get(0) * 5);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twaitGuest.remove(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++time;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????????????????????????????????????\n\n\t//\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext()){\n\t\t\tint temp=sc.nextInt();\n\t\t\tMAX=max(MAX,temp);\n\t\t\tqueue.add(temp);\n\t\t}\n\t\t++MAX;\n\t\tint[] num=new int[MAX],time=new int[MAX],seat=new int[17];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\ttime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"TIME\"+i+\" \"+time[i]);\n\t\t//for(int i=0; i<MAX; i++)\tout.println(\"NUM\"+i+\" \"+num[i]);\n\t\tint j=0,min=0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tseat=exit(seat,min,time);\n\t\t\tint temp=find(seat,num[j]);\n\t\t\tif(temp>=0 && min>=j*5){\n\t\t\t\tint q=queue.getFirst();\n\t\t\t\tif(j==q){\n\t\t\t\t\tout.println(max(0,min-j*5));\n\t\t\t\t\tqueue.removeFirst();\n\t\t\t\t}\n\t\t\t\tfor(int i=temp; i<temp+num[j]; i++)\tseat[i]=j;\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\tmin++;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//disp(seat,min-1);\n\t\t}\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] time){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint idx=seat[i],emin=idx*5+time[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(--now.ttl==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                        groupOrder++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        groupOrder++;\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n\n            for (String seat : seats) {\n                System.out.print(seat + \",\");\n            }\n            System.out.println();\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)] - waitTimes[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n\n        // 対象のグループ番号：待ち時間の形で保持\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> targetCustomer = new LinkedHashMap<Integer, Integer>();\n        List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n        while (sc.hasNext()) {\n            targetCustomerGroupNumbers.add(sc.nextInt());\n        }\n\n        // 椅子 客が出るまでの分数を保持する\n        int[] chairs = new int[17];\n        // 待ち行列 客グループ数を保持する\n        Deque<Integer> que = new LinkedList<Integer>();\n        // これまでに来た最大のグループ番号\n        int cameGroup = 0;\n        // これまでに座ったグループの「数」\n        int sitGroupCount = 0;\n        // 経過時間\n        int pastMinutes = 0;\n\n        while (sitGroupCount < 100) {\n            // 食べる\n            eat(chairs);\n\n            // 客が来る\n            boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n            // 座る\n            sitGroupCount += sit(chairs, que, sitGroupCount);\n\n            // 後処理\n            for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                    // まだ座れていない\n                    continue;\n                }\n\n                if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                    // もうすでに座っていた\n                    continue;\n                } else {\n                    // この時間で初めて座れた\n                    int waitMinutes = pastMinutes\n                            - (5 * targetCustomerGroupNumber);\n                    targetCustomer.put(targetCustomerGroupNumber, waitMinutes);\n                }\n            }\n\n            if (customerHasCome) {\n                cameGroup++;\n            }\n            pastMinutes++;\n        }\n\n        for (Entry<Integer, Integer> entry : targetCustomer.entrySet()) {\n            System.out.println(entry.getValue());\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int sitGroupNumber) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (sitGroupNumber % 2))\n                    + (3 * (sitGroupNumber % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, (sitGroupNumber + 1));\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] c = new int[17];\n\t\tint[] p = new int[100];\n\t\tint[] w = new int[100];\n\t\tint[] sit = new int[100];\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tp[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tw[i] = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\t\tint i = 0;\n\t\tint t = 0;\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tDeque<Integer> m = new ArrayDeque<Integer>();\n\t\tint a = -1;\n\t\tloop1: while (true) {\n\t\t\tif (t == i * 5 && i < 100) {\n\t\t\t\tdeque.offer(i++);\n\t\t\t\tm.offer(t);\n\t\t\t}\n\t\t\tfor (int k = 0; k < 17; k++) {\n\t\t\t\tc[k] = Math.max(0, c[k] - 1);\n\t\t\t}\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint de = deque.peekFirst();\n\t\t\t\ta = getA(p[de], c);\n\t\t\t\tif (a == -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint id = deque.poll();\n\t\t\t\tfor (int j = a; j < a + p[id]; j++) {\n\t\t\t\t\tc[j] = w[id];\n\t\t\t\t}\n\t\t\t\tsit[id] = t - m.pollFirst();\n\t\t\t\tif (id == 99) {\n\t\t\t\t\tbreak loop1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\twhile (scanner.hasNext()) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tSystem.out.println(sit[n]);\n\t\t}\n\t}\n\n\tprivate static int getA(int d, int[] c) {\n\t\tint count = 0;\n\t\tint a = -1;\n\t\tfor (int i = 0; i < 17; i++) {\n\t\t\tif (c[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tif (d == count) {\n\t\t\t\t\treturn i - count + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** １グループの人数 */\n    public static final int[] numInGroupList = {2, 5, 2, 2, 2};\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime;\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        waitingTime = new int[GROUP_NUM];\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        calcWaitTime(maxGroupNum);\n        \n        for (Integer i : inputList) {\n            System.out.println(waitingTime[i]);\n        }\n\n    }\n    \n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n            System.err.println(\"min : \" + min);\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    System.err.println(\"Group \" + seat[s] + \" end\");\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            printSeat();\n            \n            //客の到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                printSeat();\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = numInGroupList[headGroupNo % numInGroupList.length];\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n                System.err.println(\"s : \" + s);\n                System.err.println(\"headGroupNo : \" + headGroupNo);\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        System.err.println(ts);\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                    \n                    printSeat();\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //\n                    if (headGroupNo == maxGroupNum) return;\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        headGroupNo++;\n                    } else {\n                        headGroupNo = -1;\n                    }\n                    \n                    System.err.println(\"headGroupNo : \" + headGroupNo);\n                } else {\n                    System.err.println(\"着席できない\");\n                    printSeat();\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static void printSeat() {\n        System.err.print(\"seat       : \");\n        for (int i = 0; i < seat.length; i++) {\n            if(seat[i] == -1)System.err.print(\"_\");\n            else System.err.print(seat[i]);\n        }\n        System.err.println();\n        \n        System.err.print(\"eatEndTime : \");\n        for (int i = 0; i < eatEndTime.length; i++) {\n            System.err.print(eatEndTime[i] + \", \");\n        }\n        System.err.println();\n    }\n    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n//\t\tString a = \"5\\r\\n6\\r\\n7\\r\\n8\";\n//\t\tInputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n//\t\t// 意味的にはSystem.in = bais;\n//\n//\t\tBufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].pastTime += group[n].pastTime\n\t\t\t\t\t\t\t\t\t\t\t- group[n].eatTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n//\t\t\t// テスト出力\n//\t\t\tfor (String abc : seat) {\n//\t\t\t\tSystem.out.print(abc);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// てすと出力\n//\t\tfor (int p = 0; p < group.length; p++) {\n//\t\t\tSystem.out.println(\"グループ番号：\" + p + \"　人数\" + group[p].peopleCnt\n//\t\t\t\t\t+ \"　食事時間\" + group[p].eatTime);\n//\n//\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "<?php\n\n$waitTime = array(0,\n0,\n0,\n0,\n0,\n0,\n14,\n9,\n4,\n0,\n0,\n8,\n3,\n2,\n0,\n0,\n15,\n10,\n15,\n10,\n6,\n12,\n7,\n9,\n11,\n6,\n23,\n18,\n13,\n8,\n3,\n23,\n18,\n13,\n8,\n3,\n34,\n29,\n24,\n22,\n17,\n28,\n23,\n24,\n19,\n27,\n34,\n29,\n35,\n30,\n28,\n31,\n28,\n23,\n24,\n28,\n42,\n37,\n32,\n27,\n22,\n42,\n37,\n32,\n27,\n22,\n53,\n48,\n43,\n41,\n36,\n47,\n42,\n43,\n38,\n46,\n64,\n59,\n54,\n49,\n44,\n61,\n56,\n51,\n46,\n44,\n72,\n67,\n62,\n57,\n52,\n72,\n67,\n62,\n57,\n52,\n83,\n78,\n73,\n71);\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}\nreturn(0);\n?>"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[SEATNUM];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n        List<int[]> endGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 最大入力値よりも大きくなったら処理を終了する。\n            int endCount = 0;\n            for (int[] endGroupDetails : endGroupInfo) {\n                for (int inputNumber : inputlist) {\n                    if (inputNumber == endGroupDetails[0]) {\n                        endCount = endCount + 1;\n                        break;\n                    }\n                }\n            }\n            if (endCount == inputlist.size()) {\n                break;\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                    endGroupInfo.add(eatenGroup);\n                    sittingGroupInfo.remove(eatenGroup);\n                    n--;\n                }\n            }\n\n            // 客が入店するかチェック\n            if (minutes % 5 == 0 || minutes / 5 >= 100) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 並んでいるグループの先頭が座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                // 席が空いているどうか判定する。\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // グループの人数分席が空いている場合には、\n                    // 座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間・退店時刻を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int outTime = minutes + comingGroup[2];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, outTime};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 先頭客の情報を削除する。\n                        groupInfo.remove(0);\n                        // 先頭の人が入れたら次の人が入れる。\n\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                if (!firstCustomer) {\n                    // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                    break;\n                }\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int input : inputlist) {\n            for (int[] outputInfo : endGroupInfo) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\t/** ??°???????????° */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** ??§????????? */\n\tstatic int[] sheets = new int[17];\n\n\t/** ?????????????????? */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** ???????????? */\n\tstatic Map<Integer, Integer> waitLine = new LinkedHashMap<Integer, Integer>();\n\n\t/** ??????????±? */\n\tstatic Set<Integer> deleteTarget = new HashSet<Integer>();\n\n\t/** ??????????????? */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** ?????§??°??????????????? */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// ?????¨?????°???????????°\n\t\tint groupNumber = 0;\n\n\t\t// ??????????????????????????????\n\t\tint time = 0;\n\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\twhile (groupNumber < MAX_GROUP_NUKMBER) {\n\t\t\tif (time % 5 == 0) {\n\t\t\t\t// ??°????????¢\n\t\t\t\t// i???????????°?????????????????°??? i%5 ??? 1 ?????¨???5??????????????\\????????¨??????2???\n\t\t\t\twaitLine.put(groupNumber, (groupNumber % 5 == 1 ? 5 : 2));\n\t\t\t\twaitTimes[groupNumber] = time;\n\n\t\t\t\tgroupNumber++;\n\t\t\t\t// ?????§??°???????????????????????°????????????????????§?????????????????????????????§??°????????????????????????????????°??????????????????\n\t\t\t\tif (maxGroupNumber < groupNumber\n\t\t\t\t\t\t&& !waitLine.containsKey(maxGroupNumber)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ??¢????????¢\n\t\t\tfor (Map.Entry<Integer, Integer> entry : waitLine.entrySet()) {\n\t\t\t\t// ?????????->entry.getValue(); ->?????°\n\t\t\t\tint startPos = getOpendSheetsPosition(entry.getValue());\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// ??§????????´???\n\t\t\t\t\t// ??§???????????????????¢???? -> ?£??????????????¨????->entry.getKey()\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(entry.getValue()),\n\t\t\t\t\t\t\tentry.getValue());\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\tdeleteTarget.add(entry.getKey());\n\t\t\t\t\twaitTimes[entry.getKey()] = time - waitTimes[entry.getKey()];\n\t\t\t\t} else {\n\t\t\t\t\t// ??§???????????´???\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tfor (int target : deleteTarget) {\n\t\t\t\twaitLine.remove(target);\n\t\t\t}\n\n\t\t\t// ??§??????????????????????????????????????????\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * ????????????????????????????????????????????´????????? ??????????????????????????´??????-1????????´?????????\n\t *\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t * @return ????????????????????????????????????\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??°?????????????????????????£??????????????¨??????????\n\t *\n\t * @param targetGroup\n\t *            ????±??????°???????????????\n\t * @return ?£??????????\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * ???????¢?????????????\n\t *\n\t * @param startPos\n\t *            ????¢?????????????????????????\n\t * @param mealtime\n\t *            ?£??????????\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// ????????????????????°???????????????\n\t\t// ???\n\t\tint[] seat = new int[17];\n\t\t// ????????????\n\t\tList<Integer> waitGuest = new ArrayList<Integer>();\n\n\t\t// ?¨??????\\???\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString input = null;\n\n\t\t// ??\\???????????????????????????????????§????????????\n\t\twhile (true) {\n\t\t\tinput = br.readLine();\n\t\t\tif (input == null || input.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// int??????????????????\n\t\t\tint inputNum = Integer.parseInt(input);\n\n\t\t\t// ????????????????????°???????????????\n\t\t\t// ??????\n\t\t\tint time = 0;\n\n\n\t\t\t// ?????????\n\t\t\twhile (true) {\n\t\t\t\t// ?£????????????£?????¢????????????????????????\n\t\t\t\texitFukushimaken(seat, time);\n\n\t\t\t\t// ??¢????????????????????????????????????????????????\n\t\t\t\tif (time % 5 == 0) {\n\t\t\t\t\twaitGuest.add(time / 5);\n\t\t\t\t}\n\n\t\t\t\t// ?????????????????¢?????????????????????\n\t\t\t\tif (isWaitGuest(waitGuest)) {\n\t\t\t\t\t// ??\\?????¢????????°????????????\n\t\t\t\t\tint guest = guestOfNumber(waitGuest.get(0));\n\t\t\t\t\t// ?????????????????????????????????\n\t\t\t\t\tint seatNum = confirmEmptySeat(seat, guest);\n\n\t\t\t\t\tif (seatNum != 99) {\n\t\t\t\t\t\tenterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n\t\t\t\t\t\t// ??\\??????????????°??????????????´?????????????????????????????????\n\t\t\t\t\t\tif (inputNum == waitGuest.get(0)) {\n\t\t\t\t\t\t\tSystem.out.println(time - waitGuest.get(0) * 5);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} \n\t\t\t\t\t\twaitGuest.remove(0);\n\n\t\t\t\t\t\t// ???????????????????????????????????\\???????????´???\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t++time;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????????????????????????????????????\n\n\t//\n\tprivate static boolean isWaitGuest(List<Integer> waitGuest){\n\n\t\tif (waitGuest.size() != 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// i???????????°?????????????????°?????????\n\tprivate static int guestOfNumber(int number) {\n\t\tif (number % 5 == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t// ??§??????????????????????????????\n\t// i = ??§????????´????????????????????????99?????§?????????\n\tprivate static int confirmEmptySeat(int[] seat, int guest) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < seat.length - guest; ++i) {\n\t\t\tfor (int j = 0; j < guest; ++j) {\n\t\t\t\tif (seat[i + j] != 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t++count;\n\t\t\t\t\tif (guest == count) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 99;\n\t}\n\n\t// ????????????\n\tprivate static void enterFukushimaken(int groupNum, int guest, int seatNum,\n\t\t\tint[] seat, int time) {\n\t\tint ateTime = time + ateFoodTime(groupNum);\n\t\tfor (int i = 0; i < guest; ++i) {\n\t\t\tseat[seatNum + i] = ateTime;\n\t\t}\n\t}\n\n\t// ?£????????????£?????¢?????????????¢??????????\n\tprivate static void exitFukushimaken(int[] seat, int time) {\n\t\tfor (int i = 0; i < seat.length; ++i) {\n\t\t\tif (time == seat[i]) {\n\t\t\t\tseat[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// i???????????°?????????????£?????????????\n\tprivate static int ateFoodTime(int number) {\n\t\tint a = (number % 2) * 17;\n\t\tint b = (number % 3) * 3;\n\t\treturn a + b + 19;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/** 147 */\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, finalSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveTime = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealTimes = new int[GROUP_NUM];\n        waitTimes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveTime[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int order;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 離席させる\n            outCustomer(currentTime);\n\n            if ((order = search(arriveTime, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(order)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(order));\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(order);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(order);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        // 待った時間を設定する\n                        waitTimes[wait] = currentTime - arriveTime[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitTimes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int search(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (mealTimes[Integer.parseInt(seat)] <= currentTime\n                    - arriveTime[Integer.parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int i = finalSeatNum - 1, count = 0; count < customersNum[Integer\n                .parseInt(groupsNum)]; i--, count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[i] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n\n        for (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                // 最後の座席番号を設定する\n                finalSeatNum = i;\n\n                return true;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < 100; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            boolean firstCustomer = false;\n            int kuusekiCount = 0;\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れるか確認。\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n        // グループ番号\n        group = time / 5;\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] c = new int[17];\n\t\tint[] p = new int[100];\n\t\tint[] w = new int[100];\n\t\tint[] sit = new int[100];\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tp[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tw[i] = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\t\tint i = 0;\n\t\tint t = 0;\n\t\tDeque<Integer> deque = new ArrayDeque<Integer>();\n\t\tDeque<Integer> m = new ArrayDeque<Integer>();\n\t\tint a = -1;\n\t\tloop1: while (true) {\n\t\t\tif (t == i * 5 && i < 100) {\n\t\t\t\tdeque.offer(i++);\n\t\t\t\tm.offer(t);\n\t\t\t}\n\t\t\tfor (int k = 0; k < 17; k++) {\n\t\t\t\tc[k] = Math.max(0, c[k] - 1);\n\t\t\t}\n\t\t\tif (!deque.isEmpty()) {\n\t\t\t\tint de = deque.peekFirst();\n\t\t\t\ta = getA(p[de], c);\n\t\t\t}\n\t\t\twhile (!deque.isEmpty() && a != -1) {\n\n\t\t\t\tint id = deque.poll();\n\t\t\t\tfor (int j = a; j < a + p[id]; j++) {\n\t\t\t\t\tc[j] = w[id];\n\t\t\t\t}\n\t\t\t\tsit[id] = t - m.pollFirst();\n\t\t\t\tif (id == 99) {\n\t\t\t\t\tbreak loop1;\n\t\t\t\t}\n\n\t\t\t\tif (!deque.isEmpty()) {\n\t\t\t\t\tint de = deque.peekFirst();\n\t\t\t\t\ta = getA(p[de], c);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\twhile (scanner.hasNext()) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tSystem.out.println(sit[n]);\n\t\t}\n\t}\n\n\tprivate static int getA(int d, int[] c) {\n\t\tint count = 0;\n\t\tint a = -1;\n\t\tfor (int i = 0; i < 17; i++) {\n\t\t\tif (c[i] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tif (d == count) {\n\t\t\t\t\treturn i - count + 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n    // ?¨???¢??°?????§???\n    static final int MAX_NUMBER_OF_VISITOR = 100;\n\n    // ??§?????°\n    static final int NUMBER_OF_SEAT = 17;\n\n    // ??°???????????°??\\??????\n    static final int INTERVAL = 5;\n\n    // ??????????????????\n    static int[] waitingTime = new int[MAX_NUMBER_OF_VISITOR];\n\n    // ???????????§????????¶???\n    static int[] shopSeatTimer = new int[NUMBER_OF_SEAT];\n\n    public static void main(String[] args) {\n\n\t// ?¨??????\\???\n\tScanner sc = new Scanner(System.in);\n\n\tList<Integer> orders = new ArrayList<>();\n\n\twhile (sc.hasNextLine()) {\n\t    String nextLine = sc.nextLine();\n\t    if (\"\".equals(nextLine)) {\n\t\tbreak;\n\t    }\n\t    orders.add(Integer.parseInt(nextLine));\n\t}\n\n\t// ??\\???????????????????????§????????????\n\tint maxOrder = returnMax(orders);\n\n\t// ????????????????????????\n\tArrays.fill(waitingTime, -1);\n\n\t// ?????\\?????¬????????§?????????\n\texecuteSimulation(maxOrder);\n\n\t// ??????????????°?????????????????????????????????\n\tfor (Integer order : orders) {\n\t    System.out.println(waitingTime[order]);\n\t}\n\n\tsc.close();\n\n    }\n\n    private static void executeSimulation(int maxOrder) {\n\t// ????????????\n\tList<Integer> waintinGroup = new ArrayList<>();\n\n\t// ???????????§???????????????(?????????-1??¨??????)\n\tArrays.fill(shopSeatTimer, -1);\n\n\t// ????????????????????????????§?\n\n\tfor (int now = 0;; now++) {\n\n\t    // ?£?????????????????????????????????????????????????????£????????????????-1\n\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\n\t\t// ????????????????????????????????????????????????\n\t\tif (shopSeatTimer[i] != -1) {\n\t\t    shopSeatTimer[i]--;\n\t\t    // ???????????????0???????????????\n\t\t    if (shopSeatTimer[i] == 0) {\n\t\t\tshopSeatTimer[i] = -1;\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now % INTERVAL == 0) {\n\t\twaintinGroup.add(now / INTERVAL);\n\t    }\n\n\t    // ????????????????????§???\n\t    while (true) {\n\t\tif (waintinGroup.isEmpty()) {\n\t\t    break;\n\t\t}\n\n\t\tint group = waintinGroup.get(0);\n\t\tint openSeatHead = canISitDown(group);\n\n\t\t// ???????????????????????°\n\t\tif (openSeatHead != -1) {\n\t\t    // ????????????????????????????´?\n\t\t    waitingTime[group] = now - group * INTERVAL;\n\n\t\t    /**\n\t\t     * ???????????°\n\t\t     */\n\t\t    System.out.println(\"??°??????????????????\" + group);\n\t\t    System.out.println(\"????????????\" + waitingTime[group]);\n\t\t    System.out.println(openSeatHead);\n\t\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\t\t\tSystem.out.print(shopSeatTimer[i] + \",\");\n\t\t    }\n\t\t    System.out.println();\n\t\t    /*\n\t\t     * \n\t\t     */\n\n\t\t    // ?£?????????????????´?\n\t\t    for (int i = 0; i < howManymembers(group); i++) {\n\t\t\tshopSeatTimer[openSeatHead + i] = howLongToEat(group);\n\t\t    }\n\t\t    // ??????????????????\n\t\t    waintinGroup.remove(0);\n\n\t\t    // ?±??????????????????§??????????????°?????????????????????????????????\n\t\t    if (group == maxOrder) {\n\t\t\treturn;\n\t\t    }\n\n\t\t} else {\n\t\t    break;\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n    // ????????????????????§????????????\n    private static int returnMax(List<Integer> orders) {\n\tint maxOrder = 0;\n\tfor (Integer order : orders) {\n\t    maxOrder = Math.max(order, maxOrder);\n\t}\n\treturn maxOrder;\n\n    }\n\n    // ??§?????????????????????\n    private static int canISitDown(int group) {\n\tint count = 0;\n\tfor (int i = 0; i < NUMBER_OF_SEAT - howManymembers(group) + 1; i++) {\n\t    for (int j = 0; j < howManymembers(group); j++) {\n\t\tif (shopSeatTimer[i + j] == -1) {\n\t\t    count++;\n\t\t} else {\n\t\t    count = 0;\n\t\t    break;\n\t\t}\n\n\t\tif (count == howManymembers(group)) {\n\t\t    return i;\n\t\t}\n\t    }\n\t}\n\treturn -1;\n    }\n\n    // ????????°?????????????????????\n    private static int howManymembers(int group) {\n\treturn group % 5 == 1 ? 5 : 2;\n    }\n\n    // ?£???????????????????\n    private static int howLongToEat(int group) {\n\treturn 17 * (group % 2) + 3 * (group % 3) + 19;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Fukushimaken {\n\n    int [] seats;\n    ArrayList<Eater> eating;\n\n    Fukushimaken () {\n        seats = new int[17];\n        for (int i = 0; i < 17; i++)    seats[i] = -1;\n        eating = new ArrayList<Eater>();\n    }\n\n    boolean acceptEater (Eater eater) {\n        int n = eater.size;\n\n        if (n == 2) {\n            for (int i = 0; i < 16; i++) {\n                if (seats[i] == -1 && seats[i+1] == -1) {\n                    eating.add(eater);\n                    eater.setSeatNum(i);\n                    seats[i] = eater.groupNum;\n                    seats[i+1] = eater.groupNum;\n                    return true;\n                }\n            }\n        }\n        else if (n == 5) {\n            for (int i = 0; i < 13; i++) {\n                if (seats[i] == -1 && seats[i+1] == -1 && seats[i+2] == -1 && seats[i+3] == -1 && seats[i+4] == -1) {\n                    eating.add(eater);\n                    eater.setSeatNum(i);\n                    for(int j = 0; j < 5; j++)  seats[i+j] = eater.groupNum;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    void removeEater (int time) {\n        for (int i = 0; i < eating.size(); i++) {\n            Eater e = eating.get(i);\n            if (time == e.getEnterTime() + e.existTime) {\n                for (int k = 0; k < e.size; k++) {\n                    this.seats[e.getSeatNum() + k] = -1;\n                }\n                eating.remove(i); \n            }\n        }\n    }\n    \n}\n\nclass Eater {\n\n    int groupNum;\n    int comeTime;\n    int size;\n    int existTime;\n    private int enterTime;\n    private int seatNum;\n    \n    Eater (int groupNum) {\n        this.groupNum = groupNum;\n        this.comeTime = groupNum * 5;\n\n        if (groupNum % 5 == 1)  this.size = 5;\n        else                    this.size = 2;\n\n        this.existTime = 17 * (groupNum % 2) + 3 * (groupNum % 3) + 19;\n    }\n\n    void setEnterTime (int time) {\n        this.enterTime = time;\n    }\n\n    int getEnterTime () {\n        return this.enterTime;\n    }\n\n    void setSeatNum (int seat) {\n        this.seatNum = seat;\n    }\n\n    int getSeatNum () {\n        return this.seatNum;\n    }\n}\n\nclass Main {\n\n    static Fukushimaken fuk;\n    static ArrayList<Eater> allEaters;\n\n    static void solve () {\n        \n        ArrayList<Eater> waitingEaters = new ArrayList<Eater>();\n\n        for(int t = 0; t < 5000; t++) {\n            fuk.removeEater(t);\n            if (t % 5 == 0 && t < 500)     waitingEaters.add(allEaters.get(t/5));\n            while ((!waitingEaters.isEmpty()) && fuk.acceptEater(waitingEaters.get(0))) {\n                int n = waitingEaters.get(0).groupNum;\n                allEaters.get(n).setEnterTime(t);\n                waitingEaters.remove(0);\n            }\n\n//            System.out.printf(\"%3d: \", t);\n//            for(int i = 0; i < 17; i++) {\n//                int j = fuk.seats[i];\n//                if ( j == -1 )  System.out.print(\"__\");\n//                else if ( j < 10 )   System.out.printf(\"0%d\", j);\n//                else    System.out.print(j);\n//            }\n//            System.out.println(\"\");\n\n        }\n    }\n\n    public static void main (String [] args) {\n\n        Scanner sc = new Scanner(System.in);\n        fuk = new Fukushimaken();\n        allEaters = new ArrayList<Eater>();\n\n        for(int i = 0; i < 100; i++) {\n            allEaters.add(new Eater(i));\n        }\n\n        solve();\n\n        while (sc.hasNext()) {\n            int n = sc.nextInt();\n            System.out.println( allEaters.get(n).getEnterTime() - allEaters.get(n).comeTime );\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.util.Arrays.deepToString;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.concurrent.PriorityBlockingQueue;\n\npublic class Main_pq {\n\tpublic static void main(String[] args) {\n\t\tnew Main_pq().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic void run() {\n\t\tint[] ans = new int[100];\n\t\t\n\t\tPriorityQueue<Event> pq = new PriorityQueue<Event>();\n\t\tint[] table = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tint nextGroup = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tEvent e = new Event();\n\t\t\te.id = i;\n\t\t\te.move = Event.ARRIVE;\n\t\t\te.initTime = i * 5;\n\t\t\te.time = i * 5;\n\t\t\te.num = i % 5 == 1 ? 5 : 2;\n\t\t\te.duration = 17*(i%2) + 3*(i%3)+19;\n\t\t\tpq.add(e);\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEvent e = pq.poll();\n\t\t\tif (e.move == Event.LEAVE) {\n\t\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\t\tif (table[i] == e.id) table[i] = -1;\n\t\t\t\t}\n\t\t\t} else if (e.move == Event.ARRIVE) {\n\t\t\t\tint pos = -1;\n\t\t\t\tif (nextGroup == e.id) {\n\t\t\t\t\tfor (int i = 0; i + e.num <= table.length; i++) {\n\t\t\t\t\t\tboolean ok = true;\n\t\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\t\tif (table[i+j] != -1) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t// 座る\n\t\t\t\t\tans[e.id] = e.time - e.initTime;\n\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\ttable[pos + j] = e.id;\n\t\t\t\t\t}\n\t\t\t\t\te.time += e.duration;\n\t\t\t\t\te.move = Event.LEAVE;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t\tnextGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 空いてなければ待つ。時刻+1して席が空くのを待つ手抜き実装\n\t\t\t\t\te.time++;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(ans[n]);\n\t\t}\n\t}\n\t\n\tclass Event implements Comparable<Event> {\n\t\tstatic final int LEAVE = 0;\n\t\tstatic final int ARRIVE = 1;\n\t\tint id;\n\t\tint initTime;\n\t\tint move;\n\t\tint time;\n\t\tint num;\n\t\tint duration;\n\t\t@Override\n\t\tpublic int compareTo(Event o) {\n\t\t\tint c = time - o.time;\n\t\t\tif (c == 0) c = move - o.move;\n\t\t\tif (c == 0) c = id - o.id;\n\t\t\treturn c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main {\n\t/**\n\t* @param args\n\t*/\n\n\tstatic class Seat {\n\t\tpublic\tint\tb = 0;\n\t}\n\n\tstatic class Grp {\n\t\tpublic\tint\ts = 0;\n\t\tpublic\tint\te = 0;\n\t\tpublic\tint\tn = 0;\n\t\tpublic\tint\tb = 0;\n\t\tpublic\tint\tw = -1;\n\n\t\tpublic Grp(int i) {\n\t\t\tthis.s = i*5;\n\t\t\tthis.e = 17*(i%2)+3*(i%3)+19;\n\t\t\tthis.n = (i%5==1)?5:2;\n\t\t}\n\t}\n\n\tstatic class Lst {\n\t\tpublic\tint[]\td = new int[101];\n\t\tpublic\tint\t\th = 0;\n\t\tpublic\tint\t\tt = 0;\n\n\t\tpublic void add(int e) {\n\t\t\td[t++] = e;\n\t\t\tthis.sort();\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\treturn d[h+i];\n\t\t}\n\n\t\tpublic int remove(int i) {\n\t\t\tint\trmv = this.d[h];\n\t\t\tthis.d[i] = 0;\n\t\t\tthis.sort();\n\t\t\tthis.h++;\n\t\t\treturn rmv;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn t-h;\n\t\t}\n\n\t\tpublic void sort() {\n\t\t\tArrays.sort(d, h, t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tGrp[]\tg = new Grp[100];\n\t\tSeat\ts = new Seat();\n\t\tLst\t\te = new Lst();\n\t\tLst\t\tw = new Lst();\n\t\tboolean\tf = true;\n\t\tint\t\to = 0;\n\t\t\n\t\tfor (int i = 0; i < g.length; i++) {\n\t\t\tg[i] = new Grp(i);\n\n\t\t\t// 席があるかチェック\n\t\t\tif (isAvailableSeat(s, g[i]) && f) {\n\t\t\t\t// 食べ終わるグループリストへ追加\n\t\t\t\te.add((g[i].s+g[i].w+g[i].e)*100+i);\n\t\t\t} else {\n\t\t\t\t// 待っているグループリストへ追加\n\t\t\t\tf = false;\n\t\t\t\tw.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(w.size() > 0) {\n\t\t\tint\ta = e.remove(0);\n\t\t\tint\tt = a/100;\n\t\t\tint\ti = a%100;\n\n\t\t\t// 一グループが食べ終わった\n\t\t\ts.b = s.b&(~g[i].b);\n\n\t\t\tfor(int b = 0; b < w.size(); b++) {\n\t\t\t\t// 待っているグループが席に座れるかチェック\n\t\t\t\tint j = w.get(b);\n\n\t\t\t\t// 待っているグループがこれ以上いなければ打ちきり\n\t\t\t\tif (g[j].s > t) break;\n\n\t\t\t\t// 席があるかチェック\n\t\t\t\tif (isAvailableSeat(s, g[j])) {\n\t\t\t\t\t// グループの待ち時間を計算\n\t\t\t\t\tg[j].w = Math.max(0, t-g[j].s);\n\n\t\t\t\t\t// 食べ終わるグループリストへ追加\n\t\t\t\t\te.add((g[j].s+g[j].w+g[j].e)*100+j);\n\n\t\t\t\t\tw.remove(b--);\n\t\t\t\t} else {\n\t\t\t\t\t// 座れなかったら打ちきり\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ((o = parseNum()) != -1) {\n\t\t\tSystem.out.println(g[o].w);\n\t\t}\n\t}\n\n\tprivate static boolean isAvailableSeat(Seat s, Grp g) {\n\t\tboolean bSt = false;\n\t\tint\t\tb   = (1<<g.n)-1;\n\n\t\tfor (int i = 0; i <= 17-g.n && !bSt; i++, b<<=1) {\n\t\t\tif ((s.b&b) == 0) {\n\t\t\t\ts.b = s.b|b;\n\t\t\t\tg.b = b;\n\t\t\t\tg.w = 0;\n\t\t\t\tbSt = true;\n\t\t\t}\n\t\t}\n\t\treturn bSt;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = -1;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tif (num == -1) num = 0;\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (skp == 0 || buf == -1) {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n\n\tpublic static void main(String... args) {\n\t\tList<Integer> targetGroupNumberList = getInputList();\n\t\tint maxGroupNumber = Collections.max(targetGroupNumberList);\n\n\t\tFukushimaken fukushimaken = new Fukushimaken();\n\t\tList<Group> groupList = new ArrayList<Group>();\n\n\t\tint elapsedTime = 0;\n\t\tint groupNumber = 0;\n\t\twhile (true) {\n\t\t\tif (elapsedTime % 5 == 0) {\n\t\t\t\tgroupNumber = elapsedTime / 5;\n\t\t\t\tGroup group = new Group(groupNumber);\n\t\t\t\tgroupList.add(group);\n\t\t\t\t\n\t\t\t\tfukushimaken.receive(group);\n\t\t\t}\n\t\t\tfukushimaken.refresh(elapsedTime);\n\n\t\t\tif (maxGroupNumber <= groupNumber\n\t\t\t\t\t&& groupList.get(maxGroupNumber).haveStartedEating()) {\n\t\t\t\t// 対象となるグループ番号の待ち時間が全て取得できた段階で終了する\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telapsedTime++;\n\t\t}\n\n\t\tfor (int i : targetGroupNumberList) {\n\t\t\tGroup group = groupList.get(i);\n\t\t\tint waitTime = group.getWaitTime();\n\t\t\tSystem.out.println(waitTime);\n\t\t}\n\t}\n\t\n\tstatic List<Integer> getInputList() {\n\t\tScanner scanner = null;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\t\ttry {\n\t\t\tscanner = new Scanner(System.in);\n\t\t\twhile (scanner.hasNext()) {\n\t\t\t\tString line = scanner.nextLine();\n\t\t\t\tinputList.add(Integer.parseInt(line));\n\t\t\t}\n\t\t\treturn inputList;\n\t\t} finally {\n\t\t\tif (scanner != null) {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Fukushimaken {\n\t\tprivate List<Boolean> tables = new ArrayList<Boolean>(17); // 座席（Falseであれば空席となる）\n\t\tprivate List<Group> groupAtTable = new ArrayList<Group>(); // 着席しているグループ\n\t\tprivate LinkedList<Group> groupQueue = new LinkedList<Group>(); // 並んでいるグループ\n\n\t\tFukushimaken() {\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\ttables.add(false);\n\t\t\t}\n\t\t}\n\n\t\tvoid receive(Group group) {\n\t\t\tthis.groupQueue.offer(group);\n\t\t}\n\n\t\tvoid refresh(int elapsedTime) {\n\t\t\tthis.refreshTables(elapsedTime);\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t\tfor (Group group : this.groupQueue) {\n\t\t\t\t// 行列にいるグループに待ち時間を加算する\n\t\t\t\tgroup.addWaitTime();\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshTables(int elapsedTime) {\n\t\t\t// 食事の済んだグループの座席を空席とする\n\t\t\tfor (int i = 0; i < this.groupAtTable.size(); i++) {\n\t\t\t\tGroup group = this.groupAtTable.get(i);\n\t\t\t\tif (!group.haveFinishedMeal(elapsedTime)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Integer> tableNumbers = group.getUseTableNumbers();\n\t\t\t\tfor (int j : tableNumbers) {\n\t\t\t\t\tthis.tables.set(j, false);\n\t\t\t\t}\n\t\t\t\tthis.groupAtTable.remove(i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshQueue(int elapsedTime) {\n\t\t\tGroup group = this.groupQueue.peek();\n\t\t\tif (group == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSet<Integer> emptyTableNumbers = this.getEmptyTablesNumbers(group.getSize());\n\t\t\tif (emptyTableNumbers.size() == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// 座席が空いていれば行列の先頭から順に着席する\n\t\t\tthis.groupAtTable.add(group);\n\t\t\tgroup.startEating(emptyTableNumbers, elapsedTime);\n\t\t\tthis.groupQueue.removeFirst();\n\t\t\tfor (int i : emptyTableNumbers) {\n\t\t\t\tthis.tables.set(i, true);\n\t\t\t}\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t}\n\n\t\tprivate Set<Integer> getEmptyTablesNumbers(int size) {\n\t\t\t// 席の番号が小さいほうから空いている座席を探す\n\t\t\tSet<Integer> tableNumbers = new HashSet<Integer>();\n\t\t\tfor (int i = 0; i < this.tables.size(); i++) {\n\t\t\t\tboolean isNotEmpty = this.tables.get(i);\n\t\t\t\tif (isNotEmpty) {\n\t\t\t\t\ttableNumbers.clear();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttableNumbers.add(i);\n\t\t\t\tif (size <= tableNumbers.size()) {\n\t\t\t\t\treturn tableNumbers;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new HashSet<Integer>();\n\t\t}\n\t}\n\n\tstatic class Group {\n\n\t\tprivate int number; // グループ番号\n\t\tprivate int timeToEat; // 食事にかかる時間\n\t\tprivate int endingTime; // 食事が済む時点の経過時間\n\t\tprivate Set<Integer> useTableNumbers; // 使用している座席の番号\n\t\tprivate int waitTime; // 待ち時間\n\n\t\tGroup(int number) {\n\t\t\tthis.number = number;\n\t\t\tthis.timeToEat = 17 * (this.number % 2) + 3 * (this.number % 3) + 19;\n\t\t}\n\n\t\tvoid startEating(Set<Integer> tableNumbers, int elapsedTime) {\n\t\t\t// 着席し、さっそく食事を始める。この時点でこのグループの待ち時間は確定する。\n\t\t\tthis.useTableNumbers = tableNumbers;\n\t\t\tthis.endingTime = elapsedTime + timeToEat;\n\t\t}\n\n\t\tboolean haveFinishedMeal(int elapsedTime) {\n\t\t\treturn this.endingTime < elapsedTime;\n\t\t}\n\n\t\tSet<Integer> getUseTableNumbers() {\n\t\t\treturn this.useTableNumbers;\n\t\t}\n\n\t\tboolean haveStartedEating() {\n\t\t\treturn this.useTableNumbers != null;\n\t\t}\n\n\t\tvoid addWaitTime() {\n\t\t\tthis.waitTime++;\n\t\t}\n\n\t\tint getWaitTime() {\n\t\t\t// 店に到着した時点の1分間を除外して待ち時間を返す\n\t\t\treturn (this.waitTime == 0) ? 0 : --this.waitTime;\n\t\t}\n\n\t\tint getSize() {\n\t\t\treturn (this.number % 5 == 1) ? 5 : 2; // グループの人数\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        int customerCount = 0;\n        int[] waitTime = new int[100];\n\n        while (customerCount < 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == groupMembers[headGroup % 5]) {\n                        startIndex = i - (groupMembers[headGroup % 5] - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime[headGroup] = pastMinutes - (headGroup << 2)\n                            + headGroup;\n                    for (int i = startIndex; i < (startIndex + groupMembers[headGroup % 5]); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = ((headGroup + 1) + ((headGroup + 1) << 2) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                    customerCount++;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime[sc.nextInt()]);\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0147().doIt();\n\t}\n\t\n\tclass AOJ0147{\n\t\tint[] waitTime;\n\t\tState[] states;\n\t\tvoid doIt(){\n\t\t\twaitTime = new int[100];\n\t\t\tLinkedList<WaitState> q = new LinkedList<WaitState>();\n\t\t\tstates = new State[17];\n\t\t\tfor(int i=0;i<17;i++)states[i] = new State(-1, -1);\n\t\t\tfor(int i=0;i<1000*5;i++){\n//\t\t\tfor(int i=0;i<100;i++){\n\t\t\t\tremoveState(i);\n\t\t\t\tif(i%5==0&&i/5<=99)q.add(new WaitState(i/5, (i/5)%5==1? 5:2, i));//stack\n\t\t\t\tint index = -1;\n\t\t\t\tif(q.size()>0)index = canPush(q.get(0));\n\t\t\t\twhile(index >= 0){\n\t\t\t\t\twaitTime[q.get(0).ban] = i-q.get(0).startTime;\n\t\t\t\t\tsetState(q.remove(), index, i);\n\t\t\t\t\tif(q.size()==0)break;\n\t\t\t\t\tindex = canPush(q.get(0));\n//\t\t\t\t\tSystem.out.println(q.get(0).ban+\" \"+q.get(0).num+\" \"+q.get(0).startTime+\" \"+index);\n\t\t\t\t}\n//\t\t\t\tprintState(i);\n//\t\t\t\tSystem.out.println(\"stacks are \");\n//\t\t\t\tfor(int s=0;s<q.size();s++)System.out.println(q.get(s).ban+\" \"+q.get(s).num);\n//\t\t\t\tSystem.out.println(\"--------------\");\n\t\t\t}\n\t\t\twhile(in.hasNext())System.out.println(getResult(in.nextInt()));\n\t\t}\n\t\t\n\t\tvoid printState(int time){\n\t\t\tfor(int i=0;i<17;i++){\n\t\t\t\tSystem.out.println((time)+\":\"+states[i].ban+\" _ \"+states[i].endTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid removeState(int time){\n\t\t\tfor(int i=0;i<17;i++)if(states[i].ban>=0&&states[i].endTime<=time)\n\t\t\t\tstates[i] = new State(-1, -1);\n\t\t}\n\t\t\n\t\tvoid setState(WaitState j,int index,int currentTime){\n\t\t\tint endTime = 17*(j.ban%2)+3*(j.ban%3)+19; \n\t\t\tfor(int i=index;i<index+j.num;i++){\n\t\t\t\tstates[i] = new State(j.ban, endTime+currentTime);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint canPush(WaitState j){\n\t\t\tfor(int i=0;i<17;i++)if(states[i].ban == -1){\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor(int s=i;s<i+j.num;s++)if(s<17&&states[s].ban == -1)cnt++;\n\t\t\t\tif(cnt==j.num)return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint getResult(int n){\n\t\t\treturn waitTime[n];\n\t\t}\n\t\t\n\t\tclass WaitState{\n\t\t\tint ban,num,startTime;\n\t\t\tpublic WaitState(int _ban,int _num,int _startTime) {\n\t\t\t\tban = _ban;\n\t\t\t\tnum = _num;\n\t\t\t\tstartTime = _startTime;\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint ban,endTime;\n\t\t\tpublic State(int _ban,int _endTime){\n\t\t\t\tban = _ban;\n\t\t\t\tendTime = _endTime;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\n\npublic class Main {\n\n\t/**グループ人数周期表*/\n\tprivate static final int[] MEMBER_CYCLE = { 2, 5, 2, 2, 2 };\n\t/**グループ食事時間周期表*/\n\tprivate static final int[] EATING_TIME_CYCLE = { 19, 39, 25, 36, 22, 42 };\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 128);//おまじない付\n\n\t\tArrayList<Integer> groupNumList = new ArrayList<Integer>();//入力値\n\t\tString singleLine;//1行分\n\t\tint maxGroupNum = 0; //入力中の最大グループ→99です。。。\n\n\t\t//一括で読み込み格納\n\t\twhile ((singleLine = reader.readLine()) != null) {\n\t\t\tint groupNum = Integer.parseInt(singleLine);\n\t\t\tgroupNumList.add(groupNum);\n\t\t\tif (groupNum > maxGroupNum) {\n\t\t\t\tmaxGroupNum = groupNum;\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t\t//読み込み後計算\n\t\tint[] result = calculate(maxGroupNum);\n\n\t\t//グループ番号に対応する待ち時間を入力順で出力\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tfor (int i = 0; i < groupNumList.size(); i++) {\n\t\t\tout.println(result[groupNumList.get(i)]);\n\t\t}\n\t\tout.flush();//まとめてflush\n\t}\n\n\t/**\n\t *メイン処理\n\t */\n\tprivate static int[] calculate(int lastGroupNum) {\n\t\tint time = -1; //時刻\n\t\tint lastGroupArriveTime = lastGroupNum * 5; //最終グループ到着時刻\n\t\tint[] waitingTimeArray = new int[lastGroupNum + 1]; //グループ毎待ち時間\n\t\tArrayList<Integer> waitingQueue = new ArrayList<Integer>(); //待ち行列(到着時刻を格納)\n\t\tint[] endTimePerSeat = new int[17]; //食事終了予定時刻(席毎に保持)\n\n\t\t/** なんとなく早そう！*/\n\t\tBitSet vacantSeatList = new BitSet(17); //空席表(true:空席 false:満席)\n\n\t\t//待ち行列無しかつ、最終グループ到着後なら終了\n\t\twhile (!(waitingQueue.isEmpty() && time > lastGroupArriveTime)) {\n\n\t\t\ttime++; //時間を進める\n\n\t\t\t//待ち無しかつ、当該時刻に新規到着が無い場合は食事終了判定スキップ\n\t\t\tif (waitingQueue.isEmpty() && time % 5 != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//食事終了時刻を過ぎた座席を見つけたら空席表を更新\n\t\t\tfor (int e = 0; e < 17; e++) {\n\t\t\t\tif (!vacantSeatList.get(e) && endTimePerSeat[e] <= time) {\n\t\t\t\t\tvacantSeatList.set(e, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//待ち行列への追加\n\t\t\tif (time % 5 == 0 && time <= lastGroupArriveTime) {\n\t\t\t\twaitingQueue.add(time);\n\t\t\t}\n\n\t\t\t//待ち行列が無くなる、または先頭グループが入店出来ない場合はループ終了\n\t\t\twhile (!waitingQueue.isEmpty()) {\n\t\t\t\tint currentGroupNum = waitingQueue.get(0) / 5;\n\t\t\t\tint memberCount = MEMBER_CYCLE[currentGroupNum % 5];\n\n\t\t\t\t//空席がメンバ数未満\n\t\t\t\tif (memberCount > vacantSeatList.cardinality()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tboolean isEnter = false;\n\t\t\t\t//空席がメンバ数以上の場合は、連続して空いているか確認\n\t\t\t\tfor (int firstVacant = vacantSeatList.nextSetBit(0); firstVacant < 16 && firstVacant != -1;) {\n\t\t\t\t\tint endVacant = vacantSeatList.nextClearBit(firstVacant) - 1; //並びでの最後の空席位置\n\n\t\t\t\t\t//着席可能の場合\n\t\t\t\t\tif (endVacant >= firstVacant + memberCount - 1) {\n\t\t\t\t\t\tvacantSeatList.set(firstVacant, firstVacant + memberCount, false);//空席表を更新\n\t\t\t\t\t\tArrays.fill(endTimePerSeat, firstVacant, firstVacant + memberCount, time\n\t\t\t\t\t\t\t\t+ EATING_TIME_CYCLE[currentGroupNum % 6]); //食事終了予定時刻を更新\n\t\t\t\t\t\twaitingTimeArray[currentGroupNum] = time - waitingQueue.get(0); //待ち時間結果表に追加\n\t\t\t\t\t\twaitingQueue.remove(0);//待ち行列減処理\n\n\t\t\t\t\t\t//次グループの入店可能判定へ移る\n\t\t\t\t\t\tisEnter = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\t//着席不可の場合、次の空席開始位置を探す\n\t\t\t\t\tisEnter = false;\n\t\t\t\t\tfirstVacant = vacantSeatList.nextSetBit(endVacant + 3);\n\n\t\t\t\t}\n\t\t\t\t//先頭グループが入店出来なかった場合はループを終了し時刻を進める\n\t\t\t\tif (!isEnter) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn waitingTimeArray;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t// 正午からの経過時間（分）\n\tprivate int time = 0;\n\n\t// 待ち時間を調査済みであるグループ数\n\tprivate int groupCount = 0;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().execute();\n\t}\n\n\tprivate void execute() throws Exception {\n\n\t\t// 標準入力を１行ずつ処理\n\t\tList<Integer> targetGroups = readInitialData();\n\n\t\t// 席数(17席)\n\t\tEatingVisitor[] seats = new EatingVisitor[17];\n\n\t\t// 待っている人の行列\n\t\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t\t// 各グループの待ち時間計算結果\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t\t// 待ち時間を調べる必要がある最後のグループを取得\n\t\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t\t// 要調査の最大グループが調べ終わったら終了\n\t\twhile (groupCount <= maxGroupNum) {\n\n\t\t\t// 行列の更新\n\t\t\twaitingGroups.addAll(updateWaitLine());\n\n\t\t\t// 離席する\n\t\t\tleaveSeat(seats);\n\n\t\t\t// 着席する\n\t\t\twaitTimes.addAll(sitDown(seats, waitingGroups));\n\n\t\t\ttime++;\n\t\t}\n\n\t\t// 結果出力\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tSystem.out.println(waitTimes.get(targetGroup));\n\t\t}\n\t}\n\n\t/**\n\t * 座席に着席する\n\t * \n\t * @param seats\n\t *            福縞軒の座席(17席)\n\t * @param waitingGroups\n\t *            外で待っているグループ\n\t */\n\tprivate List<Integer> sitDown(EatingVisitor[] seats,\n\t\t\tList<WaitingVisitor> waitingGroups) {\n\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t\tint removeCount = 0;\n\t\tfor (WaitingVisitor waitingPerson : waitingGroups) {\n\n\t\t\tint emptySeatCount = 0;\n\t\t\tboolean isEmpty = false;\n\t\t\tfor (int i = 0; i < seats.length; i++) {\n\n\t\t\t\t// 空席数を検知\n\t\t\t\tif (seats[i] == null) {\n\t\t\t\t\temptySeatCount++;\n\t\t\t\t} else {\n\t\t\t\t\temptySeatCount = 0;\n\t\t\t\t}\n\n\t\t\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t\t\t\t// 席に座ったグループ数を更新\n\t\t\t\t\tgroupCount++;\n\t\t\t\t\tremoveCount++;\n\t\t\t\t\tisEmpty = true;\n\n\t\t\t\t\t// 所属グループの待ち時間を記録\n\t\t\t\t\twaitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t\t\t\t// 食べ終わる時間を計算\n\t\t\t\t\tint endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n\t\t\t\t\t\t\t* (waitingPerson.getGroup() % 3) + 19;\n\n\t\t\t\t\tfor (int j = 0; j < emptySeatCount; j++) {\n\t\t\t\t\t\tseats[i - j] = new EatingVisitor(\n\t\t\t\t\t\t\t\twaitingPerson.getGroup(), endTime + time);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t// 食事を始めた待ち人を削除\n\t\tfor (int i = 0; i < removeCount; i++) {\n\t\t\twaitingGroups.remove(0);\n\t\t}\n\n\t\treturn waitTimes;\n\t}\n\n\t/**\n\t * 食事が終わった人を離席させる\n\t * \n\t * @param seats\n\t *            座席\n\t */\n\tprivate void leaveSeat(EatingVisitor[] seats) {\n\t\tfor (int i = 0; i < seats.length; i++) {\n\t\t\tif (seats[i] != null && seats[i].getEndTime() == time) {\n\t\t\t\tseats[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 待っている行列を更新\n\t * \n\t * @return 待ち行列\n\t */\n\tprivate List<WaitingVisitor> updateWaitLine() {\n\n\t\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t\tint nowGroup = time / 5;\n\t\t// グループがやってきたか判定\n\t\tif (time % 5 == 0) {\n\t\t\t// グループの人数を算出\n\t\t\tint number = 2;\n\t\t\tif (nowGroup % 5 == 1) {\n\t\t\t\tnumber = 5;\n\t\t\t}\n\n\t\t\t// 行列の後ろに追加。待ち始めた時間を記録\n\t\t\twaitingGroups.add(new WaitingVisitor(nowGroup, number, time));\n\t\t}\n\n\t\treturn waitingGroups;\n\t}\n\n\t/**\n\t * 標準入力からデータ取得\n\t * \n\t * @return 要調査のグループ\n\t */\n\tprivate List<Integer> readInitialData() throws Exception {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tString line = null;\n\t\tList<Integer> groups = new ArrayList<Integer>();\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tgroups.add(Integer.parseInt(line));\n\t\t}\n\n\t\treturn groups;\n\t}\n\n\t/**\n\t * 調査が必要な最大グループ番号を検索\n\t * \n\t * @param targetGroups\n\t *            調査対象のグループ\n\t * @return グループ番号\n\t */\n\tprivate int searchMaxGroupNum(List<Integer> targetGroups) {\n\t\tint maxGroupNum = 0;\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tif (maxGroupNum < targetGroup) {\n\t\t\t\tmaxGroupNum = targetGroup;\n\t\t\t}\n\t\t}\n\t\treturn maxGroupNum;\n\t}\n\n}\n\n/**\n * お客さん\n */\nabstract class Visitor {\n\n\t// 所属グループ\n\tprivate int group;\n\n\tpublic int getGroup() {\n\t\treturn group;\n\t}\n\n\tpublic void setGroup(int group) {\n\t\tthis.group = group;\n\t}\n\n}\n\n/**\n * 外で待っているお客さん\n */\nclass WaitingVisitor extends Visitor {\n\n\tpublic WaitingVisitor(int group, int number, int startTime) {\n\t\tsetGroup(group);\n\t\tsetNumber(number);\n\t\tsetStartTime(startTime);\n\t}\n\n\t// 待ち始めた時刻\n\tprivate int startTime;\n\n\t// グループの人数\n\tprivate int number;\n\n\tpublic int getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(int startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic int getNumber() {\n\t\treturn number;\n\t}\n\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n}\n\n/**\n * 食事中のお客さん\n */\nclass EatingVisitor extends Visitor {\n\n\tpublic EatingVisitor(int group, int endTime) {\n\t\tsetGroup(group);\n\t\tsetEndtTime(endTime);\n\t}\n\n\t// 食べ終わる時間\n\tprivate int endtTime;\n\n\tpublic int getEndTime() {\n\t\treturn endtTime;\n\t}\n\n\tpublic void setEndtTime(int endtTime) {\n\t\tthis.endtTime = endtTime;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint[] arrivals = new int[100];\n\t\tint[] seats = new int[17];\n\t\tint[] end_seats = new int[17];\n\t\tint[] wait = new int[100];\n\t\tArrays.fill(seats, -1);\n\t\tArrays.fill(end_seats, -1);\n\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tarrivals[i] = 5 * i;\n\t\t}\n\n\t\tint porpos = 0;\n\t\tEND: for (int time = 0;; time++) {\n\t\t\t\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\tif (seats[i] != -1 && end_seats[i] <= time) {\n\t\t\t\t\tseats[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLOOP:while (arrivals[porpos] <= time) {\n\t\t\t\t\n\t\t\t\t//System.out.println(porpos);\n\t\t\t\t\n\t\t\t\tboolean f_fount = false;\n\t\t\t\tfor (int i = 0; i <= 17 - (porpos % 5 == 1 ? 5 : 2); i++) {\n\t\t\t\t\tboolean found = true;\n\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\tif (seats[i + j] != -1) {\n\t\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tf_fount = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\t\tseats[i + j] = porpos;\n\t\t\t\t\t\t\tend_seats[i + j] = time + 17 * (porpos % 2) + 3\n\t\t\t\t\t\t\t\t\t* (porpos % 3) + 19;\n\t\t\t\t\t\t\twait[porpos] = time - arrivals[porpos];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (porpos == 99) {\n\t\t\t\t\t\t\tbreak END;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tporpos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!f_fount){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"time = \" + time + \" : \" + Arrays.toString(seats));\n\t\t}\n\n\t\twhile (sc.hasNext()) {\n\t\t\tSystem.out.println(wait[sc.nextInt()]);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    static int inputNumber;\n    // 店のカウンター\n    static List<Integer> serviceCounterList;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static int waitTime;\n\n    // 初期化\n    public static void init() {\n        inputNumber = 0;\n        Integer[] serviceCounters = new Integer[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCounters, -1);\n        serviceCounterList = new ArrayList<Integer>(Arrays.asList(serviceCounters));\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTime = 0;\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null || inputStr.isEmpty()) {\n                break;\n            }\n            // 変数の初期化\n            init();\n            inputNumber = Integer.valueOf(inputStr);\n\n            // 各グループの情報を登録（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // printCustomer();\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセット\n                if (nextArrivalGroupNumber <= inputNumber\n                        && currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                    waitGroupNumberList.offer(nextArrivalGroupNumber);\n                    nextArrivalGroupNumber++;\n                }\n\n                // 食べ終わったグループがいれば、退店させる\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // printCounter();\n                // printQuere();\n\n                // 現在時間を1分経過させる\n                currentTime++;\n\n                // ループ終了条件\n                // 入力されたグループ番号まで店に到着し、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTime);\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCounterList.size(); i++) {\n            if (serviceCounterList.get(i) != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCounterList.get(i)) == (currentTime - sitTimeList\n                        .get(serviceCounterList.get(i)))) {\n                    int ateGroupNumber = serviceCounterList.get(i);\n                    // 該当グループの席を空席にする\n                    Collections.replaceAll(serviceCounterList, ateGroupNumber, -1);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            if (firstCountNumber == -1) {\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCounterList.set(firstCountNumber + i, firstWaitGroupNumber);\n            }\n            // 入力値のグループ番号の時、着席時間と待ち時間を設定\n            if (inputNumber == firstWaitGroupNumber) {\n                // 待ち時間を設定\n                waitTime = currentTime - arrivalTimeList.get(firstWaitGroupNumber);\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号<br>\n     * 座れる席がない場合は-1を返す。\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n        int emptyCount = 0;\n        for (int startPoint = 0; startPoint < serviceCounterList.size(); startPoint++) {\n            if (serviceCounterList.get(startPoint) == -1) {\n                emptyCount = 1;\n                for (int endpoint = startPoint + 1; endpoint < serviceCounterList.size(); endpoint++) {\n                    // 空席ならカウント\n                    if (serviceCounterList.get(endpoint) == -1) {\n                        emptyCount++;\n                        // 連続空席がグループの人数以上か判定\n                        if (emptyCount >= groupNumberOfPeopleList.get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                    } else {\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n    /*\n     * private static void printCustomer() {\n     * System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\"); System.out.print(\"\");\n     * System.out.println(\"\"); for (int i = 0; i < arrivalTimeList.size(); i++)\n     * { System.out.print(i + \"\\t\\t\"); System.out.print(arrivalTimeList.get(i) +\n     * \"\\t\\t\"); System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n     * System.out.println(eatTimeList.get(i)); } }\n     * \n     * private static void printQuere() { System.out.print(\"キュー＝\"); for\n     * (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n     * System.out.print(it.next()); } System.out.println(\"\\n\"); }\n     * \n     * private static void printCounter() { System.out.print(currentTime +\n     * \"：[\"); for (int a : serviceCounterList) { System.out.print(a + \", \"); }\n     * System.out.println(\"]\"); }\n     */\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput < sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れる。\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main{\n\n\t/*** ??°??????????????° */\n\tprivate static final int GROUP_NUM = 100;\n\n\tprivate static BufferedReader br;\n\tprivate static int placeNum;\n\tprivate static int[] arriveTime, customerNum, mealTime, waitTime;\n\n\t/*** ??? */\n\tprivate static String[] places;\n\tprivate static int finalPlace;\n\n\t/*** ????????? */\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tplaceNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomerNum = new int[GROUP_NUM];\n\t\tmealTime = new int[GROUP_NUM];\n\t\twaitTime = new int[GROUP_NUM];\n\t\tplaces = new String[placeNum];\n\n\t}\n\n\t/**\n\t * ?????????????????????\n\t *\n\t * @param args\n\t *            ??????????????°\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\t// ??\\???\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\texe(inputList);\n\n\t\t// ??????\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTime[input]);\n\t\t}\n\n\t}\n\n\tprivate static void exe(List<Integer> inputList) {\n\t\t// ?????????\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tarriveTime[i] = 5 * i;\n\t\t\tcustomerNum[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tmealTime[i] = placeNum * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\n\t\tint key;\n\n\t\t// ????????¢?????????\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// ??\\?????¢?????????\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\t// ??°??????????????¨?????????????????????????????????????????????\n\t\tfor (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n\n\t\t\toutStore(currentTime);\n\n\t\t\t// ?????????????????°????????????\n\t\t\tif ((key = search(arriveTime, currentTime)) != -1) {\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\tif (isEmpty(key)) {\n\t\t\t\t\t\tset(Integer.toString(key));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitList.add(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitList.add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// ???????????¢???????????´???\n\t\t\t\tint i = 0;\n\t\t\t\tboolean flg = true;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\tif (isEmpty(wait) && flg) {\n\t\t\t\t\t\tset(Integer.toString(wait));\n\t\t\t\t\t\twaitTime[wait] = currentTime - arriveTime[wait];\n\t\t\t\t\t\tremoveList.add(i);\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\tCollections.reverse(removeList);\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// ??\\???????????¢???????????¢???????????????????????????\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int search(int[] targets, int currentTime) {\n\t\tint i = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??????????????£?????°?????????????????????????????????\n\t *\n\t */\n\tprivate static void outStore(int currentTime) {\n\t\tint i = 0;\n\t\tfor (String place : places) {\n\t\t\tif (place == null) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mealTime[Integer.parseInt(place)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(place)]) {\n\t\t\t\tplaces[i] = null;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\t/**\n\t * ??°?????????????????§???????¨??????????\n\t *\n\t * @param groupNum\n\t *            ??°???????????????\n\t */\n\tprivate static void set(String groupNum) {\n\n\t\tfor (int i = finalPlace - 1, count = 0; count < customerNum[Integer\n\t\t\t\t.parseInt(groupNum)]; i--, count++) {\n\t\t\tplaces[i] = groupNum;\n\t\t}\n\t}\n\n\t/**\n\t * ?????°?????°?????????????????°?????§?????????????????????????????????\n\t *\n\t * @param groupNum\n\t *            ??°?????????????????°\n\t * @return true : ??§?????? false : ??§?????????\n\t */\n\tprivate static boolean isEmpty(int groupNum) {\n\n\t\t// ????????°\n\t\tint emptyPlaceNum = 0;\n\n\t\tfor (int i = 0; i < placeNum; i++) {\n\t\t\tif (emptyPlaceNum == customerNum[groupNum]) {\n\t\t\t\tfinalPlace = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (places[i] == null) {\n\t\t\t\temptyPlaceNum++;\n\t\t\t} else {\n\t\t\t\temptyPlaceNum = 0;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    int sittingGroupNum = seat[s];\n                    if (sittingGroupNum == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                        //グループの人数分飛ばす\n                        s += (sittingGroupNum % 5 == 1 ? 5 : 2) - 1;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, min + timeToEatList[headGroupNo % timeToEatList.length]);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // ?????????????????£???????????????????´????????????????\n        List<String> waitingCustomersList = new ArrayList<String>();\n\n        List<String> list = new ArrayList<String>();\n\n        List<String> waitingStartTimeList = new ArrayList<String>();\n\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // ??\\???????????????null???????????????????????????????????????????????????\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // ?£????????????£?????¢??????????????£??????????????????\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // ?????£????????????????????§??£????????????\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n                waitingStartTimeList.remove(0);\n            }\n            // ??¢?????????\n            if (timeGoesBy % 5 == 0) {\n                // ??¢????????°???????????????\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // ???????????????????????????????????????????????????\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // ??¢???????????§?????????????????????????????§????????°???????????????\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // ??¢????????°???????????????\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ?£????????????£?????¢??????????????????\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package aoj;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 座席数 */\n\tprivate final static int SEATS = 17;\n\n\t/** 客グループ数 */\n\tprivate final static int GROUP = 100;\n\n\t/** 客グループの到着する間隔（分） */\n\tprivate final static int INTERVAL = 5;\n\n\t/** 客グループの待ち時間を格納する配列 */\n\tprivate static int[] watingTimes = new int[GROUP];\n\n\t/** 客グループの到着時刻、人数、食事時間を格納する二次元配列 */\n\tprivate static int[][] groupInfo = new int[GROUP][3];\n\n\t/** 客グループの到着時刻を表す添え字 */\n\tprivate final static int GROUP_INFO_ARRIVAL = 0;\n\n\t/** 客グループの人数を表す添え字 */\n\tprivate final static int GROUP_INFO_PERSONS = 1;\n\n\t/** 客グループの食事時間を表す添え字 */\n\tprivate final static int GROUP_INFO_EATING_MINUTES = 2;\n\n\t/** 座席の着席状況を格納する配列 */\n\tprivate static int[] seatsCondition = new int[SEATS];\n\n\t/** お店が開いているかどうか */\n\tprivate static boolean openFlag = true;\n\n\t/** 最後に到着したグループ */\n\tprivate static int lastArrivalGroup = -1;\n\n\t/** 待ちグループ数 */\n\tprivate static int watingGroups = 0;\n\n\t/** 正午からの経過時間（分） */\n\tprivate static int passedMinutes = 0;\n\n\t/**\n\t * 「福縞軒」に訪れる客グループの待ち時間を算出する。\n\t *\n\t * @param args\n\t *            利用しない。\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException,\n\t\t\tIOException {\n\n\t\t// 入力値の読み込み\n\t\tList<Integer> inputList = getInput();\n\n\t\t// 全客グループの到着時間と人数と食事時間を求める\n\t\tsetGroupInfo();\n\n\t\twhile (openFlag) {\n\n\t\t\t// 等間隔で次のグループが到着する\n\t\t\tif (passedMinutes % INTERVAL == 0) {\n\t\t\t\tlastArrivalGroup++;\n\t\t\t\twatingGroups++;\n\t\t\t}\n\n\t\t\t// 待ちグループがいなければ何もせずに時刻を進める\n\t\t\tif (watingGroups == 0) {\n\t\t\t\tpassedMinutes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 待ちグループが存在した場合\n\t\t\t// 待ちの先頭グループ番号を求める\n\t\t\tint nextGroup = lastArrivalGroup - watingGroups + 1;\n\n\t\t\t// 待ちグループがいて、空席が存在する場合　※最初の１回は必ず空席チェックする\n\t\t\tboolean vacancyFlag = true; // 空席が存在するかのフラグ\n\t\t\twhile (watingGroups != 0 && vacancyFlag) {\n\n\t\t\t\t// 待ちの先頭グループの人数を求める\n\t\t\t\tint numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS];\n\n\t\t\t\t// 退席時刻となった席を空席にし、先頭のグループが着席できる座席の番号を求める\n\t\t\t\tint seatNumber = getSeatNumber(numberOfPersons);\n\n\t\t\t\tif (seatNumber != -1) {\n\n\t\t\t\t\t// 着席できる座席があった場合、座席にグループの退席時刻を設定する\n\t\t\t\t\tfor (int i = 0; i < numberOfPersons; i++) {\n\t\t\t\t\t\tseatsCondition[seatNumber] = passedMinutes\n\t\t\t\t\t\t\t\t+ groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n\t\t\t\t\t\tseatNumber++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// グループの待ち時間を設定する\n\t\t\t\t\twatingTimes[nextGroup] = passedMinutes\n\t\t\t\t\t\t\t- groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n\t\t\t\t\t// 待ちグループ数を減らす\n\t\t\t\t\twatingGroups--;\n\t\t\t\t\tnextGroup = lastArrivalGroup - watingGroups + 1;\n\n\t\t\t\t\t// 最後のグループが座ったら、お店を閉店する\n\t\t\t\t\tif (nextGroup == GROUP) {\n\t\t\t\t\t\topenFlag = false;\n\t\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpassedMinutes++;\n\t\t}\n\n\t\t// 結果を出力する\n\t\tfor (int i : inputList) {\n\t\t\tSystem.out.println(watingTimes[i]);\n\t\t}\n\t}\n\n\t/**\n\t * 入力値（n番目のグループ）を取得する\n\t *\n\t * @return 入力値のリスト\n\t * @throws NumberFormatException\n\t * @throws IOException\n\t */\n\tprivate static List<Integer> getInput() throws NumberFormatException,\n\t\t\tIOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\tString line = null;\n\t\twhile ((line = br.readLine()) != null) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\treturn inputList;\n\t}\n\n\t/**\n\t * 客グループの到着時刻、人数、食事時間を計算し、配列にセットする\n\t */\n\tprivate static void setGroupInfo() {\n\n\t\tfor (int i = 0; i < GROUP; i++) {\n\t\t\tgroupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n\t\t\tgroupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n\t\t\tgroupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n\t\t\t\t\t* (i % 3) + 19;\n\t\t}\n\n\t}\n\n\t/**\n\t * 退席時刻となった席を空席にする。\n\t * 引数で受け取った人数が座れる席を探し、座席番号を返す。\n\t * 座席がない場合は-1を返す。\n\t *\n\t * @param numberOfPersons 人数\n\t * @return 座席番号\n\t */\n\tprivate static int getSeatNumber(int numberOfPersons) {\n\n\t\tint seatNumber = 0; // 先頭の座席番号\n\t\tint vacancySeats = 0; // 空席数\n\n\t\tfor (int i = 0; i < SEATS; i++) {\n\n\t\t\t// 退席時刻となった座席を空席に戻す\n\t\t\tif (seatsCondition[i] <= passedMinutes) {\n\t\t\t\tseatsCondition[i] = 0;\n\t\t\t}\n\n\t\t\tif (seatsCondition[i] == 0) {\n\n\t\t\t\t// 席が空席であれば、空席数を増やす\n\t\t\t\tvacancySeats++;\n\n\t\t\t\t// 空席数が待ち人数と等しければ、先頭の座席番号を返す\n\t\t\t\tif (vacancySeats == numberOfPersons) {\n\t\t\t\t\treturn seatNumber;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// 席が空席でなければ、座席番号を次に移し、空席数を0に戻す\n\t\t\t\tseatNumber = i + 1;\n\t\t\t\tvacancySeats = 0;\n\t\t\t}\n\t\t}\n\n\t\t// 空席がなければ-1を返す\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].eatTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Fukushimaken {\n\n    // ??£?????????????????????????????????\n    private int time = 0;\n\n    // ?????????????????????????????§????????°???????????°\n    private int groupCount = 0;\n\n    public static void main(String[] args) throws Exception {\n\tnew Fukushimaken().execute();\n    }\n\n    private void execute() throws Exception {\n\n\t// ?¨??????\\????????????????????????\n\tList<Integer> targetGroups = readInitialData();\n\n\t// ?????°(17???)\n\tEatingVisitor[] seats = new EatingVisitor[17];\n\n\t// ?????£?????????????????????\n\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t// ?????°?????????????????????????¨??????????\n\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t// ??????????????????????????????????????????????????°??????????????????\n\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t// ?????????????????§??°??????????????????????????£????????????\n\twhile (groupCount <= maxGroupNum) {\n\n\t    // ???????????´??°\n\t    waitingGroups.addAll(updateWaitLine());\n\n\t    // ??¢?????????\n\t    leaveSeat(seats);\n\n\t    // ????????????\n\t    waitTimes.addAll(sitDown(seats, waitingGroups));\n\n\t    time++;\n\t}\n\n\t// ????????????\n\tfor (int targetGroup : targetGroups) {\n\t    System.out.println(waitTimes.get(targetGroup));\n\t}\n    }\n\n    /**\n     * ??§??????????????????\n     * \n     * @param seats\n     *            ??????????????§???(17???)\n     * @param waitingGroups\n     *            ?????§?????£???????????°?????????\n     */\n    private List<Integer> sitDown(EatingVisitor[] seats, List<WaitingVisitor> waitingGroups) {\n\n\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\tint removeCount = 0;\n\tfor (WaitingVisitor waitingPerson : waitingGroups) {\n\n\t    int emptySeatCount = 0;\n\t    boolean isEmpty = false;\n\t    for (int i = 0; i < seats.length; i++) {\n\n\t\t// ????????°????????\\\n\t\tif (seats[i] == null) {\n\t\t    emptySeatCount++;\n\t\t} else {\n\t\t    emptySeatCount = 0;\n\t\t}\n\n\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t    // ????????§??£?????°???????????°?????´??°\n\t\t    groupCount++;\n\t\t    removeCount++;\n\t\t    isEmpty = true;\n\n\t\t    // ????±???°????????????????????????????¨????\n\t\t    waitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t    // ?£???????????????????????¨????\n\t\t    int endTime = 17 * (waitingPerson.getGroup() % 2) + 3 * (waitingPerson.getGroup() % 3) + 19;\n\n\t\t    for (int j = 0; j < emptySeatCount; j++) {\n\t\t\tseats[i - j] = new EatingVisitor(waitingPerson.getGroup(), endTime + time);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (!isEmpty) {\n\t\tbreak;\n\t    }\n\n\t}\n\n\t// ?£????????§?????????????????????????\n\tfor (int i = 0; i < removeCount; i++) {\n\t    waitingGroups.remove(0);\n\t}\n\n\treturn waitTimes;\n    }\n\n    /**\n     * ?£???????????????£???????????¢????????????\n     * \n     * @param seats\n     *            ??§???\n     */\n    private void leaveSeat(EatingVisitor[] seats) {\n\tfor (int i = 0; i < seats.length; i++) {\n\t    if (seats[i] != null && seats[i].getEndTime() == time) {\n\t\tseats[i] = null;\n\t    }\n\t}\n    }\n\n    /**\n     * ?????£????????????????????´??°\n     * \n     * @return ????????????\n     */\n    private List<WaitingVisitor> updateWaitLine() {\n\n\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\tint nowGroup = time / 5;\n\t// ??°?????????????????£??????????????????\n\tif (time % 5 == 0) {\n\t    // ??°?????????????????°?????????\n\t    int number = 2;\n\t    if (nowGroup % 5 == 1) {\n\t\tnumber = 5;\n\t    }\n\n\t    // ??????????????????????????????????§?????????????????¨????\n\t    waitingGroups.add(new WaitingVisitor(nowGroup, number, time));\n\t}\n\n\treturn waitingGroups;\n    }\n\n    /**\n     * ?¨??????\\????????????????????????\n     * \n     * @return ??????????????°?????????\n     */\n    private List<Integer> readInitialData() throws Exception {\n\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\tString line = null;\n\tList<Integer> groups = new ArrayList<Integer>();\n\twhile ((line = reader.readLine()) != null) {\n\t    groups.add(Integer.parseInt(line));\n\t}\n\n\treturn groups;\n    }\n\n    /**\n     * ???????????????????????§??°??????????????????????´¢\n     * \n     * @param targetGroups\n     *            ??????????±??????°?????????\n     * @return ??°???????????????\n     */\n    private int searchMaxGroupNum(List<Integer> targetGroups) {\n\tint maxGroupNum = 0;\n\tfor (int targetGroup : targetGroups) {\n\t    if (maxGroupNum < targetGroup) {\n\t\tmaxGroupNum = targetGroup;\n\t    }\n\t}\n\treturn maxGroupNum;\n    }\n\n}\n\n/**\n * ?????¢??????\n */\nabstract class Visitor {\n\n    // ????±???°?????????\n    private int group;\n\n    public int getGroup() {\n\treturn group;\n    }\n\n    public void setGroup(int group) {\n\tthis.group = group;\n    }\n\n}\n\n/**\n * ?????§?????£??????????????¢??????\n */\nclass WaitingVisitor extends Visitor {\n\n    public WaitingVisitor(int group, int number, int startTime) {\n\tsetGroup(group);\n\tsetNumber(number);\n\tsetStartTime(startTime);\n    }\n\n    // ???????§?????????????\n    private int startTime;\n\n    // ??°?????????????????°\n    private int number;\n\n    public int getStartTime() {\n\treturn startTime;\n    }\n\n    public void setStartTime(int startTime) {\n\tthis.startTime = startTime;\n    }\n\n    public int getNumber() {\n\treturn number;\n    }\n\n    public void setNumber(int number) {\n\tthis.number = number;\n    }\n}\n\n/**\n * ?£???????????????¢??????\n */\nclass EatingVisitor extends Visitor {\n\n    public EatingVisitor(int group, int endTime) {\n\tsetGroup(group);\n\tsetEndtTime(endTime);\n    }\n\n    // ?£???????????????????\n    private int endtTime;\n\n    public int getEndTime() {\n\treturn endtTime;\n    }\n\n    public void setEndtTime(int endtTime) {\n\tthis.endtTime = endtTime;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\twhile (sc.hasNextLine()) {\n\t    String query = null;\n\t    query = sc.nextLine();\n\t    if (\"???\".equals(query) || query == null) {\n\t\tSystem.exit(0);\n\t    }\n\n\t    System.out.println(waitingTime[Integer.parseInt(query)][1] - waitingTime[Integer.parseInt(query)][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\tfor (int now = 0; now / 5 < 100 || isAllSeatEmpty(storeSeat); now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now / 5 < 100 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 0147:Fukushimaken\n * \n * @author MS14A\n * @version 2015/05/09\n */\npublic class Main {\n\n    private static int[] seatWaitTime = new int[17];\n\n    /**\n     * メインメソッド\n     * \n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n\n        List<Integer> inputGroupNumbers = getGroupNumbers();\n\n        for (Integer inputGroupNumber : inputGroupNumbers) {\n            Arrays.fill(seatWaitTime, 0);\n\n            System.out.println(getWaitingTime(inputGroupNumber.intValue()));\n        }\n    }\n\n    private static int getWaitingTime(int inputGroupNumber) {\n\n        boolean canSit = false;\n        List<Integer> waitingGroups = new ArrayList<Integer>();\n        int groupNumber = 0;\n\n        int time = 0;\n        int waitingStartTime = 0;\n        int waitingEndTime = 0;\n\n        while (!canSit) {\n            // 食事時間を一分進める\n            for (int seatTime : seatWaitTime) {\n                if (seatTime > 0) {\n                    seatTime -= 1;\n                }\n            }\n\n            // グループが来る\n            if (time % 5 == 0) {\n                groupNumber = time / 5;\n                waitingGroups.add(Integer.valueOf(groupNumber));\n\n                if (groupNumber == inputGroupNumber) {\n                    waitingStartTime = time;\n                }\n            }\n\n            if (!waitingGroups.isEmpty()) {\n                // 座れる場合は待ちリストから削除していく\n                canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n\n                while (canSit) {\n                    if (waitingGroups.get(0) == inputGroupNumber) {\n                        waitingEndTime = time;\n                        break;\n                    }\n                    waitingGroups.remove(0);\n                    if (waitingGroups.isEmpty()) {\n                        canSit = false;\n                    } else {\n                        canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n                    }\n                }\n            }\n\n            ++time;\n        }\n\n        return waitingEndTime - waitingStartTime;\n    }\n\n    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {\n        int count = 0;\n        for (int i = 0; i < seatWaitTime.length; ++i) {\n            if (seatWaitTime[i] == 0) {\n                count += 1;\n                if (count == NumberOfGroupMember) {\n                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);\n                    return true;\n                }\n            } else {\n                count = 0;\n            }\n        }\n\n        return false;\n    }\n\n    private static int getNumberOfGuy(int groupNumber) {\n        if (groupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    private static int getEatingTime(int groupNumber) {\n        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;\n    }\n\n    private static List<Integer> getGroupNumbers() throws IOException {\n        // 入力読取り\n        InputStreamReader streamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(streamReader);\n\n        String line = null;\n        List<Integer> groupNumbers = new ArrayList<Integer>();\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                groupNumbers.add(Integer.parseInt(line));\n            }\n        } finally {\n            bufferedReader.close();\n            streamReader.close();\n        }\n\n        return groupNumbers;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Event implements Comparable<Event> {\n\n    static final int ARRIVE = 1;\n    static final int LEAVE = 0;\n\n    final int state;\n    final int id;\n    final int time;\n\n    public Event( final int state, final int id, final int time ) {\n\tthis.state = state;\n\tthis.id = id;\n\tthis.time = time;\n    }\n\n    @Override public int compareTo( Event event ) {\n\tif ( time != event.time ) {\n\t    return time - event.time;\t    \n\t} else {\n\t    return state - event.state;\n\t}\n    }\n\n    public String toString() {\n\tfinal String stateStr = ( state == ARRIVE ? \"ARRIVE\" : \"LEAVE\" );\n\treturn String.format( \"%s %d, time = %d\", stateStr, id, time );\n    }\n    \n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\tfinal int[] waitTime = new int[100];\n\tsimulate( waitTime );\n\t//System.err.println( Arrays.toString( waitTime ) );\n\n\twhile ( stdin.hasNextInt() ) {\n\t    final int n = stdin.nextInt();\n\t    System.out.println( waitTime[n] );\n\t}\t\n    }\n\n    static void simulate( final int[] waitTime ) {\n\t\n\tfinal PriorityQueue<Event> queue = new PriorityQueue<Event>();\n\tfinal LinkedList<Event> waitQueue = new LinkedList<Event>();\n\tfor ( int i = 0; i < 100; i++ ) {\n\t    queue.offer( new Event( Event.ARRIVE, i, i * 5 ) );\n\t}\n\n\tint time = 0;\n\n\tint[] seats = new int[17];\n\tArrays.fill( seats, -1 );\n\t\n\twhile ( !queue.isEmpty() ) {\n\t    //System.err.println( Arrays.toString( seats ) );\n\t    final Event e = queue.poll();\n\t    //System.err.println( e );\n\t    time = e.time;\n\t    if ( e.state == Event.ARRIVE ) {\n\t\tfinal int pos = canPut( seats, getNoOfPeople( e.id ) );\n\t\tif ( waitQueue.isEmpty() && pos >= 0 ) {\n\t\t    put( seats, e.id, pos );\n\t\t    queue.offer( new Event( Event.LEAVE, e.id, e.time + calcEatTime( e.id ) ) );\n\t\t} else {\n\t\t    //System.err.printf( \"wait... %s\\n\", e );\n\t\t    waitQueue.offer( e );\n\t\t}\n\t    } else { //if ( e.state == Event.LEAVE ) {\n\t\tremove( seats, e.id );\n\t\twhile ( !waitQueue.isEmpty() ) {\n\t\t    final Event ne = waitQueue.peek();\n\t\t    final int nPos = canPut( seats, getNoOfPeople( ne.id ) );\n\t\t    if ( nPos >= 0 ) {\n\t\t\twaitQueue.poll();\n\t\t\tput( seats, ne.id, nPos );\n\t\t\twaitTime[ne.id] = time - ne.time;\n\t\t\t//System.err.printf( \"in: %s\\n\", ne );\n\t\t\t//System.err.printf( \"waitTime = %d\\n\", waitTime[ne.id] );\n\t\t\tqueue.offer( new Event( Event.LEAVE, ne.id, ne.time + calcEatTime( ne.id ) ) );\n\t\t    } else {\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    static int calcEatTime( final int id ) {\n\treturn 17 * ( id % 2 ) + 3 * ( id % 3 ) + 19;\n    }\n\n    static void put( final int[] seats, final int id, final int pos ) {\n\tfinal int p = getNoOfPeople( id );\n\tfor ( int i = pos; i < pos + p; i++ ) {\n\t    seats[i] = id;\n\t}\n    }\n\n    static int getNoOfPeople( final int id ) {\n\treturn id % 5 == 1 ? 5 : 2;\n    }\n\n    static int canPut( final int[] seats, final int noOfPeople ) {\n\tint count = 0;\n\tfor ( int i = 0; i < seats.length; i++ ) {\n\t    if ( seats[i] == -1 ) {\n\t\tcount++;\n\t\tif ( count >= noOfPeople ) {\n\t\t    return i - count + 1;\n\t\t}\n\t    } else {\n\t\tcount = 0;\n\t    }\n\t}\n\treturn -1;\n    }\n\n    static void remove( final int[] seats, final int id ) {\n\tfor ( int i = 0; i < seats.length; i++ ) {\n\t    if ( seats[i] == id ) {\n\t\tfinal int noOfPeople = getNoOfPeople( id );\n\t\tfor ( int j = i; j < i + noOfPeople; j++ ) {\n\t\t    seats[j] = -1;\n\t\t}\n\t\treturn;\n\t    }\n\t}\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "package fukushimaken;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 0147:Fukushimaken\n * \n * @author MS14A\n * @version 2015/05/09\n */\npublic class Main {\n\n    /** 席での食事時間の残を格納する配列 */\n    private static int[] seatWaitTime = new int[17];\n\n    /**\n     * メインメソッド\n     * \n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n\n        // 標準入力読取り。\n        List<Integer> inputGroupNumbers = getGroupNumbers();\n\n        for (Integer inputGroupNumber : inputGroupNumbers) {\n            // 各席での食事時間を初期化\n            Arrays.fill(seatWaitTime, 0);\n\n            // 与えられたグループ番号の待ち時間を算出・表示\n            System.out.println(getWaitingTime(inputGroupNumber.intValue()));\n        }\n    }\n\n    /**\n     * 指定された番号のグループの待ち時間を計算し、返却する。\n     * \n     * @param inputGroupNumber 指定されたグループ番号\n     * @return 待ち時間\n     */\n    private static int getWaitingTime(int inputGroupNumber) {\n\n        List<Integer> waitingGroups = new ArrayList<Integer>(); // 席待ちのグループを格納するリスト\n        int groupNumber = 0; // グループ番号\n        boolean canSit = false; // 行列の先頭グループが着席可能ならtrue\n\n        int time = 0; // 経過時間\n        int waitingStartTime = 0; // 指定グループが並び始めた時間\n        int waitingEndTime = 0; // 指定グループが席に着いた時間\n\n        while (!canSit) {\n            // 食事時間を一分消化\n            for (int i = 0; i < seatWaitTime.length; i++) {\n                if (seatWaitTime[i] > 0) {\n                    seatWaitTime[i] -= 1;\n                }\n            }\n\n            // グループが来る\n            if (time % 5 == 0) {\n                groupNumber = time / 5;\n                waitingGroups.add(Integer.valueOf(groupNumber));\n\n                // 店に来たグループが指定グループなら、待ち時間のカウント開始\n                if (groupNumber == inputGroupNumber) {\n                    waitingStartTime = time;\n                }\n            }\n\n            if (!waitingGroups.isEmpty()) {\n                // 座れる場合は待ちリストから削除していく\n                canSit = sit(getNumberOfGroupMember(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n\n                while (canSit) {\n                    // 席に着いたグループが指定グループの場合、待ち時間をカウントしループ終了\n                    if (waitingGroups.get(0) == inputGroupNumber) {\n                        waitingEndTime = time;\n                        break;\n                    }\n                    \n                    // 席に着いたグループを待ちグループのリストから削除\n                    waitingGroups.remove(0);\n                    if (waitingGroups.isEmpty()) {\n                        canSit = false;\n                    } else {\n                        // 次の待ちグループがいた場合、席に着けるか確認\n                        canSit = sit(getNumberOfGroupMember(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n                    }\n                }\n            }\n\n            ++time;\n        }\n\n        return waitingEndTime - waitingStartTime;\n    }\n\n    /**\n     * グループを席に着かせる<br>\n     * <br>\n     * 【説明】<br>\n     *  グループの人数分だけ連続した空席があるか確認し、空席が存在すれば<br>\n     *  グループの食事時間を配列に格納する。\n     * \n     * @param NumberOfGroupMember グループの人数\n     * @param eatingTimeOfGroup グループの食事時間\n     * @return グループの人数分空席があればtrue、空席がなければfalse\n     */\n    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {\n        int count = 0;\n        for (int i = 0; i < seatWaitTime.length; ++i) {\n            if (seatWaitTime[i] == 0) {\n                count += 1;\n                \n                // 空席が人数分連続していれば、人数分の食事時間を配列に格納(＝席に着かせる)\n                if (count == NumberOfGroupMember) {\n                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);\n                    return true;\n                }\n            } else {\n                count = 0;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * グループの人数を求める。\n     * \n     * @param groupNumber グループ番号\n     * @return グループの人数\n     */\n    private static int getNumberOfGroupMember(int groupNumber) {\n        if (groupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * グループの食事時間を求める。\n     * \n     * @param groupNumber グループ番号\n     * @return グループの食事時間\n     */\n    private static int getEatingTime(int groupNumber) {\n        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;\n    }\n\n    /**\n     * 標準入力から待ち時間を計算するグループ番号を読取り、リストで返却する。\n     * \n     * @return グループ番号のリスト\n     * @throws IOException\n     */\n    private static List<Integer> getGroupNumbers() throws IOException {\n        // 入力読取り\n        InputStreamReader streamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(streamReader);\n\n        String line = null;\n        List<Integer> groupNumbers = new ArrayList<Integer>();\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                groupNumbers.add(Integer.parseInt(line));\n            }\n            return groupNumbers;\n            \n        } finally {\n            bufferedReader.close();\n            streamReader.close();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        int customerCount = 0;\n        List<Integer> waitTime = new ArrayList<Integer>(100);\n\n        while (customerCount < 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                    customerCount++;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            for (int i = 0; i < queueStatusList.size(); i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                int groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                int blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList, baseTime, blankStartSeatNo, n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.poll();\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>();\n\n        for (int i = 0; i < seatNo; i++) {\n\n            GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        GroupStatus seatStatus = new GroupStatus();\n\n        for (int i = 0; i < 17; ++i) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatus = seatStatusMap.get(i);\n                seatStatus.endStayTime = time;\n\n                if ((seatStatus.endStayTime - seatStatus.startStayTime) == getMealTime(seatStatus.groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.remove(i);\n                    seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n                    seatStatusMap.put((Integer) i, seatStatus);\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap,\n            LinkedList<GroupStatus> queueStatusList, int baseTime, int blankStartSeatNo, int n) {\n\n        GroupStatus queueStatus = queueStatusList.peek();\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<>();\n        arrivalTimeList = new ArrayList<>();\n        eatTimeList = new ArrayList<>();\n        sitTimeList = new ArrayList<>();\n        waitTimeList = new ArrayList<>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            try {\n                inputNumber = Integer.valueOf(br.readLine());\n            } catch (IOException e) {\n                System.out.println(\"inputError\" + e.getMessage());\n            }\n            if (inputNumber == null) {\n                break;\n            }\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    private static void printCustomer() {\n        System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\");\n        System.out.print(\"\");\n        System.out.println(\"\");\n        for (int i = 0; i < arrivalTimeList.size(); i++) {\n            System.out.print(i + \"\\t\\t\");\n            System.out.print(arrivalTimeList.get(i) + \"\\t\\t\");\n            System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n            System.out.println(eatTimeList.get(i));\n        }\n    }\n\n    private static void printQuere() {\n        System.out.print(\"キュー＝\");\n        for (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n            System.out.print(it.next());\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void printCounter() {\n        System.out.print(currentTime + \"：[\");\n        for (int a : serviceCouters) {\n            System.out.print(a + \", \");\n        }\n        System.out.println(\"]\");\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n        int groupMember = 0; // 入店したグループ人数\n        int blankStartSeatNo = -1; // 空席No\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            for (int i = 0; i < queueStatusList.size(); i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList, baseTime, blankStartSeatNo, n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.poll();\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(seatNo);\n        GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n\n        for (int i = 0; i < seatNo; i++) {\n\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        GroupStatus seatStatus = new GroupStatus();\n\n        for (int i = 0; i < 17; ++i) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatus = seatStatusMap.get(i);\n                seatStatus.endStayTime = time;\n\n                if ((seatStatus.endStayTime - seatStatus.startStayTime) == getMealTime(seatStatus.groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.remove(i);\n                    seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n                    seatStatusMap.put((Integer) i, seatStatus);\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap,\n            LinkedList<GroupStatus> queueStatusList, int baseTime, int blankStartSeatNo, int n) {\n\n        GroupStatus queueStatus = queueStatusList.peek();\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput < sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            boolean firstCustomer = false;\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れるか確認。\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                if (firstCustomer) {\n                    continue;\n                }\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "package aoj;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    /** 座席数 */\n    private final static int SEATS = 17;\n\n    /** 客グループ数 */\n    private final static int GROUP = 100;\n\n    /** 客グループの到着する間隔（分） */\n    private final static int INTERVAL = 5;\n\n    /** 客グループの待ち時間を格納する配列 */\n    private static int[] watingTimes = new int[GROUP];\n\n    /** 客グループの到着時刻、人数、食事時間を格納する二次元配列 */\n    private static int[][] groupInfo = new int[GROUP][3];\n\n    /** 客グループの到着時刻を表す添え字 */\n    private final static int GROUP_INFO_ARRIVAL = 0;\n\n    /** 客グループの人数を表す添え字 */\n    private final static int GROUP_INFO_PERSONS = 1;\n\n    /** 客グループの食事時間を表す添え字 */\n    private final static int GROUP_INFO_EATING_MINUTES = 2;\n\n    /** 座席の着席状況を格納する配列 */\n    private static int[] seatsCondition = new int[SEATS];\n\n    /** お店が開いているかどうか */\n    private static boolean openFlag = true;\n\n    /** 最後に到着したグループ */\n    private static int lastArrivalGroup = -1;\n\n    /** 待ちグループ数 */\n    private static int watingGroups = 0;\n\n    /** 正午からの経過時間（分） */\n    private static int passedMinutes = 0;\n\n    /**\n     * 「福縞軒」に訪れる客グループの待ち時間を算出する。\n     *\n     * @param args\n     *            利用しない。\n     * @throws IOException\n     * @throws NumberFormatException\n     */\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n\n        // 入力値の読み込み\n        List<Integer> inputList = getInput();\n\n        // 全客グループの到着時間と人数と食事時間を求める\n        setGroupInfo();\n\n        while (openFlag) {\n\n            // 等間隔で次のグループが到着する\n            if (passedMinutes % INTERVAL == 0) {\n                lastArrivalGroup++;\n                watingGroups++;\n            }\n\n            // 待ちグループがいなければ何もせずに時刻を進める\n            if (watingGroups == 0) {\n                passedMinutes++;\n                continue;\n            }\n\n            // 待ちグループが存在した場合\n            // 待ちの先頭グループ番号を求める\n            int nextGroup = lastArrivalGroup - watingGroups + 1;\n\n            // 待ちグループがいて、空席が存在する場合　※最初の１回は必ず空席チェックする\n            boolean vacancyFlag = true; // 空席が存在するかのフラグ\n            while (watingGroups != 0 && vacancyFlag) {\n\n                // 待ちの先頭グループの人数を求める\n                int numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS];\n\n                // 退席時刻となった席を空席にし、先頭のグループが着席できる座席の番号を求める\n                int seatNumber = getSeatNumber(numberOfPersons);\n\n                if (seatNumber != -1) {\n\n                    // 着席できる座席があった場合、座席にグループの退席時刻を設定する\n                    for (int i = 0; i < numberOfPersons; i++) {\n                        seatsCondition[seatNumber] = passedMinutes\n                                + groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n                        seatNumber++;\n                    }\n\n                    // グループの待ち時間を設定する\n                    watingTimes[nextGroup] = passedMinutes\n                            - groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n                    // 待ちグループ数を減らす\n                    watingGroups--;\n                    nextGroup = lastArrivalGroup - watingGroups + 1;\n\n                    // 最後のグループが座ったら、お店を閉店する\n                    if (nextGroup == GROUP) {\n                        openFlag = false;\n                        vacancyFlag = false;\n                    }\n                } else {\n                    vacancyFlag = false;\n                }\n            }\n\n            passedMinutes++;\n        }\n\n        // 結果を出力する\n        for (int i : inputList) {\n            System.out.println(watingTimes[i]);\n        }\n    }\n\n    /**\n     * 入力値（n番目のグループ）を取得する\n     *\n     * @return 入力値のリスト\n     * @throws NumberFormatException\n     * @throws IOException\n     */\n    private static List<Integer> getInput() throws NumberFormatException,\n            IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        String line = null;\n        while ((line = br.readLine()) != null) {\n            inputList.add(Integer.parseInt(line));\n        }\n\n        return inputList;\n    }\n\n    /**\n     * 客グループの到着時刻、人数、食事時間を計算し、配列にセットする\n     */\n    private static void setGroupInfo() {\n\n        for (int i = 0; i < GROUP; i++) {\n            groupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n            groupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n            groupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n                    * (i % 3) + 19;\n        }\n\n    }\n\n    /**\n     * 退席時刻となった席を空席にする。 引数で受け取った人数が座れる席を探し、座席番号を返す。 座席がない場合は-1を返す。\n     *\n     * @param numberOfPersons\n     *            人数\n     * @return 座席番号\n     */\n    private static int getSeatNumber(int numberOfPersons) {\n\n        int seatNumber = 0; // 先頭の座席番号\n        int vacancySeats = 0; // 空席数\n\n        for (int i = 0; i < SEATS; i++) {\n\n            // 退席時刻となった座席を空席に戻す\n            if (seatsCondition[i] <= passedMinutes) {\n                seatsCondition[i] = 0;\n            }\n\n            if (seatsCondition[i] == 0) {\n\n                // 席が空席であれば、空席数を増やす\n                vacancySeats++;\n\n                // 空席数が待ち人数と等しければ、先頭の座席番号を返す\n                if (vacancySeats == numberOfPersons) {\n                    return seatNumber;\n                }\n            } else {\n\n                // 席が空席でなければ、座席番号を次に移し、空席数を0に戻す\n                seatNumber = i + 1;\n                vacancySeats = 0;\n            }\n        }\n\n        // 空席がなければ-1を返す\n        return -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n        int groupMember = 0; // 入店したグループ人数\n        int blankStartSeatNo = -1; // 空席No\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            int waitGroupSize = queueStatusList.size();\n\n            for (int i = 0; i < waitGroupSize; i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList, baseTime, blankStartSeatNo, n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.poll();\n\n                } else {\n\n                    // 座れる座席なし\n                    break;\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(seatNo);\n\n        for (int i = 0; i < seatNo; i++) {\n            GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        GroupStatus seatStatus = new GroupStatus();\n\n        for (int i = 0; i < 17; ++i) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatus = seatStatusMap.get(i);\n                seatStatus.endStayTime = time;\n\n                if ((seatStatus.endStayTime - seatStatus.startStayTime) == getMealTime(seatStatus.groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.remove(i);\n                    seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n                    seatStatusMap.put((Integer) i, seatStatus);\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap,\n            LinkedList<GroupStatus> queueStatusList, int baseTime, int blankStartSeatNo, int n) {\n\n        GroupStatus queueStatus = queueStatusList.peek();\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // 店内の座席を作成する。0が空席,1行目が席、2行目が着席時刻、3行目が食事時間\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // 空席がなかった人たちを格納するリスト\n        List<String> waitingCustomersList = new ArrayList<String>();\n        //最終的に出力する値\n        List<String> list = new ArrayList<String>();\n        //待ち行列\n        List<String> waitingStartTimeList = new ArrayList<String>();\n        //出力されるグループ\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // 入力データがnullもしくは空文字の時、ループを抜ける\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // 食べ終わった客に出て行ってもらいたい\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // 待ってる人たちに座ってもらう\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    //各グループの待ち時間を計算し、リストに格納する\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n            //席についた客と時間をリストから削除する\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n                waitingStartTimeList.remove(0);\n            }\n            // 客がくる\n            if (timeGoesBy % 5 == 0 || timeGoesBy == 0) {\n                // 客の人数を取得する\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // 空席があるか判定し、あれば着席させる、なければ待ち行列に追加する\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // 指定された番号の待ち時間を取得する\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // 客が着席できるか判定し、可能であれば着席させる\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    //着席可能か判断する\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // 客の人数を判定する\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // 食べ終わった客を退席させる\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n                seats[count][1] = 0;\n                seats[count][2] = 0;\n\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Calendar;\n\npublic class Main {\n\n    private static final int NOT_SIT = 100;\n\n    private static int[] SHEETS = new int[17];\n\n    public static void main(String[] args) {\n\n    }\n\n    /**\n     * index番目のグループの到着時刻を返却する（正午からの経過時間）\n     * 単位：分\n     * @param index\n     * @return 到着時刻\n     */\n    private static Calendar getArriveTime(int index) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(2015, 4, 11, 12, 0, 0);\n        calendar.add(Calendar.MINUTE, index * 5);\n        return calendar;\n    }\n\n    /**\n     * index番目のグループの人数を返却する\n     * 単位：人\n     * @param index\n     * @return 人数\n     */\n    private static int getNums(int index) {\n        return((index % 5 == 1) ? 5 : 2);\n    }\n\n    /**\n     * index番目のグループの所要時間を返却する\n     * 単位：分\n     * @param index\n     * @return 所要時間\n     */\n    private static int getEatingTime(int index) {\n        return 17 * (index % 2) + 3 * (index % 3) + 19;\n    }\n\n    /**\n     *\n     * @param sheets\n     * @param index\n     * @param customers\n     * @return\n     */\n    private static boolean checkSheet(int index, int customers) {\n\n        boolean canSit = true;\n\n        for (int i = 0; i < SHEETS.length; i++) { // 椅子\n            for (int j = i; j < customers; j++) { // 客人数\n\n                if (j + customers <= SHEETS.length) { // 客が着席する始点から終点が、椅子総数を超えていない場合\n\n                    if (SHEETS[j] != NOT_SIT) { // 着席済みの場合\n                        canSit = false;\n                        break;\n                    }\n                }\n                i++;\n            }\n            if (canSit) {\n                for (int j = i; j < customers; j++) {\n                    SHEETS[j] = index;\n                }\n            }\n        }\n\n        return canSit;\n    }\n\n    /**\n     * 座席の初期化（初期値：100（空席））\n     */\n    private static void initSheets() {\n\n        for (int i = 0; i < SHEETS.length; i++) {\n            SHEETS[i] = 100;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n\n        // 対象のグループ番号：待ち時間の形で保持\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> targetCustomer = new HashMap<Integer, Integer>();\n        List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n        while (sc.hasNext()) {\n            targetCustomerGroupNumbers.add(sc.nextInt());\n        }\n\n        // 椅子 客が出るまでの分数を保持する\n        int[] chairs = new int[17];\n        // 待ち行列 客グループ数を保持する\n        Deque<Integer> que = new LinkedList<Integer>();\n        // これまでに来た最大のグループ番号\n        int cameGroup = 0;\n        // これまでに座ったグループの「数」\n        int sitGroupCount = 0;\n        // 経過時間\n        int pastMinutes = 0;\n\n        while (sitGroupCount < 100) {\n            // 食べる\n            eat(chairs);\n\n            // 客が来る\n            boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n            // 座る\n            sitGroupCount += sit(chairs, que, sitGroupCount);\n\n            // 後処理\n            for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                    // まだ座れていない\n                    continue;\n                }\n\n                if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                    // もうすでに座っていた\n                    continue;\n                } else {\n                    // この時間で初めて座れた\n                    int waitMinutes = pastMinutes\n                            - (5 * targetCustomerGroupNumber);\n                    targetCustomer.put(targetCustomerGroupNumber, waitMinutes);\n                }\n            }\n\n            if (customerHasCome) {\n                cameGroup++;\n            }\n            pastMinutes++;\n        }\n\n        for (Entry<Integer, Integer> entry : targetCustomer.entrySet()) {\n            System.out.println(entry.getValue());\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int sitGroupNumber) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (sitGroupNumber % 2))\n                    + (3 * (sitGroupNumber % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, (sitGroupNumber + 1));\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    /** 座席数 */\n    private final static int SEATS = 17;\n\n    /** 客グループ数 */\n    private final static int GROUP = 100;\n\n    /** 客グループの到着する間隔（分） */\n    private final static int INTERVAL = 5;\n\n    /** 客グループの待ち時間を格納する配列 */\n    private static int[] watingTimes = new int[GROUP];\n\n    /** 客グループの到着時刻、人数、食事時間を格納する二次元配列 */\n    private static int[][] groupInfo = new int[GROUP][3];\n\n    /** 客グループの到着時刻を表す添え字 */\n    private final static int GROUP_INFO_ARRIVAL = 0;\n\n    /** 客グループの人数を表す添え字 */\n    private final static int GROUP_INFO_PERSONS = 1;\n\n    /** 客グループの食事時間を表す添え字 */\n    private final static int GROUP_INFO_EATING_MINUTES = 2;\n\n    /** 座席の着席状況を格納する配列 */\n    private static int[] seatsCondition = new int[SEATS];\n\n    /** お店が開いているかどうか */\n    private static boolean openFlag = true;\n\n    /** 最後に到着したグループ */\n    private static int lastArrivalGroup = -1;\n\n    /** 待ちグループ数 */\n    private static int watingGroups = 0;\n\n    /** 正午からの経過時間（分） */\n    private static int passedMinutes = 0;\n\n    /**\n     * <p>\n     * 「福縞軒」に訪れる客グループの待ち時間を算出する。\n     * </p>\n     *\n     * @param args\n     *            利用しない。\n     * @throws IOException\n     * @throws NumberFormatException\n     */\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n\n        // 入力値の読み込み\n        List<Integer> inputList = getInput();\n\n        // 全客グループの到着時間と人数と食事時間を求める\n        setGroupInfo();\n\n        while (openFlag) {\n\n            // 等間隔で次のグループが到着する\n            if (passedMinutes % INTERVAL == 0) {\n                lastArrivalGroup++;\n                watingGroups++;\n            }\n\n            // 待ちグループがいなければ何もせずに時刻を進める\n            if (watingGroups == 0) {\n                passedMinutes++;\n                continue;\n            }\n\n            // 待ちグループが存在した場合\n            // 待ちの先頭グループ番号を求める\n            int nextGroup = lastArrivalGroup - watingGroups + 1;\n\n            // 待ちグループがいて、空席が存在する場合　※最初の１回は必ず空席チェックする\n            boolean vacancyFlag = true; // 空席が存在するかのフラグ\n            while (watingGroups != 0 && vacancyFlag) {\n\n                // 待ちの先頭グループの人数を求める\n                int numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS];\n\n                // 退席時刻となった席を空席にし、先頭のグループが着席できる座席の番号を求める\n                int seatNumber = getSeatNumber(numberOfPersons);\n\n                if (seatNumber != -1) {\n\n                    // 着席できる座席があった場合、座席にグループの退席時刻を設定する\n                    for (int i = 0; i < numberOfPersons; i++) {\n                        seatsCondition[seatNumber] = passedMinutes\n                                + groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n                        seatNumber++;\n                    }\n\n                    // グループの待ち時間を設定する\n                    watingTimes[nextGroup] = passedMinutes\n                            - groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n                    // 待ちグループ数を減らす\n                    watingGroups--;\n                    nextGroup = lastArrivalGroup - watingGroups + 1;\n\n                    // 最後のグループが座ったら、お店を閉店する\n                    if (nextGroup == GROUP) {\n                        openFlag = false;\n                        vacancyFlag = false;\n                    }\n                } else {\n                    vacancyFlag = false;\n                }\n            }\n\n            passedMinutes++;\n        }\n\n        // 結果を出力する\n        for (int i : inputList) {\n            System.out.println(watingTimes[i]);\n        }\n    }\n\n    /**\n     * <p>\n     * 入力値（n番目のグループ）を取得する\n     * </p>\n     *\n     * @return 入力値のリスト\n     * @throws NumberFormatException\n     * @throws IOException\n     */\n    private static List<Integer> getInput() throws NumberFormatException,\n            IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        String line = null;\n        while ((line = br.readLine()) != null) {\n            inputList.add(Integer.parseInt(line));\n        }\n\n        return inputList;\n    }\n\n    /**\n     * <p>\n     * 客グループの到着時刻、人数、食事時間を計算し、配列にセットする\n     * </p>\n     */\n    private static void setGroupInfo() {\n\n        for (int i = 0; i < GROUP; i++) {\n            groupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n            groupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n            groupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n                    * (i % 3) + 19;\n        }\n\n    }\n\n    /**\n     * <p>\n     * 退席時刻となった席を空席にする。<br/>\n     * 引数で受け取った人数が座れる席を探し、座席番号を返す。<br/>\n     * 座席がない場合は-1を返す。\n     * </p>\n     *\n     * @param numberOfPersons\n     *            人数\n     * @return 座席番号\n     */\n    private static int getSeatNumber(int numberOfPersons) {\n\n        int seatNumber = 0; // 先頭の座席番号\n        int vacancySeats = 0; // 空席数\n\n        for (int i = 0; i < SEATS; i++) {\n\n            // 退席時刻となった座席を空席に戻す\n            if (seatsCondition[i] <= passedMinutes) {\n                seatsCondition[i] = 0;\n            }\n\n            if (seatsCondition[i] == 0) {\n\n                // 席が空席であれば、空席数を増やす\n                vacancySeats++;\n\n                // 空席数が待ち人数と等しければ、先頭の座席番号を返す\n                if (vacancySeats == numberOfPersons) {\n                    return seatNumber;\n                }\n            } else {\n\n                // 席が空席でなければ、座席番号を次に移し、空席数を0に戻す\n                seatNumber = i + 1;\n                vacancySeats = 0;\n            }\n        }\n\n        // 空席がなければ-1を返す\n        return -1;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\t/** ??°???????????° */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/** ??§????????? */\n\tstatic int[] sheets = new int[17];\n\n\t/** ?????????????????? */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** ???????????? */\n\tstatic Map<Integer, Integer> waitLine = new LinkedHashMap<Integer, Integer>();\n\n\t/** ??????????±? */\n\tstatic Set<Integer> deleteTarget = new HashSet<Integer>();\n\n\t/** ??????????????? */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** ?????§??°??????????????? */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// ?????¨?????°???????????°\n\t\tint groupNumber = 0;\n\n\t\t// ??????????????????????????????\n\t\tint time = 0;\n\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\twhile (groupNumber < MAX_GROUP_NUKMBER) {\n\t\t\tif (time % 5 == 0) {\n\t\t\t\t// ??°????????¢\n\t\t\t\t// i???????????°?????????????????°??? i%5 ??? 1 ?????¨???5??????????????\\????????¨??????2???\n\t\t\t\twaitLine.put(groupNumber, (groupNumber % 5 == 1 ? 5 : 2));\n\t\t\t\twaitTimes[groupNumber] = time;\n\n\t\t\t\t// ?????§??°???????????????????????°????????????????????§?????????????????????????????§??°????????????????????????????????°??????????????????\n\t\t\t\tif (maxGroupNumber < groupNumber\n\t\t\t\t\t\t&& !waitLine.containsKey(maxGroupNumber)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgroupNumber++;\n\t\t\t}\n\n\t\t\t// ??¢????????¢\n\t\t\tfor (Map.Entry<Integer, Integer> entry : waitLine.entrySet()) {\n\t\t\t\t// ?????????->entry.getValue(); ->?????°\n\t\t\t\tint startPos = getOpendSheetsPosition(entry.getValue());\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// ??§????????´???\n\t\t\t\t\t// ??§???????????????????¢???? -> ?£??????????????¨????->entry.getKey()\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(entry.getValue()),\n\t\t\t\t\t\t\tentry.getValue());\n\n\t\t\t\t\t// ????????????????????????\n\t\t\t\t\tdeleteTarget.add(entry.getKey());\n\t\t\t\t\twaitTimes[entry.getKey()] = time - waitTimes[entry.getKey()] - 1 < 0 ? 0 : time\n\t\t\t\t\t\t\t- waitTimes[entry.getKey()] - 1;\n\t\t\t\t} else {\n\t\t\t\t\t// ??§???????????´???\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ??????????????????????????????\n\t\t\tfor (int target : deleteTarget) {\n\t\t\t\twaitLine.remove(target);\n\t\t\t}\n\n\t\t\t// ??§??????????????????????????????????????????\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * ????????????????????????????????????????????´????????? ??????????????????????????´??????-1????????´?????????\n\t *\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t * @return ????????????????????????????????????\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??°?????????????????????????£??????????????¨??????????\n\t *\n\t * @param targetGroup\n\t *            ????±??????°???????????????\n\t * @return ?£??????????\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * ???????¢?????????????\n\t *\n\t * @param startPos\n\t *            ????¢?????????????????????????\n\t * @param mealtime\n\t *            ?£??????????\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\twhile (sc.hasNextLine()) {\n\t    String query = null;\n\t    query = sc.nextLine();\n\t    if (\"???\".equals(query) || query == null) {\n\t\tSystem.exit(0);\n\t    }\n\n\t    System.out.println(waitingTime[Integer.parseInt(query)][1] - waitingTime[Integer.parseInt(query)][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\topenStore: for (int now = 0;; now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now < 500 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    empty = 0;\n\t\t\t    int groupId = waitingGroups.get(0);\n\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\n\t\t\t    // ???????????§??¢?????§??£??????????????????\n\t\t\t    if (groupId == 99) {\n\t\t\t\tbreak openStore;\n\t\t\t    }\n\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/** 対象外 */\n\tprivate static final int EXEMPT = -1;\n\n\t/** グループ数 */\n\tprivate static final int GROUP_NUM = 100;\n\n\t/** 標準入力 */\n\tprivate static BufferedReader br;\n\n\t/** 座席数 最後の座席番号 */\n\tprivate static int seatsNum, firstSeatNum;\n\n\t/** 到着時間 客数 食事時間 待ち時間 */\n\tprivate static int[] arriveTime, customersNum, mealTimes, waitTimes;\n\n\t/** 座席 */\n\tprivate static String[] seats;\n\n\t/** 初期化 */\n\tstatic {\n\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tseatsNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomersNum = new int[GROUP_NUM];\n\t\tmealTimes = new int[GROUP_NUM];\n\t\twaitTimes = new int[GROUP_NUM];\n\t\tseats = new String[seatsNum];\n\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\t// グループ数分繰り返す\n\n\t\t\t// 到着時間\n\t\t\tarriveTime[i] = 5 * i;\n\n\t\t\t// 人数\n\t\t\tcustomersNum[i] = i % 5 == 1 ? 5 : 2;\n\n\t\t\t// 食事時間\n\t\t\tmealTimes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n\t\t}\n\n\t\t// 待ち時間を作成\n\t\tcreateWaitTimes();\n\n\t}\n\n\t/** 待ち時間を作成する */\n\tprivate static void createWaitTimes() {\n\t\t// 順番\n\t\tint order;\n\n\t\t// 行列リスト\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// 行列排除リスト\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\tfor (int currentTime = 0, groupOrder = 0; groupOrder < GROUP_NUM; currentTime++) {\n\t\t\t// 行列が終了するまで、一分毎に繰り返す\n\n\t\t\t// 食事の時間が終了した客を離席させる\n\t\t\toutCustomer(currentTime);\n\n\t\t\tif ((order = arrivedCustomer(arriveTime, currentTime)) != EXEMPT) {\n\t\t\t\t// 到着時間の場合\n\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\t// 行列がない場合\n\n\t\t\t\t\tif (isEmpty(order)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(order));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\t\twaitList.add(order);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// 行列がある場合\n\n\t\t\t\t\t// 行列に並ばせる\n\t\t\t\t\twaitList.add(order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// 行列がある場合\n\n\t\t\t\t// 行列番号\n\t\t\t\tint i = 0;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\t// 行列リスト分、繰り返す\n\n\t\t\t\t\tif (isEmpty(wait)) {\n\t\t\t\t\t\t// 着席可能の場合\n\n\t\t\t\t\t\t// 座席に着席させる\n\t\t\t\t\t\tsetSeat(Integer.toString(wait));\n\n\t\t\t\t\t\tgroupOrder++;\n\n\t\t\t\t\t\t// 待った時間を設定する\n\t\t\t\t\t\twaitTimes[wait] = currentTime - arriveTime[wait];\n\n\t\t\t\t\t\t// 着席したグループを行列排除リストに追加する\n\t\t\t\t\t\tremoveList.add(i);\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 着席不可の場合\n\n\t\t\t\t\t\t// 行列の先頭が着席できないため、残りの行列も着席不可にする。\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\t// 行列排除リストに着席したグループが追加されていた場合\n\n\t\t\t\t// リストの降順でソートする（リムーブするため）\n\t\t\t\tCollections.reverse(removeList);\n\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// 行列排除リスト分、繰り返す\n\n\t\t\t\t\t// 行列リストから行列排除リストの番号を削除する\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\n\t\t\t\t// 初期化\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t\t/*\n\t\t\tif (currentTime < 10)\n\t\t\t\tSystem.out.print(currentTime + \" : \");\n\t\t\telse\n\t\t\t\tSystem.out.print(currentTime + \": \");\n\t\t\tfor (String seat : seats) {\n\t\t\t\tif (seat == null)\n\t\t\t\t\tSystem.out.print(seat + \" ,\");\n\t\t\t\telse if (Integer.parseInt(seat) < 10)\n\t\t\t\t\tSystem.out.print(seat + \"    ,\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.print(seat + \"   ,\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t}\n\t}\n\n\t/** メイン */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\n\t}\n\n\t/** 現在時間に到着するグループ番号を検索し返す */\n\tprivate static int arrivedCustomer(int[] targets, int currentTime) {\n\t\tint order = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn order;\n\t\t\t}\n\t\t\torder++;\n\t\t}\n\t\treturn EXEMPT;\n\t}\n\n\t/** 離席させる */\n\tprivate static void outCustomer(int currentTime) {\n\n\t\t// 席番\n\t\tint seatNum = 0;\n\n\t\tfor (String seat : seats) {\n\t\t\t// 座席数分繰り返す\n\n\t\t\tif (seat == null) {\n\t\t\t\t// 空席の場合\n\t\t\t\tseatNum++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (currentTime - (arriveTime[Integer.parseInt(seat)]\n\t\t\t\t\t+ waitTimes[Integer.parseInt(seat)]) >= mealTimes[Integer\n\t\t\t\t\t\t.parseInt(seat)]) {\n\t\t\t\t// 食事の時間が終了した場合\n\n\t\t\t\t// 空席にする\n\t\t\t\tseats[seatNum] = null;\n\t\t\t}\n\t\t\tseatNum++;\n\t\t}\n\n\t}\n\n\t/** 着席させる */\n\tprivate static void setSeat(String groupsNum) {\n\n\t\tfor (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n\t\t\t// 着席する人数分繰り返す\n\n\t\t\t// 座席にグループ番号を設定する\n\t\t\tseats[firstSeatNum++] = groupsNum;\n\t\t}\n\t}\n\n\t/** 引数のグループ番号の客数分、空席かどうか確認する */\n\tprivate static boolean isEmpty(int groupsNum) {\n\n\t\t// 空席数\n\t\tint emptyseatsNum = 0;\n\n\t\tfor (int i = 0; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n\t\t\t// 残座席数が客の数以下になるまで座席数分繰り返す\n\n\t\t\tif (emptyseatsNum == customersNum[groupsNum]) {\n\t\t\t\t// 連続した空席が客の数だけあった場合\n\n\t\t\t\t// 空席の最初の座席番号を設定する\n\t\t\t\tfirstSeatNum = i - emptyseatsNum;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tif (seats[i] == null) {\n\t\t\t\t// 空席かつ繰り返す席が顧客数分以上存在する場合\n\n\t\t\t\temptyseatsNum++;\n\n\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t// 空席でない場合\n\n\t\t\t\t// 空席数を初期化\n\t\t\t\temptyseatsNum = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n\n    // ??£?????????????????????????????????\n    private int time = 0;\n\n    // ?????????????????????????????§????????°???????????°\n    private int groupCount = 0;\n\n    public static void main(String[] args) throws Exception {\n\tnew Fukushimaken().execute();\n    }\n\n    private void execute() throws Exception {\n\n\t// ?¨??????\\????????????????????????\n\tList<Integer> targetGroups = readInitialData();\n\n\t// ?????°(17???)\n\tEatingVisitor[] seats = new EatingVisitor[17];\n\n\t// ?????£?????????????????????\n\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t// ?????°?????????????????????????¨??????????\n\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t// ??????????????????????????????????????????????????°??????????????????\n\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t// ?????????????????§??°??????????????????????????£????????????\n\twhile (groupCount <= maxGroupNum) {\n\n\t    // ???????????´??°\n\t    waitingGroups.addAll(updateWaitLine());\n\n\t    // ??¢?????????\n\t    leaveSeat(seats);\n\n\t    // ????????????\n\t    waitTimes.addAll(sitDown(seats, waitingGroups));\n\n\t    time++;\n\t}\n\n\t// ????????????\n\tfor (int targetGroup : targetGroups) {\n\t    System.out.println(waitTimes.get(targetGroup));\n\t}\n    }\n\n    /**\n     * ??§??????????????????\n     * \n     * @param seats\n     *            ??????????????§???(17???)\n     * @param waitingGroups\n     *            ?????§?????£???????????°?????????\n     */\n    private List<Integer> sitDown(EatingVisitor[] seats, List<WaitingVisitor> waitingGroups) {\n\n\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\tint removeCount = 0;\n\tfor (WaitingVisitor waitingPerson : waitingGroups) {\n\n\t    int emptySeatCount = 0;\n\t    boolean isEmpty = false;\n\t    for (int i = 0; i < seats.length; i++) {\n\n\t\t// ????????°????????\\\n\t\tif (seats[i] == null) {\n\t\t    emptySeatCount++;\n\t\t} else {\n\t\t    emptySeatCount = 0;\n\t\t}\n\n\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t    // ????????§??£?????°???????????°?????´??°\n\t\t    groupCount++;\n\t\t    removeCount++;\n\t\t    isEmpty = true;\n\n\t\t    // ????±???°????????????????????????????¨????\n\t\t    waitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t    // ?£???????????????????????¨????\n\t\t    int endTime = 17 * (waitingPerson.getGroup() % 2) + 3 * (waitingPerson.getGroup() % 3) + 19;\n\n\t\t    for (int j = 0; j < emptySeatCount; j++) {\n\t\t\tseats[i - j] = new EatingVisitor(waitingPerson.getGroup(), endTime + time);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    if (!isEmpty) {\n\t\tbreak;\n\t    }\n\n\t}\n\n\t// ?£????????§?????????????????????????\n\tfor (int i = 0; i < removeCount; i++) {\n\t    waitingGroups.remove(0);\n\t}\n\n\treturn waitTimes;\n    }\n\n    /**\n     * ?£???????????????£???????????¢????????????\n     * \n     * @param seats\n     *            ??§???\n     */\n    private void leaveSeat(EatingVisitor[] seats) {\n\tfor (int i = 0; i < seats.length; i++) {\n\t    if (seats[i] != null && seats[i].getEndTime() == time) {\n\t\tseats[i] = null;\n\t    }\n\t}\n    }\n\n    /**\n     * ?????£????????????????????´??°\n     * \n     * @return ????????????\n     */\n    private List<WaitingVisitor> updateWaitLine() {\n\n\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\tint nowGroup = time / 5;\n\t// ??°?????????????????£??????????????????\n\tif (time % 5 == 0) {\n\t    // ??°?????????????????°?????????\n\t    int number = 2;\n\t    if (nowGroup % 5 == 1) {\n\t\tnumber = 5;\n\t    }\n\n\t    // ??????????????????????????????????§?????????????????¨????\n\t    waitingGroups.add(new WaitingVisitor(nowGroup, number, time));\n\t}\n\n\treturn waitingGroups;\n    }\n\n    /**\n     * ?¨??????\\????????????????????????\n     * \n     * @return ??????????????°?????????\n     */\n    private List<Integer> readInitialData() throws Exception {\n\n\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n\tString line = null;\n\tList<Integer> groups = new ArrayList<Integer>();\n\twhile ((line = reader.readLine()) != null) {\n\t    groups.add(Integer.parseInt(line));\n\t}\n\n\treturn groups;\n    }\n\n    /**\n     * ???????????????????????§??°??????????????????????´¢\n     * \n     * @param targetGroups\n     *            ??????????±??????°?????????\n     * @return ??°???????????????\n     */\n    private int searchMaxGroupNum(List<Integer> targetGroups) {\n\tint maxGroupNum = 0;\n\tfor (int targetGroup : targetGroups) {\n\t    if (maxGroupNum < targetGroup) {\n\t\tmaxGroupNum = targetGroup;\n\t    }\n\t}\n\treturn maxGroupNum;\n    }\n\n}\n\n/**\n * ?????¢??????\n */\nabstract class Visitor {\n\n    // ????±???°?????????\n    private int group;\n\n    public int getGroup() {\n\treturn group;\n    }\n\n    public void setGroup(int group) {\n\tthis.group = group;\n    }\n\n}\n\n/**\n * ?????§?????£??????????????¢??????\n */\nclass WaitingVisitor extends Visitor {\n\n    public WaitingVisitor(int group, int number, int startTime) {\n\tsetGroup(group);\n\tsetNumber(number);\n\tsetStartTime(startTime);\n    }\n\n    // ???????§?????????????\n    private int startTime;\n\n    // ??°?????????????????°\n    private int number;\n\n    public int getStartTime() {\n\treturn startTime;\n    }\n\n    public void setStartTime(int startTime) {\n\tthis.startTime = startTime;\n    }\n\n    public int getNumber() {\n\treturn number;\n    }\n\n    public void setNumber(int number) {\n\tthis.number = number;\n    }\n}\n\n/**\n * ?£???????????????¢??????\n */\nclass EatingVisitor extends Visitor {\n\n    public EatingVisitor(int group, int endTime) {\n\tsetGroup(group);\n\tsetEndtTime(endTime);\n    }\n\n    // ?£???????????????????\n    private int endtTime;\n\n    public int getEndTime() {\n\treturn endtTime;\n    }\n\n    public void setEndtTime(int endtTime) {\n\tthis.endtTime = endtTime;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * 0147:Fukushimaken\n * \n * @author MS14A\n * @version 2015/05/09\n */\npublic class Main {\n\n    private static int[] seatWaitTime = new int[17];\n\n    /**\n     * メインメソッド\n     * \n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n\n        List<Integer> inputGroupNumbers = getGroupNumbers();\n\n        for (Integer inputGroupNumber : inputGroupNumbers) {\n            Arrays.fill(seatWaitTime, 0);\n\n            System.out.println(getWaitingTime(inputGroupNumber.intValue()));\n        }\n    }\n\n    private static int getWaitingTime(int inputGroupNumber) {\n\n        boolean canSit = false;\n        List<Integer> waitingGroups = new ArrayList<Integer>();\n        int groupNumber = 0;\n\n        int time = 0;\n        int waitingStartTime = 0;\n        int waitingEndTime = 0;\n\n        while (!canSit) {\n            // 食事時間を一分進める\n            for (int i = 0; i < seatWaitTime.length; i++) {\n                if (seatWaitTime[i] > 0) {\n                    seatWaitTime[i] -= 1;\n                }\n            }\n\n            // グループが来る\n            if (time % 5 == 0) {\n                groupNumber = time / 5;\n                waitingGroups.add(Integer.valueOf(groupNumber));\n\n                if (groupNumber == inputGroupNumber) {\n                    waitingStartTime = time;\n                }\n            }\n\n            if (!waitingGroups.isEmpty()) {\n                // 座れる場合は待ちリストから削除していく\n                canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n\n                while (canSit) {\n                    if (waitingGroups.get(0) == inputGroupNumber) {\n                        waitingEndTime = time;\n                        break;\n                    }\n                    waitingGroups.remove(0);\n                    if (waitingGroups.isEmpty()) {\n                        canSit = false;\n                    } else {\n                        canSit = sit(getNumberOfGuy(waitingGroups.get(0)), getEatingTime(waitingGroups.get(0)));\n                    }\n                }\n            }\n\n            ++time;\n        }\n\n        return waitingEndTime - waitingStartTime;\n    }\n\n    private static boolean sit(int NumberOfGroupMember, int eatingTimeOfGroup) {\n        int count = 0;\n        for (int i = 0; i < seatWaitTime.length; ++i) {\n            if (seatWaitTime[i] == 0) {\n                count += 1;\n                if (count == NumberOfGroupMember) {\n                    Arrays.fill(seatWaitTime, i - NumberOfGroupMember + 1, i + 1, eatingTimeOfGroup);\n                    return true;\n                }\n            } else {\n                count = 0;\n            }\n        }\n\n        return false;\n    }\n\n    private static int getNumberOfGuy(int groupNumber) {\n        if (groupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    private static int getEatingTime(int groupNumber) {\n        return 17 * (groupNumber % 2) + 3 * (groupNumber % 3) + 19;\n    }\n\n    private static List<Integer> getGroupNumbers() throws IOException {\n        // 入力読取り\n        InputStreamReader streamReader = new InputStreamReader(System.in);\n        BufferedReader bufferedReader = new BufferedReader(streamReader);\n\n        String line = null;\n        List<Integer> groupNumbers = new ArrayList<Integer>();\n\n        try {\n            while ((line = bufferedReader.readLine()) != null) {\n                groupNumbers.add(Integer.parseInt(line));\n            }\n            return groupNumbers;\n        } finally {\n            bufferedReader.close();\n            streamReader.close();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n\n            // 入力\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetAndResult = new LinkedHashMap<Integer, Integer>();\n            while (sc.hasNext()) {\n                targetAndResult.put(sc.nextInt(), 0);\n            }\n\n            // 席\n            int[] chairs = new int[17];\n            // 待ち行列\n            Deque<Integer> customers = new LinkedList<Integer>();\n            // 店に来た客グループ数\n            int cameGroupCount = 0;\n            // 経過時間数\n            int pastMinutes = 0;\n            // 座れた客グループ数\n            int sitGroupCount = 0;\n\n            // 1ループ = 1分\n            while (sitGroupCount <= 100) {\n\n                // 客が来る\n                boolean isCustomerCame = comeCustomer(customers, pastMinutes,\n                        cameGroupCount);\n\n                // 食べる\n                eat(chairs);\n\n                // 席に着く\n                int sitCustomerOnMinute = sit(chairs, customers, cameGroupCount);\n\n                // 後処理\n                if (isCustomerCame) {\n                    cameGroupCount++;\n                }\n\n                // 座れた人の時間の計測\n                for (int i = 1; i <= sitCustomerOnMinute; i++) {\n                    if (targetAndResult.containsKey(sitGroupCount)) {\n                        int waitMinutes = pastMinutes - (5 * (sitGroupCount));\n\n                        targetAndResult.put(sitGroupCount, waitMinutes);\n                    }\n\n                    sitGroupCount++;\n                }\n\n                pastMinutes++;\n\n            }\n\n            for (Entry<Integer, Integer> entry : targetAndResult.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static boolean comeCustomer(Deque<Integer> customers, int minutes,\n            int cameGroupCount) {\n        if (cameGroupCount > 100) {\n            // 100人までしか来ない\n            return false;\n        }\n\n        if (minutes % 5 == 0) {\n            // 5分後に到着する\n            if (cameGroupCount % 5 == 1) {\n                // i%5 = 1のとき5人到着\n                customers.offer(5);\n            } else {\n                // それ以外は2人到着\n                customers.offer(2);\n            }\n            // 客が来た\n            return true;\n        }\n\n        // 客が来なかった\n        return false;\n    }\n\n    private static void eat(int[] chairs) {\n        for (int i = 0; i < chairs.length; i++) {\n            chairs[i] = (chairs[i] - 1) < 0 ? 0 : chairs[i] - 1;\n        }\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> customers,\n            int cameGroupCount) {\n        int sitGroupCount = 0;\n\n        Integer firstCustomersNumber = customers.peek();\n\n        if (firstCustomersNumber == null) {\n            // 客が待っていない場合には何もしない\n            return sitGroupCount;\n        }\n\n        int sequencialChair = 0;\n        int sittableChairStart = 0;\n        boolean sittable = false;\n        for (int i = 0; i < chairs.length; i++) {\n            // 席が空いているかどうかを判定\n            if (chairs[i] == 0) {\n                sequencialChair++;\n            } else {\n                sequencialChair = 0;\n            }\n\n            if (sequencialChair >= firstCustomersNumber) {\n                // 連続した席数が必要数に達していたら、その時点のインデックスを返却\n                sittableChairStart = i - (firstCustomersNumber - 1); // 必要席数なので、-1\n                sittable = true;\n                break;\n            }\n        }\n\n        if (!sittable) {\n            // 座れる席が無かった\n            return sitGroupCount;\n        }\n\n        // 待ち行列から削除して座れた扱いとする\n        sitGroupCount++;\n        customers.poll();\n\n        for (int j = 0; j < firstCustomersNumber; j++) {\n            // 席に所要時間をカウント\n            chairs[j + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れる可能性があるので、再帰呼出し\n        cameGroupCount++;\n        sitGroupCount += sit(chairs, customers, cameGroupCount);\n\n        // 座れた\n        return sitGroupCount;\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    public static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        int[] _seat = seat;\n        int[] _eatEndTime = eatEndTime;\n        int[] _waitingTime = waitingTime;\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(_eatEndTime[s] == min) {\n                    _seat[s] = -1;\n                    _eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (_seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        _seat[ts] = headGroupNo;\n                        _eatEndTime[ts] = min + timeToEatList[headGroupNo % timeToEatList.length];\n                    }\n                     \n                    //待った時間を記録\n                    _waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[SEATNUM];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 最大入力値よりも大きくなったら処理を終了する。\n            int groupMaxCount = sittingGroupInfo.size();\n            if (groupMaxCount > 0 && maxInput <= sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                break;\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // 客が入店するかチェック\n            if (minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 並んでいるグループの先頭が座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                // 席が空いているどうか判定する。\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, minutes+comingGroup[2]};\n\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 先頭客の情報を削除する。\n                        groupInfo.remove(0);\n                        // 先頭の人が入れたら次の人が入れる。\n\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                if (!firstCustomer) {\n                    // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                    break;\n                }\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[17];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 客が入店するかチェック\n            if (minutes == 0 || minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n\n                // 最大入力値よりも大きくなったら処理を終了する。\n                int groupMaxCount = sittingGroupInfo.size();\n                if (groupMaxCount > 0 && maxInput == sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                    break;\n                }\n            }\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // グループが座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 並んでいた客の情報を削除する。\n                        groupInfo.remove(comingGroup);\n                        // 先頭の人が入れたら次の人が入れる。\n                        firstCustomer = true;\n                        groupCount--;\n                        // インクリメントされるので-1にしておく。\n                        k = -1;\n                        break;\n                    }\n                }\n                if (firstCustomer) {\n                    continue;\n                }\n                // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                break;\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ3\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0147();\n\t}\n\t\n\tvoid AOJ0145(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt(),ans=Integer.MAX_VALUE;\n\t\t\tC0145[] c=new C0145[N];\n\t\t\tfor(int i=0; i<N; i++)\tc[i]=new C0145(sc.nextInt(),sc.nextInt());\n\t\t\t\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tclass C0145{\n\t\tint upper,down;\n\t\tC0145(int u,int d){\tthis.upper=u;\tthis.down=d;\t}\n\t}\n\t\n\tvoid AOJ0147(){\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\tint MAX=110;\n\t\twhile(sc.hasNext())\tqueue.add(sc.nextInt());\n\t\tint[] num=new int[MAX],atime=new int[MAX],itime=new int[MAX],seat=new int[17],ans=new int[MAX];\n\t\tArrays.fill(seat, -1);\n\t\tfor(int i=0; i<MAX; i++){\n\t\t\tnum[i]=(i%5==1?5:2);\n\t\t\tatime[i]=(17*(i%2)+3*(i%3)+19);\n\t\t}\n\t\t//for(int i=0; i<MAX; i++)\tout.println(i+\": ATIME\"+atime[i]+\" NUM\"+num[i]);\n\t\tint gno=0,min=0;\n\t\twhile(gno<=99){\n\t\t\tseat=exit(seat,min,atime,itime);\n\t\t\tint temp=find(seat,num[gno]);\n\t\t\tif(temp>=0 && min>=gno*5){\n\t\t\t\tans[gno]=max(0,min-gno*5);\n\t\t\t\tfor(int i=temp; i<temp+num[gno]; i++)\tseat[i]=gno;\n\t\t\t\titime[gno]=min;\n\t\t\t\tgno++;\n\t\t\t}else{\n\t\t\t\t//debug\n\t\t\t\t//disp(seat,min);\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\t//disp(seat,min);\n\t\twhile(!queue.isEmpty())\tout.println(ans[queue.poll()]);\n\t}\n\tint find(int[] seat,int n){\n\t\tfor(int i=0; i<=17-n; i++){\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(seat[i+j]!=-1){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\tint[] exit(int[] seat,int min,int[] atime,int[] itime){\n\t\tfor(int i=0; i<17; i++){\n\t\t\tif(seat[i]<0)\tcontinue;\n\t\t\tint emin=itime[seat[i]]+atime[seat[i]];\n\t\t\tif(min>=emin)\tseat[i]=-1;\n\t\t}\n\t\treturn seat;\n\t}\n\tvoid disp(int[] seat,int min){\n\t\tout.print(min+\"m : \");\n\t\tfor(int i=0; i<17; i++)\tout.print(seat[i]+\" \");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tboolean[][] R=new boolean[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint r=sc.nextInt(),k=sc.nextInt();\n\t\t\t\tfor(int j=0; j<k; j++)\tR[r][sc.nextInt()]=true;\n\t\t\t}\n\t\t\tint P=sc.nextInt();\n\t\t\tfor(int i=0; i<P; i++){\n\t\t\t\tint s=sc.nextInt(),d=sc.nextInt(),v=sc.nextInt(),ans=-1;\n\t\t\t\tPriorityQueue<C0144> open=new PriorityQueue<C0144>();\n\t\t\t\topen.add(new C0144(s,v,1));\n\t\t\t\tint[] close=new int[N+1];\n\t\t\t\tArrays.fill(close, Integer.MAX_VALUE);\n\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\tC0144 now=open.poll();\n\t\t\t\t\t//out.println(\"1NOW\"+now.now+\" TTL\"+now.ttl+\" C\"+now.c);\n\t\t\t\t\tif(now.ttl-1==0)\tcontinue;\n\t\t\t\t\tfor(int j=1; j<=N; j++){\n\t\t\t\t\t\tif(R[now.now][j] && now.c+1<close[j]){\n\t\t\t\t\t\t\tif(j==d){\n\t\t\t\t\t\t\t\tans=(ans<0?now.c+1:min(ans,now.c+1));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C0144(j,now.ttl-1,now.c+1));\n\t\t\t\t\t\t\tclose[j]=now.c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.println((ans<0?\"NA\":ans));\n\t\t\t}\n\t\t}\n\t}\n\tclass C0144 implements Comparable<C0144>{\n\t\tint now,ttl,c;\n\t\tC0144(int now,int ttl,int c){\n\t\t\tthis.now=now;\tthis.ttl=ttl;\tthis.c=c;\n\t\t}\n\t\t@Override public int compareTo(C0144 o) {\n\t\t\tif(this.c<o.c)\treturn -1;\n\t\t\tif(this.c>o.c)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t// 正午からの経過時間（分）\n\tprivate int time = 0;\n\n\t// 待ち時間を調査済みであるグループ数\n\tprivate int groupCount = 0;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().execute();\n\t}\n\n\tprivate void execute() throws Exception {\n\n\t\t// 標準入力を１行ずつ処理\n\t\tList<Integer> targetGroups = readInitialData();\n\n\t\t// 席数(17席)\n\t\tEatingVisitor[] seats = new EatingVisitor[17];\n\n\t\t// 待っている人の行列\n\t\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t\t// 各グループの待ち時間計算結果\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t\t// 待ち時間を調べる必要がある最後のグループを取得\n\t\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t\t// 要調査の最大グループが調べ終わったら終了\n\t\twhile (groupCount <= maxGroupNum) {\n\n\t\t\t// 行列の更新\n\t\t\twaitingGroups.addAll(updateWaitLine());\n\n\t\t\t// 離席する\n\t\t\tleaveSeat(seats);\n\n\t\t\t// 着席する\n\t\t\twaitTimes.addAll(sitDown(seats, waitingGroups));\n\n\t\t\ttime++;\n\t\t}\n\n\t\t// 結果出力\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tSystem.out.println(waitTimes.get(targetGroup));\n\t\t}\n\t}\n\n\t/**\n\t * 座席に着席する\n\t * \n\t * @param seats\n\t *            福縞軒の座席(17席)\n\t * @param waitingGroups\n\t *            外で待っているグループ\n\t */\n\tprivate List<Integer> sitDown(EatingVisitor[] seats,\n\t\t\tList<WaitingVisitor> waitingGroups) {\n\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\n\t\tint removeCount = 0;\n\t\tfor (WaitingVisitor waitingPerson : waitingGroups) {\n\n\t\t\tint emptySeatCount = 0;\n\t\t\tboolean isEmpty = false;\n\t\t\tfor (int i = 0; i < seats.length; i++) {\n\n\t\t\t\t// 空席数を検知\n\t\t\t\tif (seats[i] == null) {\n\t\t\t\t\temptySeatCount++;\n\t\t\t\t} else {\n\t\t\t\t\temptySeatCount = 0;\n\t\t\t\t}\n\n\t\t\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t\t\t\t// 席に座ったグループ数を更新\n\t\t\t\t\tgroupCount++;\n\t\t\t\t\tremoveCount++;\n\t\t\t\t\tisEmpty = true;\n\n\t\t\t\t\t// 所属グループの待ち時間を記録\n\t\t\t\t\twaitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t\t\t\t// 食べ終わる時間を計算\n\t\t\t\t\tint endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n\t\t\t\t\t\t\t* (waitingPerson.getGroup() % 3) + 19;\n\n\t\t\t\t\tfor (int j = 0; j < emptySeatCount; j++) {\n\t\t\t\t\t\tseats[i - j] = new EatingVisitor(\n\t\t\t\t\t\t\t\twaitingPerson.getGroup(), endTime + time);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t// 食事を始めた待ち人を削除\n\t\tfor (int i = 0; i < removeCount; i++) {\n\t\t\twaitingGroups.remove(0);\n\t\t}\n\n\t\treturn waitTimes;\n\t}\n\n\t/**\n\t * 食事が終わった人を離席させる\n\t * \n\t * @param seats\n\t *            座席\n\t */\n\tprivate void leaveSeat(EatingVisitor[] seats) {\n\t\tfor (int i = 0; i < seats.length; i++) {\n\t\t\tif (seats[i] != null && seats[i].getEndTime() == time) {\n\t\t\t\tseats[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 待っている行列を更新\n\t * \n\t * @return 待ち行列\n\t */\n\tprivate List<WaitingVisitor> updateWaitLine() {\n\n\t\tList<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n\n\t\tint nowGroup = time / 5;\n\t\t// グループがやってきたか判定\n\t\tif (time % 5 == 0) {\n\t\t\t// グループの人数を算出\n\t\t\tint number = 2;\n\t\t\tif (nowGroup % 5 == 1) {\n\t\t\t\tnumber = 5;\n\t\t\t}\n\n\t\t\t// 行列の後ろに追加。待ち始めた時間を記録\n\t\t\twaitingGroups.add(new WaitingVisitor(nowGroup, number, time));\n\t\t}\n\n\t\treturn waitingGroups;\n\t}\n\n\t/**\n\t * 標準入力からデータ取得\n\t * \n\t * @return 要調査のグループ\n\t */\n\tprivate List<Integer> readInitialData() throws Exception {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tString line = null;\n\t\tList<Integer> groups = new ArrayList<Integer>();\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tgroups.add(Integer.parseInt(line));\n\t\t}\n\n\t\treturn groups;\n\t}\n\n\t/**\n\t * 調査が必要な最大グループ番号を検索\n\t * \n\t * @param targetGroups\n\t *            調査対象のグループ\n\t * @return グループ番号\n\t */\n\tprivate int searchMaxGroupNum(List<Integer> targetGroups) {\n\t\tint maxGroupNum = 0;\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tif (maxGroupNum < targetGroup) {\n\t\t\t\tmaxGroupNum = targetGroup;\n\t\t\t}\n\t\t}\n\t\treturn maxGroupNum;\n\t}\n\n}\n\n/**\n * お客さん\n */\nabstract class Visitor {\n\n\t// 所属グループ\n\tprivate int group;\n\n\tpublic int getGroup() {\n\t\treturn group;\n\t}\n\n\tpublic void setGroup(int group) {\n\t\tthis.group = group;\n\t}\n\n}\n\n/**\n * 外で待っているお客さん\n */\nclass WaitingVisitor extends Visitor {\n\n\tpublic WaitingVisitor(int group, int number, int startTime) {\n\t\tsetGroup(group);\n\t\tsetNumber(number);\n\t\tsetStartTime(startTime);\n\t}\n\n\t// 待ち始めた時刻\n\tprivate int startTime;\n\n\t// グループの人数\n\tprivate int number;\n\n\tpublic int getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(int startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic int getNumber() {\n\t\treturn number;\n\t}\n\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n}\n\n/**\n * 食事中のお客さん\n */\nclass EatingVisitor extends Visitor {\n\n\tpublic EatingVisitor(int group, int endTime) {\n\t\tsetGroup(group);\n\t\tsetEndtTime(endTime);\n\t}\n\n\t// 食べ終わる時間\n\tprivate int endtTime;\n\n\tpublic int getEndTime() {\n\t\treturn endtTime;\n\t}\n\n\tpublic void setEndtTime(int endtTime) {\n\t\tthis.endtTime = endtTime;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCounters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCounters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCounters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            String inputStr = null;\n            try {\n                inputStr = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (inputStr == null) {\n                break;\n            }\n            inputNumber = Integer.valueOf(inputStr);\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了。\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCounters.length; i++) {\n            if (serviceCounters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCounters[i]) == (currentTime - sitTimeList.get(serviceCounters[i]))) {\n                    int emptyCounter = serviceCounters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCounters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCounters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n        for (int startPoint = 0; startPoint < serviceCounters.length; startPoint++) {\n            if (serviceCounters[startPoint] == -1) {\n                int emptyCount = 1;\n                for (int endpoint = startPoint + 1; endpoint < serviceCounters.length; endpoint++) {\n                    // 空席ならカウント\n                    if (serviceCounters[endpoint] == -1) {\n                        emptyCount++;\n                        // 連続空席がグループの人数以上か判定\n                        if (emptyCount >= groupNumberOfPeopleList.get(firstWaitGroupNumber)) {\n                            System.out.println(emptyCount);\n                            return startPoint;\n                        }\n                    } else {\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\tfor (int countTimeGoesBy = 0; countTimeGoesBy < 300; countTimeGoesBy++) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\tint countDelete = 0;\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\t\t\t\t\t\n\t\t\t\t\tcountDelete++;\n\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// waitingCustomersList.remove(count);\n\t\t\t\t// waitingStartTimeList.remove(count);\n\t\t\t\t// count++;\n\t\t\t\t// int sizeCustomer = waitingCustomersList.size();\n\t\t\t\t// int sizeStartTime = waitingStartTimeList.size();\n\n\t\t\t\t// for (int count2 = waitingCustomersList.size() + 1; count2 <\n\t\t\t\t// 1; count2--) {\n\t\t\t\t// if (waitingCustomersList.size() <= sizeCustomer) {\n\t\t\t\t// waitingCustomersList.add(waitingCustomersList\n\t\t\t\t// .get(waitingCustomersList.size() - 1));\n\t\t\t\t//\n\t\t\t\t// } else {\n\t\t\t\t//\n\t\t\t\t// waitingCustomersList.set(count2,\n\t\t\t\t// waitingCustomersList.get(count2 - 1));\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t\t// for (int count3 = waitingStartTimeList.size() + 1; count3 <\n\t\t\t\t// 1; count3--) {\n\t\t\t\t// if (waitingStartTimeList.size() <= sizeStartTime) {\n\t\t\t\t// waitingStartTimeList.add(waitingStartTimeList\n\t\t\t\t// .get(waitingStartTimeList.size() - 1));\n\t\t\t\t//\n\t\t\t\t// } else {\n\t\t\t\t// waitingStartTimeList.set(count3,\n\t\t\t\t// waitingStartTimeList.get(count3 - 1));\n\t\t\t\t// }\n\t\t\t\t// }\n\n\t\t\t}\n\t\t\tfor (int countt = 0; countt < countDelete; countt++) {\n\t\t\t\twaitingCustomersList.remove(0);\n\t\t\t\twaitingStartTimeList.remove(0);\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(waitingTime);\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\tint[] enter;\n\tint time(int n){\n\t\treturn 17*(n%2)+3*(n%3)+19; \n\t}\n\t\n\tvoid solve(){\n\t\tint[] seats=new int[17];\n\t\tArrays.fill(seats,-1);\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\t\n\t\tint[] finish=new int[100];\n\t\tenter=new int[100];\n\t\t\n\t\tint nq=0,ns=0;\n\t\tfor(int t=0;ns<100;++t){\n\t\t\t//離席\n\t\t\tfor(int i=0;i<17;++i){\n\t\t\t\tif(seats[i]!=-1&&t>=finish[seats[i]]){\n\t\t\t\t\tseats[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//来店\n\t\t\tif(nq<100&&t%5==0){\n\t\t\t\tqueue.add(nq++);\n\t\t\t}\n\t\t\t//空席判定\n\t\t\tfor(int i=0;i<17&&!queue.isEmpty();++i){\n\t\t\t\tif(seats[i]==-1){\n\t\t\t\t\t//[i,j] : 連続空席\n\t\t\t\t\tint j=i;\n\t\t\t\t\tfor(;j<17&&seats[j]==-1;++j);\n\t\t\t\t\t--j;\n\t\t\t\t\t//店に這入れるなら入れる\n\t\t\t\t\t//p:客数\n\t\t\t\t\tint p=(queue.peek()%5==1)?5:2;\n\t\t\t\t\tif(j-i+1>=p){\n\t\t\t\t\t\tint group=queue.poll();\n\t\t\t\t\t\tfor(int k=i;k<i+p;++k){\n\t\t\t\t\t\t\tseats[k]=group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter[group]=t;\n\t\t\t\t\t\tfinish[group]=t+time(group);\n\t\t\t\t\t\t++ns;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug(t,seats);\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tsolve();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=ni();\n\t\t\tSystem.out.println(enter[n]-n*5);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n\n        List<Integer> output = new ArrayList<Integer>();\n\n        // ??¨??????\\???\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = null;\n\n        while (true) {\n            input = br.readLine();\n            if (input == null || input.isEmpty()) {\n                break;\n            }\n            int inputNum = Integer.parseInt(input);\n            int time = 0;\n            boolean result = true;\n            int[] seat = new int[17];\n            List<Integer> waitGuest = new ArrayList<Integer>();\n\n            while (result) {\n                exitFukushimaken(seat, time);\n\n                if (time % 5 == 0) {\n                    waitGuest.add(time / 5);\n                }\n\n                while (waitGuest.size() > 0)  {\n                    if (isWaitGuest(waitGuest)) {\n                        int guest = guestOfNumber(waitGuest.get(0));\n                        int seatNum = confirmEmptySeat(seat, guest);\n\n                        if (seatNum != 99) {\n                            enterFukushimaken(waitGuest.get(0), guest, seatNum, seat, time);\n                            if (inputNum == waitGuest.get(0)) {\n                                output.add(time - (waitGuest.get(0) * 5));\n                                result = false;\n                                break;\n                            }\n                            waitGuest.remove(0);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                ++time;\n            }\n        }\n        for (int outputNum : output) {\n            System.out.println(outputNum);\n        }\n    }\n\n\n\n    private static boolean isWaitGuest(List<Integer> waitGuest){\n\n        if (waitGuest.size() != 0) {\n            return true;\n        }\n        return false;\n    }\n\n    // i????????????°??????????????????°?????????\n    private static int guestOfNumber(int number) {\n        if (number % 5 == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ???§??????????????????????????????\n    // i = ???§?????????´????????????????????????99??????§?????????\n    private static int confirmEmptySeat(int[] seat, int guest) {\n        for (int i = 0; i <= seat.length - guest; ++i) {\n            int count = 0;\n            for (int j = 0; j < guest; ++j) {\n                if (seat[i + j] != 0) {\n                    break;\n                } else {\n                    ++count;\n                    if (guest == count) {\n                        return i;\n                    }\n                }\n            }\n        }\n        return 99;\n    }\n\n    // ????????????\n    private static void enterFukushimaken(int groupNum, int guest, int seatNum,\n            int[] seat, int time) {\n        int ateTime = time + ateFoodTime(groupNum);\n        for (int i = 0; i < guest; ++i) {\n            seat[seatNum + i] = ateTime;\n        }\n    }\n\n    // ??£?????????????£??????¢??????????????¢??????????\n    private static void exitFukushimaken(int[] seat, int time) {\n        for (int i = 0; i < seat.length; ++i) {\n            if (time == seat[i]) {\n                seat[i] = 0;\n            }\n        }\n    }\n\n    // i????????????°??????????????£?????????????\n    private static int ateFoodTime(int number) {\n        int a = (number % 2) * 17;\n        int b = (number % 3) * 3;\n        return a + b + 19;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint[] arrivals = new int[100];\n\t\tint[] seats = new int[17];\n\t\tint[] end_seats = new int[17];\n\t\tint[] wait = new int[100];\n\t\tArrays.fill(seats, -1);\n\t\tArrays.fill(end_seats, -1);\n\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tarrivals[i] = 5 * i;\n\t\t}\n\n\t\tint porpos = 0;\n\t\tEND: for (int time = 0;; time++) {\n\t\t\t\n\t\t\t//System.out.println(Arrays.toString(seats));\n\t\t\t\n\t\t\tLOOP:while (arrivals[porpos] <= time) {\n\t\t\t\t\n\t\t\t\t//System.out.println(porpos);\n\t\t\t\t\n\t\t\t\tboolean f_fount = false;\n\t\t\t\tfor (int i = 0; i < 17 - (porpos % 5 == 1 ? 5 : 2); i++) {\n\t\t\t\t\tboolean found = true;\n\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\tif (seats[i + j] != -1) {\n\t\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tf_fount = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int j = 0; j < (porpos % 5 == 1 ? 5 : 2); j++) {\n\t\t\t\t\t\t\tseats[i + j] = porpos;\n\t\t\t\t\t\t\tend_seats[i + j] = time + 17 * (porpos % 2) + 3\n\t\t\t\t\t\t\t\t\t* (porpos % 3) + 19;\n\t\t\t\t\t\t\twait[porpos] = time - arrivals[porpos];\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (porpos == 99) {\n\t\t\t\t\t\t\tbreak END;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tporpos++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!f_fount){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\tif (seats[i] != -1 && end_seats[i] < time) {\n\t\t\t\t\tseats[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (sc.hasNext()) {\n\t\t\tSystem.out.println(wait[sc.nextInt()]);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // ?????????????????£???????????????????´????????????????\n        List<String> waitingCustomersList = new ArrayList<String>();\n\n        List<String> list = new ArrayList<String>();\n\n        List<String> waitingStartTimeList = new ArrayList<String>();\n\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // ??\\???????????????null???????????????????????????????????????????????????\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // ?£????????????£?????¢??????????????£??????????????????\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // ?????£????????????????????§??£????????????\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n               // waitingStartTimeList.remove(0);\n            }\n            // ??¢?????????\n            if (timeGoesBy % 5 == 0) {\n                // ??¢????????°???????????????\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // ???????????????????????????????????????????????????\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // ??¢???????????§?????????????????????????????§????????°???????????????\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // ??¢????????°???????????????\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ?£????????????£?????¢??????????????????\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n                seats[count][1] = 0;\n                seats[count][2] = 0;\n\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n\t/*** ??°??????????????° */\n\tprivate static final int GROUP_NUM = 100;\n\n\tprivate static BufferedReader br;\n\tprivate static int placeNum;\n\tprivate static int[] arriveTime, customerNum, mealTime, waitTime;\n\n\t/*** ??? */\n\tprivate static String[] places;\n\tprivate static int finalPlace;\n\n\t/*** ????????? */\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tplaceNum = 17;\n\t\tarriveTime = new int[GROUP_NUM];\n\t\tcustomerNum = new int[GROUP_NUM];\n\t\tmealTime = new int[GROUP_NUM];\n\t\twaitTime = new int[GROUP_NUM];\n\t\tplaces = new String[placeNum];\n\n\t\t// ?????????\n\t\tfor (int i = 0; i < GROUP_NUM; i++) {\n\t\t\tarriveTime[i] = 5 * i;\n\t\t\tcustomerNum[i] = i % 5 == 1 ? 5 : 2;\n\t\t\tmealTime[i] = placeNum * (i % 2) + 3 * (i % 3) + 19;\n\t\t}\n\n\t\tint key;\n\n\t\t// ????????¢?????????\n\t\tList<Integer> waitList = new ArrayList<Integer>();\n\n\t\t// ??\\?????¢?????????\n\t\tList<Integer> removeList = new ArrayList<Integer>();\n\n\t\t// ??°??????????????¨?????????????????????????????????????????????\n\t\tfor (int currentTime = 0; currentTime <= 5 * 100; currentTime++) {\n\t\t\toutStore(currentTime);\n\n\t\t\t// ?????????????????°????????????\n\t\t\tif ((key = search(arriveTime, currentTime)) != -1) {\n\t\t\t\tif (waitList.isEmpty()) {\n\t\t\t\t\tif (isEmpty(key)) {\n\t\t\t\t\t\tset(Integer.toString(key));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitList.add(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitList.add(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!waitList.isEmpty()) {\n\t\t\t\t// ???????????¢???????????´???\n\t\t\t\tint i = 0;\n\t\t\t\tboolean flg = true;\n\n\t\t\t\tfor (int wait : waitList) {\n\t\t\t\t\tif (isEmpty(wait) && flg) {\n\t\t\t\t\t\tset(Integer.toString(wait));\n\t\t\t\t\t\twaitTime[wait] = currentTime - arriveTime[wait];\n\t\t\t\t\t\tremoveList.add(i);\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!removeList.isEmpty()) {\n\t\t\t\tCollections.reverse(removeList);\n\t\t\t\tfor (int remove : removeList) {\n\t\t\t\t\t// ??\\???????????¢???????????¢???????????????????????????\n\t\t\t\t\twaitList.remove(remove);\n\t\t\t\t}\n\t\t\t\tremoveList = new ArrayList<Integer>();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * ?????????????????????\n\t *\n\t * @param args\n\t *            ??????????????°\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws IOException {\n\t\tString line;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\n\t\t// ??\\???\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\t// ??????\n\t\tfor (int input : inputList) {\n\t\t\tSystem.out.println(waitTime[input]);\n\t\t}\n\n\t}\n\n\tprivate static int search(int[] targets, int currentTime) {\n\t\tint i = 0;\n\t\tfor (int target : targets) {\n\t\t\tif (target == currentTime) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??????????????£?????°?????????????????????????????????\n\t *\n\t */\n\tprivate static void outStore(int currentTime) {\n\t\tint i = 0;\n\t\tfor (String place : places) {\n\t\t\tif (place == null) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mealTime[Integer.parseInt(place)] <= currentTime\n\t\t\t\t\t- arriveTime[Integer.parseInt(place)]) {\n\t\t\t\tplaces[i] = null;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t}\n\n\t/**\n\t * ??°?????????????????§???????¨??????????\n\t *\n\t * @param groupNum\n\t *            ??°???????????????\n\t */\n\tprivate static void set(String groupNum) {\n\n\t\tfor (int i = finalPlace, count = 0; count < customerNum[Integer\n\t\t\t\t.parseInt(groupNum)]; i--, count++) {\n\t\t\tplaces[i] = groupNum;\n\t\t}\n\t}\n\n\t/**\n\t * ?????°?????°?????????????????°?????§?????????????????????????????????\n\t *\n\t * @param groupNum\n\t *            ??°?????????????????°\n\t * @return true : ??§?????? false : ??§?????????\n\t */\n\tprivate static boolean isEmpty(int groupNum) {\n\n\t\t// ????????°\n\t\tint emptyPlaceNum = 0;\n\n\t\tfor (int i = 0; i < placeNum; i++) {\n\t\t\tif (places[i] == null) {\n\t\t\t\temptyPlaceNum++;\n\t\t\t} else {\n\t\t\t\t// ??£?¶???????????????§???????????°???????????°??????????????????\n\t\t\t\temptyPlaceNum = 0;\n\t\t\t}\n\t\t\tif (emptyPlaceNum == customerNum[groupNum]) {\n\t\t\t\tfinalPlace = i;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Main {\n \n    // ??£?????????????????????????????????\n    private int time = 0;\n \n    // ?????????????????????????????§????????°???????????°\n    private int groupCount = 0;\n \n    public static void main(String[] args) throws Exception {\n        new Main().execute();\n    }\n \n    private void execute() throws Exception {\n \n        // ?¨??????\\????????????????????????\n        List<Integer> targetGroups = readInitialData();\n \n        // ?????°(17???)\n        EatingVisitor[] seats = new EatingVisitor[17];\n \n        // ?????£?????????????????????\n        List<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n \n        // ?????°?????????????????????????¨??????????\n        List<Integer> waitTimes = new ArrayList<Integer>();\n \n        // ??????????????????????????????????????????????????°??????????????????\n        int maxGroupNum = searchMaxGroupNum(targetGroups);\n \n        // ?????????????????§??°??????????????????????????£????????????\n        while (groupCount <= maxGroupNum) {\n \n            // ???????????´??°\n            waitingGroups.addAll(updateWaitLine());\n \n            // ??¢?????????\n            leaveSeat(seats);\n \n            // ????????????\n            waitTimes.addAll(sitDown(seats, waitingGroups));\n \n            time++;\n        }\n \n        // ????????????\n        for (int targetGroup : targetGroups) {\n            System.out.println(waitTimes.get(targetGroup));\n        }\n    }\n \n    /**\n     * ??§??????????????????\n     * \n     * @param seats\n     *            ??????????????§???(17???)\n     * @param waitingGroups\n     *            ?????§?????£???????????°?????????\n     */\n    private List<Integer> sitDown(EatingVisitor[] seats,\n            List<WaitingVisitor> waitingGroups) {\n \n        List<Integer> waitTimes = new ArrayList<Integer>();\n \n        int removeCount = 0;\n        for (WaitingVisitor waitingPerson : waitingGroups) {\n \n            int emptySeatCount = 0;\n            boolean isEmpty = false;\n            for (int i = 0; i < seats.length; i++) {\n \n                // ????????°????????\\\n                if (seats[i] == null) {\n                    emptySeatCount++;\n                } else {\n                    emptySeatCount = 0;\n                }\n \n                if (waitingPerson.getNumber() == emptySeatCount) {\n \n                    // ????????§??£?????°???????????°?????´??°\n                    groupCount++;\n                    removeCount++;\n                    isEmpty = true;\n \n                    // ????±???°????????????????????????????¨????\n                    waitTimes.add(time - waitingPerson.getStartTime());\n \n                    // ?£???????????????????????¨????\n                    int endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n                            * (waitingPerson.getGroup() % 3) + 19;\n \n                    for (int j = 0; j < emptySeatCount; j++) {\n                        seats[i - j] = new EatingVisitor(\n                                waitingPerson.getGroup(), endTime + time);\n                    }\n                    break;\n                }\n            }\n \n            if (!isEmpty) {\n                break;\n            }\n \n        }\n \n        // ?£????????§?????????????????????????\n        for (int i = 0; i < removeCount; i++) {\n            waitingGroups.remove(0);\n        }\n \n        return waitTimes;\n    }\n \n    /**\n     * ?£???????????????£???????????¢????????????\n     * \n     * @param seats\n     *            ??§???\n     */\n    private void leaveSeat(EatingVisitor[] seats) {\n        for (int i = 0; i < seats.length; i++) {\n            if (seats[i] != null && seats[i].getEndTime() == time) {\n                seats[i] = null;\n            }\n        }\n    }\n \n    /**\n     * ?????£????????????????????´??°\n     * \n     * @return ????????????\n     */\n    private List<WaitingVisitor> updateWaitLine() {\n \n        List<WaitingVisitor> waitingGroups = new ArrayList<WaitingVisitor>();\n \n        int nowGroup = time / 5;\n        // ??°?????????????????£??????????????????\n        if (time % 5 == 0) {\n            // ??°?????????????????°?????????\n            int number = 2;\n            if (nowGroup % 5 == 1) {\n                number = 5;\n            }\n \n            // ??????????????????????????????????§?????????????????¨????\n            waitingGroups.add(new WaitingVisitor(nowGroup, number, time));\n        }\n \n        return waitingGroups;\n    }\n \n    /**\n     * ?¨??????\\????????????????????????\n     * \n     * @return ??????????????°?????????\n     */\n    private List<Integer> readInitialData() throws Exception {\n \n        BufferedReader reader = new BufferedReader(new InputStreamReader(\n                System.in));\n \n        String line = null;\n        List<Integer> groups = new ArrayList<Integer>();\n        while ((line = reader.readLine()) != null) {\n            groups.add(Integer.parseInt(line));\n        }\n \n        return groups;\n    }\n \n    /**\n     * ???????????????????????§??°??????????????????????´¢\n     * \n     * @param targetGroups\n     *            ??????????±??????°?????????\n     * @return ??°???????????????\n     */\n    private int searchMaxGroupNum(List<Integer> targetGroups) {\n        int maxGroupNum = 0;\n        for (int targetGroup : targetGroups) {\n            if (maxGroupNum < targetGroup) {\n                maxGroupNum = targetGroup;\n            }\n        }\n        return maxGroupNum;\n    }\n \n}\n \n/**\n * ?????¢??????\n */\nabstract class Visitor {\n \n    // ????±???°?????????\n    private int group;\n \n    public int getGroup() {\n        return group;\n    }\n \n    public void setGroup(int group) {\n        this.group = group;\n    }\n \n}\n \n/**\n * ?????§?????£??????????????¢??????\n */\nclass WaitingVisitor extends Visitor {\n \n    public WaitingVisitor(int group, int number, int startTime) {\n        setGroup(group);\n        setNumber(number);\n        setStartTime(startTime);\n    }\n \n    // ???????§?????????????\n    private int startTime;\n \n    // ??°?????????????????°\n    private int number;\n \n    public int getStartTime() {\n        return startTime;\n    }\n \n    public void setStartTime(int startTime) {\n        this.startTime = startTime;\n    }\n \n    public int getNumber() {\n        return number;\n    }\n \n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n \n/**\n * ?£???????????????¢??????\n */\nclass EatingVisitor extends Visitor {\n \n    public EatingVisitor(int group, int endTime) {\n        setGroup(group);\n        setEndtTime(endTime);\n    }\n \n    // ?£???????????????????\n    private int endtTime;\n \n    public int getEndTime() {\n        return endtTime;\n    }\n \n    public void setEndtTime(int endtTime) {\n        this.endtTime = endtTime;\n    }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n\n            // 入力\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetAndResult = new LinkedHashMap<Integer, Integer>();\n            while (sc.hasNext()) {\n                targetAndResult.put(sc.nextInt(), 0);\n            }\n\n            // 席\n            int[] chairs = new int[17];\n            // 待ち行列\n            Deque<Integer> customers = new LinkedList<Integer>();\n            // 店に来た客グループ数\n            int cameGroupCount = 0;\n            // 経過時間数\n            int pastMinutes = 0;\n            // 座れた客グループ数\n            int sitGroupCount = 0;\n\n            // 1ループ = 1分\n            while (sitGroupCount <= 100) {\n\n                // 客が来る\n                boolean isCustomerCame = comeCustomer(customers, pastMinutes,\n                        cameGroupCount);\n\n                // 食べる\n                eat(chairs);\n\n                // 席に着く\n                int sitCustomerOnMinute = sit(chairs, customers, cameGroupCount);\n\n                // 後処理\n                if (isCustomerCame) {\n                    cameGroupCount++;\n                }\n\n                // 座れた人の時間の計測\n                for (int i = 1; i <= sitCustomerOnMinute; i++) {\n                    if (targetAndResult.containsKey(sitGroupCount)) {\n                        int waitMinutes = pastMinutes - (5 * (sitGroupCount));\n\n                        targetAndResult.put(sitGroupCount, waitMinutes);\n                    }\n\n                    sitGroupCount++;\n                }\n\n                pastMinutes++;\n\n            }\n\n            for (Entry<Integer, Integer> entry : targetAndResult.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static boolean comeCustomer(Deque<Integer> customers, int minutes,\n            int cameGroupCount) {\n        if (cameGroupCount > 100) {\n            // 100人までしか来ない\n            return false;\n        }\n\n        if (minutes % 5 == 0) {\n            // 5分後に到着する\n            if (cameGroupCount % 5 == 1) {\n                // i%5 = 1のとき5人到着\n                customers.offer(5);\n            } else {\n                // それ以外は2人到着\n                customers.offer(2);\n            }\n            // 客が来た\n            return true;\n        }\n\n        // 客が来なかった\n        return false;\n    }\n\n    private static void eat(int[] chairs) {\n        for (int i = 0; i < chairs.length; i++) {\n            chairs[i] = (chairs[i] - 1) < 0 ? 0 : chairs[i] - 1;\n        }\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> customers,\n            int cameGroupCount) {\n        int sitGroupCount = 0;\n\n        Integer firstCustomersNumber = customers.peek();\n\n        if (firstCustomersNumber == null) {\n            // 客が待っていない場合には何もしない\n            return sitGroupCount;\n        }\n\n        int sequencialChair = 0;\n        int sittableChairStart = 0;\n        boolean sittable = false;\n        for (int i = 0; i < chairs.length; i++) {\n            // 席が空いているかどうかを判定\n            if (chairs[i] == 0) {\n                sequencialChair++;\n            } else {\n                sequencialChair = 0;\n            }\n\n            if (sequencialChair >= firstCustomersNumber) {\n                // 連続した席数が必要数に達していたら、その時点のインデックスを返却\n                sittableChairStart = i - (firstCustomersNumber - 1); // 必要席数なので、-1\n                sittable = true;\n                break;\n            }\n        }\n\n        if (!sittable) {\n            // 座れる席が無かった\n            return sitGroupCount;\n        }\n\n        // 待ち行列から削除して座れた扱いとする\n        sitGroupCount++;\n        customers.poll();\n\n        for (int j = 0; j < firstCustomersNumber; j++) {\n            // 席に所要時間をカウント\n            chairs[j + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れる可能性があるので、再帰呼出し\n        cameGroupCount++;\n        sitGroupCount += sit(chairs, customers, cameGroupCount);\n\n        // 座れた\n        return sitGroupCount;\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] a = new int[17];\n\t\tint[] out = new int[101];\n\t\tint[] time = new int[]{19,39,25,36,22,42};\n\t\tArrayList<Integer> wait = new ArrayList<Integer>();\n\t\tArrays.fill(a, -1);\n\t\tint p, q;\n\t\tboolean flag;\n\t\tboolean check;\n\t\tfor(int i=0;i<567;i++){\n\t\t\tfor(int j=0;j<17;j++){\n\t\t\t\tif(a[j]==i) a[j] = -1;\n\t\t\t}\n\t\t\tif(i%5==0) wait.add(i/5);\n\t\t\twhile(wait.size()!=0){\n\t\t\t\tcheck = false;\n\t\t\t\tp = wait.get(0);\n\t\t\t\tq = 2;\n\t\t\t\tif(p%5==1) q = 5;\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<18-q;j++){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tfor(int k=0;k<q;k++){\n\t\t\t\t\t\tif(a[j+k]!=-1) flag = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==true){\n\t\t\t\t\t\tout[p] = i+time[p%6];\n\t\t\t\t\t\tfor(int k=0;k<q;k++) a[j+k] = out[p];\n\t\t\t\t\t\tcheck = true;\n\t\t\t\t\t\twait.remove(0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check==false) break;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(out[n]- time[n%6] - n*5);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(waitingTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n             \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    int sittingGroupNum = seat[s];\n                    if (sittingGroupNum == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                        //グループの人数分飛ばす\n                        s += sittingGroupNum % 5 == 1 ? 5 : 2;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, min + timeToEatList[headGroupNo % timeToEatList.length]);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            for (int i = 0; i < queueStatusList.size(); i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                int groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                int blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList, baseTime, blankStartSeatNo, n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.poll();\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>();\n\n        for (int i = 0; i < seatNo; i++) {\n\n            GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        GroupStatus seatStatus = new GroupStatus();\n\n        for (int i = 0; i < 17; ++i) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatus = seatStatusMap.get(i);\n                seatStatus.endStayTime = time;\n\n                if ((seatStatus.endStayTime - seatStatus.startStayTime) == getMealTime(seatStatus.groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.remove(i);\n                    seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n                    seatStatusMap.put((Integer) i, seatStatus);\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap,\n            LinkedList<GroupStatus> queueStatusList, int baseTime, int blankStartSeatNo, int n) {\n\n        GroupStatus queueStatus = queueStatusList.peek();\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\tfor (int countTimeGoesBy = 0; countTimeGoesBy < 300; countTimeGoesBy++) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\twaitingCustomersList.remove(count);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(waitingTime);\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // 店内の座席を作成する。0が空席,1行目が席、2行目が着席時刻、3行目が食事時間\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // 空席がなかった人たちを格納するリスト\n        List<String> waitingCustomersList = new ArrayList<String>();\n        //最終的に出力する値\n        List<String> list = new ArrayList<String>();\n        //待ち行列\n        List<String> waitingStartTimeList = new ArrayList<String>();\n        //出力されるグループ\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // 入力データがnullもしくは空文字の時、ループを抜ける\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // 食べ終わった客に出て行ってもらいたい\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // 待ってる人たちに座ってもらう\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    //各グループの待ち時間を計算し、リストに格納する\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n            //席についた客と時間をリストから削除する\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n                waitingStartTimeList.remove(0);\n            }\n            // 客がくる\n            if (timeGoesBy % 5 == 0 || timeGoesBy == 0) {\n                // 客の人数を取得する\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // 空席があるか判定し、あれば着席させる、なければ待ち行列に追加する\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // 指定された番号の待ち時間を取得する\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // 客が着席できるか判定し、可能であれば着席させる\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    //着席可能か判断する\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // 客の人数を判定する\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // 食べ終わった客を退席させる\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n                seats[count][1] = 0;\n                seats[count][2] = 0;\n\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n    // ?¨???¢??°?????§???\n    static final int MAX_NUMBER_OF_VISITOR = 100;\n\n    // ??§?????°\n    static final int NUMBER_OF_SEAT = 17;\n\n    // ??°???????????°??\\??????\n    static final int INTERVAL = 5;\n\n    // ??????????????????\n    static int[] waitingTime = new int[MAX_NUMBER_OF_VISITOR];\n\n    // ???????????§????????¶???\n    static int[] shopSeatTimer = new int[NUMBER_OF_SEAT];\n\n    public static void main(String[] args) {\n\n\t// ?¨??????\\???\n\tScanner sc = new Scanner(System.in);\n\n\tList<Integer> orders = new ArrayList<>();\n\n\twhile (sc.hasNextLine()) {\n\t    String nextLine = sc.nextLine();\n\t    if (\"\".equals(nextLine)) {\n\t\tbreak;\n\t    }\n\t    orders.add(Integer.parseInt(nextLine));\n\t}\n\n\t// ??\\???????????????????????§????????????\n\tint maxOrder = returnMax(orders);\n\n\t// ????????????????????????\n\tArrays.fill(waitingTime, -1);\n\n\t// ?????\\?????¬????????§?????????\n\texecuteSimulation(maxOrder);\n\n\t// ??????????????°?????????????????????????????????\n\tfor (Integer order : orders) {\n\t    System.out.println(waitingTime[order]);\n\t}\n\n\tsc.close();\n\n    }\n\n    private static void executeSimulation(int maxOrder) {\n\t// ????????????\n\tList<Integer> waintinGroup = new ArrayList<>();\n\n\t// ???????????§???????????????(?????????-1??¨??????)\n\tArrays.fill(shopSeatTimer, -1);\n\n\t// ????????????????????????????§?\n\n\tfor (int now = 0;; now++) {\n\n\t    // ?£?????????????????????????????????????????????????????£????????????????-1\n\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\n\t\t// ????????????????????????????????????????????????\n\t\tif (shopSeatTimer[i] != -1) {\n\t\t    shopSeatTimer[i]--;\n\t\t    // ???????????????0???????????????\n\t\t    if (shopSeatTimer[i] == 0) {\n\t\t\tshopSeatTimer[i] = -1;\n\t\t    }\n\t\t}\n\n\t    }\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now % INTERVAL == 0) {\n\t\twaintinGroup.add(now / INTERVAL);\n\t    }\n\n\t    // ????????????????????§???\n\t    while (true) {\n\t\tif (waintinGroup.isEmpty()) {\n\t\t    break;\n\t\t}\n\n\t\tint group = waintinGroup.get(0);\n\t\tint openSeatHead = canISitDown(group);\n\n\t\t// ???????????????????????°\n\t\tif (openSeatHead != -1) {\n\t\t    // ????????????????????????????´?\n\t\t    waitingTime[group] = now - group * INTERVAL;\n\n\t\t    // /**\n\t\t    // * ???????????°\n\t\t    // */\n\t\t    // System.out.println(\"??°??????????????????\" + group);\n\t\t    // System.out.println(\"????????????\" + waitingTime[group]);\n\t\t    // System.out.println(openSeatHead);\n\t\t    // for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\t\t    // System.out.print(shopSeatTimer[i] + \",\");\n\t\t    // }\n\t\t    // System.out.println();\n\t\t    // /*\n\t\t    // *\n\t\t    // */\n\n\t\t    // ?£?????????????????´?\n\t\t    for (int i = 0; i < howManymembers(group); i++) {\n\t\t\tshopSeatTimer[openSeatHead + i] = howLongToEat(group);\n\t\t    }\n\t\t    // ??????????????????\n\t\t    waintinGroup.remove(0);\n\n\t\t    // ?±??????????????????§??????????????°?????????????????????????????????\n\t\t    if (group == maxOrder) {\n\t\t\treturn;\n\t\t    }\n\n\t\t} else {\n\t\t    break;\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n    // ????????????????????§????????????\n    private static int returnMax(List<Integer> orders) {\n\tint maxOrder = 0;\n\tfor (Integer order : orders) {\n\t    maxOrder = Math.max(order, maxOrder);\n\t}\n\treturn maxOrder;\n\n    }\n\n    // ??§?????????????????????\n    private static int canISitDown(int group) {\n\tint count = 0;\n\tfor (int i = 0; i < NUMBER_OF_SEAT - howManymembers(group) + 1; i++) {\n\t    for (int j = 0; j < howManymembers(group); j++) {\n\t\tif (shopSeatTimer[i + j] == -1) {\n\t\t    count++;\n\t\t} else {\n\t\t    count = 0;\n\t\t    break;\n\t\t}\n\n\t\tif (count == howManymembers(group)) {\n\t\t    return i;\n\t\t}\n\t    }\n\t}\n\treturn -1;\n    }\n\n    // ????????°?????????????????????\n    private static int howManymembers(int group) {\n\treturn group % 5 == 1 ? 5 : 2;\n    }\n\n    // ?£???????????????????\n    private static int howLongToEat(int group) {\n\treturn 17 * (group % 2) + 3 * (group % 3) + 19;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        try {\n\n            // 入力\n            Scanner sc = new Scanner(System.in);\n            Map<Integer, Integer> targetAndResult = new LinkedHashMap<Integer, Integer>();\n            while (sc.hasNext()) {\n                targetAndResult.put(sc.nextInt(), 0);\n            }\n\n            // 席\n            int[] chairs = new int[17];\n            // 待ち行列\n            Deque<Integer> customers = new LinkedList<Integer>();\n            // 店に来た客グループ数\n            int cameGroupCount = 0;\n            // 経過時間数\n            int pastMinutes = 0;\n            // 座れた客グループ数\n            int sitGroupCount = 0;\n\n            // 1ループ = 1分\n            while (sitGroupCount <= 100) {\n\n                // 客が来る\n                boolean isCustomerCame = comeCustomer(customers, pastMinutes,\n                        cameGroupCount);\n\n                // 食べる\n                eat(chairs);\n\n                // 席に着く\n                int sitCustomerOnMinute = sit(chairs, customers, cameGroupCount);\n\n                // 後処理\n                if (isCustomerCame) {\n                    cameGroupCount++;\n                }\n\n                // 座れた人の時間の計測\n                for (int i = 1; i <= sitCustomerOnMinute; i++) {\n                    if (targetAndResult.containsKey(sitGroupCount)) {\n                        int waitMinutes = pastMinutes - (5 * (sitGroupCount));\n\n                        targetAndResult.put(sitGroupCount, waitMinutes);\n                    }\n\n                    sitGroupCount++;\n                }\n\n                pastMinutes++;\n\n            }\n\n            for (Entry<Integer, Integer> entry : targetAndResult.entrySet()) {\n                System.out.println(entry.getValue());\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(0);\n        }\n\n    }\n\n    private static boolean comeCustomer(Deque<Integer> customers, int minutes,\n            int cameGroupCount) {\n        if (cameGroupCount > 100) {\n            // 100人までしか来ない\n            return false;\n        }\n\n        if (minutes % 5 == 0) {\n            // 5分後に到着する\n            if (cameGroupCount % 5 == 1) {\n                // i%5 = 1のとき5人到着\n                customers.offer(5);\n            } else {\n                // それ以外は2人到着\n                customers.offer(2);\n            }\n            // 客が来た\n            return true;\n        }\n\n        // 客が来なかった\n        return false;\n    }\n\n    private static void eat(int[] chairs) {\n        for (int i = 0; i < chairs.length; i++) {\n            chairs[i] = (chairs[i] - 1) < 0 ? 0 : chairs[i] - 1;\n        }\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> customers,\n            int cameGroupCount) {\n        int sitGroupCount = 0;\n\n        Integer firstCustomersNumber = customers.peek();\n\n        if (firstCustomersNumber == null) {\n            // 客が待っていない場合には何もしない\n            return sitGroupCount;\n        }\n\n        int sequencialChair = 0;\n        int sittableChairStart = 0;\n        boolean sittable = false;\n        for (int i = 0; i < chairs.length; i++) {\n            // 席が空いているかどうかを判定\n            if (chairs[i] == 0) {\n                sequencialChair++;\n            } else {\n                sequencialChair = 0;\n            }\n\n            if (sequencialChair >= firstCustomersNumber) {\n                // 連続した席数が必要数に達していたら、その時点のインデックスを返却\n                sittableChairStart = i - (firstCustomersNumber - 1); // 必要席数なので、-1\n                sittable = true;\n                break;\n            }\n        }\n\n        if (!sittable) {\n            // 座れる席が無かった\n            return sitGroupCount;\n        }\n\n        // 待ち行列から削除して座れた扱いとする\n        sitGroupCount++;\n        customers.poll();\n\n        for (int j = 0; j < firstCustomersNumber; j++) {\n            // 席に所要時間をカウント\n            chairs[j + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れる可能性があるので、再帰呼出し\n        sitGroupCount += sit(chairs, customers, cameGroupCount);\n\n        // 座れた\n        return sitGroupCount;\n\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n/**\n * No 147\n * Time: 2h\n * Result : OK\n *\n */\npublic class Main {\n\n\t/** Group */\n\tprivate static class Group {\n\t\t/** group number */\n\t\tint i;\n\t\t\n\t\tint arriveTime;\n\t\t/** number of person */\n\t\tint person;\n\t\t\n\t\t/** Time to finish eating */\n\t\tint period;\n\t\t\n\t\tpublic Group(int i) {\n\t\t\tthis.i = i;\n\t\t\tthis.arriveTime = i * 5;\n\t\t\tthis.person = i%5 == 1 ? 5 : 2;\n\t\t\tthis.period = 17*(i % 2) + 3*(i % 3) + 19;\n\t\t}\n\t\t\n\t\tint eatStart = -1;\n\t\tpublic void setEatStart(int time) {\n\t\t\tthis.eatStart = time;\n\t\t}\n\t\tpublic int waitingTime() {\n\t\t\treturn eatStart - arriveTime;\n\t\t}\n\t}\n\t\n\tprivate static class Table {\n\t\t// this value is time to finish eating;\n\t\tprivate int[] table = new int[17];\n\t\t\n\t\tpublic void forwardTime(){\n\t\t\tfor (int i = 0; i < table.length;i++) {\n\t\t\t\tif (table[i] > 0) {\n\t\t\t\t\ttable[i] -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean welcomeGroupIfavailable(Group g) {\n\t\t\tTreeMap<Integer, Integer> available = new TreeMap<Integer, Integer>();\n\t\t\tint hit=-1;\n\t\t\t// find continue 0;\n\t\t\tfor (int i = 0; i < table.length;i++) {\n\t\t\t\tint t = table[i];\n\t\t\t\t\n\t\t\t\tif (t == 0){ // tabale is availabel\n\t\t\t\t\tif (hit < 0) {\n\t\t\t\t\t\thit = i;\n\t\t\t\t\t\tavailable.put(hit, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tavailable.put(hit, available.get(hit)+1);\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\thit = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(Map.Entry<Integer, Integer> e : available.entrySet()) {\n\t\t\t\tif(e.getValue() >= g.person) { // table is available for group;\n\t\t\t\t\tfor (int i = 0; i < g.person; i++) {\n\t\t\t\t\t\ttable[i + e.getKey()] = g.period;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic void dump(int time) {\n\n\t\t\tSystem.out.print(time + \":\");\n\t\t\tfor (int i :table) {\n\t\t\t\tSystem.out.print(i > 0 ? i+\"\" : \"_\");\n\t\t\t\tSystem.out.print(\",\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tList<Group> groups = new ArrayList<Group>();\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tgroups.add(new Group(i));\n\t\t}\n\n\t\tTable table = new Table();\n\n\t\t// start time loop\n\t\tLinkedList<Group> q = new LinkedList<Group>(); // waiting queue;\n\t\tint groupCount = 0;\n\t\tfor (int time = 0; ; time++){\n\t\t\t// arrive next group\n\t\t\t\n\t\t\tGroup next = groups.get(groupCount >= groups.size() ? groups.size()-1 : groupCount);\n\t\t\tif (time == next.arriveTime) {\n\t\t\t\tq.add(next);\n\t\t\t\tgroupCount++;\n\t\t\t}\n\t\t\t\n\t\t\t// change table state;\n\t\t\ttable.forwardTime();\n\t\t\t\n\t\t\t// welcome from q, if table is available\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tGroup g = q.peek();\n\t\t\t\tif (table.welcomeGroupIfavailable(g)) {\n\t\t\t\t\tg.setEatStart(time);\n\t\t\t\t\t//System.out.println(g.i + \";\" + g.arriveTime + \"<\" + g.eatStart + \":\" +g.person);\n\t\t\t\t\tq.poll(); // remove from queue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // not exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//table.dump(time);\n\t\t\t// end if final group start eating;\n\t\t\tif (groupCount >= groups.size() && next.eatStart >= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// calc is end. reading stdio. then\t answer;\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(s.hasNextInt()) {\n\t\t\tSystem.out.println(groups.get(s.nextInt()).waitingTime());\n\t\t}\n\t\ts.close();\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\t// ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n\t\tint[][] seats = new int[17][3];\n\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tfor (int doneTime = 0; doneTime < 3; doneTime++) {\n\t\t\t\tseats[count][doneTime] = 0;\n\t\t\t}\n\t\t}\n\t\t// ?????????????????£???????????????????´????????????????\n\t\tList<String> waitingCustomersList = new ArrayList<String>();\n\n\t\tList<String> list = new ArrayList<String>();\n\n\t\tList<String> waitingStartTimeList = new ArrayList<String>();\n\n\t\tList<String> appointedGroupList = new ArrayList<String>();\n\n\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tint group = 0;\n\t\tint timeGoesBy = 0;\n\t\tint numberOfCustomer = 0;\n\n\t\twhile (true) {\n\t\t\tString inputData = input.readLine();\n\n\t\t\t// ??\\???????????????null???????????????????????????????????????????????????\n\t\t\tif (inputData == null || inputData.equals(\"\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tappointedGroupList.add(inputData);\n\n\t\t}\n\n\t\twhile (true) {\n\n\t\t\t// ?£????????????£?????¢??????????????£??????????????????\n\t\t\tseats = getoutCustomer(seats, timeGoesBy);\n\n\t\t\tint countDelete = 0;\n\n\t\t\t// ?????£????????????????????§??£????????????\n\t\t\tfor (int count = 0; count < waitingCustomersList.size(); count++) {\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(Integer\n\t\t\t\t\t\t.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)))) {\n\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tInteger.parseInt(waitingCustomersList.get(count)));\n\n\t\t\t\t\tcountDelete++;\n\n\t\t\t\t\tfor (String appointedGroup : appointedGroupList) {\n\t\t\t\t\t\tif (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n\t\t\t\t\t\t\t\t.parseInt(appointedGroup)) {\n\n\t\t\t\t\t\t\tlist.add(Integer.toString(timeGoesBy\n\t\t\t\t\t\t\t\t\t- Integer.parseInt(waitingStartTimeList\n\t\t\t\t\t\t\t\t\t\t\t.get(count))));\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (int countt = 0; countt < countDelete; countt++) {\n\t\t\t\twaitingCustomersList.remove(0);\n\t\t\t\twaitingStartTimeList.remove(0);\n\t\t\t}\n\n\t\t\t// ??¢?????????\n\t\t\tif (timeGoesBy % 5 == 0) {\n\n\t\t\t\t// ??¢????????°???????????????\n\t\t\t\tnumberOfCustomer = getNumberOfHuman(group);\n\n\t\t\t\tif (waitingCustomersList.isEmpty()) {\n\t\t\t\t\t// ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n\t\t\t\t\tif (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\tgroup)) {\n\t\t\t\t\t\tseats = getSeats(seats, numberOfCustomer, timeGoesBy,\n\t\t\t\t\t\t\t\tgroup);\n\n\t\t\t\t\t\t// ???????????????????????????????????????????????????\n\t\t\t\t\t\tfor (int countLoop = 0; countLoop < appointedGroupList\n\t\t\t\t\t\t\t\t.size(); countLoop++) {\n\n\t\t\t\t\t\t\tif (group == Integer.parseInt(appointedGroupList\n\t\t\t\t\t\t\t\t\t.get(countLoop))) {\n\t\t\t\t\t\t\t\tlist.add(Integer.toString(0));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitingCustomersList.add(Integer.toString(group));\n\t\t\t\t\twaitingStartTimeList.add(Integer.toString(timeGoesBy));\n\t\t\t\t}\n\n\t\t\t\tgroup++;\n\t\t\t}\n\t\t\ttimeGoesBy++;\n\t\t\tif (list.size() == appointedGroupList.size()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (String waitingTime : list) {\n\t\t\tSystem.out.println(Integer.parseInt(waitingTime));\n\t\t}\n\t}\n\n\t// ??¢???????????§?????????????????????????????§????????°???????????????\n\tstatic int[][] getSeats(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tint count = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\t\t\t\tfor (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n\t\t\t\t\tseats[count1][0] = 1;\n\t\t\t\t\tseats[count1][1] = timeGoesBy;\n\t\t\t\t\tseats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n\t\t\t\t}\n\t\t\t\treturn seats;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\t}\n\n\tstatic boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n\t\t\tint timeGoesBy, int group) {\n\t\tint countAvailableSeats = 0;\n\t\tfor (int[] seat : seats) {\n\t\t\tif (seat[0] == 0) {\n\t\t\t\tcountAvailableSeats++;\n\t\t\t} else {\n\t\t\t\tcountAvailableSeats = 0;\n\t\t\t}\n\t\t\tif (countAvailableSeats == numberOfCustomer) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// ??¢????????°???????????????\n\tstatic int getNumberOfHuman(int group) {\n\t\tint judgeNumver = group % 5;\n\t\tif (judgeNumver == 1) {\n\t\t\treturn 5;\n\t\t} else {\n\t\t\treturn 2;\n\t\t}\n\n\t}\n\n\t// ?£????????????£?????¢??????????????????\n\tstatic int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n\t\tfor (int count = 0; count < 17; count++) {\n\t\t\tif (seats[count][1] + seats[count][2] == timeGoesBy) {\n\t\t\t\tseats[count][0] = 0;\n\t\t\t}\n\t\t}\n\t\treturn seats;\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Main {\n\n    /** 対象外 */\n    private static final int EXEMPT = -1;\n\n    /** グループ数 */\n    private static final int GROUP_NUM = 100;\n\n    /** 標準入力 */\n    private static BufferedReader br;\n\n    /** 座席数 最後の座席番号 */\n    private static int seatsNum, firstSeatNum;\n\n    /** 到着時間 客数 食事時間 待ち時間 */\n    private static int[] arriveMinutes, customersNum, mealMinutes, waitMinutes;\n\n    /** 座席 */\n    private static String[] seats;\n\n    /** 初期化 */\n    static {\n\n        br = new BufferedReader(new InputStreamReader(System.in));\n        seatsNum = 17;\n        arriveMinutes = new int[GROUP_NUM];\n        customersNum = new int[GROUP_NUM];\n        mealMinutes = new int[GROUP_NUM];\n        waitMinutes = new int[GROUP_NUM];\n        seats = new String[seatsNum];\n\n        for (int i = 0; i < GROUP_NUM; i++) {\n            // グループ数分繰り返す\n\n            // 到着時間\n            arriveMinutes[i] = 5 * i;\n\n            // 人数\n            customersNum[i] = i % 5 == 1 ? 5 : 2;\n\n            // 食事時間\n            mealMinutes[i] = seatsNum * (i % 2) + 3 * (i % 3) + 19;\n\n        }\n\n        // 待ち時間を作成\n        createWaitTimes();\n\n    }\n\n    /** 待ち時間を作成する */\n    private static void createWaitTimes() {\n        // 順番\n        int groupOrder;\n\n        // 行列リスト\n        List<Integer> waitList = new ArrayList<Integer>();\n\n        // 行列排除リスト\n        List<Integer> removeList = new ArrayList<Integer>();\n\n        for (int currentTime = 0, totalGroupNum = 0; totalGroupNum < GROUP_NUM; currentTime++) {\n            // 行列が終了するまで、一分毎に繰り返す\n\n            // 食事の時間が終了した客を離席させる\n            outCustomer(currentTime);\n\n            if ((groupOrder = arrivedCustomer(arriveMinutes, currentTime)) != EXEMPT) {\n                // 到着時間の場合\n\n                if (waitList.isEmpty()) {\n                    // 行列がない場合\n\n                    if (isEmpty(groupOrder)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(groupOrder));\n\n                        totalGroupNum++;\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列に並ばせる\n                        waitList.add(groupOrder);\n                    }\n\n                } else {\n                    // 行列がある場合\n\n                    // 行列に並ばせる\n                    waitList.add(groupOrder);\n                }\n            }\n\n            if (!waitList.isEmpty()) {\n                // 行列がある場合\n\n                // 行列番号\n                int i = 0;\n\n                for (int wait : waitList) {\n                    // 行列リスト分、繰り返す\n\n                    if (isEmpty(wait)) {\n                        // 着席可能の場合\n\n                        // 座席に着席させる\n                        setSeat(Integer.toString(wait));\n\n                        totalGroupNum++;\n\n                        // 待った時間を設定する\n                        waitMinutes[wait] = currentTime - arriveMinutes[wait];\n\n                        // 着席したグループを行列排除リストに追加する\n                        removeList.add(i);\n\n                    } else {\n                        // 着席不可の場合\n\n                        // 行列の先頭が着席できないため、残りの行列も着席不可にする。\n                        break;\n                    }\n                    i++;\n                }\n            }\n\n            if (!removeList.isEmpty()) {\n                // 行列排除リストに着席したグループが追加されていた場合\n\n                // リストの降順でソートする（リムーブするため）\n                Collections.reverse(removeList);\n\n                for (int remove : removeList) {\n                    // 行列排除リスト分、繰り返す\n\n                    // 行列リストから行列排除リストの番号を削除する\n                    waitList.remove(remove);\n                }\n\n                // 初期化\n                removeList = new ArrayList<Integer>();\n            }\n        }\n    }\n\n    /** メイン */\n    public static void main(String[] args) throws IOException {\n        String line;\n        List<Integer> inputList = new ArrayList<Integer>();\n\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            inputList.add(Integer.parseInt(line));\n        }\n        for (int input : inputList) {\n            System.out.println(waitMinutes[input]);\n        }\n\n    }\n\n    /** 現在時間に到着するグループ番号を検索し返す */\n    private static int arrivedCustomer(int[] targets, int currentTime) {\n        int order = 0;\n        for (int target : targets) {\n            if (target == currentTime) {\n                return order;\n            }\n            order++;\n        }\n        return EXEMPT;\n    }\n\n    /** 離席させる */\n    private static void outCustomer(int currentTime) {\n\n        // 席番\n        int seatNum = 0;\n\n        for (String seat : seats) {\n            // 座席数分繰り返す\n\n            if (seat == null) {\n                // 空席の場合\n                seatNum++;\n                continue;\n            }\n\n            if (currentTime - (arriveMinutes[Integer.parseInt(seat)]\n                    + waitMinutes[Integer.parseInt(seat)]) >= mealMinutes[Integer\n                        .parseInt(seat)]) {\n                // 食事の時間が終了した場合\n\n                // 空席にする\n                seats[seatNum] = null;\n            }\n            seatNum++;\n        }\n\n    }\n\n    /** 着席させる */\n    private static void setSeat(String groupsNum) {\n\n        for (int count = 0; count < customersNum[Integer.parseInt(groupsNum)]; count++) {\n            // 着席する人数分繰り返す\n\n            // 座席にグループ番号を設定する\n            seats[firstSeatNum++] = groupsNum;\n        }\n    }\n\n    /** 引数のグループ番号の客数分、空席かどうか確認する */\n    private static boolean isEmpty(int groupsNum) {\n\n        // 空席数\n        int emptyseatsNum = 0;\n        int i = 0;\n\n        for (; i < seatsNum || customersNum[groupsNum] <= seatsNum - i; i++) {\n            // 残座席数が客の数以下になるまで座席数分繰り返す\n\n            if (emptyseatsNum == customersNum[groupsNum]) {\n                // 連続した空席が客の数だけあった場合\n\n                break;\n\n            }\n\n            if (seats[i] == null) {\n                // 空席かつ繰り返す席が顧客数分以上存在する場合\n\n                emptyseatsNum++;\n\n                continue;\n\n            } else {\n                // 空席でない場合\n\n                // 空席数を初期化\n                emptyseatsNum = 0;\n            }\n        }\n        if (emptyseatsNum == customersNum[groupsNum]) {\n            // 空席の最初の座席番号を設定する\n            firstSeatNum = i - emptyseatsNum;\n\n            return true;\n        }\n\n        return false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint z[];\n\t\tint wait[];\n\t\tQueue<Integer> g = new LinkedList<Integer>();\n\n\t\tz = new int[17];\n\t\tArrays.fill(z, -1);\n\t\twait = new int[101];\n\t\tfor (int i = 0; i < 530; i++) {\n\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\tif (i - z[j] * 5 == 17 * (z[j] % 2) + 3 * (z[j] % 3) + 19) {\n\t\t\t\t\tz[j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i % 5 == 0) {\n\t\t\t\tg.add(i / 5);\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\twhile (g.peek() != null && flag) {\n\t\t\t\tflag = false;\n\t\t\t\tint m = g.peek() % 5 == 1 ? 5 : 2;\n\t\t\t\tint l = g.peek();\n\t\t\t\tint index = 0;\n\t\t\t\tboolean flag2 = false;\n\t\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t\t\tflag2 = true;\n\t\t\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\t\t\tif (17 <= j + k || 0 <= z[j + k]) {\n\t\t\t\t\t\t\tflag2 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag2) {\n\t\t\t\t\t\tindex = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag2) {\n\t\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\t\tz[index + j] = l;\n\t\t\t\t\t}\n\t\t\t\t\tg.poll();\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int x: g) {\n\t\t\t\twait[x]++;\n\t\t\t}\n\t\t\t//\t\t\tSystem.out.printf(\"%2d: \", i);\n\t\t\t//\t\t\tfor (int j = 0; j < 17; j++) {\n\t\t\t//\t\t\t\tSystem.out.printf(\"%2d\", z[j]);\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tfor (int x: g) {\n\t\t\t//\t\t\t\tSystem.out.printf(\"%2d\", x);\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\tSystem.out.println();\n\t\t}\n\t\twhile (sc.hasNext()) {\n\t\t\tn = sc.nextInt();\n\t\t\tSystem.out.println(wait[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\twhile (sc.hasNextLine()) {\n\t    String query = null;\n\t    query = sc.nextLine();\n\t    if (\"???\".equals(query) || query == null) {\n\t\tSystem.exit(0);\n\t    }\n\n\t    System.out.println(waitingTime[Integer.parseInt(query)][1] - waitingTime[Integer.parseInt(query)][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\topenStore: for (int now = 0;; now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now / 5 < 100 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    int groupId = waitingGroups.get(0);\n\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\n\t\t\t    // ???????????§??¢?????§??£??????????????????\n\t\t\t    if (groupId == 99) {\n\t\t\t\tbreak openStore;\n\t\t\t    }\n\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        exec();\n    }\n\n    private static void exec() {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // n番目グループ\n        int baseTime = 0; // 基準時間\n        int addGroupNo = -1; // 入店したグループNo\n        int groupMember = 0; // 入店したグループ人数\n        int blankStartSeatNo = -1; // 空席No\n\n        // 座席状態の初期化\n        Map<Integer, GroupStatus> seatStatusMap = initSeatStatus();\n\n        // 待ち行列の初期化\n        LinkedList<GroupStatus> queueStatusList = new LinkedList<GroupStatus>();\n\n        while (addGroupNo != n) {\n\n            // 座席の状態更新\n            updateSeatStatus(seatStatusMap, baseTime);\n\n            // 待ち行列の状態更新\n            updateQueueStatus(queueStatusList, baseTime);\n\n            for (int i = 0; i < queueStatusList.size(); i++) {\n\n                // 待ち行列の先頭グループ人数取得\n                groupMember = queueStatusList.peek().groupMember;\n\n                // 空席シートNoの取得\n                blankStartSeatNo = getBlankStartSeatNo(seatStatusMap, baseTime, groupMember);\n\n                if (blankStartSeatNo >= 0) {\n\n                    // 座席に先頭グループ追加\n                    addGroupNo =\n                        addSeat(seatStatusMap, queueStatusList, baseTime, blankStartSeatNo, n);\n\n                    // 待ち行列の先頭グループ削除\n                    queueStatusList.poll();\n                }\n            }\n\n            baseTime++;\n        }\n    }\n\n    /** n番目のグループ人数 */\n    private static int getGroupMember(int i) {\n\n        int result = i % 5;\n\n        // i%5 の結果が1であれば5を、1でなければ2を返却\n        if (result == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    /** n番目のグループの食事時間 */\n    private static int getMealTime(int i) {\n\n        int result = (17 * (i % 2)) + (3 * (i % 3)) + 19;\n        return result;\n    }\n\n    /** 待ち行列の状態更新 */\n    private static void updateQueueStatus(LinkedList<GroupStatus> queueStatusList, int time) {\n\n        // 待ち行列の更新\n        for (GroupStatus queueStatus : queueStatusList) {\n\n            queueStatus.endStayTime = time;\n        }\n\n        // 待ち行列の追加\n        if (time == 0) {\n\n            // 初回\n            int groupNo = 0;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n\n        } else if (time % 5 == 0) {\n\n            // 初回以降\n            int groupNo = time / 5;\n            int groupMember = getGroupMember(groupNo);\n\n            GroupStatus queueStatus = new GroupStatus(groupNo, groupMember, time, time, true);\n            queueStatusList.offer(queueStatus);\n        }\n    }\n\n    /** 座席状態の初期化 */\n    private static Map<Integer, GroupStatus> initSeatStatus() {\n\n        int seatNo = 17;\n        Map<Integer, GroupStatus> seatStatusMap = new HashMap<Integer, GroupStatus>(seatNo);\n        GroupStatus seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n\n        for (int i = 0; i < seatNo; i++) {\n\n            seatStatusMap.put((Integer) i, seatStatus);\n        }\n\n        return seatStatusMap;\n    }\n\n    /** 座席状態の更新 */\n    private static void updateSeatStatus(Map<Integer, GroupStatus> seatStatusMap, int time) {\n\n        GroupStatus seatStatus = new GroupStatus();\n\n        for (int i = 0; i < 17; ++i) {\n\n            if (seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいる場合\n\n                seatStatus = seatStatusMap.get(i);\n                seatStatus.endStayTime = time;\n\n                if ((seatStatus.endStayTime - seatStatus.startStayTime) == getMealTime(seatStatus.groupNo)) {\n\n                    // 滞在時間から着席時間を減算した値が食事時間と一致した場合\n\n                    // 座席ステータスを初期化\n                    seatStatusMap.remove(i);\n                    seatStatus = new GroupStatus(-1, 0, 0, 0, false);\n                    seatStatusMap.put((Integer) i, seatStatus);\n                }\n            }\n        }\n    }\n\n    /** 空席シートの取得 */\n    private static int getBlankStartSeatNo(Map<Integer, GroupStatus> seatStatusMap, int time,\n            int groupMember) {\n\n        int blankStartSeat = -1; // 空席開始No\n        int blankEndSeat = -1; // 空席終了No\n        boolean isCount = false; // 空席集計フラグ\n        boolean isEnableSeat = false; // 着席可能フラグ\n\n        for (int i = 0; i < 17; i++) {\n\n            if (!seatStatusMap.get(i).isStay) {\n\n                // 座席に客がいない場合\n\n                isCount = true;\n\n                if (blankStartSeat == -1) {\n\n                    blankStartSeat = i;\n                }\n\n                blankEndSeat = i;\n\n                if ((blankEndSeat - (blankStartSeat - 1)) >= groupMember) {\n\n                    isEnableSeat = true;\n                    break;\n                }\n\n            } else {\n\n                // 座席に客がいる場合\n\n                if (isCount) {\n\n                    blankEndSeat = i;\n\n                    if (((blankEndSeat - 1) - blankStartSeat) >= groupMember) {\n\n                        isEnableSeat = true;\n                        break;\n                    }\n\n                    // 初期化\n                    blankStartSeat = -1;\n                    blankEndSeat = -1;\n                    isCount = false;\n                }\n            }\n        }\n\n        if (isEnableSeat) {\n\n            return blankStartSeat;\n        }\n\n        return -1;\n    }\n\n    /** 座席に先頭グループ追加 */\n    private static int addSeat(Map<Integer, GroupStatus> seatStatusMap,\n            LinkedList<GroupStatus> queueStatusList, int baseTime, int blankStartSeatNo, int n) {\n\n        GroupStatus queueStatus = queueStatusList.peek();\n        int groupNo = queueStatus.groupNo;\n        int groupMember = queueStatus.groupMember;\n\n        for (int seatNo = blankStartSeatNo; seatNo < (blankStartSeatNo + groupMember); seatNo++) {\n\n            seatStatusMap.get(seatNo).groupNo = groupNo;\n            seatStatusMap.get(seatNo).groupMember = groupMember;\n            seatStatusMap.get(seatNo).startStayTime = baseTime;\n            seatStatusMap.get(seatNo).endStayTime = baseTime;\n            seatStatusMap.get(seatNo).isStay = true;\n        }\n\n        if (groupNo == n) {\n\n            System.out.println(queueStatus.endStayTime - queueStatus.startStayTime);\n        }\n\n        return groupNo;\n    }\n\n    static class GroupStatus {\n\n        public int groupNo;\n        public int groupMember;\n        public int startStayTime;\n        public int endStayTime;\n        public boolean isStay;\n\n        public GroupStatus() {\n\n        }\n\n        public GroupStatus(int groupNo, int groupMember, int startStayTime, int endStayTime,\n                boolean isStay) {\n            this.groupNo = groupNo;\n            this.groupMember = groupMember;\n            this.startStayTime = startStayTime;\n            this.endStayTime = endStayTime;\n            this.isStay = isStay;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        // ???????????§?????????????????????0?????????,1???????????????2????????????????????????3??????????£??????????\n        int[][] seats = new int[17][3];\n        for (int count = 0; count < 17; count++) {\n            for (int doneTime = 0; doneTime < 3; doneTime++) {\n                seats[count][doneTime] = 0;\n            }\n        }\n\n        // ?????????????????£???????????????????´????????????????\n        List<String> waitingCustomersList = new ArrayList<String>();\n\n        List<String> list = new ArrayList<String>();\n\n        List<String> waitingStartTimeList = new ArrayList<String>();\n\n        List<String> appointedGroupList = new ArrayList<String>();\n\n        BufferedReader input = new BufferedReader(new InputStreamReader(\n                System.in));\n\n        int group = 0;\n        int timeGoesBy = 0;\n        int numberOfCustomer = 0;\n\n        while (true) {\n            String inputData = input.readLine();\n            // ??\\???????????????null???????????????????????????????????????????????????\n            if (inputData == null || inputData.equals(\"\")) {\n                break;\n            }\n            appointedGroupList.add(inputData);\n        }\n\n        while (true) {\n            // ?£????????????£?????¢??????????????£??????????????????\n            seats = getoutCustomer(seats, timeGoesBy);\n            int countDelete = 0;\n            // ?????£????????????????????§??£????????????\n            for (int count = 0; count < waitingCustomersList.size(); count++) {\n                numberOfCustomer = getNumberOfHuman(Integer\n                        .parseInt(waitingCustomersList.get(count)));\n\n                if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                        Integer.parseInt(waitingCustomersList.get(count)))) {\n                    seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                            Integer.parseInt(waitingCustomersList.get(count)));\n                    countDelete++;\n                    for (String appointedGroup : appointedGroupList) {\n                        if (Integer.parseInt(waitingCustomersList.get(count)) == Integer\n                                .parseInt(appointedGroup)) {\n                            list.add(Integer.toString(timeGoesBy\n                                    - Integer.parseInt(waitingStartTimeList\n                                            .get(count))));\n                            break;\n                        }\n                    }\n                } else {\n                    break;\n                }\n            }\n\n            for (int countt = 0; countt < countDelete; countt++) {\n                waitingCustomersList.remove(0);\n                waitingStartTimeList.remove(0);\n            }\n            // ??¢?????????\n            if (timeGoesBy % 5 == 0||timeGoesBy==0) {\n                // ??¢????????°???????????????\n                numberOfCustomer = getNumberOfHuman(group);\n                if (waitingCustomersList.isEmpty()) {\n                    // ??????????????????????????????????????°?????????????????????????????°???????????????????????????\n                    if (isSeatsAvailable(seats, numberOfCustomer, timeGoesBy,\n                            group)) {\n                        seats = getSeats(seats, numberOfCustomer, timeGoesBy,\n                                group);\n                        // ???????????????????????????????????????????????????\n                        for (int countLoop = 0; countLoop < appointedGroupList\n                                .size(); countLoop++) {\n                            if (group == Integer.parseInt(appointedGroupList\n                                    .get(countLoop))) {\n                                list.add(Integer.toString(0));\n                            }\n                        }\n                    } else {\n                        waitingCustomersList.add(Integer.toString(group));\n                        waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                    }\n                } else {\n                    waitingCustomersList.add(Integer.toString(group));\n                    waitingStartTimeList.add(Integer.toString(timeGoesBy));\n                }\n                group++;\n            }\n            timeGoesBy++;\n\n            if (list.size() == appointedGroupList.size()) {\n                break;\n            }\n        }\n        for (String waitingTime : list) {\n            System.out.println(Integer.parseInt(waitingTime));\n        }\n    }\n\n    // ??¢???????????§?????????????????????????????§????????°???????????????\n    static int[][] getSeats(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        int count = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            count++;\n            if (countAvailableSeats == numberOfCustomer) {\n                for (int count1 = count - numberOfCustomer; count1 < count; count1++) {\n                    seats[count1][0] = 1;\n                    seats[count1][1] = timeGoesBy;\n                    seats[count1][2] = 17 * (group % 2) + 3 * (group % 3) + 19;\n                }\n                return seats;\n            }\n        }\n        return seats;\n    }\n\n    static boolean isSeatsAvailable(int[][] seats, int numberOfCustomer,\n            int timeGoesBy, int group) {\n        int countAvailableSeats = 0;\n        for (int[] seat : seats) {\n            if (seat[0] == 0) {\n                countAvailableSeats++;\n            } else {\n                countAvailableSeats = 0;\n            }\n            if (countAvailableSeats == numberOfCustomer) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // ??¢????????°???????????????\n    static int getNumberOfHuman(int group) {\n        int judgeNumver = group % 5;\n        if (judgeNumver == 1) {\n            return 5;\n        } else {\n            return 2;\n        }\n    }\n\n    // ?£????????????£?????¢??????????????????\n    static int[][] getoutCustomer(int[][] seats, int timeGoesBy) {\n        for (int count = 0; count < 17; count++) {\n            if (seats[count][1] + seats[count][2] == timeGoesBy) {\n                seats[count][0] = 0;\n                seats[count][1] = 0;\n                seats[count][2] = 0;\n\n            }\n        }\n        return seats;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tScanner sc;\n\tint[] enter;\n\tint time(int n){\n\t\treturn 17*(n%2)+3*(n%3)+19; \n\t}\n\t\n\tvoid solve(){\n\t\tint[] seats=new int[17];\n\t\tArrays.fill(seats,-1);\n\t\tLinkedList<Integer> queue=new LinkedList<Integer>();\n\t\t\n\t\tint[] finish=new int[100];\n\t\tenter=new int[100];\n\t\t\n\t\tint nq=0,ns=0;\n\t\tfor(int t=0;ns<100;++t){\n\t\t\t//離席\n\t\t\tfor(int i=0;i<17;++i){\n\t\t\t\tif(seats[i]!=-1&&t>=finish[seats[i]]){\n\t\t\t\t\tseats[i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//来店\n\t\t\tif(nq<100&&t%5==0){\n\t\t\t\tqueue.add(nq++);\n\t\t\t}\n\t\t\t//空席判定\n\t\t\tfor(int i=0;i<17&&!queue.isEmpty();++i){\n\t\t\t\tif(seats[i]==-1){\n\t\t\t\t\t//[i,j[ : 連続空席\n\t\t\t\t\tint j=i;\n\t\t\t\t\tfor(;j<17&&seats[j]==-1;++j);\n\t\t\t\t\tint s=j-i;\n\t\t\t\t\t//店に這入れるなら入れる\n\t\t\t\t\t//p:客数\n\t\t\t\t\tint p=(queue.peek()%5==1)?5:2;\n\t\t\t\t\tif(s>=p){\n\t\t\t\t\t\tint group=queue.poll();\n\t\t\t\t\t\tfor(int k=i;k<i+p;++k){\n\t\t\t\t\t\t\tseats[k]=group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tenter[group]=t;\n\t\t\t\t\t\tfinish[group]=t+time(group);\n\t\t\t\t\t\t++ns;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug(t,seats);\n\t\t}\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\tsolve();\n\t\twhile(sc.hasNext()){\n\t\t\tint n=ni();\n\t\t\tSystem.out.println(enter[n]-n*5);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t/** ??°???????????° */\n\tstatic final int MAX_GROUP_NUKMBER = 100;\n\n\t/**  */\n\tstatic final int TIME_INTERVAL = 5;\n\n\t/** ??§????????? */\n\tstatic int[] sheets = new int[17];\n\n\t/** ?????????????????? */\n\tstatic int[] waitTimes = new int[100];\n\n\t/** ??????????????? */\n\tstatic List<Integer> inputs = new ArrayList<Integer>();\n\n\t/** ?????§??°??????????????? */\n\tstatic int maxGroupNumber;\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (scanner.hasNextInt()) {\n\t\t\tint inputNum = scanner.nextInt();\n\t\t\tif (maxGroupNumber < inputNum) {\n\t\t\t\tmaxGroupNumber = inputNum;\n\t\t\t}\n\t\t\tinputs.add(inputNum);\n\t\t}\n\n\t\t// ???????°??????°???????????????\n\t\tint endGroup = 0;\n\t\t// ???????????°???????????????\n\t\tint frontGroup = 0;\n\t\t// ??????????????????????????????\n\t\tint time = 0;\n\n\t\twhile (true) {\n\t\t\t// 5???????????§???????°??????°???????????????????????????????????????????????§??°??\\???????¢?????????????\n\t\t\tif (time % TIME_INTERVAL == 0 && endGroup < MAX_GROUP_NUKMBER) {\n\t\t\t\tendGroup++;\n\t\t\t}\n\n\t\t\t// ??¢????????¢\n\t\t\tfor (int i = frontGroup; i < endGroup; i++) {\n\t\t\t\tint ninzu = i % 5 == 1 ? 5 : 2;\n\t\t\t\tint startPos = getOpendSheetsPosition(ninzu);\n\t\t\t\tif (startPos >= 0) {\n\t\t\t\t\t// ??§????????´???\n\t\t\t\t\tsecureSheets(startPos, calcMealtime(i),\n\t\t\t\t\t\t\tninzu);\n\t\t\t\t\twaitTimes[i] = time - i * 5;\n\t\t\t\t\tfrontGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// ??§???????????´???\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// ??\\??????????????°???????????????????????§?????????????????§?????????100???????????§??£????????????\n\t\t\tif (frontGroup == MAX_GROUP_NUKMBER || frontGroup > maxGroupNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// ??§??????????????????????????????????????????\n\t\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\t\tif (sheets[i] > 0) {\n\t\t\t\t\tsheets[i] = sheets[i] - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int input : inputs) {\n\t\t\tSystem.out.println(waitTimes[input]);\n\t\t}\n\t}\n\n\t/**\n\t * ????????????????????????????????????????????´????????? ??????????????????????????´??????-1????????´?????????\n\t *\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t * @return ????????????????????????????????????\n\t */\n\tprivate static int getOpendSheetsPosition(int peopleNum) {\n\t\tint startPos = -1;\n\t\tint openedSheetNum = 0;\n\t\tfor (int i = 0; i < sheets.length; i++) {\n\t\t\tif (sheets[i] == 0) {\n\t\t\t\tif (startPos == -1) {\n\t\t\t\t\tstartPos = i;\n\t\t\t\t}\n\t\t\t\topenedSheetNum++;\n\t\t\t} else {\n\t\t\t\tstartPos = -1;\n\t\t\t\topenedSheetNum = 0;\n\t\t\t}\n\n\t\t\tif (openedSheetNum == peopleNum) {\n\t\t\t\treturn startPos;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * ??°?????????????????????????£??????????????¨??????????\n\t *\n\t * @param targetGroup\n\t *            ????±??????°???????????????\n\t * @return ?£??????????\n\t */\n\tprivate static int calcMealtime(int targetGroup) {\n\t\treturn 17 * (targetGroup % 2) + 3 * (targetGroup % 3) + 19;\n\t}\n\n\t/**\n\t * ???????¢?????????????\n\t *\n\t * @param startPos\n\t *            ????¢?????????????????????????\n\t * @param mealtime\n\t *            ?£??????????\n\t * @param peopleNum\n\t *            ??°?????????????????°\n\t */\n\tprivate static void secureSheets(int startPos, int mealtime, int peopleNum) {\n\t\tfor (int i = 0; i < peopleNum; i++) {\n\t\t\tsheets[i + startPos] = mealtime;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        int customerCount = 0;\n        int[] waitTime = new int[100];\n\n        while (customerCount < 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == groupMembers[headGroup % 5]) {\n                        startIndex = i - (groupMembers[headGroup % 5] - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime[headGroup] = pastMinutes - (headGroup * 5);\n                    for (int i = startIndex; i < (startIndex + groupMembers[headGroup % 5]); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                    customerCount++;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime[sc.nextInt()]);\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tScanner sc = new Scanner(System.in);\n\tint [][] data;\n\tint [] table;\n\tLinkedList<Integer> mat;\n\t\n\tprivate void doit(){\n\t\tdata = new int[100][2];\n\t\tinit();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(data[n][1] - data[n][0]);\n\t\t}\n\t}\n\n\tprivate void init() {\n\t\ttable = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tmat = new LinkedList<Integer>();\n\t\tfor(int i = 0;i < 46; i++){\n\t\t\tif(i != 0 && isOK()) break;\n\t\t\tout(i);\n\t\t\tif(i % 5 == 0 && i / 5  < 100){\n\t\t\t\tdata[i / 5][0] = i;\n\t\t\t\tmat.addLast(i / 5);\n\t\t\t}\n\t\t\twhile(in(i)){\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tprivate boolean in(int time) {\n\t\tif(mat.isEmpty()) return false;\n\t\tint nextid = mat.getFirst();\n\t\tint num = 0;\n\t\tif(nextid % 5 == 1){\n\t\t\tnum = 5;\n\t\t}\n\t\telse{\n\t\t\tnum = 2;\n\t\t}\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1) continue;\n\t\t\tint now = 1;\n\t\t\tfor(int j = i + 1; j < table.length; j++){\n\t\t\t\tif(table[j] == -1){\n\t\t\t\t\tnow++;\n\t\t\t\t\tif(now == num){\n\t\t\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\t\t\ttable[i + k] = nextid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[nextid][1] = time;\n\t\t\t\t\t\tmat.removeFirst();\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void out(int time) {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] >= 0){\n\t\t\t\tint id = table[i];\n\t\t\t\tint res = data[id][0] + 17 * (id % 2) + 3 * (id % 3) + 19;\n\t\t\t\tif(res == time){\n\t\t\t\t\ttable[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK() {\n\t\tfor(int i = 0; i < table.length; i++){\n\t\t\tif(table[i] != -1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = ((headGroup * 5) < pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        for (int i = 0; i < waitTime.size(); i++) {\n            System.out.println(waitTime.get(i));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\t/** ??§?????° */\n\tprivate final static int SEATS = 17;\n\n\t/** ??¢??°???????????° */\n\tprivate final static int GROUP = 10;\n\n\t/** ??¢??°??????????????°???????????????????????? */\n\tprivate final static int INTERVAL = 5;\n\n\t/** ??¢??°???????????????????????????????´????????????? */\n\tprivate static int[] watingTimes = new int[GROUP];\n\n\t/** ??¢??°??????????????°?????????????????°????£?????????????????´???????????¬?????????? */\n\tprivate static int[][] groupInfo = new int[GROUP][3];\n\n\t/** ??¢??°??????????????°??????????????¨???????????? */\n\tprivate final static int GROUP_INFO_ARRIVAL = 0;\n\n\t/** ??¢??°?????????????????°?????¨???????????? */\n\tprivate final static int GROUP_INFO_PERSONS = 1;\n\n\t/** ??¢??°?????????????£???????????????¨???????????? */\n\tprivate final static int GROUP_INFO_EATING_MINUTES = 2;\n\n\t/** ??§??????????????¶??????????´????????????? */\n\tprivate static int[] seatsCondition = new int[SEATS];\n\n\t/** ???????????????????????????????????? */\n\tprivate static boolean openFlag = true;\n\n\t/** ???????????°???????????°????????? */\n\tprivate static int lastArrivalGroup = -1;\n\n\t/** ????????°???????????° */\n\tprivate static int watingGroups = 0;\n\n\t/** ??£????????????????????????????????? */\n\tprivate static int passedMinutes = 0;\n\n\t/**\n\t * ???????????????????¨?????????¢??°??????????????????????????????????????????\n\t *\n\t * @param args\n\t *            ?????¨????????????\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic static void main(String[] args) throws NumberFormatException,\n\t\t\tIOException {\n\n\t\t// ??\\?????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\t\tString line = null;\n\t\twhile (!\"\".equals(line = br.readLine())) {\n\t\t\t\tinputList.add(Integer.parseInt(line));\n\t\t}\n\n\t\t// ??¨??¢??°??????????????°???????????¨?????°??¨?£??????????????±???????\n\t\tsetGroupInfo();\n\n\t\twhile (openFlag) {\n\n\t\t\t// ???????????§?¬??????°??????????????°?????????\n\t\t\tif (passedMinutes % INTERVAL == 0) {\n\t\t\t\tlastArrivalGroup++;\n\t\t\t\twatingGroups++;\n\t\t\t}\n\n\t\t\t// ????????°??????????????????????????°???????????????\n\t\t\tif (watingGroups == 0) {\n\t\t\t\tpassedMinutes++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean vacancyFlag = true; // ??????????????¨?????????\n\t\t\tint nextGroup = lastArrivalGroup - watingGroups + 1; // ????????????????????°???????????????\n\n\t\t\t// ????????°???????????????????????????????????¨????????´????????????????????????????????????????????§????????????\n\t\t\twhile (watingGroups != 0 && vacancyFlag) {\n\t\t\t\tint numberOfPersons = groupInfo[nextGroup][GROUP_INFO_PERSONS]; // ???????????°?????????????????°\n\n\t\t\t\t// ???????????°????????????????????§????????§????????????????±???????\n\t\t\t\tint seatNumber = getSeatNumber(numberOfPersons);\n\n\t\t\t\tif (seatNumber != -1) {\n\n\t\t\t\t\t// ????????§????????§???????????£?????´????????§??????????????????????¨??????????\n\t\t\t\t\tfor (int i = 0; i < numberOfPersons; i++) {\n\t\t\t\t\t\tseatsCondition[seatNumber] = passedMinutes\n\t\t\t\t\t\t\t\t+ groupInfo[nextGroup][GROUP_INFO_EATING_MINUTES];\n\t\t\t\t\t\tseatNumber++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// ??°????????????????????????????¨??????????\n\t\t\t\t\twatingTimes[nextGroup] = passedMinutes\n\t\t\t\t\t\t\t- groupInfo[nextGroup][GROUP_INFO_ARRIVAL];\n\n\t\t\t\t\t// ????????°???????????°????????????\n\t\t\t\t\twatingGroups--;\n\t\t\t\t\tnextGroup = lastArrivalGroup - watingGroups + 1;\n\t\t\t\t} else {\n\t\t\t\t\tvacancyFlag = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpassedMinutes++;\n\n\t\t\t// ???????????°??????????????§??£??????????????????????????????\n\t\t\tif (nextGroup == GROUP - 1) {\n\t\t\t\topenFlag = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i : inputList) {\n\t\t\tSystem.out.println(watingTimes[i]);\n\t\t}\n\t}\n\n\tprivate static void setGroupInfo() {\n\n\t\tfor (int i = 0; i < GROUP; i++) {\n\t\t\tgroupInfo[i][GROUP_INFO_ARRIVAL] = i * INTERVAL;\n\t\t\tgroupInfo[i][GROUP_INFO_PERSONS] = (i % 5 == 1 ? 5 : 2);\n\t\t\tgroupInfo[i][GROUP_INFO_EATING_MINUTES] = 17 * (i % 2) + 3\n\t\t\t\t\t* (i % 3) + 19;\n\t\t}\n\n\t}\n\n\tprivate static int getSeatNumber(int numberOfPersons) {\n\n\t\tint seatNumber = 0; // ???????????§?????????\n\t\tint vacancySeats = 0; // ????????°\n\n\t\tfor (int i = 0; i < SEATS; i++) {\n\n\t\t\t// ??????????????¨?????£?????§?????????????????????\n\t\t\tif (seatsCondition[i] <= passedMinutes) {\n\t\t\t\tseatsCondition[i] = 0;\n\t\t\t}\n\n\t\t\tif (seatsCondition[i] == 0) {\n\n\t\t\t\t// ??????????????§????????°???????????°????¢???????\n\t\t\t\tvacancySeats++;\n\n\t\t\t\t// ????????°??????????????°??¨??????????????°??????????????§??????????????????\n\t\t\t\tif (vacancySeats == numberOfPersons) {\n\t\t\t\t\treturn seatNumber;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// ??????????????§???????????°?????§?????????????¬?????§???????????????°???0?????????\n\t\t\t\tseatNumber = i + 1;\n\t\t\t\tvacancySeats = 0;\n\t\t\t}\n\t\t}\n\n\t\t// ????????????????????°-1?????????\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    // 店のカウンター\n    static int[] serviceCouters;\n    // 次に到着するグループ番号\n    static int nextArrivalGroupNumber;\n    // 待ち行列作成(到着したグループを格納)\n    static LinkedList<Integer> waitGroupNumberList;\n    // 正午から現在までの経過時間（分）\n    static int currentTime;\n\n    // 各グループの情報を登録（添え字はグループ番号を表す）\n    // グループの人数\n    static List<Integer> groupNumberOfPeopleList;\n    // 店に到着する時間（分）\n    static List<Integer> arrivalTimeList;\n    // 食事時間（分）\n    static List<Integer> eatTimeList;\n    // 席に着いた時間（分）\n    static List<Integer> sitTimeList;\n    // 待ち時間（分）\n    static List<Integer> waitTimeList;\n\n    // 初期化\n    public static void init() {\n        serviceCouters = new int[17];\n        // 空席を\"-1\"とするため、\"-1\"で初期化\n        Arrays.fill(serviceCouters, -1);\n        nextArrivalGroupNumber = 0;\n        waitGroupNumberList = new LinkedList<Integer>();\n        currentTime = 0;\n        groupNumberOfPeopleList = new ArrayList<Integer>();\n        arrivalTimeList = new ArrayList<Integer>();\n        eatTimeList = new ArrayList<Integer>();\n        sitTimeList = new ArrayList<Integer>();\n        waitTimeList = new ArrayList<Integer>();\n    }\n\n    public static void main(String[] args) {\n\n        // 入力値を一行分取得する。\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Integer inputNumber = null;\n        while (true) {\n            try {\n                inputNumber = Integer.valueOf(br.readLine());\n            } catch (IOException e) {\n                System.out.println(\"inputError\" + e.getMessage());\n            }\n            if (inputNumber == null) {\n                break;\n            }\n\n            // 変数の初期化\n            init();\n            // 各グループの情報を登録する。（入力されたグループ番号まで）\n            for (int i = 0; i <= inputNumber; i++) {\n                arrivalTimeList.add(calArrivalTime(i));\n                groupNumberOfPeopleList.add(calgroupNumberOfPeople(i));\n                eatTimeList.add(calEatTime(i));\n            }\n\n            // メイン処理開始\n            while (true) {\n                // 次に到着するグループがいるか調べ、いれば待ち行列の最後尾にセットする\n                if (inputNumber >= nextArrivalGroupNumber) {\n                    if (currentTime == arrivalTimeList.get(nextArrivalGroupNumber)) {\n                        waitGroupNumberList.offer(nextArrivalGroupNumber);\n                        nextArrivalGroupNumber++;\n                    }\n                }\n\n                // 食べ終わったグループに退店される\n                exitGroup();\n\n                // 待っているグループがいれば着席させる\n                sitGroup();\n\n                // 現在時刻を1分進める\n                currentTime++;\n\n                // 終了条件\n                // 入力されたグループ番号まで客を入店させ、最後のグループが着席（待ち行列が空）すれば終了\n                if ((inputNumber + 1) == nextArrivalGroupNumber && waitGroupNumberList.isEmpty()) {\n                    break;\n                }\n            }\n            System.out.println(waitTimeList.get(inputNumber));\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 食べ終わったグループがいればに退店させる。</p>\n     * <p> [説明] グループが着席してからの経過時間を調べ、食事時間と一致すれば退店させる。</p>\n     */\n    private static void exitGroup() {\n        for (int i = 0; i < serviceCouters.length; i++) {\n            if (serviceCouters[i] != -1) {\n                // 食事が終了したか判定\n                if (eatTimeList.get(serviceCouters[i]) == (currentTime - sitTimeList.get(serviceCouters[i]))) {\n                    int emptyCounter = serviceCouters[i];\n                    // グループの人数分空席にする\n                    for (int j = 0; j < groupNumberOfPeopleList.get(emptyCounter); j++) {\n                        serviceCouters[i + j] = -1;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * <p> [機能] 空席があれば待っているグループに座らせる。</p>\n     * <p> [説明] 待ち行列の先頭のグループと店の空席を確認し、座らせる。</p>\n     * <p> [備考] 着席時間と待ち時間を設定する。</p>\n     */\n    private static void sitGroup() {\n        while (!(waitGroupNumberList.isEmpty())) {\n            int firstWaitGroupNumber = waitGroupNumberList.poll();\n            int firstCountNumber = getSeriesChairs(firstWaitGroupNumber);\n            // 座れる席がない場合\n            if (firstCountNumber == -1) {\n                // 待ち行列にグループを戻す\n                waitGroupNumberList.addFirst(firstWaitGroupNumber);\n                break;\n            }\n            for (int i = 0; i < groupNumberOfPeopleList.get(firstWaitGroupNumber); i++) {\n                serviceCouters[firstCountNumber + i] = firstWaitGroupNumber;\n            }\n            // 着席時間を設定\n            sitTimeList.add(currentTime);\n            // 待ち時間を設定\n            waitTimeList.add(currentTime - arrivalTimeList.get(firstWaitGroupNumber));\n\n        }\n    }\n\n    private static void printCustomer() {\n        System.out.print(\"No\\t\\t到着時間\\t人数\\t\\t食事時間\");\n        System.out.print(\"\");\n        System.out.println(\"\");\n        for (int i = 0; i < arrivalTimeList.size(); i++) {\n            System.out.print(i + \"\\t\\t\");\n            System.out.print(arrivalTimeList.get(i) + \"\\t\\t\");\n            System.out.print(groupNumberOfPeopleList.get(i) + \"\\t\\t\");\n            System.out.println(eatTimeList.get(i));\n        }\n    }\n\n    private static void printQuere() {\n        System.out.print(\"キュー＝\");\n        for (Iterator<Integer> it = waitGroupNumberList.iterator(); it.hasNext();) {\n            System.out.print(it.next());\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void printCounter() {\n        System.out.print(currentTime + \"：[\");\n        for (int a : serviceCouters) {\n            System.out.print(a + \", \");\n        }\n        System.out.println(\"]\");\n    }\n\n    /**\n     * \n     * <p> [機能] カウンターの先頭から空席を調べ、<br>\n     *                    連続した空席が入力値以上になれば連続した空席の最も小さい席番号を返す。<br>\n     *                    それ以外は-1を返す。</p>\n     *@param firstWaitGroupNumber グループ番号\n     * @return  連続空席の最も小さい席番号\n     */\n    private static int getSeriesChairs(int firstWaitGroupNumber) {\n\n        for (int startPoint = 0; startPoint < serviceCouters.length; startPoint++) {\n            if (serviceCouters[startPoint] == -1) {\n                for (int endpoint = startPoint + 1; endpoint < serviceCouters.length; endpoint++) {\n                    // 空席でないもしくは最後の席の場合\n                    if (serviceCouters[endpoint] != -1 || serviceCouters.length == endpoint + 1) {\n                        // 連続空席がグループの人数以上か判定\n                        if (Math.abs(startPoint - endpoint) >= groupNumberOfPeopleList\n                                .get(firstWaitGroupNumber)) {\n                            return startPoint;\n                        }\n                        startPoint = endpoint + 1;\n                        break;\n                    }\n                }\n            }\n        }\n        // 座れる席がない場合は-1を返す\n        return -1;\n    }\n\n    /**\n     * <p> [機能] グループの人数を計算する。 </p>\n     */\n    public static int calgroupNumberOfPeople(int GroupNumber) {\n        if (GroupNumber % 5 == 1) {\n            return 5;\n        }\n        return 2;\n    }\n\n    /**\n     * <p> [機能] 食事時間を計算する。 </p>\n     */\n    public static int calEatTime(int GroupNumber) {\n        return 17 * (GroupNumber % 2) + 3 * (GroupNumber % 3) + 19;\n    }\n\n    /**\n     * <p> [機能] 店への到着時間の計算する。 </p>\n     */\n    public static int calArrivalTime(int GroupNumber) {\n        return GroupNumber * 5;\n    }\n\n    /**\n     * <p> [機能] 到着したグループ番号に1を加算する。</p>\n     * @param arrivaledGroupNumber 到着したグループ番号\n     */\n    public static void addNextArrivaledGroupNumber(Integer arrivaledGroupNumber) {\n        nextArrivalGroupNumber++;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        List<Integer> waitTime = new ArrayList<Integer>();\n\n        while (waitTime.size() <= 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int needsSequencialSeats = groupMembers[headGroup % 5];\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == needsSequencialSeats) {\n                        startIndex = i - (needsSequencialSeats - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + needsSequencialSeats); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            // debug\n            System.out.println(pastMinutes);\n            for (int chair : seats) {\n                String s = \"0\" + Integer.valueOf(chair);\n                System.out.print(s.substring(s.length() - 2) + \",\");\n            }\n            System.out.println();\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    private static int KUUSEKI = 9999;\n\n    private static int TIME = 999999;\n\n    private static int SEATNUM = 17;\n\n    /**\n     * <p> [機能] 各入力値について、n番目のお客の分単位の待ち時間(0以上の整数) を出力する。 </p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param args\n     * @throws IOException\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader stdReader = new BufferedReader(new InputStreamReader(System.in));\n        List<Integer> inputlist = new ArrayList<Integer>();\n\n        String line;\n        int maxInput = 0;\n        int intLine;\n\n        while ((line = stdReader.readLine()) != null) { // ユーザの一行入力を待つ\n            // 空文字が入力されたら入力値の取得を終了する\n            if (line.equals(\"\")) {\n                break;\n            }\n            // listに入力値の1行分を格納する。\n            intLine = Integer.valueOf(line);\n            if (intLine > maxInput) {\n                maxInput = intLine;\n            }\n            inputlist.add(intLine);\n        }\n        stdReader.close();\n\n        // 17席分空席として用意する。\n        int[] seats = new int[SEATNUM];\n        for (int i = 0; i < SEATNUM; i++) {\n            seats[i] = KUUSEKI;\n        }\n\n        List<int[]> groupInfo = new ArrayList<int[]>();\n        List<int[]> sittingGroupInfo = new ArrayList<int[]>();\n\n        // 時間の経過とともに変化する条件の処理\n        for (int minutes = 0; minutes < TIME; minutes++) {\n\n            // 最大入力値よりも大きくなったら処理を終了する。\n            int groupMaxCount = sittingGroupInfo.size();\n            if (groupMaxCount > 0 && maxInput == sittingGroupInfo.get(groupMaxCount - 1)[0]) {\n                break;\n            }\n\n            // 食べ終わっていたら退店させる。\n            for (int n = 0; n < sittingGroupInfo.size(); n++) {\n                int[] eatenGroup = sittingGroupInfo.get(n);\n                if (minutes == eatenGroup[2]) {\n                    for (int i = 0; i < SEATNUM; i++) {\n                        if (seats[i] == eatenGroup[0]) {\n                            seats[i] = KUUSEKI;\n                        }\n                    }\n                }\n            }\n\n            // 客が入店するかチェック\n            if (minutes % 5 == 0) {\n                groupInfo.add(inputGroupInfo(minutes));\n            }\n\n            // 並んでいるグループの先頭が座れるかどうか判定する。\n            int groupCount = groupInfo.size();\n            for (int k = 0; k < groupCount; k++) {\n                int[] comingGroup = groupInfo.get(0);\n                int kuusekiCount = 0;\n                boolean firstCustomer = false;\n                // 席が空いているどうか判定する。\n                for (int i = 0; i < SEATNUM; i++) {\n                    if (seats[i] == KUUSEKI) {\n                        kuusekiCount = kuusekiCount + 1;\n                    } else {\n                        kuusekiCount = 0;\n                    }\n                    // 座れた場合には、座席にグループ番号を入力し、待ち時間を取得する。\n                    if (kuusekiCount == comingGroup[1]) {\n                        for (int m = 0; m < comingGroup[1]; m++) {\n                            seats[i - m] = comingGroup[0];\n                        }\n                        // 待ち時間を取得する。\n                        int waitedTime = minutes - comingGroup[3];\n                        int[] sittingGroupDetails = {comingGroup[0], waitedTime, comingGroup[4]};\n\n                        sittingGroupInfo.add(sittingGroupDetails);\n                        // 先頭客の情報を削除する。\n                        groupInfo.remove(0);\n                        // 先頭の人が入れたら次の人が入れる。\n\n                        firstCustomer = true;\n                        break;\n                    }\n                }\n                if (!firstCustomer) {\n                    // 先頭の人が入れなかった場合は後ろの人も入れないので処理を終了する。\n                    break;\n                }\n            }\n        }\n        // 入力値と一致した場合は出力を行う\n        for (int[] outputInfo : sittingGroupInfo) {\n            for (int input : inputlist) {\n                if (input == outputInfo[0]) {\n                    System.out.println(outputInfo[1]);\n                }\n            }\n        }\n    }\n\n    /**\n     * <p> [機能] 5分ごとに入店するグループの情報を配列に格納する。</p>\n     * <p> [説明] 特になし。</p>\n     * <p> [備考] 特になし。</p>\n     * @param time\n     * @return\n     */\n    private static int[] inputGroupInfo(int time) {\n        int group = 0;\n        int groupNumber = 0;\n        int eatingTime = 0;\n        int eatenTime = 0;\n\n        // グループ番号\n        group = time / 5;\n\n        // グループ人数\n        if (group % 5 == 1) {\n            groupNumber = 5;\n        } else {\n            groupNumber = 2;\n        }\n        // 食べるのにかかる時間\n        eatingTime = 17 * (group % 2) + 3 * (group % 3) + 19;\n\n        // 食べ終わる時間\n        eatenTime = eatingTime + time;\n\n        // グループ番号・グループ人数・食べるのにかかる時間・入店した時刻・食べ終わる時間を保持する。\n        int[] groupDetails = {group, groupNumber, eatingTime, time, eatenTime};\n        return groupDetails;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n\n        // 対象のグループ番号：待ち時間の形で保持\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> targetCustomer = new LinkedHashMap<Integer, Integer>();\n        List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n        while (sc.hasNext()) {\n            targetCustomerGroupNumbers.add(sc.nextInt());\n        }\n\n        // 椅子 客が出るまでの分数を保持する\n        int[] chairs = new int[17];\n        // 待ち行列 客グループ数を保持する\n        Deque<Integer> que = new LinkedList<Integer>();\n        // これまでに来た最大のグループ番号\n        int cameGroup = 0;\n        // これまでに座ったグループの「数」\n        int sitGroupCount = 0;\n        // 経過時間\n        int pastMinutes = 0;\n\n        while (sitGroupCount < 100) {\n            // 食べる\n            eat(chairs);\n\n            // 客が来る\n            boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n            // 座る\n            sitGroupCount += sit(chairs, que, sitGroupCount);\n\n            // 後処理\n            for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                    // まだ座れていない\n                    continue;\n                }\n\n                if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                    // もうすでに座っていた\n                    continue;\n                } else {\n                    // この時間で初めて座れた\n                    int waitMinutes = pastMinutes\n                            - (5 * targetCustomerGroupNumber);\n                    targetCustomer.put(targetCustomerGroupNumber, waitMinutes);\n                }\n            }\n\n            if (customerHasCome) {\n                cameGroup++;\n            }\n            pastMinutes++;\n        }\n\n        for (Entry<Integer, Integer> entry : targetCustomer.entrySet()) {\n            System.out.println(entry.getValue());\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int sitGroupNumber) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (sitGroupNumber % 2))\n                    + (3 * (sitGroupNumber % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, (sitGroupNumber + 1));\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n\n        // 対象のグループ番号：待ち時間の形で保持\n        Scanner sc = new Scanner(System.in);\n        Map<Integer, Integer> targetCustomer = new HashMap<Integer, Integer>();\n        List<Integer> targetCustomerGroupNumbers = new LinkedList<Integer>();\n        while (sc.hasNext()) {\n            targetCustomerGroupNumbers.add(sc.nextInt());\n        }\n\n        // 椅子 客が出るまでの分数を保持する\n        int[] chairs = new int[17];\n        // 待ち行列 客グループ数を保持する\n        Deque<Integer> que = new LinkedList<Integer>();\n        // これまでに来た最大のグループ番号\n        int cameGroup = 0;\n        // これまでに座ったグループの「数」\n        int sitGroupCount = 0;\n        // 経過時間\n        int pastMinutes = 0;\n\n        while (sitGroupCount < 100) {\n            // 食べる\n            eat(chairs);\n\n            // 客が来る\n            boolean customerHasCome = come(que, pastMinutes, cameGroup);\n\n            // 座る\n            sitGroupCount += sit(chairs, que, cameGroup);\n\n            // 後処理\n            for (Integer targetCustomerGroupNumber : targetCustomerGroupNumbers) {\n                if (targetCustomerGroupNumber > (sitGroupCount - 1)) {\n                    // まだ座れていない\n                    continue;\n                }\n\n                if (targetCustomer.containsKey(targetCustomerGroupNumber)) {\n                    // もうすでに座っていた\n                    continue;\n                } else {\n                    // この時間で初めて座れた\n                    int waitMinutes = pastMinutes\n                            - (5 * targetCustomerGroupNumber);\n                    targetCustomer.put(targetCustomerGroupNumber, waitMinutes);\n                }\n            }\n\n            if (customerHasCome) {\n                cameGroup++;\n            }\n            pastMinutes++;\n        }\n\n        for (Entry<Integer, Integer> entry : targetCustomer.entrySet()) {\n            System.out.println(entry.getValue());\n        }\n\n    }\n\n    private static void eat(int[] chairs) {\n        for (int c = 0; c < chairs.length; c++) {\n            chairs[c]--;\n            if (chairs[c] < 0) {\n                chairs[c] = 0;\n            }\n        }\n    }\n\n    private static boolean come(Deque<Integer> que, int pastMinutes,\n            int cameGroup) {\n        if (pastMinutes % 5 == 0) {\n            if (cameGroup % 5 == 1) {\n                que.offer(5);\n            } else {\n                que.offer(2);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    private static int sit(int[] chairs, Deque<Integer> que, int cameGroupCount) {\n        // 先頭の人を取得\n        Integer groupMembers = que.peek();\n\n        if (groupMembers == null) {\n            // 待っていなかった場合\n            return 0;\n        }\n\n        int sequencialEmptyChairs = 0;\n        int sittableChairStart = -1;\n        for (int c = 0; c < chairs.length; c++) {\n            if (chairs[c] == 0) {\n                // 空いていたら連続空席数をカウント\n                sequencialEmptyChairs++;\n            } else {\n                sequencialEmptyChairs = 0;\n            }\n\n            // 全員座れるまで席が空いていた\n            if (sequencialEmptyChairs == groupMembers) {\n                sittableChairStart = c - (sequencialEmptyChairs - 1);\n                break;\n            }\n        }\n\n        if (sittableChairStart == -1) {\n            // 連続して席が空いていなかった\n            return 0;\n        }\n\n        // 座れる席を確保\n        que.poll();\n\n        for (int c = 0; c < groupMembers; c++) {\n            chairs[c + sittableChairStart] = (17 * (cameGroupCount % 2))\n                    + (3 * (cameGroupCount % 3)) + 19;\n        }\n\n        // まだ座れるかも\n        int sitGroupCount = 1;\n        sitGroupCount += sit(chairs, que, cameGroupCount + sitGroupCount);\n\n        return sitGroupCount;\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader\tbr = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t* @param args\n\t*/\n \n\tstatic class Seat {\n\t\tpublic\tint\tb = 0;\n\t}\n\n\tstatic class Grp {\n\t\tpublic\tint\ts = 0;\n\t\tpublic\tint\te = 0;\n\t\tpublic\tint\tn = 0;\n\t\tpublic\tint\tb = 0;\n\t\tpublic\tint\tw = -1;\n\n\t\tpublic Grp(int i) {\n\t\t\tthis.s = i*5;\n\t\t\tthis.e = 17*(i%2)+3*(i%3)+19;\n\t\t\tthis.n = (i%5==1)?5:2;\n\t\t}\n\t}\n\n\tstatic class Lst {\n\t\tpublic\tint[]\td = new int[101];\n\t\tpublic\tint\t\th = 0;\n\t\tpublic\tint\t\tt = 0;\n\n\t\tpublic void add(int e) {\n\t\t\td[t++] = e;\n\t\t\tthis.sort();\n\t\t}\n\n\t\tpublic int get(int i) {\n\t\t\treturn d[h+i];\n\t\t}\n\n\t\tpublic int remove(int i) {\n\t\t\tint\trmv = this.d[h];\n\t\t\tthis.d[i] = 0;\n\t\t\tthis.sort();\n\t\t\tthis.h++;\n\t\t\treturn rmv;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn t-h;\n\t\t}\n\n\t\tpublic void sort() {\n\t\t\tArrays.sort(d, h, t);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tGrp[]\tg = new Grp[100];\n\t\tSeat\ts = new Seat();\n\t\tLst\t\te = new Lst();\n\t\tLst\t\tw = new Lst();\n\t\tboolean\tf = true;\n\t\tint\t\to = 0;\n\t\t\n\t\tfor (int i = 0; i < g.length; i++) {\n\t\t\tg[i] = new Grp(i);\n\n\t\t\t// 席があるかチェック\n\t\t\tif (isAvailableSeat(s, g[i]) && f) {\n\t\t\t\t// 食べ終わるグループリストへ追加\n\t\t\t\te.add((g[i].s+g[i].w+g[i].e)*100+i);\n\t\t\t} else {\n\t\t\t\t// 待っているグループリストへ追加\n\t\t\t\tf = false;\n\t\t\t\tw.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(w.size() > 0) {\n\t\t\tint\ta = e.remove(0);\n\t\t\tint\tt = a/100;\n\t\t\tint\ti = a%100;\n\n\t\t\t// 一グループが食べ終わった\n\t\t\ts.b = s.b&(~g[i].b);\n\n\t\t\tfor(int b = 0; b < w.size(); b++) {\n\t\t\t\t// 待っているグループが席に座れるかチェック\n\t\t\t\tint j = w.get(b);\n\n\t\t\t\t// 待っているグループがこれ以上いなければ打ちきり\n\t\t\t\tif (g[j].s > t) break;\n\n\t\t\t\t// 席があるかチェック\n\t\t\t\tif (isAvailableSeat(s, g[j])) {\n\t\t\t\t\t// グループの待ち時間を計算\n\t\t\t\t\tg[j].w = Math.max(0, t-g[j].s);\n\n\t\t\t\t\t// 食べ終わるグループリストへ追加\n\t\t\t\t\te.add((g[j].s+g[j].w+g[j].e)*100+j);\n\n\t\t\t\t\tw.remove(b--);\n\t\t\t\t} else {\n\t\t\t\t\t// 座れなかったら打ちきり\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ((o = parseNum()) != -1) {\n\t\t\tSystem.out.println(g[o].w);\n\t\t}\n\t}\n\n\tprivate static boolean isAvailableSeat(Seat s, Grp g) {\n\t\tboolean bSt = false;\n\t\tint\t\tb   = (1<<g.n)-1;\n\n\t\tfor (int i = 0; i <= 17-g.n && !bSt; i++, b<<=1) {\n\t\t\tif ((s.b&b) == 0) {\n\t\t\t\ts.b = s.b|b;\n\t\t\t\tg.b = b;\n\t\t\t\tg.w = 0;\n\t\t\t\tbSt = true;\n\t\t\t}\n\t\t}\n\t\treturn bSt;\n\t}\n\n\n\tprivate static int parseNum() {\n\t\tint\t\tparam = -1;\n\t\tString\tstrin = null;\n\n\t\tif ((strin = parseStdin()) != null) {\n\t\t\tparam = Integer.parseInt(strin);\n\t\t}\n \n\t\treturn param;\n\t}\n\n\tprivate static String parseStdin() {\n        String  stdin = null;\n        \n        try {\n        \tString  tmp = br.readLine();\n        \tif (tmp != null) {\n            \tif (!tmp.isEmpty()) {\n            \t\tstdin = tmp;\n            \t}\n        \t}\n        }\n        catch (IOException e) {}\n \n        return stdin;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Main {\n\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\n\t\t// String a = \"5\\r\\n6\\r\\n7\\r\\n8\";\n\t\t// InputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n\t\t// // 意味的にはSystem.in = bais;\n\t\t//\n\t\t// BufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t}\n\n\t\tgroup = new Group[maxInputNum + 1];\n\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\tbyeStore(String.valueOf(n));\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\tfor (int m = n + 1; m < i; m++) {\n\n\t\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\t\t\t\tgroup[m].pastTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t\t- group[n].pastTime;\n\n\t\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\n\t\tfor (int n = 0; n < seat.length; n++) {\n\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (\"_\".equals(seat[n])) {\n\n\t\t\t\temptySeat++;\n\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n\tprivate int time = 0;\n\tprivate int groupCount = 0;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().execute();\n\t}\n\n\tprivate void execute() throws Exception {\n\n\t\t// 標準入力を１行ずつ処理\n\t\tList<Integer> targetGroups = readInitialData();\n\n\t\tEatingPerson[] seats = new EatingPerson[17];\n\t\tList<WaitingPerson> waitingGroups = new ArrayList<WaitingPerson>();\n\t\tList<Integer> waitTimes = new ArrayList<Integer>();\n\t\t\n\t\t// 待ち時間を調べる必要がある最後のグループを取得\n\t\tint maxGroupNum = searchMaxGroupNum(targetGroups);\n\n\t\twhile (groupCount <= maxGroupNum) {\n\n\t\t\t// 行列の更新\n\t\t\tupdateWaitLine(waitingGroups);\n\n\t\t\t// 離席する\n\t\t\tleaveSeat(seats);\n\n\t\t\t// 着席する\n\t\t\tsitDown(seats, waitingGroups, waitTimes);\n\n\t\t\ttime++;\n\t\t}\n\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tSystem.out.println(waitTimes.get(targetGroup));\n\t\t}\n\t}\n\n\tprivate int searchMaxGroupNum(List<Integer> targetGroups) {\n\t\t// 最大番号のグループ\n\t\tint maxGroupNum = 0;\n\t\tfor (int targetGroup : targetGroups) {\n\t\t\tif (maxGroupNum < targetGroup) {\n\t\t\t\tmaxGroupNum = targetGroup;\n\t\t\t}\n\t\t}\n\t\treturn maxGroupNum;\n\t}\n\n\tprivate void sitDown(EatingPerson[] seats,\n\t\t\tList<WaitingPerson> waitingGroups, List<Integer> waitTimes) {\n\n\t\tint removeCount = 0;\n\t\tfor (WaitingPerson waitingPerson : waitingGroups) {\n\n\t\t\tint emptySeatCount = 0;\n\t\t\tboolean isEmpty = false;\n\t\t\tfor (int i = 0; i < seats.length; i++) {\n\n\t\t\t\t// 空席数を検知\n\t\t\t\tif (seats[i] == null) {\n\t\t\t\t\temptySeatCount++;\n\t\t\t\t} else {\n\t\t\t\t\temptySeatCount = 0;\n\t\t\t\t}\n\n\t\t\t\tif (waitingPerson.getNumber() == emptySeatCount) {\n\n\t\t\t\t\t// 席に座ったグループ数を更新\n\t\t\t\t\tgroupCount++;\n\t\t\t\t\tremoveCount++;\n\t\t\t\t\tisEmpty = true;\n\n\t\t\t\t\t// 所属グループの待ち時間を記録\n\t\t\t\t\twaitTimes.add(time - waitingPerson.getStartTime());\n\n\t\t\t\t\t// 食べ終わる時間を計算\n\t\t\t\t\tint endTime = 17 * (waitingPerson.getGroup() % 2) + 3\n\t\t\t\t\t\t\t* (waitingPerson.getGroup() % 3) + 19;\n\n\t\t\t\t\tfor (int j = 0; j < emptySeatCount; j++) {\n\t\t\t\t\t\tseats[i - j] = new EatingPerson(\n\t\t\t\t\t\t\t\twaitingPerson.getGroup(), endTime + time);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!isEmpty) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < removeCount; i++) {\n\t\t\twaitingGroups.remove(0);\n\t\t}\n\t}\n\n\tprivate void leaveSeat(EatingPerson[] seats) {\n\t\tfor (int i = 0; i < seats.length; i++) {\n\t\t\tif (seats[i] != null && seats[i].getEndTime() == time) {\n\t\t\t\tseats[i] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateWaitLine(List<WaitingPerson> waitingGroups) {\n\t\tint nowGroup = time / 5;\n\n\t\t// グループがやってきたか判定\n\t\tif (time % 5 == 0) {\n\t\t\t// グループの人数を算出\n\t\t\tint number = 2;\n\t\t\tif (nowGroup % 5 == 1) {\n\t\t\t\tnumber = 5;\n\t\t\t}\n\n\t\t\t// 行列の後ろに追加\n\t\t\t// 待ち始めた時間を記録\n\t\t\twaitingGroups.add(new WaitingPerson(nowGroup, number, time));\n\t\t}\n\t}\n\n\tprivate List<Integer> readInitialData() throws IOException {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(\n\t\t\t\tSystem.in));\n\n\t\tString line = null;\n\t\tList<Integer> groups = new ArrayList<Integer>();\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tif (!line.equals(\"\")) {\n\t\t\t\tgroups.add(Integer.parseInt(line));\n\t\t\t}\n\t\t}\n\n\t\treturn groups;\n\t}\n\n}\n\nabstract class Person {\n\n\t// 所属グループ\n\tprivate int group;\n\n\tpublic int getGroup() {\n\t\treturn group;\n\t}\n\n\tpublic void setGroup(int group) {\n\t\tthis.group = group;\n\t}\n\n}\n\nclass WaitingPerson extends Person {\n\n\tpublic WaitingPerson(int group, int number, int startTime) {\n\t\tsetGroup(group);\n\t\tsetNumber(number);\n\t\tsetStartTime(startTime);\n\t}\n\n\t// 待ち始めた時刻\n\tprivate int startTime;\n\n\t// グループの人数\n\tprivate int number;\n\n\tpublic int getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic void setStartTime(int startTime) {\n\t\tthis.startTime = startTime;\n\t}\n\n\tpublic int getNumber() {\n\t\treturn number;\n\t}\n\n\tpublic void setNumber(int number) {\n\t\tthis.number = number;\n\t}\n}\n\nclass EatingPerson extends Person {\n\n\tpublic EatingPerson(int group, int endTime) {\n\t\tsetGroup(group);\n\t\tsetEndtTime(endTime);\n\t}\n\n\t// 食べ終わる時間\n\tprivate int endtTime;\n\n\tpublic int getEndTime() {\n\t\treturn endtTime;\n\t}\n\n\tpublic void setEndtTime(int endtTime) {\n\t\tthis.endtTime = endtTime;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n \n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 食べ終わるまでの時間 */\n    private static final int[] timeToEatList = {19, 39, 25, 36, 22, 42};\n    /** 座席数 */\n    private static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    private static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    private static final int ARRIVE_INTERVAL = 5;\n     \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    private static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    private static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    private static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    private static int headGroupNo = -1;\n     \n    static {\n        Arrays.fill(seat, -1);\n        Arrays.fill(waitingTime, -1);\n        Arrays.fill(eatEndTime, -1);\n    }\n     \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n         \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n         \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n             \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n             \n            inputList.add(Integer.parseInt(input));\n        }\n         \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n         \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n \n    }\n    \n    /**\n     * グル?プの人数を計算する\n     */\n    private static int getNumInGroup(int groupNo) {\n        return groupNo % 5 == 1 ? 5 : 2;\n    }\n     \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    private static void calcWaitTime(int maxGroupNum) {\n        \n        for (int min = 0; ; min++) {\n \n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    int numOfSittingGroup = getNumInGroup(seat[s]);\n                    Arrays.fill(seat, s, s + numOfSittingGroup, -1);\n                    Arrays.fill(eatEndTime, s, s + numOfSittingGroup, -1);\n                    \n                    //グループの人数分飛ばす\n                    s += numOfSittingGroup - 1;\n                }\n            }\n             \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                int numInGroup = getNumInGroup(headGroupNo);\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    int sittingGroupNum = seat[s];\n                    if (sittingGroupNum == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                        //グループの人数分飛ばす\n                        //s += getNumInGroup(sittingGroupNum) - 1;\n                    }\n                }\n \n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    //席を埋める\n                    Arrays.fill(seat, s - numInGroup, s, headGroupNo);\n                    Arrays.fill(eatEndTime, s - numInGroup, s, min + timeToEatList[headGroupNo % timeToEatList.length]);\n                     \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                     \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                     \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n    // ?¨???¢??°?????§???\n    static final int MAX_NUMBER_OF_VISITOR = 100;\n\n    // ??§?????°\n    static final int NUMBER_OF_SEAT = 17;\n\n    // ??°???????????°??\\??????\n    static final int INTERVAL = 5;\n\n    // ??????????????????\n    static int[] waitingTime = new int[MAX_NUMBER_OF_VISITOR];\n\n    // ???????????§????????¶???\n    static int[] shopSeatTimer = new int[NUMBER_OF_SEAT];\n\n    public static void main(String[] args) {\n\n\t// ?¨??????\\???\n\tScanner sc = new Scanner(System.in);\n\n\tList<Integer> orders = new ArrayList<>();\n\n\twhile (sc.hasNextLine()) {\n\t    String nextLine = sc.nextLine();\n\t    if (\"\".equals(nextLine)) {\n\t\tbreak;\n\t    }\n\t    orders.add(Integer.parseInt(nextLine));\n\t}\n\n\t// ??\\???????????????????????§????????????\n\tint maxOrder = returnMax(orders);\n\n\t// ????????????????????????\n\tArrays.fill(waitingTime, -1);\n\n\t// ?????\\?????¬????????§?????????\n\texecuteSimulation(maxOrder);\n\n\t// ??????????????°?????????????????????????????????\n\tfor (Integer order : orders) {\n\t    System.out.println(waitingTime[order]);\n\t}\n\n\tsc.close();\n\n    }\n\n    private static void executeSimulation(int maxOrder) {\n\t// ????????????\n\tList<Integer> waintinGroup = new ArrayList<>();\n\n\t// ???????????§???????????????(?????????-1??¨??????)\n\tArrays.fill(shopSeatTimer, -1);\n\n\t// ????????????????????????????§?\n\n\tfor (int now = 0;; now++) {\n\n\t    // ?£?????????????????????????????????????????????????????£????????????????-1\n\t    for (int i = 0; i < NUMBER_OF_SEAT; i++) {\n\n\t\t// ????????????????????????????????????????????????\n\t\tif (shopSeatTimer[i] != -1) {\n\t\t    shopSeatTimer[i]--;\n\t\t}\n\n\t\t// ???????????????0???????????????\n\t\tif (shopSeatTimer[i] == 0) {\n\t\t    shopSeatTimer[i] = -1;\n\t\t}\n\t    }\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now % INTERVAL == 0) {\n\t\twaintinGroup.add(now / INTERVAL);\n\t    }\n\n\t    // ????????????????????§???\n\t    while (true) {\n\t\tif (waintinGroup.isEmpty()) {\n\t\t    break;\n\t\t}\n\n\t\tint group = waintinGroup.get(0);\n\t\tint openSeatHead = canISitDown(group);\n\n\t\t// ???????????????????????°\n\t\tif (openSeatHead != -1) {\n\t\t    // ????????????????????????????´?\n\t\t    waitingTime[group] = now - group * INTERVAL;\n\n\t\t    // ?£?????????????????´?\n\t\t    for (int i = 0; i < howManymembers(group); i++) {\n\t\t\tshopSeatTimer[openSeatHead + i] = howLongToEat(group);\n\t\t    }\n\t\t    // ??????????????????\n\t\t    waintinGroup.remove(0);\n\n\t\t    // ?±??????????????????§??????????????°?????????????????????????????????\n\t\t    if (group == maxOrder) {\n\t\t\treturn;\n\t\t    }\n\n\t\t} else {\n\t\t    break;\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n    // ????????????????????§????????????\n    private static int returnMax(List<Integer> orders) {\n\tint maxOrder = 0;\n\tfor (Integer order : orders) {\n\t    maxOrder = Math.max(order, maxOrder);\n\t}\n\treturn maxOrder;\n\n    }\n\n    // ??§?????????????????????\n    private static int canISitDown(int group) {\n\tint count = 0;\n\tfor (int i = 0; i < NUMBER_OF_SEAT - howManymembers(group) + 1; i++) {\n\t    for (int j = 0; j < howManymembers(group); j++) {\n\t\tif (shopSeatTimer[i + j] == -1) {\n\t\t    count++;\n\t\t} else {\n\t\t    count = 0;\n\t\t}\n\n\t\tif (count == howManymembers(group)) {\n\t\t    return i;\n\t\t}\n\t    }\n\t}\n\treturn -1;\n    }\n\n    // ????????°?????????????????????\n    private static int howManymembers(int group) {\n\treturn group % 5 == 1 ? 5 : 2;\n    }\n\n    // ?£???????????????????\n    private static int howLongToEat(int group) {\n\treturn 17 * (group % 2) + 3 * (group % 3) + 19;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.concurrent.PriorityBlockingQueue;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tint[] ans;\n\tpublic void run() {\n\t\tans = new int[100];\n\t\t\n\t\tPriorityQueue<Event> pq = new PriorityQueue<Event>();\n\t\tint[] table = new int[17];\n\t\tArrays.fill(table, -1);\n\t\tint nextGroup = 0;\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tEvent e = new Event();\n\t\t\te.id = i;\n\t\t\te.move = Event.ARRIVE;\n\t\t\te.time = i * 5;\n\t\t\te.num = i % 5 == 1 ? 5 : 2;\n\t\t\te.duration = 17*(i%2) + 3*(i%3)+19;\n\t\t\tpq.add(e);\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEvent e = pq.poll();\n//\t\t\ttr(e.time, e.id, e.move, table);\n\t\t\tif (e.move == Event.LEAVE) {\n\t\t\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\t\t\tif (table[i] == e.id) table[i] = -1;\n\t\t\t\t}\n\t\t\t} else if (e.move == Event.ARRIVE) {\n\t\t\t\tint pos = -1;\n\t\t\t\tif (nextGroup == e.id) {\n\t\t\t\t\tfor (int i = 0; i + e.num < table.length; i++) {\n\t\t\t\t\t\tboolean ok = true;\n\t\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\t\tif (table[i+j] != -1) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\t// 座る\n\t\t\t\t\tans[e.id] = e.time - e.id * 5;\n\t\t\t\t\tfor (int j = 0; j < e.num; j++) {\n\t\t\t\t\t\ttable[pos + j] = e.id;\n\t\t\t\t\t}\n\t\t\t\t\te.time += e.duration;\n\t\t\t\t\te.move = Event.LEAVE;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t\tnextGroup++;\n\t\t\t\t} else {\n\t\t\t\t\t// 空いてなければ待つ。時刻+1して席が空くのを待つ手抜き実装\n\t\t\t\t\te.time++;\n\t\t\t\t\tpq.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;sc.hasNext();) {\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(ans[n]);\n\t\t}\n\t}\n\t\n\tclass Event implements Comparable<Event> {\n\t\tstatic final int LEAVE = 0;\n\t\tstatic final int ARRIVE = 1;\n\t\tint id;\n\t\tint move;\n\t\tint time;\n\t\tint num;\n\t\tint duration;\n\t\t@Override\n\t\tpublic int compareTo(Event o) {\n\t\t\tint c = time - o.time;\n\t\t\tif (c == 0) c = move - o.move;\n\t\t\tif (c == 0) c = id - o.id;\n\t\t\treturn c;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\nclass Main {\n\n\tpublic static void main(String... args) {\n\t\tList<Integer> targetGroupNumberList = getInputList();\n\t\tint maxGroupNumber = Collections.max(targetGroupNumberList);\n\n\t\tFukushimaken fukushimaken = new Fukushimaken();\n\t\tList<Group> groupList = new ArrayList<Group>();\n\n\t\tint elapsedTime = 0;\n\t\tint groupNumber = 0;\n\t\twhile (true) {\n\t\t\tif (elapsedTime % 5 == 0) {\n\t\t\t\tgroupNumber = elapsedTime / 5;\n\t\t\t\tGroup group = new Group(groupNumber);\n\t\t\t\tgroupList.add(group);\n\t\t\t\t\n\t\t\t\tfukushimaken.receive(group);\n\t\t\t}\n\t\t\tfukushimaken.refresh(elapsedTime);\n\n\t\t\tif (maxGroupNumber <= groupNumber\n\t\t\t\t\t&& groupList.get(maxGroupNumber).haveStartedEating()) {\n\t\t\t\t// 対象となるグループ番号の待ち時間が全て取得できた段階で終了する\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telapsedTime++;\n\t\t}\n\n\t\tfor (int i : targetGroupNumberList) {\n\t\t\tGroup group = groupList.get(i);\n\t\t\tint waitTime = group.getWaitTime();\n\t\t\tSystem.out.println(waitTime);\n\t\t}\n\t}\n\t\n\tstatic List<Integer> getInputList() {\n\t\tScanner scanner = null;\n\t\tList<Integer> inputList = new ArrayList<Integer>();\n\t\ttry {\n\t\t\tscanner = new Scanner(System.in);\n\t\t\twhile (scanner.hasNext()) {\n\t\t\t\tString line = scanner.nextLine();\n\t\t\t\tinputList.add(Integer.parseInt(line));\n\t\t\t}\n\t\t\treturn inputList;\n\t\t} finally {\n\t\t\tif (scanner != null) {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Fukushimaken {\n\t\tprivate List<Boolean> tables = new ArrayList<Boolean>(17); // 座席（Falseであれば空席となる）\n\t\tprivate List<Group> groupAtTable = new ArrayList<Group>(); // 着席しているグループ\n\t\tprivate LinkedList<Group> groupQueue = new LinkedList<Group>(); // 並んでいるグループ\n\n\t\tFukushimaken() {\n\t\t\tfor (int i = 0; i < 17; i++) {\n\t\t\t\ttables.add(false);\n\t\t\t}\n\t\t}\n\n\t\tvoid receive(Group group) {\n\t\t\tthis.groupQueue.offer(group);\n\t\t}\n\n\t\tvoid refresh(int elapsedTime) {\n\t\t\tthis.refreshTables(elapsedTime);\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t\tfor (Group group : this.groupQueue) {\n\t\t\t\t// 行列にいるグループに待ち時間を加算する\n\t\t\t\tgroup.addWaitTime();\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshTables(int elapsedTime) {\n\t\t\t// 食事の済んだグループの座席を空席とする\n\t\t\tfor (int i = 0; i < this.groupAtTable.size(); i++) {\n\t\t\t\tGroup group = this.groupAtTable.get(i);\n\t\t\t\tif (!group.haveFinishedMeal(elapsedTime)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Integer> tableNumbers = group.getUseTableNumbers();\n\t\t\t\tfor (int j : tableNumbers) {\n\t\t\t\t\tthis.tables.set(j, false);\n\t\t\t\t}\n\t\t\t\tthis.groupAtTable.remove(i);\n\t\t\t}\n\t\t}\n\n\t\tprivate void refreshQueue(int elapsedTime) {\n\t\t\tGroup group = this.groupQueue.peek();\n\t\t\tif (group == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSet<Integer> emptyTableNumbers = this.getEmptyTablesNumbers(group.getSize());\n\t\t\tif (emptyTableNumbers.size() == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// 座席が空いていれば行列の先頭から順に着席する\n\t\t\tthis.groupAtTable.add(group);\n\t\t\tgroup.startEating(emptyTableNumbers, elapsedTime);\n\t\t\tthis.groupQueue.removeFirst();\n\t\t\tfor (int i : emptyTableNumbers) {\n\t\t\t\tthis.tables.set(i, true);\n\t\t\t}\n\t\t\tthis.refreshQueue(elapsedTime);\n\t\t}\n\n\t\tprivate Set<Integer> getEmptyTablesNumbers(int size) {\n\t\t\t// 席の番号が小さいほうから空いている座席を探す\n\t\t\tSet<Integer> tableNumbers = new HashSet<Integer>();\n\t\t\tfor (int i = 0; i < this.tables.size(); i++) {\n\t\t\t\tboolean isNotEmpty = this.tables.get(i);\n\t\t\t\tif (isNotEmpty) {\n\t\t\t\t\ttableNumbers.clear();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttableNumbers.add(i);\n\t\t\t\tif (size <= tableNumbers.size()) {\n\t\t\t\t\treturn tableNumbers;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new HashSet<Integer>();\n\t\t}\n\t}\n\n\tstatic class Group {\n\n\t\tprivate int number; // グループ番号\n\t\tprivate int timeToEat; // 食事にかかる時間\n\t\tprivate int endingTime; // 食事が済む時点の経過時間\n\t\tprivate Set<Integer> useTableNumbers; // 使用している座席の番号\n\t\tprivate int waitTime; // 待ち時間\n\n\t\tGroup(int number) {\n\t\t\tthis.number = number;\n\t\t\tthis.timeToEat = 17 * (this.number % 2) + 3 * (this.number % 3) + 19;\n\t\t}\n\n\t\tvoid startEating(Set<Integer> tableNumbers, int elapsedTime) {\n\t\t\t// 着席し、さっそく食事を始める。この時点でこのグループの待ち時間は確定する。\n\t\t\tthis.useTableNumbers = tableNumbers;\n\t\t\tthis.endingTime = elapsedTime + timeToEat;\n\t\t}\n\n\t\tboolean haveFinishedMeal(int elapsedTime) {\n\t\t\treturn this.endingTime <= elapsedTime;\n\t\t}\n\n\t\tSet<Integer> getUseTableNumbers() {\n\t\t\treturn this.useTableNumbers;\n\t\t}\n\n\t\tboolean haveStartedEating() {\n\t\t\treturn this.useTableNumbers != null;\n\t\t}\n\n\t\tvoid addWaitTime() {\n\t\t\tthis.waitTime++;\n\t\t}\n\n\t\tint getWaitTime() {\n\t\t\treturn this.waitTime;\n\t\t}\n\n\t\tint getSize() {\n\t\t\treturn (this.number % 5 == 1) ? 5 : 2; // グループの人数\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n\tScanner sc = new Scanner(System.in);\n\n\t// ??¢?????¶???\n\tString[] storeSeat = new String[17];\n\t// ??¢?????¶???????????????\n\tmakeEmptyStore(storeSeat);\n\n\t// ???????????°??????????????????????????????????????????\n\tint[][] waitingTime = fillSeat(storeSeat);\n\n\twhile (sc.hasNextLine()) {\n\t    String query = null;\n\t    query = sc.nextLine();\n\t    if (\"???\".equals(query) || query == null) {\n\t\tSystem.exit(0);\n\t    }\n\n\t    System.out.println(waitingTime[Integer.parseInt(query)][1] - waitingTime[Integer.parseInt(query)][0]);\n\t}\n    }\n\n    // ??¨??????????????????????????\\??¢??¶???\n    private static void makeEmptyStore(String[] storeSeat) {\n\tfor (int i = 0; i < storeSeat.length; i++) {\n\t    storeSeat[i] = \"_\";\n\t}\n    }\n\n    private static int[][] fillSeat(String[] storeSeat) {\n\n\t// ????????°???????????????\n\tList<Integer> waitingGroups = new ArrayList<>();\n\n\t// ?????°????????????????????????\n\tint[][] waitingTime = new int[100][2];\n\n\t// ???????????¨?????¶??????????????¶??????????????????\n\topenStore: for (int now = 0;; now++) {\n\n\t    // ??°??????????????°????????????????????¶\n\t    if (now / 5 < 100 && now % 5 == 0) {\n\t\twaitingTime[now / 5][0] = now;\n\t\twaitInLine(waitingGroups, now / 5);\n\t    }\n\n\t    // ?£?????????????????????§????????????\n\t    for (int i = 0; i < storeSeat.length; i++) {\n\n\t\tif (\"_\".equals(storeSeat[i])) {\n\t\t    continue;\n\t\t}\n\n\t\tint groupId = Integer.parseInt(storeSeat[i]);\n\n\t\t// ?????????????????????\n\t\tint eatingTime = 17 * (groupId % 2) + 3 * (groupId % 3) + 19;\n\n\t\tif (eatingTime == now - waitingTime[groupId][1]) {\n\t\t    storeSeat[i] = \"_\";\n\t\t}\n\t    }\n\n\t    // ??????????????£????????§???\n\t    int empty = 0;\n\t    // ??????????????????0??????????????§???????????????\n\t    cont: while (waitingGroups.size() != 0) {\n\t\t// ??°?????????????????°??????\n\t\tint members = membersOfGroup(waitingGroups.get(0));\n\t\tfor (int i = 0; i < storeSeat.length - 1; i++) {\n\t\t    for (int j = 0; j < members; j++) {\n\t\t\t// ???????????????????????????????????¬??????\n\t\t\tif (j + i >= 17) {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\t// ???????????????????????????????????°??£?¶??????????????????§????????´???\n\t\t\tif (\"_\".equals(storeSeat[i + j])) {\n\t\t\t    empty++;\n\t\t\t} else {\n\t\t\t    empty = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (empty == membersOfGroup(waitingGroups.get(0))) {\n\t\t\t    int groupId = waitingGroups.get(0);\n\n\t\t\t    sit(waitingGroups, waitingTime, now, storeSeat, i);\n\n\t\t\t    // ???????????§??¢?????§??£??????????????????\n\t\t\t    if (groupId == 99) {\n\t\t\t\tbreak openStore;\n\t\t\t    }\n\n\t\t\t    continue cont;\n\t\t\t}\n\n\t\t    }\n\t\t}\n\t\t// ???????????°??????????????§???????????£????????????\n\t\tbreak;\n\t    }\n\t}\n\n\treturn waitingTime;\n    }\n\n    // ????????°????????????\n    private static int membersOfGroup(int groupId) {\n\n\tif (isFiveGroup(groupId)) {\n\t    return 5;\n\t}\n\treturn 2;\n    }\n\n    // ????????°?????????????????????\n    private static boolean isFiveGroup(int groupId) {\n\treturn groupId % 5 == 1;\n    }\n\n    // ????????????????????¶\n    private static void waitInLine(List<Integer> waitingGroups, int groupId) {\n\n\tint number = membersOfGroup(groupId);\n\n\tfor (; number > 0; number--) {\n\t    waitingGroups.add(groupId);\n\t}\n    }\n\n    // ?????????????????????????????\\?????????\n    private static void sit(List<Integer> waitingGroups, int[][] waitingTime, int now, String[] storeSeat, int seat) {\n\tint groupId = waitingGroups.get(0);\n\tint members = membersOfGroup(groupId);\n\twaitingTime[groupId][1] = now;\n\n\tfor (int i = 0; i < members; i++) {\n\t    storeSeat[seat + i] = Integer.toString(groupId);\n\n\t    waitingGroups.remove(0);\n\t}\n    }\n\n    // ???????????????????????????????¢????\n    private static boolean isAllSeatEmpty(String[] storeSeat) {\n\n\tfor (String string : storeSeat) {\n\t    if (!\"_\".equals(string)) {\n\t\treturn false;\n\t    }\n\t}\n\n\treturn true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\npublic class Main {\n\t// 席\n\tstatic String[] seat = new String[17];\n\tstatic String emptySeatString = \"_\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// 初期値設定\n\t\tArrays.fill(seat, emptySeatString);\n\t\t// グループ\n\t\tGroup[] group;\n\t\t// 退店グループリスト\n\t\tMap<Integer, Integer> byeGroupMap;\n\t\t// インプット\n\t\tList<Integer> input = new ArrayList<Integer>();\n\t\tint maxInputNum = 0;\n\t\t String a = \"96\\r\\n97\\r\\n98\\r\\n99\";\n\t\t InputStream bais = new ByteArrayInputStream(a.getBytes(\"utf-8\"));\n\t\t// 意味的にはSystem.in = bais;\n\n//\t\t BufferedReader br = new BufferedReader(new InputStreamReader(bais));\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// 最終行まで読み込む\n\t\tString num = \"\";\n\t\twhile ((num = br.readLine()) != null) {\n\t\t\tinput.add(Integer.parseInt(num));\n\t\t\tmaxInputNum = Math.max(maxInputNum, Integer.parseInt(num));\n\t\t\tif (maxInputNum >= 100) {\n\t\t\t\tthrow new Exception(\"グループオーバー\");\n\t\t\t}\n\t\t}\n\n\n\t\tgroup = new Group[maxInputNum + 1];\n\t\tint i = 0;\n\t\tgroup[maxInputNum] = new Group();\n\n\t\t// ラストのグループが食べ終わるまでループ処理実行\n\t\twhile (!group[maxInputNum].eatFlug) {\n\n\t\t\t// 退店グループリストの初期化\n\t\t\tbyeGroupMap = new HashMap<Integer, Integer>();\n\n\t\t\t// 時間を経過させる ←ここのループ工夫すれば 回数を減らせる\n\t\t\tfor (int n = 0; n < i; n++) {\n\t\t\t\tif (maxInputNum < n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 食べてるグループ\n\t\t\t\tif (!group[n].waitFlug && !group[n].eatFlug) {\n\t\t\t\t\t// 経過時間カウント\n\t\t\t\t\tgroup[n].pastTime += 5;\n\t\t\t\t\t// 食べ終わったか確認\n\t\t\t\t\tif (group[n].pastTime >= group[n].eatTime) {\n\n\t\t\t\t\t\t// 退店グループリスト追加（後ほど退店処理で実施）\n\t\t\t\t\t\tbyeGroupMap\n\t\t\t\t\t\t\t\t.put(n, group[n].pastTime - group[n].eatTime);\n\t\t\t\t\t\tgroup[n].eatFlug = true;\n\n\t\t\t\t\t\t// // 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\t\t// byeStore(String.valueOf(n));\n\t\t\t\t\t\t// group[n].eatFlug = true;\n\t\t\t\t\t\t// // 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\t\t// for (int m = n + 1; m < i; m++) {\n\t\t\t\t\t\t// if (maxInputNum < m) {\n\t\t\t\t\t\t// break;\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// if (group[m].waitFlug) {\n\t\t\t\t\t\t// // 待っていたら入店処理\n\t\t\t\t\t\t// //\n\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t// if (enterStore(m, group[m].peopleCnt)) {\n\t\t\t\t\t\t// group[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t// - group[n].pastTime;\n\t\t\t\t\t\t// group[m].pastTime += group[n].pastTime\n\t\t\t\t\t\t// - group[n].eatTime;\n\t\t\t\t\t\t// group[m].waitFlug = false;\n\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t// break;\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 待ってるグループは待ち時間をカウント\n\t\t\t\telse if (group[n].waitFlug) {\n\t\t\t\t\tgroup[n].waitTime += 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ここで退入店処理を実施\n\t\t\tif (!byeGroupMap.isEmpty()) {\n\n\t\t\t\t// List 生成 (ソート用)\n\t\t\t\tList<Map.Entry<Integer, Integer>> entries = new ArrayList<Map.Entry<Integer, Integer>>(\n\t\t\t\t\t\tbyeGroupMap.entrySet());\n\t\t\t\tCollections.sort(entries,\n\t\t\t\t\t\tnew Comparator<Map.Entry<Integer, Integer>>() {\n\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic int compare(Entry<Integer, Integer> entry1,\n\t\t\t\t\t\t\t\t\tEntry<Integer, Integer> entry2) {\n\t\t\t\t\t\t\t\treturn ((Integer) entry2.getValue())\n\t\t\t\t\t\t\t\t\t\t.compareTo((Integer) entry1.getValue());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\tfor (Entry<Integer, Integer> byeGroupNum : entries) {\n\t\t\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\t\t\tbyeStore(String.valueOf(byeGroupNum.getKey()));\n\t\t\t\t\tgroup[byeGroupNum.getKey()].eatFlug = true;\n\t\t\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\t\t\tfor (int m = byeGroupNum.getKey() + 1; m < i; m++) {\n\t\t\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\t\t\t\t\t\t\t\tgroup[m].waitTime += (group[byeGroupNum\n\t\t\t\t\t\t\t\t\t\t.getKey()].eatTime + 5)\n\t\t\t\t\t\t\t\t\t\t- group[byeGroupNum.getKey()].pastTime;\n\t\t\t\t\t\t\t\tgroup[m].pastTime += group[byeGroupNum.getKey()].pastTime\n\t\t\t\t\t\t\t\t\t\t- group[byeGroupNum.getKey()].eatTime;\n\t\t\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t\t\t\tgroup[m].waitTime -= 5;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 新規来店グループがいるかどうか確認\n\t\t\tif ((maxInputNum) >= i) {\n\t\t\t\tgroup[i] = new Group();\n\t\t\t\t// グループ情報の設定\n\t\t\t\tsetGroupInfo(group, i);\n\t\t\t\t// 前のグループが待ってなければ入店処理\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tif (!group[i - 1].waitFlug) {\n\t\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!enterStore(i, group[i].peopleCnt)) {\n\t\t\t\t\t\tgroup[i].waitFlug = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// テスト出力\n\t\t\t// for (String abc : seat) {\n\t\t\t// System.out.print(abc);\n\t\t\t// }\n\t\t\t// System.out.println();\n\t\t\t// 次グループが来る時間までカウント\n\t\t\ti++;\n\t\t}\n\t\t// てすと出力\n\t\t// for (int p = 0; p < group.length; p++) {\n\t\t// System.out.println(\"グループ番号：\" + p + \"　人数\" + group[p].peopleCnt\n\t\t// + \"　食事時間\" + group[p].eatTime);\n\t\t//\n\t\t// }\n\t\t// 待ち時間を出力する\n\t\tfor (int inputNum : input) {\n\t\t\tSystem.out.println(group[inputNum].waitTime);\n\t\t}\n\t}\n\n\t// 入店処理\n\t// 席が空いているかどうかチェック\n\t// 空いていれば入店し、trueを返す\n\t// 空いていなければ待ちフラグを付与し、falseを返す\n\tstatic boolean enterStore(int i, int currentPeopleCnt) {\n\t\tint emptySeat = 0;\n\t\tboolean okFlug = false;\n\t\tfor (int n = 0; n < seat.length; n++) {\n\t\t\tif (okFlug) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (\"_\".equals(seat[n])) {\n\t\t\t\temptySeat++;\n\t\t\t\tfor (int m = n + 1; m < currentPeopleCnt + n; m++) {\n\t\t\t\t\t// 次の席がない場合はブレイク\n\t\t\t\t\tif (m == seat.length) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!\"_\".equals(seat[m])) {\n\t\t\t\t\t\tn = m;\n\t\t\t\t\t\temptySeat = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\temptySeat++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentPeopleCnt == emptySeat) {\n\t\t\t\t\t\tfor (int l = m; l > m - currentPeopleCnt; l--) {\n\t\t\t\t\t\t\tseat[l] = String.valueOf(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tokFlug = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn okFlug;\n\t}\n\n\tstatic void byeStore(String n) {\n\t\tfor (int i = 0; i < seat.length; i++) {\n\t\t\tif (seat[i].equals(n)) {\n\t\t\t\tseat[i] = emptySeatString;\n\t\t\t}\n\t\t}\n\t}\n\n\t// グループ情報の設定\n\tstatic void setGroupInfo(Group[] group, int i) {\n\t\tgroup[i].eatTime = 17 * (i % 2) + 3 * (i % 3) + 19;\n\t\tif (i % 5 == 1) {\n\t\t\tgroup[i].peopleCnt = 5;\n\t\t} else {\n\t\t\tgroup[i].peopleCnt = 2;\n\t\t}\n\t}\n\n\t// 退店＆入店処理実施\n\tstatic void byeAndEnterStore(List<Integer> byeGroupList, Group[] group,\n\t\t\tint maxInputNum, int currentGroupNum) {\n\n\t\tfor (int n : byeGroupList) {\n\n\t\t\t// 食べ終わっているグループがいる場合、退店処理を実施\n\t\t\tbyeStore(String.valueOf(n));\n\t\t\tgroup[n].eatFlug = true;\n\t\t\t// 待っているグループが入れるか確認(待ってるグループは自分より絶対後)\n\t\t\tfor (int m = n + 1; m < currentGroupNum; m++) {\n\t\t\t\tif (maxInputNum < m) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (group[m].waitFlug) {\n\t\t\t\t\t// 待っていたら入店処理\n\t\t\t\t\t// 入店処理で待ちの1グループ目が入れなかったら(enterStoreの戻り値falseなら)後続組もまつ\n\t\t\t\t\tif (enterStore(m, group[m].peopleCnt)) {\n\t\t\t\t\t\tgroup[m].waitTime += (group[n].eatTime + 5)\n\t\t\t\t\t\t\t\t- group[n].pastTime;\n\t\t\t\t\t\tgroup[m].pastTime += group[n].pastTime\n\t\t\t\t\t\t\t\t- group[n].eatTime;\n\t\t\t\t\t\tgroup[m].waitFlug = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class Group {\n\t\t// 人数\n\t\tint peopleCnt = 0;\n\t\t// 食事時間\n\t\tint eatTime = 0;\n\t\t// 経過時間\n\t\tint pastTime = 0;\n\t\t// 食べ終わりフラグ(true：食べ終わった、false：食べ終わってない)\n\t\tboolean eatFlug = false;\n\t\t// 待ち時間\n\t\tint waitTime = 0;\n\t\t// 待ちフラグ(true：待ってる、false：待ってない)\n\t\tboolean waitFlug = false;\n\t\t// 退店フラグ(true：帰った、false：帰ってない)\n\t\tboolean byeFlug = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n/**\n * Fukushimaken\n */\npublic class Main{\n    /** 座席数 */\n    public static final int SEAT_NUM = 17;\n    /** 来店するグループ数 */\n    public static final int GROUP_NUM = 100;\n    /** 客の到着する間隔 */\n    public static final int ARRIVE_INTERVAL = 5;\n    \n    /** 座席 */\n    // -1 は空席、0以上はグループの番号\n    public static int[] seat = new int[SEAT_NUM];\n    /** 座席毎の食べ終わる時間 */\n    //誰もいない場合は-1。 */\n    public static int[] eatEndTime = new int[SEAT_NUM];\n    /** n番目の客の待ち時間 */\n    public static int[] waitingTime = new int[GROUP_NUM];\n    /** 先頭で待っているグループ番号 */\n    public static int headGroupNo = -1;\n    \n    /**\n     * エントリポイント\n     */\n    public static void main(String args[]) throws IOException {        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String input = \"\";\n        \n        //入力値をまとめて読み込み\n        //（入力値中の、最大のグループ番号を求める）\n        List<Integer> inputList = new ArrayList<Integer>();\n        int maxGroupNum = 0;\n        while(true) {\n            input = br.readLine();\n            if(input == null) break;\n            \n            int inputInt = Integer.parseInt(input);\n            if(maxGroupNum < inputInt) maxGroupNum = inputInt;\n            \n            inputList.add(Integer.parseInt(input));\n        }\n        \n        //入力値中の、最大のグループ番号までの待ち時間を計算\n        calcWaitTime(maxGroupNum);\n        \n        //結果を表示\n        for (int i = 0;  i < inputList.size(); i++) {\n            System.out.println(waitingTime[inputList.get(i)]);\n        }\n\n    }\n    \n    /**\n     * 待ち時間を計算し、waitingTimeに記録する。\n     * ただし、入力値中の、最大のグループ番号まで、計算する。\n     */\n    public static void calcWaitTime(int maxGroupNum) {\n        for (int min = 0; ; min++) {\n\n            //食べ終わりの判定\n            for (int s = 0; s < SEAT_NUM; s++) {\n                if(eatEndTime[s] == min) {\n                    seat[s] = -1;\n                    eatEndTime[s] = -1;\n                }\n            }\n            \n            //客が到着し、誰も待っていなければ先頭のグループNoを更新\n            if (min % 5 == 0 && headGroupNo == -1) {\n                headGroupNo = min / ARRIVE_INTERVAL;\n            }\n            \n            //席が空いていれば着席させる\n            while(headGroupNo != -1) {\n                //連続して空いている席を探索\n                int blankSeatNum = 0;\n                //i番目のグループの人数は i%5 が 1 のとき5人、それ以外のときは2人\n                int numInGroup = headGroupNo % 5 == 1 ? 5 : 2;\n                int s;\n                for (s = 0; s < SEAT_NUM && blankSeatNum < numInGroup; s++) {\n                    if (seat[s] == -1) {\n                        blankSeatNum++;\n                    } else {\n                        blankSeatNum = 0;\n                    }\n                }\n\n                //着席できた場合\n                if(blankSeatNum == numInGroup) {\n                    for(int ts = s - 1; ts > s - 1 - numInGroup; ts--) {\n                        seat[ts] = headGroupNo;\n                        //i番目のグループは、席に着くと 17(i%2)+3(i%3)+19 分間で食事を済ませる\n                        eatEndTime[ts] = min + (17 * (headGroupNo % 2) + 3 * (headGroupNo % 3) + 19);\n                    }\n                    \n                    //待った時間を記録\n                    waitingTime[headGroupNo] = min - headGroupNo * ARRIVE_INTERVAL;\n                    \n                    //求める最大のグループ番号が着席できた時点で、処理中断。\n                    if (headGroupNo == maxGroupNum) return;\n                    \n                    //次に先頭になるグループを算出\n                    if(min >= (headGroupNo + 1) * ARRIVE_INTERVAL) {\n                        //次のグループが既に到着していれば、次のグループが先頭\n                        headGroupNo++;\n                    } else {\n                        //まだ到着していなければ、先頭はなし\n                        headGroupNo = -1;\n                    }\n                } else {\n                    //着席できない場合、次の時刻に進む\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] seats = new int[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0};\n        int[] groupMembers = new int[] {2, 5, 2, 2, 2};\n        int[] eatTimes = new int[] {19, 39, 25, 36, 22, 42};\n\n        int headGroup = -1;\n        int pastMinutes = 0;\n        int customerCount = 0;\n        List<Integer> waitTime = new ArrayList<Integer>(100);\n\n        while (customerCount < 100) {\n            // たべおわる\n            for (int i = 0; i < seats.length; i++) {\n                seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n            }\n\n            // 来店\n            if (headGroup == -1 && pastMinutes % 5 == 0) {\n                headGroup = pastMinutes / 5;\n            }\n\n            // ちゃくせき\n            while (headGroup != -1) {\n                int sequencialSeats = 0;\n                int startIndex = -1;\n                for (int i = 0; i < seats.length; i++) {\n                    sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n                    if (sequencialSeats == groupMembers[headGroup % 5]) {\n                        startIndex = i - (groupMembers[headGroup % 5] - 1);\n                        break;\n                    }\n                }\n\n                if (startIndex != -1) {\n                    // すわれたみたい\n                    waitTime.add(headGroup, pastMinutes - (headGroup * 5));\n                    for (int i = startIndex; i < (startIndex + groupMembers[headGroup % 5]); i++) {\n                        seats[i] = eatTimes[headGroup % 6];\n                    }\n\n                    headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1\n                            : -1;\n                    customerCount++;\n                } else {\n                    // すわれなかったみたい\n                    break;\n                }\n\n            }\n\n            pastMinutes++;\n\n        }\n\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            System.out.println(waitTime.get(sc.nextInt()));\n        }\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\npublic class P : IComparable\n{\n    public int id { get; set; }\n    public int m { get; set; }\n    public int t { get; set; }\n    public bool a { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (P)obj;\n        if (this.t > x.t) return 1;\n        else if (this.t == x.t) return 0;\n        else return -1;\n    }\n}\n\npublic class hello\n{\n    public static int[] sheet;\n    public static void Main()\n    {\n        var pq = new PriorityQueue<P>(500, 0);\n        for (int i = 0; i < 100; i++)\n        {\n            var m = i % 5 == 1 ? 5 : 2;\n            pq.Push(new P { a = true, id = i, m = m, t = 5 * i });\n        }\n        var wait = new int[100];\n        var q = new Queue<P>();\n        sheet = new int[17];\n        for (int i = 0; i < 17; i++) sheet[i] = -1;\n        while (pq.Count() > 0)\n        {\n            var w = pq.Pop();\n            if (w.a) q.Enqueue(w);\n            else remove(w.id);\n            while (true)\n            {\n                if (q.Count() == 0) break;\n                var w2 = q.Peek();\n                if (check(w2.id, w2.m))\n                {\n\n                    var t = 17 * (w2.id % 2) + 3 * (w2.id % 3) + 19;\n                    var m = w2.m;\n                    pq.Push(new P { a = false, id = w2.id, m = m, t = w.t + t });\n\n                    q.Dequeue();\n                    wait[w2.id] = w.t - 5 * w2.id;\n                }\n                else break;\n            }\n        }\n        string s;\n        for (; (s = Console.ReadLine()) != null;)\n        {\n            var n = int.Parse(s.Trim());\n            Console.WriteLine(wait[n]);\n        }\n    }\n    static void remove(int id)\n    {\n        for (int i = 0; i < 17; i++)\n            if (sheet[i] == id) sheet[i] = -1;\n    }\n    static bool check(int id, int m)\n    {\n        var p = 0;\n        var count = 0;\n        var flag = false;\n        while (p < 17)\n        {\n            if (sheet[p] == -1)\n            {\n                count++;\n                if (flag)\n                    if (count == m)\n                    {\n                        for (int i = 0; i < m; i++) sheet[p - i] = id;\n                        return true;\n                    }\n                    else flag = true;\n                else flag = true;\n            }\n            else { flag = false; count = 0; }\n            p++;\n        }\n        return false;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Customer\n    {\n        internal int nums, wait, arrival, stay;\n    }\n\n    class Problem\n    {\n        readonly int n = 100;\n\n        Customer[] cs;\n        Queue<int> waiting;\n        int[] seats;\n        int time, minStay;\n\n        public Problem()\n        {\n            cs = new Customer[n];\n            waiting = new Queue<int>();\n            seats = Enumerable.Repeat(-1, 17).ToArray();\n            time = 0;\n            minStay = int.MaxValue;\n        }\n\n        public int SearchWaitTime(int id)\n        {\n            return cs[id].wait;\n        }\n\n        public void MakeMap()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                Customer temp;\n                temp.nums = (i % 5 == 1) ? 5 : 2;\n                temp.wait = 0;\n                temp.arrival = time;\n                temp.stay = 17 * (i % 2) + 3 * (i % 3) + 19;\n                cs[i] = temp;\n\n                int seatIdx = CheckSeat(i, true);\n\n                if (seatIdx != -1)\n                {\n                    SetSeat(i, seatIdx);\n                }\n                else\n                {\n                    waiting.Enqueue(i);\n                }\n\n                for (int j = 0; j < 5; j++)\n                {\n                    CheckLeave();\n                }\n            }\n\n            while (waiting.Count > 0)\n            {\n                CheckLeave();\n            }\n        }\n\n        private void CheckLeave()\n        {\n            if (time == minStay)\n            {\n                int tempMin = int.MaxValue;\n\n                for (int k = 0; k < seats.Length; k++)\n                {\n                    if (seats[k] == -1) continue;\n\n                    if (seats[k] == minStay)\n                    {\n                        seats[k] = -1;\n                    }\n                    else\n                    {\n                        tempMin = Math.Min(tempMin, seats[k]);\n                    }\n                }\n                minStay = tempMin;\n\n                CheckWait();\n            }\n            time++;\n        }\n\n        private void CheckWait()\n        {\n            while (waiting.Count > 0)\n            {\n                int tempId = waiting.Peek();\n                int tempSt = CheckSeat(tempId, false);\n\n                if (tempSt != -1)\n                {\n                    SetSeat(tempId, tempSt);\n\n                    cs[tempId].wait = time - cs[tempId].arrival;\n                    waiting.Dequeue();\n                }\n                else return;\n            }\n        }\n\n        private void SetSeat(int id, int idx)\n        {\n            int temp = cs[id].stay + time;\n\n            for (int i = 0; i < cs[id].nums; i++)\n            {\n                seats[idx + i] = temp;\n            }\n            minStay = Math.Min(minStay, temp);\n        }\n\n        private int CheckSeat(int id, bool isArrival)\n        {\n            if (isArrival && waiting.Count > 0) return -1;\n\n            int num = cs[id].nums;\n            int len = seats.Length - num;\n\n            for (int i = 0; i <= len; i++)\n            {\n                bool isOpen = true;\n\n                for (int j = 0; j < num; j++)\n                {\n                    if (seats[i + j] != -1) isOpen = false;\n                }\n                if (isOpen) return i;\n            }\n            return -1;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            Problem p = new Problem();\n            p.MakeMap();\n\n            string input;\n\n            while (!string.IsNullOrEmpty(input = Console.ReadLine()))\n            {\n                int n = int.Parse(input);\n\n                sb.AppendLine(p.SearchWaitTime(n).ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0147\n{\n    public class Program\n\n    {\n        static Client[] seat = new Client[17];\n        static Queue<Client> clients = new Queue<Client>(100);\n        static Queue<Client> waiting = new Queue<Client>(100);\n        static Dictionary<int, int> position = new Dictionary<int, int>(2) { { 2, 0 }, { 5, 0 } };\n\n        class Client\n        {\n            public int ID { get; }\n            public int Count { get; }\n            public int MealTimes { get; }\n            public int VisitClock { get; }\n            public int SeatingClock { get; private set; }\n            public int LeaveClock { get; private set; }\n\n            public Client(int i)\n            {\n                ID = i;\n                Count = i % 5 == 1 ? 5 : 2;\n                MealTimes = 17 * (i % 2) + 3 * (i % 3) + 19;\n                VisitClock = 5 * i;\n            }\n\n            public void Seating(int i)\n            {\n                SeatingClock = i;\n                LeaveClock = i + MealTimes;\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n\n            Dictionary<int, int> WaitTime = new Dictionary<int, int>(100);\n            for (int i = 0 ; i < 100 ; i++) clients.Enqueue(new Client(i));\n\n            int t = 0;\n            CalcSeatPos();\n\n            do\n            {\n                //visitsProcessing\n                if (clients.Count() > 0 && clients.Peek().VisitClock == t) waiting.Enqueue(clients.Dequeue());\n\n                //leaveProcessing\n                if (Leave(t)) CalcSeatPos();\n\n                //seatingProcessing\n                while (waiting.Count > 0)\n                {\n                    int pos = position[waiting.Peek().Count];\n                    if (pos >= 0)\n                    {\n                        Client tmp = waiting.Dequeue();\n                        tmp.Seating(t);\n                        for (int i = 0 ; i < tmp.Count ; i++) seat[pos + i] = tmp;\n                        CalcSeatPos();\n                        WaitTime.Add(tmp.ID, tmp.SeatingClock - tmp.VisitClock);\n                    }\n                    else break;\n                }\n\n                t++;\n\n            } while (clients.Count > 0 | waiting.Count > 0 | seat.Any(x => x != null));\n\n            while (true)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line)) return;\n                Console.WriteLine(WaitTime[int.Parse(line)]);\n            }\n        }\n\n        private static bool Leave(int t)\n        {\n            bool res = false;\n            for (int i = 0 ; i < seat.Count() ; i++)\n            {\n                if (seat[i] != null && seat[i].LeaveClock == t)\n                {\n                    seat[i] = null;\n                    res = true;\n                }\n            }\n            return res;\n        }\n\n\n        private static void CalcSeatPos()\n        {\n            int pos2 = -1;\n            int pos5 = -1;\n            int continuousVacancy = 0;\n            for (int i = 0 ; i < seat.Count() ; i++)\n            {\n                if (seat[i] == null) continuousVacancy++;\n                else continuousVacancy = 0;\n\n                if (pos2 == -1 && continuousVacancy == 2) pos2 = i - 1;\n                if (pos5 == -1 && continuousVacancy == 5) pos5 = i - 4;\n                if (pos2 >= 0 && pos5 >= 0) break;\n            }\n\n            position[2] = pos2;\n            position[5] = pos5;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Customer\n    {\n        internal int nums, wait, arrival, stay;\n    }\n\n    class Problem\n    {\n        readonly int n = 100;\n\n        Customer[] cs;\n        Queue<int> waiting;\n        int[] seats;\n        int time, minStay;\n\n        public Problem()\n        {\n            cs = new Customer[n];\n            waiting = new Queue<int>();\n            seats = Enumerable.Repeat(-1, 17).ToArray();\n            time = 0;\n            minStay = int.MaxValue;\n        }\n\n        public int SearchWaitTime(int id)\n        {\n            return cs[id].wait;\n        }\n\n        public void MakeMap()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                Customer temp;\n                temp.nums = (i % 5 == 1) ? 5 : 2;\n                temp.wait = 0;\n                temp.arrival = time;\n                temp.stay = 17 * (i % 2) + 3 * (i % 3) + 19;\n                cs[i] = temp;\n\n                int seatIdx = CheckSeat(i, true);\n\n                if (seatIdx != -1)\n                {\n                    SetSeat(i, seatIdx);\n                }\n                else\n                {\n                    waiting.Enqueue(i);\n                }\n\n                for (int j = 0; j < 5; j++)\n                {\n                    CheckLeave();\n                }\n            }\n\n            while (waiting.Count > 0)\n            {\n                CheckLeave();\n            }\n        }\n\n        private void CheckLeave()\n        {\n            if (time == minStay)\n            {\n                int tempMin = int.MaxValue;\n\n                for (int k = 0; k < seats.Length; k++)\n                {\n                    if (seats[k] == -1) continue;\n\n                    if (seats[k] == minStay)\n                    {\n                        seats[k] = -1;\n                    }\n                    else\n                    {\n                        tempMin = Math.Min(tempMin, seats[k]);\n                    }\n                }\n                minStay = tempMin;\n\n                CheckWait();\n            }\n            time++;\n        }\n\n        private void CheckWait()\n        {\n            while (waiting.Count > 0)\n            {\n                int id = waiting.Peek();\n                int idx = CheckSeat(id, false);\n\n                if (idx != -1)\n                {\n                    SetSeat(id, idx);\n\n                    cs[id].wait = time - cs[id].arrival;\n                    waiting.Dequeue();\n                }\n                else return;\n            }\n        }\n\n        private void SetSeat(int id, int idx)\n        {\n            int temp = cs[id].stay + time;\n\n            for (int i = 0; i < cs[id].nums; i++)\n            {\n                seats[idx + i] = temp;\n            }\n            minStay = Math.Min(minStay, temp);\n        }\n\n        private int CheckSeat(int id, bool isArrival)\n        {\n            if (isArrival && waiting.Count > 0) return -1;\n\n            int num = cs[id].nums;\n            int len = seats.Length - num;\n\n            for (int i = 0; i <= len; i++)\n            {\n                bool isOpen = true;\n\n                for (int j = 0; j < num; j++)\n                {\n                    if (seats[i + j] != -1) isOpen = false;\n                }\n                if (isOpen) return i;\n            }\n            return -1;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            Problem p = new Problem();\n            p.MakeMap();\n\n            string input;\n\n            while (!string.IsNullOrEmpty(input = Console.ReadLine()))\n            {\n                int n = int.Parse(input);\n\n                sb.AppendLine(p.SearchWaitTime(n).ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Customer\n    {\n        internal int num, wait, arrival, stay;\n    }\n\n    class Problem\n    {\n        readonly int n = 100;\n\n        Customer[] cs;\n        Queue<int> waiting;\n        int[] seats;\n        int time, minStay;\n\n        public Problem()\n        {\n            cs = new Customer[n];\n            waiting = new Queue<int>();\n            seats = Enumerable.Repeat(-1, 17).ToArray();\n            time = 0;\n            minStay = int.MaxValue;\n        }\n\n        public int SearchWaitTime(int id)\n        {\n            return cs[id].wait;\n        }\n\n        public void MakeMap()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                Customer temp;\n                temp.num = (i % 5 == 1) ? 5 : 2;\n                temp.wait = 0;\n                temp.arrival = time;\n                temp.stay = 17 * (i % 2) + 3 * (i % 3) + 19;\n                cs[i] = temp;\n\n                if (waiting.Count > 0) waiting.Enqueue(i);\n                else\n                {\n                    int seatIdx = CheckSeat(i);\n\n                    if (seatIdx != -1) SetSeat(i, seatIdx);\n                    else waiting.Enqueue(i);\n                }\n\n                for (int j = 0; j < 5; j++) CheckLeave();\n            }\n\n            while (waiting.Count > 0) CheckLeave();\n        }\n\n        private void CheckLeave()\n        {\n            if (time == minStay)\n            {\n                int tempMin = int.MaxValue;\n\n                for (int k = 0; k < seats.Length; k++)\n                {\n                    if (seats[k] == -1) continue;\n\n                    if (seats[k] == minStay) seats[k] = -1;\n                    else tempMin = Math.Min(tempMin, seats[k]);\n                }\n                minStay = tempMin;\n\n                CheckWait();\n            }\n            time++;\n        }\n\n        private void CheckWait()\n        {\n            while (waiting.Count > 0)\n            {\n                int id = waiting.Peek();\n                int idx = CheckSeat(id);\n\n                if (idx != -1)\n                {\n                    SetSeat(id, idx);\n\n                    cs[id].wait = time - cs[id].arrival;\n                    waiting.Dequeue();\n                }\n                else return;\n            }\n        }\n\n        private void SetSeat(int id, int idx)\n        {\n            int temp = cs[id].stay + time;\n\n            for (int i = 0; i < cs[id].num; i++)\n            {\n                seats[idx + i] = temp;\n            }\n            minStay = Math.Min(minStay, temp);\n        }\n\n        private int CheckSeat(int id)\n        {\n            int num = cs[id].num;\n            int len = seats.Length - num;\n\n            for (int i = 0; i <= len; i++)\n            {\n                bool isOpen = true;\n\n                for (int j = 0; j < num; j++)\n                {\n                    if (seats[i + j] != -1) isOpen = false;\n                }\n                if (isOpen) return i;\n            }\n            return -1;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            Problem p = new Problem();\n            p.MakeMap();\n\n            string input;\n\n            while (!string.IsNullOrEmpty(input = Console.ReadLine()))\n            {\n                int n = int.Parse(input);\n\n                sb.AppendLine(p.SearchWaitTime(n).ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Customer\n    {\n        internal int num, wait, arrival, stay;\n    }\n\n    class Problem\n    {\n        readonly int n = 100;\n\n        Customer[] cs;\n        Queue<int> waiting;\n        int[] seats;\n        int time, minStay;\n\n        public Problem()\n        {\n            cs = new Customer[n];\n            waiting = new Queue<int>();\n            seats = Enumerable.Repeat(-1, 17).ToArray();\n            time = 0;\n            minStay = int.MaxValue;\n        }\n\n        public int SearchWaitTime(int id)\n        {\n            return cs[id].wait;\n        }\n\n        public void MakeMap()\n        {\n            for (int i = 0; i < n; i++)\n            {\n                Customer c;\n                c.num = (i % 5 == 1) ? 5 : 2;\n                c.wait = 0;\n                c.arrival = time;\n                c.stay = 17 * (i % 2) + 3 * (i % 3) + 19;\n                cs[i] = c;\n\n                if (waiting.Count > 0)\n                {\n                    waiting.Enqueue(i);\n                }\n                else\n                {\n                    int idx = CheckSeat(i);\n\n                    if (idx != -1) SetSeat(i, idx);\n                    else waiting.Enqueue(i);\n                }\n\n                for (int j = 0; j < 5; j++) CheckLeave();\n            }\n\n            while (waiting.Count > 0) CheckLeave();\n        }\n\n        private void CheckLeave()\n        {\n            if (time == minStay)\n            {\n                int tempMin = int.MaxValue;\n\n                for (int k = 0; k < seats.Length; k++)\n                {\n                    if (seats[k] == -1) continue;\n\n                    if (seats[k] == minStay) seats[k] = -1;\n                    else tempMin = Math.Min(tempMin, seats[k]);\n                }\n                minStay = tempMin;\n\n                CheckWait();\n            }\n            time++;\n        }\n\n        private void CheckWait()\n        {\n            while (waiting.Count > 0)\n            {\n                int id = waiting.Peek();\n                int idx = CheckSeat(id);\n\n                if (idx != -1)\n                {\n                    SetSeat(id, idx);\n                    cs[id].wait = time - cs[id].arrival;\n                    waiting.Dequeue();\n                }\n                else return;\n            }\n        }\n\n        private void SetSeat(int id, int idx)\n        {\n            int temp = cs[id].stay + time;\n\n            for (int i = 0; i < cs[id].num; i++)\n            {\n                seats[idx + i] = temp;\n            }\n            minStay = Math.Min(minStay, temp);\n        }\n\n        private int CheckSeat(int id)\n        {\n            int num = cs[id].num;\n            int len = seats.Length - num;\n\n            for (int i = 0; i <= len; i++)\n            {\n                bool isOpen = true;\n\n                for (int j = 0; j < num; j++)\n                {\n                    if (seats[i + j] != -1) isOpen = false;\n                }\n                if (isOpen) return i;\n            }\n            return -1;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            Problem p = new Problem();\n            p.MakeMap();\n\n            string input;\n\n            while (!string.IsNullOrEmpty(input = Console.ReadLine()))\n            {\n                int n = int.Parse(input);\n                sb.AppendLine(p.SearchWaitTime(n).ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\npublic class P2 : IComparable\n{\n    public int id { get; set; }\n    public int dtime { get; set; }\n    public int sid { get; set; }\n    public int mem { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (P2)obj;\n        if (this.dtime > x.dtime) return 1;\n        else if (this.dtime == x.dtime) return 0;\n        else return -1;\n    }\n}\npublic class P\n{\n    public int id { get; set; }\n    public int atime { get; set; }\n    public int mem { get; set; }\n    public int mtime { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string line;\n        for (; (line = Console.ReadLine()) != null;)\n        {\n            var n = int.Parse(line.Trim());\n            var q = new Queue<P>();\n            for (int i = 0; i <= n; i++)\n            {\n                var w = 17 * (i % 2) + 3 * (i % 3) + 19;\n                q.Enqueue(new P { id = i, atime = 5 * i, mtime = w, mem = i % 5 == 1 ? 5 : 2 });\n            }\n            var s = new bool[17];\n            var pq = new PriorityQueue<P2>(100, 0);\n            var now = 0;\n            var wait = false;\n            for (int i = 0; i <= 1000; i++)\n            {\n                if (pq.Count() > 0)\n                {\n                    var te = pq.Peek();\n                    var te2 = q.Peek();\n                    if (te.dtime <= te2.atime | wait)\n                    {\n                        wait = false;\n                        pq.Pop();\n                        now = te.dtime;\n                        reLSeat(s, te.sid, te.mem);\n                    }\n                    else\n                    {\n                        now = Math.Max(now, te2.atime);\n                        if (putSeat(pq, s, te2, now, n))\n                        {\n                            if (n == te2.id) {  Console.WriteLine(now - te2.atime); goto next; }\n                            q.Dequeue();\n                        }\n                        else wait = true;\n                    }\n                }\n                else\n                {\n                    var te2 = q.Dequeue();\n                    now = te2.atime;\n                    putSeat(pq, s, te2, now, n);\n                }\n            }\n            next:;\n        }\n    }\n    public static bool putSeat(PriorityQueue<P2> pq, bool[] s, P te2, int now, int n)\n    {\n        var ws = checkSeat(s, te2.mem);\n        if (ws == -1) return false;\n        else\n        {\n            if (n == te2.id) {  return true; }\n            pq.Push(new P2 { id = te2.id, dtime = now + te2.mtime, sid = ws, mem = te2.mem });\n            return true;\n        }\n    }\n    public static void reLSeat(bool[] s, int a, int b)\n    {\n        for (int i = a; i <= a + b - 1; i++) s[i] = false;\n    }\n    public static int checkSeat(bool[] s, int n)\n    {\n        if (n == 5)\n        {\n            for (int i = 0; i <= 12; i++)\n                if (!s[i] && !s[i + 1] && !s[i + 2] && !s[i + 3] && !s[i + 4])\n                {\n                    s[i] = true; s[i + 1] = true; s[i + 2] = true; s[i + 3] = true; s[i + 4] = true;\n                    return i;\n                }\n            return -1;\n        }\n        else\n        {\n            for (int i = 0; i <= 15; i++)\n                if (!s[i] && !s[i + 1]) { s[i] = true; s[i + 1] = true; return i; }\n            return -1;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\npublic class P2 : IComparable\n{\n    public int id { get; set; }\n    public int dtime { get; set; }\n    public int sid { get; set; }\n    public int mem { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (P2)obj;\n        if (this.dtime > x.dtime) return 1;\n        else if (this.dtime == x.dtime) return 0;\n        else return -1;\n    }\n}\npublic class P\n{\n    public int id { get; set; }\n    public int atime { get; set; }\n    public int mem { get; set; }\n    public int mtime { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        string line;\n        for (; (line = Console.ReadLine()) != null;)\n        {\n            var n = int.Parse(line.Trim());\n            var q = new Queue<P>();\n            for (int i = 0; i <= n; i++)\n            {\n                var w = 17 * (i % 2) + 3 * (i % 3) + 19;\n                q.Enqueue(new P { id = i, atime = 5 * i, mtime = w, mem = i % 5 == 1 ? 5 : 2 });\n            }\n            var s = new bool[17];\n            var pq = new PriorityQueue<P2>(100, 0);\n            var now = 0;\n            var wait = false;\n            for (int i = 0; i <= 100; i++)\n            {\n                if (pq.Count() > 0)\n                {\n                    var te = pq.Peek();\n                    var te2 = q.Peek();\n                    if (te.dtime <= te2.atime | wait)\n                    {\n                        wait = false;\n                        pq.Pop();\n                        now = te.dtime;\n                        reLSeat(s, te.sid, te.mem);\n                    }\n                    else\n                    {\n                        now = Math.Max(now, te2.atime);\n                        if (putSeat(pq, s, te2, now, n))\n                        {\n                            if (n == te2.id) {  Console.WriteLine(now - te2.atime); goto next; }\n                            q.Dequeue();\n                        }\n                        else wait = true;\n                    }\n                }\n                else\n                {\n                    var te2 = q.Dequeue();\n                    now = te2.atime;\n                    putSeat(pq, s, te2, now, n);\n                }\n            }\n            next:;\n        }\n    }\n    public static bool putSeat(PriorityQueue<P2> pq, bool[] s, P te2, int now, int n)\n    {\n        var ws = checkSeat(s, te2.mem);\n        if (ws == -1) return false;\n        else\n        {\n            if (n == te2.id) {  return true; }\n            pq.Push(new P2 { id = te2.id, dtime = now + te2.mtime, sid = ws, mem = te2.mem });\n            return true;\n        }\n    }\n    public static void reLSeat(bool[] s, int a, int b)\n    {\n        for (int i = a; i <= a + b - 1; i++) s[i] = false;\n    }\n    public static int checkSeat(bool[] s, int n)\n    {\n        if (n == 5)\n        {\n            for (int i = 0; i <= 12; i++)\n                if (!s[i] && !s[i + 1] && !s[i + 2] && !s[i + 3] && !s[i + 4])\n                {\n                    s[i] = true; s[i + 1] = true; s[i + 2] = true; s[i + 3] = true; s[i + 4] = true;\n                    return i;\n                }\n            return -1;\n        }\n        else\n        {\n            for (int i = 0; i <= 15; i++)\n                if (!s[i] && !s[i + 1]) { s[i] = true; s[i + 1] = true; return i; }\n            return -1;\n        }\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n \nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n \nfunction calc(){\n  var seats = new Int32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n  var groupMembers = new Int32Array([2,5,2,2,2]);\n  var eatTimes = new Int32Array([19,39,25,36,22,42]);\n   \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = new Int32Array(100);\n  var lastMembers = 100;\n   \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n     \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n     \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n       \n      for(i = 0; i < 17; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n         \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n \n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n           \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n     \n    pastMinutes++;\n  }\n   \n}\n \nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n  var waitTime = [0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71];\n  for(var i = 0; i < (input.length - 1); i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n\nvar waitTime = [0,\n0,\n0,\n0,\n0,\n0,\n14,\n9,\n4,\n0,\n0,\n8,\n3,\n2,\n0,\n0,\n15,\n10,\n15,\n10,\n6,\n12,\n7,\n9,\n11,\n6,\n23,\n18,\n13,\n8,\n3,\n23,\n18,\n13,\n8,\n3,\n34,\n29,\n24,\n22,\n17,\n28,\n23,\n24,\n19,\n27,\n34,\n29,\n35,\n30,\n28,\n31,\n28,\n23,\n24,\n28,\n42,\n37,\n32,\n27,\n22,\n42,\n37,\n32,\n27,\n22,\n53,\n48,\n43,\n41,\n36,\n47,\n42,\n43,\n38,\n46,\n64,\n59,\n54,\n49,\n44,\n61,\n56,\n51,\n46,\n44,\n72,\n67,\n62,\n57,\n52,\n72,\n67,\n62,\n57,\n52,\n83,\n78,\n73,\n71];\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n \nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n \nfunction calc(){\n  var seats = new Int32Array(17);\n  var groupMembers = new Int32Array([2,5,2,2,2]);\n  var eatTimes = new Int32Array([19,39,25,36,22,42]);\n   \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = new Int32Array(100);\n  var lastMembers = 100;\n   \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n     \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n     \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n       \n      for(i = 0; i < 17; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n         \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n \n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n           \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n     \n    pastMinutes++;\n  }\n   \n}\n \nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main(){\n  var groupMems = [2, 5, 2, 2, 2];\n  var eatTimes = [19, 39, 25, 36, 22, 42];\n\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n  var waitTimes; // 待ち時間\n  var headGroup = null; // 待ちの先頭\n  var pastMinutes; // 経過時間\n  var sitGroup = 0; // 座ったグループ数\n\n  while(sitGroup <= 100){\n    // たべる\n    for(var seatNo = 0; seatNo < seats.length; seatNo++){\n      seats[seatNo] = seats[seatNo] == 0 ? 0 : seatNo - 1;\n    }\n    // らいてん\n    if(headGroup === null && pastMinutes % 5 == 0){\n      headGroup = Math.floor(pastMinutes / 5);\n    }\n\n    // 座る\n    var sit = true;\n    while(headGroup != null && sit == true){\n      var needsSequencial = groupMems[headGroup % 5];\n      var sequancialSeats = 0;\n      var startIndex = -1;\n      for(var seatNo = 0; seatNo < 17; seatNo++){\n        sequencialSeats = seats[seatNo] == 0 ? sequencialSeats + 1 : 0; \n        if(sequencialSeats == needsSequencial){\n          startIndex = seatNo - (needsSequencial - 1);\n          break;\n        }\n      }\n\n      if(startIndex != -1){\n        // 座れた\n       waitTimes[headGroup] = pastMinutes - (headGroup * 5);\n       sit = true;\n       sitGroup++;\n       for(var seatNo = startIndex; seatNo < needsSequencial; seatNo++){\n         seats[seatNo] = eatTimes[headGroup % 5];\n       }\n       if(headGroup * 5 < pastMinutes){\n         // まだ客がいる\n         headGroup++;\n       }else{\n         headGroup = null;\n       }\n      }else{\n        // すわれなかった\n        sit = false;\n      }\n\n    }\n\n  }\n\n  for(var i = 0; i < input.length; i++){\n    console.log(waitTimes[input[i]]);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 100){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < (input.length - 1); i++){\n  var idx = parseInt(input[i], idx);\n  console.log(waitTime[idx]);\n}\n\n}\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 99){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}\n\nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 99){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 100){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n\n}\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length <= 100){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}\n\nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main(){\n  var groupMems = {2, 5, 2, 2, 2};\n  var eatTimes = {19, 39, 25, 36, 22, 42};\n\n  var seats = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n\n  var waitTimes; // 待ち時間\n  var headGroup = null; // 待ちの先頭\n  var pastMinutes; // 経過時間\n  var sitGroup = 0; // 座ったグループ数\n\n  while(sitGroup <= 100){\n    // たべる\n    for(var seatNo = 0; seatNo < 17; seatNo++){\n      seats[seatNo] = seats[seatNo] == 0 ? 0 : seatNo - 1;\n    }\n    // らいてん\n    if(headGroup === null && pastMinutes % 5 == 0){\n      headGroup = Math.floor(pastMinutes / 5);\n    }\n\n    // 座る\n    var sit = true;\n    while(headGroup != null && sit == true){\n      var needsSequencial = groupMems[headGroup % 5];\n      var sequancialSeats = 0;\n      var startIndex = -1;\n      for(var seatNo = 0; seatNo < 17; seatNo++){\n        sequencialSeats = seats[seatNo] == 0 ? sequencialSeats + 1 : 0; \n        if(sequencialSeats == needsSequencial){\n          startIndex = seatNo - (needsSequencial - 1);\n          break;\n        }\n      }\n\n      if(startIndex != -1){\n        // 座れた\n       waitTimes[headGroup] = pastMinutes - (headGroup * 5);\n       sit = true;\n       sitGroup++;\n       for(var seatNo = startIndex; seatNo < needsSequencial; seatNo++){\n         seats[seatNo] = eatTimes[headGroup % 5];\n       }\n       if(headGroup * 5 < pastMinutes){\n         // まだ客がいる\n         headGroup++;\n       }else{\n         headGroup = null;\n       }\n      }else{\n        // すわれなかった\n        sit = false;\n      }\n\n    }\n\n  }\n\n  for(var i = 0; i < input.length; i++){\n    console.log(waitTimes[input[i]]);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nfor(var waits = 0; waits < 100;){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n      waits++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}\n\nvar input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n  var waitTime = [0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71];\n  for(var i = 0; i < input.length; i++){\n    var idx = parseInt(input[i], 10);\n    console.log(waitTime[idx]);\n  }\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar lastMembers = 100;\n  \nwhile(true){\n  // たべおわる\n  var i;\n  for(i = 17; i--;){\n    seats[i] = max(--seats[i], 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1 && i != 17){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    \n    for(i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        // すわれるみたい\n        waitTime[headGroup] = pastMinutes - (headGroup * 5);\n        for(var j = startIndex; j < (needsSequencialSeats + startIndex); j++){\n          seats[j] = eatTimes[headGroup % 6];\n        }\n        \n        headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n        if(!(--lastMembers)){\n          // 100グループ着席\n          return;\n        }\n        break;\n      }\n    }\n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction max(a, b){\n var t = (a - b);\n return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n \nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n \nfunction calc(){\n  var seats = new Int32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n  var groupMembers = new Int32Array([2,5,2,2,2]);\n  var eatTimes = new Int32Array([19,39,25,36,22,42]);\n   \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = new Int32Array(100);\n  var lastMembers = 100;\n   \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n     \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n     \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n       \n      for(i = 0; i < 17; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n         \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n \n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n           \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n     \n    pastMinutes++;\n  }\n   \n}\n \nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length <= 100){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}\n\nvar input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n\nfunction calc(){\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var groupMembers = [2,5,2,2,2];\n  var eatTimes = [19,39,25,36,22,42];\n  \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var lastMembers = 100;\n  \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n    \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n    \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n      \n      for(i = 0, len = seats.length; i < len; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n        \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n\n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n          \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n    \n    pastMinutes++;\n  }\n  \n}\n\nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n  \n// ここから\nfunction main(){\n  var readLines = 0;\n  while(true){\n    var fieldInfo = input[readLines].split(' ');\n    var width = fieldInfo[0] - 0;//toInt\n    var height = fieldInfo[1] - 0;//toInt\n      \n    // 0 0が入力された\n    if(!width && !height){\n      break;\n    }\n  \n    var start;\n    var goal;\n    var elem = [[],[],[],[],[]]; // 場にいるパチモン[属性][属性内連番]\n    var c;\n    var rowData;\n    var elemCache;\n    var y;\n    var x;\n      \n    for(y = height; y--;){// reverse loop\n      readLines++;//1行進める\n      rowData = input[readLines];\n      for(x = width; x--;){// reverse loop\n        c = rowData[x];\n          \n        if(c == '.'){\n          // ドットが一番多いはずなので、先にひっかけてしまう\n        }else if(c == '1' || c == '2' || c == '3' || c == '4' || c == '5'){\n          // 次に多いはずの属性を潰す\n          elemCache = elem[c - 1];\n          elemCache[elemCache.length] = pos(x, y);\n        }else if(c == 'S'){\n          start = pos(x, y);\n        }else{\n          goal = pos(x, y);\n        }\n          \n      }\n    }\n  \n    // ブロックスコープが無いから変数宣言をまとめる\n    var selectElem;\n    var INF = 1 << 30;\n    var bestElement = -1;\n    var currentDisance;\n    var nearestDistance = INF;\n    var dp; // 距離[属性][同じ属性内の連番]\n    var i; // loop index\n    var j;\n    var e;\n    var len;\n    var dpCacheNow; // cache of dp[i] for loop\n    var dpCacheNowi; // cache of dp[now][i]\n    var dpCacheNext; // cache of dp[i + 1] for loop\n    var elemCacheNow;\n    var elemCacheNowi; // cache of elem[now][i]\n    var elemCacheNext;\n    var now;\n    var nowLength;\n    var next;\n    var nextLength;\n      \n    // 最初に選ぶ属性ごとにループ\n    for (selectElem = 0; selectElem < 5; selectElem++) {\n      dp = [[],[],[],[],[]]; // 距離[属性][同じ属性内の連番]\n  \n      for(i = 5; i--;){// reverse loop\n        len  = elem[i].length;\n        dp[i].length = len;\n        dpCache = dp[i];\n        while(len--){// reverse loop\n          dpCache[len] = INF;\n        }\n      }\n        \n      now = (selectElem + 1) % 5;\n      nowLength = elem[now].length;\n      dpCacheNow = dp[now];\n      elemCacheNow= elem[now];\n        \n      for (i = 0; i < nowLength; i++) {\n        // s→e1を計算\n        dpCacheNow[i] = dist(start, elemCacheNow[i]);\n      }\n                        \n      // s->1->2->3->4->g\n      // なので、ループは間の-> * 3分まわす\n      for (e = 0; e < 3; e++) {\n        // e(x)->e(x+1)\n        next = (now + 1) % 5;\n        dpCacheNext = dp[next];\n        elemCacheNext = elem[next];\n        nextLength = elemCacheNext.length;\n        for (i = 0; i < nowLength; i++) {\n          dpCacheNowi = dpCacheNow[i];\n          elemCacheNowi = elemCacheNow[i];\n   \n          if(dpCacheNowi >= nearestDistance){\n            // 既に決まっている最短距離を超えたら絶対に候補ではない\n            continue;\n          }\n   \n          for (j = 0; j < nextLength; j++) {\n            dpCacheNext[j] = min(dpCacheNext[j], dpCacheNowi + dist(elemCacheNowi, elemCacheNext[j])); // メモと新しい経路の最短\n          }\n        }\n          \n        now = next;\n        dpCacheNow = dpCacheNext;\n        elemCacheNow = elemCacheNext;\n        nowLength = nextLength;\n      }\n  \n      for (i = 0; i < nextLength; i++) {\n        // e4->g\n        currentDistance = dpCacheNext[i] + dist(elemCacheNext[i], goal);\n                          \n        if (currentDistance < nearestDistance) {\n          nearestDistance = currentDistance;\n          bestElement = selectElem;\n        }\n          \n      }\n        \n    }\n      \n    if (nearestDistance == INF) {\n      console.log(\"NA\");\n    } else {\n      console.log((bestElement + 1) + \" \" + nearestDistance);\n    }\n                  \n    readLines++;\n  }\n    \n}\n                  \nfunction dist(from, to){\n  // x座標とy座標の切り出し(10ビット右シフトでxを、1023 = 2^10 -1とのAND演算でyを取り出す)\n  return abs((from >> 10) - (to >> 10)) + abs((from & 0x03FF) - (to & 0x03FF));\n}\n                  \nfunction min(a, b){\n  // ビット演算で高速化\n return b + ((a - b) & ((a - b) >> 31));// 変数宣言よりもこっちの方が高速\n}\n                  \nfunction pos(a, b){\n  // オブジェクトのインスタンス作るよりもプリミティブの方が早い\n  // 座標はたかだか1k * 1kなので上位ビットと下位ビットで保持する\n  return (a << 10) + b;\n}\n                 \nfunction abs(a){\n // ビット演算で高速化\n  var t = a >> 31;\n  return (a ^ t) - t;\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\n// ここから\nfunction main(){\n  // faster initialize\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n  var groupMembers = [2,5,2,2,2];\n  var eatTimes = [19,39,25,36,22,42];\n  var headGroup = -1;\n  var pastMinutes = 0;\n  var lastMembers = 100;\n  var notWait = true;\n\n  var i;\n\n  \n  while(lastMembers){\n\n    // たべおわる\n    for(i = 17; i--;){\n      seats[i] = max(0, --seats[i]);\n    }\n    \n    // 来店\n    if(notWait && !(pastMinutes % 5)){\n      headGroup = pastMinutes / 5;// %5してるから絶対に整数\n    }\n    \n    // ちゃくせき\n    while(headGroup != -1){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n      for(i = 0; i < 17; i++){\n        sequencialSeats = seats[i] == 0 ? ++sequencialSeats : 0;\n        \n        if(sequencialSeats == needsSequencialSeats){\n          startIndex = i - (needsSequencialSeats - 1);\n          break;\n        }\n      }\n      \n      if(startIndex != -1){\n        // すわれたみたい\n        waitTime[headGroup] = pastMinutes - (headGroup * 5);\n        for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n          seats[i] = eatTimes[headGroup % 6];\n        }\n        \n        headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n        lastMembers--;\n      }else{\n        // すわれなかったみたい\n        break;\n      }\n      \n    }\n    \n    pastMinutes++;\n    \n  }\n  \n  for(var i = 0, len = input.length - 1; i < len; i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n  \n}\n\nfunction max(a, b){\n var t = (a - b);\n return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n  var waitTime = [0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71];\n  for(var i = 0; i < input.length; i++){\n    var idx = parseInt(input[i], 10);\n    console.log('%d', waitTime[idx]);\n  }\n}\nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nfor(var waits = 0; waits < 100;){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = ((headGroup * 5) < pastMinutes) ? headGroup + 1 : -1;\n      waits++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < input.length; i++){\n  console.log(waitTime[input[i]]);\n}\n\n}\n\nvar input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 99){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < (input.length - 1); i++){\n  var idx = parseInt(input[i], idx);\n  console.log(waitTime[idx]);\n}\n\n}\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main(){\n  var groupMems = [2, 5, 2, 2, 2];\n  var eatTimes = [19, 39, 25, 36, 22, 42];\n\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n  var waitTimes; // 待ち時間\n  var headGroup = null; // 待ちの先頭\n  var pastMinutes; // 経過時間\n  var sitGroup = 0; // 座ったグループ数\n\n  while(sitGroup <= 100){\n    // たべる\n    for(var seatNo = 0; seatNo < seats.length; seatNo++){\n      seats[seatNo] = seats[seatNo] == 0 ? 0 : seatNo - 1;\n    }\n    // らいてん\n    if(headGroup === null && pastMinutes % 5 == 0){\n      headGroup = Math.floor(pastMinutes / 5);\n    }\n\n    // 座る\n    var sit = true;\n    while(headGroup != null && sit == true){\n      var needsSequencial = groupMems[headGroup % 5];\n      var sequancialSeats = 0;\n      var startIndex = -1;\n      for(var seatNo = 0; seatNo < 17; seatNo++){\n        sequencialSeats = seats[seatNo] == 0 ? sequencialSeats + 1 : 0; \n        if(sequencialSeats == needsSequencial){\n          startIndex = seatNo - (needsSequencial - 1);\n          break;\n        }\n      }\n\n      if(startIndex != -1){\n        // 座れた\n       waitTimes[headGroup] = pastMinutes - (headGroup * 5);\n       sit = true;\n       sitGroup++;\n       for(var seatNo = startIndex; seatNo < needsSequencial; seatNo++){\n         seats[seatNo] = eatTimes[headGroup % 5];\n       }\n       if(headGroup * 5 < pastMinutes){\n         // まだ客がいる\n         headGroup++;\n       }else{\n         headGroup = null;\n       }\n      }else{\n        // すわれなかった\n        sit = false;\n      }\n\n    }\n\n    // けいか\n    pastMinutes++;\n\n  }\n\n  for(var i = 0; i < input.length; i++){\n    console.log(waitTimes[input[i]]);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n\nfunction calc(){\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var groupMembers = [2,5,2,2,2];\n  var eatTimes = [19,39,25,36,22,42];\n  \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var lastMembers = 100;\n  \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n    \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n    \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n      \n      for(i = 0, len = seats.length; i < len; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n        \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n\n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n          \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n    \n    pastMinutes++;\n  }\n  \n}\n\nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  for(var i = 17; i--;){\n    seats[i] = max(--seats[i], 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction max(a, b){\n var t = (a - b);\n return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n\nfunction calc(){\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var groupMembers = [2,5,2,2,2];\n  var eatTimes = [19,39,25,36,22,42];\n  \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var lastMembers = 100;\n  \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n    \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n    \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n      \n      for(i = 0; i < seats.length; i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n        \n        if(sequencialSeats == needsSequencialSeats){\n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex; j < (needsSequencialSeats + startIndex); j++){\n            seats[j] = eatTimes[headGroup % 6];\n          }\n          \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n    \n    pastMinutes++;\n  }\n  \n}\n\nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nfor(var waits = 0; waits < 100;){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = ((headGroup * 5) < pastMinutes) ? headGroup + 1 : -1;\n      waits++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\n\n\nconsole.log(waitTime[input]);\n\n}\n\nvar input = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "xhvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main(){\n  var groupMems = [2, 5, 2, 2, 2];\n  var eatTimes = [19, 39, 25, 36, 22, 42];\n\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n  var waitTimes = []; // 待ち時間\n  var headGroup = null; // 待ちの先頭\n  var pastMinutes = 0; // 経過時間\n  var sitGroup = 0; // 座ったグループ数\n\n  while(sitGroup <= 100){\n    // たべる\n    for(var seatNo = 0; seatNo < seats.length; seatNo++){\n      seats[seatNo] = seats[seatNo] == 0 ? 0 : seatNo - 1;\n    }\n    // らいてん\n    if(headGroup === null && pastMinutes % 5 == 0){\n      headGroup = Math.floor(pastMinutes / 5);\n    }\n\n    // 座る\n    var sit = true;\n    while(headGroup !== null && sit == true){\n      var needsSequencial = groupMems[headGroup % 5];\n      var sequancialSeats = 0;\n      var startIndex = -1;\n      for(var seatNo = 0; seatNo < 17; seatNo++){\n        sequencialSeats = seats[seatNo] == 0 ? sequencialSeats + 1 : 0; \n        if(sequencialSeats == needsSequencial){\n          startIndex = seatNo - (needsSequencial - 1);\n          break;\n        }\n      }\n\n      if(startIndex != -1){\n        // 座れた\n       waitTimes[headGroup] = pastMinutes - (headGroup * 5);\n       sit = true;\n       sitGroup++;\n       for(var seatNo = startIndex; seatNo < needsSequencial; seatNo++){\n         seats[seatNo] = eatTimes[headGroup % 5];\n       }\n       if(headGroup * 5 < pastMinutes){\n         // まだ客がいる\n         headGroup++;\n       }else{\n         headGroup = null;\n       }\n      }else{\n        // すわれなかった\n        sit = false;\n      }\n\n    }\n\n    // けいか\n    pastMinutes++;\n\n  }\n\n  for(var i = 0; i < input.length; i++){\n    console.log(waitTimes[input[i]]);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main(){\n  var groupMems = [2, 5, 2, 2, 2];\n  var eatTimes = [19, 39, 25, 36, 22, 42];\n\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n  var waitTimes = new Array(); // 待ち時間\n  var headGroup = null; // 待ちの先頭\n  var pastMinutes = 0; // 経過時間\n  var sitGroup = 0; // 座ったグループ数\n\n  while(sitGroup <= 100){\n    // たべる\n    for(var seatNo = 0; seatNo < seats.length; seatNo++){\n      seats[seatNo] = seats[seatNo] == 0 ? 0 : seatNo - 1;\n    }\n    // らいてん\n    if(headGroup === null && pastMinutes % 5 == 0){\n      headGroup = Math.floor(pastMinutes / 5);\n    }\n\n    // 座る\n    var sit = true;\n    while(headGroup !== null && sit == true){\n      var needsSequencial = groupMems[headGroup % 5];\n      var sequancialSeats = 0;\n      var startIndex = -1;\n      for(var seatNo = 0; seatNo < 17; seatNo++){\n        sequencialSeats = seats[seatNo] == 0 ? sequencialSeats + 1 : 0; \n        if(sequencialSeats == needsSequencial){\n          startIndex = seatNo - (needsSequencial - 1);\n          break;\n        }\n      }\n\n      if(startIndex != -1){\n        // 座れた\n       waitTimes[headGroup] = pastMinutes - (headGroup * 5);\n       sit = true;\n       sitGroup++;\n       for(var seatNo = startIndex; seatNo < needsSequencial; seatNo++){\n         seats[seatNo] = eatTimes[headGroup % 5];\n       }\n       if(headGroup * 5 < pastMinutes){\n         // まだ客がいる\n         headGroup++;\n       }else{\n         headGroup = null;\n       }\n      }else{\n        // すわれなかった\n        sit = false;\n      }\n\n    }\n\n    // けいか\n    pastMinutes++;\n\n  }\n\n  for(var i = 0; i < input.length; i++){\n    console.log(waitTimes[input[i]]);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 99){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < (input.length - 1); i++){\n  var idx = parseInt(input[i], idx);\n  console.log(waitTime[idx]);\n}\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = max(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n  var waitTime = [0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71];\n  for(var i = 0; i < input.length; i++){\n    var idx = parseInt(input[i], 10);\n    console.log(waitTime[idx]);\n  }\n}\nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n\nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n\nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n\nwhile(waitTime.length < 99){\n  // たべおわる\n  for(var i = 0; i < seats.length; i++){\n    seats[i] = seats[i] == 0 ? 0 : seats[i] - 1;\n  }\n\n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0; i < seats.length; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n\n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex; i < (needsSequencialSeats + startIndex); i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n      \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  pastMinutes++;\n\n}\n\nfor(var i = 0; i < (input.length - 1); i++){\n  console.log(waitTime[input[i]]);\n}\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "// 標準入力\nvar fs = require('fs'),\nlength = fs.fstatSync(process.stdin.fd).size,\nbuffer = new Buffer(length),\nbytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\ninput = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\n\nfunction main(){\n  var waitTime = calc();\n  for(var i = 0, len = input.length - 1; i < len;i++){\n    console.log(waitTime[parseInt(input[i], 10)]);\n  }\n}\n\nfunction calc(){\n  var seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var groupMembers = [2,5,2,2,2];\n  var eatTimes = [19,39,25,36,22,42];\n  \n  var headGroup = -1;\n  var pastMinutes = 0;\n  var waitTime = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n  var lastMembers = 100;\n  \n  while(true){\n    // たべおわる\n    var i;\n    for(i = 17; i--;){\n      seats[i] = max(--seats[i], 0);\n    }\n    \n    // 来店\n    if(headGroup == -1 && pastMinutes % 5 == 0){\n      headGroup = pastMinutes / 5;\n    }\n    \n    // ちゃくせき\n    while(headGroup != -1 && i != 17){\n      var needsSequencialSeats = groupMembers[headGroup % 5];\n      var sequencialSeats = 0;\n      var startIndex = -1;\n      \n      for(i = 0, len = seats.length; i < len i++){\n        sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n        \n        if(sequencialSeats == needsSequencialSeats){\n          var eatTime = eatTimes[headGroup % 6];\n\n          startIndex = i - (needsSequencialSeats - 1);\n          // すわれるみたい\n          waitTime[headGroup] = pastMinutes - (headGroup * 5);\n          for(var j = startIndex, len = (needsSequencialSeats + startIndex); j < len; j++){\n            seats[j] = eatTime;\n          }\n          \n          headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n          if(!(--lastMembers)){\n            // 100グループ着席\n            return waitTime;\n          }\n          break;\n        }\n      }\n    }\n    \n    pastMinutes++;\n  }\n  \n}\n\nfunction max(a, b){\n  var t = (a - b);\n  return a - (t & (t >> 31));\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main(){\n \nvar seats = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\nvar groupMembers = [2,5,2,2,2];\nvar eatTimes = [19,39,25,36,22,42];\n \nvar headGroup = -1;\nvar pastMinutes = 0;\nvar waitTime = [];\n \nwhile(waitTime.length < 100){\n  // たべおわる\n  var slen = seats.length;\n  for(; slen--;){\n    seats[slen] = mx(seats[slen] - 1, 0);\n  }\n \n  // 来店\n  if(headGroup == -1 && pastMinutes % 5 == 0){\n    headGroup = pastMinutes / 5;\n  }\n \n  // ちゃくせき\n  while(headGroup != -1){\n    var needsSequencialSeats = groupMembers[headGroup % 5];\n    var sequencialSeats = 0;\n    var startIndex = -1;\n    for(var i = 0, sl = seats.length; i < sl; i++){\n      sequencialSeats = seats[i] == 0 ? sequencialSeats + 1 : 0;\n \n      if(sequencialSeats == needsSequencialSeats){\n        startIndex = i - (needsSequencialSeats - 1);\n        break;\n      }\n    }\n \n    if(startIndex != -1){\n      // すわれたみたい\n      waitTime[headGroup] = pastMinutes - (headGroup * 5);\n      for(var i = startIndex, total = (needsSequencialSeats + startIndex); i < total; i++){\n        seats[i] = eatTimes[headGroup % 6];\n      }\n       \n      headGroup = (((headGroup + 1) * 5) <= pastMinutes) ? headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n \n  }\n \n  pastMinutes++;\n \n}\n \nfor(var i = 0, ilen = (input.length - 1); i < ilen; i++){\n  console.log(waitTime[parseInt(input[i], 10)]);\n}\n \n}\n\nfunction mx(a, b){\n var t = (a-b);\n return a - (t & (t >> 31));\n}\n \nvar\ninput = '';\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "Ruby",
    "code": "def eating_time(i)\n  17*(i%2) + 3*(i%3) + 19\nend\n\ndef have_seats(guest_n, seats)\n  first = seats.index(nil)\n  loop do\n    return false if first.nil? || seats.size - 1 < first\n    enough_seats = seats[first, guest_n]\n    if enough_seats.all?(&:nil?) && enough_seats.size == guest_n\n      return first\n    end\n    first += 2\n  end\nend\n\nreadlines.each do |l|\n  n = l.to_i\n  seats = Array.new(17,nil)\n  line = []\n  etimes = []\n  wtimes = []\n  time = 0 \n  i = 0\n\n  while true\n    unless etimes.index(time).nil?\n      leaving_guests = etimes.map.with_index do |t, i|\n        if t == time\n          i\n        else\n          nil\n        end\n      end\n      leaving_guests.compact!\n      seats.map! do |seat|\n        if leaving_guests.include?(seat)\n          nil\n        else\n          seat\n        end\n      end\n    end\n        \n    if line.any?\n      0.upto(line.size-1) { |j| line[j][1] += 1 }\n    end\n    \n    if (time%5).zero?\n      line << [i, 0]\n      i += 1\n    end\n    \n    before_s = -1\n    while line.any?  \n      s = line.first.first\n      break if before_s == s\n      guest_n = (s % 5 == 1 ? 5 : 2)\n      if (first = have_seats(guest_n, seats))\n        seats[first, guest_n] = [s]*guest_n\n        etimes[s] = eating_time(s) + time\n        wtimes[s] = line.first.last\n        line.shift\n      end\n      before_s = s\n    end\n\n    if seats.include?(n)\n      puts wtimes[n]\n      break\n    end\n\n    time += 1\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "tt = [0]*17\nq = []\nres = [-1]*100\n(0..600).each do |i|\n  p tt\n  break if q.empty? && res.all?{ |v| v != -1 }\n  tt.map!{|j| j - 1 }\n  unless q.empty?\n    idx = 0\n    while idx < 17\n      break if q.empty?\n      x = q[0][1] \n      cnt = 0\n      tt[idx..-1].each do |t|\n        break if cnt == x\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n      if cnt == x \n        y = q.shift\n        tt.fill(y[2],idx-x,x)\n        res[y[0]] = i - y[3]\n      end\n    end\n  end\n  if i % 5 == 0 && i < 500\n    m = ((i/5)%5 == 1 ? 5 : 2)\n    eat = 17*((i/5)%2)+3*((i/5)%3)+19\n    if q.empty?\n      cnt = idx = 0\n      tt.each do |t|\n        break if cnt == m\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n\n      if cnt == m\n        tt.fill(eat, idx-m, m)\n        res[i/5] = 0\n      else\n        q << [i/5,m,eat,i]\n      end\n    else q << [i/5,m,eat,i]\n    end\n  end\nend\np res\nwhile gets\n  p res[$_.to_i]\nend"
  },
  {
    "language": "Ruby",
    "code": "s=[t=l=0]*17\nc=(0..99).map{|i|[i*5,i%5==1?5:2,17*(i%2)+3*(i%3)+19]}\n(a,n,b=c[l];(a<=t&&(z=[*s.each_cons(n)].index{|j|j.all?{|i|i<=t}}))?(s[z,n]=[t+b]*n;c[l]=t-a;l+=1):t+=1)while c[l]\n$<.map{|i|p c[i.to_i]}"
  },
  {
    "language": "Ruby",
    "code": "tt = [0]*17\nq = []\nres = [-1]*100\n(0..600).each do |i|\n  break if q.empty? && res.all?{ |v| v != -1 }\n  tt.map!{|j| j - 1 }\n  unless q.empty?\n    idx = 0\n    while idx < 17\n      break if q.empty?\n      x = q[0][1] \n      cnt = 0\n      tt[idx..-1].each do |t|\n        break if cnt == x\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n      if cnt == x \n        y = q.shift\n        tt.fill(y[2],idx-x,x)\n        res[y[0]] = i - y[3]\n      end\n    end\n  end\n  if i % 5 == 0 && i < 500\n    m = ((i/5)%5 == 1 ? 5 : 2)\n    eat = 17*((i/5)%2)+3*((i/5)%3)+19\n    if q.empty?\n      cnt = idx = 0\n      tt.each do |t|\n        break if cnt == m\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n\n      if cnt == m\n        tt.fill(eat, idx-m, m)\n        res[i/5] = 0\n      else\n        q << [i/5,m,eat,i]\n      end\n    else q << [i/5,m,eat,i]\n    end\n  end\nend\nwhile gets\n  p res[$_.to_i]\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nW=17\nZ=100\nn=0\nq=[]\nr=[]\nsheat=Array.new(W)\nt=0\nloop{\n\tif t%5==0\n\t\tq << t/5\n\tend\n\tW.times{|i|\n\t\tif sheat[i]\n\t\t\tsheat[i]-=1\n\t\t\tsheat[i]=nil if sheat[i]==0\n\t\tend\n\t}\n\twhile q.size>0\n\t\tl=(q[0]%5==1 ? 5 : 2)\n\t\t_p=(0..W-l).find{|i|sheat[i,l]==[nil]*l}\n\t\tbreak if !_p\n\t\t_p.step(_p+l-1){|i|\n\t\t\tsheat[i]=17*(q[0]%2)+3*(q[0]%3)+19\n\t\t}\n\t\tr<<t-q[0]*5\n\t\tq.shift\n\tend\n\tbreak if r.length>Z\n\tt+=1\n}\nwhile gets\np r[$_.to_i]end"
  },
  {
    "language": "Ruby",
    "code": "tt = [0]*17\nq = []\nres = [-1]*100\n(0..600).each do |i|\n  p tt\n  break if q.empty? && res.all?{ |v| v != -1 }\n  tt.map!{|j| j - 1 }\n  unless q.empty?\n    idx = 0\n    while idx < 17\n      break if q.empty?\n      x = q[0][1] \n      cnt = 0\n      tt[idx..-1].each do |t|\n        break if cnt == x\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n      if cnt == x \n        y = q.shift\n        tt.fill(y[2],idx-x,x)\n        res[y[0]] = i - y[3]\n      end\n    end\n  end\n  if i % 5 == 0 && i < 500\n    m = ((i/5)%5 == 1 ? 5 : 2)\n    eat = 17*((i/5)%2)+3*((i/5)%3)+19\n    if q.empty?\n      cnt = idx = 0\n      tt.each do |t|\n        break if cnt == m\n        if t <= 0 then cnt += 1\n        elsif t > 0 then cnt = 0\n        end\n        idx += 1\n      end\n\n      if cnt == m\n        tt.fill(eat, idx-m, m)\n        res[i/5] = 0\n      else\n        q << [i/5,m,eat,i]\n      end\n    else q << [i/5,m,eat,i]\n    end\n  end\nend\nwhile gets\n  p res[$_.to_i]\nend"
  },
  {
    "language": "Ruby",
    "code": "class Group\n  attr_accessor :arrival, :number, :sojourn\n  attr_accessor :in, :out\n  def initialize(arrival, number, sojourn)\n    @arrival, @number, @sojourn = arrival, number, sojourn\n  end\n  def sit(time)\n    @in = time\n    @out = @in + sojourn\n  end\n  def show\n    p [@arrival, @number, @sojourn]\n  end\nend\n\ngroup = 100.times.map{|i| Group.new(5 * i, (i % 5 == 1 ? 5 : 2), (17 * (i % 2) + 3 * (i % 3) + 19))}\nseat = Array.new(17)\n\ntime = 0\nhead = 0\nuntil head == 100\n  # out\n  seat.map! do |s|\n    if s\n      group[s].out <= time ? nil : s\n    else\n      nil\n    end\n  end\n\n  # in\n  until head == 100 || group[head].arrival > time\n    ok = false\n    n = group[head].number\n    (17 - n + 1).times do |i|\n      next unless seat[i, n].all?(&:nil?)\n      group[head].sit(time)\n      seat[i, n] = n.times.map{head}\n      head += 1\n      ok = true\n      break\n    end\n    break unless ok\n  end\n\n  # update\n  time += 1\nend\n\nwhile gets\n  n = $_.to_i\n  p (group[n].in - group[n].arrival)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Group\n  attr_accessor :arrival, :number, :sojourn\n  attr_accessor :in, :out\n  def initialize(arrival, number, sojourn)\n    @arrival, @number, @sojourn = arrival, number, sojourn\n  end\n  def sit(time)\n    @in = time\n    @out = @in + sojourn\n  end\n  def show\n    p [@arrival, @number, @sojourn]\n  end\nend\n\ngroup = 100.times.map{|i| Group.new(5 * i, (i % 5 == 1 ? 5 : 2), (17 * (i % 2) + 3 * (i % 3) + 19))}\nseat = Array.new(17)\n\ntime = 0\nhead = 0\nuntil time == 3047 || head == 100\n  # out\n  seat.map! do |s|\n    if s\n      group[s].out <= time ? nil : s\n    else\n      nil\n    end\n  end\n\n  # in\n  loop do\n    break if head == 100\n    break if group[head].arrival > time\n\n    ok = false\n    n = group[head].number\n    (17 - n).times do |i|\n      next unless seat[i, n].all?(&:nil?)\n      group[head].sit(time)\n      seat[i, n] = n.times.map{head}\n      head += 1\n      ok = true\n      break\n    end\n    break unless ok\n  end\n\n  # update\n  time += 1\nend\n\nwhile gets\n  n = $_.to_i\n  p (group[n].in - group[n].arrival)\nend"
  },
  {
    "language": "Ruby",
    "code": "def eating_time(i)\n  17*(i%2) + 3*(i%3) + 19\nend\n\ndef have_seats(guest_n, seats)\n  _seats = seats\n  loop do\n    first = _seats.index(nil)\n    return false if first.nil?\n    enough_seats = _seats[first, guest_n]\n    if enough_seats.all?(&:nil?) && enough_seats.size == guest_n\n      return first\n    end\n    _seats = [first+1..-1]\n  end\nend\n\nreadlines.each do |l|\n  n = l.to_i\n  seats = Array.new(17,nil)\n  line = []\n  etimes = []\n  wtimes = []\n  time = 0 \n  i = 0\n\n  while true\n    if !(leaving_guest = etimes.index(time)).nil?\n      seats.map! do |seat|\n        if seat == leaving_guest\n          nil\n        else\n          seat\n        end\n      end\n    end\n    \n    if line.any?\n      0.upto(line.size-1) { |j| line[j][1] += 1 }\n    end\n    \n    if (time%5).zero?\n      line << [i, 0]\n      i += 1\n    end\n    \n    before_s = -1\n    while line.any?  \n      s = line.first.first\n      break if before_s == s\n      guest_n = (s % 5 == 1 ? 5 : 2)\n      if (first = have_seats(guest_n, seats))\n        seats[first, guest_n] = [s]*guest_n\n        etimes[s] = eating_time(s) + time\n        wtimes[s] = line.first.last\n        line.shift\n      end\n      before_s = s\n    end\n\n    if seats.include?(n)\n      puts wtimes[n]\n      break\n    end\n\n    time += 1\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "table = [0, 0, 0, 0, 0, 0, 14, 9, 4, 0, 0, 8, 3, 2, 0, 0, 15, 10, 15, 10,\n         6, 12, 7, 9, 11, 6, 23, 18, 13, 8, 3, 23, 18, 13, 8, 3, 34, 29, 24,\n         22, 17, 28, 23, 24, 19, 27, 34, 29, 35, 30, 28, 31, 28, 23, 24, 28,\n         42, 37, 32, 27, 22, 42, 37, 32, 27, 22, 53, 48, 43, 41, 36, 47, 42,\n         43, 38, 46, 64, 59, 54, 49, 44, 61, 56, 51, 46, 44, 72, 67, 62, 57,\n         52, 72, 67, 62, 57, 52, 83, 78, 73, 71]\nputs $<.readlines.map(&:to_i).map {|i| table[i]}\n"
  },
  {
    "language": "Ruby",
    "code": "\nNUM_C = 17;\n\n### subroutines\n\ndef n_grp(i)\n  (i % 5 == 1) ? 5 : 2;\nend\n\ndef t_grp(i)\n  17 * (i % 2) + 3 * (i % 3) + 19\nend\n\ndef find_seats(seats, n)\n  st = 0\n  while st < NUM_C\n    while st < NUM_C && ! seats[st].nil?\n      st += 1\n    end\n\n    k = 0;\n    while st + k < NUM_C && seats[st + k].nil?\n      k += 1\n      return st if k >= n\n    end\n    st += k\n  end\n  nil\nend\n\n### main\n\nseats = (0...NUM_C).map{nil}\n\nt = 0\nqueue = []\nwaits = []\n\nwhile (t < 500 || ! queue.empty?)\n  # check if customers finish eating\n  for i in (0...NUM_C)\n    if ! seats[i].nil? && seats[i][1] == t\n      seats[i] = nil\n    end\n  end\n\n  # check if new group arrives\n  if t < 500 && t % 5 == 0\n    i = t / 5\n    queue.push [i, n_grp(i), t_grp(i)]\n  end\n\n  # check if seats are available\n  while ! queue.empty?\n    gid, gn, gtime = queue[0]\n    sid = find_seats(seats, gn)\n    break if sid.nil?\n\n    ginfo = [gid, t + gtime]\n    for i in (0...gn)\n      seats[sid + i] = ginfo\n    end\n\n    waits[gid] = t - 5 * gid\n\n    queue.shift\n  end\n\n  # print current status\n  #p [t, [seats]]\n\n  # next time\n  t += 1\nend\n\n#p waits\n\nwhile (line = gets)\n  gid = line.strip.to_i\n\n  puts waits[gid]\nend"
  },
  {
    "language": "Ruby",
    "code": "def search(arr, n, idx)\n  (idx..17-n).each do |t|\n    return t if arr[t, n].all?{|v| v <= 0}\n  end\n  nil\nend\n\ntt = [0]*17\nq = []\nres = [-1]*100\n(0..1000).each do |i|\n  break if q.empty? && res.all?{ |v| v != -1 }\n  tt.map!{|j| j - 1 }\n  until q.empty?\n    idx = 0\n    if t = search(tt, x = q[0][1], idx)\n      id, n, c, s = q.shift\n      tt.fill(c, t, x)\n      res[id] = i - s\n      idx = t + x\n    else break\n    end\n  end\n  if i % 5 == 0 && i < 500\n    m = ((i/5)%5 == 1 ? 5 : 2)\n    eat = 17 * ((i/5)%2) + 3 * ((i/5)%3) + 19\n    if q.empty?\n      if t = search(tt, m, 0)\n        tt.fill(eat, t, m)\n        res[i/5] = 0\n      else\n        q << [i/5, m, eat, i]\n      end\n    else q << [i/5, m, eat, i]\n    end\n  end\nend\nwhile gets\n  p res[$_.to_i]\nend"
  },
  {
    "language": "Ruby",
    "code": "while gets\np [0,0,0,0,0,0,14,9,4,0,0,8,3,2,0,0,15,10,15,10,6,12,7,9,11,6,23,18,13,8,3,23,18,13,8,3,34,29,24,22,17,28,23,24,19,27,34,29,35,30,28,31,28,23,24,28,42,37,32,27,22,42,37,32,27,22,53,48,43,41,36,47,42,43,38,46,64,59,54,49,44,61,56,51,46,44,72,67,62,57,52,72,67,62,57,52,83,78,73,71][$_.to_i]end"
  },
  {
    "language": "Ruby",
    "code": "def calc()\n  a, s, q = [0] * 100, [0] * 17, []\n  loop.with_index do |_, t|\n    s.each.with_index do |e, i|\n      s[i] -= 1 if e > 0\n    end\n    q.push(t / 5) if t % 5 == 0\n    while q[0]\n      f = false\n      g = q[0]\n      n = g % 5 == 1 ? 5 : 2\n      s.each_cons(n).with_index do |c, i|\n        if c.all? { |e| e == 0 }\n          n.times do |j|\n            s[i + j] = 17 * (g % 2) + 3 * (g % 3) + 19\n          end\n          a[g] = t - g * 5\n          return a if g == 99\n          q.shift\n          f = true\n          break\n        end\n      end\n      break unless f\n    end\n  end\nend\n1.times do\n  a = calc\n  loop do\n    n = gets\n    break unless n\n    puts a[n.to_i]\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def eating_time(i)\n  17*(i%2) + 3*(i%3) + 19\nend\n\ndef have_seats(guest_n, seats)\n  first = seats.index(nil)\n  loop do\n    return false if first.nil? || seats.size - 1 < first\n    enough_seats = seats[first, guest_n]\n    if enough_seats.all?(&:nil?) && enough_seats.size == guest_n\n      return first\n    end\n    first += 2\n  end\nend\n\nreadlines.each do |l|\n  n = l.to_i\n  seats = Array.new(17,nil)\n  line = []\n  etimes = {}\n  wtimes = {}\n  time = 0 \n  i = 0\n\n  while true\n    if !(leaving_guest = etimes.key(time)).nil?\n      seats.map! do |seat|\n        if seat == leaving_guest\n          nil\n        else\n          seat\n        end\n      end\n    end\n    \n    if line.any?\n      0.upto(line.size-1) { |j| line[j][1] += 1 }\n    end\n    \n    if (time%5).zero?\n      line << [i, 0]\n      i += 1\n    end\n    \n    before_s = -1\n    while line.any?  \n      s = line.first.first\n      break if before_s == s\n      guest_n = (s % 5 == 1 ? 5 : 2)\n      if (first = have_seats(guest_n, seats))\n        seats[first, guest_n] = [s]*guest_n\n        etimes[s] = eating_time(s) + time\n        wtimes[s] = line.first.last\n        line.shift\n      end\n      before_s = s\n    end\n\n    if seats.include?(n)\n      puts wtimes[n]\n      break\n    end\n\n    time += 1\n  end\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nconst INF = 0x7fffffff\nfunc main() {\n\tS := 17\n\tseat := make([][]int, 27)\n\tfor i :=range seat {\n\t\tseat[i] = make([]int, 27)\n\t}\n\tans := make([]int, 105)\n\tid := 0\n\tQ := make([][]int, 0)\n\tfor i := 0; i < S; i++ {\n\t\tseat[i][0] = -1\n\t}\n\tt := -1\n\tfor ans[99] == 0 {\n\t\tt++\n\t\tif  t%5 == 0 && id <= 99 {\n\t\t\tif id % 5 == 1 {\n\t\t\t\tn := 5\n\t\t\t\ttmp := []int{id, n, t}\n\t\t\t\tQ = append(Q, tmp)\n\t\t\t\tid++\n\t\t\t} else {\n\t\t\t\tn := 2\n\t\t\t\ttmp := []int{id, n, t}\n\t\t\t\tQ = append(Q, tmp)\n\t\t\t\tid++\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tif seat[i][1] == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseat[i][1]--\n\t\t\tif seat[i][1] == 0 {\n\t\t\t\tseat[i][0] = -1\n\t\t\t}\n\t\t}\n\t\tf := len(Q)\n\t\tfor f > 0 {\n\t\t\ti, n := Q[0][0], Q[0][1]\n\t\t\tf = 0\n\t\t\tfor j := 0; j < S; j++ {\n\t\t\t\tg := 0\n\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\tif seat[j+k][0] >= 0 {\n\t\t\t\t\t\tg = 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif g != 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tans[i] = t-Q[0][2]\n\t\t\t\tQ = Q[1:]\n\t\t\t\tf = len(Q)\n\t\t\t\tfor k := 0; k < n; k++ {\n\t\t\t\t\tseat[j+k][0] = i\n\t\t\t\t\tseat[j+k][1] = 17*(i&1) + 3*(i%3) + 19\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tfor scanner.Scan() {\n\t\tn, _ := strconv.Atoi(scanner.Text())\n\t\tfmt.Println(ans[n])\n\t}\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\ntype chair struct {\n\tgroup_id, rest_time int\n}\n\ntype info struct {\n\tgroup_id, num, wait_sum, before_go int\n\tfixed                              bool\n}\n\nfunc main() {\n\tans := make([]int, 100)\n\tchair := make([]chair, 17)\n\tfor i := 0; i < 17; i++ {\n\t\tchair[i].group_id = -1\n\t}\n\tinfo := make([]info, 100)\n\tfor i := 0; i <= 99; i++ {\n\t\tinfo[i].group_id = i\n\t\tinfo[i].before_go = 5 * i\n\t\tinfo[i].wait_sum = 0\n\t\tif i%5 == 1 {\n\t\t\tinfo[i].num = 5\n\t\t} else {\n\t\t\tinfo[i].num = 2\n\t\t}\n\t\tinfo[i].fixed = false\n\t}\n\tcount := 0\n\tFLG := 0\n\ttmp_num := 0\n\tisOK := false\n\twaitFLG := false\n\tfor {\n\t\tfor i := 0; i < 17; i++ {\n\t\t\tif chair[i].group_id != -1 {\n\t\t\t\tchair[i].rest_time--\n\t\t\t\tif chair[i].rest_time <= 0 {\n\t\t\t\t\tchair[i].group_id = -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twaitFLG = false\n\t\tcount = 0\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tif info[i].fixed {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif waitFLG == false && info[i].before_go == 0 {\n\t\t\t\tFLG = -1\n\t\t\t\ttmp_num = info[i].num\n\t\t\t\tfor k := 0; k <= 17-tmp_num; k++ {\n\t\t\t\t\tisOK = true\n\t\t\t\t\tfor p := 0; p < tmp_num; p++ {\n\t\t\t\t\t\tif chair[k+p].group_id != -1 {\n\t\t\t\t\t\t\tisOK = false\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif isOK {\n\t\t\t\t\t\tFLG = k\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif FLG != -1 {\n\t\t\t\t\tfor k := FLG; k < FLG+tmp_num; k++ {\n\t\t\t\t\t\tchair[k].group_id = info[i].group_id\n\t\t\t\t\t\tchair[k].rest_time = 17*(i%2) + 3*(i%3) + 19\n\t\t\t\t\t\tinfo[i].fixed = true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twaitFLG = true\n\t\t\t\t\tinfo[i].wait_sum++\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif info[i].before_go == 0 {\n\t\t\t\t\tinfo[i].wait_sum++\n\t\t\t\t} else {\n\t\t\t\t\tinfo[i].before_go--\n\t\t\t\t}\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tif count == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor i := 0; i <= 99; i++ {\n\t\tans[i] = info[i].wait_sum\n\t}\n\tfor scanner.Scan() {\n\t\tn, _ := strconv.Atoi(scanner.Text())\n\t\tfmt.Println(ans[n])\n\t}\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n  \n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n  \n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n    \n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < ($needsSequencialSeats + $startIndex); $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = ((($headGroup + 1) * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n    \n  }\n  \n  $pastMinutes++;\n  \n}\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit == true && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n  \n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n  \n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n    \n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < ($needsSequencialSeats + $startIndex); $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n    \n  }\n  \n  $pastMinutes++;\n  \n}\n\nwhile( TRUE ) {\n  $line = fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n  \n  echo $waitTime[$a];\n  \n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sqeuencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats + 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $waitTime[$headGroup] = $pastMinutes - $headGroup * 5;\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = $headGroup * 5 < $pastMinutes : $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n    \n  }\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$waitTime = array(0,\n0,\n0,\n0,\n0,\n0,\n14,\n9,\n4,\n0,\n0,\n8,\n3,\n2,\n0,\n0,\n15,\n10,\n15,\n10,\n6,\n12,\n7,\n9,\n11,\n6,\n23,\n18,\n13,\n8,\n3,\n23,\n18,\n13,\n8,\n3,\n34,\n29,\n24,\n22,\n17,\n28,\n23,\n24,\n19,\n27,\n34,\n29,\n35,\n30,\n28,\n31,\n28,\n23,\n24,\n28,\n42,\n37,\n32,\n27,\n22,\n42,\n37,\n32,\n27,\n22,\n53,\n48,\n43,\n41,\n36,\n47,\n42,\n43,\n38,\n46,\n64,\n59,\n54,\n49,\n44,\n61,\n56,\n51,\n46,\n44,\n72,\n67,\n62,\n57,\n52,\n72,\n67,\n62,\n57,\n52,\n83,\n78,\n73,\n71);\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}\nreturn(0);\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nfor($c = 0; $c < 100; ){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n  \n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n  \n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n    \n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < ($needsSequencialSeats + $startIndex); $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = ((($headGroup + 1) * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n      $c++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n    \n  }\n  \n  $pastMinutes++;\n  \n}\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$result = array(0,\n0,\n0,\n0,\n0,\n0,\n14,\n9,\n4,\n0,\n0,\n8,\n3,\n2,\n0,\n0,\n15,\n10,\n15,\n10,\n6,\n12,\n7,\n9,\n11,\n6,\n23,\n18,\n13,\n8,\n3,\n23,\n18,\n13,\n8,\n3,\n34,\n29,\n24,\n22,\n17,\n28,\n23,\n24,\n19,\n27,\n34,\n29,\n35,\n30,\n28,\n31,\n28,\n23,\n24,\n28,\n42,\n37,\n32,\n27,\n22,\n42,\n37,\n32,\n27,\n22,\n53,\n48,\n43,\n41,\n36,\n47,\n42,\n43,\n38,\n46,\n64,\n59,\n54,\n49,\n44,\n61,\n56,\n51,\n46,\n44,\n72,\n67,\n62,\n57,\n52,\n72,\n67,\n62,\n57,\n52,\n83,\n78,\n73,\n71\n);\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $result[$input]);\n}\nreturn(0);\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sqeuencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats + 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $waitTime[$headGroup] = $pastMinutes - $headGroup * 5;\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = $headGroup * 5 < $pastMinutes : $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nfor($c = 0; $c < 100; ){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n  \n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n  \n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n    \n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < ($needsSequencialSeats + $startIndex); $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = ((($headGroup + 1) * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n      $c++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n    \n  }\n  \n  $pastMinutes++;\n  \n}\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -100;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if($startIndex != -100){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  $line = fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats + 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $sitGroupCount++;\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sqeuencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats + 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $waitTime[$headGroup] = $pastMinutes - $headGroup * 5;\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = $headGroup * 5 < $pastMinutes : $headGroup + 1 : -1;\n        \n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n    \n  }\n \n}  \n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $sitGroupCount++;\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nfor($c = 0; $c < 100; ){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n  \n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n  \n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n    \n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < ($needsSequencialSeats + $startIndex); $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = ((($headGroup + 1) * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n      $c++;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n    \n  }\n  \n  $pastMinutes++;\n  \n}\n\nwhile($input = fscanf(STDIN, \"%d\")){\n  fprintf(STDOUT, \"%d\\n\", $waitTime[$input]);\n}\nreturn(0);\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$sitGroupCount = 0;\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile($sitGroupCount <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  $sit = true;\n  while($sit && $headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats + 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $sit = true;\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      $sit = false;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && $pastMinutes % 5 == 0){\n    $headGroup = $pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  $line = fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "PHP",
    "code": "<?php\n\n$seats = array(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n$groupMembers = array(2,5,2,2,2);\n$eatTimes = array(19,39,25,36,22,42);\n\n$headGroup = -1;\n$pastMinutes = 0;\n$waitTime = array();\n\nwhile(count($waitTime) <= 100){\n  // たべおわる\n  for($i = 0; $i < count(seats); $i++){\n    $seats[$i] = $seats[$i] == 0 ? 0 : $seats[$i] - 1;\n  }\n\n  // 来店\n  if($headGroup == -1 && pastMinutes % 5 == 0){\n    $headGroup = pastMinutes / 5;\n  }\n\n  // ちゃくせき\n  while($headGroup != -1){\n    $needsSequencialSeats = $groupMembers[$headGroup % 5];\n    $sequencialSeats = 0;\n    $startIndex = -1;\n    for($i = 0; $i < count(seats); $i++){\n      $sequencialSeats = $seats[$i] == 0 ? $sequencialSeats + 1 : 0;\n\n      if($sequencialSeats == $needsSequencialSeats){\n        $startIndex = $i - ($needsSequencialSeats - 1);\n        break;\n      }\n    }\n\n    if($startIndex != -1){\n      // すわれたみたい\n      $waitTime[$headGroup] = $pastMinutes - ($headGroup * 5);\n      for($i = $startIndex; $i < $needsSequencialSeats; $i++){\n        $seats[$i] = $eatTimes[$headGroup % 6];\n      }\n      \n      $headGroup = (($headGroup * 5) < $pastMinutes) ? $headGroup + 1 : -1;\n    }else{\n      // すわれなかったみたい\n      break;\n    }\n\n  }\n\n  $pastMinutes++;\n \n}\n\nwhile( TRUE ) {\n  $line = fscanf(STDIN, \"%d\", $a);\n  if( feof(STDIN) )\n    break;\n\n  echo $waitTime[$a];\n\n}\n\n?>"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nvoid main(){\n    auto tSit = new long[](100);\n    tSit[] = -1;\n    auto sheets = new int[](17);\n    sheets[] = -1;\n    int findSheet(int n) {\niLoop:foreach(i; iota(17)) {\n            foreach(j; iota(i, 17)) {\n                if(sheets[j] != -1) {\n                    continue iLoop;\n                }\n                if(j-i+1 == n) {\n                    return i;\n                }\n            }\n        }\n      return -1;\n    }\n    DList!int q;\n    int t;\n    while(tSit.back == -1) {\n        foreach(ref i; sheets) {\n            if(i >= 0 && t - tSit[i] == 17*(i%2) + 3*(i%3) + 19) {\n                i = -1;\n            }\n        }\n        if(t%5 == 0 && t/5 < 100) {\n            q.insertBack(t/5);\n        }\n        while(!q.empty()) {\n            auto i = q.front;\n            auto n = (i%5 == 1 ? 5: 2);\n            auto s = findSheet(n);\n            if(s >= 0) {\n                tSit[i] = t;\n                foreach(j; iota(s, s+n)) {\n                    sheets[j] = i;\n                }\n                q.removeFront();\n            } else {\n                break;\n            }\n        }\n        ++t;\n    }\n    while(!stdin.eof()) {\n        auto n = readInt();\n        writeln(tSit[n] - 5*n);\n    }\n}"
  },
  {
    "language": "D",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Group{\n\tint indx, num;\n\tGroup(){}\n\tGroup(const int &_indx, const int &_num){\n\t\tindx = _indx; num = _num;\n\t}\n};\n\nint main(){\n\tint table[17], ans[100];\n\tqueue<Group> q;\n\tfor(int i = 0;; i++){\n\t\tif(i%5 == 0 && i/5 < 100){\n\t\t\tif( (i/5)%5 == 1 ) q.push( Group(i/5, 5) );\n\t\t\telse q.push( Group(i/5, 2) );\n\t\t}\n\t\tif( i/5 >= 100 && q.empty() ) break;\n\t\t\n\t\tGroup q_c = q.front();\n\t\tint space_cnt = 0;\n\t\tfor(int i = 16; i >= 0; i--){\n\t\t\tif(table[i] > 0) table[i]--;\n\t\t\tif(table[i] == 0) space_cnt++;\n\t\t\telse space_cnt = 0;\n\t\t\t\n\t\t\tif(space_cnt == q_c.num){\n\t\t\t\tq.pop();\n\t\t\t\tfor(int j = 0; j < space_cnt; j++){\n\t\t\t\t\ttable[i+j] = \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array;\n\nint[17] seat;\nint[] q;\n\nvoid main(){\n\tbool f;\n\tint n, t, m, a, id;\n\twhile (readf(\"%d\\n\", &n)) {\n\t\tseat[] = -1;\n\t\tq = [];\n\t\tt = 0;\n\t\twhile (1) {\n\t\t\tseat[] -= 1;\n\t\t\tif (t%5 == 0) q ~= t/5;\n\t\t\tf = true;\n\t\t\twhile (!q.empty && f) {\n\t\t\t\tf = false;\n\t\t\t\tid = q.front;\n\t\t\t\tm = (id%5 == 1) ? 5 : 2;\n\t\t\t\ta = available(m);\n\t\t\t\tif (a != -1) {\n\t\t\t\t\tforeach (j; 0..m) seat[a+j] = 17*(id%2)+3*(id%3)+19;\n\t\t\t\t\tq.popFront();\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t/5 >= n && (q.empty || q.front > n)) break;\n\t\t\tt++;\n\t\t}\n\t\twriteln(t - n*5);\n\t}\n}\n\nint available(int m){\n\tint s, e;\n\ts = e = 0;\n\twhile (e < 17) {\n\t\tif (seat[s] <= 0 && seat[e] <= 0) e++;\n\t\telse if (seat[s] <= 0 && seat[e] > 0) s = e;\n\t\telse {\n\t\t\ts++;\n\t\t\te = s;\n\t\t}\n\n\t\tif (e - s == m) return s;\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nvoid main(){\n    auto tSit = new long[](100);\n    tSit[] = -1;\n    auto sheets = new int[](17);\n    sheets[] = -1;\n    int findSheet(int n) {\niLoop:foreach(i; iota(17)) {\n            foreach(j; iota(i, 17)) {\n                if(sheets[j] != -1) {\n                    continue iLoop;\n                }\n                if(j-i+1 == n) {\n                    return i;\n                }\n            }\n        }\n      return -1;\n    }\n    DList!int q;\n    int t;\n    while(tSit.back == -1) {\n        foreach(ref i; sheets) {\n            if(i >= 0 && t - tSit[i] == 17*(i%2) + 3*(i%3) + 19) {\n                i = -1;\n            }\n        }\n        if(t%5 == 0 && t/5 < 100) {\n            q.insertBack(t/5);\n        }\n        while(!q.empty()) {\n            auto i = q.front;\n            auto n = (i%5 == 1 ? 5: 2);\n            auto s = findSheet(n);\n            if(s >= 0) {\n                tSit[i] = t;\n                foreach(j; iota(s, s+n)) {\n                    sheets[j] = i;\n                }\n                q.removeFront();\n            } else {\n                break;\n            }\n        }\n        ++t;\n    }\n    while(!stdin.eof()) {\n        auto l = readln().chomp();\n        if(l == \"\") {\n            break;\n        }\n        auto n = l.to!int;\n        writeln(tSit[n] - 5*n);\n    }\n}"
  },
  {
    "language": "D",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Group{\n\tint indx, num;\n\tGroup(){}\n\tGroup(const int &_indx, const int &_num){\n\t\tindx = _indx; num = _num;\n\t}\n};\n\nint main(){\n\tint table[17], ans[100];\n\tqueue<Group> q;\n\tfor(int i = 0;; i++){\n\t\tif(i%5 == 0 && i/5 < 100){\n\t\t\tif( (i/5)%5 == 1 ) q.push( Group(i/5, 5) );\n\t\t\telse q.push( Group(i/5, 2) );\n\t\t}\n\t\tif( i/5 >= 100 && q.empty() ) break;\n\t\t\n\t\tGroup q_c = q.front();\n\t\tint space_cnt = 0;\n\t\tfor(int i = 16; i >= 0; i--){\n\t\t\tif(table[i] > 0) table[i]--;\n\t\t\tif(table[i] == 0) space_cnt++;\n\t\t\telse space_cnt = 0;\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nque = deque()\nt = 0\nseat = [0] * 17\nscore = []\nwhile que or t < 500:\n  if t % 5 == 0 and t < 500:\n    i = t // 5\n    que.append([t, 5 if i % 5 == 1 else 2, 17 * (i % 2) + 3 * (i % 3) + 19])\n  \n  for i in range(17):\n    if seat[i]:\n      seat[i] -= 1\n\n  while que:\n    need_space = que[0][1]\n    for i in range(18 - need_space):\n      if not any(seat[i:i+need_space]):\n        for j in range(i, i + need_space):\n          seat[j] = que[0][2]\n        score.append(t - que[0][0])\n        que.popleft()\n        break\n    else:\n      break\n  t += 1\n\nwhile True:\n  try:\n    print(score[int(input())])\n  except EOFError:\n    break\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    # ??????????????¶???????????????????????????\n    # '_'?????????????????????'o'???????????§??£??????????????????\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        # num????????£?¶?????????§???????????????????????°?????§???????????????????????????????????????????????????????????????????????°-1????????????\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return -1\n\n    def release(self, i, num):\n        # ??§??£???????????????????????????????????????????????????????????????????????????????????´??§???????????????\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100   #  ?????°??????????????¨???????????????\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)    #  ???????????¶????????????????????????????????????\n    LEAVE = 0                   #  ??\\???????£???????????????????????????????????????\\\n    COME = 1                    #  LEAVE??¨COME??????????????????????????´????????????????????\\?????§LEAVE????????????????????????????????????????????´???????????????\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??§??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num)) #  ????????????????????????????????????????¨?????????????????????´????????????????????????????????°????????????????????\\????????°\n\n    # ???????????\\??????????????????????????????????????????????????????\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num)) #  ??\\????????´???????????¢????????£?????????????????§??????????????§??????????????§?????????\n        else:\n            seat.release(start_seat, num) #  ?£???????????????????????????????\n        while Q:                #  ?????£???????????°??????????????§?????????????????§????????????\n            res = seat.get(Q[0][2]) #  ?????????????????????????????§????????????\n            if res != -1:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive #  ????????°?????????????????\\?????????????????§???????????§????????????????¨????\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19 #  ?£??????????\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num)) #  ?????????????????????????????¨???????????????????????????\n            else:\n                break           #  ??????????????????????????°??????????????§???????????£????????§????¬??????°?????????????¢??????????\n    return waiting_time         #  ??¨??°??????????????????????????????\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "#Fukushimaken: \nfrom heapq import heappop, heappush\nOUT, IN = 0, 1\ndef P(i):\n    return 31 if i % 5 == 1 else 3\n\ndef M(i):\n    return 17 * (i % 2) + 3 * (i % 3) + 19\n\ndef check(c, n):\n    for i in xrange(16):\n        if (c >> i) & n == 0:\n            return i\n    return None\n\nans = [-1] * 100 + [0]\neq = map(lambda i: (i * 5, i, IN, None), xrange(100))\nc = 1 << 17\nwhile len(eq) != 0:    \n    m, n, et, i = heappop(eq)\n    if et == IN:        \n        p = P(n)\n        i = check(c, p)\n        if ans[n-1] != -1 and i is not None:\n            c = c | (p << i)\n            ans[n] = m - n * 5\n            heappush(eq, (m + M(n), n, OUT, i))\n        else:\n            heappush(eq, (m + 1, n, IN, None)) #\n    else:        \n        p = P(n)\n        c = c ^ (p << i)\n\nwhile True:\n    try:\n        n = input()\n        print ans[n]\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0147\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom heapq import heappop, heappush\nfrom collections import deque\ninput = stdin.readline\n\n\nclass Seat():\n    def __init__(self, n):\n        self.seat = '_' * n\n\n    def get(self, num):\n        i = self.seat.find('_'*num)\n        if i != -1:\n            self.seat = self.seat[0:i] + 'o'*num + self.seat[i+num:]\n            return i\n        return None\n\n    def release(self, i, num):\n        self.seat = self.seat[0:i] + '_'*num + self.seat[i+num:]\n\n\ndef solve():\n    waiting_time = [-1] * 100\n    NUM_OF_SEAT = 17\n    seat = Seat(NUM_OF_SEAT)\n    LEAVE = 0\n    COME = 1\n    in_out = []                 #  ??\\?????????????????????????????????\n    Q = deque()                      #  ??§??????????????????\n    # 100???????????\\????????????????????????\n    for group_id in range(100):\n        if group_id % 5 == 1:\n            num = 5\n        else:\n            num = 2\n        heappush(in_out, (group_id * 5, COME, NUM_OF_SEAT+1, group_id, num))\n\n    while in_out:\n        time, event, start_seat, group_id, num = heappop(in_out)\n        if event == COME:\n            Q.append((time, group_id, num))\n        else:\n            seat.release(start_seat, num)\n        while Q:\n            res = seat.get(Q[0][2])\n            if res is not None:\n                arrive, group_id, num = Q.popleft()\n                waiting_time[group_id] = time - arrive\n                eating_time = 17 * (group_id % 2) + 3*(group_id % 3) + 19\n                heappush(in_out, (time + eating_time, LEAVE, res, group_id, num))\n            else:\n                break\n    return waiting_time\n\n\ndef main(args):\n    waiting_time = solve()\n\n    for line in sys.stdin:\n        print(waiting_time[int(line)])\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "# AOJ 0147 Fukushimaken\n# Python3 2018.6.23 bal4u\n# キューで待ち行列\n\nS = 17\nseat = [[0 for t in range(27)] for id in range(27)]\nans = [0]*105\nid = 0\nQ = []\nfor i in range(S): seat[i][0] = -1\nt = -1\nwhile ans[99] == 0:\n\tt += 1\n\t# グループ到着\n\tif t % 5 == 0 and id <= 99:\n\t\tn = 5 if (id % 5) == 1 else 2\n\t\tQ.append((id, n, t))\n\t\tid += 1\n\n\t# 食事時間の確認\n\tfor i in range(S):\n\t\tif seat[i][1] == 0: continue\n\t\tseat[i][1] -= 1\n\t\tif seat[i][1] == 0: seat[i][0] = -1\n\n\t# 待ち行列の案内\n\tf = len(Q)\n\twhile f > 0:\n\t\ti, n = Q[0][0], Q[0][1]\n\t\tf = 0;\n\t\tfor j in range(S):\n\t\t\tg = 0\n\t\t\tfor k in range(n):\n\t\t\t\tif seat[j+k][0] >= 0:\n\t\t\t\t\tg = 1\n\t\t\t\t\tbreak\n\t\t\tif g: continue\n\t\t\tans[i] = t-Q[0][2]\n\t\t\tdel Q[0]\n\t\t\tf = len(Q)\n\t\t\tfor k in range(n):\n\t\t\t\tseat[j+k][0] = i\n\t\t\t\tseat[j+k][1] = 17*(i&1) + 3*(i%3) + 19\n\t\t\tbreak\n\nwhile 1:\n\ttry: n = int(input())\n\texcept: break\t\n\tprint(ans[n])\n"
  },
  {
    "language": "Python",
    "code": "R = range(100)\nM = [[2,5,2,2,2][i%5] for i in R]\nOut = [-1] *100\nP = [-1]*100\nS = [-1]*17\nQ = []\nW = [0]*100\n\ndef stand(I, s):\n  n = M[I]\n  P[I] = -1\n  S[s:s+n] = [-1] * n\n  Out[I] = -1\n  return 1\n\ndef sit(I, s):\n  n = M[I]\n  P[I] = s\n  S[s:s+n] = [I] * n\n  Out[I] = t+ 17*(I%2)+3*(I%3)+19\n  W[I] = t - I*5\n  return\n\ndef check(I):\n  n = M[I]\n  for s in range(17-n):\n    if S[s:s+n] == [-1]*n: return s\n  return -1\n\nt = 0\nc = 0\nwhile c<100:\n  while t in Out:\n    I = Out.index(t)\n    c += stand(I, P[I])\n\n  if t<500 and t%5==0: Q.append(t/5)\n \n  while len(Q)>0:\n    s = check(Q[0])\n    if s==-1: break\n    sit(Q.pop(0), s)\n  t += 1\n\nwhile 1:\n  try: print W[int(raw_input())]\n  except: break"
  },
  {
    "language": "Python",
    "code": "seat = [0]*17\ntime = [0]*100\nqueue = []\nt = 0\nwhile 1:\n    if t <= 5*99 and t%5 == 0:\n        queue.append(t/5)\n        \n    sits = []\n    for wait in queue:\n        p = (2 if wait%5 != 1 else 5)\n        for i in range(17-p):\n            if seat[i:i+p].count(0) == p:\n                seat[i:i+p] = [17*(wait%2)+3*(wait%3)+19]*p\n                sits.append(wait)\n                break\n        else:\n            break\n    for sit in sits:\n        queue.remove(sit)\n    seat = [max(0,i-1) for i in seat]\n    for wait in queue:\n        time[wait] += 1\n    t += 1\n    if t > 5*99 and not queue: break\n\nwhile 1:\n    try:\n        n = int(raw_input())\n        print time[n]\n    except:\n        break\n    "
  },
  {
    "language": "Python",
    "code": "R = range(100)\nIn = [i*5 for i in R]\nOut = [-1] *100\nMen = [[2, 5][(i % 5)==1] for i in R]\nPos = [-1]*100\nEat = [17*(i%2)+3*(i%3)+19 for i in R]\nSeat = [-1]*17\nQUE=[]\nWait = [0]*100\n\ndef stand(I, s):\n  n = Men[I]\n  Pos[I] = -1\n  Seat[s:s+n] = [-1] * n\n  Out[I] = -1\n  return 1\n\ndef sit(I, s):\n  n = Men[I]\n  Pos[I] = s\n  Seat[s:s+n] = [I] * n\n  Out[I] = t + Eat[I]\n  Wait[I] += t\n  return\n\ndef check(I):\n  n = Men[I]\n  for s in range(17-n):\n    if Seat[s:s+n] == [-1]*n: return s\n  return -1\n\nt = 0\nc = 0\nwhile c<100:\n  while t in Out:\n    I = Out.index(t)\n    c += stand(I, Pos[I])\n\n  while t in In:\n    I = In.index(t)\n    QUE.append(I)\n    Wait[I] = -t\n    In[I] = -1\n\n  while len(QUE)>0:\n    I = QUE[0]\n    s = check(I)\n    if s==-1: break\n    sit(I, s)\n    del QUE[0]\n  t += 1\n\nwhile 1:\n  try: I=int(raw_input())\n  except: break\n  print Wait[I]"
  },
  {
    "language": "Python",
    "code": "seat = [0]*17\ntime = [0]*100\nqueue = []\nt = 0\nwhile 1:\n    if t <= 5*99 and t%5 == 0:\n        queue.append(t/5)\n        \n    sits = []\n    for group in queue:\n        p = (2 if group%5 != 1 else 5)\n        for j in range(17-p+1):\n            if seat[j:j+p].count(0) == p:\n                seat[j:j+p] = [17*(group%2)+3*(group%3)+19]*p\n                sits.append(group)\n                break\n        else:\n            break\n    for sit in sits:\n        queue.remove(sit)\n        \n    seat = [max(0,i-1) for i in seat]\n    for group in queue:\n        time[group] += 1\n    t += 1\n    if t > 5*99 and not queue: break\n\nwhile 1:\n    try:\n        n = int(raw_input())\n        print time[n]\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "R = range(100)\nM = [[2,5,2,2,2][i%5] for i in R]\nOut = [-1] *100\nP = [-1]*100\nS = [-1]*17\nQ = []\nW = [0]*100\n\ndef stand(I, s):\n  n = M[I]\n  P[I] = -1\n  S[s:s+n] = [-1] * n\n  Out[I] = -1\n  return 1\n\ndef sit(I, s):\n  n = M[I]\n  P[I] = s\n  S[s:s+n] = [I] * n\n  Out.[I] = t+ 17*(I%2)+3*(I%3)+19\n  W[I] = t - I*5\n  return\n\ndef check(I):\n  n = M[I]\n  for s in range(17-n):\n    if S[s:s+n] == [-1]*n: return s\n  return -1\n\nt = 0\nc = 0\nwhile t<100:\n  while t in Out:\n    I = Out.index(t)\n    c += stand(I, P[I])\n\n  if t<500 and t%5==0: Q.append(t/5)\n \n  while len(Q)>0:\n    s = check(Q[0])\n    if s==-1: break\n    sit(Q.pop(0), s)\n  t += 1\n\nwhile 1:\n  try: print W[int(raw_input())]\n  except: break"
  },
  {
    "language": "Python",
    "code": "seat = [0]*17\nwait = [0]*100\nqueue = []\nt = 0\nwhile 1:\n    if t <= 5*99 and t%5 == 0:\n        queue.append(t/5)\n        \n    newqueue = queue[:]\n    for group in queue:\n        p = (2 if group%5 != 1 else 5)\n        for j in range(17-p+1):\n            if seat[j:j+p] == [0]*p:\n                seat[j:j+p] = [17*(group%2)+3*(group%3)+19]*p\n                newqueue.remove(group)\n                break\n        else:\n            break\n    queue = newqueue[:]\n    seat = [max(0,i-1) for i in seat]\n    for group in queue:\n        wait[group] += 1\n    t += 1\n    if t > 5*99 and not queue: break\n\nwhile 1:\n    try:\n        print wait[int(raw_input())]\n    except:\n        break\n    "
  },
  {
    "language": "Python",
    "code": "seat = [0]*17\ntime = [0]*99\nqueue = []\nt = 0\nwhile 1:\n    if t < 5*99 and t%5 == 0:\n        queue.append(t/5)\n        \n    sits = []\n    for wait in queue:\n        p = (2 if wait%5 != 1 else 5)\n        for i in range(17-p):\n            if seat[i:i+p].count(0) == p:\n                seat[i:i+p] = [17*(wait%2)+3*(wait%3)+19]*p\n                sits.append(wait)\n                break\n        else:\n            break\n    for sit in sits:\n        queue.remove(sit)\n    seat = [max(0,i-1) for i in seat]\n    for wait in queue:\n        time[wait] += 1\n    t += 1\n    if t > 5*99 and not queue: break\n\nwhile 1:\n    try:\n        n = int(raw_input())\n        print time[n]\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "def et():\n    lis = []\n    for n in eat:\n        eat[n] = eat[n]-1\n        if eat[n] == 0:\n            ct(n)\n            lis.append(n)\n    for n in lis:\n        del eat[n]\n        \ndef ct(n):\n    for i, s in enumerate(counter):\n        if s == n:\n            counter[i] = '_'\n            \ndef wt():\n    for n in wait:\n        wait[n] = wait[n]+1\n        \ndef ck(n, w):\n    c = 5 if n%5 == 1 else 2\n    for i, s in enumerate(counter):\n        if s == '_':\n            if counter[i:i+c] == ['_']*c:\n                for i in range(i,i+c):\n                    counter[i] = n\n                else:\n                    res[n] = w\n                    return True\n    \nres = {}       \nprocession = []\nwait = {}\neat = {}\ncounter = ['_' for i in range(17)]\nt = 0\nwhile True:\n    et()\n    wt()\n    if procession:\n        for n in procession[:]:\n            if ck(n, wait[n]):\n                del wait[n]\n                del procession[0]\n                eat[n] = 17*(n%2)+3* (n%3)+19\n            else:\n                break\n    if len(res) == 100:\n        break\n    if t <= 495:\n        if t%5 == 0:\n            n = t/5\n            if not procession and ck(n, 0):\n                eat[n] = 17*(n%2)+3* (n%3)+19\n            else:\n                procession.append(n)\n                wait[n] = 0\n    t += 1\n    \nwhile True:\n    try:\n        print res[input()]\n    except EOFError:\n        break"
  },
  {
    "language": "Python",
    "code": "#Fukushimaken: \nfrom heapq import heappop, heappush\nOUT, IN = 0, 1\ndef P(i):\n    return 31 if i % 5 == 1 else 3\n\ndef M(i):\n    return 17 * (i % 2) + 3 * (i % 3) + 19\n\ndef check(c, n):\n    for i in xrange(16):\n        if (c >> i) & n == 0:\n            return i\n    return None\n\nans = [-1] * 100 + [0]\neq = map(lambda i: (i * 5, i, IN, None, P(i)), xrange(100))\nc = 1 << 17\nwhile len(eq) != 0:    \n    m, n, et, i, p = heappop(eq)\n    if et == IN:        \n        i = check(c, p)\n        if ans[n-1] != -1 and i is not None:\n            c = c | (p << i)\n            ans[n] = m - n * 5\n            heappush(eq, (m + M(n), n, OUT, i, p))\n        else:\n            heappush(eq, (m + 1, n, IN, None, p)) #\n    else:        \n        c = c ^ (p << i)\n\nwhile True:\n    try:\n        n = input()\n        print ans[n]\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "seat = [0]*17\ntime = [0]*100\nqueue = []\nt = 0\nwhile 1:\n    if t <= 5*99 and t%5 == 0:\n        queue.append(t/5)\n        \n    sits = []\n    for wait in queue:\n        p = (2 if wait%5 != 1 else 5)\n        for i in range(17-p):\n            if seat[i:i+p].count(0) == p:\n                seat[i:i+p] = [17*(wait%2)+3*(wait%3)+19]*p\n                sits.append(wait)\n                break\n        else:\n            break\n    for sit in sits:\n        queue.remove(sit)\n    seat = [max(0,i-1) for i in seat]\n    for wait in queue:\n        time[wait] += 1\n    t += 1\n    if t > 5*99 and not queue: break\n\nwhile 1:\n    try:\n        n = int(raw_input())\n        print time[n]\n    except:\n        break\n    "
  },
  {
    "language": "Python",
    "code": "#Fukushimaken: \nfrom heapq import heappop, heappush\ndef P(i):\n    return 31 if i % 5 == 1 else 3\n\ndef M(i):\n    return 17 * (i % 2) + 3 * (i % 3) + 19\n\ndef check(c, n):\n    for i in xrange(16):\n        if (c >> i) & n == 0:\n            return i\n    return None\n\nans = [-1] * 100 + [0]\neq = map(lambda i: (i * 5, i, None, P(i)), xrange(100))\nc = 1 << 17\nwhile len(eq) != 0:    \n    m, n, i, p = heappop(eq)\n    if i is None:        \n        i = check(c, p)\n        if ans[n-1] != -1 and i is not None:\n            c = c | (p << i)\n            ans[n] = m - n * 5\n            heappush(eq, (m + M(n), n, i, p))\n        else:\n            heappush(eq, (m + 1, n, None, p)) #\n    else:        \n        c = c ^ (p << i)\n\nwhile True:\n    try:\n        print ans[input()]\n    except:\n        break"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nfrom heapq import heappush, heappop\nque = deque()\nq = []\nN = 100\nfor i in range(N):\n    heappush(q, (5*i, 0, i))\nM = 17\nS = [-1]*M\nT = [0]*N\nwhile q:\n    t = None\n    while q and (t is None or q[0][0] == t):\n        t, c, i = heappop(q)\n        if c == 0:\n            que.append(i)\n        else:\n            for j in range(M):\n                if S[j] == i:\n                    S[j] = -1\n\n    while que:\n        i = que[0]\n        m = 5 if i % 5 == 1 else 2\n\n        cnt = 0; j = -1\n        for k in range(M):\n            if S[k] == -1:\n                cnt += 1\n                if cnt == m:\n                    j = k-m+1\n                    break\n            else:\n                cnt = 0\n        if j == -1:\n            break\n        for k in range(m):\n            S[j + k] = i\n        T[i] = t - 5*i\n        que.popleft()\n        heappush(q, (t + (17*(i%2) + 3*(i%3) + 19), 1, i))\nopen(1, 'w').writelines([\"{}\\n\".format(T[v]) for v in map(int, open(0).read().split())])\n"
  },
  {
    "language": "Python",
    "code": "R = range(100)\nM = [[2,5,2,2,2][i%5] for i in R]\nOut = [-1] *100\nP = [-1]*100\nS = [-1]*17\nQ = []\nW = [0]*100\n\ndef stand(I, s):\n  n = M[I]\n  P[I] = -1\n  S[s:s+n] = [-1] * n\n  Out[I] = -1\n  return 1\n\ndef sit(I, s):\n  n = M[I]\n  P[I] = s\n  S[s:s+n] = [I] * n\n  Out[I] = t+ 17*(I%2)+3*(I%3)+19\n  W[I] = t - I*5\n  return\n\ndef check(I):\n  n = M[I]\n  for s in range(17-n+1):\n    if S[s:s+n] == [-1]*n: return s\n  return -1\n\nt = 0\nc = 0\nwhile c<100:\n  while t in Out:\n    I = Out.index(t)\n    c += stand(I, P[I])\n\n  if t<500 and t%5==0: Q.append(t/5)\n \n  while len(Q)>0:\n    s = check(Q[0])\n    if s==-1: break\n    sit(Q.pop(0), s)\n  t += 1\n\nwhile 1:\n  try: print W[int(raw_input())]\n  except: break"
  },
  {
    "language": "Python",
    "code": "S = [0]*17\nQ = []\nW = [0]*100\n \ndef check(I):\n  n = [2,5][I%5==1]\n  for s in range(17-n+1):\n    if S[s:s+n] == [0]*n: return s\n  return -1\n\nt = 0\nc = 0\nwhile c<100:\n  for i in range(S.count(t)): S[S.index(t)]=0\n  if t<500 and t%5==0: Q.append(t/5)\n  \n  while len(Q)>0:\n    s = check(Q[0])\n    if s==-1: break\n    I = Q.pop(0)\n    n = [2,5][I%5==1]\n    S[s:s+n] = [t+ 17*(I%2) + 3*(I%3) + 19] * n\n    W[I] = t - I*5\n    c += 1\n  t += 1\n \nwhile 1:\n  try: print W[int(raw_input())]\n  except: break"
  },
  {
    "language": "Rust",
    "code": "use std::collections::BinaryHeap;\nuse std::collections::VecDeque;\n\nfn main(){\n\n  let mut seat: Vec<usize> = vec![0; 18];\n\n  for i in 0 .. 17 {\n    seat[i] = 17 - i;\n  }\n\n  let mut tm: usize = 0;\n\n  let mut que: VecDeque<usize> = VecDeque::new();\n  \n  let mut bh: BinaryHeap<(i32, usize, usize)> = BinaryHeap::new();\n  \n  seat[0] = 0;\n  seat[1] = 0;\n\n  let et: i32 = -1 * ((tm + meal_time(0)) as i32);\n  bh.push((et, 0, 0));\n\n  let mut rslt: Vec<usize> = vec![0;100];\n\n  let mut ext: bool = false;\n  \n  loop {\n    tm += 1;\n\n    loop {\n      match bh.peek() {\n        Some(&(tpt, ti, tsn)) => {\n          let tt: usize = (-1 * tpt) as usize;\n  \n          if tt == tm {\n            for i in tsn .. tsn + num_member(ti) {\n              seat[i] = 1;\n            }\n            for i in (0..17).rev() {\n              if seat[i] != 0 {\n                seat[i] = seat[i+1] + 1;\n              }\n            }\n            bh.pop();\n          } else { break; }\n        },\n        None => { break; }\n      }\n    }\n    \n    if tm % 5 == 0  && tm < 500{\n      que.push_back(tm / 5);\n    }\n\n    loop {\n      match que.front() {\n        Some(&ti) => {\n          let tn = num_member(ti);\n          match find_seat(&seat, tn) {\n            Some(tsi) => {\n              for i in tsi .. tsi + tn {\n                seat[i] = 0;\n              }\n              que.pop_front();\n              rslt[ti] = tm - 5 * ti;\n\n              let pt: i32 = -1 * ((tm + meal_time(ti)) as i32);\n              bh.push((pt, ti, tsi));\n              \n              if ti == 99 { ext = true; }\n            },\n            None => { break; }\n          }\n        },\n        None => { break; }\n      }\n    }\n    if ext { break; }\n  }\n\n  loop {\n    let mut buf = String::new();\n    \n    if let Ok(c) = std::io::stdin().read_line(&mut buf) {\n      if c == 0 { break; }\n    }\n\n    let n: usize = buf.trim().parse().unwrap();\n    println!(\"{}\", rslt[n]);\n  }\n}\n\nfn num_member(i: usize) -> usize {\n  if i % 5 == 1 { 5 } else { 2 }\n}\n\nfn meal_time(i: usize) -> usize {\n  17 * (i % 2) + 3 * (i % 3) + 19\n}\n\nfn find_seat(st: &Vec<usize>, t: usize) -> Option<usize> {\n  for i in 0 .. 17 {\n    if st[i] >= t {\n      return Some(i)\n    }\n  }\n  None\n}\n\n"
  }
]