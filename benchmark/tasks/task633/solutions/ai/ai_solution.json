[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int heights[2*N];\n    for (int i = 0; i < 2*N; i++) {\n        scanf(\"%d\", &heights[i]);\n    }\n    \n    long long dp[2*N+1][N+1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    \n    for (int i = 0; i < 2*N; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (dp[i][j] == 0) continue;\n            \n            for (int k = i+1; k < 2*N; k++) {\n                if (heights[i] != heights[k]) {\n                    dp[k+1][j+1] = (dp[k+1][j+1] + dp[i][j]) % MOD;\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", dp[2*N][N]);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAX_N 50000\n#define MAX_H 100000\n\ntypedef long long ll;\n\nint N;\nint h[2 * MAX_N + 1];\nint freq[MAX_H + 1];\nll fact[2 * MAX_N + 1];\nll inv_fact[2 * MAX_N + 1];\nll dp[MAX_N + 1];\n\nll mod_pow(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nvoid precompute_factorials() {\n    fact[0] = 1;\n    for (int i = 1; i <= 2 * MAX_N; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    inv_fact[2 * MAX_N] = mod_pow(fact[2 * MAX_N], MOD - 2);\n    for (int i = 2 * MAX_N - 1; i >= 0; i--) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nint main() {\n    precompute_factorials();\n    scanf(\"%d\", &N);\n    for (int i = 0; i < 2 * N; i++) {\n        scanf(\"%d\", &h[i]);\n        freq[h[i]]++;\n    }\n    \n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    \n    for (int num = 1; num <= MAX_H; num++) {\n        int cnt = freq[num];\n        for (int pairs = N; pairs >= 0; pairs--) {\n            for (int take = 1; take <= cnt && pairs + take <= N; take++) {\n                ll ways = comb(cnt, take) * comb(cnt, take) % MOD * fact[take] % MOD;\n                dp[pairs + take] = (dp[pairs + take] + dp[pairs] * ways) % MOD;\n            }\n        }\n    }\n    \n    ll ans = dp[N];\n    ans = ans * inv_fact[N] % MOD;\n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> h(2*N);\n    for (int i = 0; i < 2*N; ++i) {\n        cin >> h[i];\n    }\n    sort(h.begin(), h.end());\n    \n    vector<vector<int>> dp(N+1, vector<int>(2*N + 1, 0));\n    dp[0][0] = 1;\n    \n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= 2*N; ++j) {\n            if (i == 0 && j == 0) continue;\n            if (j == 0) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = dp[i][j-1];\n                if (i > 0 && j > 1) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-2]) % MOD;\n                }\n            }\n        }\n    }\n    \n    vector<int> fact(2*N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= 2*N; ++i) {\n        fact[i] = 1LL * fact[i-1] * i % MOD;\n    }\n    \n    long long ans = dp[N][2*N];\n    map<int, int> freq;\n    for (int num : h) {\n        freq[num]++;\n    }\n    for (auto &p : freq) {\n        ans = ans * fact[p.second] % MOD;\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n    static int[] fact;\n    static int[] invFact;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        int[] h = new int[2 * N];\n        for (int i = 0; i < 2 * N; i++) {\n            h[i] = Integer.parseInt(br.readLine());\n        }\n        Arrays.sort(h);\n\n        precomputeFactorials(2 * N);\n\n        long[] dp = new long[N + 1];\n        dp[0] = 1;\n        int[] cnt = new int[100001];\n        for (int num : h) {\n            cnt[num]++;\n        }\n\n        List<Integer> freqList = new ArrayList<>();\n        for (int i = 1; i <= 100000; i++) {\n            if (cnt[i] > 0) {\n                freqList.add(cnt[i]);\n            }\n        }\n\n        for (int f : freqList) {\n            for (int j = N; j >= 0; j--) {\n                if (dp[j] == 0) continue;\n                if (j + 1 <= N) {\n                    dp[j + 1] = (dp[j + 1] + dp[j] * f % MOD) % MOD;\n                }\n            }\n        }\n\n        long ans = dp[N];\n        ans = ans * fact[N] % MOD;\n        for (int f : freqList) {\n            ans = ans * invFact[f / 2] % MOD;\n        }\n\n        System.out.println(ans);\n    }\n\n    static void precomputeFactorials(int max) {\n        fact = new int[max + 1];\n        invFact = new int[max + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= max; i++) {\n            fact[i] = (int)((long)fact[i - 1] * i % MOD);\n        }\n        invFact[max] = modInverse(fact[max], MOD);\n        for (int i = max - 1; i >= 0; i--) {\n            invFact[i] = (int)((long)invFact[i + 1] * (i + 1) % MOD);\n        }\n    }\n\n    static int modInverse(int a, int m) {\n        int m0 = m;\n        int y = 0, x = 1;\n        if (m == 1) return 0;\n        while (a > 1) {\n            int q = a / m;\n            int t = m;\n            m = a % m;\n            a = t;\n            t = y;\n            y = x - q * y;\n            x = t;\n        }\n        if (x < 0) x += m0;\n        return x;\n    }\n}",
    "timestamp": "2025-08-05 22:24:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PairedPeople {\n    static final int MOD = 998244353;\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] heights = new int[2*N];\n        \n        for (int i = 0; i < 2*N; i++) {\n            heights[i] = sc.nextInt();\n        }\n        \n        long[][] dp = new long[2*N + 1][N + 1];\n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= 2*N; i++) {\n            for (int j = 0; j <= N; j++) {\n                // Skip pairing current person\n                if (j <= i-1) {\n                    dp[i][j] = dp[i-1][j];\n                }\n                \n                // Try pairing current person with others\n                for (int k = 0; k < i-1; k++) {\n                    if (heights[k] != heights[i-1] && j > 0) {\n                        dp[i][j] = (dp[i][j] + dp[k][j-1]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[2*N][N]);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:24:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 998244353;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<int> heights(2*N);\n    for (int i = 0; i < 2*N; ++i) {\n        cin >> heights[i];\n    }\n\n    vector<vector<ll>> dp(2*N + 1, vector<ll>(N + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < 2*N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (dp[i][j] == 0) continue;\n            \n            // Don't pair current person\n            if (j < N) {\n                for (int k = i+1; k < 2*N; ++k) {\n                    if (heights[i] != heights[k]) {\n                        dp[k+1][j+1] = (dp[k+1][j+1] + dp[i][j]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[2*N][N] << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 998244353\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    \n    # Read the input\n    data = input().split()\n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    # Count the occurrences of each height\n    from collections import Counter\n    height_count = Counter(heights)\n    \n    # Check if it's possible to form the pairs\n    for count in height_count.values():\n        if count % 2 != 0:\n            print(0)\n            return\n    \n    # Calculate factorials\n    from math import factorial\n    \n    num_ways = 1\n    for count in height_count.values():\n        num_ways *= factorial(count // 2)\n        num_ways %= MOD\n    \n    # Calculate the number of ways to partition N pairs such that each height has different pair members\n    num_ways *= factorial(N)\n    num_ways %= MOD\n    \n    print(num_ways)\n\nsolve()",
    "timestamp": "2025-08-13 10:22:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class PairCounts {\n    private static final int MOD = 998244353;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        \n        int N = Integer.parseInt(reader.readLine().trim());\n        int[] heights = new int[2 * N];\n        \n        for (int i = 0; i < 2 * N; i++) {\n            heights[i] = Integer.parseInt(reader.readLine().trim());\n        }\n        \n        Arrays.sort(heights);\n        \n        long answer = 1;\n        for (int i = 0; i < N; i++) {\n            int distinctPairs = heights[i + N] - heights[i];\n            answer = (answer * distinctPairs) % MOD;\n        }\n        \n        long factorial = 1;\n        for (int i = 1; i <= N; i++) {\n            factorial = (factorial * i) % MOD;\n        }\n        \n        answer = (answer * factorial) % MOD;\n        \n        System.out.println(answer);\n    }\n}",
    "timestamp": "2025-08-13 10:22:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MODULO 998244353\n\nlong long factorial[100001];\n\nvoid init_factorial(int n) {\n    factorial[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        factorial[i] = (factorial[i - 1] * i) % MODULO;\n    }\n}\n\nlong long power_mod(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long inverse_mod(long long x, long long mod) {\n    return power_mod(x, mod - 2, mod);\n}\n\nint compare(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int people_count = 2 * N;\n    int *heights = (int *)malloc(sizeof(int) * people_count);\n\n    for (int i = 0; i < people_count; ++i) {\n        scanf(\"%d\", &heights[i]);\n    }\n\n    qsort(heights, people_count, sizeof(int), compare);\n\n    long long result = factorial[N];\n\n    long long duplicates = 1;\n    int current_count = 1;\n\n    for (int i = 1; i <= people_count; ++i) {\n        if (i < people_count && heights[i] == heights[i - 1]) {\n            ++current_count;\n        } else {\n            duplicates = (duplicates * factorial[current_count]) % MODULO;\n            current_count = 1;\n        }\n    }\n\n    result = (result * inverse_mod(duplicates, MODULO)) % MODULO;\n\n    for (int i = 0; i < N; ++i) {\n        if (heights[2 * i] == heights[2 * i + 1]) {\n            printf(\"0\\n\");\n            free(heights);\n            return 0;\n        }\n    }\n\n    free(heights);\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:23:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, heights):\n    MOD = 998244353\n    \n    # Sort heights and create index mapping\n    indexed_heights = [(h, i) for i, h in enumerate(heights)]\n    indexed_heights.sort()\n    \n    # Dynamic programming\n    dp = [0] * (1 << (2*N))\n    dp[0] = 1\n    \n    for mask in range(1 << (2*N)):\n        if bin(mask).count('1') % 2 != 0:\n            continue\n        \n        # Find first unmatched person\n        i = 0\n        while i < 2*N and (mask & (1 << i)):\n            i += 1\n        \n        # Try pairing with other unmatched people\n        for j in range(i+1, 2*N):\n            if (mask & (1 << j)) == 0 and indexed_heights[i][0] != indexed_heights[j][0]:\n                new_mask = mask | (1 << i) | (1 << j)\n                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD\n    \n    return dp[(1 << (2*N)) - 1]\n\n# Read input\nN = int(input())\nheights = [int(input()) for _ in range(2*N)]\n\n# Print output\nprint(solve(N, heights))",
    "timestamp": "2025-08-13 10:23:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    h = list(map(int, input[ptr:ptr + 2*N]))\n    ptr += 2*N\n    \n    h.sort()\n    fact = [1] * (2*N + 1)\n    inv_fact = [1] * (2*N + 1)\n    for i in range(1, 2*N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[2*N] = pow(fact[2*N], MOD-2, MOD)\n    for i in range(2*N - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # Precompute the number of pairs where h[i] != h[j]\n    # We need to count the number of valid pairings\n    # The answer is (number of all pairings) - (number of pairings with at least one pair having same height)\n    # But inclusion-exclusion is complicated, so we can use DP\n    \n    # The key observation is that the answer is (2N)! / (2^N N!) ) multiplied by some inclusion-exclusion terms\n    # But it's easier to think in terms of DP\n    \n    # Let's count the number of ways to pair 2N people where no pair has same height\n    # The answer is (2N-1)!! * product_{x} (1 - m_x / (total pairs remaining at that step))\n    # But this is not straightforward\n    \n    # Alternative approach: group by the same heights\n    from collections import defaultdict\n    freq = defaultdict(int)\n    for num in h:\n        freq[num] += 1\n    \n    # The problem reduces to counting the number of perfect matchings in a graph where edges are between different h's\n    # The total number of perfect matchings is (2N)! / (2^N N!) ) = (2N-1)!!\n    # We need to subtract the invalid ones\n    \n    # But inclusion-exclusion is tricky, so we use DP where we process the counts in order\n    # Let dp[i][j] = number of ways to choose j pairs with same height, using first i groups\n    # Then the answer is sum_{j=0 to max_pairs} (-1)^j * dp[m][j] * (2N - 2j - 1)!! * (j! 2^j)\n    \n    # The total answer is sum_{j=0}^{k} (-1)^j * (number of ways to choose j same pairs) * (number of ways to pair the rest) * j! * 2^j\n    \n    # The number of ways to pair the rest is (2N - 2j - 1)!!\n    \n    # So first, compute the number of ways to choose j same pairs\n    # Then multiply by (-1)^j * (2N - 2j - 1)!! * j! * 2^j\n    \n    # So first, compute the DP for selecting j same pairs\n    m = len(freq)\n    counts = sorted(freq.values())\n    \n    max_pairs_possible = sum(c // 2 for c in counts)\n    \n    # Initialize DP\n    dp = [0] * (N + 2)\n    dp[0] = 1\n    for cnt in counts:\n        new_dp = [0] * (N + 2)\n        max_pairs = cnt // 2\n        for j in range(N + 1):\n            if dp[j] == 0:\n                continue\n            for k in range(0, max_pairs + 1):\n                if j + k > N:\n                    continue\n                # The number of ways to choose k pairs from cnt elements is C(cnt, 2k) * (2k-1)!! \n                # C(cnt, 2k) * (2k-1)!! = cnt! / ( (cnt - 2k)! k! 2^k )\n                term = fact[cnt] * inv_fact[cnt - 2 * k] % MOD\n                term = term * inv_fact[k] % MOD\n                term = term * pow(inv_fact[2], k, MOD) % MOD\n                new_dp[j + k] = (new_dp[j + k] + dp[j] * term) % MOD\n        dp = new_dp\n    \n    # Precompute (2N - 2j -1)!! for j from 0 to N\n    double_fact = [1] * (2*N + 2)\n    for i in range(1, 2*N + 2):\n        if i % 2 == 0:\n            double_fact[i] = double_fact[i-1] * (i // 2) % MOD\n        else:\n            double_fact[i] = double_fact[i-1] * i % MOD\n    \n    ans = 0\n    for j in range(0, N + 1):\n        if 2*j > 2*N:\n            continue\n        remaining = 2*N - 2*j\n        if remaining < 0:\n            continue\n        ways = dp[j]\n        # (2N - 2j -1)!! is double_fact[2N - 2j -1]\n        # But double_fact[2m -1] = (2m)! / (2^m m!)\n        # So double_fact[2N - 2j -1] = (2*(N-j))! / (2^{N-j} (N-j)!)\n        # So double_fact[2*(N-j) -1] = fact[2*(N-j)] * inv_fact[N-j] * pow(2, -(N-j), MOD) mod MOD\n        # But we can precompute double_fact up front\n        current_double_fact = double_fact[2*(N-j) -1]\n        sign = (-1)**j\n        term = ways * current_double_fact % MOD\n        term = term * pow(2, j, MOD) % MOD\n        term = term * fact[j] % MOD\n        if sign == 1:\n            ans = (ans + term) % MOD\n        else:\n            ans = (ans - term) % MOD\n    print(ans % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 10:24:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<int> heights(2 * N);\n    \n    for (int i = 0; i < 2 * N; ++i) {\n        std::cin >> heights[i];\n    }\n    \n    std::sort(heights.begin(), heights.end());\n    \n    std::vector<long long> fact(2 * N + 1, 1);\n    for (int i = 2; i <= 2 * N; ++i) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    \n    std::vector<long long> inverse_fact(2 * N + 1, 1);\n    inverse_fact[2 * N] = 1; \n    \n    long long power = fact[2 * N - 1];\n    long long base = MOD - 2;\n    int exp = MOD - 2;\n    \n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            inverse_fact[2 * N] = (inverse_fact[2 * N] * power) % MOD;\n        }\n        power = (power * power) % MOD;\n        exp /= 2;\n    }\n    \n    for (int i = 2 * N - 1; i >= 1; --i) {\n        inverse_fact[i] = (inverse_fact[i + 1] * (i + 1)) % MOD;\n    }\n    \n    std::unordered_map<int, int> height_count;\n    for (int h : heights) {\n        ++height_count[h];\n    }\n    \n    long long ans = 1;\n    for (const auto &entry : height_count) {\n        ans = (ans * inverse_fact[entry.second]) % MOD;\n    }\n\n    ans = (ans * fact[N]) % MOD;\n    \n    for (int i = 0; i < N; ++i) {\n        ans = (ans * (heights[N + i] - heights[i])) % MOD;\n    }\n    \n    std::cout << ans << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:58:46"
  }
]