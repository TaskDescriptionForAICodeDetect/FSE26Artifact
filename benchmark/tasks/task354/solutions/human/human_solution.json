[
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvoid rotx(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[5];\tv[2]=t[1];\tv[3]=t[0];\n\tv[4]=t[7];\tv[5]=t[6];\tv[6]=t[2];\tv[7]=t[3];\n}\n\nvoid roty(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[0];\tv[2]=t[6];\tv[3]=t[2];\n\tv[4]=t[5];\tv[5]=t[1];\tv[6]=t[7];\tv[7]=t[3];\n}\n\nvoid rotz(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[0];\tv[2]=t[1];\tv[3]=t[2];\n\tv[4]=t[7];\tv[5]=t[4];\tv[6]=t[5];\tv[7]=t[6];\n}\n\nvi findRegularPaint(const vi &_a){\n\tvi a=_a,reg=a;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\treg=min(reg,a);\n\t\t\trotz(a);\n\t\t}\n\t\trotx(a);\n\t}\n\troty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\troty(a),roty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\n\treturn reg;\n}\n\nint vi2int(const vi &a){\n\tint res=0;\n\trep(i,a.size())\tres=res*10+a[i];\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tstring s[8];\n\t\trep(i,8) if(!(cin>>s[i])) return 0;\n\n\t\tvi clr(8);\n\t\t{\n\t\t\tint id=0;\n\t\t\tmap<string,int> colorid;\n\t\t\trep(i,8){\n\t\t\t\tif(colorid.count(s[i])==0)\tcolorid[s[i]]=id++;\n\t\t\t\tclr[i]=colorid[s[i]];\n\t\t\t}\n\t\t}\n\t\tsort(clr.begin(),clr.end());\n\n\t\tset<int> cube;\n\t\tdo{\n\t\t\tcube.insert(vi2int(findRegularPaint(clr)));\n\t\t}while(next_permutation(clr.begin(),clr.end()));\n\n\t\tcout<<cube.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvector<string> colors(8);\nvector<string> panels(8);\nset<vector<string>> ex;\nint ans = 0;\nvector<string> roll(vector<string> vs,int pos,int z){\n\tvector<string> res(8);\n\tif (pos < 4) {\n\t\tREP(i, 4) {\n\t\t\tres[i] = vs[(i + pos)%4];\n\t\t\tres[4+i]= vs[4+(i + pos) % 4];\n\t\t}\n\t\tvector<string> res2=res;\n\t\tif (z == 1) {\n\t\t\tres[1] = res2[3];\n\t\t\tres[3] = res2[4];\n\t\t\tres[4] = res2[1];\n\t\t\tres[5] = res2[2];\n\t\t\tres[2] = res2[7];\n\t\t\tres[7] = res2[5];\n\t\t}\n\t\tif (z == 2) {\n\t\t\tres[1] = res2[4];\n\t\t\tres[3] = res2[1];\n\t\t\tres[4] = res2[3];\n\t\t\tres[5] = res2[7];\n\t\t\tres[2] = res2[5];\n\t\t\tres[7] = res2[2];\n\t\t}\n\t}\n\telse {\n\t\t\tREP(i, 4) {\n\t\t\t\tres[i] = vs[4+(i + pos) % 4];\n\t\t\t\tres[4 + i] = vs[(i + pos) % 4];\n\t\t\t\t\n\t\t\t}\n\t\t\tvector<string> res2 = res;\n\t\t\tif (z == 1) {\n\t\t\t\tres[1] = res2[3];\n\t\t\t\tres[3] = res2[4];\n\t\t\t\tres[4] = res2[1];\n\t\t\t\tres[5] = res2[2];\n\t\t\t\tres[2] = res2[7];\n\t\t\t\tres[7] = res2[5];\n\t\t\t}\n\t\t\tif (z == 2) {\n\t\t\t\tres[1] = res2[4];\n\t\t\t\tres[3] = res2[1];\n\t\t\t\tres[4] = res2[3];\n\t\t\t\tres[5] = res2[7];\n\t\t\t\tres[2] = res2[5];\n\t\t\t\tres[7] = res2[2];\n\t\t\t}\n\t}\n\treturn res;\n}\nvoid dfs(int idx) {\n\tif (idx == 8) {\n\t\tif (ex.find(panels)==ex.end()){\n\t\t\tans++;\n\t\t\tREP(i,8)\n\t\t\t\tREP(j, 3) {\n\t\t\t\tex.insert(roll(panels,i,j));\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tREP(i,8){\n\t\tif (panels[i] == \"\") {\n\t\t\tpanels[i] = colors[idx];\n\t\t\tdfs(idx + 1);\n\t\t\tpanels[i] = \"\";\n\t\t}\n\t}\n}\nint main() {\n\t\n\twhile (cin>>colors[0]) {\n\t\tFOR(i, 1, 8) {\n\t\t\tcin >> colors[i];\n\t\t}\n\t\tpanels.clear();\n\t\tpanels.resize(8,\"\");\n\t\tex.clear();\n\t\tans = 0;\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nconst int tb[][8] = {\n\t{3, 0, 1, 2, 7, 4, 5, 6},\n\t{4, 0, 3, 7, 5, 1, 2, 6}\n};\n\nmap<string, int> cv;\nset<int> dn;\nint a[8];\n\nint main()\n{\n\twhile (true){\n\t\tcv.clear();\n\t\tdn.clear();\n\n\t\tstring s;\n\t\trep(i, 8){\n\t\t\tif (!(cin >> s)) return 0;\n\t\t\tint t = cv.size();\n\t\t\tif (cv.count(s)) a[i] = cv[s];\n\t\t\telse cv[s] = a[i] = t;\n\t\t}\n\n\t\tint res = 0;\n\t\tint perm[8];\n\t\tiota(perm, perm + 8, 0);\n\t\tdo {\n\t\t\tarray<int, 8> b;\n\t\t\tint c[16] = {};\n\t\t\trep(i, 8) b[i] = a[perm[i]];\n\t\t\tbool f = true;\n\t\t\trep(i, 16){\n\t\t\t\trep(j, 8) c[i] = c[i] * 8 + b[j];\n\t\t\t\tif (dn.count(c[i])) f = false;\n\t\t\t\tarray<int, 8> dst;\n\t\t\t\trep(j, 8){\n\t\t\t\t\tdst[j] = b[tb[0][j]];\n\t\t\t\t}\n\t\t\t\tif (i % 4 == 3){\n\t\t\t\t\trep(j, 8){\n\t\t\t\t\t\tdst[j] = b[tb[1][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = dst;\n\t\t\t}\n\t\t\tif (f) res++;\n\t\t\trep(i, 16) dn.insert(c[i]);\n\t\t} while (next_permutation(perm, perm + 8));\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  vector<int> v;\n  P(vector<int> &v) : v(v) {}\n  P rotate1() {\n    P r = *this;\n    REP(i,3) swap(r.v[i],r.v[(i+1)%4]);\n    REP(i,3) swap(r.v[4+i],r.v[4+(i+1)%4]);\n    return r;\n  }\n  P rotate2() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[5]);swap(w[5],w[1]);\n    swap(w[2],w[3]);swap(w[3],w[7]);swap(w[7],w[6]);\n    return P(w);\n  }\n  P rotate3() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[7]);swap(w[7],w[3]);\n    swap(w[1],w[5]);swap(w[5],w[6]);swap(w[6],w[2]);\n    return P(w);\n  }\n  vector<P> all() {\n    P r = *this;\n    vector<P> res;\n    for (int i=0; i<6; ++i,r=(i&2?r.rotate2():r.rotate3())) {\n      for (int j=0;j<4; ++j,r=r.rotate1())\n        res.push_back(r);\n    }\n    return res;\n  }\n};\nint main() {\n  string s;\n  while(cin>>s) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> v;\n    mp[s] = num++;\n    v.push_back(mp[s]);\n    REP(i,7) {\n      cin >> s;\n      if (mp.count(s) == 0) mp[s] = num++;\n      v.push_back(mp[s]);\n    }\n    vector<int> cnt(24);\n    do {\n      vector<P> ret = P(v).all();\n      REP(i,24) {\n        if (ret[i].v == v) cnt[i]++;\n      }\n    } while(next_permutation(ALL(v)));\n    int ans = 0;\n    REP(i,24) ans += cnt[i];\n    cout << ans/24 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Oct=array<int,8>;\nvoid rotateA(Oct& o){\n    Oct tmp=o;\n    for(int i=0;i<4;i++){\n        o[i]=tmp[(i+1)%4];\n        o[i+4]=tmp[(i+1)%4+4];\n    }\n}\nvoid rotateB(Oct& oct){\n    Oct tmp=oct;\n    oct[0]=tmp[4];\n    oct[1]=tmp[5];\n    oct[2]=tmp[1];\n    oct[3]=tmp[0];\n    oct[4]=tmp[7];\n    oct[5]=tmp[6];\n    oct[6]=tmp[2];\n    oct[7]=tmp[3];\n}\n\nbool check(Oct oct,set<Oct> &s){\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            for(int k=0;k<4;k++){\n                if(s.count(oct)) return false;             \n                rotateA(oct);\n            }\n            rotateB(oct);\n        }\n        rotateA(oct);\n    }\n    return true;\n}\nint dfs(int x,const vector<int>& v,set<Oct>& s,Oct& oct){\n    if(x==8){\n        assert(count(oct.begin(),oct.end(),-1)==0);\n        if(!check(oct,s)) return 0;\n        s.insert(oct);\n        return 1;\n    }\n    int res=0;\n    for(int i=0;i<oct.size();i++){\n        if(oct[i]==-1){\n            oct[i]=v[x];\n            res+=dfs(x+1,v,s,oct);\n            oct[i]=-1;\n        }\n    }\n    return res;\n}\nint main(){\n    vector<string> color(8);\n    while(cin>>color[0]){\n        for(int i=1;i<8;i++) cin>>color[i];\n        map<string,int> mp;\n        for(int i=0;i<8;i++) mp[color[i]]++;\n        vector<int> v;\n        int idx=0;\n        for(auto &e:mp){\n            for(int i=0;i<e.second;i++) v.push_back(idx);\n            idx++;\n        }\n        set<Oct> s;\n        Oct oct;\n        fill(oct.begin(),oct.end(),-1);\n        cout<<dfs(0,v,s,oct)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    auto equal=[](const vector<int>& x,const vector<int>& y){\n        auto equal_=[](const vector<int>& a,const vector<int>& b){\n            rep(i,0,4){\n                bool ok=true;\n                rep(j,0,4) if(a[j]!=b[(i+j)%4] or a[4+j]!=b[(4+i+j>=8?i+j:4+i+j)]){\n                    ok=false;\n                    break;\n                }\n                if(ok) return true;\n            }\n            rep(i,0,4){\n                bool ok=true;\n                rep(j,0,4) if(a[j]!=b[(4+i+j>=8?i+j:4+i+j)] or a[4+j]!=b[(i+j)%4]){\n                    ok=false;\n                    break;\n                }\n                if(ok) return true;\n            }\n            return false;\n        };\n        if(equal_(x,y)) return true;\n        vector<int> tmp(8);\n        const int idx1[]={0,4,5,1,3,7,6,2};\n        const int idx2[]={0,3,7,4,1,2,6,5};\n        rep(i,0,8) tmp[i]=y[idx1[i]];\n        if(equal_(x,tmp)) return true;\n        rep(i,0,8) tmp[i]=y[idx2[i]];\n        return equal_(x,tmp);\n    };\n    string tmp;\n    while(cin >> tmp){\n        vector<string> color(8);\n        color[0]=tmp;\n        rep(i,1,8) cin >> color[i];\n\n        map<string,int> mp;\n        int cnt=0;\n        rep(i,0,8) if(mp.find(color[i])==mp.end()){\n            mp[color[i]]=cnt;\n            ++cnt;\n        }\n        vector<int> v(8);\n        rep(i,0,8) v[i]=mp[color[i]];\n        sort(v.begin(),v.end());\n\n        vector<vector<int>> all;\n        do{\n            bool ok=true;\n            for(const auto& a:all) if(equal(v,a)){\n                ok=false;\n                break;\n            }\n            if(ok) all.emplace_back(v);\n        }while(next_permutation(v.begin(),v.end()));\n\n        cout << all.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvi right(vi& v)\n{\n\tvi res(8);\n\tREP(i, 4)\n\t{\n\t\tres[i] = v[(i + 3) % 4];\n\t\tres[i + 4] = v[(i + 3) % 4 + 4];\n\t}\n\treturn res;\n}\n\nvi forward(vi& v)\n{\n\tvi res(v);\n\tres[0] = v[3];\n\tres[1] = v[2];\n\tres[2] = v[6];\n\tres[3] = v[7];\n\tres[4] = v[0];\n\tres[5] = v[1];\n\tres[6] = v[5];\n\tres[7] = v[4];\n\treturn res;\n}\n\nint main()\n{\n\tstring s[8];\n\twhile (cin >> s[0])\n\t{\n\t\tREP(i, 7) cin >> s[i + 1];\n\t\tmap<string, int> mp;\n\t\tREP(i, 8) mp[s[i]]++;\n\t\tvi v;\n\t\tint t = 0;\n\t\tfor (auto i : mp)\n\t\t{\n\t\t\tREP(j, i.second) v.push_back(t);\n\t\t\tt++;\n\t\t}\n\t\tsort(ALL(v));\n\t\tset<vi> st;\n\t\tll cnt = 0;\n\t\tdo\n\t\t{\n\t\t\tif (st.count(v)) continue;\n\t\t\tcnt++;\n\t\t\tst.insert(v);\n\t\t\tvi tv = v;\n\t\t\tqueue<vi> que;\n\t\t\tque.push(v);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tvi tmp = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tauto r = right(tmp);\n\t\t\t\tauto f = forward(tmp);\n\t\t\t\tif (!st.count(r))\n\t\t\t\t{\n\t\t\t\t\tst.insert(r);\n\t\t\t\t\tque.push(r);\n\t\t\t\t}\n\t\t\t\tif (!st.count(f))\n\t\t\t\t{\n\t\t\t\t\tst.insert(f);\n\t\t\t\t\tque.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(ALL(v)));\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint color2num(map<string,int>& dictionary,const string& color){\n  if(dictionary.find(color) == dictionary.end()){\n    int idx = dictionary.size();\n    dictionary[color] = idx;\n  }\n  return dictionary[color];\n}\n\nclass Octahedra{\npublic:\n  int* upper_face;\n  int* lower_face;\n\n  Octahedra(){\n    upper_face = new int[4]();\n    lower_face = new int[4]();\n  }\n\n  void set_colors(const vector<int>& colors){\n    for(int i=0;i<4;i++){\n      upper_face[i] = colors[i];\n      lower_face[i] = colors[4+i];\n    }\n  }\n\n  int rotateZ(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      for(int i=0;i<4;i++){\n\ttmp_upper[(i+1)%4] = upper_face[i];\n\ttmp_lower[(i+1)%4] = lower_face[i];\n      }\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int rotateX(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      tmp_upper[1] = upper_face[0];\n      tmp_lower[1] = upper_face[1];\n      tmp_lower[2] = upper_face[2];\n      tmp_upper[2] = upper_face[3];\n\n      tmp_upper[0] = lower_face[0];\n      tmp_lower[0] = lower_face[1];\n      tmp_lower[3] = lower_face[2];\n      tmp_upper[3] = lower_face[3];\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n  \n  int rotateY(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      tmp_lower[0] = upper_face[0];\n      tmp_lower[1] = upper_face[1];\n      tmp_upper[1] = upper_face[2];\n      tmp_upper[0] = upper_face[3];\n\n      tmp_lower[3] = lower_face[0];\n      tmp_lower[2] = lower_face[1];\n      tmp_upper[2] = lower_face[2];\n      tmp_upper[3] = lower_face[3];\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int write(){\n    int res = 0;\n    int digit = 1;\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string color;\n\n  while(cin >> color){\n    vector<int> colors;\n    map<string,int> dictionary;\n    int color_num;\n    color_num = color2num(dictionary,color);\n    colors.push_back(color_num);\n    for(int i=1;i<8;i++){\n      cin >> color;\n\n      color_num = color2num(dictionary,color);\n      colors.push_back(color_num);\n    }\n\n    sort(colors.begin(),colors.end());\n\n    int res = 0;\n    set<int> visited;\n    do {\n      Octahedra oct;\n      int state;\n      bool isok = false;\n      for(int i=0;i<8;i++){\n\toct.set_colors(colors);\n\toct.rotateX(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateY(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateZ(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n      }\n\n      if(isok) res++;\n    }while(next_permutation(colors.begin(),colors.end()));\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvoid rotx(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[2];\tv[2]=t[6];\tv[3]=t[7];\n\tv[4]=t[0];\tv[5]=t[1];\tv[6]=t[5];\tv[7]=t[4];\n}\n\nvoid roty(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[0];\tv[2]=t[3];\tv[3]=t[7];\n\tv[4]=t[5];\tv[5]=t[1];\tv[6]=t[2];\tv[7]=t[6];\n}\n\nvoid rotz(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[0];\tv[2]=t[1];\tv[3]=t[2];\n\tv[4]=t[7];\tv[5]=t[4];\tv[6]=t[5];\tv[7]=t[6];\n}\n\nvi findRegularPaint(const vi &_a){\n\tvi a=_a,reg=_a;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\treg=min(reg,a);\n\t\t\trotz(a);\n\t\t}\n\t\trotx(a);\n\t}\n\troty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\troty(a),roty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\n\treturn reg;\n}\n\nint vi2int(const vi &a){\n\tint res=0;\n\trep(i,a.size())\tres=res*10+a[i];\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tstring s[8];\n\t\trep(i,8) if(!(cin>>s[i])) return 0;\n\n\t\tvi clr(8);\n\t\t{\n\t\t\tint id=0;\n\t\t\tmap<string,int> colorid;\n\t\t\trep(i,8){\n\t\t\t\tif(colorid.count(s[i])==0)\tcolorid[s[i]]=id++;\n\t\t\t\tclr[i]=colorid[s[i]];\n\t\t\t}\n\t\t}\n\t\tsort(clr.begin(),clr.end());\n\n\t\tset<int> cube;\n\t\tdo{\n\t\t\tcube.insert(vi2int(findRegularPaint(clr)));\n\t\t}while(next_permutation(clr.begin(),clr.end()));\n\n\t\tcout<<cube.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nusing P = array<char, 8>;\nP merge(P a, P b){\n    P c;\n    for (int i = 0; i < 8; ++i) {\n        c[i] = a[b[i]];\n    }\n    return c;\n}\n\n\nint main() {\n    string s;\n\n    P p = {3, 2, 6, 7, 0, 1, 5, 4}, q = {1, 5, 6, 2, 0, 4, 7, 3};\n    set<P> perm;\n    stack<P> S;\n    S.emplace(P{0, 1, 2, 3, 4, 5, 6, 7});\n    while(!S.empty()){\n        P x = S.top(); S.pop();\n        perm.emplace(x);\n        P y = merge(x, p), z = merge(x, q);\n        if(!perm.count(y)){\n            S.emplace(y);\n            perm.emplace(y);\n        }\n        if(!perm.count(z)){\n            S.emplace(z);\n            perm.emplace(z);\n        }\n    }\n    while(cin >> s){\n        vector<string> v;\n        v.emplace_back(s);\n        for (int i = 0; i < 7; ++i) {\n            string t;\n            cin >> t;\n            v.emplace_back(t);\n        }\n        auto u = v;\n        sort(u.begin(), u.end());\n        u.erase(unique(u.begin(), u.end()), u.end());\n        P x;\n        for (int i = 0; i < 8; ++i) {\n            x[i] = lower_bound(u.begin(),u.end(), v[i])- u.begin();\n        }\n        set<P> Q;\n        sort(x.begin(),x.end());\n        do {\n            int ok = 1;\n            for (auto &&j : perm) {\n                if(Q.count(merge(x, j))){\n                    ok = 0;\n                }\n            }\n            if(ok){\n                Q.emplace(x);\n            }\n        }while(next_permutation(x.begin(),x.end()));\n        cout << Q.size() << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Vec;\nvoid rotatex(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[2];a[2]=a[3];a[3]=tmp;\n  tmp=a[4];a[4]=a[5];a[5]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatey(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[5];a[5]=a[4];a[4]=tmp;\n  tmp=a[3];a[3]=a[2];a[2]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatez(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[4];a[4]=a[7];a[7]=a[3];a[3]=tmp;\n  tmp=a[1];a[1]=a[5];a[5]=a[6];a[6]=a[2];a[2]=tmp;\n}\n\nint main(){\n  string s[8];\n  set<Vec> sv;\n  map<Vec,bool> mv;\n  while(cin>>s[0]){\n    int i,j,k,ans=0;\n    sv.clear();mv.clear();\n    for(i=1;i<8;i++) cin>>s[i];\n    sort(s,s+8);\n    set<string> ss;\n    Vec v;\n    for(i=0;i<8;i++) ss.insert(s[i]),v.push_back(ss.size()-1);\n    do{\n      for(i=0;i<4;i++){\n\trotatez(v);\n\tfor(j=0;j<4;j++){\n\t  rotatey(v);\n\t  for(k=0;k<4;k++){\n\t    rotatex(v);\n\t    sv.insert(v);\n\t  }\n\t}\n      }\n    }while(next_permutation(v.begin(),v.end()));\n    for(Vec a:sv){\n      if(mv[a]) continue;\n      ans++;\n      for(i=0;i<4;i++){\n\trotatez(a);\n\tfor(j=0;j<4;j++){\n\t  rotatey(a);\n\t  for(k=0;k<4;k++){\n\t    rotatex(a);\n\t    mv[a]=1;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nstruct octa {\n\tint v[8];\n\tbool operator<(const octa &a) const {\n\t\trep(i, 7) {\n\t\t\tif (a.v[i] != v[i])return a.v[i] > v[i];\n\t\t}\n\t\treturn a.v[7] > v[7];\n\t}\n};\nocta turnright(octa x) {\n\tocta res;\n\trep(i, 4) {\n\t\tres.v[i] = x.v[(i + 1) % 4];\n\t\tres.v[i + 4] = x.v[(i + 1) % 4 + 4];\n\t}\n\treturn res;\n}\nocta rev(octa x) {\n\tocta res;\n\tres.v[0] = x.v[4];\n\tres.v[1] = x.v[7];\n\tres.v[2] = x.v[6];\n\tres.v[3] = x.v[5];\n\tres.v[4] = x.v[0];\n\tres.v[5] = x.v[3];\n\tres.v[6] = x.v[2];\n\tres.v[7] = x.v[1];\n\treturn res;\n}\nocta turn2(octa x) {\n\tocta res;\n\tres.v[0] = x.v[0];\n\tres.v[1] = x.v[4];\n\tres.v[3] = x.v[1];\n\tres.v[4] = x.v[3];\n\tres.v[2] = x.v[5];\n\tres.v[5] = x.v[7];\n\tres.v[7] = x.v[2];\n\tres.v[6] = x.v[6];\n\treturn res;\n} \nint main() {\n\tstring s;\n\twhile (cin>>s) {\n\t\tmap<octa, bool> mp;\n\t\tmap<string, int> memo;\n\t\tint b[8];\n\t\tint id = 1;\n\t\tmemo[s] = id;\n\t\tb[0] = id;\n\t\trep1(i, 7) {\n\t\t\tcin >> s;\n\t\t\tif (!memo[s]) {\n\t\t\t\tid++;\n\t\t\t\tmemo[s] = id;\n\t\t\t\tb[i] = id;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb[i] = memo[s];\n\t\t\t}\n\t\t}\n\t\tsort(b, b + 8);\n\t\tint out = 0;\n\t\twhile (true) {\n\t\t\tocta y;\n\t\t\tocta y1, y2;\n\t\t\trep(i, 8) {\n\t\t\t\ty.v[i] = b[i];\n\t\t\t}\n\t\t\tif(!mp[y]) {\n\t\t\t\tout++;\n\t\t\t\ty1 = turn2(y);\n\t\t\t\ty2 = turn2(y1);\n\t\t\t\tmp[y] = mp[y1] = mp[y2] = true;\n\t\t\t\trep(i, 3) {\n\t\t\t\t\ty = turnright(y);\n\t\t\t\t\ty1 = turn2(y);\n\t\t\t\t\ty2 = turn2(y1);\n\t\t\t\t\tmp[y] = mp[y1] = mp[y2] = true;\n\t\t\t\t}\n\t\t\t\ty = rev(y);\n\t\t\t\ty1 = turn2(y);\n\t\t\t\ty2 = turn2(y1);\n\t\t\t\tmp[y] = mp[y1] = mp[y2] = true;\n\t\t\t\trep(i, 3) {\n\t\t\t\t\ty = turnright(y);\n\t\t\t\t\ty1 = turn2(y);\n\t\t\t\t\ty2 = turn2(y1);\n\t\t\t\t\tmp[y] = mp[y1] = mp[y2] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!next_permutation(b, b + 8))break;\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n\nbool hs[1<<24];\n\nint calchs(int c[8])\n{\n\tint ret=0;\n\tfor(int i=0; i<8; i++)\n\t\tret|=c[i]<<(3*i);\n\n\treturn ret;\n}\n\nclass Octahedra\n{\npublic:\n\tint f[8];\n\n\tvoid all_rotate()\n\t{\n\t\tfor(int i=0; i<8; i++)\n\t\t{\n\t\t\tx_rot();\n\t\t\tfor(int j=0; j<8; j++)\n\t\t\t{\n\t\t\t\ty_rot();\n\t\t\t\tfor(int k=0; k<8; k++)\n\t\t\t\t{\n\t\t\t\t\tz_rot();\n\t\t\t\t\ths[calchs(f)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid x_rot()\n\t{\n\t\tint t1=f[0], t2=f[4];\n\t\tf[0]=f[1];\n\t\tf[1]=f[2];\n\t\tf[2]=f[3];\n\t\tf[3]=t1;\n\n\t\tf[4]=f[5];\n\t\tf[5]=f[6];\n\t\tf[6]=f[7];\n\t\tf[7]=t2;\n\t\t\n\t}\n\n\tvoid y_rot()\n\t{\n\t\tint t0=f[0], t1=f[1], t2=f[2], t3=f[3];\n\t\tf[0]=f[4];\n\t\tf[1]=f[5];\n\t\tf[2]=t0;\n\t\tf[3]=t1;\n\t\tf[4]=f[6];\n\t\tf[5]=f[7];\n\t\tf[6]=t2;\n\t\tf[7]=t3;\n\t}\n\n\tvoid z_rot()\n\t{\n\t\tint t0=f[0],t1=f[1], t2=f[2], t6=f[6];\n\t\tf[0]=f[4];\n\t\tf[1]=t0;\n\t\tf[2]=f[3];\n\t\tf[3]=f[7];\n\t\tf[4]=f[5];\n\t\tf[5]=t1;\n\t\tf[6]=t2;\n\t\tf[7]=t6;\n\t}\n\n\tOctahedra(int face[8])\n\t{\n\t\tfor(int i=0; i<8; i++)\n\t\t\tf[i]=face[i];\n\t}\n};\n\nint main()\n{\n\tint c[8];\n\tstring s;\n\twhile(1)\n\t{\n\t\tmemset(hs, 0, sizeof(hs));\n\t\tint cnt=0;\n\t\tmap<string, int> d;\n\n\t\tfor(int i=0; i<8; i++)\n\t\t{\n\t\t\tif(!(cin >> s)) return 0;\n\t\t\t\n\t\t\tint color;\t\t\t\n\t\t\tif(d.count(s) == 0)\n\t\t\t{\n\t\t\t\tcolor=cnt;\n\t\t\t\td.insert(make_pair(s,cnt));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor=d.find(s)->second;\n\t\t\t}\n\n\t\t\tc[i]=color;\n\t\t}\n\t\n\n\t\tint ans=0;\n\t\tsort(c, c+8);\n\t\twhile(1)\n\t\t{\n\t\t\tOctahedra o(c);\n\t\t\t\n\t\t\tif(!hs[calchs(c)])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\to.all_rotate();\n\t\t\t}\n\n\t\t\tif(!next_permutation(c, c+8)) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 1;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 5 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 6 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tif(y.size() == 1){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t} else if(y.size() == 2){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t} else{\n\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tf[0] = 1;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()*2)); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 0; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 0; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nstring color[8];\nmap<string,int> used;\nset<int> S;\nint t;\n\nvoid rot1(){\n  rep(i,3)swap(color[i],color[i+1]);\n  rep(i,3)swap(color[i+4],color[i+5]);\n}\n\nvoid rot2(){\n  swap(color[0],color[4]);  swap(color[1],color[5]);\n  swap(color[4],color[7]);  swap(color[5],color[6]);\n  swap(color[7],color[1]);  swap(color[6],color[2]);\n}\n\nbool check(){\n  int s=0;\n  rep(i,8)s=s*10+used[color[i]];\n  t=s;\n  return S.count(t)!=0;\n}\n\nvoid solve(){\n  S.clear();\n  int num[8];\n  string cp[8];\n  rep(i,8)num[i]=i,cp[i]=color[i];\n  do{\n    rep(i,8)color[i]=cp[num[i]];\n    bool f=false;\n    rep(i,4){ rot1();\n      rep(j,4){ rot2();\n\trep(k,4){ rot1();\n\t  if(check())f=true;\n\t}\n      }\n    }\n    if(!f)S.insert(t);\n  }while(next_permutation(num,num+8));\n  cout<<S.size()<<endl;\n}\n\nint main(){\n  while(cin>>color[7]){\n    rep(i,7)cin>>color[i];\n    used.clear();\n    int Num=0;\n    rep(i,8)\n      if(!used.count(color[i]))\n\tused[color[i]]=Num++;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int vx[] = {3, 2, 6, 7, 0, 1, 5, 4};\nconst int vy[] = {4, 0, 3, 7, 5, 1, 2, 6};\nconst int vz[] = {1, 2, 3, 0, 5, 6, 7, 4};\n\nvector< string > rollX(vector< string >& t)\n{\n  vector< string > u(8);\n  for(int i = 0; i < 8; i++) u[i] = t[vx[i]];\n  return(u);\n}\nvector< string > rollY(vector< string >& t)\n{\n  vector< string > u(8);\n  for(int i = 0; i < 8; i++) u[i] = t[vy[i]];\n  return(u);\n}\nvector< string > rollZ(vector< string >& t)\n{\n  vector< string > u(8);\n  for(int i = 0; i < 8; i++) u[i] = t[vz[i]];\n  return(u);\n}\n\nint main()\n{\n  string s[8];\n  while(cin >> s[0]) {\n    for(int i = 1; i < 8; i++) cin >> s[i];\n    sort(s, s + 8);\n    set< vector< string > > ss;\n    int ret = 0;\n    do {\n      vector< string > buff(s, s + 8);\n      if(ss.find(buff) == ss.end()) {\n        ++ret;\n        for(int i = 0; i < 4; i++) {\n          for(int j = 0; j < 4; j++) {\n            for(int k = 0; k < 4; k++) {\n              ss.insert(buff);\n              buff = rollX(buff);\n            }\n            buff = rollY(buff);\n          }\n          buff = rollZ(buff);\n        }\n      }\n    } while(next_permutation(s, s + 8));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint table_4[24][4],index_8,leftTable[24],rightTable[24],m_data[8] = {0,1,2,3,4,5,6,7};\nint* table_8;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid calc8(){\n\n\tint select_num = 4,num,loc_left[4],loc_right[4],left_index,right_index,index,calc[4],value;\n\n\tindex_8 = 0;\n\n\tfor(int i = 0; i < 256;i++){\n\t\tnum = 0;\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tif(i & (1 << k))num++;\n\t\t}\n\t\tif(num != select_num)continue;\n\n\t\tleft_index = right_index = 0;\n\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tif(i & (1 << k)){\n\t\t\t\tloc_left[left_index++] = k;\n\t\t\t}else{\n\t\t\t\tloc_right[right_index++] = k;\n\t\t\t}\n\t\t}\n\n\t\tleft_index = right_index = 0;\n\n\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\n\t\tfor(index = 0;index < 24; index++){\n\t\t\tvalue = 0;\n\t\t\tfor(int p = 0; p < 4;p++){\n\t\t\t\tvalue = 10*value + calc[table_4[index][p]];\n\t\t\t}\n\t\t\tleftTable[left_index++] = value;\n\t\t}\n\n\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\n\t\tfor(index = 0;index < 24; index++){\n\t\t\tvalue = 0;\n\t\t\tfor(int p = 0; p < 4;p++){\n\t\t\t\tvalue = 10*value + calc[table_4[index][p]];\n\t\t\t}\n\t\t\trightTable[right_index++] = value;\n\t\t}\n\n\t\tfor(int k = 0; k < 24; k++){\n\t\t\tfor(int p = 0; p < 24; p++){\n\t\t\t\ttable_8[index_8++] = 10000*leftTable[k] + rightTable[p];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\ttable_8 = new int[40320];\n\n\tint index_4 = 0;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcalc8();\n\n\tint DIV = 10,line;\n\n\tint **calc_table = new int*[40320];\n\tfor(int i = 0; i < 40320; i++){\n\t\tcalc_table[i] = new int[8];\n\t\tline = table_8[i];\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tcalc_table[i][7-k] = line%DIV;\n\t\t\tline /= DIV;\n\t\t}\n\t}\n\n\tchar colors[8][21],buf[21],all_color[200],work[8][21],tmp_work[8][21];\n\tint array[24][8] = {{0,1,2,3,4,5,6,7},\n\t\t\t\t\t\t{7,6,5,4,3,2,1,0},\n\t\t\t\t\t\t{3,0,1,2,7,4,5,6},\n\t\t\t\t\t\t{6,5,4,7,2,1,0,3},\n\t\t\t\t\t\t{2,3,0,1,6,7,4,5},\n\t\t\t\t\t\t{5,4,7,6,1,0,3,2},\n\t\t\t\t\t\t{1,2,3,0,5,6,7,4},\n\t\t\t\t\t\t{4,7,6,5,0,3,2,1},\n\n\t\t\t\t\t\t{7,3,2,6,4,0,1,5},\n\t\t\t\t\t\t{5,1,0,4,6,2,3,7},\n\t\t\t\t\t\t{6,7,3,2,5,4,0,1},\n\t\t\t\t\t\t{1,0,4,5,2,3,7,6},\n\t\t\t\t\t\t{2,6,7,3,1,5,4,0},\n\t\t\t\t\t\t{0,4,5,1,3,7,6,2},\n\t\t\t\t\t\t{3,2,6,7,0,1,5,4},\n\t\t\t\t\t\t{4,5,1,0,7,6,2,3},\n\n\n\t\t\t\t\t\t{7,4,0,3,6,5,1,2},\n\t\t\t\t\t\t{2,1,5,6,3,0,4,7},\n\t\t\t\t\t\t{3,7,4,0,2,6,5,1},\n\t\t\t\t\t\t{1,5,6,2,0,4,7,3},\n\t\t\t\t\t\t{0,3,7,4,1,2,6,5},\n\t\t\t\t\t\t{5,6,2,1,4,7,3,0},\n\t\t\t\t\t\t{4,0,3,7,5,1,2,6},\n\t\t\t\t\t\t{6,2,1,5,7,3,0,4}\n\t\t\t\t\t\t};\n\n\tset<string> S;\n\n\tbool FLG;\n\n\tint index,ans;\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tstrcpy(colors[0],buf);\n\t\tfor(int i = 1; i <= 7; i++){\n\t\t\tscanf(\"%s\",colors[i]);\n\t\t}\n\n\t\tS.clear();\n\n\t\tindex = 0;\n\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int k = 0; colors[i][k] != '\\0'; k++){\n\t\t\t\tall_color[index++] = colors[i][k];\n\t\t\t}\n\t\t}\n\t\tall_color[index] = '\\0';\n\n\t\tS.insert(string(all_color));\n\n\t\tans = 1;\n\n\t\tfor(int i = 0; i < 40320; i++){\n\n\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\tstrcpy(work[k],colors[calc_table[i][k]]);\n\t\t\t}\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int a = 0;a < 24; a++){\n\t\t\t\tfor(int b = 0; b < 8; b++){\n\t\t\t\t\tstrcpy(tmp_work[b],work[array[a][b]]);\n\t\t\t\t}\n\t\t\t\tindex = 0;\n\t\t\t\tfor(int b = 0; b < 8; b++){\n\t\t\t\t\tfor(int c = 0; tmp_work[b][c] != '\\0'; c++){\n\t\t\t\t\t\tall_color[index++] = tmp_work[b][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tall_color[index] = '\\0';\n\n\t\t\t\tif(S.count(string(all_color)) != 0){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\tS.insert(string(all_color));\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n\nbool hs[1<<24];\n\nint calchs(int c[8])\n{\n\tint ret=0;\n\tfor(int i=0; i<8; i++)\n\t\tret|=c[i]<<(3*i);\n\n\treturn ret;\n}\n\nclass Octahedra\n{\npublic:\n\tint f[8];\n\n\tvoid all_rotate()\n\t{\nhs[calchs(f)]=1;\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tx_rot();\n\t\t\tfor(int j=0; j<4; j++)\n\t\t\t{\n\t\t\t\ty_rot();\n\t\t\t\tfor(int k=0; k<4; k++)\n\t\t\t\t{\n\t\t\t\t\tz_rot();\n\t\t\t\t\ths[calchs(f)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid x_rot()\n\t{\n\t\tint t1=f[0], t2=f[4];\n\t\tf[0]=f[1];\n\t\tf[1]=f[2];\n\t\tf[2]=f[3];\n\t\tf[3]=t1;\n\n\t\tf[4]=f[5];\n\t\tf[5]=f[6];\n\t\tf[6]=f[7];\n\t\tf[7]=t2;\n\t\t\n\t}\n\n\tvoid y_rot()\n\t{\n\t\tint t0=f[0], t1=f[1], t2=f[2], t3=f[3];\n\t\tf[0]=f[4];\n\t\tf[1]=f[5];\n\t\tf[2]=t0;\n\t\tf[3]=t1;\n\t\tf[4]=f[6];\n\t\tf[5]=f[7];\n\t\tf[6]=t2;\n\t\tf[7]=t3;\n\t}\n\n\tvoid z_rot()\n\t{\n\t\tint t0=f[0],t1=f[1], t2=f[2], t6=f[6];\n\t\tf[0]=f[4];\n\t\tf[1]=t0;\n\t\tf[2]=f[3];\n\t\tf[3]=f[7];\n\t\tf[4]=f[5];\n\t\tf[5]=t1;\n\t\tf[6]=t2;\n\t\tf[7]=t6;\n\t}\n\n\tOctahedra(int face[8])\n\t{\n\t\tfor(int i=0; i<8; i++)\n\t\t\tf[i]=face[i];\n\t}\n};\n\nint main()\n{\n\tint c[8];\n\tstring s;\n\twhile(1)\n\t{\n\t\tmemset(hs, 0, sizeof(hs));\n\t\tint cnt=0;\n\t\tmap<string, int> d;\n\n\t\tfor(int i=0; i<8; i++)\n\t\t{\n\t\t\tif(!(cin >> s)) return 0;\n\t\t\t\n\t\t\tint color;\t\t\t\n\t\t\tif(d.count(s) == 0)\n\t\t\t{\n\t\t\t\tcolor=cnt;\n\t\t\t\td.insert(make_pair(s,cnt));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor=d.find(s)->second;\n\t\t\t}\n\n\t\t\tc[i]=color;\n\t\t}\n\t\n\n\t\tint ans=0;\n\t\tsort(c, c+8);\n\t\twhile(1)\n\t\t{\n\t\t\tOctahedra o(c);\n\t\t\t\n\t\t\tif(!hs[calchs(c)])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\to.all_rotate();\n\t\t\t}\n\n\t\t\tif(!next_permutation(c, c+8)) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\nconst int l[] = {4,0,3,7,5,1,2,6}, r[] = {3,2,6,7,0,1,5,4};\n\nvoid rotate(set<string> &T, string S){\n  string S_ = S;\n  for(int i = 0; i < 4; ++i){\n    for(int j = 0; j < 4; ++j){\n      for(int k = 0; k < 4; ++k){\n        T.insert(S);\n        S_ = S;\n        for(int l = 0; l < 4; ++l){\n          S[l] = S_[(l+1)%4];\n          S[l+4] = S_[(l+1)%4+4];\n        }\n      }\n      S_ = S;\n      for(int k = 0; k < 8; ++k) S[k] = S_[r[k]];\n    }\n    S_ = S;\n    for(int k = 0; k < 8; ++k) S[k] = S_[l[k]];\n  }\n}\n\nint main(){\n  string s;\n  while(cin >> s){\n    map<string,int> M;\n    ++M[s];\n    for(int i = 1; i < 8; ++i){\n      cin >> s;\n      ++M[s];\n    }\n    vector<int> V;\n    for(auto itr = M.begin(); itr != M.end(); ++itr)\n      V.push_back(itr->second);\n    string S;\n    for(int i = 0; i < (int)V.size(); ++i)\n      for(int j = 0; j < V[i]; ++j)\n        S += '0' + i;\n    sort(S.begin(), S.end());\n    set<string> T;\n    int ans = 0;\n    do{\n      if(T.count(S)) continue;\n      ++ans;\n      rotate(T,S);\n    }while(next_permutation(S.begin(), S.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\nint main() {\n\tstring st;\n\twhile (getline(cin, st)) {\n\t\tint from = 0;\n\t\tvector<string>names;\n\t\tfor (int i = 0; i < st.size(); ++i) {\n\t\t\tif (st[i] == ' ') {\n\t\t\t\tnames.push_back(st.substr(from, i - from));\n\t\t\t\tfrom = i + 1;\n\t\t\t}\n\t\t}\n\t\tnames.push_back(st.substr(from,st.size() - from));\n\t\tmap<string, int>namemp;\n\t\tvector<int>ids;\n\t\tint now = 0;\n\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\tif (namemp.count(names[i])) {\n\t\t\t\tids.push_back(namemp[names[i]]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnamemp[names[i]] = now;\n\t\t\t\tids.push_back(now);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tset<vector<int>>octamp;\n\t\tvector<int>perm(8);\n\t\tiota(perm.begin(), perm.end(), 0);\n\t\tdo {\n\t\t\tvector<int>colors;\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tcolors.push_back(ids[perm[i]]);\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tfor (int l = 0; l < 3; ++l) {\n\t\t\t\tint atem = colors[1];\n\t\t\t\tcolors[1] = colors[3];\n\t\t\t\tcolors[3] = colors[4];\n\t\t\t\tcolors[4] = atem;\n\t\t\t\tatem = colors[2];\n\t\t\t\tcolors[2] = colors[7];\n\t\t\t\tcolors[7] = colors[5];\n\t\t\t\tcolors[5] = atem;\n\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint tem = colors[0];\n\t\t\t\t\tcolors[0] = colors[1];\n\t\t\t\t\tcolors[1] = colors[2];\n\t\t\t\t\tcolors[2] = colors[3];\n\t\t\t\t\tcolors[3] = tem;\n\t\t\t\t\ttem = colors[4];\n\t\t\t\t\tcolors[4] = colors[5];\n\t\t\t\t\tcolors[5] = colors[6];\n\t\t\t\t\tcolors[6] = colors[7];\n\t\t\t\t\tcolors[7] = tem;\n\t\t\t\t\tif (octamp.count(colors))ok = false;\n\t\t\t\t}\n\t\t\t\tswap(colors[0], colors[6]);\n\t\t\t\tswap(colors[1], colors[5]);\n\t\t\t\tswap(colors[2], colors[4]);\n\t\t\t\tswap(colors[3], colors[7]);\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint tem = colors[0];\n\t\t\t\t\tcolors[0] = colors[1];\n\t\t\t\t\tcolors[1] = colors[2];\n\t\t\t\t\tcolors[2] = colors[3];\n\t\t\t\t\tcolors[3] = tem;\n\t\t\t\t\ttem = colors[4];\n\t\t\t\t\tcolors[4] = colors[5];\n\t\t\t\t\tcolors[5] = colors[6];\n\t\t\t\t\tcolors[6] = colors[7];\n\t\t\t\t\tcolors[7] = tem;\n\t\t\t\t\tif (octamp.count(colors))ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans++;\n\t\t\t\tfor (int l = 0; l < 3; ++l) {\n\t\t\t\t\tint atem = colors[1];\n\t\t\t\t\tcolors[1] = colors[3];\n\t\t\t\t\tcolors[3] = colors[4];\n\t\t\t\t\tcolors[4] = atem;\n\t\t\t\t\tatem = colors[2];\n\t\t\t\t\tcolors[2] = colors[7];\n\t\t\t\t\tcolors[7] = colors[5];\n\t\t\t\t\tcolors[5] = atem;\n\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tint tem = colors[0];\n\t\t\t\t\t\tcolors[0] = colors[1];\n\t\t\t\t\t\tcolors[1] = colors[2];\n\t\t\t\t\t\tcolors[2] = colors[3];\n\t\t\t\t\t\tcolors[3] = tem;\n\t\t\t\t\t\ttem = colors[4];\n\t\t\t\t\t\tcolors[4] = colors[5];\n\t\t\t\t\t\tcolors[5] = colors[6];\n\t\t\t\t\t\tcolors[6] = colors[7];\n\t\t\t\t\t\tcolors[7] = tem;\n\t\t\t\t\t\toctamp.emplace(colors);\n\t\t\t\t\t}\n\t\t\t\t\tswap(colors[0], colors[6]);\n\t\t\t\t\tswap(colors[1], colors[5]);\n\t\t\t\t\tswap(colors[2], colors[4]);\n\t\t\t\t\tswap(colors[3], colors[7]);\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tint tem = colors[0];\n\t\t\t\t\t\tcolors[0] = colors[1];\n\t\t\t\t\t\tcolors[1] = colors[2];\n\t\t\t\t\t\tcolors[2] = colors[3];\n\t\t\t\t\t\tcolors[3] = tem;\n\t\t\t\t\t\ttem = colors[4];\n\t\t\t\t\t\tcolors[4] = colors[5];\n\t\t\t\t\t\tcolors[5] = colors[6];\n\t\t\t\t\t\tcolors[6] = colors[7];\n\t\t\t\t\t\tcolors[7] = tem;\n\t\t\t\t\t\toctamp.emplace(colors);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t} while (next_permutation(perm.begin(), perm.end()));\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint ans;\nvector<string>a(8);\nset<vector<string> >s;\nvoid ch(){\n  if(s.count(a))return;\n  r(i,2){\n    swap(a[0],a[6]);\n    swap(a[1],a[5]);\n    swap(a[2],a[4]);\n    swap(a[3],a[7]);\n    r(j,4){\n      swap(a[0],a[1]);\n      swap(a[1],a[2]);\n      swap(a[2],a[3]);\n      swap(a[4],a[5]);\n      swap(a[5],a[6]);\n      swap(a[6],a[7]);\n      r(k,3){\n        swap(a[0],a[7]);\n        swap(a[2],a[7]);\n        swap(a[4],a[6]);\n        swap(a[6],a[1]);\n        s.insert(a);\n      }\n    }\n  }\n  ans++;\n}\nmain(){\n  while(cin>>a[0]){\n    ans=0;int p=0;\n    s.clear();\n    r(i,7)cin>>a[i+1];\n    sort(a.begin(),a.end());\n    do{\n      ch();\n    }while(next_permutation(a.begin(),a.end()));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 1;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 5 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 6 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tif(f[i] == 0) continue;\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<14); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < 8; k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < 8; k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < 8; k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tfor(int j = 0; j < (1<<14); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < 8; k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < 8; k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < 8; k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tif(y.size() == 1){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t} else if(y.size() == 2){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t} else{\n\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tf[0] = 1;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tif(f[i] == 0) continue;\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<16); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 0; k < 8; k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 0; k < 8; k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvector<string> colors(8);\nvector<string> panels(8);\nset<vector<string>> ex;\nint ans = 0;\nvector<string> roll(vector<string> vs,int pos,int z){\n\tvector<string> res(8);\n\tif (pos < 4) {\n\t\tREP(i, 4) {\n\t\t\tres[i] = vs[(i + pos)%4];\n\t\t\tres[4+i]= vs[4+(i + pos) % 4];\n\t\t}\n\t\tvector<string> res2=res;\n\t\tif (z == 1) {\n\t\t\tres[1] = res2[3];\n\t\t\tres[3] = res2[4];\n\t\t\tres[4] = res2[1];\n\t\t\tres[5] = res2[2];\n\t\t\tres[2] = res2[7];\n\t\t\tres[7] = res2[5];\n\t\t}\n\t\tif (z == 2) {\n\t\t\tres[1] = res2[4];\n\t\t\tres[3] = res2[1];\n\t\t\tres[4] = res2[3];\n\t\t\tres[5] = res2[7];\n\t\t\tres[2] = res2[5];\n\t\t\tres[7] = res2[2];\n\t\t}\n\t}\n\telse {\n\t\t\tREP(i, 4) {\n\t\t\t\tres[i] = vs[4+(i + pos) % 4];\n\t\t\t\tres[4 + i] = vs[(i + pos) % 4];\n\t\t\t\t\n\t\t\t}\n\t\t\tvector<string> res2 = res;\n\t\t\tif (z == 1) {\n\t\t\t\tres[1] = res2[3];\n\t\t\t\tres[3] = res2[4];\n\t\t\t\tres[4] = res2[1];\n\t\t\t\tres[5] = res2[2];\n\t\t\t\tres[2] = res2[7];\n\t\t\t\tres[7] = res2[5];\n\t\t\t}\n\t\t\tif (z == 2) {\n\t\t\t\tres[1] = res2[4];\n\t\t\t\tres[3] = res2[1];\n\t\t\t\tres[4] = res2[3];\n\t\t\t\tres[5] = res2[7];\n\t\t\t\tres[2] = res2[5];\n\t\t\t\tres[7] = res2[2];\n\t\t\t}\n\t}\n\treturn res;\n}\nvoid dfs(int idx) {\n\tif (idx == 8) {\n\t\tif (ex.find(panels)==ex.end()){\n\t\t\tans++;\n\t\t\tREP(i,8)\n\t\t\t\tREP(j, 3) {\n\t\t\t\tex.insert(roll(panels,i,j));\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tREP(i,8){\n\t\tif (panels[i] == \"\") {\n\t\t\tpanels[i] = colors[idx];\n\t\t\tdfs(idx + 1);\n\t\t\tpanels[i] = \"\";\n\t\t}\n\t}\n}\nint main() {\n\t\n\twhile (cin>>colors[0],cin) {\n\t\tFOR(i, 1, 8) {\n\t\t\tcin >> colors[i];\n\t\t}\n\t\tpanels.clear();\n\t\tpanels.resize(8,\"\");\n\t\tex.clear();\n\t\tans = 0;\n\t\tdfs(0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nclass data{\npublic:\n\tstring str[8];\n\tdata(){}\n};\n\nbool operator<(const data &d1,const data &d2){\n\tfor(int i=0;i<8;i++){\n\t\tif(d1.str[i]!=d2.str[i])return d1.str[i]<d2.str[i];\n\t}\n\treturn d1.str[7]<d2.str[7];\n}\n\nstring str[8];\nset<data> dat;\nint id[8];\nbool used[8];\nint next[16][8]={\n\t{0,1,2,3,4,5,6,7},\n\t{3,0,1,2,7,4,5,6},\n\t{2,3,0,1,6,7,4,5},\n\t{1,2,3,0,5,6,7,4},\n\n\t{4,7,6,5,0,3,2,1},\n\t{5,4,7,6,1,0,3,2},\n\t{6,5,4,7,2,1,0,3},\n\t{7,6,5,4,3,2,1,0},\n\n\t{4,5,1,0,7,6,2,3},\n\t{0,4,5,1,3,7,6,2},\n\t{1,0,4,5,2,3,7,6},\n\t{5,1,0,4,6,2,3,7},\n\n\t{3,2,6,7,0,1,4,5},\n\t{7,3,2,6,5,0,1,4},\n\t{6,7,3,2,4,5,0,1},\n\t{2,6,7,3,1,4,5,0},\n};\nvoid dfs(int v){\n\tif(v==8){\n\t\tbool ok=true;\n\t\tfor(int i=0;i<16;i++){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tdl.str[j]=str[id[next[i][j]]];\n\t\t\t}\n\t\t\tif(dat.find(dl)!=dat.end()){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tdl.str[j]=str[id[j]];\n\t\t\t}\n\t\t\tdat.insert(dl);\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tid[v]=i;\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin>>str[0]){\n\t\tll res=0,res2=0;\n\t\tfor(int i=1;i<8;i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tdat.clear();\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",dat.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring name[8];\nint color[8];\nint perm[8];\nbool used[1 << 24];\nint mat[3][8][8];\nint octa[8];\n\nvoid make_mat()\n{\n\tconst int swap[3][8] = {\n\t\t{1, 2, 3, 0, 5, 6, 7, 4},\n\t\t{1, 5, 6, 2, 0, 4, 7, 3},\n\t\t{3, 2, 6, 7, 0, 1, 5, 4}\n\t};\n\t\n\tfor(int m = 0; m < 3; m++){\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tif(swap[m][i] == j) mat[m][i][j] = 1;\n\t\t\t\telse mat[m][i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint encode(int a[8])\n{\n\tint ret = 0;\n\tfor(int i = 0; i < 8; i++){\n\t\tret <<= 3;\n\t\tret += a[i];\n\t}\n\treturn ret;\n}\n\nvoid mul(int mat[8][8], int vec[8])\n{\n\tint tmp[8];\n\tint sum;\n\t\n\tfor(int i = 0; i < 8; i++){\n\t\tsum = 0;\n\t\tfor(int k = 0; k < 8; k++) sum += mat[i][k] * vec[k];\n\t\ttmp[i] = sum;\n\t}\n\tfor(int i = 0; i < 8; i++) vec[i] = tmp[i];\n}\n\nint main(void)\n{\n\tmake_mat();\n\t\n\tfor(int i = 0; i < 8; i++) octa[i] = i;\n\t\n\twhile(cin >> name[0]){\n\t\t\n\t\tint c = 1;\n\t\tstring *p;\n\t\t\n\t\tcolor[0] = 0;\n\t\tfor(int i = 1; i < 8; i++){\n\t\t\tcin >> name[c];\n\t\t\tp = find(name, name+c, name[c]);\n\t\t\tif(p == name+i) c++;\n\t\t\tcolor[i] = p - name;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1 << 24); i++) used[i] = false;\n\t\t\n\t\tbool flag;\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 8; i++) perm[i] = i;\n\t\tdo{\n\t\t\tfor(int i = 0; i < 8; i++) octa[i] = color[perm[i]];\n\t\t\t\n\t\t\tflag = false;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tmul(mat[0], octa);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tmul(mat[1], octa);\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tmul(mat[2], octa);\n\t\t\t\t\t\tif(used[encode(octa)]){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tend:;\n\t\t\tif(!flag){\n\t\t\t\tused[encode(octa)] = true;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\t\n\t\t}while(next_permutation(perm, perm+8));\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint y[8][4]={\n\t{0,1,2,3},\n\t{1,0,5,4},\n\t{2,0,4,6},\n\t{3,0,6,5},\n\t{4,7,2,1},\n\t{5,7,1,3},\n\t{6,7,3,2},\n\t{7,4,5,6}\n};\nset<int> st;\nint main(){\n\tstring s[8];\n\twhile(cin>>s[0]>>s[1]>>s[2]>>s[3]>>s[4]>>s[5]>>s[6]>>s[7]){\n\t\tst.clear();\n\t\tvector<string> ash;\n\t\trep(i,8) ash.pb(s[i]);\n\t\tsort(all(ash));\n\t\tash.erase(unique(all(ash)),ash.end());\n\t\tint x[8];\n\t\trep(i,8) x[i]=lower_bound(all(ash),s[i])-ash.begin();\n\t\tsort(x,x+8);\n\t\tdo{\n\t\t\tint mn=1e9;\n\t\t\trep(i,8){\n\t\t\t\trep(j,3){\n\t\t\t\t\tint z[8];\n\t\t\t\t\tz[0]=x[y[i][0]];\n\t\t\t\t\tz[1]=x[y[i][(j)%3+1]];\n\t\t\t\t\tz[2]=x[y[i][(j+1)%3+1]];\n\t\t\t\t\tz[3]=x[y[i][(j+2)%3+1]];\n\t\t\t\t\tz[4]=x[7-y[i][(j+2)%3+1]];\n\t\t\t\t\tz[5]=x[7-y[i][(j+1)%3+1]];\n\t\t\t\t\tz[6]=x[7-y[i][(j)%3+1]];\n\t\t\t\t\tz[7]=x[7-y[i][0]];\n\t\t\t\t\tint sum=0;\n\t\t\t\t\trep(k,8) sum+=(z[k]<<(3*k));\n\t\t\t\t\tmn=min(mn,sum);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.insert(mn);\n\t\t}while(next_permutation(x,x+8));\n\t\tcout<<st.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<unordered_map>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<queue>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\nvoid roll_x(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {7,0,3,4,5,2,1,6};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nvoid roll_y(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {7,6,1,0,3,2,5,4};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nvoid roll_z(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {3,0,1,2,5,6,7,4};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nint normalize(vector<int> color) {\n  int mini = INT_MAX;\n  vector<int> tmp = color;\n  rep(_,4) {\n    rep(__,4) {\n      rep(___,4) {\n\tint v = 0;\n\trep(i,8) { assert(color[i]); v *= 10; v += color[i]; }\n\tmini = min(mini,v);\n\troll_x(color);\n      }\n      roll_y(color);\n    }\n    roll_z(color);\n  }\n  assert( tmp == color );\n  return mini;\n}\n\nvoid compute(vector<int> &color) {\n  sort(all(color));\n  set<int> S;\n  do {\n    S.insert(normalize(color));\n  } while( next_permutation(all(color)) );\n  cout << (int)S.size() << endl;\n}\n\nint main() {\n  string s;\n  while( cin >> s ) {\n    map<string,int> toInt;\n    vector<int> color;\n    {\n      int id = 1;\n      toInt[s] = id++;\n      color.push_back(toInt[s]);\n      rep(i,7) {\n\tcin >> s;\n\tif( toInt.count(s) == 0 ) toInt[s] = id++;\n\tcolor.push_back(toInt[s]);\n      }\n    }\n    compute(color);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nmap<string,bool> M;\nmap<string,bool>::iterator Mp;\n\nvector<int> color;\nstring S;\nbool cb[8];\n\nvoid Check(string S)\n{\n\n  string C=S;\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  swap(C[0],C[4]);swap(C[1],C[5]);swap(C[2],C[6]);swap(C[3],C[7]);\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  swap(C[1],C[4]);swap(C[2],C[7]);\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  swap(C[0],C[4]);swap(C[1],C[5]);swap(C[2],C[6]);swap(C[3],C[7]);\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  swap(C[2],C[4]);swap(C[3],C[5]);\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  swap(C[0],C[4]);swap(C[1],C[5]);swap(C[2],C[6]);swap(C[3],C[7]);\n  for(int i=0;i<4;i++){\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n\n  M[S]=true;\n}\nvoid make(int i)\n{\n  S+=(color[i]+'0');\n  if(S.length()==8){\n    Check(S);\n  }\n  else {\n    for(int i=0;i<8;i++){\n      if(cb[i])continue;\n      cb[i]=true;\n      make(i);\n      cb[i]=false;\n    }\n  }\n  S.erase(S.begin()+S.length()-1);\n}\n\nint main()\n{\n  string s[8];\n  while(cin>>s[0]){\n    for(int i=0;i<7;i++)cin>>s[i+1];\n    int a=1;\n    map<string,int> m;\n    color.clear();\n    M.clear();\n    m.clear();\n    for(int i=0;i<8;i++){\n      if(m[s[i]]==0){\n\tcolor.push_back(a);\n\tm[s[i]]=a;\n\ta++;\n      }\n      else color.push_back(m[s[i]]);\n    }\n    for(int i=0;i<8;i++){\n      S=\"\";\n      cb[i]=true;\n      make(i);\n      cb[i]=false;\n    }\n    int ans=0;\n    for(Mp=M.begin();Mp!=M.end();Mp++)if(Mp->second)ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint color2num(map<string,int>& dictionary,const string& color){\n  if(dictionary.find(color) == dictionary.end()){\n    int idx = dictionary.size();\n    dictionary[color] = idx;\n  }\n  return dictionary[color];\n}\n\nclass Octahedra{\npublic:\n  int* upper_face;\n  int* lower_face;\n\n  Octahedra(){\n    upper_face = new int[4]();\n    lower_face = new int[4]();\n  }\n\n  void set_colors(const vector<int>& colors){\n    for(int i=0;i<4;i++){\n      upper_face[i] = colors[i];\n      lower_face[i] = colors[4+i];\n    }\n  }\n\n  int rotateZ(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      for(int i=0;i<4;i++){\n\ttmp_upper[(i+1)%4] = upper_face[i];\n\ttmp_lower[(i+1)%4] = lower_face[i];\n      }\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int rotateX(int turn){\n    for(int t = 0; t < turn; t++){\n      swap(upper_face[0],lower_face[2]);\n      swap(upper_face[1],lower_face[1]);\n      swap(upper_face[2],lower_face[0]);\n      swap(upper_face[3],lower_face[3]);\n    }\n  }\n  \n  int rotateY(int turn){\n    for(int t = 0; t < turn; t++){\n      swap(upper_face[0],lower_face[0]);\n      swap(upper_face[1],lower_face[3]);\n      swap(upper_face[2],lower_face[2]);\n      swap(upper_face[3],lower_face[1]);\n    }\n  }\n\n  int write(){\n    int res = 0;\n    int digit = 1;\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string color;\n\n  while(cin >> color){\n    vector<int> colors;\n    map<string,int> dictionary;\n    int color_num;\n    color_num = color2num(dictionary,color);\n    colors.push_back(color_num);\n    for(int i=1;i<8;i++){\n      cin >> color;\n\n      color_num = color2num(dictionary,color);\n      colors.push_back(color_num);\n    }\n\n    sort(colors.begin(),colors.end());\n\n    int res = 0;\n    set<int> visited;\n    do {\n      Octahedra oct;\n      int state;\n      bool isok = false;\n      for(int i=0;i<8;i++){\n\toct.set_colors(colors);\n\toct.rotateX(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateY(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateZ(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n      }\n\n      if(isok) res++;\n    }while(next_permutation(colors.begin(),colors.end()));\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<class T>\nclass ID{\n  map<T,int> _id;\npublic:\n  ID(){}\n  int operator()(const T &val){\n    if(_id.find(val) == _id.end()){\n      int next = _id.size();\n      return _id[val] = next;\n    }\n    return _id[val];\n  }\n};\n\nint main(){\n  string s;\n  while(cin >> s){\n    vector<int> v(8);\n    ID<string> id;\n    v[0] = id(s);\n    REP(i,7){\n      cin >> s;\n      v[i+1] = id(s);\n    }\n\n    set<string> ans;\n    sort(v.begin(), v.end());\n\n    do{\n      vector<string> tmp(24, \"        \");\n\n      REP(i,4){\n\tREP(j,4){\n\t  tmp[i][(i+j)%4]   = v[j] + '0';\n\t  tmp[i][(i+j)%4+4] = v[j+4] + '0';\n\n\t  tmp[i+4][(i+j)%4]   = v[j+4] + '0';\n\t  tmp[i+4][(i+j)%4+4] = v[j] + '0';\n\t}\n      }\n\n      REP(i,8){\n\ttmp[i+8][0] = tmp[i][0];\n\ttmp[i+8][1] = tmp[i][3];\n\ttmp[i+8][2] = tmp[i][7];\n\ttmp[i+8][3] = tmp[i][4];\n\ttmp[i+8][4] = tmp[i][1];\n\ttmp[i+8][5] = tmp[i][2];\n\ttmp[i+8][6] = tmp[i][6];\n\ttmp[i+8][7] = tmp[i][5];\n      }\n\n      REP(i,8){\n\ttmp[i+16][0] = tmp[i][0];\n\ttmp[i+16][1] = tmp[i][4];\n\ttmp[i+16][2] = tmp[i][5];\n\ttmp[i+16][3] = tmp[i][1];\n\ttmp[i+16][4] = tmp[i][3];\n\ttmp[i+16][5] = tmp[i][7];\n\ttmp[i+16][6] = tmp[i][6];\n\ttmp[i+16][7] = tmp[i][2];\n      }\n\n      sort(tmp.begin(), tmp.end());\n      ans.insert(tmp[0]);\n\n    }while(next_permutation(v.begin(), v.end()));\n\n    /*\n    for(set<string>::iterator it = ans.begin();\n\tit != ans.end(); ++it){\n      cout << *it << endl;\n    }\n    */\n\n    printf(\"%d\\n\", ans.size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nvoid rotate(vector<int>& v, int a, int b, int c, int d){\n  int t = v[a];\n  v[a] = v[b];\n  v[b] = v[c];\n  v[c] = v[d];\n  v[d] = t;\n}\nvoid rotate_x(vector<int>& v){\n  rotate(v, 1, 2, 6, 5);\n  rotate(v, 0, 3, 7, 4);\n}\nvoid rotate_y(vector<int>& v){\n  rotate(v, 0, 1, 5, 4);\n  rotate(v, 3, 2, 6, 7);\n}\nvoid rotate_z(vector<int>& v){\n  rotate(v, 0, 1, 2, 3);\n  rotate(v, 4, 5, 6, 7);\n}\nbool equal(const vector<int>& d, vector<int> e){\n  for(int i = 0; i < 6; i++){\n    if(i & 1) rotate_x(e);\n    else rotate_y(e);\n    for(int j = 0; j < 4; j++){\n      rotate_z(e);\n      if(d == e) return true;\n    }\n  }\n  return false;\n}\nvoid all_insert(set< vector<int> >& s, vector<int> e){\n  for(int i = 0; i < 6; i++){\n    if(i & 1) rotate_x(e);\n    else rotate_y(e);\n    for(int j = 0; j < 4; j++){\n      rotate_z(e);\n      s.insert(e);\n    }\n  }\n}\nint main(){\n  string line;\n  while(getline(cin, line)){\n    string s;\n    stringstream ss(line);\n    map<string, int> id;\n    vector<int> d(8);\n    REP(i, 8){\n      ss>>s;\n      if(id.count(s)){\n        d[i] = id[s];\n      }else{\n        int t = id.size();\n        d[i] = id[s] = t;\n      }\n    }\n    sort(d.begin(), d.end());\n    int ans = 0;\n    set< vector<int> > check;\n    do{\n      bool ok = true;\n      if(!check.count(d)){\n        ans++;\n        all_insert(check, d);\n      }\n    }while(next_permutation(d.begin(), d.end()));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<short> V;\nconst int UF=0,UL=1,UB=2,UR=3;\nconst int DF=4,DL=5,DB=6,DR=7;\nset<int> S;\nV A(8),num(8,-1);\n\nvoid SW(int a,int b){swap(num[a],num[b]);}\nvoid rot(){\n  SW(UF,UR),SW(UR,UB),SW(UB,UL);\n  SW(DF,DR),SW(DF,DB),SW(DF,DL);\n}\n\nvoid rot90(){\n  SW(DF,UF),SW(DF,UR),SW(DF,DR);\n  SW(DB,UB),SW(DB,DL),SW(DB,UL);\n}\nvoid rev(){SW(UF,DB),SW(DF,UB),SW(UR,DR),SW(UL,DL);}\n\nint VtoI(V&a=num){\n  int res=0;\n  for(int i=0;i<8;i++)res=res*10+num[i]+1;\n  return res;\n}\n\nvoid Insert(){\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  rot90();\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n\n}\n\nint check(){\n  if(S.count(VtoI()))return 0;\n  V tmp = num;\n  Insert();\n  num= tmp;\n  return 1;\n}\n\nint dfs(int dep){\n  if(dep==8) return check();\n  int res=0;\n  for(int i=0;i<8;i++){\n    if(num[i]!=-1)continue;\n    num[i] = A[dep];\n    res+=dfs(dep+1);\n    num[i] = -1;\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    map<string,int> M;\n    string str;\n    for(int i=0,cnt=0;i<8;i++){\n      if((cin>>str)==0)return 0;\n      if(M.count(str)) A[i] = M[str];\n      else A[i] = M[str] = cnt++;\n    }\n    S.clear();\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=200005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    mt19937_64 rng(58);\n    \n    while(1){\n        vector<string> S(8);\n        for(int i=0;i<8;i++) cin>>S[i];\n        if(S[0].size()==0) break;\n        \n        sort(all(S));\n        set<vector<string>> SE;\n        int ans=0;\n        \n        do{\n            if(SE.find(S)==SE.end()) ans++;\n            else continue;\n            \n            vector<string> T=S;\n            \n            for(int t=0;t<100;t++){\n                SE.insert(T);\n                for(int i=0;i<rng()%10;i++){\n                    vector<string> U(8);\n                    for(int j=0;j<8;j++){\n                        U[j]=T[(j+2)%8];\n                    }\n                    T=U;\n                    \n                    SE.insert(T);\n                }\n                \n                vector<string> U(8);\n                U[0]=T[6];\n                U[1]=T[0];\n                U[2]=T[4];\n                U[3]=T[2];\n                U[4]=T[5];\n                U[5]=T[3];\n                U[6]=T[7];\n                U[7]=T[1];\n                \n                T=U;\n            }\n            \n        }while(next_permutation(all(S)));\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nclass Octahedra{\n\tpublic:\n\t\tstring color[8];\n\t\tvoid right(){\n\t\t\tstring tmp[8];\n\t\t\trep(i,8) tmp[i]=color[i];\n\t\t\tcolor[0]=tmp[4],color[1]=tmp[5],color[2]=tmp[1],color[3]=tmp[0];\n\t\t\tcolor[4]=tmp[7],color[5]=tmp[6],color[6]=tmp[2],color[7]=tmp[3];\n\t\t}\n\t\tvoid top(){\n\t\t\tstring tmp[8];\n\t\t\trep(i,8) tmp[i]=color[i];\n\t\t\tcolor[0]=tmp[4],color[1]=tmp[0],color[2]=tmp[3],color[3]=tmp[7];\n\t\t\tcolor[4]=tmp[5],color[5]=tmp[1],color[6]=tmp[2],color[7]=tmp[6];\n\t\t}\n\t\tvoid rotation(){\n\t\t\trep(i,3) swap(color[i],color[i+1]);\n\t\t\trep(i,3) swap(color[i+4],color[i+1+4]);\n\t\t}\n\n\t\tbool operator<(Octahedra a) const{\n\t\t\trep(i,8) if(color[i]!=a.color[i]) return color[i]<a.color[i];\n\t\t\treturn color[7]<a.color[7];\n\t\t}\n};\n\nset<Octahedra> s;\n\nint main(void){\n\twhile(1){\n\t\tstring color[8];\n\t\trep(i,8) cin >> color[i];\n\t\tif(cin.eof()) break;\n\n\t\ts.clear();\n\t\tsort(color,color+8);\n\n\t\tdo{\n\t\t\tOctahedra in;\n\t\t\trep(i,8) in.color[i]=color[i];\n\n\t\t\tbool check=true;\n\t\t\trep(i,4){\n\t\t\t\trep(j,4){\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tif(s.find(in)!=s.end()) check=false;\n\t\t\t\t\t\tin.rotation();\n\t\t\t\t\t}\n\t\t\t\t\tin.right();\n\t\t\t\t}\n\t\t\t\tin.top();\n\t\t\t}\n\n\t\t\tif(check) s.insert(in);\n\n\t\t}while(next_permutation(color,color+8));\n\t\tcout << s.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint dx[] = {3,2,6,7,0,1,5,4};\nint dy[] = {4,0,3,7,5,1,2,6};\nint dz[] = {1,2,3,0,5,6,7,4};\n\nvector<int> changeX(vector<int> vi){\n\tvector<int> res(8);\n\tfor(int i=0;i<8;i++) res[i] = vi[dx[i]];\n\treturn res;\n}\n\nvector<int> changeY(vector<int> vi){\n\tvector<int> res(8);\n\tfor(int i=0;i<8;i++) res[i] = vi[dy[i]];\n\treturn res;\n}\n\nvector<int> changeZ(vector<int> vi){\n\tvector<int> res(8);\n\tfor(int i=0;i<8;i++) res[i] = vi[dz[i]];\n\treturn res;\n}\n\nint main(){\n\twhile(true){\n\t\tmap< string, int > mp;\n\t\tint size = 0;\n\t\tvector<int> vs;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tstring s;\n\t\t\tif(!(cin >> s)) return 0;\n\t\t\tif(!mp.count(s)) mp[s] = size++;\n\t\t\tvs.push_back(mp[s]);\n\t\t}\n\t\tsort(vs.begin(), vs.end());\n\t\tset< vector<int> > S;\n\t\tint ans = 0;\n\t\tdo{\n\t\t\tif(S.find(vs)==S.end()){\n\t\t\t\tans++;\n\t\t\t\tvector<int> vi = vs;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tS.insert(vi);\n\t\t\t\t\t\t\tvi=changeZ(vi);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvi = changeY(vi);\n\t\t\t\t\t}\n\t\t\t\t\tvi=changeX(vi);\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(vs.begin(),vs.end()));\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Vec;\nvoid rotatex(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[2];a[2]=a[3];a[3]=tmp;\n  tmp=a[4];a[4]=a[5];a[5]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatey(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[5];a[5]=a[4];a[4]=tmp;\n  tmp=a[3];a[3]=a[2];a[2]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatez(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[4];a[4]=a[7];a[7]=a[3];a[3]=tmp;\n  tmp=a[1];a[1]=a[5];a[5]=a[6];a[6]=a[2];a[2]=tmp;\n}\n\nint main(){\n  string s[8];\n  set<Vec> sv;\n  map<Vec,bool> mv;\n  while(cin>>s[0]){\n    int i,j,k,ans=0;\n    sv.clear();mv.clear();\n    for(i=1;i<8;i++) cin>>s[i];\n    sort(s,s+8);\n    set<string> ss;\n    Vec v;\n    for(i=0;i<8;i++) ss.insert(s[i]),v.push_back(ss.size()-1);\n    do{\n      for(i=0;i<4;i++){\n\trotatez(v);\n\tfor(j=0;j<4;j++){\n\t  rotatey(v);\n\t  for(k=0;k<4;k++){\n\t    rotatex(v);\n\t    sv.insert(v);\n\t  }\n\t}\n      }\n    }while(next_permutation(v.begin(),v.end()));\n    for(Vec a:sv){\n      if(mv[a]) continue;\n      ans++;\n      for(i=0;i<4;i++){\n\trotatez(a);\n\tfor(j=0;j<4;j++){\n\t  rotatey(a);\n\t  for(k=0;k<4;k++){\n\t    rotatex(a);\n\t    mv[a]=1;\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint color2num(map<string,int>& dictionary,const string& color){\n  if(dictionary.find(color) == dictionary.end()){\n    int idx = dictionary.size();\n    dictionary[color] = idx;\n  }\n  return dictionary[color];\n}\n\nclass Octahedra{\npublic:\n  int* upper_face;\n  int* lower_face;\n\n  Octahedra(){\n    upper_face = new int[4]();\n    lower_face = new int[4]();\n  }\n\n  void set_colors(const vector<int>& colors){\n    for(int i=0;i<4;i++){\n      upper_face[i] = colors[i];\n      lower_face[i] = colors[4+i];\n    }\n  }\n\n  int rotateZ(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      for(int i=0;i<4;i++){\n\ttmp_upper[(i+1)%4] = upper_face[i];\n\ttmp_lower[(i+1)%4] = lower_face[i];\n      }\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int rotateX(int turn){\n    for(int t = 0; t < turn; t++){\n      swap(upper_face[0],lower_face[2]);\n      swap(upper_face[1],lower_face[1]);\n      swap(upper_face[2],lower_face[0]);\n      swap(upper_face[3],lower_face[3]);\n    }\n  }\n  \n  int rotateY(int turn){\n    for(int t = 0; t < turn; t++){\n      swap(upper_face[0],lower_face[0]);\n      swap(upper_face[1],lower_face[3]);\n      swap(upper_face[2],lower_face[2]);\n      swap(upper_face[3],lower_face[1]);\n    }\n  }\n\n  int write(){\n    int res = 0;\n    int digit = 1;\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 8;\n    }\n    return res;\n  }\n};\n\nint main(){\n  string color;\n\n  while(cin >> color){\n    vector<int> colors;\n    map<string,int> dictionary;\n    int color_num;\n    color_num = color2num(dictionary,color);\n    colors.push_back(color_num);\n    for(int i=1;i<8;i++){\n      cin >> color;\n\n      color_num = color2num(dictionary,color);\n      colors.push_back(color_num);\n    }\n\n    sort(colors.begin(),colors.end());\n\n    int res = 0;\n    set<int> visited;\n    do {\n      Octahedra oct;\n      int state;\n      bool isok = false;\n      for(int i=0;i<4;i++){\n\toct.set_colors(colors);\n\toct.rotateX(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateY(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n\toct.set_colors(colors);\n\toct.rotateZ(i);\n\tstate = oct.write();\n\tif(visited.count(state) == 0){\n\t  visited.insert(state);\n\t  isok = true;\n\t}\n\n      }\n\n      if(isok) res++;\n    }while(next_permutation(colors.begin(),colors.end()));\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nconst int N = 8;\nint res;\nmap<vi, bool> used;\nint n;\nvector<vi> rot = {{1, 2, 3, 0, 5, 6, 7, 4},\n                  {6, 7, 1, 0, 2, 3, 5, 4}};\n\nvoid dfs2(vi perm){\n    if(used[perm]) return;\n    used[perm] = true;\n\n    vi next_perm(N);\n    rep(i, 2){\n        rep(j, N){\n            next_perm[j] = perm[rot[i][j]];\n        }\n        dfs2(next_perm);\n    }\n}\n\nvoid dfs(int cnt, vi & perm, vi & num_color){\n    if(cnt == N){\n        if(used[perm]) return;\n        res++;\n        dfs2(perm);\n        return;\n    }\n\n    rep(i, n){\n        if(num_color[i] <= 0) continue;\n\n        num_color[i]--;\n        perm[cnt] = i;\n        dfs(cnt + 1, perm, num_color);\n        num_color[i]++;\n    }\n}\n\nint main(void){\n    vector<string> in(N);\n    while(cin >> in[0]){\n        rep(i, 1, N) cin >> in[i];\n        map<string, int> s2i;\n        int idx = -1;\n        vi num_color;\n        for(auto & e : in){\n            if(s2i.find(e) == end(s2i)){\n                idx++;\n                s2i[e] = idx;\n                num_color.push_back(0);\n            }\n            num_color[idx]++;\n        }\n\n        res = 0;\n        used.clear();\n\n        n = num_color.size();\n        vi perm(N);\n        dfs(0, perm, num_color);\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n// 24ñÅ³ÉàÇé\n/*\nzñÆ_CXÌÊÌÖW\nc0ÍRXgN^ÌøÅ^¦çêéxN^Ìvf\n0 c4 0 0\nc3 c0 c2 c5\n0 c1 0 0\n*/\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\nprivate:\n\tint face[3][4];\npublic:\n\tvector<int> colored;\n\tint getFace(const int idx)const{\n\t\tif(idx==0)return face[1][1];\n\t\telse if(idx==1)return face[2][1];\n\t\telse if(idx==2)return face[1][2];\n\t\telse if(idx==3)return face[1][0];\n\t\telse if(idx==4)return face[0][1];\n\t\telse if(idx==5)return face[1][3];\n\t\treturn -1;\n\t}\n\tDice(const vector<int> &v){\n\t\tinit();\n\t\tfor(int i=0;i<8;i++)colored.push_back(v[i]);\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<4;j++)face[i][j]=-1;\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n\t\t\tround++;\n\t\t\t// z²ðSÉñ]\n\t\t\tint tp[8];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ttp[(i+1)%4]=colored[i];\n\t\t\t\ttp[(i+1)%4+4]=colored[i+4];\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n//\t\t\t\tint tmp = face[1][3];\n//\t\t\t\tfor(int i = 2; i >= 0; i--)\n//\t\t\t\t\tface[1][i+1]=face[1][i];\n//\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t\tint tp[8];\n\t\t\t\ttp[0]=colored[4];\n\t\t\t\ttp[1]=colored[5];\n\t\t\t\ttp[4]=colored[7];\n\t\t\t\ttp[5]=colored[6];\n\t\t\t\ttp[2]=colored[1];\n\t\t\t\ttp[3]=colored[0];\n\t\t\t\ttp[7]=colored[3];\n\t\t\t\ttp[6]=colored[2];\n\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\tint loop=1;\n\t\t\t\t\tif(tate==1)loop=2;\n\t\t\t\t\twhile(loop--){\n\t\t\t\t\t\ttate++;\n\t\t\t\t\t\tint tp[8];\n\t\t\t\t\t\ttp[7]=colored[3];\n\t\t\t\t\t\ttp[4]=colored[0];\n\t\t\t\t\t\ttp[6]=colored[7];\n\t\t\t\t\t\ttp[5]=colored[4];\n\t\t\t\t\t\ttp[2]=colored[6];\n\t\t\t\t\t\ttp[1]=colored[5];\n\t\t\t\t\t\ttp[3]=colored[2];\n\t\t\t\t\t\ttp[0]=colored[1];\n\t\t\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nint main() {\n\tint cs[8];\n\tstring s;\n\twhile (getline(cin, s)) {\n\t\tmap<string,int> idxs;\n\t\tint idx=0;\n\t\tistringstream iss(s);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tstring ts;\n\t\t\tiss>>ts;\n\t\t\tif(idxs.find(ts)==idxs.end())idxs[ts]=idx++;\n\t\t\tcs[i]=idxs[ts];\n\t\t}\n\t\tset<vector<int> > svs;\n\t\tint cnt=0;\n\t\tdo{\n\t\t\tvector<int> init;\n\t\t\tfor(int i=0;i<8;i++)init.push_back(cs[i]);\n\t\t\tDice d(init);\n\t\t\t// ¡Ìhèûªp^[ÌÇê©Éêv·é©`FbN\n\t\t\tif(svs.find(d.colored)==svs.end()){\n\t\t\t\tcnt++;\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tsvs.insert(d.colored);\n\t\t\t\t\td.rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(cs,cs+8));\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nvs in(8);\nmap<vs,int>ma;\nvoid roll(){\n\tstring t=in[3];\n\tin[3]=in[2];\n\tin[2]=in[1];\n\tin[1]=in[0];\n\tin[0]=t;\n\tt=in[7];\n\tin[7]=in[6];\n\tin[6]=in[5];\n\tin[5]=in[4];\n\tin[4]=t;\n}\nvoid rooll(){\n\tstring t=in[5];\n\tin[5]=in[4];\n\tin[4]=in[0];\n\tin[0]=in[1];\n\tin[1]=t;\n\tt=in[6];\n\tin[6]=in[7];\n\tin[7]=in[3];\n\tin[3]=in[2];\n\tin[2]=t;\n}\nvoid roooll(){\n\tstring t=in[6];\n\tin[6]=in[5];\n\tin[5]=in[1];\n\tin[1]=in[2];\n\tin[2]=t;\n\tt=in[7];\n\tin[7]=in[4];\n\tin[4]=in[0];\n\tin[0]=in[3];\n\tin[3]=t;\n}\nvoid F(){\n\tbool h=false;\n\trep(k,4){\n\t\trep(j,4){\n\t\t\trep(i,4){\n\t\t\t\troll();\n\t\t\t\tif(ma.count(in))h=true;\n\t\t\t}\n\t\t\trooll();\n\t\t}\n\t\troooll();\n\t}\n\tif(!h)ma[in]=1;\n}\nsigned main(){\n\twhile(cin>>in[0]){\n\t\trep(i,7)cin>>in[i+1];\n\t\tsort(all(in));\n\t\tma.clear();\n\t\tdo{F();}while(next_permutation(all(in)));\n\t\tcout<<ma.size()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\n\nusing Bool = bool;\nusing Int = long long int;\nusing String = std::string;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Set = std::set<T>;\n\nconst Vector<Vector<Int>> trans{\n    {0, 1, 2, 3},\n    {4, 5, 6, 7},\n    {0, 1, 5, 4},\n    {3, 2, 6, 7}};\n\nvoid rotate(Vector<String>& v, Int t) {\n    for (Int i = 0; i < 2; ++i) {\n        for (Int j = 0; j < 3; ++j) {\n            std::swap(v[trans[t * 2 + i][j]], v[trans[t * 2 + i][j + 1]]);\n        }\n    }\n}\n\nBool solve() {\n    Vector<String> s(8);\n    if (!(std::cin >> s[0])) return false;\n    for (Int i = 1; i < 8; ++i) std::cin >> s[i];\n\n    std::sort(s.begin(), s.end());\n    Set<Vector<String>> pats;\n    do {\n        pats.insert(s);\n    } while (std::next_permutation(s.begin(), s.end()));\n\n    Int ans = 0;\n    while (!pats.empty()) {\n        s = *pats.begin();\n        ++ans;\n\n        for (Int i = 0; i < 4; ++i) {\n            for (Int j = 0; j < 4; ++j) {\n                for (Int k = 0; k < 4; ++k) {\n                    for (Int l = 0; l < 4; ++l) {\n                        pats.erase(s);\n                        rotate(s, 0);\n                    }\n                    rotate(s, 1);\n                }\n                rotate(s, 0);\n            }\n            rotate(s, 1);\n        }\n    }\n\n    std::cout << ans << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nset< vector<string> > S;\n\nint func[2][8] = {\n    {4, 5, 1, 0, 7, 6, 2, 3},\n    {1, 2, 3, 0, 5, 6, 7, 4}\n};\n\nvoid rot(vector<string> s) {\n    for(int i=0; i<2; i++) {\n        vector<string> nxt(8);\n        for(int k=0; k<8; k++) {\n            nxt[ func[i][k] ] = s[k];\n        }\n        if(S.count(nxt)) continue;\n\n        S.insert(nxt);\n        rot(nxt);\n    }\n}\n\nint main() {\n    string s;\n    while(cin >> s) {\n        vector<string> vs;\n        vs.push_back(s);\n        for(int i=0; i<7; i++) {\n            cin >> s;\n            vs.push_back(s);\n        }\n        S.clear();\n        sort(vs.begin(), vs.end());\n\n        int ans = 0;\n        do {\n            if(S.count(vs)) continue;\n            ans++;\n\n            S.insert(vs);\n            rot(vs);\n        }while(next_permutation(vs.begin(), vs.end()));\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nset< vector<string> > ans;\nvector<string> c(8);\n\nbool check()\n{\n\tfor (auto vs : ans)\n\t{\n\t\tbool ok = true;\n\t\trep(i, 0, 8)\n\t\t{\n\t\t\tif (vs[i] != c[i]) ok = false;\n\t\t}\n\t\tif (ok) return true;\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tstring s;\n\n\trep(j, 0, 2)\n\t{\n\t\tif (check()) return;\n\t\trep(i, 0, 3)\n\t\t{\n\t\t\ts = c[0];\n\n\t\t\tc[0] = c[1];\n\t\t\tc[1] = c[2];\n\t\t\tc[2] = c[3];\n\t\t\tc[3] = s;\n\n\t\t\tif (check()) return;\n\t\t}\n\n\t\tswap(c[0], c[6]);\n\t\tswap(c[1], c[5]);\n\t\tswap(c[2], c[4]);\n\t\tswap(c[3], c[7]);\n\t}\n\n\tans.insert(c);\n}\n\nvoid dfs(int d)\n{\n\tif (d == 8)\n\t{\n\t\tsolve();\n\t\treturn;\n\t}\n\n\trep(i, d, 8)\n\t{\n\t\tswap(c[d], c[i]);\n\t\tdfs(d + 1);\n\t\tswap(c[d], c[i]);\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\twhile (cin >> s)\n\t{\n\t\tc[0] = s;\n\t\trep(i, 1, 8) cin >> c[i];\n\t\tans.clear();\n\t\tdfs(0);\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 0;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 7 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\t/*\n\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tbool val = true;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] != x[k]*2 && x[k] > 0) val = false;\n\t\t\tif(!val){\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1*2;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 2*2;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 9*2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tlong long tmpans = 0;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int i2 = i; i2 < f.size(); i2++){\n\t\t\t\tif(f[i2] <= 0) continue;\n\t\t\t\tf[i2]--;\n\t\t\t\tint tmp = 4*3*2*1;\n\t\t\t\tfor(int j = 1; j < f.size(); j++){\n\t\t\t\t\tif(f[j] <= 0) continue;\n\t\t\t\t\tfor(int k = f[j]; k >= 1; k--) tmp /= k;\n\t\t\t\t}\n\t\t\t\tif(i != i2){\n\t\t\t\t\ttmpans += tmp;\n\t\t\t\t} else{\n\t\t\t\t\tvector<int> y;\n\t\t\t\t\tfor(int j = 1; j < f.size(); j++) if(f[j] > 0) y.push_back(f[j]);\n\t\t\t\t\tif(y.size() == 1) tmpans += 1;\n\t\t\t\t\telse if(y.size() == 2 && y[0] == 2) tmpans += 4;\n\t\t\t\t\telse{\n\t\t\t\t\t\ttmpans += tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i2]++;\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t\tans += tmpans*2;\n\t\t*/\n\t\tif(f[1] == 3){\n\t\t\tans = 24;\n\t\t} else{\n\t\t\tif(f[2] == 2) ans = 114;\n\t\t\telse ans = 22;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint a[][4] = {{0, 1, 2, 3},\n              {4, 5, 6, 7},\n              {0, 1, 5, 4},\n              {3, 2, 6, 7},\n              {0, 4, 7, 3},\n              {1, 5, 6, 2}};\n\nint main()\n{\n    for(;;){\n        vector<string> color(8);\n        map<string, char> index;\n        for(int i=0; i<8; ++i){\n            if(!(cin >> color[i]))\n                return 0;\n            if(index.find(color[i]) == index.end()){\n                int k = index.size();\n                index[color[i]] = k + 'a';\n            }\n        }\n\n       string s(8, ' ');\n        for(int i=0; i<8; ++i)\n            s[i] = index[color[i]];\n        sort(s.begin(), s.end());\n\n        set<string> x;\n        do{\n            string t = s;\n            bool ok = true;\n\n            for(int i=0; i<500; ++i){\n                int b = xor128() % 3;\n                for(int j=0; j<3; ++j){\n                    swap(t[a[b*2][j]], t[a[b*2][j+1]]);\n                    swap(t[a[b*2+1][j]], t[a[b*2+1][j+1]]);\n                }\n                if(x.find(t) != x.end()){\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok)\n                x.insert(s);\n        }while(next_permutation(s.begin(), s.end()));\n\n        cout << x.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 1;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 5 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 6 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tif(y.size() == 1){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t} else if(y.size() == 2){\n\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t} else{\n\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tf[0] = 1;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()*2)); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 0; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 0; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 0; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<unordered_map>\n#include<climits>\n#include<sstream>\n#include<deque>\n#include<queue>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<bitset>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(),x.end()\n\nusing namespace std;\n\nvoid roll_x(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {7,0,3,4,5,2,1,6};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nvoid roll_y(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {7,6,1,0,3,2,5,4};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nvoid roll_z(vector<int> &vec) {\n  vector<int> tmp(8);\n  int f[] = {3,0,1,2,5,6,7,4};\n  rep(i,8) tmp[i] = vec[f[i]];\n  vec = tmp;\n}\n\nint normalize(vector<int> color) {\n  int mini = INT_MAX;\n  vector<int> tmp = color;\n  rep(_,4) {\n    rep(__,4) {\n      rep(___,4) {\n\tint v = 0;\n\trep(i,8) { assert(color[i]); v *= 10; v += color[i]; }\n\tmini = min(mini,v);\n\troll_x(color);\n      }\n      roll_y(color);\n    }\n    roll_z(color);\n  }\n  assert( tmp == color );\n  return mini;\n}\n\nvoid compute(vector<int> &color) {\n  sort(all(color));\n  set<int> S;\n  do {\n    S.insert(normalize(color));\n  } while( next_permutation(all(color)) );\n  cout << (int)S.size() << endl;\n}\n\nint main() {\n  string s;\n  while( cin >> s ) {\n    map<string,int> toInt;\n    vector<int> color;\n    {\n      int id = 1;\n      toInt[s] = id++;\n      color.push_back(toInt[s]);\n      rep(i,7) {\n\tcin >> s;\n\tif( toInt.count(s) == 0 ) toInt[s] = id++;\n\tcolor.push_back(toInt[s]);\n      }\n    }\n    compute(color);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<short> V;\nconst int UF=0,UL=1,UB=2,UR=3;\nconst int DF=4,DL=5,DB=6,DR=7;\nset<int> S;\nV A(8),num(8,-1);\n\nvoid SW(int a,int b){swap(num[a],num[b]);}\nvoid rot(){\n  SW(UF,UR),SW(UR,UB),SW(UB,UL);\n  SW(DF,DR),SW(DR,DB),SW(DB,DL);\n}\n\nvoid rot90(){\n  V tmp = num;\n  num[UF] = tmp[DF];\n  num[UL] = tmp[DL];\n  num[UB] = tmp[UL];\n  num[UR] = tmp[UF];\n  \n  num[DF] = tmp[DR];\n  num[DL] = tmp[DB];\n  num[DB] = tmp[UB];\n  num[DR] = tmp[UR];\n  \n  \n}\nvoid rev(){SW(UF,DB),SW(DF,UB),SW(UR,DR),SW(UL,DL);}\n\nint VtoI(V&a=num){\n  int res=0;\n  for(int i=0;i<8;i++)res=res*10+num[i]+1;\n  return res;\n}\n\nvoid RotRev(){\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  \n}\n\nvoid Insert(){\n  RotRev();\n  rot90(),RotRev();\n  rot(),rot90(),RotRev();\n}\n\nint check(){\n  if(S.count(VtoI()))return 0;\n  V tmp = num;\n  Insert();\n  num= tmp;\n  return 1;\n}\n\nint dfs(int dep){\n  if(dep==8) return check();\n  int res=0;\n  for(int i=0;i<8;i++){\n    if(num[i]!=-1)continue;\n    num[i] = A[dep];\n    res+=dfs(dep+1);\n    num[i] = -1;\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    map<string,int> M;\n    string str;\n    for(int i=0,cnt=0;i<8;i++){\n      if((cin>>str)==0)return 0;\n      if(M.count(str)) A[i] = M[str];\n      else A[i] = M[str] = cnt++;\n    }\n    S.clear();\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint ans;\nvector<string>a(8);\nset<vector<string> >s;\nvoid ch(){\n  if(s.count(a))return;\n  r(i,2){\n    swap(a[0],a[4]);\n    swap(a[1],a[5]);\n    swap(a[2],a[6]);\n    swap(a[3],a[7]);\n    r(j,4){\n      swap(a[0],a[1]);\n      swap(a[1],a[2]);\n      swap(a[2],a[3]);\n      swap(a[4],a[5]);\n      swap(a[5],a[6]);\n      swap(a[6],a[7]);\n      r(k,3){\n        swap(a[0],a[2]);\n        swap(a[2],a[5]);\n        swap(a[4],a[6]);\n        swap(a[6],a[1]);\n        s.insert(a);\n      }\n    }\n  }\n  ans++;\n}\nmain(){\n  while(cin>>a[0]){\n    ans=0;\n    s.clear();\n    r(i,7)cin>>a[i+1];\n    sort(a.begin(),a.end());\n    do{\n      ch();\n    }while(next_permutation(a.begin(),a.end()));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 0;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 5 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 6 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tbool val = true;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] != x[k]*2 && x[k] > 0) val = false;\n\t\t\tif(!val){\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1*2;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 2*2;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 9*2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tcout << ans << endl;\n\t\tlong long tmpans = 0;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int i2 = i; i2 < f.size(); i2++){\n\t\t\t\tif(f[i2] <= 0) continue;\n\t\t\t\tf[i2]--;\n\t\t\t\tint tmp = 4*3*2*1;\n\t\t\t\tfor(int j = 1; j < f.size(); j++){\n\t\t\t\t\tif(f[j] <= 0) continue;\n\t\t\t\t\tfor(int k = f[j]; k >= 1; k--) tmp /= k;\n\t\t\t\t}\n\t\t\t\tif(i != i2){\n\t\t\t\t\ttmpans += tmp;\n\t\t\t\t} else{\n\t\t\t\t\tvector<int> y;\n\t\t\t\t\tfor(int j = 1; j < f.size(); j++) if(f[j] > 0) y.push_back(f[j]);\n\t\t\t\t\tif(y.size() == 1) tmpans += 1;\n\t\t\t\t\tif(y.size() == 2 && y[0] == 2) tmpans += 4;\n\t\t\t\t\telse{\n\t\t\t\t\t\ttmpans += tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i2]++;\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t\tans += tmpans*2;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nbool isSame(const vector<string> &s, const vector<string> &t)\n{\n    bool f = false;\n    for (int i = 0; i < 4; i++)\n    {\n        vector<string> cp(8), cp2;\n        for (int j = 0; j < 4; j++)\n        {\n            cp[j] = t[(i + j) % 4];\n            cp[j + 4] = t[(i + j) % 4 + 4];\n        }\n        if (cp == s)\n            f = true;\n        cp2 = cp;\n        cp2[1] = cp[4];\n        cp2[2] = cp[5];\n        cp2[3] = cp[1];\n        cp2[4] = cp[3];\n        cp2[5] = cp[7];\n        cp2[6] = cp[6];\n        cp2[7] = cp[2];\n        if (cp2 == s)\n            f = true;\n\n        cp2 = cp;\n        cp2[1] = cp[3];\n        cp2[2] = cp[7];\n        cp2[3] = cp[4];\n        cp2[4] = cp[1];\n        cp2[5] = cp[2];\n        cp2[6] = cp[6];\n        cp2[7] = cp[5];\n        if (cp2 == s)\n            f = true;\n    }\n    for (int i = 0; i < 4; i++)\n    {\n        vector<string> cp(8), cp2;\n        for (int j = 0; j < 4; j++)\n        {\n            cp[j] = t[(i + j) % 4 + 4];\n            cp[j + 4] = t[(i + j) % 4];\n        }\n        if (cp == s)\n            f = true;\n        cp2 = cp;\n        cp2[1] = cp[4];\n        cp2[2] = cp[5];\n        cp2[3] = cp[1];\n        cp2[4] = cp[3];\n        cp2[5] = cp[7];\n        cp2[6] = cp[6];\n        cp2[7] = cp[2];\n        if (cp2 == s)\n            f = true;\n\n        cp2 = cp;\n        cp2[1] = cp[3];\n        cp2[2] = cp[7];\n        cp2[3] = cp[4];\n        cp2[4] = cp[1];\n        cp2[5] = cp[2];\n        cp2[6] = cp[6];\n        cp2[7] = cp[5];\n        if (cp2 == s)\n            f = true;\n    }\n    return f;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    vector<string> s(8);\n    while (cin >> s[0])\n    {\n        for (int i = 1; i < 8; i++)\n            cin >> s[i];\n        sort(s.begin(), s.end());\n        set<vector<string>> st;\n        do\n        {\n            bool f = true;\n            for (auto v : st)\n            {\n                if (isSame(v, s))\n                    f = false;\n            }\n            if (f)\n                st.insert(s);\n        } while (next_permutation(s.begin(), s.end()));\n        cout << st.size() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nconst int tb[][8] = {\n\t{3, 0, 1, 2, 7, 4, 5, 6},\n\t{4, 0, 3, 7, 5, 1, 2, 6}\n};\n\nmap<string, int> cv;\nset<int> dn;\nint a[8];\n\nint main()\n{\n\twhile (true){\n\t\tcv.clear();\n\t\tdn.clear();\n\n\t\tstring s;\n\t\trep(i, 8){\n\t\t\tif (!(cin >> s)) return 0;\n\t\t\tint t = cv.size();\n\t\t\tif (cv.count(s)) a[i] = cv[s];\n\t\t\telse cv[s] = a[i] = t;\n\t\t}\n\n\t\tint res = 0;\n\t\tint perm[8];\n\t\tiota(perm, perm + 8, 0);\n\t\tdo {\n\t\t\tarray<int, 8> b;\n\t\t\tint c[16] = {};\n\t\t\trep(i, 8) b[i] = a[perm[i]];\n\t\t\tbool f = true;\n\t\t\trep(i, 16){\n\t\t\t\trep(j, 8) c[i] = c[i] * 8 + b[j];\n\t\t\t\tif (dn.count(c[i])) f = false;\n\t\t\t\tarray<int, 8> dst;\n\t\t\t\trep(j, 8){\n\t\t\t\t\tdst[j] = b[tb[(i & 3) == 3][j]];\n\t\t\t\t}\n\t\t\t\tb = dst;\n\t\t\t}\n\t\t\tif (f) res++;\n\t\t\trep(i, 16) dn.insert(c[i]);\n\t\t} while (next_permutation(perm, perm + 8));\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  vector<int> v;\n  P(vector<int> &v) : v(v) {}\n  P rotate1() {\n    P r = *this;\n    REP(i,3) swap(r.v[i],r.v[(i+1)%4]);\n    REP(i,3) swap(r.v[4+i],r.v[4+(i+1)%4]);\n    return r;\n  }\n  P rotate2() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[5]);swap(w[5],w[1]);\n    swap(w[2],w[3]);swap(w[3],w[7]);swap(w[7],w[6]);\n    return P(w);\n  }\n  P rotate3() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[7]);swap(w[7],w[3]);\n    swap(w[1],w[5]);swap(w[5],w[6]);swap(w[6],w[2]);\n    return P(w);\n  }\n  vector<P> all() {\n    P r = *this;\n    vector<P> res;\n    for (int i=0; i<6; ++i,r=(i&2?r.rotate2():r.rotate3())) {\n      for (int j=0;j<4; ++j,r=r.rotate1())\n        res.push_back(r);\n    }\n    return res;\n  }\n};\nint main() {\n  string s;\n  while(cin>>s) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> v;\n    mp[s] = num++;\n    v.push_back(mp[s]);\n    REP(i,7) {\n      cin >> s;\n      if (mp.count(s) == 0) mp[s] = num++;\n      v.push_back(mp[s]);\n    }\n    vector<int> cnt(24);\n    sort(ALL(v));\n    do {\n      vector<P> ret = P(v).all();\n      REP(i,24) {\n        if (ret[i].v == v) cnt[i]++;\n      }\n    } while(next_permutation(ALL(v)));\n    int ans = 0;\n    REP(i,24) ans += cnt[i];\n    cout << ans/24 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<short> V;\nconst int UF=0,UL=1,UB=2,UR=3;\nconst int DF=4,DL=5,DB=6,DR=7;\nset<int> S;\nV A(8),num(8,-1);\n\nvoid SW(int a,int b){swap(num[a],num[b]);}\nvoid rot(){\n  SW(UF,UR),SW(UR,UB),SW(UB,UL);\n  SW(DF,DR),SW(DR,DB),SW(DB,DL);\n}\n\nvoid rot90(){\n  V tmp = num;\n  num[UF] = tmp[DF];\n  num[UL] = tmp[DL];\n  num[UB] = tmp[UL];\n  num[UR] = tmp[UF];\n  \n  num[DF] = tmp[DR];\n  num[DL] = tmp[DB];\n  num[DB] = tmp[UB];\n  num[DR] = tmp[UR];\n  \n  \n}\nvoid rev(){SW(UF,DB),SW(DF,UB),SW(UR,DR),SW(UL,DL);}\n\nint VtoI(V&a=num){\n  int res=0;\n  for(int i=0;i<8;i++)res=res*10+num[i]+1;\n  return res;\n}\n\nvoid RotRev(){\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  for(int i=0;i<4;i++) rot(),S.insert(VtoI());\n  rev();\n  \n}\n\nvoid Insert(){\n  RotRev();\n  rot90(),RotRev();\n  rot(),rot90(),RotRev();\n}\n\nint check(){\n  if(S.count(VtoI()))return 0;\n  V tmp = num;\n  Insert();\n  num= tmp;\n  return 1;\n}\n\nint dfs(int dep){\n  if(dep==8) return check();\n  int res=0;\n  for(int i=0;i<8;i++){\n    if(num[i]!=-1)continue;\n    num[i] = A[dep];\n    res+=dfs(dep+1);\n    num[i] = -1;\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    map<string,int> M;\n    string str;\n    for(int i=0,cnt=0;i<8;i++){\n      if((cin>>str)==0)return 0;\n      if(M.count(str)) A[i] = M[str];\n      else A[i] = M[str] = cnt++;\n    }\n    S.clear();\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nconst int tb[][8] = {\n\t{3, 0, 1, 2, 7, 4, 5, 6},\n\t{4, 0, 3, 7, 5, 1, 2, 6},\n\t{4, 5, 1, 0, 7, 6, 2, 3}\n};\n\nmap<string, int> cv;\nset<int> dn;\nint a[8];\n\nint main()\n{\n\twhile (true){\n\t\tcv.clear();\n\t\tdn.clear();\n\n\t\tstring s;\n\t\trep(i, 8){\n\t\t\tif (!(cin >> s)) return 0;\n\t\t\tint t = cv.size();\n\t\t\tif (cv.count(s)) a[i] = cv[s];\n\t\t\telse cv[s] = a[i] = t;\n\t\t}\n\n\t\tint res = 0;\n\t\tint perm[8];\n\t\tint c[64];\n\t\tiota(perm, perm + 8, 0);\n\t\tdo {\n\t\t\tarray<int, 8> b;\n\t\t\trep(i, 8) b[i] = a[perm[i]];\n\t\t\tbool f = true;\n\t\t\trep(i, 64){\n\t\t\t\tc[i] = 0;\n\t\t\t\trep(j, 8) c[i] = c[i] * 8 + b[j];\n\t\t\t\tif (dn.count(c[i])) f = false;\n\t\t\t\tarray<int, 8> dst;\n\t\t\t\trep(j, 8){\n\t\t\t\t\tdst[j] = b[tb[0][j]];\n\t\t\t\t}\n\t\t\t\tif (i % 4 == 3){\n\t\t\t\t\trep(j, 8){\n\t\t\t\t\t\tdst[j] = b[tb[1][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i % 16 == 15){\n\t\t\t\t\trep(j, 8){\n\t\t\t\t\t\tdst[j] = b[tb[2][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = dst;\n\t\t\t}\n\t\t\tif (f) res++;\n\t\t\trep(i, 64) dn.insert(c[i]);\n\t\t} while (next_permutation(perm, perm + 8));\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint color2num(map<string,int>& dictionary,const string& color){\n  if(dictionary.find(color) == dictionary.end()){\n    dictionary[color] = dictionary.size();\n  }\n  return dictionary[color];\n}\n\nclass Octahedra{\npublic:\n  int* upper_face;\n  int* lower_face;\n\n  Octahedra(){\n    upper_face = new int[4]();\n    lower_face = new int[4]();\n  }\n\n  void set_colors(const vector<int>& colors){\n    for(int i=0;i<4;i++){\n      upper_face[i] = colors[i];\n      lower_face[i] = colors[4+i];\n    }\n  }\n\n  int rotateZ(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      for(int i=0;i<4;i++){\n\ttmp_upper[(i+1)%4] = upper_face[i];\n\ttmp_lower[(i+1)%4] = lower_face[i];\n      }\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int rotateX(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      tmp_upper[1] = upper_face[0];\n      tmp_lower[1] = upper_face[1];\n      tmp_lower[2] = upper_face[2];\n      tmp_upper[2] = upper_face[3];\n\n      tmp_upper[0] = lower_face[0];\n      tmp_lower[0] = lower_face[1];\n      tmp_lower[3] = lower_face[2];\n      tmp_upper[3] = lower_face[3];\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n  \n  int rotateY(int turn){\n    for(int t = 0; t < turn; t++){\n      int tmp_upper[4];\n      int tmp_lower[4];\n      tmp_lower[0] = upper_face[0];\n      tmp_lower[1] = upper_face[1];\n      tmp_upper[1] = upper_face[2];\n      tmp_upper[0] = upper_face[3];\n\n      tmp_lower[3] = lower_face[0];\n      tmp_lower[2] = lower_face[1];\n      tmp_upper[2] = lower_face[2];\n      tmp_upper[3] = lower_face[3];\n      for(int i=0;i<4;i++){\n\tupper_face[i] = tmp_upper[i];\n\tlower_face[i] = tmp_lower[i];\n      }\n    }\n  }\n\n  int write(){\n    int res = 0;\n    int digit = 1;\n    for(int i=0;i<4;i++){\n      res += upper_face[i] * digit;\n      digit *= 9;\n    }\n    for(int i=0;i<4;i++){\n      res += lower_face[i] * digit;\n      digit *= 9;\n    }\n    return res;\n  }\n\n  int print_face(){\n    for(int i=0;i<4;i++){\n      printf(\"%d \",upper_face[i]);\n    }\n    printf(\"\\n\");\n    for(int i=0;i<4;i++){\n      printf(\"%d \",lower_face[i]);\n    }\n    printf(\"\\n\");\n    printf(\"\\n\");\n  }\n};\n\nint main(){\n  string color;\n\n  while(cin >> color){\n    vector<int> colors;\n    map<string,int> dictionary;\n    int color_num;\n    color_num = color2num(dictionary,color);\n    colors.push_back(color_num);\n    for(int i=1;i<8;i++){\n      cin >> color;\n\n      color_num = color2num(dictionary,color);\n      colors.push_back(color_num);\n    }\n\n    sort(colors.begin(),colors.end());\n\n    int res = 0;\n    set<int> visited;\n    do {\n      Octahedra oct;\n      int state;\n      bool isok = false;\n\n      for(int i=0;i<4;i++){\n\tfor(int j=0;j<4;j++){\n\t  for(int k=0;k<4;k++){\n\t    oct.set_colors(colors);\n\t    oct.rotateX(i);\n\t    oct.rotateY(j);\n\t    oct.rotateZ(k);\n\t    state = oct.write();\n\t    if(visited.count(state) == 0){\n\t      visited.insert(state);\n\t      isok = true;\n\t    }\n\t  }\n\t}\n      }\n      if(isok) res++;\n    }while(next_permutation(colors.begin(),colors.end()));\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<set>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nchar str[8][21];\nstring name[8];\nint perm[8];\nint h[6][8]={\n{0,1,2,3,4,5,6,7},\n{1,5,6,2,0,4,7,3},\n{5,4,7,6,1,0,3,2},\n{4,0,3,7,5,1,2,6},\n{4,5,1,0,7,6,2,3},\n{3,2,6,7,0,1,5,4},\n};\nint main(){\n\twhile(~scanf(\"%s\",str[0])){\n\t\tfor(int i=1;i<8;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<8;i++)name[i]=str[i];\n\t\tstd::sort(name,name+8);\n\t\tset<int>S;\n\t\tint sz=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tperm[i]=sz;\n\t\t\tif(i<7&&name[i]!=name[i+1]){\n\t\t\t\tsz++;\n\t\t\t}\n\t\t}\n\t\tdo{\n\t\t\tint t=0;\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tt*=8;t+=perm[i];\n\t\t\t}\n\t\t\tbool ok=true;\n\t\t\tfor(int i=0;i<6;i++)for(int j=0;j<4;j++){\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(int k=0;k<8;k++){\n\t\t\t\t\ttmp*=8;\n\t\t\t\t\ttmp+=perm[h[i][k/4*4+(j+k)%4]];\n\t\t\t\t}\n\t\t\t\tif(S.count(tmp)){ok=false;break;}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tS.insert(t);\n\t\t\t}\n\t\t}while(next_permutation(perm,perm+8));\n\t\tprintf(\"%d\\n\",(int)S.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid reverse(int ind[8]) {\n  int tmp;\n  tmp = ind[0];\n  ind[0] = ind[5];\n  ind[5] = tmp;\n  tmp = ind[1];\n  ind[1] = ind[6];\n  ind[6] = tmp;\n  tmp = ind[2];\n  ind[2] = ind[7];\n  ind[7] = tmp;\n  tmp = ind[3];\n  ind[3] = ind[4];\n  ind[4] = tmp;\n}\n\nvoid roll1(int n, int ind[8]) {\n  for(int i = 0; i < n; ++i) {\n    int tmp;\n    tmp = ind[3];\n    ind[3] = ind[0];\n    ind[0] = ind[1];\n    ind[1] = ind[2];\n    ind[2] = tmp;\n    tmp = ind[4];\n    ind[4] = ind[7];\n    ind[7] = ind[6];\n    ind[6] = ind[5];\n    ind[5] = tmp;\n  }\n}\nvoid roll2(int n, int ind[8]) {\n  for(int i = 0; i < n; ++i) {\n    int tmp;\n    tmp = ind[0];\n    ind[0] = ind[2];\n    ind[2] = ind[4];\n    ind[4] = tmp;\n    tmp = ind[1];\n    ind[1] = ind[5];\n    ind[5] = ind[7];\n    ind[7] = tmp;\n  }\n}\n\nclass Octahedra {\npublic:\n  string s[8];\n  bool operator == (const Octahedra &oct) const {\n    int ind[8];\n    for(int i = 0; i < 8; ++i) ind[i] = i;\n    for(int k = 0; k < 8; ++k) {\n      if(k == 4) {\n\treverse(ind);\n      }\n      for(int j = 0; j < 3; ++j) {\n\tfor(int i = 0; i < 8; ++i) {\n\t  if(s[ind[i]] != oct.s[i]) break;\n\t  if(i == 7) return true;\n\t}\n\troll2(1, ind);\n      }\n      roll1(1, ind);\n    }\n    return false;\n  }\n};\n\nstring str[8];\n\nint solve() {\n  vector<Octahedra> count;\n  sort(str, str+8);\n  Octahedra oct;\n  for(int i = 0; i < 8; ++i) oct.s[i] = str[i];\n  do {\n    bool flag = false;\n    for(int i = 0; i < count.size(); ++i) {\n      if(count[i] == oct) break;\n      if(i == count.size() - 1) flag = true;\n    }\n    if(flag || count.size() == 0) {\n      count.push_back(oct);\n    }\n  } while(next_permutation(oct.s, oct.s+8));\n  return count.size();\n}\n\nmain() {\n  while((cin >> str[0])) {\n    for(int i = 1; i < 8; ++i) cin >> str[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nclass data{\npublic:\n\tstring str[8];\n\tdata(){}\n};\n\nbool operator<(const data &d1,const data &d2){\n\tfor(int i=0;i<8;i++){\n\t\tif(d1.str[i]!=d2.str[i])return d1.str[i]<d2.str[i];\n\t}\n\treturn d1.str[7]<d2.str[7];\n}\n\nstring str[8];\nset<data> dat;\nint id[8];\nbool used[8];\nint next[24][8]={\n\t{0,1,2,3,4,5,6,7},\n\t{3,0,1,2,7,4,5,6},\n\t{2,3,0,1,6,7,4,5},\n\t{1,2,3,0,5,6,7,4},\n\n\t{4,7,6,5,0,3,2,1},\n\t{5,4,7,6,1,0,3,2},\n\t{6,5,4,7,2,1,0,3},\n\t{7,6,5,4,3,2,1,0},\n\n\t{0,4,5,1,3,7,6,2},\n\t{1,0,4,5,2,3,7,6},\n\t{5,1,0,4,6,2,3,7},\n\t{4,5,1,0,7,6,2,3},\n\n\t{7,3,2,6,4,0,1,5},\n\t{6,7,3,2,5,4,0,1},\n\t{2,6,7,3,1,5,4,0},\n\t{3,2,6,7,0,1,5,4},\n\n\t{0,3,7,4,1,2,6,5},\n\t{4,0,3,7,5,1,2,6},\n\t{7,4,0,3,6,5,1,2},\n\t{3,7,4,0,2,6,5,1},\n\n\t{1,5,6,2,0,4,7,3},\n\t{2,1,5,6,3,0,4,7},\n\t{6,2,1,5,7,3,0,4},\n\t{5,6,2,1,4,7,3,0},\n\n};\nvoid dfs(int v){\n\tif(v==8){\n\t\tbool ok=true;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tdl.str[j]=str[id[next[i][j]]];\n\t\t\t}\n\t\t\tif(dat.find(dl)!=dat.end()){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tdl.str[j]=str[id[j]];\n\t\t\t}\n\t\t\tdat.insert(dl);\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tid[v]=i;\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(v+1);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin>>str[0]){\n\t\tll res=0,res2=0;\n\t\tfor(int i=1;i<8;i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tdat.clear();\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",dat.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define int long long\n\nint rot[2][8] = {{3, 0, 1, 2, 7, 4, 5, 6}, {4, 5, 1, 0, 7, 6, 2, 3}};\n\nset<int> st;\nint to_int(vector<int>& v) {\n    int ret = 0;\n    int p10 = 1;\n    REP(i, v.size()) {\n        ret += p10 * v[i];\n        p10 *= 10;\n    }\n    return ret;\n}\nvoid dfs(vector<int> v) {\n    int num = to_int(v);\n    if (st.count(num)) return;\n    st.insert(num);\n    vector<int> nv(8);\n    REP(i, 2) {\n        REP(j, 8) { nv[j] = v[rot[i][j]]; }\n        dfs(nv);\n    }\n}\n\nbool solve() {\n    int b[8];\n    st.clear();\n    map<string, int> mp;\n    int id = 0;\n    REP(i, 8) {\n        string s;\n        if (cin >> s)\n            ;\n        else\n            return false;\n        if (mp.count(s)) {\n            b[i] = mp[s];\n        } else {\n            mp[s] = id;\n            id++;\n            b[i] = mp[s];\n        }\n    }\n    sort(b, b + 8);\n    int ans = 0;\n    do {\n        vector<int> v(8);\n        REP(i, 8) v[i] = b[i];\n        if (!st.count(to_int(v))) ans++;\n        dfs(v);\n    } while (next_permutation(b, b + 8));\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n    // solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<class T>\nclass ID{\n  map<T,int> _id;\npublic:\n  ID(){}\n  int operator()(const T &val){\n    if(_id.find(val) == _id.end()){\n      int next = _id.size();\n      return _id[val] = next;\n    }\n    return _id[val];\n  }\n};\n\nint main(){\n  string s;\n  while(cin >> s){\n    vector<int> v(8);\n    ID<string> id;\n    v[0] = id(s);\n    REP(i,7){\n      cin >> s;\n      v[i+1] = id(s);\n    }\n\n    set<string> ans;\n    sort(v.begin(), v.end());\n\n    do{\n      vector<string> tmp(24, \"        \");\n\n      REP(i,4){\n\tREP(j,4){\n\t  tmp[i][(i+j)%4]   = v[j] + '0';\n\t  tmp[i][(i+j)%4+4] = v[j+4] + '0';\n\n\t  tmp[i+4][(i+j)%4]   = v[4+(3-j)] + '0';\n\t  tmp[i+4][(i+j)%4+4] = v[3-j] + '0';\n\t}\n      }\n\n      REP(i,8){\n\ttmp[i+8][0] = tmp[i][0];\n\ttmp[i+8][1] = tmp[i][3];\n\ttmp[i+8][2] = tmp[i][7];\n\ttmp[i+8][3] = tmp[i][4];\n\ttmp[i+8][4] = tmp[i][1];\n\ttmp[i+8][5] = tmp[i][2];\n\ttmp[i+8][6] = tmp[i][6];\n\ttmp[i+8][7] = tmp[i][5];\n      }\n\n      REP(i,8){\n\ttmp[i+16][0] = tmp[i][0];\n\ttmp[i+16][1] = tmp[i][4];\n\ttmp[i+16][2] = tmp[i][5];\n\ttmp[i+16][3] = tmp[i][1];\n\ttmp[i+16][4] = tmp[i][3];\n\ttmp[i+16][5] = tmp[i][7];\n\ttmp[i+16][6] = tmp[i][6];\n\ttmp[i+16][7] = tmp[i][2];\n      }\n\n      sort(tmp.begin(), tmp.end());\n      ans.insert(tmp[0]);\n\n    }while(next_permutation(v.begin(), v.end()));\n\n    /*\n    for(set<string>::iterator it = ans.begin();\n\tit != ans.end(); ++it){\n      cout << *it << endl;\n    }\n    */\n\n\n    printf(\"%d\\n\", ans.size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\nclass data{\npublic:\n\tstring str[4];\n\tdata(){}\n\tdata(string st,string st2,string st3,string st4){\n\t\tstr[0]=st;\n\t\tstr[1]=st2;\n\t\tstr[2]=st3;\n\t\tstr[3]=st4;\n\t}\n};\n\nbool operator<(const data &d1,const data &d2){\n\tfor(int i=0;i<3;i++){\n\t\tif(d1.str[i]!=d2.str[i])return d1.str[i]<d2.str[i];\n\t}\n\treturn d1.str[3]<d2.str[3];\n}\n\nclass data2{\npublic:\n\tdata d[2];\n\tdata2(){}\n\tdata2(data d1,data d2){\n\t\td[0]=d1;\n\t\td[1]=d2;\n\t}\n\tbool same(){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(d[0].str[i]!=d[1].str[i])return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nbool operator<(const data2 &d1,const data2 &d2){\n\tfor(int i=0;i<4;i++){\n\t\tif(d1.d[0].str[i]!=d2.d[0].str[i])return d1.d[0].str[i]<d2.d[0].str[i];\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tif(d1.d[1].str[i]!=d2.d[1].str[i])return d1.d[1].str[i]<d2.d[1].str[i];\n\t}\n\treturn d1.d[1].str[3]<d2.d[1].str[3];\n}\n\nstring str[8];\nint cnt[2][4];\nset<data> dat;\nset<data2> checked;\nint id[4];\nbool used[8];\nvoid dfs(int bit,int b,int v){\n\tif(v==4){\n\t\tbool ok=true;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tdl.str[j]=str[id[(i+j)%4]];\n\t\t\t}\n\t\t\tif(dat.find(dl)!=dat.end())ok=false;\n\t\t}\n\t\tif(ok){\n\t\t\tdata dl;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tdl.str[j]=str[id[j]];\n\t\t\t}\n\t\t\tdat.insert(dl);\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif((bit >> i & 1)==b && !used[i]){\n\t\t\t\tid[v]=i;\n\t\t\t\tused[i]=true;\n\t\t\t\tdfs(bit,b,v+1);\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(cin>>str[0]){\n\t\tll res=0,res2=0;\n\t\tfor(int i=1;i<8;i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tchecked.clear();\n\t\tfor(int i=0;i<(1<<8);i++){\n\t\t\tdata2 du;\n\t\t\tif(__builtin_popcount(i)!=4)continue;\n\t\t\tint cn[2]={0,0,};\n\t\t\tfor(int j=0;j<8;j++){\n\t\t\t\tif(i>>j & 1)du.d[1].str[cn[1]++]=str[j];\n\t\t\t\telse du.d[0].str[cn[0]++]=str[j];\n\t\t\t}\n\t\t\tsort(du.d[0].str,du.d[0].str+4);\n\t\t\tsort(du.d[1].str,du.d[1].str+4);\n\t\t\tif(checked.find(du)!=checked.end())continue;\n\t\t\tll all=1;\n\t\t\tdat.clear();\n\t\t\tdfs(i,0,0);\n\t\t\tall*=dat.size();\n\t\t\tdat.clear();\n\t\t\tdfs(i,1,0);\n\t\t\tall*=dat.size();\n\t\t\tif(du.same())res+=all;\n\t\t\telse res2+=all;\n\t\t\tchecked.insert(du);\n\t\t}\n\t\tprintf(\"%lld\\n\",res+res2/2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint color[8];\nmap<string,int> used;\nset<int> S;\nint t;\n\nvoid rot1(){\n  rep(i,3)swap(color[i],color[i+1]);\n  rep(i,3)swap(color[i+4],color[i+5]);\n}\n\nvoid rot2(){\n  swap(color[0],color[4]);  swap(color[1],color[5]);\n  swap(color[4],color[7]);  swap(color[5],color[6]);\n  swap(color[7],color[1]);  swap(color[6],color[2]);\n}\n\nbool check(){\n  int s=0;\n  rep(i,8)s=s*10+color[i];\n  t=s;\n  return S.count(t)!=0;\n}\n\nvoid solve(){\n  S.clear();\n  int num[8];\n  int cp[8];\n  rep(i,8)num[i]=i,cp[i]=color[i];\n  do{\n    rep(i,8)color[i]=cp[num[i]];\n    bool f=false;\n    rep(i,4){ rot1();\n      rep(j,4){ rot2();\n\trep(k,4){ rot1();\n\t  if(check())f=true;\n\t}\n      }\n    }\n    if(!f){\n      S.insert(t);\n      cout<<t<<endl;\n    }\n  }while(next_permutation(num,num+8));\n  \n  rep(i,8)color[i]=2;\n  color[0]=1;\n  color[6]=1;\n  bool f=false;\n  rep(i,4){ rot1();\n    rep(j,4){ rot2();\n      rep(k,4){ rot1();\n\tif(check())f=true;\n      }\n    }\n  }\n  cout<<f<<endl;\n  \n  cout<<S.size()<<endl;\n}\nstring in[8];\nint main(){\n  while(cin>>in[7]){\n    rep(i,7)cin>>in[i];\n    used.clear();\n    int Num=1;\n    rep(i,8){\n      if(!used.count(in[i]))\n\tused[in[i]]=Num++;\n      color[i]=used[in[i]];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\nusing namespace std;\n\nstruct Oct {\n    int c[8];\n    bool operator<(const Oct &rhs) const {\n        for (int j=0;j<8;++j) {\n            if (c[j]<rhs.c[j]) return true;\n            else if (c[j]>rhs.c[j]) return false;\n        }\n        return false;\n    }\n};\n\nstring color[8];\nint col[8];\nmap<string,int> mp;\n\nOct x_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[2];\n    rt.c[2]=ot.c[6];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[0];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[4];\n    return rt;\n}\n\nOct y_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[4];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[3];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[5];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[2];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct z_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[1];\n    rt.c[3]=ot.c[2];\n    rt.c[4]=ot.c[7];\n    rt.c[5]=ot.c[4];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct gOct;\nOct sortOct[64];\nset<Oct> ans;\n\nvoid calc(int depth, int pos) {\n    if (depth == 8) {\n        Oct temp = gOct;\n        for (int x = 0; x < 4; x++) {\n            for (int y = 0; y < 4; y++) {\n                for (int z = 0; z < 4; z++) {\n                    sortOct[x + y * 4 + z * 16] = temp;\n                    temp = z_rot(temp);\n                }\n                temp = y_rot(temp);\n            }\n            temp = x_rot(temp);\n        }\n        sort(sortOct, sortOct + 64);\n        ans.insert(sortOct[0]);\n        return;\n    }\n    for (int i = 0; i < 8; i++) {\n        if ((pos >> i) & 1) { continue; }\n        gOct.c[depth] = col[i];\n        calc(depth + 1, pos | (1 << i));\n    }\n}\n\n\nint main()\n{\nwhile (true) {\nans.clear();mp.clear();\n    for (int j=0;j<8;++j)\n        if (!(cin >> color[j])) { return 0; }\n    for (int j=0;j<8;++j) {\n        if (mp.find(color[j])!=mp.end())\n            col[j]=mp[color[j]];\n        else {\n            col[j]=mp.size();\n            mp[color[j]]=col[j];\n        }\n    }\n\n    calc(0,0);\n    cout << ans.size() << endl;\n}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(c,i,n) c + (i), c + (i) + (n)\n\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n//// etc ////\n\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n//// dice ////\n\ntemplate<class T>\nstruct Dice\n{\n\t/* v as 天一地六東五西二南三北四\n\t  |3|\n\t|1|0|4|5|\n\t  |2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Dice &rhs) const { return lexicographical_compare(apartof(v, 0, 6), apartof(rhs.v, 0, 6)); }\n};\n\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as \n\t\t/0\\/1\\/2\\/3\\\n\t\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(apartof(v, 0, 8), apartof(rhs.v, 0, 8)); }\n};\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tauto colors = read<string>(8);\n\t\tif (cin.eof()) { break; }\n\n\t\tsort(allof(colors));\n\t\tset<Octahedra<string>> visited;\n\t\tdo \n\t\t{\n\t\t\tOctahedra<string> octa;\n\t\t\tcopy(allof(colors), octa.v);\n\t\t\tbool found = false;\n\t\t\t\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tREP(j, 4)\n\t\t\t\t{\n\t\t\t\t\tREP(k, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (visited.count(octa)) { found = true; goto found; }\n\t\t\t\t\t\tocta.rotateLeft();\n\t\t\t\t\t}\n\t\t\t\t\tocta.rotateDown();\n\t\t\t\t}\n\t\t\t\tocta.rotateCw();\n\t\t\t}\n\n\t\t\tfound:\n\t\t\tif (!found)\t{ visited.insert(octa); }\n\t\t\t\n\t\t} while (next_permutation(allof(colors)));\n\t\twrite(visited.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n// 24ñÅ³ÉàÇé\n/*\nzñÆ_CXÌÊÌÖW\nc0ÍRXgN^ÌøÅ^¦çêéxN^Ìvf\n0 c4 0 0\nc3 c0 c2 c5\n0 c1 0 0\n*/\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\nprivate:\n\tint face[3][4];\npublic:\n\tvector<int> colored;\n\tint getFace(const int idx)const{\n\t\tif(idx==0)return face[1][1];\n\t\telse if(idx==1)return face[2][1];\n\t\telse if(idx==2)return face[1][2];\n\t\telse if(idx==3)return face[1][0];\n\t\telse if(idx==4)return face[0][1];\n\t\telse if(idx==5)return face[1][3];\n\t\treturn -1;\n\t}\n\tDice(const vector<int> &v){\n\t\tinit();\n\t\tfor(int i=0;i<8;i++)colored.push_back(v[i]);\n//\t\tface[1][1]=v[0];\n//\t\tface[2][1]=v[1];\n//\t\tface[1][2]=v[2];\n//\t\tface[1][0]=v[3];\n//\t\tface[0][1]=v[4];\n//\t\tface[1][3]=v[5];\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tfor(int i=0;i<3;i++)for(int j=0;j<4;j++)face[i][j]=-1;\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n\t\t\tint tmp = face[2][1];\n\t\t\tface[2][1]=face[1][2];\n\t\t\tface[1][2]=face[0][1];\n\t\t\tface[0][1]=face[1][0];\n\t\t\tface[1][0]=tmp;\n\t\t\tround++;\n\t\t\t// z²ðSÉñ]\n\t\t\tint tp[8];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ttp[(i+1)%4]=colored[i];\n\t\t\t\ttp[(i+1)%4+4]=colored[i+4];\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n\t\t\t\tint tmp = face[1][3];\n\t\t\t\tfor(int i = 2; i >= 0; i--)\n\t\t\t\t\tface[1][i+1]=face[1][i];\n\t\t\t\tface[1][0]=tmp;\n\t\t\t\tyoko++;\n\t\t\t\tint tp[8];\n\t\t\t\ttp[0]=colored[4];\n\t\t\t\ttp[1]=colored[5];\n\t\t\t\ttp[4]=colored[7];\n\t\t\t\ttp[5]=colored[6];\n\t\t\t\ttp[2]=colored[1];\n\t\t\t\ttp[3]=colored[0];\n\t\t\t\ttp[7]=colored[3];\n\t\t\t\ttp[6]=colored[2];\n\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\tint loop=1;\n\t\t\t\t\tif(tate==1)loop=2;\n\t\t\t\t\twhile(loop--){\n\t\t\t\t\t\ttate++;\n\t\t\t\t\t\tint tmp = face[1][3];\n\t\t\t\t\t\tface[1][3]=face[0][1];\n\t\t\t\t\t\tfor(int i = 0; i < 2; i++)\n\t\t\t\t\t\t\tface[i][1]=face[i+1][1];\n\t\t\t\t\t\tface[2][1]=tmp;\n\t\t\t\t\t}\n\t\t\t\t\tint tp[8];\n\t\t\t\t\ttp[7]=colored[3];\n\t\t\t\t\ttp[4]=colored[0];\n\t\t\t\t\ttp[6]=colored[7];\n\t\t\t\t\ttp[5]=colored[4];\n\t\t\t\t\ttp[2]=colored[6];\n\t\t\t\t\ttp[1]=colored[5];\n\t\t\t\t\ttp[3]=colored[2];\n\t\t\t\t\ttp[0]=colored[1];\n\t\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nint main() {\n\tint cs[8];\n\tstring s;\n\twhile (getline(cin, s)) {\n\t\tmap<string,int> idxs;\n\t\tint idx=0;\n\t\tistringstream iss(s);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tstring ts;\n\t\t\tiss>>ts;\n\t\t\tif(idxs.find(ts)==idxs.end())idxs[ts]=idx++;\n\t\t\tcs[i]=idxs[ts];\n\t\t}\n\t\tset<vector<int> > svs;\n\t\tint cnt=0;\n\t\tdo{\n\t\t\tvector<int> init;\n\t\t\tfor(int i=0;i<8;i++)init.push_back(cs[i]);\n\t\t\tDice d(init);\n\t\t\t// ¡Ìhèûªp^[ÌÇê©Éêv·é©`FbN\n\t\t\tif(svs.find(d.colored)==svs.end()){\n\t\t\t\tcnt++;\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tsvs.insert(d.colored);\n\t\t\t\t\td.rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(cs,cs+8));\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(vs ss(8);cin>>ss[0];){\n\t\trepi(i,1,8) cin>>ss[i];\n\t\t\n\t\tmap<string,int> f;\n\t\trep(i,8) if(!f.count(ss[i])) f.insert(mp(ss[i],f.size()));\n\t\t\n\t\tvi a(8);\n\t\trep(i,8) a[i]=f[ss[i]];\n\t\tsort(all(a));\n\t\t\n\t\tset<vi> res;\n\t\tdo{\n\t\t\tvi b=a;\n\t\t\trep(_,2){\n\t\t\t\trep(_,4){\n\t\t\t\t\tb=min(b,vi({a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7]}));\n\t\t\t\t\tb=min(b,vi({a[0],a[4],a[5],a[1],a[3],a[7],a[6],a[2]}));\n\t\t\t\t\tb=min(b,vi({a[0],a[3],a[7],a[4],a[1],a[2],a[6],a[5]}));\n\t\t\t\t\trotate(0+begin(a),1+begin(a),4+begin(a));\n\t\t\t\t\trotate(4+begin(a),5+begin(a),8+begin(a));\n\t\t\t\t}\n\t\t\t\treverse(all(a));\n\t\t\t}\n\t\t\tres.insert(b);\n\t\t}while(next_permutation(all(a)));\n\t\t\n\t\tcout<<res.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\n#include<string>\n#include<set>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\ntypedef array<string,8> O;\n\nset<O> s;\n\nvoid rot(O &o,vector<int> v){\n  auto t=o[v[0]];\n  for(int i=0;i+1<v.size();i++){\n    o[v[i]]=o[v[i+1]];\n  }\n  o[v.back()]=t;\n}\n\nvoid dfs(O o){\n  if(s.insert(o).second){\n    O n1=o;\n    rot(n1,{0,1,2,3});\n    rot(n1,{4,5,6,7});\n    dfs(n1);\n    O n2=o;\n    rot(n2,{0,1,5,4});\n    rot(n2,{3,2,6,7});\n    dfs(n2);\n    O n3=o;\n    rot(n3,{0,3,7,4});\n    rot(n3,{1,2,6,5});\n    dfs(n3);\n  }\n}\n\nint main(){\n  for(;;){\n    O o;\n    for(auto &e:o){\n      cin>>e;\n    }\n    if(!cin)break;\n    s.clear();\n    sort(begin(o),end(o));\n    int a=0;\n    do{\n      if(s.count(o)==0){\n\ta++;\n\tdfs(o);\n      }\n    }while(next_permutation(begin(o),end(o)));\n    cout<<a<<endl;\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n//#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid solve() {\n    string s;\n    while (cin >> s) {\n        vector<string> inputs;\n        inputs.push_back(s);\n        REP(i, 7) {\n            cin >> s;\n            inputs.push_back(s);\n        }\n        map<string, int> go;\n        vector<int> cnter;\n        REP(i, 8) {\n            go[inputs[i]]++;\n        }\n        int now = 0;\n        for (auto i : go) {\n            REP(q, i.second) {\n                cnter.push_back(now);\n            }\n            now++;\n        }\n        int ans = 0;\n        set<vector<int>> trying;\n        do {\n            if (trying.count(cnter)) continue;\n            ans++;\n            vector<int> now = cnter;\n            queue<vector<int>> next;\n            trying.insert(now);\n            next.push(now);\n            while (next.empty() == false) {\n                vector<int> now = next.front();\n                next.pop();\n                vector<int> tmp = now;\n                for (int q = 2; q < 8; ++q) {\n                    swap(now[q - 2], now[q]);\n                }\n                if (trying.count(now) == 0) {\n                    trying.insert(now);\n                    next.push(now);\n                }\n                now = tmp;\n                tmp[0] = now[1];\n                tmp[2] = now[3];\n                tmp[6] = now[0];\n                tmp[4] = now[2];\n                tmp[1] = now[7];\n                tmp[3] = now[5];\n                tmp[5] = now[4];\n                tmp[7] = now[6];\n                if (trying.count(tmp) == 0) {\n                    trying.insert(tmp);\n                    next.push(tmp);\n                }\n            }\n        } while (next_permutation(ALL(cnter)));\n        cout << ans << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll base = 211;\nconstexpr ll M = 1000000000000037LL;\n\nll get_hash(vector<string> const& v) {\n    hash<string> hash_fn;\n    ll res = 0;\n    for(int i=0; i<v.size(); ++i) {\n        res = (hash_fn(v[i]) + res * base) % M;\n    }\n    return res;\n}\n\nint main() {\n    vector<string> panels(8);\n    while(cin >> panels[0]) {\n        for(int i=1; i<8; ++i) {\n            cin >> panels[i];\n        }\n        sort(panels.begin(), panels.end());\n\n        set<ll> s;\n        vector<int> rot1 = {2, 3, 4, 5, 6, 7, 0, 1};\n        vector<int> rot2 = {5, 4, 3, 2, 1, 0, 7, 6};\n        vector<int> rot3 = {0, 6, 1, 7, 3, 5, 2, 4};\n        int res = 0;\n        do {\n            vector<string> v = panels;\n            set<ll> ss;\n            for(int i=0; i<2; ++i) {\n                for(int j=0; j<2; ++j) {\n                    for(int k=0; k<4; ++k) {\n                        ss.insert(get_hash(v));\n                        vector<string> next(8);\n                        for(int l=0; l<8; ++l) {\n                            next[l] = move(v[rot1[l]]);\n                        }\n                        v = move(next);\n                    }\n                    vector<string> next(8);\n                    for(int l=0; l<8; ++l) {\n                        next[l] = move(v[rot2[l]]);\n                    }\n                    v = move(next);\n                }\n                vector<string> next(8);\n                for(int l=0; l<8; ++l) {\n                    next[l] = move(v[rot3[l]]);\n                }\n                v = move(next);\n            }\n            bool f = false;\n            for(auto hs : ss) {\n                f |= s.count(hs);\n            }\n            res += !f;\n            s.insert(ss.begin(), ss.end());\n        } while(next_permutation(panels.begin(), panels.end()));\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> t,u;\nset< vector<string> > s;\n\nint func(){\n  if(s.find(t)!=s.end())return 0;\n  string tmp;\n  \n  for(int i=0;i<2;i++){\n    swap(t[0],t[4]);\n    swap(t[2],t[6]);\n    swap(t[1],t[7]);\n    swap(t[3],t[5]);\n    for(int j=0;j<4;j++){\n      tmp=t[0];\n      t[0]=t[1];\n      t[1]=t[2];\n      t[2]=t[3];\n      t[3]=tmp;\n      \n      tmp=t[4];\n      t[4]=t[5];\n      t[5]=t[6];\n      t[6]=t[7];\n      t[7]=tmp;\n      for(int k=0;k<3;k++){\n        tmp=t[1];\n        t[1]=t[4];\n        t[4]=t[3];\n        t[3]=tmp;\n\n        tmp=t[5];\n        t[5]=t[7];\n        t[7]=t[2];\n        t[2]=tmp;\n        s.insert(t);\n      }\n    }\n  }\n  if(u!=t)cout<<'a'<<endl;\n  return 1;\n}\n\nint main(){\n  t.resize(8);\n  while(cin>>t[0]){\n    s.clear();\n    for(int i=1;i<8;i++)cin>>t[i];\n    u=t;\n    sort(u.begin(),u.end());\n    int ans=0;\n    do{\n      t=u;\n      ans+=func();\n    }while(next_permutation(u.begin(),u.end()));\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nmap<string,int>::iterator it;\nvector<int> x, y, v;\nset<vector<int> > se;\n\nvoid solve(){\n\tm.clear();\n\tse.clear();\n\tx.clear();\n\tx.resize(8);\n\tint cnt = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trep(i,8) x[i] = i;\n\tdo{\n\t\ty = x;\n\t\tbool ok = true;\n\t\trep(i,6){\n\t\t\tv.clear();\n\t\t\trep(j,8) v.push_back(m[str[y[j]]]);\n\t\t\tif(se.count(v) > 0){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(y[4],y[1]); swap(y[1],y[2]); swap(y[3],y[5]); swap(y[6],y[3]);\n\t\t}\n\t\tif(ok) se.insert(v);\n\t} while(next_permutation(x.begin()+1,x.end()));\n\tcout << se.size() << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nconst int N=23;\nint f[N][8] = {\n    {1,2,3,0,5,6,7,4},\n    {2,3,0,1,6,7,4,5},\n    {3,0,1,2,7,4,5,6},\n    {4,7,6,5,0,3,2,1},\n    {5,4,7,6,1,0,3,2},\n    {6,5,4,7,2,1,0,3},\n    {7,6,5,4,3,2,1,0},\n    {0,3,7,4,1,2,6,5},\n    {3,7,4,0,2,6,5,1},\n    {7,4,0,3,6,5,1,2},\n    {4,0,3,7,5,1,2,6},\n    {1,5,6,2,0,4,7,3},\n    {5,6,2,1,4,7,3,0},\n    {6,2,1,5,7,3,0,4},\n    {2,1,5,6,3,0,4,7},\n    {0,4,5,1,3,7,6,2},\n    {4,5,1,0,7,6,2,3},\n    {5,1,0,4,6,2,3,7},\n    {1,0,4,5,2,3,7,6},\n    {3,2,6,7,0,1,5,4},\n    {2,6,7,3,1,5,4,0},\n    {6,7,3,2,5,4,0,1},\n    {7,3,2,6,4,0,1,5},\n};\n\nvi normalize(const vi& v)\n{\n    vi ret(v);\n\n    rep(i,N)\n    {\n        vi tmp(8);\n        rep(j,8) tmp[j] = v[f[i][j]];\n\n        ret = min(ret,tmp);\n    }\n\n    return ret;\n}\n\nint main()\n{\n    string s[8];\n    while(cin >>s[0])\n    {\n        for(int i=1; i<8; ++i) cin >>s[i];\n\n        vi a(8);\n\n        map<string,int> col;\n        int now=0;\n        rep(i,8)\n        {\n            if(col.find(s[i]) == col.end()) col[s[i]]=now++;\n            a[i] = col[s[i]];\n        }\n\n        sort(all(a));\n\n        set<vi> octahedra;\n\n        do {\n            vi norm = normalize(a);\n            octahedra.insert(norm);\n        } while(next_permutation(all(a)));\n\n        cout << octahedra.size() << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    auto equal=[](const vector<int>& x,const vector<int>& y){\n        auto equal_=[](vector<int> a,vector<int> b){\n            auto equal__=[&]{\n                rep(i,0,4){\n                    bool ok=true;\n                    rep(j,0,4) if(a[j]!=b[(i+j)%4] or a[4+j]!=b[(4+i+j>=8?i+j:4+i+j)]){\n                        ok=false;\n                        break;\n                    }\n                    if(ok) return true;\n                }\n                return false;\n            };\n            if(equal__()) return true;\n            reverse(b.begin(),b.end());\n            return equal__();\n        };\n        if(equal_(x,y)) return true;\n        vector<int> tmp(8);\n        const int idx1[]={0,4,5,1,3,7,6,2};\n        const int idx2[]={0,3,7,4,1,2,6,5};\n        rep(i,0,8) tmp[i]=y[idx1[i]];\n        if(equal_(x,tmp)) return true;\n        rep(i,0,8) tmp[i]=y[idx2[i]];\n        return equal_(x,tmp);\n    };\n    string tmp;\n    while(cin >> tmp){\n        vector<string> color(8);\n        color[0]=tmp;\n        rep(i,1,8) cin >> color[i];\n\n        map<string,int> mp;\n        int cnt=0;\n        rep(i,0,8) if(mp.find(color[i])==mp.end()){\n            mp[color[i]]=cnt;\n            ++cnt;\n        }\n        vector<int> v(8);\n        rep(i,0,8) v[i]=mp[color[i]];\n        sort(v.begin(),v.end());\n\n        vector<vector<int>> all;\n        do{\n            bool ok=true;\n            for(const auto& a:all) if(equal(v,a)){\n                ok=false;\n                break;\n            }\n            if(ok) all.emplace_back(v);\n        }while(next_permutation(v.begin(),v.end()));\n\n        cout << all.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Vec;\nvoid rotatex(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[2];a[2]=a[3];a[3]=tmp;\n  tmp=a[4];a[4]=a[5];a[5]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatey(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[5];a[5]=a[4];a[4]=tmp;\n  tmp=a[3];a[3]=a[2];a[2]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatez(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[4];a[4]=a[7];a[7]=a[3];a[3]=tmp;\n  tmp=a[1];a[1]=a[5];a[5]=a[6];a[6]=a[2];a[2]=tmp;\n}\n\nint main(){\n  string s[8];\n  while(cin>>s[0]){\n    int i,j,k,ans=0;\n    for(i=1;i<8;i++) cin>>s[i];\n    sort(s,s+8);\n    set<string> ss;\n    set<Vec> sv;\n    Vec v;\n    for(i=0;i<8;i++) ss.insert(s[i]),v.push_back(ss.size()-1);\n    do{\n      if(sv.find(v)!=sv.end()) continue;\n      ans++;\n      for(i=0;i<4;i++){\n\trotatez(v);\n\tfor(j=0;j<4;j++){\n\t  rotatey(v);\n\t  for(k=0;k<4;k++){\n\t    rotatex(v);\n\t    sv.insert(v);\n\t  }\n\t}\n      }\n    }while(next_permutation(v.begin(),v.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvoid spinface(vector<string> &a){\n    swap(a[0], a[1]);\n    swap(a[1], a[2]);\n    swap(a[2], a[3]);\n    swap(a[4], a[5]);\n    swap(a[5], a[6]);\n    swap(a[6], a[7]);\n}\n\nvoid spindiag(vector<string> &a){\n    swap(a[1], a[3]);\n    swap(a[3], a[4]);\n    swap(a[2], a[7]);\n    swap(a[7], a[5]);\n}\n\nvoid turnupdown(vector<string> &a){\n    swap(a[0], a[4]);\n    swap(a[1], a[7]);\n    swap(a[2], a[6]);\n    swap(a[3], a[5]);\n}\n\nint main(){\n    vector<string> s(8);\n    while(cin >> s[0]){\n        for(int i=1; i<8; i++) cin >> s[i];\n        map<vector<string> ,bool> cases;\n        sort(s.begin(), s.end());\n        do{\n            bool used = false;\n            for(int i=0; i<8; i++){\n                for(int j=0; j<3; j++){\n                    if(cases.count(s)!=0){\n                        used = true;\n                    }\n                    spindiag(s);\n                }\n                spinface(s);\n                if(i%4==3){\n                    turnupdown(s);\n                }\n            }\n            if(!used){\n                cases[s] = true;\n            }\n        }while(next_permutation(s.begin(), s.end()));\n        cout << cases.size() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nmap<int,int>Map;\nint N[8];\nint n[8];\nint ans=0;\n\nvoid rot1(){\n\tint p[8];\n\t\n\tp[0]=n[1];\n\tp[1]=n[2];\n\tp[2]=n[3];\n\tp[3]=n[0];\n\tp[4]=n[5];\n\tp[5]=n[6];\n\tp[6]=n[7];\n\tp[7]=n[4];\n\t\n\tfor(int i=0;i<8;i++)n[i]=p[i];\n}\n\nvoid rot2(){\n\tint p[8];\n\t\n\tp[0]=n[3];\n\tp[1]=n[2];\n\tp[2]=n[6];\n\tp[3]=n[7];\n\tp[4]=n[0];\n\tp[5]=n[1];\n\tp[6]=n[5];\n\tp[7]=n[4];\n\t\n\tfor(int i=0;i<8;i++)n[i]=p[i];\n}\n\nvoid rot3(){\n\tint p[8];\n\t\n\tp[0]=n[1];\n\tp[1]=n[5];\n\tp[2]=n[6];\n\tp[3]=n[2];\n\tp[4]=n[0];\n\tp[5]=n[4];\n\tp[6]=n[7];\n\tp[7]=n[3];\n\t\n\tfor(int i=0;i<8;i++)n[i]=p[i];\n}\n\n\nint INT(){\n\tint t=0;\n\tfor(int i=0;i<8;i++){\n\t\tt=t*10+n[i];\n\t}\n\treturn t;\n}\n\nvoid cal(){\n\tint p[8];\n\tfor(int i=0;i<8;i++)p[i]=n[i];\n\tint f=1;\n\tfor(int x=0;x<4;x++){\n\t\tfor(int y=0;y<4;y++){\n\t\t\tfor(int z=0;z<4;z++){\n\t\t\t\tfor(int i=0;i<8;i++)n[i]=p[i];\n\t\t\t\tfor(int i=0;i<x;i++)rot1();\n\t\t\t\tfor(int i=0;i<y;i++)rot2();\n\t\t\t\tfor(int i=0;i<z;i++)rot3();\n\t\t\t\tint t=INT();\n\t\t\t\tif(Map[t])f=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(f){\n\t\tint t=INT();\n\t\tans++;\n\t\tMap[t]=1;\n\t}\n\t\n}\n\nint main(){\n\t\n\tstring t[8];\n\twhile(cin>>t[0]){\n\t\t\n\t\tfor(int i=1;i<8;i++){\n\t\t\tcin>>t[i];\n\t\t}\n\t\tans=0;\n\t\tmap<string , int>M;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(M[t[i]]){\n\t\t\t\tN[i]=M[t[i]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnt++;\n\t\t\t\tM[t[i]]=cnt;\n\t\t\t\tN[i]=M[t[i]];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tsort(N,N+8);\n\t\tdo{\n\t\t\tfor(int i=0;i<8;i++)n[i]=N[i];\n\t\t\tcal();\n\t\t}while(next_permutation(N,N+8));\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int N = 8;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef map<string,int> msi;\ntypedef map<vi,bool> mvib;\n\n/* global variables */\n\nmsi cid;\nmvib cache;\n\n/* subroutines */\n\nvoid rotx(vi& dc) {\n  vi dc0(dc);\n  dc[0] = dc0[1], dc[1] = dc0[3], dc[3] = dc0[2], dc[2] = dc0[0];\n  dc[4] = dc0[5], dc[5] = dc0[7], dc[7] = dc0[6], dc[6] = dc0[4];\n}\n\nvoid roty(vi& dc) {\n  vi dc0(dc);\n  dc[0] = dc0[4], dc[4] = dc0[5], dc[5] = dc0[1], dc[1] = dc0[0];\n  dc[2] = dc0[6], dc[6] = dc0[7], dc[7] = dc0[3], dc[3] = dc0[2];\n}\n\nvoid rotz(vi& dc) {\n  vi dc0(dc);\n  dc[0] = dc0[2], dc[2] = dc0[6], dc[6] = dc0[4], dc[4] = dc0[0];\n  dc[1] = dc0[3], dc[3] = dc0[7], dc[7] = dc0[5], dc[5] = dc0[1];\n}\n\n/* main */\n\nint main() {\n  mvib rimap;\n  vi idx(N);\n  for (int i = 0; i < N; i++) idx[i] = i;\n\n  for (int x = 0; x < 4; x++, rotx(idx))\n    for (int y = 0; y < 4; y++, roty(idx))\n      for (int z = 0; z < 4; z++, rotz(idx))\n\tif (rimap.find(idx) == rimap.end()) rimap[idx] = true;\n  //cout << rimap.size() << endl;\n\n  vvi ridx;\n  for (mvib::iterator mit = rimap.begin(); mit != rimap.end(); mit++)\n    ridx.push_back(mit->first);\n  \n  for (;;) {\n    string cstr;\n    cin >> cstr;\n    if (cin.eof()) break;\n\n    int id = 0;\n    cid.clear();\n    vi dc(N);\n\n    dc[0] = id;\n    cid[cstr] = id++;\n\n    for (int i = 1; i < N; i++) {\n      cin >> cstr;\n      if (cid.find(cstr) == cid.end()) {\n\tdc[i] = id;\n\tcid[cstr] = id++;\n      }\n      else\n\tdc[i] = cid[cstr];\n    }\n\n    for (int i = 0; i < N; i++) idx[i] = i;\n\n    cache.clear();\n    vi dcr(N), dcr0(N);\n    int count = 0;\n    \n    do {\n      for (int i = 0; i < N; i++) dcr[i] = dc[idx[i]];\n\n      if (cache.find(dcr) == cache.end()) {\n\t//for (int i = 0; i < N; i++) cout << dcr[i]; cout << endl;\n\tcount ++;\n\n\tfor (vvi::iterator vit = ridx.begin(); vit != ridx.end(); vit++) {\n\t  for (int i = 0; i < N; i++) dcr0[i] = dcr[(*vit)[i]];\n\t  cache[dcr0] = true;\n\t}\n      }\n    } while (next_permutation(idx.begin(), idx.end()));\n\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int r[][8] = {\n\t{1, 2, 3, 0, 5, 6, 7, 4},\n\t{1, 5, 6, 2, 0, 4, 7, 3}\n};\nset<int> s;\nvoid rec(const vi &v){\n\tint h = 0;\n\trep(i, 7) h *= 8, h += v[i];\n\tif(s.count(h)) return;\n\ts.insert(h);\n\t\n\trep(d, 2){\n\t\tvi nv;\n\t\trep(i, 8) nv.pb(v[r[d][i]]);\n\t\trec(nv);\n\t}\n}\nint main(){\n\tstring in[8];\n\twhile(cin >> in[0]){\n\t\trep(i, 7) cin >> in[i + 1];\n\t\tmap<string, int> m;\n\t\trep(i, 8) m[in[i]]++;\n\t\tvi v;\n\t\tint k = 0, ans = 0;\n\t\teach(i, m){\n\t\t\trep(j, i->second) v.pb(k);\n\t\t\tk++;\n\t\t}\n\t\ts.clear();\n\t\tdo{\n\t\t\tint h = 0;\n\t\t\trep(i, 7) h *= 8, h += v[i];\n\t\t\tif(!s.count(h)){\n\t\t\t\trec(v);\n\t\t\t\tans++;\n\t\t\t}\n\t\t}while(next_permutation(all(v)));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    vvi perm;\n    perm.push_back({0, 1, 3, 4, 2, 7, 5, 6});\n    perm.push_back({0, 3, 4, 1, 7, 5, 2, 6});\n    perm.push_back({0, 4, 1, 3, 5, 2, 7, 6});\n\n    perm.push_back({1, 2, 0, 5, 3, 4, 6, 7});\n    perm.push_back({1, 0, 5, 2, 4, 6, 3, 7});\n    perm.push_back({1, 5, 2, 0, 6, 3, 4, 7});\n\n    perm.push_back({2, 3, 1, 6, 0, 5, 7, 4});\n    perm.push_back({2, 1, 6, 3, 5, 7, 0, 4});\n    perm.push_back({2, 6, 3, 1, 7, 0, 5, 4});\n\n    perm.push_back({3, 0, 2, 7, 1, 6, 4, 5});\n    perm.push_back({3, 2, 7, 0, 6, 4, 1, 5});\n    perm.push_back({3, 7, 0, 2, 4, 1, 6, 5});\n\n    perm.push_back({4, 0, 7, 5, 3, 6, 1, 2});\n    perm.push_back({4, 7, 5, 0, 6, 1, 3, 2});\n    perm.push_back({4, 5, 0, 7, 1, 3, 6, 2});\n\n    perm.push_back({5, 1, 4, 6, 0, 7, 2, 3});\n    perm.push_back({5, 4, 6, 1, 7, 2, 0, 3});\n    perm.push_back({5, 6, 1, 4, 2, 0, 7, 3});\n\n    perm.push_back({6, 2, 5, 7, 1, 4, 3, 0});\n    perm.push_back({6, 5, 7, 2, 4, 3, 1, 0});\n    perm.push_back({6, 7, 2, 5, 3, 1, 4, 0});\n\n    perm.push_back({7, 3, 6, 4, 2, 5, 0, 1});\n    perm.push_back({7, 6, 4, 3, 5, 0, 2, 1});\n    perm.push_back({7, 4, 3, 6, 0, 2, 5, 1});\n\n    string s;\n    vector<string> S;\n    while (cin >> s) {\n        S.push_back(s);\n        if (S.size() < 8) continue;\n        map<string,int> ord;\n        for (string t : S) ord[t] = -1;\n        int cnt = 0;\n        for (auto &tp : ord) tp.second = cnt++;\n\n        map<string,bool> sorted, mp;\n        vector<int> a(8);\n        iota(ALL(a), 0);\n\n        do {\n            set<string> codes;\n            bool exist = 0;\n            for (auto p : perm) {\n                string t;\n                for (int i : p) {\n                    t += to_string(ord[S[a[i]]]);\n                }\n                if (mp.count(t)) {\n                    exist = 1;\n                    break;\n                }\n                codes.insert(t);\n            }\n            if (exist) continue;\n            for (string t : codes) mp[t] = 1;\n            sorted[*min_element(ALL(codes))] = 1;\n        } while (next_permutation(ALL(a)));\n\n        cout << sorted.size() << endl;\n        S.clear();\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<vector>\nusing namespace std;\n\nmap<string,bool> M;\nmap<string,bool>::iterator Mp;\nvector<int> color;\nstring S;\nbool cb[8];\nint ans;\n\nvoid Check(string S)\n{\n  string C=S;\n  for(int i=0;i<4;i++){\n    for(int i=0;i<4;i++){\n      for(int i=0;i<4;i++){\n\tswap(C[0],C[1]);swap(C[1],C[5]);swap(C[5],C[4]);\n\tswap(C[3],C[2]);swap(C[2],C[6]);swap(C[6],C[7]);\n\tif(M[C])return;\n      }\n      swap(C[0],C[3]);swap(C[3],C[7]);swap(C[7],C[4]);\n      swap(C[1],C[2]);swap(C[2],C[6]);swap(C[6],C[5]);\n      if(M[C])return;\n    }\n    swap(C[0],C[1]);swap(C[1],C[2]);swap(C[2],C[3]);\n    swap(C[4],C[5]);swap(C[5],C[6]);swap(C[6],C[7]);\n    if(M[C])return;\n  }\n  M[C]=true;\n  ans++;\n}\n\nvoid make(int i)\n{\n  S+=(color[i]+'0');\n  if(S.length()==8){\n    Check(S);\n  }\n  else {\n    for(int i=0;i<8;i++){\n      if(cb[i])continue;\n      cb[i]=true;\n      make(i);\n      cb[i]=false;\n    }\n  }\n  S.erase(S.begin()+S.length()-1);\n}\n\nint main()\n{\n  string s[8];\n  while(cin>>s[0]){\n    for(int i=0;i<7;i++)cin>>s[i+1];\n    int a=1;\n    map<string,int> m;\n    color.clear();\n    M.clear();\n    m.clear();\n    for(int i=0;i<8;i++){\n      if(m[s[i]]==0){\n\tcolor.push_back(a);\n\tm[s[i]]=a;\n\ta++;\n      }\n      else color.push_back(m[s[i]]);\n    }\n    ans=0;\n    for(int i=0;i<8;i++){\n      S=\"\";\n      cb[i]=true;\n      make(i);\n      cb[i]=false;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 0;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 5 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 6 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\tint J = j, checker = 0;\n\t\t\tbool val = true;\n\t\t\tvector<int> y, z;\n\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\tx[k] = J%4;\n\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\tchecker += x[k];\n\t\t\t\tJ /= 4;\n\t\t\t}\n\t\t\tif(checker != 3) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\tif(checker == -1) continue;\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] != x[k]*2 && x[k] > 0) val = false;\n\t\t\tif(!val){\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1*2;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 2*2;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 9*2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans /= 2;\n\t\tlong long tmpans = 0;\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int i2 = i; i2 < f.size(); i2++){\n\t\t\t\tif(f[i2] <= 0) continue;\n\t\t\t\tf[i2]--;\n\t\t\t\tint tmp = 4*3*2*1;\n\t\t\t\tfor(int j = 1; j < f.size(); j++){\n\t\t\t\t\tif(f[j] <= 0) continue;\n\t\t\t\t\tfor(int k = f[j]; k >= 1; k--) tmp /= k;\n\t\t\t\t}\n\t\t\t\tif(i != i2){\n\t\t\t\t\ttmpans += tmp;\n\t\t\t\t} else{\n\t\t\t\t\tvector<int> y;\n\t\t\t\t\tfor(int j = 1; j < f.size(); j++) if(f[j] > 0) y.push_back(f[j]);\n\t\t\t\t\tif(y.size() == 1) tmpans += 1;\n\t\t\t\t\tif(y.size() == 2 && y[0] == 2) tmpans += 4;\n\t\t\t\t\telse{\n\t\t\t\t\t\ttmpans += tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i2]++;\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t\tans += tmpans*2;\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const int idx1[]={0,4,5,1,3,7,6,2};\n    const int idx2[]={0,3,7,4,1,2,6,5};\n    auto equal=[&](const vector<int>& x,const vector<int>& y){\n        auto equal_=[](vector<int> a,vector<int> b){\n            auto equal__=[&]{\n                rep(i,0,4){\n                    bool ok=true;\n                    rep(j,0,4) if(a[j]!=b[(i+j)%4] or a[4+j]!=b[(4+i+j>=8?i+j:4+i+j)]){\n                        ok=false;\n                        break;\n                    }\n                    if(ok) return true;\n                }\n                return false;\n            };\n            if(equal__()) return true;\n            reverse(b.begin(),b.end());\n            return equal__();\n        };\n        if(equal_(x,y)) return true;\n        vector<int> tmp(8);\n        rep(i,0,8) tmp[i]=y[idx1[i]];\n        if(equal_(x,tmp)) return true;\n        rep(i,0,8) tmp[i]=y[idx2[i]];\n        return equal_(x,tmp);\n    };\n    string tmp;\n    while(cin >> tmp){\n        vector<string> color(8);\n        color[0]=tmp;\n        rep(i,1,8) cin >> color[i];\n\n        map<string,int> mp;\n        int cnt=0;\n        rep(i,0,8) if(mp.find(color[i])==mp.end()){\n            mp[color[i]]=cnt;\n            ++cnt;\n        }\n        vector<int> v(8);\n        rep(i,0,8) v[i]=mp[color[i]];\n        sort(v.begin(),v.end());\n\n        vector<vector<int>> all;\n        do{\n            bool ok=true;\n            for(const auto& a:all) if(equal(v,a)){\n                ok=false;\n                break;\n            }\n            if(ok) all.emplace_back(v);\n        }while(next_permutation(v.begin(),v.end()));\n\n        cout << all.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvoid rotx(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[5];\tv[2]=t[1];\tv[3]=t[0];\n\tv[4]=t[7];\tv[5]=t[6];\tv[6]=t[2];\tv[7]=t[3];\n}\n\nvoid roty(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[0];\tv[2]=t[6];\tv[3]=t[2];\n\tv[4]=t[5];\tv[5]=t[1];\tv[6]=t[7];\tv[7]=t[3];\n}\n\nvoid rotz(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[0];\tv[2]=t[1];\tv[3]=t[2];\n\tv[4]=t[7];\tv[5]=t[4];\tv[6]=t[5];\tv[7]=t[6];\n}\n\nvi findRegularPaint(const vi &_a){\n\tvi a=_a,reg=a;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\treg=min(reg,a);\n\t\t\trotz(a);\n\t\t}\n\t\trotx(a);\n\t}\n\troty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\troty(a),roty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\n\treturn reg;\n}\n\nint vi2int(const vi &a){\n\tint res=0;\n\trep(i,a.size())\tres=res*10+a[i];\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tstring s[8];\n\t\trep(i,8) if(!(cin>>s[i])) return 0;\n\n\t\tvi clr(8);\n\t\t{\n\t\t\tint id=0;\n\t\t\tmap<string,int> colorid;\n\t\t\trep(i,8){\n\t\t\t\tif(colorid.count(s[i])==0)\tcolorid[s[i]]=id++;\n\t\t\t\tclr[i]=colorid[s[i]];\n\t\t\t}\n\t\t}\n\t\tsort(clr.begin(),clr.end());\n\n\t\tset<int> cube;\n\t\tdo{\n\t\t\tcube.insert(vi2int(findRegularPaint(clr)));\n\t\t}while(next_permutation(clr.begin(),clr.end()));\n\n\t\tcout<<cube.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint a[][4] = {{0, 1, 2, 3},\n              {4, 5, 6, 7},\n              {0, 1, 5, 4},\n              {3, 2, 6, 7},\n              {0, 4, 7, 3},\n              {1, 5, 6, 2}};\n\nint main()\n{\n    for(;;){\n        vector<string> s(8);\n        for(int i=0; i<8; ++i){\n            if(!(cin >> s[i]))\n                return 0;\n        }\n        sort(s.begin(), s.end());\n\n        set<vector<string> > x;\n        do{\n            vector<string> t = s;\n            bool ok = true;\n\n            for(int i=0; i<100; ++i){\n                int b = xor128() % 3;\n                for(int j=0; j<3; ++j){\n                    swap(t[a[b*2][j]], t[a[b*2][j+1]]);\n                    swap(t[a[b*2+1][j]], t[a[b*2+1][j+1]]);\n                }\n                if(x.find(t) != x.end()){\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok)\n                x.insert(s);\n        }while(next_permutation(s.begin(), s.end()));\n\n        cout << x.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 8;\n\narray<int, N> h = { 3, 0, 1, 2, 7, 4, 5, 6 }; // 横回転\narray<int, N> v = { 6, 5, 4, 7, 2, 1, 0, 3 }; // 上下反転\narray<int, N> r = { 7, 3, 2, 6, 4, 0, 1, 5 }; // 120度回転\n\narray<int, N> rotate(array<int, N> ar, array<int, N> x){\n\tauto ret = ar;\n\trep(i, N) ret[i] = ar[x[i]];\n\treturn ret;\n}\n\nset<array<int, N>> st;\n\nvoid insert(array<int, N> ar){\n\tauto flip = rotate(ar, v);\n\n\trep(i, 4){\n\t\trep(j, 3){\n\t\t\tst.insert(ar);\n\t\t\tst.insert(flip);\n\t\t\tar = rotate(ar, r);\n\t\t\tflip = rotate(flip, r);\n\t\t}\n\t\tar = rotate(ar, h);\n\t\tflip = rotate(flip, h);\n\t}\n}\n\n\nint main(){\n\n\tstring s[N];\n\twhile (1){\n\t\trep(i, N) cin >> s[i];\n\t\tif (!cin) break;\n\n\t\tst.clear();\n\t\tmap<string, int> m;\n\t\tarray<int, N> ar;\n\t\trep(i, N){\n\t\t\tif (m.count(s[i])) ar[i] = m[s[i]];\n\t\t\telse ar[i] = i, m[s[i]] = i;\n\t\t}\n\t\tsort(ALL(ar));\n\n\t\tint ans = 0;\n\t\tdo{\n\t\t\tans += !st.count(ar);\n\n\t\t\t//if (!st.count(ar)){\n\t\t\t//\trep(i, N) cout << ar[i] << ' ';\n\t\t\t//\tcout << endl;\n\t\t\t//}\n\n\t\t\tinsert(ar);\n\t\t} while (next_permutation(ALL(ar)));\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid rot(vector<string>& a, int i, int j, int k, int l) {\n\tswap(a[i], a[j]); swap(a[j], a[k]); swap(a[k], a[l]);\n}\n\nint main() {\n\tvector<string> a(8);\n\twhile (cin >> a[0]) {\n\t\tfor (int i = 1; i < 8; i++)\n\t\t\tcin >> a[i];\n\t\tsort(a.begin(), a.end());\n\t\tset< vector<string> > s;\n\t\tint cnt = 0;\n\t\tdo {\n\t\t\tif (s.count(a)) continue;\n\t\t\tcnt++;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\ts.insert(a);\n\t\t\t\t\trot(a, 0, 1, 2, 3);\n\t\t\t\t\trot(a, 4, 5, 6, 7);\n\t\t\t\t}\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\trot(a, 0, 3, 7, 4);\n\t\t\t\t\trot(a, 1, 2, 6, 5);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trot(a, 0, 4, 5, 1);\n\t\t\t\t\trot(a, 3, 7, 6, 2);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (next_permutation(a.begin(), a.end()));\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvector<int> a;\nbool f;\nset<vector<int> > s;\n\n\nvoid solve() {\n  rep(i,8) {\n    rep(k,4) {\n      rep(j,3) {\n        swap(a[j],a[j+1]);\n        swap(a[j+4],a[j+5]);\n      }\n      if(s.count(a)) f=1;\n    }\n    if(i==4) {\n      rep(j,3) {\n        swap(a[j],a[j+1]);\n        swap(a[j+4],a[j+5]);\n      }\n    }\n    swap(a[0],a[3]);\n    swap(a[3],a[7]);\n    swap(a[4],a[7]);\n    swap(a[1],a[2]);\n    swap(a[2],a[6]);\n    swap(a[5],a[6]);\n  }\n}\n\nvoid Main() {\n  string t[8];\n  while(R t[0]) {\n    REP(i,1,8) R t[i];\n    vector<int> b(8);\n    map<string,int> c;\n    s.clear();\n    rep(i,8) {\n      if(c[t[i]]) b[i]=c[t[i]];\n      else {\n        int x=c.size();\n        c[t[i]]=x;\n        b[i]=x;\n      }\n    }\n    sort(all(b));\n    do {\n      a=b;\n      f=0;\n      solve();\n      if(!f) s.in(b);\n    } while(next_permutation(all(b)));\n    pr(s.size());\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef vector<int> vi;\n\nint rot[] = {0,4,5,1,3,7,6,2};\nvector<vi> rots;\n\nvoid next(vi &x){\n  rep(i,3){\n    swap(x[i],x[i+1]);\n    swap(x[i+4],x[i+5]);\n  }\n}\n\nbool t[1<<24];\n\nint main(){\n  vi tmp;\n  rep(i,8)tmp.push_back(i);\n  rots.push_back(tmp);\n  rep(i,3){\n    next(tmp);\n    rots.push_back(tmp);\n  }\n\n  rep(i,4){\n    tmp = rots[i];\n    reverse(all(tmp));\n    rots.push_back(tmp);\n  }\n\n  rep(i,16){\n    tmp.resize(8);\n    rep(j,8)tmp[j] = rots[i][rot[j]];\n    rots.push_back(tmp);\n  }\n\n  string s;\n  while(cin >> s){\n    map<string,int> m;\n    m[s]++;\n    rep(i,7)cin >> s, m[s]++;\n    vi v;\n    int id=0;\n    for(map<string,int>::iterator it=m.begin();it!=m.end();it++){\n      rep(i,it->second)v.push_back(id);\n      id++;\n    }\n\n    int ans = 0;\n    rep(i,1<<24)t[i] = false;\n\n    do{\n      int h = 0;\n      rep(i,8)h*=8,h+=v[i];\n      if(!t[h]){\n\trep(i,24){\n\t  h = 0;\n\t  rep(j,8)h*=8,h+=v[rots[i][j]];\n\t  t[h] = true;\n\t}\n\tans++;\n      }\n    }while(next_permutation(all(v)));\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\nusing namespace std;\n\nstruct Oct {\n    int c[8];\n    bool operator<(const Oct &rhs) const {\n        for (int j=0;j<8;++j) {\n            if (c[j]<rhs.c[j]) return true;\n            else if (c[j]>rhs.c[j]) return false;\n        }\n        return false;\n    }\n};\n\nstring color[8];\nint col[8];\nmap<string,int> mp;\n\nOct x_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[2];\n    rt.c[2]=ot.c[6];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[0];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[4];\n    return rt;\n}\n\nOct y_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[4];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[3];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[5];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[2];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct z_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[1];\n    rt.c[3]=ot.c[2];\n    rt.c[4]=ot.c[7];\n    rt.c[5]=ot.c[4];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct gOct;\nOct sortOct[64];\nset<Oct> ans;\n\nvoid calc(int depth, int pos) {\n    if (depth == 8) {\n        Oct temp = gOct;\n        for (int x = 0; x < 4; x++) {\n            for (int y = 0; y < 4; y++) {\n                for (int z = 0; z < 4; z++) {\n                    sortOct[x + y * 4 + z * 16] = temp;\n                    temp = z_rot(temp);\n                }\n                temp = y_rot(temp);\n            }\n            temp = x_rot(temp);\n        }\n        sort(sortOct, sortOct + 64);\n        ans.insert(sortOct[0]);\n        return;\n    }\n    for (int i = 0; i < 8; i++) {\n        if ((pos >> i) & 1) { continue; }\n        gOct.c[depth] = col[i];\n        calc(depth + 1, pos | (1 << i));\n    }\n}\n\n\nint main()\n{\nwhile (true) {\n    for (int j=0;j<8;++j)\n        if (!(cin >> color[j])) { break; }\n    for (int j=0;j<8;++j) {\n        if (mp.find(color[j])!=mp.end())\n            col[j]=mp[color[j]];\n        else {\n            col[j]=mp.size();\n            mp[color[j]]=col[j];\n        }\n    }\n\n    calc(0,0);\n    cout << ans.size() << endl;\n}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring name[8];\nint color[8];\nint perm[8];\nbool used[1 << 24];\nint mat[3][8][8];\nint octa[8];\n\nvoid make_mat()\n{\n\tconst int swap[3][8] = {\n\t\t{1, 2, 3, 0, 5, 6, 7, 4},\n\t\t{1, 5, 6, 2, 0, 4, 7, 3},\n\t\t{3, 2, 6, 7, 0, 1, 5, 4}\n\t};\n\t\n\tfor(int m = 0; m < 3; m++){\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int j = 0; j < 8; j++){\n\t\t\t\tif(swap[m][i] == j) mat[m][i][j] = 1;\n\t\t\t\telse mat[m][i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint encode(int a[8])\n{\n\tint ret = 0;\n\tfor(int i = 0; i < 8; i++){\n\t\tret <<= 3;\n\t\tret += a[i];\n\t}\n\treturn ret;\n}\n\nvoid mul(int mat[8][8], int vec[8])\n{\n\tint tmp[8];\n\tint sum;\n\t\n\tfor(int i = 0; i < 8; i++){\n\t\tsum = 0;\n\t\tfor(int k = 0; k < 8; k++) sum += mat[i][k] * vec[k];\n\t\ttmp[i] = sum;\n\t}\n\tfor(int i = 0; i < 8; i++) vec[i] = tmp[i];\n}\n\nint main(void)\n{\n\tmake_mat();\n\t\n\tfor(int i = 0; i < 8; i++) octa[i] = i;\n\t\n\twhile(cin >> name[0]){\n\t\t\n\t\tint c = 1;\n\t\tstring *p;\n\t\t\n\t\tcolor[0] = 0;\n\t\tfor(int i = 1; i < 8; i++){\n\t\t\tcin >> name[c];\n\t\t\tp = find(name, name+c, name[c]);\n\t\t\tif(p == name+c) c++;\n\t\t\tcolor[i] = p - name;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1 << 24); i++) used[i] = false;\n\t\t\n\t\tbool flag;\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 8; i++) perm[i] = i;\n\t\tdo{\n\t\t\tfor(int i = 0; i < 8; i++) octa[i] = color[perm[i]];\n\t\t\t\n\t\t\tflag = false;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tmul(mat[0], octa);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tmul(mat[1], octa);\n\t\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\t\tmul(mat[2], octa);\n\t\t\t\t\t\tif(used[encode(octa)]){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tend:;\n\t\t\tif(!flag){\n\t\t\t\tused[encode(octa)] = true;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\t\n\t\t}while(next_permutation(perm, perm+8));\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(c,i,n) c + (i), c + (i) + (n)\n\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\ntemplate<class T>\nistream & operator>>(istream & in, complex<T> & n) { T r, i; in >> r >> i; n = complex<T>(r, i); return in; }\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n//// dice ////\n\ntemplate<class T>\nstruct Dice\n{\n\t/* v as 天一地六東五西二南三北四\n\t  |3|\n\t|1|0|4|5|\n\t  |2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Dice &rhs) const { return lexicographical_compare(apartof(v, 0, 6), apartof(rhs.v, 0, 6)); }\n};\n\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as \n\t\t/0\\/1\\/2\\/3\\\n\t\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(apartof(v, 0, 8), apartof(rhs.v, 0, 8)); }\n};\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\ttypedef Octahedra<unsigned char> Octa;\n\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tauto colors = read<string>(8);\n\t\tif (cin.eof()) { break; }\n\t\t\n\t\tsort(allof(colors));\n\t\tvector<string> color2 = colors;\n\t\tcolor2.erase(unique(allof(color2)), color2.end());\n\t\t\n\t\tset<Octa> visited;\n\t\t\n\t\tOcta o;\n\t\tREP(i, 8) { o.v[i] = index_of(allof(color2), colors[i]); }\n\n\t\tdo \n\t\t{\n\t\t\tOcta octa = o;\n\t\t\tbool found = false;\n\t\t\t\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tREP(j, 4)\n\t\t\t\t{\n\t\t\t\t\tREP(k, 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (visited.count(octa))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tgoto found;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tocta.rotateLeft();\n\t\t\t\t\t}\n\t\t\t\t\tocta.rotateDown();\n\t\t\t\t}\n\t\t\t\tocta.rotateCw();\n\t\t\t}\n\n\t\t\tfound:\n\t\t\tif (!found)\t{ visited.insert(octa); }\n\t\t\t\n\t\t} while (next_permutation(apartof(o.v, 0, 8)));\n\t\twrite(visited.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  while (1){\n    vector<string> C(8);\n    for (int i = 0; i < 8; i++){\n      cin >> C[i];\n    }\n    if (!cin){\n      break;\n    }\n    sort(C.begin(), C.end());\n    set<vector<string>> st;\n    while (1){\n      vector<string> D = C;\n      vector<string> tmp = D;\n      for (int i = 0; i < 4; i++){\n        for (int j = 0; j < 4; j++){\n          for (int k = 0; k < 4; k++){\n            tie(D[0], D[1], D[3], D[2]) = make_tuple(D[2], D[0], D[1], D[3]);\n            tie(D[4], D[5], D[7], D[6]) = make_tuple(D[6], D[4], D[5], D[7]);\n            tmp = min(tmp, D);\n          }\n          tie(D[0], D[1], D[5], D[4]) = make_tuple(D[4], D[0], D[1], D[5]);\n          tie(D[2], D[3], D[7], D[6]) = make_tuple(D[6], D[2], D[3], D[7]);\n        }\n        tie(D[0], D[2], D[6], D[4]) = make_tuple(D[4], D[0], D[2], D[6]);\n        tie(D[1], D[3], D[7], D[5]) = make_tuple(D[5], D[1], D[3], D[7]);\n      }\n      st.insert(tmp);\n      if (!next_permutation(C.begin(), C.end())){\n        break;\n      }\n    }\n    cout << st.size() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    auto equal=[](const vector<int>& x,const vector<int>& y){\n        auto equal_=[&](const vector<vector<int>>& a,const vector<vector<int>>& b){\n            rep(i,0,4){\n                bool ok=true;\n                rep(j,0,4) if(a[0][j]!=b[0][(j+i)%4] or a[1][j]!=b[1][(j+i)%4]){\n                    ok=false;\n                    break;\n                }\n                if(ok) return true;\n            }\n            rep(i,0,4){\n                bool ok=true;\n                rep(j,0,4) if(a[0][j]!=b[1][(j+i)%4] or a[1][j]!=b[0][(j+i)%4]){\n                    ok=false;\n                    break;\n                }\n                if(ok) return true;\n            }\n            return false;\n        };\n        vector<vector<int>> tmp1(2),tmp2(2);\n        tmp1[0].insert(tmp1[0].end(),x.begin(),x.begin()+4);\n        tmp2[0].insert(tmp2[0].end(),y.begin(),y.begin()+4);\n        tmp1[1].insert(tmp1[1].end(),x.begin()+4,x.end());\n        tmp2[1].insert(tmp2[1].end(),y.begin()+4,y.end());\n        if(equal_(tmp1,tmp2)) return true;\n        vector<vector<int>> tmp3(2);\n        tmp3[0].emplace_back(tmp2[0][0]);\n        tmp3[0].emplace_back(tmp2[1][0]);\n        tmp3[0].emplace_back(tmp2[1][1]);\n        tmp3[0].emplace_back(tmp2[0][1]);\n        tmp3[1].emplace_back(tmp2[0][3]);\n        tmp3[1].emplace_back(tmp2[1][3]);\n        tmp3[1].emplace_back(tmp2[1][2]);\n        tmp3[1].emplace_back(tmp2[0][2]);\n        return equal_(tmp1,tmp3);\n    };\n    string tmp;\n    while(cin >> tmp){\n        vector<string> color(8);\n        color[0]=tmp;\n        rep(i,1,8) cin >> color[i];\n\n        map<string,int> mp;\n        int cnt=0;\n        rep(i,0,8) if(mp.find(color[i])==mp.end()){\n            mp[color[i]]=cnt;\n            ++cnt;\n        }\n        vector<int> v(8);\n        rep(i,0,8) v[i]=mp[color[i]];\n        sort(v.begin(),v.end());\n\n        vector<pair<int,vector<int>>> all;\n        set<pair<int,vector<int>>> candidate;\n        int cnt2=0;\n        do{\n            all.emplace_back(make_pair(cnt2,v));\n            candidate.insert(make_pair(cnt2,v));\n            ++cnt2;\n        }while(next_permutation(v.begin(),v.end()));\n\n        for(const auto& x:all){\n            for(const auto& y:candidate){\n                if(x.first!=y.first and equal(x.second,y.second)){\n                    candidate.erase(x);\n                    break;\n                }\n            }\n        }\n\n        cout << candidate.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nclass Octahedra{\npublic:\n  vector<int> x;\n\n  Octahedra(){\n    x.resize(8);\n  }\n  \n  void rollLR(){\n    int tmp = x[0];\n    x[0] = x[3];\n    x[3] = x[4];\n    x[4] = x[1];\n    x[1] = tmp;\n\n    tmp = x[7];\n    x[7] = x[6];\n    x[6] = x[5];\n    x[5] = x[2];\n    x[2] = tmp;\n  }\n\n  void rollTF(){\n    swap(x[0],x[7]);\n    swap(x[1],x[2]);\n    swap(x[4],x[5]);\n    swap(x[3],x[6]);\n  }\n\n  void rollR(){\n    int tmp = x[0];\n    x[0] = x[7];\n    x[7] = x[2];\n    x[2] = x[1];\n    x[1] = tmp;\n    \n    tmp = x[3];\n    x[3] = x[6];\n    x[6] = x[5];\n    x[5] = x[4];\n    x[4] = tmp;\n  }\n\n  bool equal(const Octahedra &o){\n    for(int i = 0 ; i < 8 ; i++){\n      if(x[i] != o.x[i]){ return false; }\n    }\n    return true;\n  }\n\n  bool operator == (const Octahedra &o){\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < 4 ; j++){\n        if(equal(o)){ return true; }\n        rollLR();\n      }\n      rollTF();\n    }\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 4 ; j++){\n        if(equal(o)){ return true; }\n        rollLR();\n      }\n      rollR();\n    }\n    rollLR();\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 4 ; j++){\n        if(equal(o)){ return true; }\n        rollLR();\n      }\n      rollR();\n    }\n    return false;\n  }\n\n  bool operator < (const Octahedra &o)const{\n    for(int i = 0 ; i < 8 ; i++){\n      if(x[i] != o.x[i]){\n        return x[i] < o.x[i];\n      }\n    }\n  }\n};\n\nint main(){\n  map<string,int> mp;\n  string s;\n  while(cin >> s){\n    Octahedra o;\n    mp.clear(); mp[s] = 0;\n    o.x[0] = 0;\n    int idx = 1;\n    set<Octahedra> st;\n    for(int i = 0 ; i < 7 ; i++){\n      cin >> s;\n      if(mp.find(s) == mp.end()){\n        mp[s] = idx++;\n      }\n      o.x[i+1] = mp[s];\n    }\n    sort(o.x.begin(),o.x.end());\n    set<Octahedra>::iterator it;\n    do{\n      bool found = false;\n      for(it = st.begin() ; it != st.end() ; ++it){\n        Octahedra a = *it;\n        if(a == o){\n          found = true;\n          break;\n        }\n      }\n      if(!found){\n        st.insert(o);\n      }\n    }while(next_permutation(o.x.begin(),o.x.end()));\n    cout << st.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n// 24ñÅ³ÉàÇé\nclass Dice{\nprivate:\n\tint yoko;\n\tint tate;\n\tint round;\npublic:\n\tvector<int> colored;\n\tDice(const vector<int> &v){\n\t\tinit();\n\t\tfor(int i=0;i<8;i++)colored.push_back(v[i]);\n\t}\nprivate:\n\t// _CXÌú»\n\tvoid init(){\n\t\tyoko=0;\n\t\ttate=0;\n\t\tround=0;\n\t}\npublic:\n\t// _CXÌñ]\n\tvoid rotate(){\n\t\tif(round<4){\n\t\t\tround++;\n\t\t\t// z²ðSÉñ]\n\t\t\tint tp[8];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ttp[(i+1)%4]=colored[i];\n\t\t\t\ttp[(i+1)%4+4]=colored[i+4];\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t}\n\t\tif(round>=4){\n\t\t\tround=0;\n\t\t\t// àÇÁÄ«½çA¡ÌXbgðñ]³¹é\n\t\t\tif(yoko<4){\n\t\t\t\tyoko++;\n\t\t\t\tint tp[8];\n\t\t\t\ttp[0]=colored[4];\n\t\t\t\ttp[1]=colored[5];\n\t\t\t\ttp[4]=colored[7];\n\t\t\t\ttp[5]=colored[6];\n\t\t\t\ttp[2]=colored[1];\n\t\t\t\ttp[3]=colored[0];\n\t\t\t\ttp[7]=colored[3];\n\t\t\t\ttp[6]=colored[2];\n\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t}\n\t\t\t// àÇÁÄ«½çAcÌXbgðñ]³¹é\n\t\t\tif(yoko>=4){\n\t\t\t\tif(tate<4){\n\t\t\t\t\tint loop=1;\n\t\t\t\t\tif(tate==1)loop=2;\n\t\t\t\t\twhile(loop--){\n\t\t\t\t\t\ttate++;\n\t\t\t\t\t\tint tp[8];\n\t\t\t\t\t\ttp[7]=colored[3];\n\t\t\t\t\t\ttp[4]=colored[0];\n\t\t\t\t\t\ttp[6]=colored[7];\n\t\t\t\t\t\ttp[5]=colored[4];\n\t\t\t\t\t\ttp[2]=colored[6];\n\t\t\t\t\t\ttp[1]=colored[5];\n\t\t\t\t\t\ttp[3]=colored[2];\n\t\t\t\t\t\ttp[0]=colored[1];\n\t\t\t\t\t\tfor(int i=0;i<8;i++)colored[i]=tp[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tate>=4){\n\t\t\t\t\tround=0;\n\t\t\t\t\ttate=0;\n\t\t\t\t\tyoko=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n\nint main() {\n\tint cs[8];\n\tstring s;\n\twhile (getline(cin, s)) {\n\t\tmap<string,int> idxs;\n\t\tint idx=0;\n\t\tistringstream iss(s);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tstring ts;\n\t\t\tiss>>ts;\n\t\t\tif(idxs.find(ts)==idxs.end())idxs[ts]=idx++;\n\t\t\tcs[i]=idxs[ts];\n\t\t}\n\t\tset<vector<int> > svs;\n\t\tint cnt=0;\n\t\tdo{\n\t\t\tvector<int> init;\n\t\t\tfor(int i=0;i<8;i++)init.push_back(cs[i]);\n\t\t\tDice d(init);\n\t\t\t// ¡Ìhèûªp^[ÌÇê©Éêv·é©`FbN\n\t\t\tif(svs.find(d.colored)==svs.end()){\n\t\t\t\tcnt++;\n\t\t\t\tfor(int i=0;i<24;i++){\n\t\t\t\t\tsvs.insert(d.colored);\n\t\t\t\t\td.rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(cs,cs+8));\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nvoid rotx(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[2];\tv[2]=t[6];\tv[3]=t[7];\n\tv[4]=t[0];\tv[5]=t[1];\tv[6]=t[5];\tv[7]=t[4];\n}\n\nvoid roty(vi &v){\n\tvi t=v;\n\tv[0]=t[4];\tv[1]=t[0];\tv[2]=t[3];\tv[3]=t[7];\n\tv[4]=t[5];\tv[5]=t[1];\tv[6]=t[2];\tv[7]=t[6];\n}\n\nvoid rotz(vi &v){\n\tvi t=v;\n\tv[0]=t[3];\tv[1]=t[0];\tv[2]=t[1];\tv[3]=t[2];\n\tv[4]=t[7];\tv[5]=t[4];\tv[6]=t[5];\tv[7]=t[6];\n}\n\nvi findRegularPaint(vi a){\n\tvi reg=a;\n\trep(i,4){\n\t\trep(j,4){\n\t\t\treg=min(reg,a);\n\t\t\trotz(a);\n\t\t}\n\t\trotx(a);\n\t}\n\troty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\troty(a),roty(a);\n\trep(i,4){\n\t\treg=min(reg,a);\n\t\trotz(a);\n\t}\n\n\treturn reg;\n}\n\nint vi2int(const vi &a){\n\tint res=0;\n\trep(i,a.size())\tres=res*10+a[i];\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tstring s[8];\n\t\trep(i,8) if(!(cin>>s[i])) return 0;\n\n\t\tint clr[8];\n\t\t{\n\t\t\tint id=0;\n\t\t\tmap<string,int> colorid;\n\t\t\trep(i,8){\n\t\t\t\tif(colorid.count(s[i])==0)\tcolorid[s[i]]=id++;\n\t\t\t\tclr[i]=colorid[s[i]];\n\t\t\t}\n\t\t}\n\t\tsort(clr,clr+8);\n\n\t\tset<int> cube;\n\t\tdo{\n\t\t\tcube.insert(vi2int(findRegularPaint(vi(clr,clr+8))));\n\t\t}while(next_permutation(clr+1,clr+8));\n\n\t\tcout<<cube.size()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nclass Octahedra{\n\tpublic:\n\t\tstring color[8];\n\t\tvoid right(){\n\t\t\tstring tmp[8];\n\t\t\trep(i,8) tmp[i]=color[i];\n\t\t\tcolor[0]=tmp[4],color[1]=tmp[5],color[2]=tmp[1],color[3]=tmp[0];\n\t\t\tcolor[4]=tmp[7],color[5]=tmp[6],color[6]=tmp[2],color[7]=tmp[3];\n\t\t}\n\t\tvoid top(){\n\t\t\tstring tmp[8];\n\t\t\trep(i,8) tmp[i]=color[i];\n\t\t\tcolor[0]=tmp[4],color[1]=tmp[0],color[2]=tmp[3],color[3]=tmp[7];\n\t\t\tcolor[4]=tmp[5],color[5]=tmp[1],color[6]=tmp[2],color[7]=tmp[6];\n\t\t}\n\t\tvoid rotation(){\n\t\t\trep(i,3) swap(color[i],color[i+1]);\n\t\t\trep(i,3) swap(color[i+4],color[i+1+4]);\n\t\t}\n\n\t\tbool operator<(Octahedra a) const{\n\t\t\trep(i,8) if(color[i]!=a.color[i]) return color[i]<a.color[i];\n\t\t\treturn color[7]<a.color[7];\n\t\t}\n};\n\nset<Octahedra> s;\n\nint main(void){\n\twhile(1){\n\t\tstring color[8];\n\t\trep(i,8) cin >> color[i];\n\t\tif(cin.eof()) break;\n\n\t\ts.clear();\n\t\tsort(color,color+8);\n\n\t\tdo{\n\t\t\tOctahedra in;\n\t\t\trep(i,8) in.color[i]=color[i];\n\n\t\t\tbool check=true;\n\t\t\trep(i,4){\n\t\t\t\trep(j,4){\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tif(s.find(in)!=s.end()){\n\t\t\t\t\t\t\tcheck=false;\n\t\t\t\t\t\t\ti=4,j=4,k=4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tin.rotation();\n\t\t\t\t\t}\n\t\t\t\t\tin.right();\n\t\t\t\t}\n\t\t\t\tin.top();\n\t\t\t}\n\n\t\t\tif(check) s.insert(in);\n\n\t\t}while(next_permutation(color,color+8));\n\t\tcout << s.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\nusing namespace std;\n\nvoid reverse(int ind[8]) {\n  int tmp;\n  tmp = ind[0];\n  ind[0] = ind[5];\n  ind[5] = tmp;\n  tmp = ind[1];\n  ind[1] = ind[6];\n  ind[6] = tmp;\n  tmp = ind[2];\n  ind[2] = ind[7];\n  ind[7] = tmp;\n  tmp = ind[3];\n  ind[3] = ind[4];\n  ind[4] = tmp;\n}\n\nvoid roll1(int n, int ind[8]) {\n  for(int i = 0; i < n; ++i) {\n    int tmp;\n    tmp = ind[3];\n    ind[3] = ind[0];\n    ind[0] = ind[1];\n    ind[1] = ind[2];\n    ind[2] = tmp;\n    tmp = ind[4];\n    ind[4] = ind[7];\n    ind[7] = ind[6];\n    ind[6] = ind[5];\n    ind[5] = tmp;\n  }\n}\n\nvoid roll2(int n, int ind[8]) {\n  for(int i = 0; i < n; ++i) {\n    int tmp;\n    tmp = ind[0];\n    ind[0] = ind[2];\n    ind[2] = ind[4];\n    ind[4] = tmp;\n    tmp = ind[1];\n    ind[1] = ind[5];\n    ind[5] = ind[7];\n    ind[7] = tmp;\n  }\n}\n\nclass Octahedra {\npublic:\n  string s[8];\n  bool operator < (const Octahedra &oct) const {\n    for(int i = 0; i < 8; ++i) {\n      if(s[i] != oct.s[i]) return s[i] < oct.s[i];\n    }\n    return false;\n  }\n};\n\nstring str[8];\n\nvoid show(string s[8]) {\n  for(int i = 0; i < 8; ++i) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\nvoid allInsert(set<Octahedra> &vis, Octahedra oc) {\n  int ind[8];\n  Octahedra no;\n  for(int i = 0; i < 8; ++i) ind[i] = i;\n  for(int k = 0; k < 8; ++k) {\n    if(k == 4) {\n      reverse(ind);\n    }\n    for(int j = 0; j < 3; ++j) {\n      for(int i = 0; i < 8; ++i) {\n\tno.s[i] = oc.s[ind[i]];\n      }\n      if(vis.find(no) == vis.end()) {\n\tvis.insert(no);\n      }\n      roll2(1, ind);\n    }\n    roll1(1, ind);\n  }\n}\n\nint solve() {\n  set<Octahedra> vis;\n  Octahedra oct;\n  int cnt = 0;\n  for(int i = 0; i < 8; ++i) oct.s[i] = str[i];\n  sort(oct.s, oct.s+8);\n  do {\n    if(vis.find(oct) == vis.end()) {\n      ++cnt;\n      allInsert(vis, oct);\n    }\n  } while(next_permutation(oct.s, oct.s+8));\n  return cnt;\n}\n\nmain() {\n  while((cin >> str[0])) {\n    for(int i = 1; i < 8; ++i) cin >> str[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nconst int N = 8;\narray<int, N> idx;\nstring color[N];\n\ninline int encode(const array<int, N> &a) {\n\tint res = 0;\n\tfor(const auto &e : a) res = (res * N) + e;\n\treturn res;\n}\n\n// a, b, c, d -> b, c, d, a\nvoid rotate(int &a, int &b, int &c, int &d) {\n\tconst int tmp = a;\n\ta = b;\n\tb = c;\n\tc = d;\n\td = tmp;\n}\n\nvoid north(array<int, N> &a) {\n\trotate(a[0], a[1], a[3], a[2]);\n\trotate(a[4], a[6], a[7], a[5]);\n}\n\nvoid east(array<int, N> &a) {\n\trotate(a[0], a[6], a[7], a[1]);\n\trotate(a[4], a[5], a[3], a[2]);\n}\n\nvoid right(array<int, N> &a) {\n\trotate(a[0], a[2], a[4], a[6]);\n\trotate(a[1], a[3], a[5], a[7]);\n}\n\nbool exist(const unordered_set<int> &s, array<int, N> a) {\n\tfor(int i = 0; i < 4; ++i) {\n\t\tfor(int j = 0; j < 4; ++j) {\n\t\t\tif(s.count(encode(a))) return true;\n\t\t\tright(a);\n\t\t}\n\t\tnorth(a);\n\t}\n\n\teast(a);\n\tfor(int i = 0; i < 4; ++i) {\n\t\tif(s.count(encode(a))) return true;\n\t\tright(a);\n\t}\n\n\teast(a);\n\teast(a);\n\tfor(int i = 0; i < 4; ++i) {\n\t\tif(s.count(encode(a))) return true;\n\t\tright(a);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> color[0]) {\n\t\tfor(int i = 1; i < N; ++i) {\n\t\t\tcin >> color[i];\n\t\t}\n\n\t\tunordered_map<string, int> converter;\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tif(!converter.count(color[i])) {\n\t\t\t\tconverter.insert({color[i], converter.size()});\n\t\t\t}\n\t\t\tidx[i] = converter[color[i]];\n\t\t}\n\n\t\tsort(idx.begin(), idx.end());\n\t\tunordered_set<int> ans;\n\t\tdo {\n\t\t\tif(!exist(ans, idx)) {\n\t\t\t\tans.insert(encode(idx));\n\t\t\t}\n\t\t} while(next_permutation(idx.begin(), idx.end()));\n\n\t\tcout << ans.size() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint encode(VI& vi){\n  int res = 0;\n  for(int i=0;i<8;++i)\n\tres = res * 8 + vi[i];\n  return res;\n}\n\nvoid g(VI& num){\n  int tmp = num[0];\n  REP(j,3)\n\tnum[j] = num[j+1];\n  num[3] = tmp;\n  \n  tmp = num[4];\n  REP(j,3)\n\tnum[j+4] = num[j+5];\n  num[7] = tmp;\n}\nvoid func(VI num, set<int>& memo){\n  //1234567\n  REP(i,4){\n\tg(num);\n\tmemo.insert(encode(num));\n  }\n  //14852376\n  VI num2 = num;\n  num2[0] = num[0];\n  num2[1] = num[3];\n  num2[2] = num[7];\n  num2[3] = num[4];\n  num2[4] = num[1];\n  num2[5] = num[2];\n  num2[6] = num[6];\n  num2[7] = num[5];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  //58761432\n  num2[0] = num[4];\n  num2[1] = num[7];\n  num2[2] = num[6];\n  num2[3] = num[5];\n  num2[4] = num[0];\n  num2[5] = num[3];\n  num2[6] = num[2];\n  num2[7] = num[1];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  //43781265\n  num2[0] = num[3];\n  num2[1] = num[2];\n  num2[2] = num[6];\n  num2[3] = num[7];\n  num2[4] = num[0];\n  num2[5] = num[1];\n  num2[6] = num[5];\n  num2[7] = num[4];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  // 26731584\n  num2[0] = num[1];\n  num2[1] = num[5];\n  num2[2] = num[6];\n  num2[3] = num[2];\n  num2[4] = num[0];\n  num2[5] = num[4];\n  num2[6] = num[7];\n  num2[7] = num[3];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  //56218734\n  num2[0] = num[4];\n  num2[1] = num[5];\n  num2[2] = num[1];\n  num2[3] = num[0];\n  num2[4] = num[7];\n  num2[5] = num[6];\n  num2[6] = num[2];\n  num2[7] = num[3];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  \n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string s[8];\n  while(cin >> s[0]){\n\tint cnt = 0;\n\tVI num(8,0);\n\tmap<string, int> mp;\n\tmp[s[0]] = cnt++;\n\tREP(i,7){\n\t  cin >> s[i+1];\n\t  if(!mp.count(s[i+1]))\n\t\tmp[s[i+1]] = cnt++;\n\t}\n\tREP(i,8)\n\t  num[i] = mp[s[i]];\n\tSORT(num);\n\n\tint ans = 0;\n\tset<int> memo;\n\tdo{\n\t  if(memo.count(encode(num))) continue;\n\t  ++ans;\n\t  func(num, memo);\n\t}while(next_permutation(ALL(num)));\n\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  vector<int> v;\n  P(vector<int> &v) : v(v) {}\n  P rotate1() {\n    P r = *this;\n    REP(i,3) swap(r.v[i],r.v[(i+1)%4]);\n    REP(i,3) swap(r.v[4+i],r.v[4+(i+1)%4]);\n    return r;\n  }\n  P rotate2() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[5]);swap(w[5],w[1]);\n    swap(w[2],w[3]);swap(w[3],w[7]);swap(w[7],w[6]);\n    return P(w);\n  }\n  P rotate3() {\n    vector<int> w = this->v;\n    swap(w[0],w[3]);swap(w[3],w[7]);swap(w[7],w[4]);\n    swap(w[1],w[2]);swap(w[2],w[6]);swap(w[6],w[5]);\n    return P(w);\n  }\n  int regular() {\n    P r = *this;\n    vector<int> mi=r.v;\n    for (int i=0; i<6; ++i,r=(i&1?r.rotate2():r.rotate3()))\n      for (int j=0;j<4; ++j,r=r.rotate1())\n        mi = min(mi,r.v);\n    int res = 0;\n    int a = 1;\n    REP(i,8) res += a*mi[i], a *= 8;\n    return res;\n  }\n};\nint main() {\n  string s;\n  while(cin>>s) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> v;\n    mp[s] = num++;\n    v.push_back(mp[s]);\n    REP(i,7) {\n      cin >> s;\n      if (mp.count(s) == 0) mp[s] = num++;\n      v.push_back(mp[s]);\n    }\n    sort(ALL(v));\n    set<int> se;\n    do {\n      se.insert(P(v).regular());\n    } while(next_permutation(ALL(v)));\n    \n    cout << se.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Oct=array<int,8>;\nvoid rotateA(Oct& o){\n    Oct tmp=o;\n    for(int i=0;i<4;i++){\n        o[i]=tmp[(i+1)%4];\n        o[i+4]=tmp[(i+1)%4+4];\n    }\n}\nvoid rotateB(Oct& oct){\n    Oct tmp=oct;\n    oct[0]=tmp[4];\n    oct[1]=tmp[5];\n    oct[2]=tmp[1];\n    oct[3]=tmp[0];\n    oct[4]=tmp[7];\n    oct[5]=tmp[6];\n    oct[6]=tmp[2];\n    oct[7]=tmp[3];\n}\n\nbool check(Oct oct,set<Oct> &s){\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            for(int k=0;k<4;k++){\n                if(s.count(oct)) return false;             \n                rotateA(oct);\n            }\n            rotateB(oct);\n        }\n        rotateA(oct);\n    }\n    return true;\n}\nint dfs(int x,const vector<int>& v,set<Oct>& s,Oct& oct){\n    if(x==8){\n        assert(count(oct.begin(),oct.end(),-1)==0);\n        if(!check(oct,s)) return 0;\n        s.insert(oct);\n        return 1;\n    }\n    int res=0;\n    for(int i=0;i<oct.size();i++){\n        if(oct[i]==-1){\n            oct[i]=v[x];\n            res+=dfs(x+1,v,s,oct);\n            oct[i]=-1;\n        }\n    }\n    return res;\n}\nint main(){\n    vector<string> color(8);\n    while(cin>>color[0]){\n        for(int i=1;i<8;i++) cin>>color[i];\n        map<string,int> mp;\n        for(int i=0;i<8;i++) mp[color[i]]++;\n        vector<int> v;\n        int idx=0;\n        for(auto &e:mp){\n            for(int i=0;i<e.second;i++) v.push_back(idx);\n            idx++;\n        }\n        set<Oct> s;\n        Oct oct;\n        fill(oct.begin(),oct.end(),-1);\n        cout<<dfs(0,v,s,oct)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string> r1(vector<string> s) {\n  vector<string> t = s;\n  t[0] = s[0];\n  t[1] = s[5];\n  t[5] = s[3];\n  t[3] = s[1];\n  t[4] = s[2];\n  t[2] = s[6];\n  t[6] = s[4];\n  t[7] = s[7];\n  return t;\n}\n\nvector<string> r2(vector<string> s) {\n  vector<string> t = s;\n  t[0] = s[1];\n  t[1] = s[2];\n  t[2] = s[3];\n  t[3] = s[0];\n  t[4] = s[5];\n  t[5] = s[6];\n  t[6] = s[7];\n  t[7] = s[4];\n  return t;\n}\n\nvector<string> r3(vector<string> s) {\n  vector<string> t = s;\n  t[0] = s[5];\n  t[5] = s[0];\n  t[1] = s[4];\n  t[4] = s[1];\n  t[2] = s[7];\n  t[7] = s[2];\n  t[3] = s[6];\n  t[6] = s[3];\n  return t;\n}\n\nint main() {\n  for(string s; cin >> s; ) {\n    vector<string> v(8, s);\n    for(int i = 1; i < 8; ++i) cin >> v[i];\n    sort(v.begin(), v.end());\n    set<vector<string> > s;\n    int res = 0;\n    do {\n      if(s.count(v)) continue;\n      ++res;\n      for(int i = 0; i < 2; ++i) {\n        for(int j = 0; j < 4; ++j) {\n          for(int k = 0; k < 3; ++k) {\n            s.insert(v);\n            v = r1(v);\n          }\n          v = r2(v);\n        }\n        v = r3(v);\n      }\n    } while(next_permutation(v.begin(), v.end()));\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nstring color[8],t;\nset<string> S;\n\nvoid rot1(){\n  rep(i,3)swap(color[i],color[i+1]);\n  rep(i,3)swap(color[i+4],color[i+5]);\n}\n\nvoid rot2(){\n  swap(color[0],color[4]);  swap(color[1],color[5]);\n  swap(color[4],color[7]);  swap(color[5],color[6]);\n  swap(color[7],color[1]);  swap(color[6],color[2]);\n}\n\nbool check(){\n  string s;\n  rep(i,8)s+=color[i];\n  return S.count(t=s)!=0;\n}\n\nvoid solve(){\n  S.clear();\n  int num[8];\n  string cp[8];\n  rep(i,8)num[i]=i,cp[i]=color[i];\n  do{\n    rep(i,8)color[i]=cp[num[i]];\n    bool f=false;\n    rep(i,4){ rot1();\n      rep(j,4){ rot2();\n\trep(k,4){ rot1();\n\t  if(check())f=true;\n\t}\n      }\n    }\n    if(!f)S.insert(t);\n  }while(next_permutation(num,num+8));\n  cout<<S.size()<<endl;\n}\n\nint main(){\n  while(cin>>color[7]){\n    rep(i,7)cin>>color[i];\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nconst int tb[][8] = {\n\t{3, 0, 1, 2, 7, 4, 5, 6},\n\t{4, 0, 3, 7, 5, 1, 2, 6}\n};\n\nmap<string, int> cv;\nset<int> dn;\nint a[8];\n\nint main()\n{\n\twhile (true){\n\t\tcv.clear();\n\t\tdn.clear();\n\n\t\tstring s;\n\t\trep(i, 8){\n\t\t\tif (!(cin >> s)) return 0;\n\t\t\tint t = cv.size();\n\t\t\tif (cv.count(s)) a[i] = cv[s];\n\t\t\telse cv[s] = a[i] = t;\n\t\t}\n\n\t\tint res = 0;\n\t\tint perm[8];\n\t\tint c[32];\n\t\tiota(perm, perm + 8, 0);\n\t\tdo {\n\t\t\tarray<int, 8> b;\n\t\t\trep(i, 8) b[i] = a[perm[i]];\n\t\t\tbool f = true;\n\t\t\trep(i, 32){\n\t\t\t\tc[i] = 0;\n\t\t\t\trep(j, 8) c[i] = c[i] * 8 + b[j];\n\t\t\t\tif (dn.count(c[i])) f = false;\n\t\t\t\tarray<int, 8> dst;\n\t\t\t\trep(j, 8){\n\t\t\t\t\tdst[j] = b[tb[0][j]];\n\t\t\t\t}\n\t\t\t\tif (i % 4 == 3){\n\t\t\t\t\trep(j, 8){\n\t\t\t\t\t\tdst[j] = b[tb[1][j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb = dst;\n\t\t\t}\n\t\t\tif (f) res++;\n\t\t\trep(i, 32) dn.insert(c[i]);\n\t\t} while (next_permutation(perm, perm + 8));\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nmap<string,int>::iterator it;\nvector<int> x, y, v;\nset<vector<int> > se;\n\nvoid solve(){\n\tm.clear();\n\tse.clear();\n\tx.clear();\n\tx.resize(8);\n\tint cnt = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trep(i,8) x[i] = i;\n\tdo{\n\t\ty = x;\n\t\tbool ok = true;\n\t\trep(i,6){\n\t\t\tv.clear();\n\t\t\trep(j,8) v.push_back(m[str[y[j]]]);\n\t\t\tif(se.count(v) > 0){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswap(y[4],y[1]); swap(y[1],y[2]); swap(y[3],y[6]); swap(y[5],y[3]);\n\t\t}\n\t\tif(ok) se.insert(v);\n\t} while(next_permutation(x.begin()+1,x.end()));\n\tcout << se.size() << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<set>\nusing namespace std;\nstring s;\nmain()\n{\n\twhile(cin>>s)\n\t{\n\t\tvector<int>a;\n\t\tmap<string,int>M;int sz=1;\n\t\tM[s]=sz++;\n\t\ta.push_back(1);\n\t\tfor(int i=1;i<8;i++)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tif(M[s]==0)M[s]=sz++;\n\t\t\ta.push_back(M[s]);\n\t\t}\n\t\tsort(a.begin(),a.end());\n\t\tvector<int>ret;\n\t\tset<int>S;\n\t\tdo{\n\t\t\tint now=0;\n\t\t\tfor(int i=0;i<8;i++)now=now*10+a[i];\n\t\t\tif(S.find(now)==S.end())\n\t\t\t{\n\t\t\t\tret.push_back(now);\n\t\t\t\tint b=now;\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS.insert(b);\n\t\t\t\t\t\t\tb=b/10000%1000*10*10000+b/10000000*10000+b%1000*10+b/1000%10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb=b/10000%10*10000000+b/100000%10*1000000+b/10%10*100000+b%10*10000+b/10000000*1000+b/1000000%10*100+b/100%10*10+b/1000%10;\n\t\t\t\t\t}\n\t\t\t\t\tb=b/10000%1000*10*10000+b/10000000*10000+b%1000*10+b/1000%10;\n\t\t\t\t}\n\t\t\t}\n\t\t}while(next_permutation(a.begin(),a.end()));\n\t\tcout<<ret.size()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nLL pp[] = {1,10,100,1000,10000,100000,1000000,10000000,100000000};\nLL ch[] = {0,3,7,4,1,2,6,5};\nLL ch1[] = {0,4,5,1,3,7,6,2};\nLL ch2[] = {6,5,4,7,2,1,0,3};\n\nLL get_hash(LL k,LL i){\n    return k * pp[i];\n}\n\n\nint main(){\n    while(true){\n        map<string,int> m;\n        vector<int> a(8,0);\n        int key = 0;\n        for (int i = 0; i < 8; i++) {\n            string s=\"\";cin >> s;\n            if(s==\"\") return 0;\n            if(m.find(s)==m.end()) m[s] = key++;\n            a[i] = m[s];\n        }\n        vector<int> v(8);\n        for (int i = 0; i < 8; i++) {\n            v[i] = i;\n        }\n        sort(RALL(a));\n        int ans = 0;\n        set<LL> st;\n        auto f = [&](vector<LL> q){\n            for (int p = 0; p < 2; p++) {\n                for (int k = 0; k < 4; k++) {\n                    auto b = q;\n                    for (int i = 0; i < 4; i++) {\n                        b[i] = q[(i+k)%4];\n                        b[i+4] = q[(i+k)%4+4];\n                    }\n                    LL t = 0;\n                    for (int i = 0; i < 8; i++) {\n                        t += get_hash(b[i],i);\n                    }\n                    if(st.find(t) != st.end()) return false;\n                }\n                auto qq = q;\n                for (int i = 0; i < 8; i++) {\n                    q[i] = qq[ch2[i]];\n                }\n            }\n            return true;\n        };\n        do{\n            vector<LL> c(8);\n            bool ff = true;\n            for (int i = 0; i < 8; i++) {\n                c[i] = a[v[i]];\n            }\n            auto cc = c;\n            ff &= f(cc);\n            for (int i = 0; i < 8; i++) {\n                cc[i] = c[ch[i]];\n            }\n            ff &= f(cc);\n            for (int i = 0; i < 8; i++) {\n                cc[i] = c[ch1[i]];\n            }\n            ff &= f(cc);\n            if(ff){\n                ans++;\n                LL t = 0;\n                for (int i = 0; i < 8; i++) {\n                    t += get_hash(c[i],i);\n                }\n                st.insert(t);\n            }\n        }\n        while(next_permutation(ALL(v)));\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  vector<int> v;\n  P(vector<int> &v) : v(v) {}\n  P rotate1() {\n    P r = *this;\n    REP(i,3) swap(r.v[i],r.v[(i+1)%4]);\n    REP(i,3) swap(r.v[4+i],r.v[4+(i+1)%4]);\n    return r;\n  }\n  P rotate2() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[5]);swap(w[5],w[1]);\n    swap(w[2],w[3]);swap(w[3],w[7]);swap(w[7],w[6]);\n    return P(w);\n  }\n  P rotate3() {\n    vector<int> w = this->v;\n    swap(w[0],w[4]);swap(w[4],w[7]);swap(w[7],w[3]);\n    swap(w[1],w[5]);swap(w[5],w[6]);swap(w[6],w[2]);\n    return P(w);\n  }\n  vector<P> all() {\n    P r = *this;\n    vector<P> res;\n    for (int i=0; i<6; ++i,r=(i&2?r.rotate2():r.rotate3())) {\n      for (int j=0;j<4; ++j,r=r.rotate1())\n        res.push_back(r);\n    }\n    return res;\n  }\n};\n\nconst bool operator<(P a, const P &b) {\n  vector<P> v = a.all();\n  vector<int> mi = a.v;\n  FOR(it, v) {\n    if (it->v == b.v) return 0;\n    mi = min(mi, it->v);\n  }\n  return mi < b.v;\n}\n\nint main() {\n  string s;\n  while(cin>>s) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> v;\n    mp[s] = num++;\n    v.push_back(mp[s]);\n    REP(i,7) {\n      cin >> s;\n      if (mp.count(s) == 0) mp[s] = num++;\n      v.push_back(mp[s]);\n    }\n    // set<P> hoge;\n    // int arr[8] = {0,1,2,3,4,5,6,7};\n    // vector<int> vv(arr,arr+8);\n    // cout << \": \" << (P(v) < P(vv)) << endl;\n    // cout << \": \" << (P(vv) < P(v)) << endl;\n    // hoge.insert(P(v));\n    // hoge.insert(P(vv));\n    // cout << hoge.size() << endl;\n    // vector<P> a = P(vv).all();\n    // FOR(it, a) {\n    //   FOR(jt, it->v) cout << *jt << \" \";\n    //   cout << endl;\n    // }\n    set<P> se;\n    do {\n      REP(i,8) {\n        se.insert(P(v));\n      }\n    } while(next_permutation(ALL(v)));\n    // FOR(it, se) {\n    //   FOR(jt, it->v) cout << *jt; cout << endl;\n    // }\n    cout << se.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nvoid rotate(vector<int>& v, int a, int b, int c, int d){\n  int t = v[a];\n  v[a] = v[b];\n  v[b] = v[c];\n  v[c] = v[d];\n  v[d] = t;\n}\nvoid rotate_x(vector<int>& v){\n  rotate(v, 1, 2, 6, 5);\n  rotate(v, 0, 3, 7, 4);\n}\nvoid rotate_y(vector<int>& v){\n  rotate(v, 0, 1, 5, 4);\n  rotate(v, 3, 2, 6, 7);\n}\nvoid rotate_z(vector<int>& v){\n  rotate(v, 0, 1, 2, 3);\n  rotate(v, 4, 5, 6, 7);\n}\nbool equal(const vector<int>& d, vector<int> e){\n  for(int i = 0; i < 6; i++){\n    if(i & 1) rotate_x(e);\n    else rotate_y(e);\n    for(int j = 0; j < 4; j++){\n      rotate_z(e);\n      if(d == e) return true;\n    }\n  }\n  return false;\n}\nint main(){\n  string line;\n  while(getline(cin, line)){\n    string s;\n    stringstream ss(line);\n    map<string, int> id;\n    vector<int> d(8);\n    REP(i, 8){\n      ss>>s;\n      if(id.count(s)){\n        d[i] = id[s];\n      }else{\n        int t = id.size();\n        d[i] = id[s] = t;\n      }\n    }\n    sort(d.begin(), d.end());\n    vector<vector<int> > ans;\n    do{\n      bool ok = true;\n      REP(i, ans.size()) if(equal(ans[i], d)){\n        ok = false;\n        break;\n      }\n      if(ok) ans.push_back(d);\n    }while(next_permutation(d.begin(), d.end()));\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <iomanip>\nusing namespace std;\n\n\nbool hs[1<<24];\n\nint calchs(int c[8])\n{\n\tint ret=0;\n\tfor(int i=0; i<8; i++)\n\t\tret|=c[i]<<(3*i);\n\n\treturn ret;\n}\n\nclass Octahedra\n{\npublic:\n\tint f[8];\n\n\tvoid all_rotate()\n\t{\nhs[calchs(f)]=1;\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tx_rot();\n\t\t\tfor(int j=0; j<4; j++)\n\t\t\t{\n\t\t\t\ty_rot();\n\t\t\t\tfor(int k=0; k<4; k++)\n\t\t\t\t{\n\t\t\t\t\tz_rot();\n\t\t\t\t\ths[calchs(f)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid x_rot()\n\t{\n\t\tint t1=f[0], t2=f[4];\n\t\tf[0]=f[1];\n\t\tf[1]=f[2];\n\t\tf[2]=f[3];\n\t\tf[3]=t1;\n\n\t\tf[4]=f[5];\n\t\tf[5]=f[6];\n\t\tf[6]=f[7];\n\t\tf[7]=t2;\n\t\t\n\t}\n\n\tvoid y_rot()\n\t{\n\t\tint t0=f[0], t1=f[1], t2=f[2], t3=f[3];\n\t\tf[0]=f[4];\n\t\tf[1]=f[5];\n\t\tf[2]=t0;\n\t\tf[3]=t1;\n\t\tf[4]=f[6];\n\t\tf[5]=f[7];\n\t\tf[6]=t2;\n\t\tf[7]=t3;\n\t}\n\n\tvoid z_rot()\n\t{\n\t\tint t0=f[0],t1=f[1], t2=f[2], t6=f[6];\n\t\tf[0]=f[4];\n\t\tf[1]=t0;\n\t\tf[2]=f[3];\n\t\tf[3]=f[7];\n\t\tf[4]=f[5];\n\t\tf[5]=t1;\n\t\tf[6]=t2;\n\t\tf[7]=t6;\n\t}\n\n\tOctahedra(int face[8])\n\t{\n\t\tfor(int i=0; i<8; i++)\n\t\t\tf[i]=face[i];\n\t}\n};\n\nint main()\n{\n\tint c[8];\n\tstring s;\n\twhile(1)\n\t{\n\t\tmemset(hs, 0, sizeof(hs));\n\t\tint cnt=0;\n\t\tmap<string, int> d;\n\n\t\tfor(int i=0; i<8; i++)\n\t\t{\n\t\t\tif(!(cin >> s)) return 0;\n\t\t\t\n\t\t\tint color;\t\t\t\n\t\t\tif(d.count(s) == 0)\n\t\t\t{\n\t\t\t\tcolor=cnt;\n\t\t\t\td.insert(make_pair(s,cnt));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor=d.find(s)->second;\n\t\t\t}\n\n\t\t\tc[i]=color;\n\t\t}\n\t\n\n\t\tint ans=0;\n\t\tsort(c, c+8);\n\t\twhile(1)\n\t\t{\n\t\t\tOctahedra o(c);\n\t\t\t\n\t\t\tif(!hs[calchs(c)])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\to.all_rotate();\n\t\t\t}\n\n\t\t\tif(!next_permutation(c, c+8)) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cmath>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nint table[6][8]={\n  {0,1,2,3,4,5,6,7},\n  {4,7,6,5,0,3,2,1},\n  {0,4,5,1,3,7,6,2},\n  {1,5,6,2,0,4,7,3},\n  {2,6,7,3,1,5,4,0},\n  {3,7,4,0,2,6,5,1}\n};\n\n\n\nclass state{\npublic:\n  char data[8];\n  bool operator<(const state & a)const {\n    rep(i,8)\n      if( data[i] != a.data[i])return data[i]<a.data[i];\n    return false;\n  }\n};\n\n\nbool check_duplicate(state & a,set<state> &S){\n  state check[4];\n  rep(i,4){\n    rep(j,4){\n      check[i].data[j]    =a.data[(i+j)%4];\n      check[i].data[4+j]  =a.data[4+(4+i+j)%4];\n    }\n  }\n  \n  rep(i,8)if ( S.find(check[i]) !=S.end())return true;\n  return false;\n}\n\nint cpy[8]={4,7,6,5,0,3,2,1};\n\nvoid make_set(state & a,set<state> & S){\n  state check;\n  state check2;\n  rep(i,6){\n    rep(j,8)check.data[j]=a.data[table[i][j]];\n    if (check_duplicate(check,S))return;\n    rep(j,8)check2.data[j]=check.data[cpy[j]];\n    if (check_duplicate(check,S))return;\n  }\n  \n  S.insert(a);\n}\n\n\nvoid generate(int num,int *rem,state &a,int now,set<state>&S){\n  if ( now == 8){\n    make_set(a,S);\n    return;\n  }\n  rep(i,num){\n    if( rem[i] == 0)continue;\n    rem[i]--;\n    a.data[now]=i;\n    generate(num,rem,a,now+1,S);\n    rem[i]++;\n  }\n\n} \n\n\nmain(){\n  string a;\n  while(cin>>a ){\n    char index=0;\n    int rem[8]={0};\n    map<string,char> M;\n    M[a]=(char)index++;\n    rem[M[a]]++;\n    REP(i,1,8){\n      cin>>a;\n      if ( M.find(a) == M.end())\n      M[a]=(char)index++;\n      rem[M[a]]++;\n    }\n    state ini;\n    set<state> S;\n    generate(M.size(),rem,ini,0,S);\n    cout << S.size() << endl;\n    /*\n    set<state>::iterator itr = S.begin();\n    while(itr != S.end()){\n      puts(\"upper\");\n      rep(i,4)\n\tcout << (int)(*itr).data[i];\n      puts(\"\");\n      puts(\"lower\");\n      rep(i,4)cout << (int)(*itr).data[i+4];\n      puts(\"\");\n      itr++;\n    }\n    */\n  }\n  return false;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nunsigned long xor128(){\n    static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned long t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nint a[][4] = {{0, 1, 2, 3},\n              {4, 5, 6, 7},\n              {0, 1, 5, 4},\n              {3, 2, 6, 7},\n              {0, 4, 7, 3},\n              {1, 5, 6, 2}};\n\nint main()\n{\n    for(;;){\n        vector<string> s(8);\n        for(int i=0; i<8; ++i){\n            if(!(cin >> s[i]))\n                return 0;\n        }\n        sort(s.begin(), s.end());\n\n        set<vector<string> > x;\n        do{\n            vector<string> t = s;\n            bool ok = true;\n\n            for(int i=0; i<500; ++i){\n                int b = xor128() % 3;\n                for(int j=0; j<3; ++j){\n                    swap(t[a[b*2][j]], t[a[b*2][j+1]]);\n                    swap(t[a[b*2+1][j]], t[a[b*2+1][j+1]]);\n                }\n                if(x.find(t) != x.end()){\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok)\n                x.insert(s);\n        }while(next_permutation(s.begin(), s.end()));\n\n        cout << x.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nint num[8];\nvector<int> f;\n\nvoid solve(){\n\tint cnt = 0;\n\tm.clear(); f.clear();\n\trep(i,8) num[i] = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tnum[cnt]++;\n\t\t\tcnt++;\n\t\t} else num[m[str[i]]]++;\n\t}\n\trep(i,8) if(num[i] > 0) f.push_back(num[i]);\n\tsort(f.begin(),f.end());\n\tif(f.size() == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 1){\n\t\tcout << 1 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 2){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t}\n\tif(f.size() == 2 && f[0] == 3){\n\t\tcout << 3 << endl;\n\t\treturn;\n\t} else if(f.size() == 2 && f[0] == 4){\n\t\tcout << 7 << endl;\n\t\treturn;\n\t}\n\tlong long ans = 0;\n\tint x[8];\n\tif(f[0] == 1){\n\t\tfor(int i = 1; i < f.size(); i++){\n\t\t\tf[i]--;\n\t\t\tfor(int j = 0; j < (1<<(f.size()-1)*2); j++){\n\t\t\t\tint J = j, checker = 0;\n\t\t\t\tvector<int> y, z;\n\t\t\t\tfor(int k = 1; k < f.size(); k++){\n\t\t\t\t\tx[k] = J%4;\n\t\t\t\t\tif(x[k] > 0) y.push_back(x[k]);\n\t\t\t\t\tchecker += x[k];\n\t\t\t\t\tJ /= 4;\n\t\t\t\t}\n\t\t\t\tif(checker != 3) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] < x[k]) checker = -1;\n\t\t\t\tif(checker == -1) continue;\n\t\t\t\tfor(int k = 1; k < f.size(); k++) if(f[k] > x[k]) z.push_back(f[k]-x[k]);\n\t\t\t\tif(y.size() == 1){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 1;\n\t\t\t\t\tif(z.size() == 3) ans += 2;\n\t\t\t\t} else if(y.size() == 2){\n\t\t\t\t\tif(z.size() == 1) ans += 1;\n\t\t\t\t\tif(z.size() == 2) ans += 3;\n\t\t\t\t\tif(z.size() == 3) ans += 6;\n\t\t\t\t} else{\n\t\t\t\t\tif(z.size() == 1) ans += 2;\n\t\t\t\t\tif(z.size() == 2) ans += 6;\n\t\t\t\t\tif(z.size() == 3) ans += 12;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i]++;\n\t\t}\n\t} else if(f[0] == 2){\n\t\tif(f[1] == 3){\n\t\t\tans = 24;\n\t\t} else{\n\t\t\tif(f[2] == 2) ans = 114;\n\t\t\telse ans = 22;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint color[8];\nmap<string,int> used;\nset<int> S;\nint t;\n\nvoid rot1(){\n  rep(i,3)swap(color[i],color[i+1]);\n  rep(i,3)swap(color[i+4],color[i+5]);\n}\n\nvoid rot2(){\n  swap(color[0],color[4]);  swap(color[1],color[5]);\n  swap(color[4],color[7]);  swap(color[5],color[6]);\n  swap(color[7],color[3]);  swap(color[6],color[2]);\n}\n\nbool check(){\n  int s=0;\n  rep(i,8)s=s*10+color[i];\n  t=s;\n  return S.count(t)!=0;\n}\n\nvoid solve(){\n  S.clear();\n  int num[8];\n  int cp[8];\n  rep(i,8)num[i]=i,cp[i]=color[i];\n  do{\n    rep(i,8)color[i]=cp[num[i]];\n    bool f=false;\n    rep(i,4){ rot1();\n      rep(j,4){ rot2();\n\trep(k,4){ rot1();\n\t  if(check())f=true;\n\t}\n      }\n    }\n    if(!f)S.insert(t);\n  }while(next_permutation(num,num+8));\n  cout<<S.size()<<endl;\n}\n\nstring in[8];\nint main(){\n  while(cin>>in[7]){\n    rep(i,7)cin>>in[i];\n    used.clear();\n    int Num=1;\n    rep(i,8){\n      if(!used.count(in[i]))\n\tused[in[i]]=Num++;\n      color[i]=used[in[i]];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid shift(int &a, int &b, int &c, int &d){\n  int tmp = a;\n  a = b;\n  b = c;\n  c = d;\n  d = tmp;\n}\n\nvoid rotx(vector<int> &v){\n  shift(v[0], v[1], v[2], v[3]);\n  shift(v[4], v[5], v[6], v[7]);\n}\n\nvoid roty(vector<int> &v){\n  shift(v[0], v[1], v[5], v[4]);\n  shift(v[6], v[7], v[3], v[2]);\n}\n\nvoid rotz(vector<int> &v){\n  shift(v[0], v[4], v[7], v[3]);\n  shift(v[1], v[2], v[6], v[5]);\n}\n\nvector<int> normalize(vector<int> v){\n  vector<int> res = v;\n  REP(i, 4){\n    REP(j, 4){\n      REP(k, 4){\n        res = min(res, v);\n        rotx(v);\n      }\n      roty(v);\n    }\n    rotx(v);\n  }\n  return res;\n}\n\nint main(){\n  string line;\n  while(getline(cin, line)){\n    string tmp;\n    istringstream in(line);\n\n    int cc = 0;\n    map<string, int> color;\n    vector<int> v;\n    \n    while(in >> tmp){\n      if(color.find(tmp) == color.end()) color[tmp] = cc++;\n      v.push_back(color[tmp]);\n    }\n    \n    vector<int> p(7);\n    REP(i, 7) p[i] = i;\n\n    set<vector<int > > oct_set;\n    \n    do{\n      vector<int> oct(8);\n      oct[7] = v[7];\n      REP(i, 7) oct[p[i]] = v[i];\n      oct_set.insert(normalize(oct));\n    }while(next_permutation(ALL(p)));\n    cout << oct_set.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nint cc[8];\n\nint solve(vector<int> c)\n{\n\tint s, t;\n\tint m = INF;\n\n\trep(i1, 0, 4) rep(i2, 0, 4) rep(i3, 0, 4)\n\t{\n\t\trep(i, 0, 8) cc[i] = c[i];\n\n\t\trep(i, 0, i1)\n\t\t{\n\t\t\tt = cc[0];\n\t\t\tcc[0] = cc[4];\n\t\t\tcc[4] = cc[7];\n\t\t\tcc[7] = cc[3];\n\t\t\tcc[3] = t;\n\n\t\t\tt = cc[1];\n\t\t\tcc[1] = cc[5];\n\t\t\tcc[5] = cc[6];\n\t\t\tcc[6] = cc[2];\n\t\t\tcc[2] = t;\n\t\t}\n\n\t\trep(i, 0, i2)\n\t\t{\n\t\t\tt = cc[0];\n\t\t\tcc[0] = cc[1];\n\t\t\tcc[1] = cc[5];\n\t\t\tcc[5] = cc[4];\n\t\t\tcc[4] = t;\n\n\t\t\tt = cc[3];\n\t\t\tcc[3] = cc[2];\n\t\t\tcc[2] = cc[6];\n\t\t\tcc[6] = cc[7];\n\t\t\tcc[7] = t;\n\t\t}\n\n\t\trep(i, 0, i3)\n\t\t{\n\t\t\tt = cc[0];\n\t\t\tcc[0] = cc[1];\n\t\t\tcc[1] = cc[2];\n\t\t\tcc[2] = cc[3];\n\t\t\tcc[3] = t;\n\n\t\t\tt = cc[4];\n\t\t\tcc[4] = cc[5];\n\t\t\tcc[5] = cc[6];\n\t\t\tcc[6] = cc[7];\n\t\t\tcc[7] = t;\n\t\t}\n\n\t\ts = 0;\n\t\trep(i, 0, 8) s = s * 10 + cc[i];\n\t\tm = min(m, s);\n\t}\n\n\treturn m;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s[8];\n\twhile (cin >> s[0])\n\t{\n\t\trep(i, 1, 8) cin >> s[i];\n\n\t\tmap<string, int> m;\n\t\trep(i, 0, 8) m[s[i]] = 0;\n\t\tint i = 0;\n\t\tfor (auto p : m)\n\t\t{\n\t\t\tm[p.first] = i;\n\t\t\ti++;\n\t\t}\n\n\t\tvector<int> c(8);\n\t\trep(i, 0, 8) c[i] = m[s[i]];\n\n\t\tset<int> ans;\n\t\tsort(c.begin(), c.end());\n\t\tdo\n\t\t{\n\t\t\tans.insert(solve(c));\n\t\t} while (next_permutation(c.begin(), c.end()));\n\t\t\n\t\tcout << ans.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nstring str[8];\nmap<string,int> m;\nvector<int> x, y, v;\nset<vector<int> > se;\n\nvector<int> change(vector<int> yy, int u){\n\tif(u == 0) return yy;\n\tif(u == 1){\n\t\tyy[0] = y[1]; yy[1] = y[3]; yy[2] = y[0]; yy[3] = y[2];\n\t\tyy[4] = y[5]; yy[5] = y[7]; yy[6] = y[4]; yy[7] = y[6];\n\t}\n\tif(u == 2){\n\t\tyy[0] = y[2]; yy[1] = y[0]; yy[2] = y[3]; yy[3] = y[1];\n\t\tyy[4] = y[6]; yy[5] = y[4]; yy[6] = y[7]; yy[7] = y[5];\n\t}\n\tif(u == 3){\n\t\tyy[0] = y[3]; yy[1] = y[2]; yy[2] = y[1]; yy[3] = y[0];\n\t\tyy[4] = y[7]; yy[5] = y[6]; yy[6] = y[5]; yy[7] = y[4];\n\t}\n\tif(u == 4){\n\t\tyy[0] = y[4]; yy[1] = y[6]; yy[2] = y[5]; yy[3] = y[7];\n\t\tyy[4] = y[0]; yy[5] = y[2]; yy[6] = y[1]; yy[7] = y[3];\n\t}\n\tif(u == 5){\n\t\tyy[0] = y[5]; yy[1] = y[4]; yy[2] = y[7]; yy[3] = y[6];\n\t\tyy[4] = y[1]; yy[5] = y[0]; yy[6] = y[3]; yy[7] = y[2];\n\t}\n\tif(u == 6){\n\t\tyy[0] = y[6]; yy[1] = y[7]; yy[2] = y[4]; yy[3] = y[5];\n\t\tyy[4] = y[2]; yy[5] = y[3]; yy[6] = y[0]; yy[7] = y[1];\n\t}\n\tif(u == 7){\n\t\tyy[0] = y[7]; yy[1] = y[6]; yy[2] = y[5]; yy[3] = y[4];\n\t\tyy[4] = y[3]; yy[5] = y[2]; yy[6] = y[1]; yy[7] = y[0];\n\t}\n\treturn yy;\n}\n\nvoid solve(){\n\tm.clear();\n\tse.clear();\n\tx.clear();\n\tx.resize(8);\n\tint cnt = 0;\n\trep(i,8){\n\t\tif(m.count(str[i]) == 0){\n\t\t\tm[str[i]] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trep(i,8) x[i] = i;\n\tdo{\n\t\tbool ok = true;\n\t\trep(u,8){\n\t\t\ty = x;\n\t\t\tif(str[y[u]] != str[x[0]]) continue;\n\t\t\ty = change(y,u);\n\t\t\trep(i,3){\n\t\t\t\tv.clear();\n\t\t\t\trep(j,8) v.push_back(m[str[y[j]]]);\n\t\t\t\tif(se.count(v) > 0){\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswap(y[4],y[1]); swap(y[1],y[2]); swap(y[3],y[5]); swap(y[6],y[3]);\n\t\t\t}\n\t\t\tif(!ok) break;\n\t\t}\n\t\tif(ok){\n\t\t\tse.insert(v);\n\t\t}\n\t} while(next_permutation(x.begin()+1,x.end()));\n\tcout << se.size() << endl;\n}\n\nint main(){\n\twhile(cin >> str[0]){\n\t\tfor(int i = 1; i < 8; i++) cin >> str[i];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint encode(VI& vi){\n  int res = 0;\n  for(int i=0;i<8;++i)\n\tres = res * 8 + vi[i];\n  return res;\n}\n\nvoid g(VI& num){\n  int tmp = num[0];\n  REP(j,3)\n\tnum[j] = num[j+1];\n  num[3] = tmp;\n  \n  tmp = num[4];\n  REP(j,3)\n\tnum[j+4] = num[j+5];\n  num[7] = tmp;\n}\nvoid func(VI num, set<int>& memo){\n  memo.insert(encode(num));\n  REP(i,4){\n\tg(num);\n\tmemo.insert(encode(num));\n  }\n  VI num2 = num;\n  num2[1] = num[3];\n  num2[2] = num[7];\n  num2[3] = num[4];\n  num2[4] = num[1];\n  num2[5] = num[2];\n  num2[6] = num[6];\n  num2[7] = num[5];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  num2[0] = num[4];\n  num2[1] = num[7];\n  num2[2] = num[6];\n  num2[3] = num[5];\n  num2[4] = num[0];\n  num2[5] = num[3];\n  num2[6] = num[2];\n  num2[7] = num[1];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  num2[0] = num[3];\n  num2[1] = num[2];\n  num2[2] = num[6];\n  num2[3] = num[7];\n  num2[4] = num[0];\n  num2[5] = num[1];\n  num2[6] = num[5];\n  num2[7] = num[4];\n  REP(i,4){\n\tg(num2);\n\tmemo.insert(encode(num2));\n  }\n  \n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string s[8];\n  while(cin >> s[0]){\n\tint cnt = 0;\n\tVI num(8,0);\n\tmap<string, int> mp;\n\tmp[s[0]] = cnt++;\n\tREP(i,7){\n\t  cin >> s[i+1];\n\t  if(!mp.count(s[i+1]))\n\t\tmp[s[i+1]] = cnt++;\n\t}\n\tREP(i,8)\n\t  num[i] = mp[s[i]];\n\tSORT(num);\n\n\tint ans = 0;\n\tset<int> memo;\n\tdo{\n\t  if(memo.count(encode(num))) continue;\n\t  ++ans;\n\t  func(num, memo);\n\t}while(next_permutation(ALL(num)));\n\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nll table_4[24][4],index_8,leftTable[24],rightTable[24],m_data[8] = {0,1,2,3,4,5,6,7};\nll* table_8;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid calc8(){\n\n\tint select_num = 4,num,loc_left[4],loc_right[4],left_index,right_index,index,calc[4],value;\n\n\tindex_8 = 0;\n\n\tfor(int i = 0; i < 256;i++){\n\t\tnum = 0;\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tif(i & (1 << k))num++;\n\t\t}\n\t\tif(num != select_num)continue;\n\n\t\tleft_index = right_index = 0;\n\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tif(i & (1 << k)){\n\t\t\t\tloc_left[left_index++] = k;\n\t\t\t}else{\n\t\t\t\tloc_right[right_index++] = k;\n\t\t\t}\n\t\t}\n\n\t\tleft_index = right_index = 0;\n\n\t\tcalc[0] = m_data[loc_left[0]],calc[1] = m_data[loc_left[1]],calc[2] = m_data[loc_left[2]],calc[3] = m_data[loc_left[3]];\n\n\t\tfor(index = 0;index < 24; index++){\n\t\t\tvalue = 0;\n\t\t\tfor(int p = 0; p < 4;p++){\n\t\t\t\tvalue = 10*value + calc[table_4[index][p]];\n\t\t\t}\n\t\t\tleftTable[left_index++] = value;\n\t\t}\n\n\t\tcalc[0] = m_data[loc_right[0]],calc[1] = m_data[loc_right[1]],calc[2] = m_data[loc_right[2]],calc[3] = m_data[loc_right[3]];\n\n\t\tfor(index = 0;index < 24; index++){\n\t\t\tvalue = 0;\n\t\t\tfor(int p = 0; p < 4;p++){\n\t\t\t\tvalue = 10*value + calc[table_4[index][p]];\n\t\t\t}\n\t\t\trightTable[right_index++] = value;\n\t\t}\n\n\t\tfor(int k = 0; k < 24; k++){\n\t\t\tfor(int p = 0; p < 24; p++){\n\t\t\t\ttable_8[index_8++] = 10000*leftTable[k] + rightTable[p];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\ttable_8 = new ll[40320];\n\n\tint index_4 = 0;\n\n\tfor(int a = 0; a < 4; a++){\n\t\tfor(int b = 0; b < 4; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tif(a != b && a != c && a != d && b != c && b != d && c != d){\n\t\t\t\t\t\ttable_4[index_4][0] = a,table_4[index_4][1] = b,table_4[index_4][2] = c,table_4[index_4][3] = d;\n\t\t\t\t\t\tindex_4++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcalc8();\n\n\tint DIV = 10,line;\n\n\tint **calc_table = new int*[40320];\n\tfor(int i = 0; i < 40320; i++){\n\t\tcalc_table[i] = new int[8];\n\t\tline = table_8[i];\n\t\tfor(int k = 0; k < 8; k++){\n\t\t\tcalc_table[i][7-k] = line%DIV;\n\t\t\tline /= DIV;\n\t\t}\n\t}\n\n\tchar colors[8][21],buf[21],all_color[200],work[8][21],tmp_work[8][21];\n\tint array[24][8] = {{0,1,2,3,4,5,6,7},\n\t\t\t\t\t\t{7,6,5,4,3,2,1,0},\n\t\t\t\t\t\t{3,0,1,2,7,4,5,6},\n\t\t\t\t\t\t{6,5,4,7,2,1,0,3},\n\t\t\t\t\t\t{2,3,0,1,6,7,4,5},\n\t\t\t\t\t\t{5,4,7,6,1,0,3,2},\n\t\t\t\t\t\t{1,2,3,0,5,6,7,4},\n\t\t\t\t\t\t{4,7,6,5,0,3,2,1},\n\n\t\t\t\t\t\t{7,3,2,6,4,0,1,5},\n\t\t\t\t\t\t{5,1,0,4,6,2,3,7},\n\t\t\t\t\t\t{6,7,3,2,5,4,0,1},\n\t\t\t\t\t\t{1,0,4,5,2,3,7,6},\n\t\t\t\t\t\t{2,6,7,3,1,5,4,0},\n\t\t\t\t\t\t{0,4,5,1,3,7,6,2},\n\t\t\t\t\t\t{3,2,6,7,0,1,5,4},\n\t\t\t\t\t\t{4,5,1,0,7,6,2,3},\n\n\n\t\t\t\t\t\t{7,4,0,3,6,5,1,2},\n\t\t\t\t\t\t{2,1,5,6,3,0,4,7},\n\t\t\t\t\t\t{3,7,4,0,2,6,5,1},\n\t\t\t\t\t\t{1,5,6,2,0,4,7,3},\n\t\t\t\t\t\t{0,3,7,4,1,2,6,5},\n\t\t\t\t\t\t{5,6,2,1,4,7,3,0},\n\t\t\t\t\t\t{4,0,3,7,5,1,2,6},\n\t\t\t\t\t\t{6,2,1,5,7,3,0,4}\n\t\t\t\t\t\t};\n\n\tset<string> S;\n\n\tbool FLG;\n\n\tint index,ans;\n\n\twhile(scanf(\"%s\",buf) != EOF){\n\t\tstrcpy(colors[0],buf);\n\t\tfor(int i = 1; i <= 7; i++){\n\t\t\tscanf(\"%s\",colors[i]);\n\t\t}\n\n\t\tS.clear();\n\n\t\tindex = 0;\n\n\t\tfor(int i = 0; i < 8; i++){\n\t\t\tfor(int k = 0; colors[i][k] != '\\0'; k++){\n\t\t\t\tall_color[index++] = colors[i][k];\n\t\t\t}\n\t\t}\n\t\tall_color[index] = '\\0';\n\n\t\tS.insert(string(all_color));\n\n\t\tans = 1;\n\n\t\tfor(int i = 0; i < 40320; i++){\n\n\t\t\tfor(int k = 0; k < 8; k++){\n\t\t\t\tstrcpy(work[k],colors[calc_table[i][k]]);\n\t\t\t}\n\n\t\t\tFLG = true;\n\n\t\t\tfor(int a = 0;a < 24; a++){\n\t\t\t\tfor(int b = 0; b < 8; b++){\n\t\t\t\t\tstrcpy(tmp_work[b],work[array[a][b]]);\n\t\t\t\t}\n\t\t\t\tindex = 0;\n\t\t\t\tfor(int b = 0; b < 8; b++){\n\t\t\t\t\tfor(int c = 0; tmp_work[b][c] != '\\0'; c++){\n\t\t\t\t\t\tall_color[index++] = tmp_work[b][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tall_color[index] = '\\0';\n\n\t\t\t\tif(S.count(string(all_color)) != 0){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG){\n\t\t\t\tS.insert(string(all_color));\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <vector>\n \nusing namespace std;\n \nclass Octahedra{\npublic:\n    vector<int> x;\n \n    Octahedra(){\n\tx.resize(8);\n    }\n   \n    void rollLR(){\n\tint tmp = x[0];\n\tx[0] = x[3];\n\tx[3] = x[4];\n\tx[4] = x[1];\n\tx[1] = tmp;\n \n\ttmp = x[7];\n\tx[7] = x[6];\n\tx[6] = x[5];\n\tx[5] = x[2];\n\tx[2] = tmp;\n    }\n \n    void rollTF(){\n\tswap(x[0],x[7]);\n\tswap(x[1],x[2]);\n\tswap(x[4],x[5]);\n\tswap(x[3],x[6]);\n    }\n \n    void rollR(){\n\tint tmp = x[0];\n\tx[0] = x[7];\n\tx[7] = x[2];\n\tx[2] = x[1];\n\tx[1] = tmp;\n     \n\ttmp = x[3];\n\tx[3] = x[6];\n\tx[6] = x[5];\n\tx[5] = x[4];\n\tx[4] = tmp;\n    }\n \n    bool equal(const Octahedra &o){\n\tfor(int i = 0 ; i < 8 ; i++){\n\t    if(x[i] != o.x[i]) return false;\n\t}\n\treturn true;\n    }\n \n    bool operator == (const Octahedra &o){\n\tfor(int i = 0 ; i < 2 ; i++){\n\t    for(int j = 0 ; j < 4 ; j++){\n\t\tif(equal(o)) return true;\n\t\trollLR();\n\t    }\n\t    rollTF();\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    for(int j = 0 ; j < 4 ; j++){\n\t\tif(equal(o)) return true;\n\t\trollLR();\n\t    }\n\t    rollR();\n\t}\n\trollLR();\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    for(int j = 0 ; j < 4 ; j++){\n\t\tif(equal(o)) return true;\n\t\trollLR();\n\t    }\n\t    rollR();\n\t}\n\treturn false;\n    }\n \n    bool operator < (const Octahedra &o)const{\n\tfor(int i = 0 ; i < 8 ; i++){\n\t    if(x[i] != o.x[i]){\n\t\treturn x[i] < o.x[i];\n\t    }\n\t}\n    }\n};\n \nint main(){\n    map<string,int> mp;\n    string s;\n    while(cin >> s){\n\tOctahedra o;\n\tmp.clear(); mp[s] = 0;\n\to.x[0] = 0;\n\tint idx = 1;\n\tset<Octahedra> st;\n\tfor(int i = 0 ; i < 7 ; i++){\n\t    cin >> s;\n\t    if(mp.find(s) == mp.end()){\n\t\tmp[s] = idx++;\n\t    }\n\t    o.x[i+1] = mp[s];\n\t}\n\tsort(o.x.begin(),o.x.end());\n\tset<Octahedra>::iterator it;\n\tdo{\n\t    bool found = false;\n\t    for(it = st.begin() ; it != st.end() ; ++it){\n\t\tOctahedra a = *it;\n\t\tif(a == o){\n\t\t    found = true;\n\t\t    break;\n\t\t}\n\t    }\n\t    if(!found){\n\t\tst.insert(o);\n\t    }\n\t}while(next_permutation(o.x.begin(),o.x.end()));\n\tcout << st.size() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nvoid shift(int &a, int &b, int &c, int &d){\n  int tmp = a;\n  a = b;\n  b = c;\n  c = d;\n  d = tmp;\n}\n\nvoid rotx(vector<int> &v){\n  shift(v[0], v[1], v[2], v[3]);\n  shift(v[4], v[5], v[6], v[7]);\n}\n\nvoid roty(vector<int> &v){\n  shift(v[0], v[1], v[5], v[4]);\n  shift(v[6], v[7], v[3], v[2]);\n}\n\nvoid rotz(vector<int> &v){\n  shift(v[0], v[4], v[7], v[3]);\n  shift(v[1], v[2], v[6], v[5]);\n}\n\nvector<int> normalize(vector<int> v){\n  vector<int> res = v;\n  REP(i, 4){\n    REP(j, 4){\n      REP(k, 4){\n        res = min(res, v);\n        rotx(v);\n      }\n      roty(v);\n    }\n    rotx(v);\n  }\n  return res;\n}\n\nint main(){\n  string line;\n  while(getline(cin, line)){\n    string tmp;\n    istringstream in(line);\n\n    int cc = 0;\n    map<string, int> color;\n    vector<int> v;\n    \n    while(in >> tmp){\n      if(color.find(tmp) == color.end()) color[tmp] = cc++;\n      v.push_back(color[tmp]);\n    }\n    \n    vector<int> p(7);\n    REP(i, 7) p[i] = i;\n\n    set<vector<int > > oct_set;\n    \n    do{\n      vector<int> oct(8);\n      oct[7] = v[7];\n      REP(i, 7) oct[p[i]] = v[i];\n      oct_set.insert(normalize(oct));\n    }while(next_permutation(ALL(p)));\n    a\n    cout << oct_set.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    const int idx1[]={0,4,5,1,3,7,6,2};\n    const int idx2[]={0,3,7,4,1,2,6,5};\n    auto equal=[&](const vector<int>& x,const vector<int>& y){\n        auto equal_=[](const vector<int> &a,vector<int> b){\n            auto equal__=[&]{\n                rep(i,0,4){\n                    bool ok=true;\n                    rep(j,0,4) if(a[j]!=b[(i+j)%4] or a[4+j]!=b[(4+i+j>=8?i+j:4+i+j)]){\n                        ok=false;\n                        break;\n                    }\n                    if(ok) return true;\n                }\n                return false;\n            };\n            if(equal__()) return true;\n            reverse(b.begin(),b.end());\n            return equal__();\n        };\n        if(equal_(x,y)) return true;\n        vector<int> tmp(8);\n        rep(i,0,8) tmp[i]=y[idx1[i]];\n        if(equal_(x,tmp)) return true;\n        rep(i,0,8) tmp[i]=y[idx2[i]];\n        return equal_(x,tmp);\n    };\n    string tmp;\n    while(cin >> tmp){\n        vector<string> color(8);\n        color[0]=tmp;\n        rep(i,1,8) cin >> color[i];\n\n        map<string,int> mp;\n        int cnt=0;\n        rep(i,0,8) if(mp.find(color[i])==mp.end()){\n            mp[color[i]]=cnt;\n            ++cnt;\n        }\n        vector<int> v(8);\n        rep(i,0,8) v[i]=mp[color[i]];\n        sort(v.begin(),v.end());\n\n        vector<vector<int>> all;\n        do{\n            bool ok=true;\n            for(const auto& a:all) if(equal(v,a)){\n                ok=false;\n                break;\n            }\n            if(ok) all.emplace_back(v);\n        }while(next_permutation(v.begin(),v.end()));\n\n        cout << all.size() << endl;\n    }\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\nclass Octahedra {\npublic:\n  string s[8];\n  int ind[8];\n  Octahedra() {\n    for(int i = 0; i < 8; ++i) ind[i] = i;\n  }\n  void reverse() {\n    int tmp;\n    tmp = ind[0];\n    ind[0] = ind[5];\n    ind[5] = tmp;\n    tmp = ind[1];\n    ind[1] = ind[6];\n    ind[6] = tmp;\n    tmp = ind[2];\n    ind[2] = ind[7];\n    ind[7] = tmp;\n    tmp = ind[3];\n    ind[3] = ind[4];\n    ind[4] = tmp;\n  }\n  void roll1(int n) {\n    for(int i = 0; i < n; ++i) {\n      int tmp;\n      tmp = ind[3];\n      ind[3] = ind[0];\n      ind[0] = ind[1];\n      ind[1] = ind[2];\n      ind[2] = tmp;\n      tmp = ind[4];\n      ind[4] = ind[7];\n      ind[7] = ind[6];\n      ind[6] = ind[5];\n      ind[5] = tmp;\n    }\n  }\n  void roll2(int n) {\n    for(int i = 0; i < n; ++i) {\n      int tmp;\n      tmp = ind[0];\n      ind[0] = ind[2];\n      ind[2] = ind[4];\n      ind[4] = tmp;\n      tmp = ind[1];\n      ind[1] = ind[5];\n      ind[5] = ind[7];\n      ind[7] = tmp;\n    }\n  }\n};\n\nstring str[8];\n\nbool isEqual(Octahedra &oct, Octahedra &o2) {\n  bool flag = false;\n  for(int i = 0; i < 8; ++i) o2.ind[i] = i;\n  for(int k = 0; k < 4; ++k) {\n    for(int j = 0; j < 3; ++j) {\n      for(int i = 0; i < 8; ++i) {\n\tif(o2.s[o2.ind[i]] != oct.s[oct.ind[i]]) break;\n\tif(i == 7) flag = true;\n      }\n      if(flag) return true;\n      o2.roll2(1);\n    }\n    o2.roll1(1);\n  }\n  o2.reverse();\n  for(int k = 0; k < 4; ++k) {\n    for(int j = 0; j < 3; ++j) {\n      for(int i = 0; i < 8; ++i) {\n\tif(o2.s[o2.ind[i]] != oct.s[oct.ind[i]]) break;\n\tif(i == 7) flag = true;\n      }\n      if(flag) return true;\n      o2.roll2(1);\n    }\n    o2.roll1(1);\n  }\n  return false;\n}\n\nint solve() {\n  vector<Octahedra> count;\n  sort(str, str+8);\n  do {\n    Octahedra oct;\n    for(int i = 0; i < 8; ++i) oct.s[i] = str[i];\n    bool flag = false;\n    for(int i = 0; i < count.size(); ++i) {\n      if(isEqual(count[i], oct)) break;\n      if(i == count.size() - 1) flag = true;\n    }\n    if(flag || count.size() == 0) {\n      count.push_back(oct);\n    }\n  } while(next_permutation(str, str+8));\n  return count.size();\n}\n\nmain() {\n  while((cin >> str[0])) {\n    for(int i = 1; i < 8; ++i) cin >> str[i];\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& xs) {\n        if (xs.empty()) return os << \"[]\";\n        os << \"[\" << xs[0];\n        for (int i = 1; i < xs.size(); i++) os << \" \" << xs[i];\n        return os << \"]\";\n    }\n\n    vector<string> F;\n    bool input() {\n        F.clear(); F.resize(8);\n        string s;\n        getline(cin, s);\n        if (cin.eof()) return false;\n        istringstream is(s);\n        for (int i = 0; i < 8; i++) {\n            string t; is >> t;\n            F[i] = t;\n        }\n        return true;\n    }\n\n    vector<int> xs[3];\n    void init() {\n        for (int i = 0; i < 3; i++) \n            xs[i].resize(4);\n        xs[0][0] = 0; xs[0][1] = 1; xs[0][2] = 2; xs[0][3] = 3;\n        xs[1][0] = 1; xs[1][1] = 2; xs[1][2] = 7; xs[1][3] = 4;\n        xs[2][0] = 0; xs[2][1] = 1; xs[2][2] = 4; xs[2][3] = 5;\n    }\n\n    void rot(vector<int>& ys) {\n        int t = ys[3];\n        for (int i = 3; i >= 0; i--) ys[i] = ys[i - 1];\n        ys[0] = t;\n    }\n\n    void rot(vector<string>& s, int index) {\n        vector<int>& from = xs[index];\n        vector<int> to = xs[index];\n        rot(to);\n        vector<string> t = s;\n        for (int i = 0; i < 4; i++) {\n            s[ to[i] ] = t[ from[i] ];\n            s[ 7 - to[i] ] = t[ 7 - from[i] ];\n        }\n    }\n\n    void dfs(vector<string>& s, int index, set< vector<string> >& X) {\n        if (index == 3) return;\n        for (int i = 0; i < 4; i++) {\n            X.insert(s);\n            rot(s, index);\n            dfs(s, index + 1, X);\n        }\n    }\n\n    void solve() {\n        set< vector<string> > X;\n        sort(F.begin(), F.end());\n        int ans = 0;\n        do {\n            if (X.count(F)) continue;\n            ans++;\n            dfs(F, 0, X);\n        } while (next_permutation(F.begin(), F.end()));\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    init();\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <string>\nusing namespace std;\n\nstruct Oct {\n    int c[8];\n    bool operator<(const Oct &rhs) const {\n        for (int j=0;j<8;++j) {\n            if (c[j]<rhs.c[j]) return true;\n            else if (c[j]>rhs.c[j]) return false;\n        }\n        return false;\n    }\n};\n\nstring color[8];\nint col[8];\nmap<string,int> mp;\n\nOct x_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[2];\n    rt.c[2]=ot.c[6];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[0];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[4];\n    return rt;\n}\n\nOct y_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[4];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[3];\n    rt.c[3]=ot.c[7];\n    rt.c[4]=ot.c[5];\n    rt.c[5]=ot.c[1];\n    rt.c[6]=ot.c[2];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct z_rot(Oct ot)\n{\n    Oct rt;\n    rt.c[0]=ot.c[3];\n    rt.c[1]=ot.c[0];\n    rt.c[2]=ot.c[1];\n    rt.c[3]=ot.c[2];\n    rt.c[4]=ot.c[7];\n    rt.c[5]=ot.c[4];\n    rt.c[6]=ot.c[5];\n    rt.c[7]=ot.c[6];\n    return rt;\n}\n\nOct gOct;\nOct sortOct[64];\nset<Oct> ans;\n\nvoid calc(int depth, int pos) {\n    if (depth == 8) {\n        Oct temp = gOct;\n        for (int x = 0; x < 4; x++) {\n            for (int y = 0; y < 4; y++) {\n                for (int z = 0; z < 4; z++) {\n                    sortOct[x + y * 4 + z * 16] = temp;\n                    temp = z_rot(temp);\n                }\n                temp = y_rot(temp);\n            }\n            temp = x_rot(temp);\n        }\n        sort(sortOct, sortOct + 64);\n        ans.insert(sortOct[0]);\n        return;\n    }\n    for (int i = 0; i < 8; i++) {\n        if ((pos >> i) & 1) { continue; }\n        gOct.c[depth] = col[i];\n        calc(depth + 1, pos | (1 << i));\n    }\n}\n\n\nint main()\n{\nwhile (true) {\n    for (int j=0;j<8;++j)\n        if (!(cin >> color[j])) { return 0; }\n    for (int j=0;j<8;++j) {\n        if (mp.find(color[j])!=mp.end())\n            col[j]=mp[color[j]];\n        else {\n            col[j]=mp.size();\n            mp[color[j]]=col[j];\n        }\n    }\n\n    calc(0,0);\n    cout << ans.size() << endl;\n}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<map>\n#include<string>\n#include<set>\n#include<algorithm>\nusing namespace std;\nint o[8];\nchar st[111];\nint p[3][8] = {\n\t{1, 2, 3, 0, 5, 6, 7, 4},\n\t{5, 6, 1, 0, 3, 4, 7, 2},\n\t{5, 0, 3, 4, 7, 6, 1, 2}\n};\nvector<int> permu(const vector<int> & v, int * p) {\n\tvector<int> res(v);\n\tfor(int i(0); i < 8; i++) {\n\t\tres[i] = v[p[i]];\n\t}\n\treturn res;\n}\nint main() {\n\tfor(;;) {\n\t\tif(scanf(\"%s\", st) == 1) {\n\t\t\tint cnt(0);\n\t\t\tvector<int> vec;\n\t\t\tmap<string, int> mp;\n\t\t\tfor(int i(0); i < 8; i++) {\n\t\t\t\tif(i > 0) {\n\t\t\t\t\tscanf(\"%s\", st);\n\t\t\t\t}\n\t\t\t\tif(!mp.count(st)) {\n\t\t\t\t\tmp[st] = cnt++;\n\t\t\t\t}\n\t\t\t\tvec.push_back(mp[st]);\n\t\t\t}\n\t\t\tfor(int i(0); i < 8; i++) {\n\t\t\t\to[i] = i;\n\t\t\t}\n\t\t\tvector<int> vec1(vec);\n\t\t\tset<long long> st;\n\t\t\tint ans(0);\n\t\t\tdo {\n\t\t\t\tbool flag(false);\n\t\t\t\tvector<int> vec1(permu(vec, o));\n\t\t\t\tfor(int i(0); i < 4; i++) {\n\t\t\t\t\tvector<int> vec2(vec1);\n\t\t\t\t\tfor(int j(0); j < 4; j++) {\n\t\t\t\t\t\tvector<int> vec3(vec2);\n\t\t\t\t\t\tfor(int k(0); k < 4; k++) {\n\t\t\t\t\t\t\tlong long tot(0);\n\t\t\t\t\t\t\tfor(int _(0); _ < 8; _++) {\n\t\t\t\t\t\t\t\ttot = tot * 8 + vec3[_];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(st.count(tot) == 0) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tst.insert(tot);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvec3 = permu(vec3, p[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvec2 = permu(vec2, p[1]);\n\t\t\t\t\t}\n\t\t\t\t\tvec1 = permu(vec1, p[0]);\n\t\t\t\t}\n\t\t\t\tif(flag) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t} while(next_permutation(o, o + 8));\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}else {\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n \nconst int N = 8;\nmap<vi, bool> used;\nint n;\nvector<vi> rot = {{1, 2, 3, 0, 5, 6, 7, 4},\n                  {6, 7, 1, 0, 2, 3, 5, 4}};\n\nvoid dfs(vi perm){\n    if(used[perm]) return;\n    used[perm] = true;\n\n    rep(i, 2){\n        vi next_perm(N);\n        rep(j, N){\n            next_perm[j] = perm[rot[i][j]];\n        }\n        dfs(next_perm);\n    }\n}\n\nint main(void){\n    vector<string> in(N);\n    while(cin >> in[0]){\n        rep(i, 1, N) cin >> in[i];\n        map<string, int> s2i;\n        int idx = -1;\n        vi num_color;\n        for(auto & e : in){\n            if(s2i.find(e) == end(s2i)){\n                idx++;\n                s2i[e] = idx;\n                num_color.push_back(0);\n            }\n            num_color[idx]++;\n        }\n\n        used.clear();\n\n        n = num_color.size();\n        vi perm(N);\n        rep(i, N) perm[i] = s2i[in[i]];\n\n        sort(_all(perm));\n        int res = 0;\n        do {\n            if(not used[perm]){\n                dfs(perm);\n                res++;\n            }\n        } while(next_permutation(_all(perm)));\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std; \nconst int INF = 1e9;\n\nstruct octa {\n    int face[8];\n    void rotate_left(){\n        rotate(face, face+1, face+4);\n        rotate(face+4, face+5, face+8);\n    }\n\n    void rotate_up(){\n        int t = face[0];\n        face[0] = face[4];\n        face[4] = face[7];\n        face[7] = face[3];\n        face[3] = t;\n        t = face[1];\n        face[1] = face[5];\n        face[5] = face[6];\n        face[6] = face[2];\n        face[2] = t;\n    }\n\n    bool equals(octa o) const {\n        if(check(o)) return true;\n        o.rotate_up();\n        if(check(o)) return true;\n        o.rotate_up();\n        if(check(o)) return true;\n        o.rotate_up();\n        if(check(o)) return true;\n        o.rotate_up();\n        o.rotate_left();\n        o.rotate_up();\n        if(check(o)) return true;\n        o.rotate_up();\n        o.rotate_up();\n        if(check(o)) return true;\n        return false;\n    }\n\n    bool check(octa &o) const {\n        rep(i,4){\n            if(equal(face, face+8, o.face)) return true;\n            o.rotate_left();\n        }\n        return false;\n    }\n};\n\nint main(){\n    string s[8];\n    while(cin >> s[0]){\n        rep(i,7) cin >> s[i+1];\n        map<string, int> m;\n        int k = 0;\n        rep(i,8) if(m.count(s[i]) == 0) m[s[i]] = k++;\n        octa o;        \n        rep(i,8) o.face[i] = m[s[i]];\n\n        sort(o.face, o.face+8);\n        vector<octa> s;\n        s.push_back(o);\n        do {\n            bool add = true;\n            for(auto &a : s){\n                if(a.equals(o)){\n                    add = false;\n                    break;\n                }\n            }\n            if(add) s.push_back(o);\n        } while(next_permutation(o.face+1, o.face+8));\n        cout << s.size() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> Vec;\nvoid rotatex(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[2];a[2]=a[3];a[3]=tmp;\n  tmp=a[4];a[4]=a[5];a[5]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatey(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[1];a[1]=a[5];a[5]=a[4];a[4]=tmp;\n  tmp=a[3];a[3]=a[2];a[2]=a[6];a[6]=a[7];a[7]=tmp;\n}\n\nvoid rotatez(Vec &a){\n  int tmp;\n  tmp=a[0];a[0]=a[4];a[4]=a[7];a[7]=a[3];a[3]=tmp;\n  tmp=a[1];a[1]=a[5];a[5]=a[6];a[6]=a[2];a[2]=tmp;\n}\n\nint main(){\n  string s[8];\n  set<Vec> sv;\n  map<Vec,bool> mv;\n  while(cin>>s[0]){\n    int i,j,k,ans=0;\n    sv.clear();mv.clear();\n    for(i=1;i<8;i++) cin>>s[i];\n    sort(s,s+8);\n    set<string> ss;\n    Vec v;\n    for(i=0;i<8;i++) ss.insert(s[i]),v.push_back(ss.size()-1);\n    do{\n      if(sv.find(v)!=sv.end()) continue;\n      ans++;\n      for(i=0;i<4;i++){\n\trotatez(v);\n\tfor(j=0;j<4;j++){\n\t  rotatey(v);\n\t  for(k=0;k<4;k++){\n\t    rotatex(v);\n\t    sv.insert(v);\n\t  }\n\t}\n      }\n    }while(next_permutation(v.begin(),v.end()));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstring s[8];\n\nint latte[6][8]={\n{0,1,2,3,4,5,6,7},\n{1,5,6,2,0,4,7,3},\n{2,6,7,3,1,5,4,0},\n{0,3,7,4,1,2,6,5},\n{0,4,5,1,3,7,6,2},\n{4,7,6,5,0,3,2,1},\n};\n\nvoid solve(){\n    vector<string>v;\n    rep(i,8)v.pb(s[i]);\n    sort(all(v));v.erase(unique(all(v)),v.end());\n\n    vint c(8);\n    rep(i,8)c[i]=lower_bound(all(v),s[i])-v.begin();\n    sort(all(c));\n    set<vint>st;\n\n    do{\n        vint mi=c;\n        rep(i,6){\n            vector<int>cc(8);\n            rep(j,8)cc[j]=c[latte[i][j]];\n            rep(j,4){\n                chmin(mi,cc);\n                rotate(cc.begin(),cc.begin()+1,cc.begin()+4);\n                rotate(cc.begin()+4,cc.begin()+5,cc.begin()+8);\n            }\n        }\n        st.insert(mi);\n    }while(next_permutation(all(c)));\n\n\n    cout<<st.size()<<endl;\n}\n\nsigned main(){\n    while(cin>>s[0]){\n        rep(i,7)cin>>s[i+1];\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\n\nint rot[] = {0,4,5,1,3,7,6,2};\nvector<vi> rots;\n\nvoid next(vi &x){\n  rep(i,3){\n    swap(x[i],x[i+1]);\n    swap(x[i+4],x[i+5]);\n  }\n}\n\null t[1<<18];\n\nint main(){\n  vi tmp;\n  rep(i,8)tmp.push_back(i);\n  rots.push_back(tmp);\n  rep(i,3){\n    next(tmp);\n    rots.push_back(tmp);\n  }\n\n  rep(i,4){\n    tmp = rots[i];\n    reverse(all(tmp));\n    rots.push_back(tmp);\n  }\n\n  rep(i,16){\n    tmp.resize(8);\n    rep(j,8)tmp[j] = rots[i][rot[j]];\n    rots.push_back(tmp);\n  }\n\n  string s;\n  while(cin >> s){\n    map<string,int> m;\n    m[s]++;\n    rep(i,7)cin >> s, m[s]++;\n    vi v;\n    int id=0;\n    for(map<string,int>::iterator it=m.begin();it!=m.end();it++){\n      rep(i,it->second)v.push_back(id);\n      id++;\n    }\n\n    int ans = 0;\n    rep(i,1<<18)t[i] = 0ULL;\n\n    do{\n      int h = 0;\n      rep(i,8)h*=8,h+=v[i];\n      if( !((t[h>>6]>>(h&63))&1ULL) ){\n\trep(i,24){\n\t  h = 0;\n\t  rep(j,8)h*=8,h+=v[rots[i][j]];\n\t  t[h>>6] |= 1ULL<<(h&63);\n\t}\n\tans++;\n      }\n    }while(next_permutation(all(v)));\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nvoid rot(array<string, 8> &a){\n    string tmp = a[0];\n    rep(i, 3) a[i] = a[(i + 1) % 4];\n    a[3] = tmp;\n    tmp = a[4];\n    rep(i, 3) a[4+i] = a[4 + (i + 1) % 4];\n    a[7] = tmp;\n}\n\nbool check(set<array<string, 8>> &S, array<string, 8> a){\n    rep(_, 4){\n        if(S.find(a) != S.end()) return false;\n        rot(a);\n    }\n    reverse(a.begin(), a.end());\n    rep(_, 4){\n        if(S.find(a) != S.end()) return false;\n        rot(a);\n    }\n    return true;\n}\n\nvoid add(set<array<string, 8>> &S, array<string, 8> a){\n    if(!check(S, a)) return;\n    array<string, 8> b = {a[0], a[3], a[7], a[4], a[1], a[2], a[6], a[5]};\n    if(!check(S, b)) return;\n    array<string, 8> c = {a[0], a[4], a[5], a[1], a[3], a[7], a[6], a[2]};\n    if(!check(S, c)) return;\n    S.insert(a);\n}\n\nint main(){\n    string s;\n    while(getline(cin, s)){\n        array<string, 8> a;\n        for(int i=0, l=0; i<8; ++i){\n            int r = l;\n            while(r < (int)s.size() && s[r] != ' '){\n                ++r;\n            }\n            a[i] = s.substr(l, r - l);\n            l = r + 1;\n        }\n        sort(a.begin(), a.end());\n        set<array<string, 8>> S;\n        do{\n            add(S, a);\n        }while(next_permutation(a.begin(), a.end()));\n        printf(\"%d\\n\", S.size());\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nint color[8];\nmap<string,int> used;\nset<int> S;\nint t;\n\nvoid rot1(){\n  rep(i,3)swap(color[i],color[i+1]);\n  rep(i,3)swap(color[i+4],color[i+5]);\n}\n\nvoid rot2(){\n  swap(color[0],color[4]);  swap(color[1],color[5]);\n  swap(color[4],color[7]);  swap(color[5],color[6]);\n  swap(color[7],color[1]);  swap(color[6],color[2]);\n}\n\nbool check(){\n  int s=0;\n  rep(i,8)s=s*10+color[i];\n  t=s;\n  return S.count(t)!=0;\n}\n\nvoid solve(){\n  S.clear();\n  int num[8];\n  int cp[8];\n  rep(i,8)num[i]=i,cp[i]=color[i];\n  do{\n    rep(i,8)color[i]=cp[num[i]];\n    bool f=false;\n    rep(i,4){ rot1();\n      rep(j,4){ rot2();\n\trep(k,4){ rot1();\n\t  if(check())f=true;\n\t}\n      }\n    }\n    if(!f)S.insert(t);\n  }while(next_permutation(num,num+8));\n  cout<<S.size()<<endl;\n}\nstring in[8];\nint main(){\n  while(cin>>in[7]){\n    rep(i,7)cin>>in[i];\n    used.clear();\n    int Num=0;\n    rep(i,8){\n      if(!used.count(in[i]))\n\tused[in[i]]=Num++;\n      color[i]=used[in[i]];\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2169 Colored Octahedra\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar hash[16777218];\n\nint tbl[24][8] = {\n{0,1,2,3,4,5,6,7},{0,3,7,4,1,2,6,5},{0,4,5,1,3,7,6,2},\n{1,0,4,5,2,3,7,6},{1,2,3,0,5,6,7,4},{1,5,6,2,0,4,7,3},\n{2,1,5,6,3,0,4,7},{2,3,0,1,6,7,4,5},{2,6,7,3,1,5,4,0},\n{3,0,1,2,7,4,5,6},{3,2,6,7,0,1,5,4},{3,7,4,0,2,6,5,1},\n{4,0,3,7,5,1,2,6},{4,5,1,0,7,6,2,3},{4,7,6,5,0,3,2,1},\n{5,1,0,4,6,2,3,7},{5,4,7,6,1,0,3,2},{5,6,2,1,4,7,3,0},\n{6,2,1,5,7,3,0,4},{6,5,4,7,2,1,0,3},{6,7,3,2,5,4,0,1},\n{7,3,2,6,4,0,1,5},{7,4,0,3,6,5,1,2},{7,6,5,4,3,2,1,0}};\n\nchar name[8][22];\nchar id[8]; int n;\nchar used[8];\nchar color[8];\nint  ans;\n\nint check()\n{\n\tint i, j, id;\n\tchar t[8];\n\n\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | color[i];\n\tif (hash[id]) return 0;\n\thash[id] = 1;\n\tfor (j = 1; j < 24; j++) {\n\t\tfor (i = 0; i < 8; i++) t[i] = color[tbl[j][i]];\n\t\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | t[i];\n\t\thash[id] = 1;\n\t}\n\treturn 1;\n}\n\nvoid rec(int k)\n{\n\tint  i;\n\tchar f[8];\n\t\n\tif (k == 8) {\n\t\tif (check()) ans++;\n\t\treturn;\n\t}\n\tmemset(f, 0, 8);\n\tfor (i = 0; i < 8; i++) {\n\t\tif (used[i] || f[id[i]]) continue;\n\t\tcolor[k] = id[i], f[id[i]] = 1;\n\t\tused[i] = 1, rec(k+1), used[i] = 0;\n\t}\n}\n\nint main()\n{\n\tint i, j, max;\n\n    while (1) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tn = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (scanf(\"%s\", name[i]) != 1) return 0;\n\t\t\tfor (j = 0; ; j++) {\n\t\t\t\tif (j == i) { id[i] = n++; break; }\n\t\t\t\tif (!strcmp(name[j], name[i])) { id[i] = id[j]; break; }\n\t\t\t}\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tif (n == 8) { puts(\"1680\"); continue; }\n\n\t\tfor (i = 0; i < 8; i++) used[id[i]]++;\n\t\tmax = 0;\n\t\tfor (i = 1; i < 8; i++) if (used[i] > max) max = i;\n\t\tfor (i = 0; i < 8; i++) if (id[i] == max) break;\n\n\t\tans = 0;\n\t\tmemset(used, 0, 8);\n\t\tused[i] = 1, color[0] = id[i];\n\t\trec(1), used[i] = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2169 Colored Octahedra\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint  hash[16777218];\n\nint tbl[24][8] = {\n{0,1,2,3,4,5,6,7},{0,3,7,4,1,2,6,5},{0,4,5,1,3,7,6,2},\n{1,0,4,5,2,3,7,6},{1,2,3,0,5,6,7,4},{1,5,6,2,0,4,7,3},\n{2,1,5,6,3,0,4,7},{2,3,0,1,6,7,4,5},{2,6,7,3,1,5,4,0},\n{3,0,1,2,7,4,5,6},{3,2,6,7,0,1,5,4},{3,7,4,0,2,6,5,1},\n{4,0,3,7,5,1,2,6},{4,5,1,0,7,6,2,3},{4,7,6,5,0,3,2,1},\n{5,1,0,4,6,2,3,7},{5,4,7,6,1,0,3,2},{5,6,2,1,4,7,3,0},\n{6,2,1,5,7,3,0,4},{6,5,4,7,2,1,0,3},{6,7,3,2,5,4,0,1},\n{7,3,2,6,4,0,1,5},{7,4,0,3,6,5,1,2},{7,6,5,4,3,2,1,0}};\n\nchar name[8][22];\nint id[8]; int n;\nchar used[8];\nint color[8];\nint ans;\n\nint check()\n{\n\tint i, j, id;\n\tint t[8];\n\n\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | color[i];\n\tif (hash[id]) return 0;\n\thash[id] = 1;\n\tfor (j = 0; j < 24; j++) {\n\t\tfor (i = 0; i < 8; i++) t[i] = color[tbl[j][i]];\n\t\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | t[i];\n\t\thash[id] = 1;\n\t}\n\treturn 1;\n}\n\nvoid rec(int k)\n{\n\tint i, p;\n\n\tif (k == 8) {\n\t\tif (check()) ans++;\n\t\treturn;\n\t}\n\tp = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (used[i] || id[i] == p) continue;\n\t\tcolor[k] = p = id[i];\n\t\tused[i] = 1, rec(k+1), used[i] = 0;\n\t}\n}\n\nint cmp(char *a, char *b) { return *a - *b; }\n\nint main()\n{\n\tint i, j, p;\n\n    while(1) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tn = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (scanf(\"%s\", name[i]) != 1) return 0;\n\t\t\tfor (j = 0; ; j++) {\n\t\t\t\tif (j == i) { id[i] = n++; break; }\n\t\t\t\tif (!strcmp(name[j], name[i])) { id[i] = id[j]; break; }\n\t\t\t}\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tif (n == 8) { puts(\"1680\"); continue; }\n\t\tqsort(id, 8, sizeof(int), cmp);\n\n\t\tans = 0; p = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (id[i] == p) continue;\n\t\t\tcolor[0] = p = id[i];\n\t\t\tused[i] = 1, rec(1), used[i] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2169 Colored Octahedra\n// 2018.3.20 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint  hash[16777218];\n\nint tbl[24][8] = {\n{0,1,2,3,4,5,6,7},{0,3,7,4,1,2,6,5},{0,4,5,1,3,7,6,2},\n{1,0,4,5,2,3,7,6},{1,2,3,0,5,6,7,4},{1,5,6,2,0,4,7,3},\n{2,1,5,6,3,0,4,7},{2,3,0,1,6,7,4,5},{2,6,7,3,1,5,4,0},\n{3,0,1,2,7,4,5,6},{3,2,6,7,0,1,5,4},{3,7,4,0,2,6,5,1},\n{4,0,3,7,5,1,2,6},{4,5,1,0,7,6,2,3},{4,7,6,5,0,3,2,1},\n{5,1,0,4,6,2,3,7},{5,4,7,6,1,0,3,2},{5,6,2,1,4,7,3,0},\n{6,2,1,5,7,3,0,4},{6,5,4,7,2,1,0,3},{6,7,3,2,5,4,0,1},\n{7,3,2,6,4,0,1,5},{7,4,0,3,6,5,1,2},{7,6,5,4,3,2,1,0}};\n\nchar name[8][22];\nint id[8]; int n;\nchar used[8];\nint color[8];\nint ans;\n\nint check()\n{\n\tint i, j, id;\n\tint t[8];\n\n\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | color[i];\n\tif (hash[id]) return 0;\n\thash[id] = 1;\n\tfor (j = 0; j < 24; j++) {\n\t\tfor (i = 0; i < 8; i++) t[i] = color[tbl[j][i]];\n\t\tid = 0; for (i = 0; i < 8; i++) id = (id << 3) | t[i];\n\t\thash[id] = 1;\n\t}\n\treturn 1;\n}\n\nvoid rec(int k)\n{\n\tint i, p;\n\n\tif (k == 8) {\n\t\tif (check()) ans++;\n\t\treturn;\n\t}\n\tp = -1;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (used[i] || id[i] == p) continue;\n\t\tcolor[k] = p = id[i];\n\t\tused[i] = 1, rec(k+1), used[i] = 0;\n\t}\n}\n\nint cmp(char *a, char *b) { return *a - *b; }\n\nint main()\n{\n\tint i, j, p;\n\n    while (1) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tn = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (scanf(\"%s\", name[i]) != 1) return 0;\n\t\t\tfor (j = 0; ; j++) {\n\t\t\t\tif (j == i) { id[i] = n++; break; }\n\t\t\t\tif (!strcmp(name[j], name[i])) { id[i] = id[j]; break; }\n\t\t\t}\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tif (n == 8) { puts(\"1680\"); continue; }\n\t\tqsort(id, 8, sizeof(int), cmp);\n\n\t\tans = 0; p = -1;\n//\t\tmemset(used, 0, sizeof(used));\n\t\tused[0] = 1;\n\t\tcolor[0] = id[0];\n\t\trec(1);\n\t\tused[0] = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tprivate static HashSet<String> set;\n\tprivate static String s;\n\n\tprivate static int check(String cat){\n\t\tif(set.contains(cat)) return 0;\n\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t//4ツ嘉ア2ツ古つつクツづァツつオ\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tset.add(cat);\n\t\t\t\t\tset.add(cat=cat.substring(2)+cat.substring(0,2));\n\t\t\t\t}\n\n\t\t\t\tcat = \"\" +\n\t\t\t\t\tcat.charAt(1) + cat.charAt(3) +\n\t\t\t\t\tcat.charAt(0) + cat.charAt(2) +\n\t\t\t\t\tcat.charAt(6) + cat.charAt(4) +\n\t\t\t\t\tcat.charAt(7) + cat.charAt(5);\n\t\t\t}\n\n\t\t\tcat = \"\" +\n\t\t\t\tcat.charAt(1) + cat.charAt(7) +\n\t\t\t\tcat.charAt(3) + cat.charAt(5) +\n\t\t\t\tcat.charAt(2) + cat.charAt(4) +\n\t\t\t\tcat.charAt(0) + cat.charAt(6);\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tprivate static int solve(int rem,String cat,boolean used[]){\n\t\tif(rem == 0){\n\t\t\treturn check(cat);\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int i=0;i<8;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\tres += solve(rem-1,cat+s.charAt(i),used);\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(sc.hasNext()){\n\t\t\ts = \"\";\n\t\t\tHashMap<String,Integer> map = new HashMap<String,Integer>();\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tString tmp = sc.next();\n\t\t\t\tif(!map.containsKey(tmp)){\n\t\t\t\t\tmap.put(tmp,i);\n\t\t\t\t\ts += i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ts += map.get(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tset = new HashSet<String>();\n\t\t\tboolean[] used = new boolean[8];\n\t\t\tSystem.out.println(solve(8,\"\",used));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Colored Octahedra\npublic class Main{\n\n\tint id, res;\n\tMap<String, Integer> ref;\n\tint[] c;\n\tvoid reg(String s){\n\t\tif(ref.containsKey(s))c[ref.get(s)]++;\n\t\telse{\n\t\t\tc[id]++;\n\t\t\tref.put(s, id++);\n\t\t}\n\t}\n\t\n\tint[][] d = {\n\t\t\t{0, 1, 2, 3, 4, 5, 6, 7},\n\t\t\t{4, 5, 1, 6, 7, 6, 3, 2},\n\t\t\t{4, 0, 3, 7, 5, 1, 2, 6},\n\t\t\t{1, 5, 6, 2, 6, 4, 7, 3},\n\t\t\t{5, 4, 7, 6, 1, 0, 3, 2},\n\t\t\t{3, 2, 6, 7, 0, 1, 4, 5}\n\t};\n\t\n\tchar[] s;\n\tSet<String> u;\n\tvoid dfs(int k){\n\t\tif(k==8){\n\t\t\tString t = new String(s);\n\t\t\tif(u.contains(t))return;\n\t\t\tres++;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tString a = \"\", b = \"\";\n\t\t\t\tfor(int j=0;j<4;j++)a+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=4;j<8;j++)b+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tu.add(a+b);\n\t\t\t\t\ta = a.substring(1)+a.charAt(0); b = b.substring(1)+b.charAt(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<id;i++){\n\t\t\tif(c[i]==0)continue;\n\t\t\ts[k] = (char)(i+'0');\n\t\t\tc[i]--;\n\t\t\tdfs(k+1);\n\t\t\tc[i]++;\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tid = res = 0;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tc = new int[8];\n\t\t\tfor(int i=0;i<8;i++)reg(sc.next());\n\t\t\tu = new HashSet<String>();\n\t\t\ts = new char[8];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[][] trans = { \n\t\t{ 0, 1, 2, 3, 4, 5, 6, 7 },\n\t\t{ 4, 5, 6, 7, 0, 1, 2, 3 },\n\t\t{ 0, 4, 5, 1, 3, 7, 6, 2 },\n\t\t{ 1, 5, 6, 2, 0, 4, 7, 3 },\n\t\t{ 2, 6, 7, 3, 1, 5, 4, 0 },\n\t\t{ 3, 7, 4, 0, 2, 6, 5, 1 },\n\t};\n\tstatic int[] C = new int[8];\n\tstatic int[] color = new int[8];\n\tstatic ArrayList<Oct> octs;\n\n\tpublic static void main(String[] args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tString c = sc.next();\n\t\t\t\tif (!map.containsKey(c)) {\n\t\t\t\t\tmap.put(c, map.size());\n\t\t\t\t}\n\t\t\t\tC[i] = map.get(c);\n\t\t\t}\n\t\t\tocts = new ArrayList<Oct>();\n\t\t\tcolor[0] = C[0];\n\t\t\tboolean[] used = new boolean[8];\n\t\t\tused[0] = true;\n\t\t\tdfs(1, color, used);\n\t\t\tSystem.out.println(octs.size());\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, int[] color, boolean[] used) {\n\t\tif (pos == 8) {\n\t\t\tif (check(color)) {\n\t\t\t\tocts.add(new Oct(color));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i < 8; ++i) {\n\t\t\tif (used[i]) continue;\n\t\t\tcolor[pos] = C[i];\n\t\t\tused[i] = true;\n\t\t\tdfs(pos + 1, color, used);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\n\tstatic boolean check(int[] color) {\n\t\tint[] c = new int[8];\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\t\tc[j] = color[trans[i][j]];\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\trot(c);\n\t\t\t\t\tfor (Oct o : octs) {\n\t\t\t\t\t\tif (Arrays.equals(o.c, c)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void rot(int[] color) {\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint tmp = color[i * 4 + 0];\n\t\t\tcolor[i * 4 + 0] = color[i * 4 + 1];\n\t\t\tcolor[i * 4 + 1] = color[i * 4 + 2];\n\t\t\tcolor[i * 4 + 2] = color[i * 4 + 3];\n\t\t\tcolor[i * 4 + 3] = tmp;\n\t\t}\n\t} \n\t\n\tstatic class Oct {\n\t\tint[] c;\n\n\t\tOct(int[] c) {\n\t\t\tthis.c = c.clone();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[][] trans = { \n\t\t{ 0, 1, 2, 3, 4, 5, 6, 7 },\n\t\t{ 4, 5, 6, 7, 0, 1, 2, 3 },\n\t\t{ 0, 4, 5, 1, 3, 7, 6, 2 },\n\t\t{ 1, 5, 6, 2, 0, 4, 7, 3 },\n\t\t{ 2, 6, 7, 3, 1, 5, 4, 0 },\n\t\t{ 3, 7, 4, 0, 2, 6, 5, 1 },\n\t};\n\tstatic int[] C = new int[8];\n\tstatic int[] color = new int[8];\n\tstatic ArrayList<Oct> octs;\n\n\tpublic static void main(String[] args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tString c = sc.next();\n\t\t\t\tif (!map.containsKey(c)) {\n\t\t\t\t\tmap.put(c, map.size());\n\t\t\t\t}\n\t\t\t\tC[i] = map.get(c);\n\t\t\t}\n\t\t\tocts = new ArrayList<Oct>();\n\t\t\tcolor[0] = C[0];\n\t\t\tboolean[] used = new boolean[8];\n\t\t\tused[0] = true;\n\t\t\tdfs(1, color, used);\n\t\t\tSystem.out.println(octs.size());\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, int[] color, boolean[] used) {\n\t\tif (pos == 8) {\n\t\t\tif (check(color)) {\n\t\t\t\tocts.add(new Oct(color));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i < 8; ++i) {\n\t\t\tif (used[i]) continue;\n\t\t\tcolor[pos] = C[i];\n\t\t\tused[i] = true;\n\t\t\tdfs(pos + 1, color, used);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\n\tstatic boolean check(int[] color) {\n\t\tint[] c = new int[8];\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\t\tc[j] = color[trans[i][j]];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\trot(c);\n\t\t\t\tfor (Oct o : octs) {\n\t\t\t\t\tif (Arrays.equals(o.c, c)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void rot(int[] color) {\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint tmp = color[i * 4 + 0];\n\t\t\tcolor[i * 4 + 0] = color[i * 4 + 1];\n\t\t\tcolor[i * 4 + 1] = color[i * 4 + 2];\n\t\t\tcolor[i * 4 + 2] = color[i * 4 + 3];\n\t\t\tcolor[i * 4 + 3] = tmp;\n\t\t}\n\t} \n\t\n\tstatic class Oct {\n\t\tint[] c;\n\n\t\tOct(int[] c) {\n\t\t\tthis.c = c.clone();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Colored Octahedra\npublic class Main{\n\n\tint id, res;\n\tMap<String, Integer> ref;\n\tint[] c;\n\tvoid reg(String s){\n\t\tif(ref.containsKey(s))c[ref.get(s)]++;\n\t\telse{\n\t\t\tc[id]++;\n\t\t\tref.put(s, id++);\n\t\t}\n\t}\n\t\n\tint[][] d = {\n\t\t\t{0, 1, 2, 3, 4, 5, 6, 7},\n\t\t\t{4, 5, 1, 0, 7, 6, 3, 2},\n\t\t\t{4, 0, 3, 7, 5, 1, 2, 6},\n\t\t\t{1, 5, 6, 2, 0, 4, 7, 3},\n\t\t\t{5, 4, 7, 6, 1, 0, 3, 2},\n\t\t\t{3, 2, 6, 7, 0, 1, 4, 5}\n\t};\n\t\n\tchar[] s;\n\tSet<String> u;\n\tvoid dfs(int k){\n\t\tif(k==8){\n\t\t\tString t = new String(s);\n\t\t\tif(u.contains(t))return;\n\t\t\tres++;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tString a = \"\", b = \"\";\n\t\t\t\tfor(int j=0;j<4;j++)a+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=4;j<8;j++)b+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tu.add(a+b);\n\t\t\t\t\ta = a.substring(1)+a.charAt(0); b = b.substring(1)+b.charAt(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<id;i++){\n\t\t\tif(c[i]==0)continue;\n\t\t\ts[k] = (char)(i+'0');\n\t\t\tc[i]--;\n\t\t\tdfs(k+1);\n\t\t\tc[i]++;\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tid = res = 0;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tc = new int[8];\n\t\t\tfor(int i=0;i<8;i++)reg(sc.next());\n\t\t\tu = new HashSet<String>();\n\t\t\ts = new char[8];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[][] trans = { \n\t\t{ 0, 1, 2, 3, 4, 5, 6, 7 },\n\t\t{ 4, 7, 6, 5, 0, 3, 2, 1 },\n\t\t{ 0, 4, 5, 1, 3, 7, 6, 2 },\n\t\t{ 1, 5, 6, 2, 0, 4, 7, 3 },\n\t\t{ 2, 6, 7, 3, 1, 5, 4, 0 },\n\t\t{ 3, 7, 4, 0, 2, 6, 5, 1 },\n\t};\n\tstatic int[] C = new int[8];\n\tstatic int[] color = new int[8];\n\tstatic ArrayList<Oct> octs;\n\n\tpublic static void main(String[] args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < 8; ++i) {\n\t\t\t\tString c = sc.next();\n\t\t\t\tif (!map.containsKey(c)) {\n\t\t\t\t\tmap.put(c, map.size());\n\t\t\t\t}\n\t\t\t\tC[i] = map.get(c);\n\t\t\t}\n\t\t\tocts = new ArrayList<Oct>();\n\t\t\tcolor[0] = C[0];\n\t\t\tboolean[] used = new boolean[8];\n\t\t\tused[0] = true;\n\t\t\tdfs(1, color, used);\n\t\t\tSystem.out.println(octs.size());\n\t\t}\n\t}\n\n\tstatic void dfs(int pos, int[] color, boolean[] used) {\n\t\tif (pos == 8) {\n\t\t\tif (check(color)) {\n\t\t\t\tocts.add(new Oct(color));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 1; i < 8; ++i) {\n\t\t\tif (used[i]) continue;\n\t\t\tcolor[pos] = C[i];\n\t\t\tused[i] = true;\n\t\t\tdfs(pos + 1, color, used);\n\t\t\tused[i] = false;\n\t\t}\n\t}\n\n\tstatic boolean check(int[] color) {\n\t\tint[] c = new int[8];\n\t\tfor (int i = 0; i < 6; ++i) {\n\t\t\tfor (int j = 0; j < 8; ++j) {\n\t\t\t\tc[j] = color[trans[i][j]];\n\t\t\t}\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\trot(c);\n\t\t\t\tfor (Oct o : octs) {\n\t\t\t\t\tif (Arrays.equals(o.c, c)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void rot(int[] color) {\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint tmp = color[i * 4 + 0];\n\t\t\tcolor[i * 4 + 0] = color[i * 4 + 1];\n\t\t\tcolor[i * 4 + 1] = color[i * 4 + 2];\n\t\t\tcolor[i * 4 + 2] = color[i * 4 + 3];\n\t\t\tcolor[i * 4 + 3] = tmp;\n\t\t}\n\t} \n\t\n\tstatic class Oct {\n\t\tint[] c;\n\n\t\tOct(int[] c) {\n\t\t\tthis.c = c.clone();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Colored Octahedra\npublic class Main{\n\n\tint id, res;\n\tMap<String, Integer> ref;\n\tint[] c;\n\tvoid reg(String s){\n\t\tif(ref.containsKey(s))c[ref.get(s)]++;\n\t\telse{\n\t\t\tc[id]++;\n\t\t\tref.put(s, id++);\n\t\t}\n\t}\n\t\n\tint[][] d = {\n\t\t\t{0, 1, 2, 3, 4, 5, 6, 7},\n\t\t\t{4, 5, 1, 0, 7, 6, 2, 3},\n\t\t\t{4, 0, 3, 7, 5, 1, 2, 6},\n\t\t\t{1, 5, 6, 2, 0, 4, 7, 3},\n\t\t\t{5, 4, 7, 6, 1, 0, 3, 2},\n\t\t\t{3, 2, 6, 7, 0, 1, 5, 4}\n\t};\n\t\n\tchar[] s;\n\tSet<String> u;\n\tvoid dfs(int k){\n\t\tif(k==8){\n\t\t\tString t = new String(s);\n\t\t\tif(u.contains(t))return;\n\t\t\tres++;\n\t\t\tfor(int i=0;i<6;i++){\n\t\t\t\tString a = \"\", b = \"\";\n\t\t\t\tfor(int j=0;j<4;j++)a+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=4;j<8;j++)b+=t.charAt(d[i][j]);\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tu.add(a+b);\n\t\t\t\t\ta = a.substring(1)+a.charAt(0); b = b.substring(1)+b.charAt(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<id;i++){\n\t\t\tif(c[i]==0)continue;\n\t\t\ts[k] = (char)(i+'0');\n\t\t\tc[i]--;\n\t\t\tdfs(k+1);\n\t\t\tc[i]++;\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tid = res = 0;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tc = new int[8];\n\t\t\tfor(int i=0;i<8;i++)reg(sc.next());\n\t\t\tu = new HashSet<String>();\n\t\t\ts = new char[8];\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def spin(a)\n\t[a[0]] + a[5..6] + a[1..4] + [a[7]]\nend\n\ndef roll(a)\n\ta[1..3] + [a[0]] + a[5..7] + [a[4]]\nend\n\nwhile gets\n\thash = {}\n\ta = $_.chomp.split.map{|x| hash[x] ||= hash.size}.sort\n\tcount = 0\n\ta[1..-1].permutation{|x|\n\t\tx.unshift 0\n\t\tstack = [x]\t\n\t\treached = {}\n\t\tok = true\n\n\t\twhile y = stack.pop\n\t\t\tnext if reached[y]\n\t\t\treached[y] = 0\n\t\t\tif hash[y]\n\t\t\t\tok = false\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tstack << spin(y)\n\t\t\tstack << roll(y)\n\t\tend\n\n\t\thash[x] = 0\n\t\tcount += 1 if ok\n\t}\n\tp count\nend"
  },
  {
    "language": "Ruby",
    "code": "def f(a)\n\ts = 0\n\ta[0] -= 1\n\tif a[0] == 0\n\t\ta.shift\n\t\t(0..a.size-1).each{|i|\n\t\t\tb = a.dup\n\t\t\tb[i] -= 1\n\t\t\tb.delete_at(i) if b[i] == 0\n\t\t\ts += g(b)\n\t\t}\n\telse\n\t\ta[0] -= 1\n\t\ts += 720 / a.map{|x| fact(x)}.inject(:*)\n\t\ta[0] += 1\n\t\t(1..a.size-1).each{|i|\n\t\t\tb = a.dup\n\t\t\tb[i] -= 1\n\t\t\tb.delete_at(i) if b[i] == 0\n\t\t\ts += g(b)\n\t\t}\n\tend\n\ts\nend\n\ndef g(a)\n\tk = a[0]\n\ts = 720 / a.map{|x| fact(x)}.inject(:*)\n\tif a == [6]\n\t\ts += 2\n\telsif a == [3, 3]\n\t\ts += 4\n\tend\n\ts / 3\nend\n\ndef fact(x)\n\t(1..x).inject(1, :*)\nend\n\nwhile gets\n\thash = {}\n\ta = $_.chomp.split.group_by{|x| x}.values.map(&:size)\n\tp f(a)\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n# aa\n# 1 2 4 5\n# 2 3 1 6\n# 3 4 2 7\n# 4 1 3 8\n# 5 8 6 1\n# 6 5 7 2\n# 7 6 8 3\n# 8 7 5 4\n#\n\ndef main():\n    rr = []\n    k = [\n            [2, 4, 5],\n            [3, 1, 6],\n            [4, 2, 7],\n            [1, 3, 8],\n            [8, 6, 1],\n            [5, 7, 2],\n            [6, 8, 3],\n            [7, 5, 4]\n        ]\n    for i in range(8):\n        for j in range(3):\n            k[i][j] -= 1\n    ptn = []\n    for i in range(8):\n        for j in range(3):\n            t = [-1] * 8\n            t[0] = i\n            t[1] = k[i][j]\n            t[3] = k[i][(j+1)%3]\n            for l in range(8):\n                if l == i:\n                    continue\n                if t[1] in k[l] and t[3] in k[l]:\n                    t[2] = l\n                    break\n            for l in range(4):\n                kl = k[t[l]]\n                for m in range(3):\n                    if kl[m] not in t:\n                        t[l+4] = kl[m]\n                        break\n            ptn.append(t)\n\n    def f(a):\n        s = set()\n        r = 0\n        tc = 0\n        for t in itertools.permutations(a):\n            tc += 1\n            if t in s:\n                continue\n            r += 1\n            for p in ptn:\n                s.add(tuple(t[p[i]] for i in range(8)))\n        return r\n\n    while True:\n        a = LS()\n        if len(a) == 0:\n            break\n        rr.append(f(a))\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]