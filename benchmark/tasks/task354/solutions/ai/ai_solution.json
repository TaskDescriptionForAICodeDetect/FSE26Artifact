[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nint isSameOctahedron(char *a, char *b) {\n    char temp[9];\n    strcpy(temp, a);\n    for (int i = 0; i < 4; i++) {\n        if (strcmp(temp, b) == 0) return 1;\n        char c = temp[0];\n        temp[0] = temp[2];\n        temp[2] = temp[4];\n        temp[4] = temp[6];\n        temp[6] = c;\n        c = temp[1];\n        temp[1] = temp[3];\n        temp[3] = temp[5];\n        temp[5] = temp[7];\n        temp[7] = c;\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char octahedra[n][9];\n    int distinct[n];\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", octahedra[i]);\n        qsort(octahedra[i], 8, sizeof(char), compare);\n        int found = 0;\n        for (int j = 0; j < count; j++) {\n            if (isSameOctahedron(octahedra[i], octahedra[distinct[j]])) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            distinct[count++] = i;\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nvector<vector<int>> generatePermutations(vector<int>& colors) {\n    vector<vector<int>> permutations;\n    sort(colors.begin(), colors.end());\n    do {\n        permutations.push_back(colors);\n    } while (next_permutation(colors.begin(), colors.end()));\n    return permutations;\n}\n\nbool isSameOctahedron(const vector<int>& a, const vector<int>& b) {\n    // Check all rotations for octahedron\n    vector<int> rotated;\n    // Rotation around axis through vertex 0 and opposite vertex\n    rotated = {a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]};\n    if (rotated == b) return true;\n    rotated = {a[0], a[3], a[1], a[2], a[4], a[7], a[5], a[6]};\n    if (rotated == b) return true;\n    rotated = {a[0], a[2], a[3], a[1], a[4], a[6], a[7], a[5]};\n    if (rotated == b) return true;\n\n    // Rotation around axis through vertex 4 and opposite vertex\n    rotated = {a[4], a[5], a[6], a[7], a[0], a[1], a[2], a[3]};\n    if (rotated == b) return true;\n    rotated = {a[4], a[7], a[5], a[6], a[0], a[3], a[1], a[2]};\n    if (rotated == b) return true;\n    rotated = {a[4], a[6], a[7], a[5], a[0], a[2], a[3], a[1]};\n    if (rotated == b) return true;\n\n    // Other face rotations\n    rotated = {a[1], a[0], a[3], a[2], a[5], a[4], a[7], a[6]};\n    if (rotated == b) return true;\n    rotated = {a[2], a[1], a[0], a[3], a[6], a[5], a[4], a[7]};\n    if (rotated == b) return true;\n    rotated = {a[3], a[2], a[1], a[0], a[7], a[6], a[5], a[4]};\n    if (rotated == b) return true;\n\n    return false;\n}\n\nint countDistinctOctahedra(vector<int>& colors) {\n    vector<vector<int>> permutations = generatePermutations(colors);\n    vector<bool> taken(permutations.size(), false);\n    int count = 0;\n\n    for (int i = 0; i < permutations.size(); ++i) {\n        if (!taken[i]) {\n            count++;\n            for (int j = i; j < permutations.size(); ++j) {\n                if (!taken[j] && isSameOctahedron(permutations[i], permutations[j])) {\n                    taken[j] = true;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        vector<int> colors(8);\n        for (int j = 0; j < 8; ++j) {\n            cin >> colors[j];\n        }\n        cout << countDistinctOctahedra(colors) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class OctahedraCounter {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine(); // consume the remaining newline\n        \n        for (int i = 0; i < n; i++) {\n            String[] colors = scanner.nextLine().split(\" \");\n            Map<String, Integer> colorCount = new HashMap<>();\n            for (String color : colors) {\n                colorCount.put(color, colorCount.getOrDefault(color, 0) + 1);\n            }\n            List<Integer> counts = new ArrayList<>(colorCount.values());\n            Collections.sort(counts);\n            \n            int distinct = 1;\n            int prev = counts.get(0);\n            int currentRun = 1;\n            \n            for (int j = 1; j < counts.size(); j++) {\n                if (counts.get(j).equals(prev)) {\n                    currentRun++;\n                } else {\n                    distinct *= factorial(currentRun);\n                    currentRun = 1;\n                    prev = counts.get(j);\n                }\n            }\n            distinct *= factorial(currentRun);\n            \n            int total = factorial(8);\n            for (int count : counts) {\n                total /= factorial(count);\n            }\n            \n            System.out.println(total / distinct);\n        }\n        scanner.close();\n    }\n    \n    private static int factorial(int n) {\n        int result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 21:12:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class OctahedronCombinations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCases = scanner.nextInt();\n        \n        for (int t = 0; t < testCases; t++) {\n            String[] colors = new String[8];\n            for (int i = 0; i < 8; i++) {\n                colors[i] = scanner.next();\n            }\n            \n            System.out.println(countDistinctOctahedra(colors));\n        }\n        \n        scanner.close();\n    }\n    \n    private static int countDistinctOctahedra(String[] colors) {\n        Set<String> uniqueOctahedra = new HashSet<>();\n        \n        for (int[] permutation : generatePermutations(8)) {\n            String[] permutedColors = new String[8];\n            for (int i = 0; i < 8; i++) {\n                permutedColors[i] = colors[permutation[i]];\n            }\n            \n            String canonicalRepresentation = getCanonicalRepresentation(permutedColors);\n            uniqueOctahedra.add(canonicalRepresentation);\n        }\n        \n        return uniqueOctahedra.size();\n    }\n    \n    private static String getCanonicalRepresentation(String[] colors) {\n        String[] faces = new String[8];\n        faces[0] = colors[0] + colors[1] + colors[2];\n        faces[1] = colors[0] + colors[2] + colors[3];\n        faces[2] = colors[0] + colors[3] + colors[4];\n        faces[3] = colors[0] + colors[4] + colors[1];\n        faces[4] = colors[5] + colors[1] + colors[2];\n        faces[5] = colors[5] + colors[2] + colors[3];\n        faces[6] = colors[5] + colors[3] + colors[4];\n        faces[7] = colors[5] + colors[4] + colors[1];\n        \n        Arrays.sort(faces);\n        return String.join(\",\", faces);\n    }\n    \n    private static List<int[]> generatePermutations(int n) {\n        List<int[]> permutations = new ArrayList<>();\n        int[] initial = new int[n];\n        for (int i = 0; i < n; i++) {\n            initial[i] = i;\n        }\n        generatePermutationsHelper(initial, 0, permutations);\n        return permutations;\n    }\n    \n    private static void generatePermutationsHelper(int[] arr, int start, List<int[]> permutations) {\n        if (start == arr.length - 1) {\n            permutations.add(arr.clone());\n            return;\n        }\n        \n        for (int i = start; i < arr.length; i++) {\n            swap(arr, start, i);\n            generatePermutationsHelper(arr, start + 1, permutations);\n            swap(arr, start, i);\n        }\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
    "timestamp": "2025-08-05 21:12:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COLORS 8\n\nvoid generateOctahedra(int colors[MAX_COLORS], int* uniqueCount) {\n    bool visited[8] = {false};\n    int current[8];\n    *uniqueCount = 0;\n\n    void backtrack(int depth) {\n        if (depth == 8) {\n            bool duplicate = false;\n            for (int rotation = 0; rotation < 24; rotation++) {\n                int rotated[8];\n                switch(rotation) {\n                    case 0: memcpy(rotated, current, sizeof(current)); break;\n                    case 1: rotated[0]=current[1]; rotated[1]=current[5]; rotated[2]=current[2]; rotated[3]=current[0]; rotated[4]=current[3]; rotated[5]=current[4]; rotated[6]=current[6]; rotated[7]=current[7]; break;\n                    // Add other rotation cases...\n                }\n                \n                for (int j = 0; j < *uniqueCount; j++) {\n                    bool match = true;\n                    for (int k = 0; k < 8; k++) {\n                        if (rotated[k] != current[k]) {\n                            match = false;\n                            break;\n                        }\n                    }\n                    if (match) {\n                        duplicate = true;\n                        break;\n                    }\n                }\n            }\n            \n            if (!duplicate) {\n                memcpy(uniqueOctahedra[*uniqueCount], current, sizeof(current));\n                (*uniqueCount)++;\n            }\n            return;\n        }\n\n        for (int i = 0; i < MAX_COLORS; i++) {\n            if (!visited[i]) {\n                visited[i] = true;\n                current[depth] = colors[i];\n                backtrack(depth + 1);\n                visited[i] = false;\n            }\n        }\n    }\n\n    backtrack(0);\n}\n\nint main() {\n    int testCases;\n    scanf(\"%d\", &testCases);\n\n    while (testCases--) {\n        int colors[MAX_COLORS];\n        for (int i = 0; i < MAX_COLORS; i++) {\n            scanf(\"%d\", &colors[i]);\n        }\n\n        int uniqueCount = 0;\n        generateOctahedra(colors, &uniqueCount);\n        printf(\"%d\\n\", uniqueCount);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int PANELS = 8;\n\nvector<vector<int>> getAllRotations(vector<int>& colors) {\n    set<vector<int>> uniqueRotations;\n    vector<vector<int>> rotationIndices = {\n        {0,1,2,3,4,5,6,7}, {0,2,4,6,1,3,5,7}, {0,3,5,6,1,2,4,7},\n        {0,4,1,5,2,6,3,7}, {0,5,3,4,1,7,2,6}, {0,6,2,5,3,4,1,7},\n        {0,7,6,3,5,2,4,1}\n    };\n\n    for (auto& indices : rotationIndices) {\n        vector<int> rotation;\n        for (int idx : indices) {\n            rotation.push_back(colors[idx]);\n        }\n        uniqueRotations.insert(rotation);\n    }\n\n    return vector<vector<int>>(uniqueRotations.begin(), uniqueRotations.end());\n}\n\nint countUniqueOctahedra(vector<int>& colors) {\n    set<vector<int>> uniqueOctahedra;\n    vector<vector<int>> rotations = getAllRotations(colors);\n\n    for (auto& rotation : rotations) {\n        uniqueOctahedra.insert(rotation);\n    }\n\n    return uniqueOctahedra.size();\n}\n\nint main() {\n    int T;\n    cin >> T;\n\n    while (T--) {\n        vector<int> colors(PANELS);\n        for (int i = 0; i < PANELS; ++i) {\n            cin >> colors[i];\n        }\n\n        cout << countUniqueOctahedra(colors) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef generate_octahedra(color_combination):\n    unique_octahedra = set()\n    for perm in permutations(color_combination):\n        # Normalize the permutation by rotating and flipping\n        for rot in range(8):\n            rotated = perm[rot:] + perm[:rot]\n            # Flip the octahedron and check the rotated and flipped versions\n            flipped = rotated[:4][::-1] + rotated[4:][::-1]\n            unique_octahedra.add(tuple(rotated))\n            unique_octahedra.add(tuple(flipped))\n    return unique_octahedra\n\ndef count_distinct_octahedra(panel_colors):\n    color_combination = panel_colors.split()\n    octahedra_set = generate_octahedra(color_combination)\n    return len(octahedra_set)\n\nif __name__ == \"__main__\":\n    # Example input color combinations, modify this list as needed\n    color_combinations = [\n        \"red red red red blue blue blue blue\",\n        \"green yellow green yellow green yellow green yellow\",\n        \"black black black white white white white black\",\n    ]\n    \n    for colors in color_combinations:\n        print(count_distinct_octahedra(colors))",
    "timestamp": "2025-08-13 05:25:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Octahedra {\n\n    public static int countDistinctOctahedra(String[] panels) {\n        Set<String> distinctOctahedra = new HashSet<>();\n        permute(panels, 0, panels.length, distinctOctahedra);\n        return distinctOctahedra.size();\n    }\n\n    private static void permute(String[] arr, int l, int r, Set<String> distinctOctahedra) {\n        if (l == r) {\n            if (isValidOctahedron(arr)) {\n                distinctOctahedra.add(canonicalForm(arr));\n            }\n        } else {\n            for (int i = l; i < r; i++) {\n                swap(arr, l, i);\n                permute(arr, l + 1, r, distinctOctahedra);\n                swap(arr, l, i); // backtrack\n            }\n        }\n    }\n\n    private static boolean isValidOctahedron(String[] arr) {\n        // Here, just assume permutation validity, which should be ensured elsewhere\n        return true;\n    }\n\n    private static String canonicalForm(String[] arr) {\n        // Simplistically assume a canonical form is a sorted array representation\n        String[] sorted = arr.clone();\n        java.util.Arrays.sort(sorted);\n        return String.join(\",\", sorted);\n    }\n\n    private static void swap(String[] arr, int i, int j) {\n        String temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"Enter color combinations for eight panels separated by space:\");\n        String[] panels = scanner.nextLine().trim().split(\"\\\\s+\");\n        System.out.println(\"Distinct octahedra can be formed: \" + countDistinctOctahedra(panels));\n    }\n}",
    "timestamp": "2025-08-13 05:25:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n// Function to check if two arrangements of panels are equivalent (considering rotations)\nbool areEquivalent(int* arr1, int* arr2) {\n    int rotations[24][8] = {\n        {0, 1, 2, 3, 4, 5, 6, 7},\n        {0, 1, 5, 4, 3, 2, 6, 7},\n        {0, 4, 3, 5, 7, 6, 2, 1},\n        {0, 4, 7, 6, 5, 3, 1, 2},\n        {0, 3, 7, 4, 2, 5, 1, 6},\n        {0, 3, 2, 1, 7, 4, 5, 6},\n        {0, 2, 1, 3, 6, 7, 4, 5},\n        {0, 2, 6, 7, 1, 3, 4, 5},\n        {1, 0, 2, 3, 5, 4, 6, 7},\n        {1, 0, 4, 5, 2, 3, 7, 6},\n        {1, 5, 0, 4, 6, 2, 7, 3},\n        {1, 5, 6, 2, 0, 4, 3, 7},\n        {1, 4, 5, 0, 7, 6, 3, 2},\n        {1, 4, 7, 6, 5, 0, 2, 3},\n        {1, 6, 5, 4, 3, 7, 2, 0},\n        {1, 6, 3, 2, 5, 4, 7, 0},\n        {2, 0, 3, 1, 6, 7, 5, 4},\n        {2, 0, 7, 6, 3, 1, 4, 5},\n        {2, 1, 3, 0, 5, 6, 4, 7},\n        {2, 1, 5, 4, 0, 3, 7, 6},\n        {2, 6, 3, 7, 0, 1, 5, 4},\n        {2, 6, 0, 7, 3, 5, 4, 1},\n        {2, 7, 6, 0, 4, 5, 1, 3},\n        {2, 7, 4, 5, 6, 0, 3, 1}\n    };\n\n    for (int i = 0; i < 24; i++) {\n        bool equals = true;\n        for (int j = 0; j < 8; j++) {\n            if (arr1[j] != arr2[rotations[i][j]]) {\n                equals = false;\n                break;\n            }\n        }\n        if (equals) return true;\n    }\n    return false;\n}\n\n// Function to calculate distinct octahedra\nint calculateDistinctOctahedra(int panels[], int size) {\n    int permutations[40320][8]; // 8! permutations\n    int temp[8];\n    bool checked[40320] = {false};\n    int count = 0;\n    bool distinct = true;\n    \n    // Generate all permutations using Heap's algorithm\n    int c[8] = {0}, i = 0, p = 0;\n    for (i = 0; i < 8; i++) temp[i] = panels[i];\n    i = 0;\n    int permIndex = 0;\n    \n    while (i < size) {\n        if (c[i] < i) {\n            if (i % 2 == 0) {\n                int tempVar = temp[0];\n                temp[0] = temp[i];\n                temp[i] = tempVar;\n            } else {\n                int tempVar = temp[c[i]];\n                temp[c[i]] = temp[i];\n                temp[i] = tempVar;\n            }\n            for (int k = 0; k < size; k++) permutations[permIndex][k] = temp[k];\n            permIndex++;\n            c[i]++;\n            i = 0;\n        } else {\n            c[i] = 0;\n            i++;\n        }\n    }\n    \n    for (int i = 0; i < 40320; i++) {\n        if (!checked[i]) {\n            count++;\n            for (int j = i + 1; j < 40320; j++) {\n                if (areEquivalent(permutations[i], permutations[j])) {\n                    checked[j] = true;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int panels[8];\n    printf(\"Enter the colors for the 8 panels as integers (e.g., 1 for red, 2 for blue):\\n\");\n    for(int i = 0; i < 8; i++) {\n        scanf(\"%d\", &(panels[i]));\n    }\n    int result = calculateDistinctOctahedra(panels, 8);\n    printf(\"Number of distinct octahedra: %d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:26:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_distinct_octahedra(colors):\n    def normalize_octahedron(perm):\n        # Generate all rotational symmetries of an octahedron\n        rotations = [\n            (perm[0], perm[1], perm[2], perm[3], perm[4], perm[5], perm[6], perm[7]),\n            (perm[0], perm[2], perm[4], perm[6], perm[1], perm[3], perm[5], perm[7]),\n            (perm[0], perm[3], perm[5], perm[6], perm[1], perm[2], perm[4], perm[7]),\n            (perm[0], perm[4], perm[1], perm[5], perm[2], perm[6], perm[3], perm[7]),\n            (perm[0], perm[5], perm[2], perm[7], perm[1], perm[4], perm[3], perm[6]),\n            (perm[0], perm[6], perm[3], perm[7], perm[1], perm[5], perm[2], perm[4]),\n            (perm[0], perm[7], perm[4], perm[5], perm[1], perm[6], perm[3], perm[2])\n        ]\n        return min(rotations)\n\n    # Generate unique color combinations\n    unique_octahedra = set()\n    for perm in set(permutations(colors)):\n        normalized = normalize_octahedron(perm)\n        unique_octahedra.add(normalized)\n\n    return len(unique_octahedra)\n\n# Read input\nn = int(input())\nfor _ in range(n):\n    colors = input().split()\n    print(count_distinct_octahedra(colors))",
    "timestamp": "2025-08-13 05:26:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\nfrom collections import defaultdict\n\ndef count_distinct_octahedra(color_list):\n    unique_perms = set()\n    for p in permutations(color_list):\n        # Normalize the permutation to account for rotations\n        # The first color is fixed, and the rest are rotated to minimize the tuple\n        rotated = p\n        min_rotated = rotated\n        for i in range(1, 8):\n            rotated = rotated[1:] + (rotated[0],)\n            if rotated < min_rotated:\n                min_rotated = rotated\n        unique_perms.add(min_rotated)\n    return len(unique_perms)\n\ndef main():\n    import sys\n    input_lines = sys.stdin.read().splitlines()\n    for line in input_lines:\n        colors = line.strip().split()\n        if not colors:\n            continue\n        color_tuple = tuple(colors)\n        print(count_distinct_octahedra(color_tuple))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:26:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// A utility function to return the index of minimum element in arr[]\nint minIndex(string *arr, int n) {\n    int min = 0;\n    for (int i = 1; i < n; i++)\n        if (arr[i] < arr[min])\n            min = i;\n    return min;\n}\n\n// Function to rotate the array to left by one position\nvoid leftRotatebyOne(string *arr, int n) {\n    string temp = arr[0];\n    for (int i = 0; i < n - 1; i++)\n        arr[i] = arr[i + 1];\n    arr[n - 1] = temp;\n}\n\n// Utility function to choose lexicographically smallest\n// rotation of given array of strings\nstring lexicographicallySmallestRotation(string *arr, int n) {\n    int min = minIndex(arr, n);\n    string smallest = arr[min];\n    for (int i = 0; i < min; i++)\n        leftRotatebyOne(arr, n);\n    string result = \"\";\n    for (int i = 0; i < n; i++)\n        result += arr[i];\n    return result;\n}\n\n// Function to determine if two specific rotations of octahedra are the same\nbool areRotationsSame(vector<string> &oct1, vector<string> &oct2) {\n    // Check 24 possible rotations\n    for (int i = 0; i < 4; i++) {\n        string arr1[4], arr2[4];\n        for (int j = 0; j < 4; j++) {\n            arr1[j] = oct1[(j + i) % 4];\n            arr2[j] = oct2[j];\n        }\n        string min_rotation1 = lexicographicallySmallestRotation(arr1, 4);\n        string min_rotation2 = lexicographicallySmallestRotation(arr2, 4);\n        if (min_rotation1 == min_rotation2)\n            return true;\n    }\n    return false;\n}\n\n// Function to determine if two octahedra are the same\nbool areSameOctahedra(vector<string> &oct1, vector<string> &oct2) {\n    for (int i = 0; i < 4; i++) {\n        if (areRotationsSame(oct1, oct2))\n            return true;\n        rotate(oct2.begin(), oct2.begin() + 1, oct2.end());\n    }\n    return false;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        vector<string> panels(8);\n        for(int i = 0; i < 8; ++i)\n            cin >> panels[i];\n        \n        sort(panels.begin(), panels.end()); // Sort panels to try all combinations\n        set<vector<string>> uniqueOctahedra;\n\n        do {\n            vector<string> topFace(panels.begin(), panels.begin() + 4);\n            vector<string> bottomFace(panels.begin() + 4, panels.end());\n\n            if(!any_of(uniqueOctahedra.begin(), uniqueOctahedra.end(), [&](const vector<string> &oct){\n                return areSameOctahedra(topFace, oct);\n            })) {\n                uniqueOctahedra.insert(topFace);\n            }\n            \n        } while(next_permutation(panels.begin(), panels.end()));\n\n        cout << uniqueOctahedra.size() << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:11"
  }
]