[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 1000\n\nvoid decode_rle(char* encoded, char* decoded) {\n    int len = strlen(encoded);\n    int j = 0;\n    for (int i = 0; i < len; i += 2) {\n        int count = encoded[i] - '0';\n        char ch = encoded[i+1];\n        for (int k = 0; k < count; k++) {\n            decoded[j++] = ch;\n        }\n    }\n    decoded[j] = '\\0';\n}\n\nvoid encode_rle(char* decoded, char* encoded) {\n    int len = strlen(decoded);\n    int j = 0, count = 1;\n    \n    for (int i = 1; i <= len; i++) {\n        if (i < len && decoded[i] == decoded[i-1]) {\n            count++;\n        } else {\n            encoded[j++] = count + '0';\n            encoded[j++] = decoded[i-1];\n            count = 1;\n        }\n    }\n    encoded[j++] = '$';\n    encoded[j] = '\\0';\n}\n\nint main() {\n    char A[MAX_LEN], B[MAX_LEN], C[MAX_LEN];\n    char decoded_A[MAX_LEN], decoded_B[MAX_LEN], decoded_C[MAX_LEN];\n    char result[MAX_LEN], final_result[MAX_LEN];\n    \n    scanf(\"%s %s %s\", A, B, C);\n    \n    decode_rle(A, decoded_A);\n    decode_rle(B, decoded_B);\n    decode_rle(C, decoded_C);\n    \n    char* pos = strstr(decoded_A, decoded_B);\n    \n    if (pos == NULL) {\n        printf(\"%s\\n\", A);\n    } else {\n        int prefix_len = pos - decoded_A;\n        strncpy(result, decoded_A, prefix_len);\n        result[prefix_len] = '\\0';\n        strcat(result, decoded_C);\n        strcat(result, pos + strlen(decoded_B));\n        \n        encode_rle(result, final_result);\n        printf(\"%s\\n\", final_result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char c;\n    int len;\n} RLEPair;\n\nvoid parseRLE(const char *s, RLEPair **pairs, int *count) {\n    *count = 0;\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) {\n        if (s[i] == '$') break;\n        (*count)++;\n    }\n    *pairs = malloc(*count * sizeof(RLEPair));\n    for (int i = 0; i < *count; i++) {\n        (*pairs)[i].c = s[2 * i];\n        (*pairs)[i].len = atoi(&s[2 * i + 1]);\n    }\n}\n\nvoid expandRLE(const RLEPair *pairs, int count, char **str, int *len) {\n    *len = 0;\n    for (int i = 0; i < count; i++) {\n        *len += pairs[i].len;\n    }\n    *str = malloc(*len + 1);\n    int pos = 0;\n    for (int i = 0; i < count; i++) {\n        for (int j = 0; j < pairs[i].len; j++) {\n            (*str)[pos++] = pairs[i].c;\n        }\n    }\n    (*str)[*len] = '\\0';\n}\n\nvoid compressRLE(const char *str, int len, RLEPair **pairs, int *count) {\n    if (len == 0) {\n        *count = 0;\n        *pairs = NULL;\n        return;\n    }\n    *count = 1;\n    for (int i = 1; i < len; i++) {\n        if (str[i] != str[i - 1]) {\n            (*count)++;\n        }\n    }\n    *pairs = malloc(*count * sizeof(RLEPair));\n    int currentLen = 1;\n    int pairIndex = 0;\n    for (int i = 1; i < len; i++) {\n        if (str[i] == str[i - 1]) {\n            currentLen++;\n        } else {\n            (*pairs)[pairIndex].c = str[i - 1];\n            (*pairs)[pairIndex].len = currentLen;\n            pairIndex++;\n            currentLen = 1;\n        }\n    }\n    (*pairs)[pairIndex].c = str[len - 1];\n    (*pairs)[pairIndex].len = currentLen;\n}\n\nvoid replaceFirstOccurrence(char *A, int lenA, const char *B, int lenB, const char *C, int lenC, char **result, int *resultLen) {\n    char *pos = strstr(A, B);\n    if (pos == NULL) {\n        *result = malloc(lenA + 1);\n        memcpy(*result, A, lenA);\n        (*result)[lenA] = '\\0';\n        *resultLen = lenA;\n        return;\n    }\n    int beforeLen = pos - A;\n    int afterLen = lenA - (beforeLen + lenB);\n    *resultLen = beforeLen + lenC + afterLen;\n    *result = malloc(*resultLen + 1);\n    memcpy(*result, A, beforeLen);\n    memcpy(*result + beforeLen, C, lenC);\n    memcpy(*result + beforeLen + lenC, pos + lenB, afterLen);\n    (*result)[*resultLen] = '\\0';\n}\n\nvoid printRLE(const RLEPair *pairs, int count) {\n    for (int i = 0; i < count; i++) {\n        printf(\"%c%d\", pairs[i].c, pairs[i].len);\n    }\n    printf(\"$\\n\");\n}\n\nint main() {\n    char inputA[1000], inputB[1000], inputC[1000];\n    scanf(\"%s %s %s\", inputA, inputB, inputC);\n\n    RLEPair *pairsA, *pairsB, *pairsC;\n    int countA, countB, countC;\n    parseRLE(inputA, &pairsA, &countA);\n    parseRLE(inputB, &pairsB, &countB);\n    parseRLE(inputC, &pairsC, &countC);\n\n    char *strA, *strB, *strC;\n    int lenA, lenB, lenC;\n    expandRLE(pairsA, countA, &strA, &lenA);\n    expandRLE(pairsB, countB, &strB, &lenB);\n    expandRLE(pairsC, countC, &strC, &lenC);\n\n    char *resultStr;\n    int resultLen;\n    replaceFirstOccurrence(strA, lenA, strB, lenB, strC, lenC, &resultStr, &resultLen);\n\n    RLEPair *resultPairs;\n    int resultCount;\n    compressRLE(resultStr, resultLen, &resultPairs, &resultCount);\n    printRLE(resultPairs, resultCount);\n\n    free(pairsA);\n    free(pairsB);\n    free(pairsC);\n    free(strA);\n    free(strB);\n    free(strC);\n    free(resultStr);\n    free(resultPairs);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\nusing namespace std;\n\nvector<pair<char, int>> decode(const string &s) {\n    vector<pair<char, int>> res;\n    for (int i = 0; i < s.size(); ) {\n        if (s[i] == '$') break;\n        char c = s[i++];\n        int num = 0;\n        while (i < s.size() && isdigit(s[i])) {\n            num = num * 10 + (s[i] - '0');\n            i++;\n        }\n        res.emplace_back(c, num);\n    }\n    return res;\n}\n\nstring encode(const vector<pair<char, int>> &v) {\n    string res;\n    for (auto &p : v) {\n        res += p.first;\n        res += to_string(p.second);\n    }\n    res += '$';\n    return res;\n}\n\nvector<pair<char, int>> expand(const vector<pair<char, int>> &v) {\n    vector<pair<char, int>> res;\n    for (auto &p : v) {\n        if (p.second > 0) {\n            res.emplace_back(p.first, p.second);\n        }\n    }\n    return res;\n}\n\nvector<pair<char, int>> merge(const vector<pair<char, int>> &v) {\n    if (v.empty()) return {};\n    vector<pair<char, int>> res;\n    char current = v[0].first;\n    int count = v[0].second;\n    for (int i = 1; i < v.size(); ++i) {\n        if (v[i].first == current) {\n            count += v[i].second;\n        } else {\n            res.emplace_back(current, count);\n            current = v[i].first;\n            count = v[i].second;\n        }\n    }\n    res.emplace_back(current, count);\n    return res;\n}\n\nvector<pair<char, int>> replaceFirst(const vector<pair<char, int>> &a, const vector<pair<char, int>> &b, const vector<pair<char, int>> &c) {\n    vector<pair<char, int>> a_expanded;\n    for (auto &p : a) {\n        for (int i = 0; i < p.second; ++i) {\n            a_expanded.emplace_back(p.first, 1);\n        }\n    }\n    vector<pair<char, int>> b_expanded;\n    for (auto &p : b) {\n        for (int i = 0; i < p.second; ++i) {\n            b_expanded.emplace_back(p.first, 1);\n        }\n    }\n    \n    if (b_expanded.empty()) {\n        return a;\n    }\n    \n    bool found = false;\n    int start = -1;\n    for (int i = 0; i + b_expanded.size() <= a_expanded.size(); ++i) {\n        bool match = true;\n        for (int j = 0; j < b_expanded.size(); ++j) {\n            if (a_expanded[i + j].first != b_expanded[j].first) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            found = true;\n            start = i;\n            break;\n        }\n    }\n    \n    if (!found) {\n        return a;\n    }\n    \n    vector<pair<char, int>> res;\n    for (int i = 0; i < start; ++i) {\n        res.push_back(a_expanded[i]);\n    }\n    for (auto &p : c) {\n        for (int i = 0; i < p.second; ++i) {\n            res.emplace_back(p.first, 1);\n        }\n    }\n    for (int i = start + b_expanded.size(); i < a_expanded.size(); ++i) {\n        res.push_back(a_expanded[i]);\n    }\n    \n    return merge(res);\n}\n\nint main() {\n    string sa, sb, sc;\n    cin >> sa >> sb >> sc;\n    \n    auto a = decode(sa);\n    auto b = decode(sb);\n    auto c = decode(sc);\n    \n    auto res = replaceFirst(a, b, c);\n    cout << encode(res) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        String[] parts = input.split(\"\\\\$\");\n        String A = parts[0];\n        String B = parts[1];\n        String C = parts[2];\n\n        List<Pair> aList = decodeRLE(A);\n        List<Pair> bList = decodeRLE(B);\n        List<Pair> cList = decodeRLE(C);\n\n        List<Pair> result = replaceFirstOccurrence(aList, bList, cList);\n        String output = encodeRLE(result);\n        System.out.println(output + \"$\");\n    }\n\n    static List<Pair> decodeRLE(String s) {\n        List<Pair> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 2) {\n            char c = s.charAt(i);\n            int count = Character.getNumericValue(s.charAt(i + 1));\n            list.add(new Pair(c, count));\n        }\n        return list;\n    }\n\n    static String encodeRLE(List<Pair> list) {\n        StringBuilder sb = new StringBuilder();\n        for (Pair p : list) {\n            sb.append(p.c).append(p.count);\n        }\n        return sb.toString();\n    }\n\n    static List<Pair> replaceFirstOccurrence(List<Pair> a, List<Pair> b, List<Pair> c) {\n        if (b.isEmpty()) return a;\n\n        for (int i = 0; i <= a.size() - b.size(); i++) {\n            boolean match = true;\n            for (int j = 0; j < b.size(); j++) {\n                if (a.get(i + j).c != b.get(j).c) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                List<Pair> newList = new ArrayList<>();\n                newList.addAll(a.subList(0, i));\n                newList.addAll(c);\n                newList.addAll(a.subList(i + b.size(), a.size()));\n                return newList;\n            }\n        }\n        return a;\n    }\n\n    static class Pair {\n        char c;\n        int count;\n        Pair(char c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:56:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ICPCRLEReplace {\n    public static String rleReplace(String A, String B, String C) {\n        String decodedA = decodeRLE(A);\n        String decodedB = decodeRLE(B);\n        String decodedC = decodeRLE(C);\n        \n        int index = decodedA.indexOf(decodedB);\n        if (index == -1) {\n            return A;\n        }\n        \n        String replacedString = decodedA.substring(0, index) + decodedC + decodedA.substring(index + decodedB.length());\n        return encodeRLE(replacedString);\n    }\n    \n    private static String decodeRLE(String encoded) {\n        StringBuilder decoded = new StringBuilder();\n        for (int i = 0; i < encoded.length(); i += 2) {\n            char letter = encoded.charAt(i);\n            int count = Integer.parseInt(String.valueOf(encoded.charAt(i + 1)));\n            for (int j = 0; j < count; j++) {\n                decoded.append(letter);\n            }\n        }\n        return decoded.toString();\n    }\n    \n    private static String encodeRLE(String decoded) {\n        StringBuilder encoded = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i < decoded.length(); i++) {\n            if (decoded.charAt(i) == decoded.charAt(i - 1)) {\n                count++;\n            } else {\n                encoded.append(decoded.charAt(i - 1)).append(count);\n                count = 1;\n            }\n        }\n        encoded.append(decoded.charAt(decoded.length() - 1)).append(count);\n        return encoded.toString();\n    }\n}",
    "timestamp": "2025-08-05 21:56:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring decode(const string& rle) {\n    string decoded;\n    for (int i = 0; i < rle.length(); i += 2) {\n        int count = rle[i] - '0';\n        char letter = rle[i+1];\n        decoded.append(count, letter);\n    }\n    return decoded;\n}\n\nstring encode(const string& s) {\n    string encoded;\n    int count = 1;\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i-1]) {\n            count++;\n        } else {\n            encoded += to_string(count) + s[i-1];\n            count = 1;\n        }\n    }\n    encoded += to_string(count) + s.back();\n    return encoded + \"$\";\n}\n\nint main() {\n    string A, B, C;\n    cin >> A >> B >> C;\n    \n    string decoded_A = decode(A);\n    string decoded_B = decode(B);\n    string decoded_C = decode(C);\n    \n    size_t pos = decoded_A.find(decoded_B);\n    if (pos != string::npos) {\n        decoded_A.replace(pos, decoded_B.length(), decoded_C);\n    }\n    \n    cout << encode(decoded_A) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decompress_rle(rle):\n    result = []\n    i = 0\n    while i < len(rle) - 1:\n        char = rle[i]\n        count = int(rle[i+1])\n        result.append(char * count)\n        i += 2\n    return ''.join(result)\n\ndef compress_rle(s):\n    result = []\n    i = 0\n    while i < len(s):\n        char = s[i]\n        count = 1\n        while i + 1 < len(s) and s[i + 1] == char:\n            count += 1\n            i += 1\n        result.append(f\"{char}{count}\")\n        i += 1\n    return ''.join(result) + '$'\n\ndef rle_substring_replace(A, B, C):\n    A_dec = decompress_rle(A[:-1])\n    B_dec = decompress_rle(B[:-1])\n    C_dec = decompress_rle(C[:-1])\n    \n    index = A_dec.find(B_dec)\n    if index != -1:\n        A_dec = A_dec[:index] + C_dec + A_dec[index+len(B_dec):]\n    \n    return compress_rle(A_dec)\n\n# Example Usage\nA = \"A2B3C2$\"\nB = \"B3$\"\nC = \"D5$\"\nprint(rle_substring_replace(A, B, C))  # Output: \"A2D5C2$\"",
    "timestamp": "2025-08-13 07:56:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RLEReplacement {\n    \n    static class RLEPair {\n        char letter;\n        int count;\n        \n        RLEPair(char letter, int count) {\n            this.letter = letter;\n            this.count = count;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String encodedA = sc.next();\n        String encodedB = sc.next();\n        String encodedC = sc.next();\n        \n        List<RLEPair> A = decodeRLE(encodedA);\n        List<RLEPair> B = decodeRLE(encodedB);\n        List<RLEPair> C = decodeRLE(encodedC);\n        \n        replaceFirstOccurrence(A, B, C);\n        \n        StringBuilder result = new StringBuilder();\n        for (RLEPair pair : A) {\n            result.append(pair.letter).append(pair.count);\n        }\n        result.append('$');\n        \n        System.out.println(result.toString());\n        \n        sc.close();\n    }\n    \n    private static List<RLEPair> decodeRLE(String encoded) {\n        List<RLEPair> decoded = new ArrayList<>();\n        int i = 0;\n        while (i < encoded.length() && encoded.charAt(i) != '$') {\n            char letter = encoded.charAt(i++);\n            int count = 0;\n            while (i < encoded.length() && Character.isDigit(encoded.charAt(i))) {\n                count = count * 10 + (encoded.charAt(i++) - '0');\n            }\n            decoded.add(new RLEPair(letter, count));\n        }\n        return decoded;\n    }\n    \n    private static void replaceFirstOccurrence(List<RLEPair> A, List<RLEPair> B, List<RLEPair> C) {\n        int alen = A.size(), blen = B.size();\n        for (int i = 0; i <= alen - blen; i++) {\n            if (matches(A, B, i)) {\n                List<RLEPair> newList = new ArrayList<>();\n                newList.addAll(A.subList(0, i));\n                \n                newList.addAll(C);\n                \n                int j = i + blen;\n                newList.addAll(A.subList(j, alen));\n                A.clear();\n                A.addAll(newList);\n                return;\n            }\n        }\n    }\n    \n    private static boolean matches(List<RLEPair> A, List<RLEPair> B, int start) {\n        int matchCount = 0;\n        for (int i = 0; i < B.size(); i++) {\n            RLEPair ap = A.get(start + i);\n            RLEPair bp = B.get(i);\n            if (ap.letter != bp.letter || ap.count < bp.count) {\n                return false;\n            }\n            if (ap.count == bp.count) {\n                matchCount++;\n            }\n        }\n        return matchCount == B.size() || canSplit(A, B, start);\n    }\n    \n    private static boolean canSplit(List<RLEPair> A, List<RLEPair> B, int start) {\n        for (int i = 0; i < B.size(); i++) {\n            RLEPair ap = A.get(start + i);\n            RLEPair bp = B.get(i);\n            if (ap.count > bp.count) {\n                A.set(start + i, new RLEPair(ap.letter, bp.count));\n                A.add(start + i + 1, new RLEPair(ap.letter, ap.count - bp.count));\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 07:56:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// A utility function to decompress an RLE encoded string\nvoid decompress(const char* rle, char* decompressed) {\n    int i = 0, d_index = 0;\n    while (rle[i] != '$') {\n        char letter = rle[i++];\n        int length = 0;\n        while (rle[i] >= '0' && rle[i] <= '9') {\n            length = length * 10 + (rle[i++] - '0');\n        }\n        for (int j = 0; j < length; j++) {\n            decompressed[d_index++] = letter;\n        }\n    }\n    decompressed[d_index] = '\\0';\n}\n\n// A utility function to compress a decompressed string\nvoid compress(const char* decompressed, char* rle) {\n    int i = 0, r_index = 0;\n    while (decompressed[i] != '\\0') {\n        char letter = decompressed[i];\n        int length = 0;\n        while (decompressed[i] == letter) {\n            length++;\n            i++;\n        }\n        rle[r_index++] = letter;\n        sprintf(rle + r_index, \"%d\", length);\n        while (rle[r_index] != '\\0') r_index++;\n    }\n    rle[r_index] = '$';\n    rle[r_index + 1] = '\\0';\n}\n\n// Function to replace first occurrence of B in A with C\nvoid replaceFirstOccurrence(const char* A, const char* B, const char* C, char* result) {\n    char decompA[1000], decompB[1000], decompC[1000];\n    decompress(A, decompA);\n    decompress(B, decompB);\n    decompress(C, decompC);\n\n    char* pos = strstr(decompA, decompB);\n    if (pos) {\n        char newString[1000];\n        int prefixLength = pos - decompA;\n        strncpy(newString, decompA, prefixLength);\n        newString[prefixLength] = '\\0';\n        strcat(newString, decompC);\n        strcat(newString, pos + strlen(decompB));\n\n        compress(newString, result);\n    } else {\n        strcpy(result, A);\n    }\n}\n\nint main() {\n    char A[] = \"A3B2C4$\";\n    char B[] = \"B2C$\";\n    char C[] = \"D5$\";\n    char result[1000];\n\n    replaceFirstOccurrence(A, B, C, result);\n    printf(\"%s\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:56:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decode_rle(encoded):\n    decoded = []\n    i = 0\n    while i < len(encoded) - 1:\n        count = int(encoded[i])\n        char = encoded[i+1]\n        decoded.extend([char] * count)\n        i += 2\n    return ''.join(decoded)\n\ndef encode_rle(decoded):\n    if not decoded:\n        return '$'\n    \n    encoded = []\n    current_char = decoded[0]\n    current_count = 1\n    \n    for char in decoded[1:]:\n        if char == current_char:\n            current_count += 1\n        else:\n            encoded.append(str(current_count) + current_char)\n            current_char = char\n            current_count = 1\n    \n    encoded.append(str(current_count) + current_char)\n    encoded.append('$')\n    \n    return ''.join(encoded)\n\ndef replace_substring(A, B, C):\n    decoded_A = decode_rle(A[:-1])\n    decoded_B = decode_rle(B[:-1])\n    decoded_C = decode_rle(C[:-1])\n    \n    index = decoded_A.find(decoded_B)\n    \n    if index == -1:\n        return A\n    \n    new_decoded = decoded_A[:index] + decoded_C + decoded_A[index+len(decoded_B):]\n    \n    return encode_rle(new_decoded)\n\n# Input handling\nA = input().strip()\nB = input().strip()\nC = input().strip()\n\n# Output the result\nprint(replace_substring(A, B, C))",
    "timestamp": "2025-08-13 07:56:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decode_rle(s):\n    parts = s.split('$')[0].split()\n    decoded = []\n    for part in parts:\n        if len(part) == 0:\n            continue\n        char = part[0]\n        num = int(part[1:]) if len(part) > 1 else 1\n        decoded.append(char * num)\n    return ''.join(decoded)\n\ndef encode_rle(s):\n    if not s:\n        return '$'\n    encoded = []\n    current_char = s[0]\n    count = 1\n    for char in s[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            encoded.append(f\"{current_char}{count if count > 1 else ''}\")\n            current_char = char\n            count = 1\n    encoded.append(f\"{current_char}{count if count > 1 else ''}\")\n    return ' '.join(encoded) + ' $'\n\ndef solve():\n    A_rle = input().strip()\n    B_rle = input().strip()\n    C_rle = input().strip()\n    \n    A = decode_rle(A_rle)\n    B = decode_rle(B_rle)\n    C = decode_rle(C_rle)\n    \n    index = A.find(B)\n    if index != -1:\n        edited = A[:index] + C + A[index + len(B):]\n    else:\n        edited = A\n    \n    print(encode_rle(edited))\n\nsolve()",
    "timestamp": "2025-08-13 07:57:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to decode an RLE encoded string\nstring decodeRLE(const string &rle) {\n    string decoded;\n    for (size_t i = 0; i < rle.size(); i += 2) {\n        char letter = rle[i];\n        int count = rle[i + 1] - '0';\n        decoded.append(count, letter);\n    }\n    return decoded;\n}\n\n// Function to encode a string using RLE\nstring encodeRLE(const string &str) {\n    string encoded;\n    int count = 0;\n    char current_char = '\\0';\n\n    for (char ch : str) {\n        if (ch != current_char) {\n            if (count > 0) {\n                encoded += current_char;\n                encoded += to_string(count);\n            }\n            current_char = ch;\n            count = 1;\n        } else {\n            count++;\n        }\n    }\n    if (count > 0) {\n        encoded += current_char;\n        encoded += to_string(count);\n    }\n    return encoded;\n}\n\n// Function to replace the first occurrence of B in A with C\nstring replaceFirst(string &a_decoded, const string &b_decoded, const string &c_decoded) {\n    size_t pos = a_decoded.find(b_decoded);\n    if (pos != string::npos) {\n        a_decoded.replace(pos, b_decoded.length(), c_decoded);\n    }\n    return a_decoded;\n}\n\nint main() {\n    string A, B, C;\n    cin >> A >> B >> C; // Input for RLE encoded strings\n\n    // Remove the `$` sign from each string\n    A.pop_back();\n    B.pop_back();\n    C.pop_back();\n\n    // Decode the RLE strings\n    string a_decoded = decodeRLE(A);\n    string b_decoded = decodeRLE(B);\n    string c_decoded = decodeRLE(C);\n\n    // Replace first occurrence of B in A with C\n    string modified = replaceFirst(a_decoded, b_decoded, c_decoded);\n\n    // Encode the result back to RLE\n    string encoded_result = encodeRLE(modified);\n\n    // Output the result\n    cout << encoded_result << \"$\" << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:42:05"
  }
]