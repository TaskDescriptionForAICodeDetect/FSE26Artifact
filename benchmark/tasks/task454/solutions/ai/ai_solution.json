[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 20\n\ntypedef struct {\n    int x, y;\n    int bag[26];\n    int top;\n} State;\n\nint W, H;\nchar grid[MAX_SIZE][MAX_SIZE + 1];\nint visited[MAX_SIZE][MAX_SIZE][1 << 10];\nint max_jewels = -1;\n\ntypedef struct {\n    int x, y;\n} Direction;\n\nDirection dirs[2] = {{0, 1}, {1, 0}};\n\nvoid solve() {\n    State initial;\n    initial.x = 0;\n    initial.y = 0;\n    initial.top = 0;\n    memset(initial.bag, 0, sizeof(initial.bag));\n\n    if (grid[0][0] == '#') {\n        max_jewels = -1;\n        return;\n    }\n\n    if (grid[0][0] >= 'a' && grid[0][0] <= 'z') {\n        initial.bag[initial.top++] = grid[0][0] - 'a';\n    }\n\n    int state_key = 0;\n    for (int i = 0; i < initial.top; ++i) {\n        state_key |= (1 << initial.bag[i]);\n    }\n    visited[0][0][state_key] = 1;\n\n    State queue[MAX_SIZE * MAX_SIZE * (1 << 10)];\n    int front = 0, rear = 0;\n    queue[rear++] = initial;\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (current.x == W - 1 && current.y == H - 1) {\n            int placed = 0;\n            for (int i = 0; i < 26; ++i) {\n                if ((state_key >> i) & 1) {\n                    placed++;\n                }\n            }\n            if (placed > max_jewels) {\n                max_jewels = placed;\n            }\n            continue;\n        }\n\n        for (int d = 0; d < 2; ++d) {\n            int nx = current.x + dirs[d].x;\n            int ny = current.y + dirs[d].y;\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && grid[nx][ny] != '#') {\n                State next = current;\n                next.x = nx;\n                next.y = ny;\n\n                char cell = grid[nx][ny];\n                if (cell >= 'a' && cell <= 'z') {\n                    next.bag[next.top++] = cell - 'a';\n                } else if (cell >= 'A' && cell <= 'Z') {\n                    if (next.top > 0 && next.bag[next.top - 1] == cell - 'A') {\n                        next.top--;\n                    }\n                }\n\n                int new_state_key = 0;\n                for (int i = 0; i < next.top; ++i) {\n                    new_state_key |= (1 << next.bag[i]);\n                }\n\n                if (!visited[nx][ny][new_state_key]) {\n                    visited[nx][ny][new_state_key] = 1;\n                    queue[rear++] = next;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n    for (int i = 0; i < W; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    solve();\n    printf(\"%d\\n\", max_jewels);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct State {\n    int x, y;\n    stack<char> bag;\n    int collected;\n};\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    int max_jewels = -1;\n    queue<State> q;\n    State initial;\n    initial.x = 0;\n    initial.y = 0;\n    initial.collected = 0;\n    q.push(initial);\n\n    vector<vector<vector<int>>> visited(H, vector<vector<int>>(W, vector<int>(27, -1))); // 26 letters + 1 for empty\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        int x = current.x;\n        int y = current.y;\n        int collected = current.collected;\n        stack<char> bag = current.bag;\n\n        if (x == W - 1 && y == H - 1) {\n            max_jewels = max(max_jewels, collected);\n            continue;\n        }\n\n        int bag_state = 0;\n        if (!bag.empty()) {\n            bag_state = bag.top() - 'a' + 1;\n        }\n\n        if (visited[y][x][bag_state] >= collected) {\n            continue;\n        }\n        visited[y][x][bag_state] = collected;\n\n        int dx[] = {1, 0};\n        int dy[] = {0, 1};\n        for (int i = 0; i < 2; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && grid[ny][nx] != '#') {\n                State next = current;\n                next.x = nx;\n                next.y = ny;\n                char c = grid[ny][nx];\n                if (islower(c)) {\n                    next.bag.push(c);\n                } else if (isupper(c)) {\n                    if (!next.bag.empty() && next.bag.top() == tolower(c)) {\n                        next.bag.pop();\n                        next.collected++;\n                    }\n                }\n                int next_bag_state = 0;\n                if (!next.bag.empty()) {\n                    next_bag_state = next.bag.top() - 'a' + 1;\n                }\n                if (visited[ny][nx][next_bag_state] < next.collected) {\n                    q.push(next);\n                }\n            }\n        }\n    }\n\n    cout << max_jewels << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MazeJewels {\n    static class State {\n        int x, y;\n        String bag;\n        int jewelsPlaced;\n\n        State(int x, int y, String bag, int jewelsPlaced) {\n            this.x = x;\n            this.y = y;\n            this.bag = bag;\n            this.jewelsPlaced = jewelsPlaced;\n        }\n    }\n\n    public static int solve(int W, int H, char[][] grid) {\n        int[] dx = {1, 0};\n        int[] dy = {0, 1};\n        boolean[][][] visited = new boolean[W + 1][H + 1][27]; // 26 letters + empty\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(1, 1, \"\", 0));\n        visited[1][1][0] = true;\n        int maxJewels = -1;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.x == W && current.y == H) {\n                maxJewels = Math.max(maxJewels, current.jewelsPlaced);\n                continue;\n            }\n\n            for (int i = 0; i < 2; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                if (nx <= W && ny <= H && grid[ny - 1][nx - 1] != '#') {\n                    char cell = grid[ny - 1][nx - 1];\n                    String newBag = current.bag;\n                    int newJewels = current.jewelsPlaced;\n\n                    if (Character.isLowerCase(cell)) {\n                        newBag += cell;\n                    } else if (Character.isUpperCase(cell)) {\n                        if (!newBag.isEmpty() && newBag.charAt(newBag.length() - 1) == Character.toLowerCase(cell)) {\n                            newBag = newBag.substring(0, newBag.length() - 1);\n                            newJewels++;\n                        }\n                    }\n\n                    int bagHash = newBag.isEmpty() ? 0 : newBag.charAt(0) - 'a' + 1;\n                    if (!visited[nx][ny][bagHash]) {\n                        visited[nx][ny][bagHash] = true;\n                        queue.add(new State(nx, ny, newBag, newJewels));\n                    }\n                }\n            }\n        }\n\n        return maxJewels;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int W = scanner.nextInt();\n        int H = scanner.nextInt();\n        scanner.nextLine();\n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n        System.out.println(solve(W, H, grid));\n    }\n}",
    "timestamp": "2025-08-05 21:38:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int maxJewels(char[][] maze) {\n        int W = maze.length;\n        int H = maze[0].length;\n        \n        // Dynamic programming state: [row][col][jewelsMask][topJewel]\n        int[][][][] dp = new int[W][H][1 << 10][11];\n        \n        // Initialize dp array\n        for (int[][][] row3d : dp) {\n            for (int[][] row2d : row3d) {\n                for (int[] row1d : row2d) {\n                    Arrays.fill(row1d, -1);\n                }\n            }\n        }\n        \n        // Start state\n        dp[0][0][0][10] = 0;\n        \n        for (int r = 0; r < W; r++) {\n            for (int c = 0; c < H; c++) {\n                for (int mask = 0; mask < (1 << 10); mask++) {\n                    for (int topJewel = 0; topJewel <= 10; topJewel++) {\n                        if (dp[r][c][mask][topJewel] == -1) continue;\n                        \n                        // Current cell\n                        char cell = maze[r][c];\n                        \n                        // Try moving right\n                        if (c + 1 < H && maze[r][c + 1] != '#') {\n                            int newMask = mask;\n                            int newTopJewel = topJewel;\n                            int newJewels = dp[r][c][mask][topJewel];\n                            \n                            // Handle jewel pickup\n                            if (Character.isLowerCase(maze[r][c + 1])) {\n                                newMask |= (1 << (maze[r][c + 1] - 'a'));\n                                newTopJewel = maze[r][c + 1] - 'a';\n                            }\n                            \n                            // Handle hole placement\n                            if (Character.isUpperCase(maze[r][c + 1])) {\n                                int hole = maze[r][c + 1] - 'A';\n                                if (newTopJewel == hole && (newMask & (1 << hole)) != 0) {\n                                    newMask &= ~(1 << hole);\n                                    newJewels++;\n                                    newTopJewel = 10;\n                                }\n                            }\n                            \n                            dp[r][c + 1][newMask][newTopJewel] = \n                                Math.max(dp[r][c + 1][newMask][newTopJewel], newJewels);\n                        }\n                        \n                        // Try moving down\n                        if (r + 1 < W && maze[r + 1][c] != '#') {\n                            int newMask = mask;\n                            int newTopJewel = topJewel;\n                            int newJewels = dp[r][c][mask][topJewel];\n                            \n                            // Handle jewel pickup\n                            if (Character.isLowerCase(maze[r + 1][c])) {\n                                newMask |= (1 << (maze[r + 1][c] - 'a'));\n                                newTopJewel = maze[r + 1][c] - 'a';\n                            }\n                            \n                            // Handle hole placement\n                            if (Character.isUpperCase(maze[r + 1][c])) {\n                                int hole = maze[r + 1][c] - 'A';\n                                if (newTopJewel == hole && (newMask & (1 << hole)) != 0) {\n                                    newMask &= ~(1 << hole);\n                                    newJewels++;\n                                    newTopJewel = 10;\n                                }\n                            }\n                            \n                            dp[r + 1][c][newMask][newTopJewel] = \n                                Math.max(dp[r + 1][c][newMask][newTopJewel], newJewels);\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Find maximum jewels at destination\n        int maxJewels = -1;\n        for (int mask = 0; mask < (1 << 10); mask++) {\n            for (int topJewel = 0; topJewel <= 10; topJewel++) {\n                if (dp[W - 1][H - 1][mask][topJewel] != -1) {\n                    maxJewels = Math.max(maxJewels, dp[W - 1][H - 1][mask][topJewel]);\n                }\n            }\n        }\n        \n        return maxJewels;\n    }\n}",
    "timestamp": "2025-08-05 21:38:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_W 100\n#define MAX_H 100\n#define MAX_JEWELS 26\n\ntypedef struct {\n    int x, y;\n    char letter;\n} Item;\n\nint max_jewels(char maze[MAX_H][MAX_W], int W, int H) {\n    int dp[MAX_H][MAX_W][MAX_JEWELS + 1][MAX_JEWELS + 1];\n    memset(dp, -1, sizeof(dp));\n    dp[0][0][0][0] = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            for (int jewels_cnt = 0; jewels_cnt <= MAX_JEWELS; jewels_cnt++) {\n                for (int stack_size = 0; stack_size <= jewels_cnt; stack_size++) {\n                    if (dp[i][j][jewels_cnt][stack_size] == -1) continue;\n\n                    // Current cell is obstacle\n                    if (maze[i][j] == '#') continue;\n\n                    // Move right\n                    if (j + 1 < W) {\n                        int new_jewels_cnt = jewels_cnt;\n                        int new_stack_size = stack_size;\n                        int added_jewels = 0;\n\n                        // Pick up jewel\n                        if (maze[i][j+1] >= 'a' && maze[i][j+1] <= 'z') {\n                            new_stack_size++;\n                            new_jewels_cnt++;\n                        }\n\n                        // Place jewel in hole\n                        if (maze[i][j+1] >= 'A' && maze[i][j+1] <= 'Z') {\n                            if (new_stack_size > 0 && \n                                maze[i][j+1] - 'A' == maze[i][j+1 - 'a']) {\n                                new_stack_size--;\n                                added_jewels = 1;\n                            }\n                        }\n\n                        dp[i][j+1][new_jewels_cnt][new_stack_size] = \n                            fmax(dp[i][j+1][new_jewels_cnt][new_stack_size], \n                                 dp[i][j][jewels_cnt][stack_size] + added_jewels);\n                    }\n\n                    // Move down\n                    if (i + 1 < H) {\n                        int new_jewels_cnt = jewels_cnt;\n                        int new_stack_size = stack_size;\n                        int added_jewels = 0;\n\n                        // Pick up jewel\n                        if (maze[i+1][j] >= 'a' && maze[i+1][j] <= 'z') {\n                            new_stack_size++;\n                            new_jewels_cnt++;\n                        }\n\n                        // Place jewel in hole\n                        if (maze[i+1][j] >= 'A' && maze[i+1][j] <= 'Z') {\n                            if (new_stack_size > 0 && \n                                maze[i+1][j] - 'A' == maze[i+1][j] - 'a') {\n                                new_stack_size--;\n                                added_jewels = 1;\n                            }\n                        }\n\n                        dp[i+1][j][new_jewels_cnt][new_stack_size] = \n                            fmax(dp[i+1][j][new_jewels_cnt][new_stack_size], \n                                 dp[i][j][jewels_cnt][stack_size] + added_jewels);\n                    }\n                }\n            }\n        }\n    }\n\n    int max_placed = 0;\n    for (int jewels_cnt = 0; jewels_cnt <= MAX_JEWELS; jewels_cnt++) {\n        for (int stack_size = 0; stack_size <= jewels_cnt; stack_size++) {\n            if (dp[H-1][W-1][jewels_cnt][stack_size] > max_placed) {\n                max_placed = dp[H-1][W-1][jewels_cnt][stack_size];\n            }\n        }\n    }\n\n    return max_placed == 0 ? -1 : max_placed;\n}\n\nint main() {\n    int W, H;\n    char maze[MAX_H][MAX_W];\n\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", maze[i]);\n    }\n\n    printf(\"%d\\n\", max_jewels(maze, W, H));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <stack>\n#include <climits>\n\nclass Solution {\npublic:\n    int collectMaxJewels(std::vector<std::string>& maze) {\n        int W = maze[0].length(), H = maze.size();\n        std::vector<std::vector<std::vector<int>>> dp(H, std::vector<std::vector<int>>(W, std::vector<int>(1024, INT_MIN)));\n        std::unordered_map<char, char> jewel_holes;\n\n        // Map jewels to their corresponding holes\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (islower(maze[i][j])) {\n                    jewel_holes[maze[i][j]] = toupper(maze[i][j]);\n                }\n            }\n        }\n\n        // Start cell initialization\n        if (maze[0][0] == '#') return -1;\n        dp[0][0][0] = (islower(maze[0][0]) ? 1 : 0);\n\n        // Dynamic programming\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (maze[i][j] == '#') continue;\n\n                for (int mask = 0; mask < 1024; mask++) {\n                    if (dp[i][j][mask] == INT_MIN) continue;\n\n                    // Movement down\n                    if (i + 1 < H && maze[i+1][j] != '#') {\n                        int new_mask = mask;\n                        int add_jewel = 0;\n\n                        // Handle jewel pick up\n                        if (islower(maze[i+1][j])) {\n                            new_mask |= (1 << (maze[i+1][j] - 'a'));\n                            add_jewel = 1;\n                        }\n\n                        // Handle hole placement\n                        if (isupper(maze[i+1][j])) {\n                            int jewel_index = maze[i+1][j] - 'A';\n                            if (mask & (1 << jewel_index)) {\n                                new_mask &= ~(1 << jewel_index);\n                                add_jewel = -1;\n                            }\n                        }\n\n                        dp[i+1][j][new_mask] = std::max(dp[i+1][j][new_mask], dp[i][j][mask] + add_jewel);\n                    }\n\n                    // Movement right\n                    if (j + 1 < W && maze[i][j+1] != '#') {\n                        int new_mask = mask;\n                        int add_jewel = 0;\n\n                        // Handle jewel pick up\n                        if (islower(maze[i][j+1])) {\n                            new_mask |= (1 << (maze[i][j+1] - 'a'));\n                            add_jewel = 1;\n                        }\n\n                        // Handle hole placement\n                        if (isupper(maze[i][j+1])) {\n                            int jewel_index = maze[i][j+1] - 'A';\n                            if (mask & (1 << jewel_index)) {\n                                new_mask &= ~(1 << jewel_index);\n                                add_jewel = -1;\n                            }\n                        }\n\n                        dp[i][j+1][new_mask] = std::max(dp[i][j+1][new_mask], dp[i][j][mask] + add_jewel);\n                    }\n                }\n            }\n        }\n\n        int max_jewels = INT_MIN;\n        for (int mask = 0; mask < 1024; mask++) {\n            max_jewels = std::max(max_jewels, dp[H-1][W-1][mask]);\n        }\n\n        return max_jewels == INT_MIN ? -1 : max_jewels;\n    }\n};",
    "timestamp": "2025-08-05 21:39:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_jewels_placed(grid):\n    from collections import defaultdict\n\n    def is_valid(x, y):\n        return 0 <= x < W and 0 <= y < H and grid[y][x] != '#'\n\n    def backtrack(x, y, jewels):\n        if (x, y) in memo:\n            return memo[(x, y)][frozenset(jewels)] if frozenset(jewels) in memo[(x, y)] else -1\n\n        if (x, y) == (W - 1, H - 1):\n            return len(jewels)\n\n        max_jewels = -1\n\n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            \n            if not is_valid(nx, ny):\n                continue\n\n            cell = grid[ny][nx]\n            new_jewels = jewels.copy()\n            \n            if 'a' <= cell <= 'z':\n                new_jewels.append(cell)\n            elif 'A' <= cell <= 'Z':\n                if new_jewels and new_jewels[-1] == cell.lower():\n                    new_jewels.pop()\n\n            placed = backtrack(nx, ny, new_jewels)\n            \n            if placed != -1:\n                max_jewels = max(max_jewels, placed)\n\n        if (x, y) not in memo:\n            memo[(x, y)] = defaultdict(lambda: -1)\n\n        memo[(x, y)][frozenset(jewels)] = max_jewels\n        return max_jewels\n\n    W, H = len(grid[0]), len(grid)\n    memo = {}\n\n    result = backtrack(0, 0, [])\n    return result\n\n# Example usage\ngrid = [\n    ['.', 'a', '.', 'A'],\n    ['.', '.', '.', '#'],\n    ['b', 'B', '.', '.'],\n    ['.', '#', 'c', 'C']\n]\n\nprint(max_jewels_placed(grid))  # Output depends on the grid configuration",
    "timestamp": "2025-08-13 07:18:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MazeSolver {\n    static int W, H;\n    static char[][] grid;\n    static int maxJewelsCollected = -1;\n    \n    // Directions for right and down movements\n    static final int[] dx = {0, 1};\n    static final int[] dy = {1, 0};\n\n    public static void main(String[] args) {\n        // Example input for testing\n        W = 5;\n        H = 5;\n        grid = new char[][] {\n            {'.', '.', '#', '.', 'a'},\n            {'.', '#', '#', 'A', '.'},\n            {'.', '.', '.', '.', '.'},\n            {'#', 'b', '#', '.', 'B'},\n            {'.', '.', '.', '.', '.'}\n        };\n        \n        System.out.println(solveMaze());\n    }\n\n    static int solveMaze() {\n        Stack<Character> stack = new Stack<>();\n        boolean[][] visited = new boolean[W][H];\n        dfs(0, 0, stack, visited, 0);\n        return maxJewelsCollected;\n    }\n\n    static void dfs(int x, int y, Stack<Character> stack, boolean[][] visited, int jewelsPlaced) {\n        if (x == W - 1 && y == H - 1) {\n            maxJewelsCollected = Math.max(maxJewelsCollected, jewelsPlaced);\n            return;\n        }\n        \n        visited[x][y] = true;\n\n        for (int dir = 0; dir < 2; dir++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n\n            if (nx >= 0 && nx < W && ny >= 0 && ny < H && !visited[nx][ny] && grid[nx][ny] != '#') {\n                if (Character.isLowerCase(grid[nx][ny])) {\n                    stack.push(grid[nx][ny]);\n                } else if (Character.isUpperCase(grid[nx][ny])) {\n                    char jewel = (char)(grid[nx][ny] + 'a' - 'A');\n                    if (!stack.isEmpty() && stack.peek() == jewel) {\n                        stack.pop();\n                        dfs(nx, ny, stack, visited, jewelsPlaced + 1);\n                        stack.push(jewel);\n                        continue;\n                    }\n                }\n\n                dfs(nx, ny, stack, visited, jewelsPlaced);\n\n                if (Character.isLowerCase(grid[nx][ny]) && !stack.isEmpty()) {\n                    stack.pop();\n                }\n            }\n        }\n        \n        visited[x][y] = false;\n    }\n}",
    "timestamp": "2025-08-13 07:19:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_W 50\n#define MAX_H 50\n\nint W, H;\nchar grid[MAX_W][MAX_H];\nint dp[MAX_W][MAX_H][1 << 10]; // DP with bitmask for collected jewels\nint jewelIndex[26];\n\ntypedef struct {\n    int x, y;\n    int jewelMask;\n} State;\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < W && y >= 0 && y < H && grid[x][y] != '#';\n}\n\nint maxJewels(int x, int y, int jewelMask) {\n    if (x == 0 && y == 0) return 0;\n    if (!isValid(x, y)) return -1;\n    if (dp[x][y][jewelMask] != -1) return dp[x][y][jewelMask];\n    \n    int maxCount = -1;\n    if (isValid(x - 1, y)) {\n        maxCount = maxJewels(x - 1, y, jewelMask);\n    }\n    if (isValid(x, y - 1)) {\n        maxCount = (maxCount > maxJewels(x, y - 1, jewelMask)) ? maxCount : maxJewels(x, y - 1, jewelMask);\n    }\n    \n    char cell = grid[x][y];\n    int count = maxCount;\n    \n    if (cell >= 'a' && cell <= 'z') {\n        int index = jewelIndex[cell - 'a'];\n        count = (count > (maxCount + 1)) ? count : (maxCount + 1);\n    } else if (cell >= 'A' && cell <= 'Z') {\n        int index = jewelIndex[cell - 'A'];\n        if (jewelMask & (1 << index)) {\n            count = (count > (maxCount + 1)) ? count : (maxCount + 1);\n        }\n    }\n    \n    return dp[x][y][jewelMask] = count;\n}\n\nint main() {\n    // Assume W, H, and grid are read from input\n    memset(dp, -1, sizeof(dp));\n    memset(jewelIndex, -1, sizeof(jewelIndex));\n    int jewelCount = 0;\n\n    for (int i = 0; i < W; i++) {\n        for (int j = 0; j < H; j++) {\n            char cell = grid[i][j];\n            if (cell >= 'a' && cell <= 'z') {\n                if (jewelIndex[cell - 'a'] == -1) {\n                    jewelIndex[cell - 'a'] = jewelCount++;\n                }\n            }\n            if (cell >= 'A' && cell <= 'Z') {\n                if (jewelIndex[cell - 'A'] == -1) {\n                    jewelIndex[cell - 'A'] = jewelCount++;\n                }\n            }\n        }\n    }\n\n    int result = maxJewels(W - 1, H - 1, 0);\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:19:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_maze(maze):\n    W, H = len(maze[0]), len(maze)\n    \n    # Create dynamic programming table with state tracking\n    dp = [[{'max_jewels': 0, 'jewel_stack': []} for _ in range(W)] for _ in range(H)]\n    \n    # Initialize start point\n    dp[0][0]['max_jewels'] = 0\n    \n    # Track collected and matched jewels\n    jewel_holes = {}\n    \n    # Process each cell\n    for r in range(H):\n        for c in range(W):\n            if maze[r][c] == '#':\n                continue\n            \n            # Collect jewels\n            if maze[r][c].islower():\n                if r > 0 and dp[r-1][c]['max_jewels'] != -1:\n                    dp[r][c]['jewel_stack'] = dp[r-1][c]['jewel_stack'] + [maze[r][c]]\n                    dp[r][c]['max_jewels'] = dp[r-1][c]['max_jewels']\n                if c > 0 and dp[r][c-1]['max_jewels'] != -1:\n                    dp[r][c]['jewel_stack'] = dp[r][c-1]['jewel_stack'] + [maze[r][c]]\n                    dp[r][c]['max_jewels'] = dp[r][c-1]['max_jewels']\n            \n            # Place jewels in holes\n            if maze[r][c].isupper():\n                if dp[r][c]['jewel_stack'] and dp[r][c]['jewel_stack'][-1].upper() == maze[r][c]:\n                    dp[r][c]['max_jewels'] += 1\n                    dp[r][c]['jewel_stack'].pop()\n            \n            # Move right\n            if c > 0 and dp[r][c-1]['max_jewels'] != -1:\n                if dp[r][c]['max_jewels'] == 0 or dp[r][c]['max_jewels'] < dp[r][c-1]['max_jewels']:\n                    dp[r][c]['max_jewels'] = dp[r][c-1]['max_jewels']\n                    dp[r][c]['jewel_stack'] = dp[r][c-1]['jewel_stack'].copy()\n            \n            # Move down\n            if r > 0 and dp[r-1][c]['max_jewels'] != -1:\n                if dp[r][c]['max_jewels'] == 0 or dp[r][c]['max_jewels'] < dp[r-1][c]['max_jewels']:\n                    dp[r][c]['max_jewels'] = dp[r-1][c]['max_jewels']\n                    dp[r][c]['jewel_stack'] = dp[r-1][c]['jewel_stack'].copy()\n    \n    # Return result\n    return dp[H-1][W-1]['max_jewels'] if dp[H-1][W-1]['max_jewels'] != -1 else -1",
    "timestamp": "2025-08-13 07:19:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Directions: right (0, 1), down (1, 0)\n    directions = [(0, 1), (1, 0)]\n    \n    # We'll use BFS where each state is (i, j, stack)\n    # Initialize with starting position (0, 0) in 0-based and empty stack\n    visited = {}\n    queue = deque()\n    initial_stack = []\n    queue.append((0, 0, initial_stack))\n    visited[(0, 0, tuple(initial_stack))] = True\n    \n    max_jewels = -1\n    \n    while queue:\n        i, j, stack = queue.popleft()\n        \n        if i == H-1 and j == W-1:\n            # Reached the end, count the jewels in holes\n            count = 0\n            temp_stack = stack.copy()\n            while temp_stack:\n                jewel = temp_stack.pop()\n                if jewel.isupper():\n                    count += 1\n            max_jewels = max(max_jewels, count)\n            continue\n        \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                cell = grid[ni][nj]\n                new_stack = stack.copy()\n                \n                if cell == '#':\n                    continue\n                elif cell == '.':\n                    pass\n                elif cell.islower():  # Jewel\n                    new_stack.append(cell)\n                elif cell.isupper():  # Hole\n                    if new_stack and new_stack[-1].lower() == cell.lower():\n                        new_stack.pop()\n                    else:\n                        new_stack.append(cell)\n                \n                state = (ni, nj, tuple(new_stack))\n                if state not in visited:\n                    visited[state] = True\n                    queue.append((ni, nj, new_stack))\n    \n    print(max_jewels)\n\nsolve()",
    "timestamp": "2025-08-13 07:19:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct State {\n    int x, y, jewelMask; // position and bitmask of jewels in the stack\n    int placedJewels;    // number of placed jewels\n\n    State(int x, int y, int jewelMask, int placedJewels)\n        : x(x), y(y), jewelMask(jewelMask), placedJewels(placedJewels) {}\n\n    bool operator<(const State& other) const {\n        if (x != other.x) return x < other.x;\n        if (y != other.y) return y < other.y;\n        return jewelMask < other.jewelMask;\n    }\n};\n\nint solveMaze(const vector<string>& maze, int W, int H) {\n    const int dx[2] = {1, 0};\n    const int dy[2] = {0, 1};\n    map<State, int> dist;\n    queue<State> q;\n\n    State start(0, 0, 0, 0);\n    q.push(start);\n    dist[start] = 0;\n\n    int maxJewelsPlaced = -1;\n\n    while (!q.empty()) {\n        State cur = q.front();\n        q.pop();\n        \n        if (cur.x == W - 1 && cur.y == H - 1) {\n            maxJewelsPlaced = max(maxJewelsPlaced, cur.placedJewels);\n            continue;\n        }\n\n        for (int dir = 0; dir < 2; ++dir) {\n            int nx = cur.x + dx[dir];\n            int ny = cur.y + dy[dir];\n            if (nx >= W || ny >= H || maze[ny][nx] == '#') continue;\n\n            char cell = maze[ny][nx];\n            int newJewelMask = cur.jewelMask;\n            int newPlacedJewels = cur.placedJewels;\n\n            if (cell >= 'a' && cell <= 'z') {\n                int jewelIdx = cell - 'a';\n                newJewelMask |= (1 << jewelIdx);\n            }\n\n            if (cell >= 'A' && cell <= 'Z') {\n                int holeIdx = cell - 'A';\n                if (newJewelMask & (1 << holeIdx)) {\n                    newJewelMask ^= (1 << holeIdx);\n                    newPlacedJewels++;\n                }\n            }\n\n            State next(nx, ny, newJewelMask, newPlacedJewels);\n            if (dist.count(next) > 0) continue;\n\n            dist[next] = dist[cur] + 1;\n            q.push(next);\n        }\n    }\n    \n    return maxJewelsPlaced;\n}\n\nint main() {\n    int W, H;\n    cin >> W >> H;\n    vector<string> maze(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> maze[i];\n    }\n    \n    int result = solveMaze(maze, W, H);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:37:40"
  }
]