[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nint H, W;\nmap<PII,int> memo;\n// sit -> tid　へ行く時の最大値\nint dfs(int sid, int tid, VVI& reachable, VVI& lowids, VVI& upids){\n  if(memo.count(MP(sid,tid))) return memo[MP(sid,tid)];\n  int& res = memo[MP(sid,tid)];\n  REP(c,26){\n\tfor(auto l: lowids[c])\n\t  for(auto u: upids[c]){\n\t\tif(l!=sid && u!=tid && reachable[sid][l] == 0 && reachable[u][tid] == 0 && reachable[l][u] == 0)\n\t\t  res =max(res, 1+dfs(sid, l, reachable, lowids, upids)\n\t\t\t\t   + dfs(l, u, reachable, lowids, upids)\n\t\t\t\t   + dfs(u, tid, reachable, lowids, upids));\n\t  }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>H>>W,H>0){memo.clear();\n\tVS vs(H);\n\tREP(i,H) cin >> vs[i];\n\t//if(vs[0][0] == '.') vs[0][0] = 'z'+1;\n\t//if(vs.back().back() == '.') vs.back().back() = 'z'+2;\n\n\tmap<PII,int> ids; // 座標と対応するid\n\tmap<int,char> ch; // idに対応するその文字\n\tint num = 0;\n\tfor(int y=0;y<H;++y)\n\t  REP(x,W)\n\t\tif(vs[y][x] != '.' && vs[y][x] != '#'){\n\t\t  ch[num] = vs[y][x];\n\t\t  ids[MP(x,y)] = num++;\n\t\t}\n\n\tVVI dist(num+2, VI(num+2, -1)); // ふたつのid: i,jについて dist[i][j] = 0 iff i -> j が存在\n\tREP(y,H) REP(x,W)\n\t  if(ids.count(MP(x,y))){\n\t\tint id = ids[MP(x,y)];\n\t\tqueue<PII> q;\n\t\tmap<PII,bool> vis;\n\t\tq.push(PII(x,y));\n\t\tvis[PII(x,y)] = true;\n\t\twhile(!q.empty()){\n\t\t  PII p = q.front(); q.pop();\n\t\t  if(ids.count(p)){\n\t\t\tdist[id][ids[p]] = 0;\n\t\t  }\n\n\t\t  for(auto dp: {PII(0,1), PII(1,0)}){\n\t\t\tp.FF += dp.FF;\n\t\t\tp.SS += dp.SS;\n\t\t\tif(p.FF < W && p.SS < H && vs[p.SS][p.FF] != '#' && !vis[p]){\n\t\t\t  q.push(p);\n\t\t\t  vis[p] =true;\n\t\t\t}\n\t\t\tp.FF -= dp.FF;\n\t\t\tp.SS -= dp.SS;\n\t\t  }\n\t\t}\n\t  }\n\n\tint S = num, T = num+1;\n\t{\n\t  queue<PII> q;\n\t  map<PII,bool> vis;\n\t  q.push(PII(0,0));\n\t  vis[PII(0,0)] = true;\n\t  while(!q.empty()){\n\t\tPII p = q.front(); q.pop();\n\t\tif(ids.count(p)){\n\t\t  dist[S][ids[p]] = 0;\n\t\t}\n\t\t\n\t\tfor(auto dp: {PII(0,1), PII(1,0)}){\n\t\t  p.FF += dp.FF;\n\t\t  p.SS += dp.SS;\n\t\t  if(p.FF < W && p.SS < H && vs[p.SS][p.FF] != '#' && !vis[p]){\n\t\t\tq.push(p);\n\t\t\tvis[p] =true;\n\t\t  }\n\t\t  p.FF -= dp.FF;\n\t\t  p.SS -= dp.SS;\n\t\t}\n\t  }\n\t}\n\t{\n\t  queue<PII> q;\n\t  map<PII,bool> vis;\n\t  q.push(PII(W-1,H-1));\n\t  vis[PII(W-1,H-1)] = true;\n\t  while(!q.empty()){\n\t\tPII p = q.front(); q.pop();\n\t\tif(ids.count(p)){\n\t\t  dist[ids[p]][T] = 0;\n\t\t}\n\t\tif(p == MP(0,0))\n\t\t  dist[S][T] = 0;\n\t\t\n\t\tfor(auto dp: {PII(0,-1), PII(-1,0)}){\n\t\t  p.FF += dp.FF;\n\t\t  p.SS += dp.SS;\n\t\t  if(p.FF >= 0 && p.SS >= 0 && vs[p.SS][p.FF] != '#' && !vis[p]){\n\t\t\tq.push(p);\n\t\t\tvis[p] =true;\n\t\t  }\n\t\t  p.FF -= dp.FF;\n\t\t  p.SS -= dp.SS;\n\t\t}\n\t  }\n\t}\n\tif(dist[S][T] != 0){\n\t  cout << -1 << endl;\n\t  continue;\n\t}\n\n\tVVI lower(26), upper(26);\n\tfor(auto& id: ids)\n\t  if('a' <= ch[id.SS] && ch[id.SS] <= 'z')\n\t\tlower[ch[id.SS]-'a'].PB(id.SS);\n\t  else if('A' <= ch[id.SS] && ch[id.SS] <= 'Z')\n\t\tupper[ch[id.SS]-'A'].PB(id.SS);\n\n\tint ans = dfs(S, T, dist, lower, upper);\n  \tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[30];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(ret != -1) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for(int i = 0; i < 2;i++){\n                    for(int j = 0; j < 2;j++){\n                        ll innery1 = y1+dy[i], innerx1 = x1+dx[i];\n                        ll innery2 = ny - dy[j], innerx2 = nx - dx[j];\n                        if(innery1 > y2 || innerx1 > x2 || innery2 < y1 || innerx2 < x1 ) continue;\n                        if(!can[innery1][innerx1][innery2][innerx2]) continue;\n                        ret = max(ret,dfs(innery1,innerx1,innery2,innerx2,maze) + dfs(ny,nx,y2,x2,maze) + 1);\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(ll H,ll W){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 30;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            char c; cin >> c;\n            maze[i][j] = c;\n            if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n        }\n    }\n    memset(can,false,sizeof(can));\n//    fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i >= 1; i--){\n        for(ll j = W; j >= 1; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    //cout << maze << endl;\n    //fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    memset(dp,-1,sizeof(dp));\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll H,W;\n    while(cin >> H >> W,H|W){\n        cout << solve(H,W) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<cctype>\n\nusing namespace std;\n\nint H,W;\nchar C[50][52];\nvector<pair<int,int> > p[256];\nbool memed[52][52][52][52];\nint mem[52][52][52][52];\n\nint rec(int hy,int hx,int ty,int tx){\n  if(ty<hy||tx<hx||C[hy][hx]=='#')return -1e9;\n  if(hy==ty&&hx==tx)return 0;\n  if(memed[hy][hx][ty][tx]++)return mem[hy][hx][ty][tx];\n  int mx=max(rec(hy+1,hx,ty,tx),rec(hy,hx+1,ty,tx));\n  if(islower(C[hy][hx])){\n    for(auto e:p[toupper(C[hy][hx])]){\n      if(ty<e.first||tx<e.second||e.first<hy||e.second<hx)continue;\n      int sx=-1e9;\n      if(hy+1==e.first&&hx==e.second||hy==e.first&&hx+1==e.second){\n\tsx=1;\n      }else{\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<2;j++){\n\t    sx=max(sx,rec(hy+i,hx+(i^1),e.first-j,e.second-(j^1))+1);\n\t  }\n\t}\n      }\n      if(e.first==ty&&e.second==tx){\n\tmx=max(mx,sx);\n      }else{\n\tfor(int i=0;i<2;i++){\n\t  mx=max(mx,sx+rec(e.first+i,e.second+(i^1),ty,tx));\n\t}\n      }\n    }\n  }\n  return mem[hy][hx][ty][tx]=mx;\n}\n\nint main(){\n  while(cin>>H>>W,H|W){\n    fill(***begin(memed),***end(memed),false);\n    for(auto &e:p){\n      e.clear();\n    }\n    for(int i=0;i<H;i++){\n      cin>>C[i];\n      for(int j=0;j<W;j++){\n\tp[C[i][j]].emplace_back(i,j);\n      }\n    }\n    int ans=rec(0,0,H-1,W-1);\n    cout<<((ans<0)?-1:ans)<<endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(a == b || b < a) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(nx1 == hole) res = max(1, res);\n                if(range_out(nx1) || range_out(nx2)) continue;\n                if(fld[nx1.y][nx1.x] == '#' || fld[nx2.y][nx2.x] == '#') continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[H - 1][W - 1] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(a == b || b < a) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(nx1 == hole) res = max(1, res);\n                if(range_out(nx1) || range_out(nx2)) continue;\n                if(fld[nx1.y][nx1.x] == '#' || fld[nx2.y][nx2.x] == '#') continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<(dfs(0,0,h-1,w-1)<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[2][55][55][55][55];\nbool used[2][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c==1&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tres=max(res,dfs(0,sy,sx,cy[0][k][i],cx[0][k][i])+\n\t\tdfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j])+\n\t\tdfs(0,cy[1][k][j],cx[1][k][j],ty,tx)+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\ntemplate <typename T>\nvector<T> Vec(int n, T v) { return vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    while (true) {\n        int H, W;\n        cin >> H >> W;\n        if (H == 0 and W == 0) { break; }\n        auto C = Vec(H, W, char(0));\n        auto I = Vec(H, W, -1);\n        using P = pair<int, int>;\n        auto in = [&](const int y, const int x) { return y >= 0 and y < H and x >= 0 and x < W and C[y][x] != '#'; };\n        vector<P> pos[26]{}, POS[26]{};\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> C[i][j];\n                if (islower(C[i][j])) {\n                    const int c = C[i][j] - 'a';\n                    pos[c].push_back({i, j});\n                    I[i][j] = pos[c].size() - 1;\n                } else if (isupper(C[i][j])) {\n                    const int c = C[i][j] - 'A';\n                    POS[c].push_back({i, j});\n                    I[i][j] = POS[c].size() - 1;\n                }\n            }\n        }\n        auto bfs = [&](const int y, const int x) {\n            auto used = Vec(H, W, false);\n            queue<P> q;\n            q.push({y, x}), used[y][x] = true;\n            while (not q.empty()) {\n                const int y = q.front().first, x = q.front().second;\n                q.pop();\n                if (in(y + 1, x) and not used[y + 1][x]) { q.push({y + 1, x}), used[y + 1][x] = true; }\n                if (in(y, x + 1) and not used[y][x + 1]) { q.push({y, x + 1}), used[y][x + 1] = true; }\n            }\n            return used;\n        };\n        if (not bfs(0, 0)[H - 1][W - 1]) {\n            cout << -1 << endl;\n            continue;\n        }\n        vector<vector<bool>> ok[26];\n        for (int i = 0; i < 26; i++) {\n            const int S = pos[i].size(), T = POS[i].size();\n            ok[i] = Vec(S, T, false);\n            for (int j = 0; j < S; j++) {\n                const auto used = bfs(pos[i][j].first, pos[i][j].second);\n                for (int k = 0; k < T; k++) { ok[i][j][k] = used[POS[i][k].first][POS[i][k].second]; }\n            }\n        }\n        auto memo = Vec(H, W, H, W, -1);\n        constexpr int INF = 1 << 30;\n        auto solve = fix([&](auto&& self, const int y1, const int x1, const int y2, const int x2) -> int {\n            if (not in(y1, x1) or not in(y2, x2) or y2 < y1 or x2 < x1) { return -INF; }\n            if (y1 == y2 and x1 == x2) { return memo[y1][x1][y2][x2] = 0; }\n            if (memo[y1][x1][y2][x2] != -1) { return memo[y1][x1][y2][x2]; }\n            int ans = max(self(self, y1 + 1, x1, y2, x2), self(self, y1, x1 + 1, y2, x2));\n            if (islower(C[y1][x1]) == 0) { return memo[y1][x1][y2][x2] = ans; }\n            const int c = C[y1][x1] - 'a', ind = I[y1][x1];\n            for (int j = 0; j < POS[c].size(); j++) {\n                if (ok[c][ind][j]) {\n                    const int D = abs(POS[c][j].first - y1) + abs(POS[c][j].second - x1);\n                    const int after = self(self, POS[c][j].first, POS[c][j].second, y2, x2);\n                    const int before = D == 1 ? 0 : max({self(self, y1 + 1, x1, POS[c][j].first - 1, POS[c][j].second), self(self, y1, x1 + 1, POS[c][j].first - 1, POS[c][j].second), self(self, y1 + 1, x1, POS[c][j].first, POS[c][j].second - 1), self(self, y1, x1 + 1, POS[c][j].first, POS[c][j].second - 1)});\n                    ans = max(ans, before + after + 1);\n                }\n            }\n            return memo[y1][x1][y2][x2] = ans;\n        });\n        cout << solve(0, 0, H - 1, W - 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n  ret = -(1<<29);\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n   \n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x==W || y==H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      int res = solve(0,0,W-1,H-1);\n      assert( res >= 0 );\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 60;\n\nstruct Po\n{\n    int x,y;\n    Po(int x,int y) : x(x) ,y(y){};\n    Po(){};\n    bool operator == (const Po &b) const{\n        return x==b.x&&y==b.y;\n    }\n    void print()\n    {\n        printf(\"(%d,%d)\",x,y);\n    }\n};\n\nchar mp[maxn][maxn];\nint id[maxn][maxn];\nint W,H;\n\nvector<Po>a[maxn],A[maxn];\n\nint down_a[maxn][maxn][maxn][maxn];\nint up_A[maxn][maxn][maxn][maxn];\n\nint dp[maxn][maxn][maxn][maxn];\nint vis[maxn][maxn][maxn][maxn];\n\nint dx[4] = { 0,1 };\nint dy[4] = { 1,0 };\n\nint TIME;\n\n#define debug_x printf(\"x1 %d y1 %d x2 %d y2 %d\\n\",x1,y1,x2,y2);\n\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if( x1 == x2 && y1 == y2+1 ) return 0;\n    if( x1 == x2+1 && y1 == y2 ) return 0;\n    if( x1 == x2 && y1 == y2 ) return 0;\n\n    if( x1>x2 || y1>y2 ) return -1;\n\n    int &t = dp[x1][y1][x2][y2];\n\n    if( vis[x1][y1][x2][y2] ) return t;\n\n    vis[x1][y1][x2][y2] = 1;\n\n\n    if( mp[x1][y1] == '#' || mp[x2][y2] == '#' ) return t=-1;\n\n    t = max( dfs(x1+1,y1,x2,y2) , dfs(x1,y1+1,x2,y2) );\n\n    for(int c=0;c<26;c++)\n    {\n        for( int i=0;i<a[c].size();i++ ) if( down_a[x1][y1][c][i] )\n            for( int j=0;j<A[c].size();j++ ) if( up_A[x2][y2][c][j] )\n            {\n                int t1=-1,t2=-1,t3=-1;\n                for( int k=0;k<2;k++ )\n                {\n                    t1 = max( t1 , dfs( x1,y1,a[c][i].x-dx[k],a[c][i].y-dy[k] ) );\n                    t3 = max( t3 , dfs( A[c][j].x+dx[k],A[c][j].y+dy[k],x2,y2 ) );\n                }\n                for(int k1=0;k1<2;k1++)\n                    for(int k2=0;k2<2;k2++)\n                    {\n                        t2 = max( t2 , dfs( a[c][i].x+dx[k1],a[c][i].y+dy[k1],\n                                            A[c][j].x-dx[k2],A[c][j].y-dy[k2] ) );\n                    }\n                if( t1>=0&&t2>=0&&t3>=0 )\n                    t = max( t , t1+t2+t3+1 );\n            }\n    }\n    return t;\n}\n\nvoid bfs()\n{\n    clr(down_a,0);\n    clr(up_A,0);\n    for(int i=1 ; i<=W ; i++)\n        for(int j=1 ; j<=H ; j++)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<A[c].size();k++)\n                {\n                    up_A[i][j][c][k] =\n                        up_A[i-1][j][c][k] | up_A[i][j-1][c][k];\n                }\n            if( mp[i][j] >= 'A' && mp[i][j] <= 'Z' )\n            {\n                up_A[i][j][ mp[i][j]-'A' ][ id[i][j] ] = 1;\n                if( id[i][j] < 0 || id[i][j] > 10 ) while(1);\n            }\n        }\n    for(int i=W ; i>=1 ; i--)\n        for(int j=H ; j>=1 ; j--)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<a[c].size();k++)\n                {\n                    down_a[i][j][c][k] =\n                        down_a[i+1][j][c][k] | down_a[i][j+1][c][k];\n                }\n            if( mp[i][j] >= 'a' && mp[i][j] <= 'z' )\n            {\n                down_a[i][j][ mp[i][j]-'a' ][ id[i][j] ] = 1;\n                if( id[i][j] < 0 || id[i][j] > 10 ) while(1);\n            }\n        }\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while( ~scanf(\"%d%d\",&W,&H) )\n    {\n        if(W==0&&H==0) break;\n        clr( id , 0 );\n        for(int i=0;i<30;i++)\n        {\n            a[i].clear();\n            A[i].clear();\n        }\n        char c;\n        for(int i=1;i<=W;i++)\n            for(int j=1;j<=H;j++)\n            {\n\n                scanf(\" %c\",&c);\n                mp[i][j] = c;\n                if( c>='a' && c<='z' )\n                {\n                    a[ c-'a' ].push_back( Po(i,j) );\n                    id[i][j] = a[ c-'a' ].size()-1;\n                }\n                if( c>='A' && c<='Z' )\n                {\n                    A[ c-'A' ].push_back( Po(i,j) );\n                    id[i][j] = A[ c-'A' ].size()-1;\n                }\n            }\n\n        bfs();\n\n        clr(vis,0);\n        int ans = dfs(1,1,W,H);\n\n        if(ans>=0) printf(\"%d\\n\",ans);\n        else printf(\"-1\\n\",ans);\n    }\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<VVV> VVVV;\ntypedef tuple<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint isLC(char c){\n    if('a'<=c&&c<='z')return c-'a';\n    else return -1;\n}\nint isUC(char c){\n    if('A'<=c&&c<='Z')return c-'A';\n    else return -2;\n}\nbool inner(int lb,int c,int ub){\n    return lb<=c&&c<=ub;\n}\nint f(int rbg,int red,int cbg,int ced,vector<string>& s,VVVV &memo,VVP&U){\n    if(memo[rbg][cbg][red][ced]!=-2)return memo[rbg][cbg][red][ced];\n    //cout<<cbg<<\" \"<<ced<<endl;\n    int R=1+red-rbg;\n    int C=1+ced-cbg;\n    VV dp(R,V(C,-1));\n    dp[0][0]=0;\n    int x=isLC(s[rbg][cbg]);\n    int y=isUC(s[red][ced]);\n    if(x==y){\n        s[rbg][cbg]='.';\n        s[red][ced]='.';\n        dp[0][0]++;\n    }\n    for(int r=rbg;r<=red;r++){\n        for(int c=cbg;c<=ced;c++){\n            int i=r-rbg;\n            int j=c-cbg;\n            if(s[r][c]=='#')continue;\n            int id=isLC(s[r][c]);\n            if(id>=0){\n                for(auto &it:U[id]){\n                    int nr,nc;\n                    tie(nr,nc)=it;\n                    if(inner(r,nr,red)&&inner(c,nc,ced)&&isLC(s[r][c])==isUC(s[nr][nc])){\n                        int val=f(r,nr,c,nc,s,memo,U);\n                        int ni=nr-rbg;\n                        int nj=nc-cbg;\n                        if(val!=-1)\n                            dp[ni][nj]=max(dp[ni][nj],dp[i][j]+val);\n                    }\n                }            \n            }\n            if(r!=red&&s[r+1][c]!='#')dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n            if(c!=ced&&s[r][c+1]!='#')dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n        }     \n    }\n    if(x==y){\n        s[rbg][cbg]=x+'a';\n        s[red][ced]=y+'A';\n    }\n    //cout<<cbg<<\" \"<<ced<<\" \"<<dp[R-1][C-1]<<endl;\n    return memo[rbg][cbg][red][ced]=dp[R-1][C-1];\n}\n\n\nint main(){\n    for(int R,C;cin>>R>>C,R+C;){\n        vector<string> s(R);\n        for(auto &it:s)cin>>it;\n        VVP uc(26);\n        for(int i=0;i<R;i++)\n            for(int j=0;j<C;j++){\n                int id=isUC(s[i][j]);\n                if(id>=0)uc[id].push_back(P(i,j));\n            }\n        VVVV memo(R,VVV(C,VV(R,V(C,-2))));\n        cout<<f(0,R-1,0,C-1,s,memo,uc)<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 51;\nconst int MAXW = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint H, W;\nchar C[MAXH][MAXW];\nvector<pair<int, int> > to[MAXH][MAXW];\nint mem[MAXH][MAXW][MAXH][MAXW];\n\nbool ok(int i, int j) {\n  if(i < 0 || i >= H) return false;\n  if(j < 0 || j >= W) return false;\n  if(C[i][j] == '#') return false;\n  return true;\n}\n\nint dist(int a, int b, int c, int d) {\n  return abs(c - a) + abs(d - b);\n}\n\nint rec(int a, int b, int c, int d) {\n  int &res = mem[a][b][c][d];\n  if(res != -1) return res;\n  if(a == c && b == d) return res = 0;\n  res = -INF;\n\n  for(int i = 0; i < 2; ++i) {\n    int na = a + di[i];\n    int nb = b + dj[i];\n    if(!ok(na, nb)) continue;\n    if(na > c || nb > d) continue;\n    res = max(res, rec(na, nb, c, d));\n  }\n\n  for(int k = 0; k < to[a][b].size(); ++k) {\n    const int p = to[a][b][k].first;\n    const int q = to[a][b][k].second;\n    if(p > c || q > d) continue;\n    for(int i = 0; i < 2; ++i) {\n      for(int j = 2; j < 4; ++j) {\n        int na = a + di[i];\n        int nb = b + dj[i];\n        int nc = p + di[j];\n        int nd = q + dj[j];\n        if(!ok(na, nb) || !ok(nc, nd)) continue;\n        int A, B;\n        if(dist(a, b, p, q) <= 2) A = 0;\n        else A = rec(na, nb, nc, nd);\n        B = rec(p, q, c, d);\n        if(A == -INF || B == -INF) continue;\n        res = max(res, 1 + A + B);\n      }\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  while(cin >> H >> W && (H|W)) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> C[i][j];\n      }\n    }\n\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        to[i][j].clear();\n        if(islower(C[i][j])) {\n          for(int ni = i; ni < H; ++ni) {\n            for(int nj = j; nj < W; ++nj) {\n              if(toupper(C[i][j]) == C[ni][nj]) {\n                to[i][j].push_back(make_pair(ni, nj));\n              }\n            }\n          }\n        }\n      }\n    }\n\n    memset(mem, -1, sizeof(mem));\n    int res = rec(0, 0, H-1, W-1);\n    if(res == -INF) res = -1;\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = (int)mp.size();\n  }\n  int V = mp.size();\n  G.resize(V);\n  ws.resize(V);\n  bool used[H][W];\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\n  assert( topologicalSort(G,order) );\n\n  // DP\n  int V = G.size();\n  bool hasEdge[V][V];\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  assert( V < MAX_V );\n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,x2,y2 ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n  if( ret == -1 ) ret = -(1<<29);\n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x>=W || y>=H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << \"-1\" << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define srep(i,n,m) for(int i=(int)n;i<=(int)m;i++)\nint n,m;\nint dp[52][52][52][52];\nbool ok[52][52][52][52];\nint inf = 1000000;\nvector<string>s;\nint saiki(int a,int b,int c,int d){\n    if(a<0||a>=n||c<0||c>=n||b<0||b>=m||d<0||d>=m)return -inf;\n    if(s[a][b]=='#'||s[c][d]=='#')return -inf;\n    if(a==c&&b==d)return 0;\n    if(ok[a][b][c][d])return dp[a][b][c][d]; \n    ok[a][b][c][d] = 1;\n    if(a>c||b>d){\n        return dp[a][b][c][d] = -inf;\n    }\n    if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]==s[a][b]+('A'-'a')){\n        if(c==a+1&&b==d)return dp[a][b][c][d]=1;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=1;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c-1,d)+1);\n        tmp = max(tmp,saiki(a+1,b,c,d-1)+1);\n        tmp = max(tmp,saiki(a,b+1,c-1,d)+1);\n        tmp = max(tmp,saiki(a,b+1,c,d-1)+1);\n        if(s[a][b]!='.'&&s[c][d]!='.'){\n            srep(i,a,c){\n                srep(j,b,d){\n                    if(i==c&&j==d)continue;\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n                }\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }else{\n        if(c==a+1&&b==d)return dp[a][b][c][d]=0;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=0;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c,d));\n        tmp = max(tmp,saiki(a,b,c-1,d));\n        tmp = max(tmp,saiki(a,b+1,c,d));\n        tmp = max(tmp,saiki(a,b,c,d-1));\n        if(s[a][b]!='.'&&s[c][d]!='.'){\n            srep(i,a,c){\n                srep(j,b,d){\n                    if(i==c&&j==d)continue;\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n                }\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }\n}\n\n\nint main(){\n    while(cin >> n >> m &&n!=0){\n        s.resize(n);\n        rep(i,n)cin >> s[i];\n        rep(i,52){\n            rep(j,52){\n                rep(k,52){\n                    rep(l,52){\n                        dp[i][j][k][l] = 0;\n                        ok[i][j][k][l] = 0;\n                    }\n                }\n            }\n        }\n        int ans = saiki(0,0,n-1,m-1);\n        if(ans<0){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n \nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n    if(x1>x2||y1>y2)return -1000;\n    if(v[x1][y1]=='#'||v[x2][y2]=='#')return -1000;\n    if(dp[x1][y1][x2][y2]!=-10000){\n        return dp[x1][y1][x2][y2];\n    }\n    if(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n    if(x2-x1==1&&y2-y1==0){\n        if(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    if(x2-x1==0&&y2-y1==1){\n        if(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    int tmp = -100;\n    if(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n        tmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n    }\n    tmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n    if(tmp>=0){\n        return dp[x1][y1][x2][y2] = tmp;\n    }\n    return dp[x1][y1][x2][y2] = -1000;\n}\n \nint saiki2(int x1,int y1,int x2,int y2){\n    if(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n    if(dp2[x1][y1][x2][y2]!=-10000)return dp2[x1][y1][x2][y2];\n    int mx = -1000;\n    for(int i=x1;i<=x2;i++){\n        for(int j=y1;j<=y2;j++){\n            if(i==x1&&j==y1)continue;\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i,j,x2,y2));\n        }\n    }\n    return dp2[x1][y1][x2][y2] = mx;\n \n}\n \nint main() {\n    while(cin >> h >> w && h!=0){\n        vector<string> v(h);\n        rep(i,h){\n            cin >> v[i];\n        }\n        rep(i,51){\n            rep(j,51){\n                rep(k,51){\n                    rep(l,51){\n                        dp[i][j][k][l] = -10000;\n                        dp2[i][j][k][l] = -10000;\n                    }\n                }\n            }\n        }           \n        int ans = saiki(0,0,h-1,w-1,v);\n        ans = saiki2(0,0,h-1,w-1);\n        if(ans>=0){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\n\nint H,W;\nint dp[50][50][50][50];\nint diff_row[2] = {0,1},diff_col[2] = {1,0};\nchar table[50][51];\nbool can_visit[50][50][50][50];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint recursive(int row1,int col1,int row2,int col2){\n\n\tif(dp[row1][col1][row2][col2] != -1)return dp[row1][col1][row2][col2];\n\n\tif(row1 == row2 && row1 == H-1 && col1 == col2 && col1 == W-1)return 0;\n\n\tint ret = 0;\n\n\tif(table[row1][col1] == '.' || (table[row1][col1] >= 'A' && table[row1][col1] <= 'Z')){\n\n\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t}else if(table[row1][col1] >= 'a' && table[row1][col1] <= 'z'){\n\n\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t\tfor(int tmp_row = row1; tmp_row <= row2; tmp_row++){\n\t\t\tfor(int tmp_col = col1; tmp_col <= col2; tmp_col++){\n\t\t\t\tif(table[tmp_row][tmp_col]+32 == table[row1][col1] && can_visit[row1][col1][tmp_row][tmp_col] == true &&\n\t\t\t\t\t\tcan_visit[tmp_row][tmp_col][row2][col2] == true){\n\n\t\t\t\t\tif((tmp_row == row1 && tmp_col == col1+1) || (tmp_row == row1+1 && tmp_col == col1)){\n\n\t\t\t\t\t\tret = max(ret,recursive(tmp_row,tmp_col,row2,col2)+1);\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true){\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row-1,tmp_col) == true && can_visit[row1][col1+1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row,tmp_col-1) == true && can_visit[row1][col1+1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true){\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row-1,tmp_col) == true && can_visit[row1+1][col1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row,tmp_col-1) == true && can_visit[row1+1][col1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[row1][col1][row2][col2] = ret;\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t}\n\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tdp[a][b][c][d] = -1;\n\t\t\t\t\tcan_visit[a][b][c][d] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tint adj_row,adj_col;\n\n\tfor(int start_row = 0; start_row < H; start_row++){\n\t\tfor(int start_col = 0; start_col < W; start_col++){\n\t\t\tif(table[start_row][start_col] == '#')continue;\n\n\t\t\tcan_visit[start_row][start_col][start_row][start_col] = true;\n\t\t\tQ.push(Info(start_row,start_col));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '#' || can_visit[start_row][start_col][adj_row][adj_col] == true)continue;\n\n\t\t\t\t\tcan_visit[start_row][start_col][adj_row][adj_col] = true;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col));\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tif(can_visit[0][0][H-1][W-1] == false){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,0,H-1,W-1));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x,bool dr){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      if(!(y1==sy&&x1==sx)&&!(gy==y2&&gx==x2)){\n\tif(check(y1,x1,sy,sx)&&check(gy,gx,y2,x2)){\n\t  dfs(i,y2,x2,1);\n\t  res1=max(res1,dp[i][y2][x2]);\n\t}\n      }\n    }\n\n    if(dr&&gy==y&&gx==x) continue;\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      if(!(y2==sy&&x2==sx)){\n\tif(check(y2,x2,sy,sx)&&check(gy,gx,y,x)){\n\t  dfs(i,y,x,0);\n\t  res2=max(res2,dp[i][y][x]);\n\t}\n      }\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++){\n\n      if(!check(0,0,rec[i].first.first,rec[i].first.second)) continue;\n      if(!check(rec[i].second.first,rec[i].second.second,h-1,w-1)) continue;\n      \n      dfs(i,h-1,w-1,0);\n    }\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n    \n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n\nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n\tif(x1>x2||y1>y2)return -1000;\n\tif(v[x1][y1]=='#'||v[x2][y2]=='#')return -1000;\n\tif(dp[x1][y1][x2][y2]!=-10000){\n\t\treturn dp[x1][y1][x2][y2];\n\t}\n\tif(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n\tif(x2-x1==1&&y2-y1==0){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tif(x2-x1==0&&y2-y1==1){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tint tmp = -100;\n\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n\t}\n\ttmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n\tif(tmp>=0){\n\t\treturn dp[x1][y1][x2][y2] = tmp;\n\t}\n\treturn dp[x1][y1][x2][y2] = -1000;\n}\n\nint saiki2(int x1,int y1,int x2,int y2){\n\tif(x1>x2||y1>y2)return -1000;\n\tif(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n\tif(dp2[x1][y1][x2][y2]!=-10000)return dp2[x1][y1][x2][y2];\n\tint mx = dp[x1][y1][x2][y2];\n\tfor(int i=x1;i<=x2;i++){\n\t\tfor(int j=y1;j<=y2;j++){\n\t\t\tif(i==x1&&j==y1)continue;\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i+1,j,x2,y2));\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i,j+1,x2,y2));\n\t\t}\n\t}\n\treturn dp2[x1][y1][x2][y2] = mx;\n\n}\n\nint main() {\n   \twhile(cin >> h >> w && h!=0){\n   \t\tvector<string> v(h);\n   \t\trep(i,h){\n   \t\t\tcin >> v[i];\n   \t\t}\n\t\trep(i,51){\n\t\t\trep(j,51){\n\t\t\t\trep(k,51){\n\t\t\t\t\trep(l,51){\n\t\t\t\t\t\tdp[i][j][k][l] = -10000;\n\t\t\t\t\t\tdp2[i][j][k][l] = -10000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}   \t\t\n\t\tint ans = saiki(0,0,h-1,w-1,v);\n\t\tans = saiki2(0,0,h-1,w-1);\n\t\tif(ans>=0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n   \t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[30];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nll H,W;\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(ret != -1) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n                    int ny1 = y1 + dy[i], nx1 = x1 + dx[i];\n                    if (ny1 > y2 || nx1 > x2) continue;\n                    int bny = ny - dy[j], bnx = nx - dx[j];\n                    if (bny < y1 || bnx < x1) continue;\n                    if (!can[ny1][nx1][bny][bnx]) continue;\n                    ret = max(ret, 1 + dfs(ny1, nx1, bny, bnx,maze) + dfs(ny, nx, y2, x2,maze));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 30;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            char c; cin >> c;\n            maze[i][j] = c;\n            if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n        }\n    }\n    memset(can,false,sizeof(can));\n//    fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i >= 1; i--){\n        for(ll j = W; j >= 1; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    //cout << maze << endl;\n    //fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    memset(dp,-1,sizeof(dp));\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> H >> W,H|W){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nint ikeru[52][52][52][52]; \nint dp[52][52][52][52];\nint h,w;\nchar v[52][52];\n// void reach(int a,int b,int c,int d){\n//     if(ikeru[a][b][c][d]!=-1)return;\n//     if(v[a][b]=='#'||v[c][d]=='#'){\n//         ikeru[a][b][c][d] = 0;\n//         return;\n//     }\n//     if(a>c||b>d){\n//         ikeru[a][b][c][d] = 0;\n//         return;\n//     }\n//     if(a==c&&b==d){\n//         ikeru[a][b][c][d] = 1;\n//         return;\n//     }\n//     if(a==c&&d==b+1){\n//         ikeru[a][b][c][d] = 1;\n//         return;\n//     }\n//     if(c==a+1&&b==d){\n//         ikeru[a][b][c][d] = 1;\n//         return;\n//     }\n//     for(int i=a;i<=c;i++){\n//         for(int j=b;j<=d;j++){\n//             if(i==a&&j==b){\n//                 ikeru[a][b][i][j]=1;\n//                 continue;\n//             }\n//             if(i==c&&j==d){\n//                 ikeru[i][j][c][d]=1;\n//                 continue;\n//             }\n//             reach(a,b,i,j);\n//             reach(i,j,c,d);\n//             if(ikeru[a][b][i][j]==1&&ikeru[i][j][c][d]==1){\n//                 ikeru[a][b][c][d] = 1;\n//             }\n//         }\n//     }\n//     return;\n// }\n\nint saiki(int a,int b,int c,int d){\n    if(dp[a][b][c][d]!=-100000){\n        return dp[a][b][c][d];\n    }\n    // if(ikeru[a][b][c][d]!=1){\n    //     return dp[a][b][c][d]=-1000000;\n    // }\n    if(v[a][b]=='#'||v[c][d]=='#'){\n        return dp[a][b][c][d] = -1000000;\n    }\n    if(a==c&&b==d){\n        return dp[a][b][c][d] = 0;\n    }\n    if(a==c&&d==b+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    if(b==d&&c==a+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    int ans = -222222;\n    if(v[a][b] + 'A'-'a' ==v[c][d]){\n        if(a+1<=c-1)ans = max(ans,1+saiki(a+1,b,c-1,d));\n        if(a+1<=c&&b<=d-1)ans = max(ans,1+saiki(a+1,b,c,d-1));\n        if(a<=c-1&&b+1<=d)ans = max(ans,1+saiki(a,b+1,c-1,d));\n        if(b+1<=d-1)ans = max(ans,1+saiki(a,b+1,c,d-1));        \n    }\n    for(int i=a;i<=c;i++){\n        for(int j=b;j<=d;j++){\n            if(i==c&&j==d)continue;\n            if(i!=c)ans = max(ans,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n            if(j!=d)ans = max(ans,saiki(a,b,i,j)+saiki(i,j+1,c,d));            \n        }\n    }\n    return dp[a][b][c][d]=ans;\n}\n\nint main() {\n    while(cin >> h >> w && h!=0){\n        rep(i,h){\n            string s;\n            cin >> s;\n            rep(j,s.size()){\n                v[i][j] = s[j];\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                rep(k,h){\n                    rep(l,w){\n                        dp[i][j][k][l] = -100000;\n                        ikeru[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        // rep(i,h){\n        //     rep(j,w){\n        //         rep(k,h){\n        //             rep(l,w){\n        //                 reach(i,j,k,l);\n        //             }\n        //         }\n        //     }\n        // }\n        //reach(0,0,h-1,w-1);\n        // if(ikeru[0][0][h-1][w-1]!=1){\n        //     cout << -1 << endl;\n        // }else{\n            int ans = saiki(0,0,h-1,w-1);\n            if(ans<0)cout << -1 << endl;\n            else cout << ans << endl;\n        // }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nbool used[60][60];\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = (int)mp.size();\n  }\n  int V = mp.size();\n  G.resize(V);\n  ws.resize(V);\n\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nbool hasEdge[MAX_V][MAX_V];\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\n  topologicalSort(G,order);\n\n  // DP\n  int V = G.size();\n\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  //assert( V < MAX_V );\n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[105][N][N];\nbool used[105][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      dfs(i,y2,x2);\n      res1=max(res1,dp[i][y2][x2]);\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      dfs(i,y,x);\n      res2=max(res2,dp[i][y][x]);\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++) dfs(i,h-1,w-1);\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return 0;\n  if(ly==ry&&lx==rx+1)return 0;\n  if(ly==ry+1&&lx==rx)return 0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    dfs(0,0,h-1,w-1);\n    cout<<(dp[0][0][h-1][w-1]<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <complex>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef vector<string> vst;\ntypedef pair<int,int> pint;\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(s) (s).begin(),(s).end()\n#define each(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define debug(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\",\"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> pair<T1,T2> operator+(pair<T1,T2> P, pair<T1,T2> Q) {return make_pair(P.first+Q.first,P.second+Q.second);}\ntemplate<class T1, class T2> pair<T1,T2> operator-(pair<T1,T2> P, pair<T1,T2> Q) {return make_pair(P.first-Q.first,P.second-Q.second);}\ntemplate<class T> pair<T,T> operator*(pair<T,T> P, int a) {return make_pair(P.first*a,P.second*a);}\ntemplate<class T> pair<T,T> operator*(pair<T,T> P, pair<T,T> Q) {return make_pair(P.first*Q.first-P.second*Q.second,P.first*Q.second+P.second*Q.first);}\n\n\n\n\npint dr[2] = {mp(1,0), mp(0,1)};\nint H,W;\nvst str;\n\nvector<vector<pint> > hset;\nbool reach[52][52][52][52];\nint dp[52][52][52][52];\n\nint solve() {\n    hset.clear();\n    hset.resize(26);\n    memset(reach, 0, sizeof(reach));\n    for (int i = 0; i < str.size(); ++i) {\n        for (int j = 0; j < str[0].size(); ++j) {\n            if (str[i][j] == '#') continue;\n            if (str[i][j] >= 'A' && str[i][j] <= 'Z') hset[(int)(str[i][j]-'A')].pb(mp(i,j));\n            reach[i][j][i][j] = true;\n            queue<pint> que;\n            que.push(mp(i,j));\n            while (!que.empty()) {\n                pint p = que.front();\n                que.pop();\n                for (int o = 0; o < 2; ++o) {\n                    pint np = p + dr[o];\n                    if (np.fi >= 0 && np.fi < str.size() && np.se >= 0 && np.se < str[0].size()) {\n                        if (!reach[i][j][np.fi][np.se] && str[np.fi][np.se] != '#') {\n                            reach[i][j][np.fi][np.se] = true;\n                            que.push(np);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (!reach[0][0][str.size()-1][str[0].size()-1]) return -1;\n    \n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= str.size(); ++i) {\n        for (int j = 1; j <= str[0].size(); ++j) {\n            for (int k = 0; k+i <= str.size(); ++k) {\n                for (int l = 0; l+j <= str[0].size(); ++l) {\n                    if (!reach[k][l][k+i-1][l+j-1]) continue;\n                    int temp = 0;\n                    \n                    if (reach[k+1][l][k+i-1][l+j-1]) temp = max(temp, dp[k+1][l][k+i][l+j]);\n                    if (reach[k][l+1][k+i-1][l+j-1]) temp = max(temp, dp[k][l+1][k+i][l+j]);\n                    \n                    if (str[k][l] >= 'a' && str[k][l] <= 'z') {\n                        for (int x = 0; x < hset[(int)(str[k][l]-'a')].size(); ++x) {\n                            int p = hset[(int)(str[k][l]-'a')][x].fi;\n                            int q = hset[(int)(str[k][l]-'a')][x].se;\n                            \n                            if (p >= k && p < k+i && q >= l && q < l+j && reach[k][l][p][q] && reach[p][q][k+i-1][l+j-1]) {\n                                int temp1 = 0, temp2 = 0;\n                                \n                                temp1 = max(temp1, dp[k+1][l][p+1][q]+1);\n                                temp1 = max(temp1, dp[k+1][l][p][q+1]+1);\n                                temp1 = max(temp1, dp[k][l+1][p+1][q]+1);\n                                temp1 = max(temp1, dp[k][l+1][p][q+1]+1);\n                            \n                                temp2 = max(temp2, dp[p][q][k+i][l+j]);\n                                \n                                temp = max(temp, temp1+temp2);\n                            }\n                        }\n                    }\n                    \n                    //if (temp > 1) cout << k << \", \" << l << \", \" << k+i-1 << \", \" << l+j-1 << \" : \" << temp << endl;\n                    \n                    dp[k][l][k+i][l+j] = temp;\n                }\n            }\n        }\n    }\n   \n    return dp[0][0][str.size()][str[0].size()];                            \n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/JAG Practice Asia 2012 E - Stack Maze.in\", \"r\", stdin );\n    \n    while (cin >> H >> W) {\n        if (H == 0 && W == 0) break;\n        str.clear();\n        for (int i = 0; i < H; ++i) {\n            string s;\n            cin >> s;\n            str.pb(s);\n        }\n        cout << solve() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[26];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(ret != -1) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for(int i = 0; i < 2;i++){\n                    for(int j = 0; j < 2;j++){\n                        ll innery1 = y1+dy[i], innerx1 = x1+dx[i];\n                        ll innery2 = ny - dy[j], innerx2 = nx - dx[j];\n                        if(innery1 > y2 || innerx1 > x2 || innery2 < y1 || innerx2 < x1 ) continue;\n                        if(!can[innery1][innerx1][innery2][innerx2]) continue;\n                        ret = max(ret,dfs(innery1,innerx1,innery2,innerx2,maze) + dfs(ny,nx,y2,x2,maze) + 1);\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(ll H,ll W){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 26;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++) for(int j = 1; j <= W;j++){\n        char c; cin >> c;\n        maze[i][j] = c;\n        if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n    }\n     fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i >= 1; i--){\n        for(ll j = W; j >= 1; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    cout << maze << endl;\n    fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll H,W;\n    while(cin >> H >> W,H|W){\n        cout << solve(H,W) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 52\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nV v[50][50];\nvoid visit(int x,int y){\n  V &D = v[y][x] = V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  V &D = v[y][x];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  V &D = v[0][0];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if((a.first==b.first||a.second == b.second)||\n     (x1>=0&&y1>=0&&!v[y1][x1][y2][x2])||\n     (!v[Y2][X2][h-1][w-1])||\n     (X1<w&&X2<h&&!v[Y2][X2][Y1][X1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n\n    visit(0,0);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)if(isalpha(mp[i][j]))visit(j,i);\n    \n    mkA();\n    if(!v[0][0][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <fstream>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar a[50][50];\nint dp[52][52][52][52];\n\nint func(int i1, int j1, int i2, int j2) {\n  int res = -1;\n  if (i2) chmax(res, dp[i1+1][j1][i2-1][j2]);\n  if (j2) chmax(res, dp[i1+1][j1][i2][j2-1]);\n  if (i2) chmax(res, dp[i1][j1+1][i2-1][j2]);\n  if (j2) chmax(res, dp[i1][j1+1][i2][j2-1]);\n  if (res == -1) return -INF;\n  return res;\n}\nint func2(int i1, int j1, int i2, int j2) {\n  // if (i1==i2&&j1==j2) return 0;\n  int res = -1;\n  chmax(res, dp[i1+1][j1][i2][j2]);\n  chmax(res, dp[i1][j1+1][i2][j2]);\n  if (res == -1) return -INF;\n  return res;\n}\n\nint main() {\n  int h,w;\n  while(cin >> h >> w, h||w) {\n    vector<pii> v[26];\n    REP(i,h)REP(j,w) {\n      cin>>a[i][j];\n      if (isupper(a[i][j])) {\n        v[a[i][j]-'A'].push_back(pii(i,j));\n      }\n    }\n    memset(dp,-1,sizeof(dp));\n    REP(i,h)REP(j,w) dp[i][j][i][j] = (a[i][j]=='#'?-1:0);\n    REP(i1,h+1)REP(j1,w+1)REP(i2,h+1)REP(j2,w+1) if (i2<i1&&j2==j1||j2<j1&&i1==i2) dp[i1][j1][i2][j2] = 0;\n    \n    for (int hh=1;hh<=h; ++hh) {\n      for (int ww=1;ww<=w; ++ww) {\n        if (hh==1&&ww==1) continue;\n        for (int i1=0; i1<h-hh+1; ++i1) {\n          for (int j1=0; j1<w-ww+1; ++j1) {\n            if (a[i1][j1] == '#') continue;\n            int i2 = i1+hh-1;\n            int j2 = j1+ww-1;\n            if (islower(a[i1][j1])) {\n              FOR(it, v[a[i1][j1]-'a']) {\n                int i3 = it->first;\n                int j3 = it->second;\n                if (i3<i1||i2<i3||j3<j1||j2<j3) continue;\n                chmax(dp[i1][j1][i2][j2], func(i1,j1,i3,j3) + func2(i3,j3,i2,j2) + 1);\n              }\n            }\n            if (i1+1<=i2) chmax(dp[i1][j1][i2][j2], dp[i1+1][j1][i2][j2]);\n            if (j1+1<=j2) chmax(dp[i1][j1][i2][j2], dp[i1][j1+1][i2][j2]);\n            // if (dp[i1][j1][i2][j2] >= 0) {\n            //   cout << i1 << \" \" << j1 << \" \" << i2 << \" \" << j2 << \" : \" << dp[i1][j1][i2][j2] << endl;\n            // }\n          }\n        }\n      }\n    }\n    if (dp[0][0][h-1][w-1] == 20) {\n      REP(i,h) {\n        REP(j,w) cout << a[i][j];\n        cout << endl;\n      }\n    }\n    cout << dp[0][0][h-1][w-1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\nstring s[50];\nint ka[50][50][50][50];\nint ans[50][50][50][50];\nvector<pa> ve[26];\n\nint h,w;\nint dfs(int i,int j,int x,int y){\n//\tcout<<i<<\" \"<<j<<\" \"<<x<<\" \"<<y<<endl;\n\tif(i>x || j>y) return -1;\n\tif(i<0 || i>=h) return-1;\n\tif(j<0 || j>=w) return -1;\n\tif(!ka[i][j][x][y])return -1;\n\tif(ans[i][j][x][y]>=0) return ans[i][j][x][y];\n\tif(i==x && j==y ){\n\t\tans[i][j][x][y]=0;\n\t\treturn 0;\n\t}\n\tif(s[i][j]=='.' || (s[i][j]>='A' && s[i][j]<='Z')){\n\t\tint r=-1;\n\t\tr=max(r,dfs(i+1,j,x,y));\n\t\tr=max(r,dfs(i,j+1,x,y));\n\t\tans[i][j][x][y]=r;\n\t\treturn r;\n\t}\n\t{\n\t\tassert(s[i][j]>='a' && s[i][j]<='z');\n\t//\tcout<<s[i][j]<<endl;\n\t\tint r=-1;\n\t\tr=max(r,dfs(i+1,j,x,y));\n\t\tr=max(r,dfs(i,j+1,x,y));\n\t\tint c=s[i][j]-'a';\n\t\tfor(auto v:ve[c]){\n\t\t\tif(i<=v.first && v.first<=x && j<=v.second && v.second<=y){\n\t\t//\t\tcout<<\"  \"<<v.first<<\" \"<<v.second<<endl;\n\t\t\t\tif(v.first==x && v.second==y && abs(x-i)+abs(y-j)==1){\n\t\t\t\t\tr=1;\n\t\t\t\t}\n\t\t\t\telse if(v.first==x && v.second==y){\n\t\t\t\t\tint f1=-1;\n\t\t\t\t\tf1=max(f1,dfs(i+1,j,v.first-1,v.second));\n\t\t\t\t\tf1=max(f1,dfs(i+1,j,v.first,v.second-1));\n\t\t\t\t\tf1=max(f1,dfs(i,j+1,v.first-1,v.second));\n\t\t\t\t\tf1=max(f1,dfs(i,j+1,v.first,v.second-1));\n\t\t\t\t\tif(f1>=0) r=max(r,f1+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ka[i][j][v.first][v.second]){\n\t\t\t\t\t\tint f1,f2,f3;\n\t\t\t\t\t\tf1=dfs(i,j,v.first,v.second);\n\t\t\t\t\t\tif(f1<0) continue;\n\t\t\t\t\t\tf2=dfs(v.first+1,v.second,x,y);\n\t\t\t\t\t\tf3=dfs(v.first,v.second+1,x,y);\n\t\t\t\t\t\tf2=max(f2,f3);\n\t\t\t\t\t\tif(f2<0) continue;\n\t\t\t\t\t\tr=max(r,f1+f2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[i][j][x][y]=r;\n\t\treturn r;\n\t}\n}\n\nint solve(){\n\n\tcin>>h>>w;\n\t\n\tif(h==0 && w==0) exit(0);\n\tfor(int i=0;i<26;i++)ve[i].clear();\n\tfor(int i=0;i<50;i++)s[i]=\"\";\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tfor(int i=0;i<50;i++)for(int j=0;j<50;j++)for(int k=0;k<50;k++)for(int l=0;l<50;l++){\n\t\tka[i][j][k][l]=0;\n\t\tans[i][j][k][l]=-1;\n\t}\n\t\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\tif(s[i][j]!='#' && s[i][j]!='.'){\n\t\t\t\tif(s[i][j]<='Z')ve[s[i][j]-'A'].pb({i,j});\n\t\t}\n\t\tif(s[i][j]=='#')continue;\n\t\tka[i][j][i][j]=1;\n\t\tfor(int x=i;x<h;x++)for(int y=j;y<w;y++)if(s[x][y]!='#'){\n\t\t\tif(x==i && y==j) continue;\n\t\t\tif(x!=i){\n\t\t\t\tif(ka[i][j][x-1][y])ka[i][j][x][y]=1;\n\t\t\t}\n\t\t\tif(y!=j){\n\t\t\t\tif(ka[i][j][x][y-1])ka[i][j][x][y]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(!ka[0][0][h-1][w-1])return -1;\n\tdfs(0,0,h-1,w-1);\n\t//for(int i=0;i<w;i++)for(int j=i;j<=w;j++)cout<<i<<\" \"<<j<<\" \"<<ans[0][i][0][j]<<endl;\n\treturn dfs(0,0,h-1,w-1);\n\n}\n\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \twhile(1){\n \t\tcout<<solve()<<endl;\n \t}\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint h, w;\nchar mp[51][51];\n\nbool visted[51][51][51][51];\nint ans[51][51][51][51];\n\nbool ismalf(char t) {\n\tif ('a' <= t && t <= 'z')return true;\n\treturn false;\n}\nbool isMalf(char t) {\n\tif ('A' <= t && t <= 'Z')return true;\n\treturn false;\n}\nbool corres(char s, char t) {\n\tif (ismalf(s) && isMalf(t)) {\n\t\tint l = s - 'a', r = t - 'A';\n\t\treturn l == r;\n\t}\n\treturn false;\n}\n\n\n\nint dx[2] = { 1,0 };\nint dy[2] = { 0,1 };\n\nvector<P> alf[26];\nvector<P> Alf[26];\n\nint dfs(int x, int y, int z, int u) {\n\tif (x < 0 || y < 0 || x >= h || y >= w || z < 0 || z >= h || u < 0 || u >= w)return -mod;\n\tif (x == z && y == u) {\n\t\tif (mp[x][y] == '#')return -mod;\n\t\telse return 0;\n\t}\n\tif (z < x || u < y)return -mod;\n\tif (mp[x][y] == '#' || mp[z][u] == '#')return -mod;\n\tif (visted[x][y][z][u])return ans[x][y][z][u];\n\tvisted[x][y][z][u] = true;\n\t//cout << x << \" \" << z << endl;\n\tchar le = mp[x][y], ri = mp[z][u];\n\tif (z - x + u - y == 1) {\n\t\tif (corres(le, ri)) {\n\t\t\treturn ans[x][y][z][u] = 1;\n\t\t}\n\t\telse {\n\t\t\treturn ans[x][y][z][u] = 0;\n\t\t}\n\t}\n\tint ret = -mod;\n\tif (corres(le, ri)) {\n\t\t//cout << le << \" \" << ri << endl;\n\t\trep(i, 2) {\n\t\t\trep(j, 2) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tint nz = z - dx[j], nu = u - dy[j];\n\t\t\t\tret = max(ret, dfs(nx, ny, nz, nu));\n\t\t\t}\n\t\t}\n\t\tret++;\n\t}\n\trep(i, 2) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tret = max(ret, dfs(nx, ny, z, u));\n\t}\n\tif (ismalf(le)) {\n\t\tint t = le - 'a';\n\t\trep(i, Alf[t].size()) {\n\t\t\tint mx = Alf[t][i].first, my = Alf[t][i].second;\n\t\t\tif (mx<x || mx>z || my<y || my>u)continue;\n\t\t\trep(k, 2) {\n\t\t\t\tint l = dfs(x, y, mx, my);\n\t\t\t\tint r = dfs(mx + dx[k], my + dy[k], z, u);\n\t\t\t\tret = max(ret, l + r);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans[x][y][z][u] = ret;\n\n}\n\nvoid solve() {\n\trep(i, 26) {\n\t\talf[i].clear();\n\t}\n\trep(i, 26) {\n\t\tAlf[i].clear();\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t\tchar t = mp[i][j];\n\t\t\tif (ismalf(t)) {\n\t\t\t\talf[(int)(t - 'a')].push_back({ i,j });\n\t\t\t}\n\t\t\telse if (isMalf(t)) {\n\t\t\t\tAlf[(int)(t - 'A')].push_back({ i,j });\n\t\t\t}\n\t\t\trep(k, h) {\n\t\t\t\trep(l, w) {\n\t\t\t\t\tans[i][j][k][l] = 0;\n\t\t\t\t\tvisted[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint out = dfs(0, 0, h - 1, w - 1);\n\tif (out < 0)out = -1;\n\tcout << out << endl;\n}\n\nvoid generate() {\n\tcout << \"50 50\" << endl;\n\trep(i, 50) {\n\t\trep(j, 50) {\n\t\t\tchar z = '.';\n\t\t\tif (i % 10 == 0) {\n\t\t\t\tz = 'A' + ((i + j) % 26);\n\t\t\t}\n\t\t\telse if (i % 10 == 1) {\n\t\t\t\tz = 'a' + ((i + j) % 26);\n\t\t\t}\n\t\t\tcout << z;\n\t\t}\n\t\tcout << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//generate();\n\twhile (cin >> h >> w, h) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1000000000;\nint h,w;\n\nint func(const vector<pair<int,int>>& v, int f, int t,\n    const vector<vector<int>>& d,\n    vector<vector<int>>& memo, bool fst = false) {\n  if (memo[f][t] >= 0) return memo[f][t];\n  int mxn = 0;\n  for(auto p:v) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    if (d[f][fp] < INF && d[tp][t] < INF) {\n      if ((f == fp || t == tp) && !fst) continue;\n      mxn = max(mxn, func(v, fp, tp, d, memo) + func(v, tp, t, d, memo) + 1);\n    }\n  }\n  return memo[f][t] = mxn;\n}\n\n\nint main() {\n  while(1){\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> m(h+1, string(w+1, '#'));\n    REP(i,h) {\n      string l;\n      cin>>l;\n      m[i] = l + \"#\";\n    }\n    int n = h*w;\n    vector<vector<int>> d(n, vector<int>(n,INF));\n    d[0][0] = 0;\n    d[n-1][n-1] = 0;\n    REP(i,h)REP(j,w) {\n      int ind = i*w+j;\n      if (m[i][j] != '#') {\n        if (m[i+1][j] != '#') d[ind][ind + w] = 1;\n        if (m[i][j+1] != '#') d[ind][ind + 1] = 1;\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int diff = 'A' - 'a';\n    vector<pair<int, int>> v;\n    REP(i,n)REP(j,n) {\n      int ii=i/w, ij=i%w;\n      int ji=j/w, jj=j%w;\n      if (d[i][j] < INF && m[ii][ij] + diff == m[ji][jj]) v.emplace_back(i,j);\n    }\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    if (d[0][n-1] < INF)\n      cout << func(v, 0, n-1, d, memo, true) << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!(move[y1][x1][ny][nx] && (y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nvoid cmax(int& lhs,int rhs){\n    lhs=max(lhs,rhs);\n}\nint e0[]={1,0};\nint e1[]={0,1};\nint solve(int h,int w){\n    Field f(h);\n    for(int i=0;i<h;i++) cin>>f[i];\n    vector<vector<int>> hs(26);\n    vector<vector<int>> ws(26);\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(isalpha(f[i][j]) && isupper(f[i][j])){\n                hs[f[i][j]-'A'].push_back(i);\n                ws[f[i][j]-'A'].push_back(j);\n            }\n        }\n    }\n    vvvvi dp(h,vvvi(w,vvi(h,vi(w,-1e9))));\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++) if(f[i][j]!='#') dp[i][j][i][j]=0;\n    auto isRange=[&](int i,int j){return 0<=i && i<h && 0<=j && j<w;};\n    for(int dh=0;dh<h;dh++){\n        for(int dw=0;dw<w;dw++){\n            for(int t=0;t<h;t++){\n                for(int l=0;l<w;l++){\n                    int b=t+dh,r=l+dw;\n                    if(!isRange(b,r)) continue;\n                    if(f[t][l]=='#' || f[b][r]=='#') continue;\n                    if(t+1<=b) cmax(dp[t][l][b][r],dp[t+1][l][b][r]);\n                    if(t<=b-1) cmax(dp[t][l][b][r],dp[t][l][b-1][r]);\n                    if(l+1<=r) cmax(dp[t][l][b][r],dp[t][l+1][b][r]);\n                    if(l<=r-1) cmax(dp[t][l][b][r],dp[t][l][b][r-1]);\n                    if(isalpha(f[t][l]) && islower(f[t][l])){\n                        for(int k=0;k<hs[f[t][l]-'a'].size();k++){\n                            int hp=hs[f[t][l]-'a'][k],wp=ws[f[t][l]-'a'][k];\n                            if(t<=hp && hp<=b && l<=wp && wp<=r){\n                                cmax(dp[t][l][b][r],dp[t][l][hp][wp]+dp[hp][wp][b][r]);\n                            }\n                        }\n                    }\n                    if(isalpha(f[t][l]) && islower(f[t][l]) && toupper(f[t][l])==f[b][r]){\n                        if(b-t+r-l==1) dp[t][l][b][r]=1;\n                        else{\n                            for(int x=0;x<2;x++){\n                                for(int y=0;y<2;y++){\n                                    int nt=t+e0[x],nl=l+e1[x];\n                                    int nb=b-e0[y],nr=r-e1[y];\n                                    if(nt<=nb && nl<=nr) cmax(dp[t][l][b][r],dp[nt][nl][nb][nr]+1);\n                                }\n                            }\n                        }\n                    }\n                    // cerr<<\"#\"<<t<<\" \"<<l<<\" \"<<b<<\" \"<<r<<endl;\n                    // cerr<<dp[t][l][b][r]<<endl;\n                }\n            }\n        }\n    }\n    \n    return dp[0][0][h-1][w-1];\n}\nint main(){\n    int h,w;\n    while(cin>>h>>w,h){\n        int ret=solve(h,w);\n        cout<<(ret<0 ? -1 : ret)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,C;\nchar s[100],a[100];\nchar t[100][100];\nint id[100][100];\nint INF=1e8;\nmap<int,int> dp[100][100];\nint ans;\n\nint dfs(int y,int x,int bit){\n\n  if(y<0||x<0||y>=H||x>=W)return -INF;\n\n  if(t[y][x]=='#')return -INF;\n\n  int res=0;\n  if('a'<=t[y][x]&&t[y][x]<='z'){\n    bit|=(1<<id[y][x]);\n  }\n  \n  if(dp[y][x].count(bit)){\n    return dp[y][x][bit];\n  }\n  \n  int flg=0;\n  int nbit=bit;\n  if('A'<=t[y][x]&&t[y][x]<='Z'){\n    for(int i=C-1;i>=0;i--){\n      if( (nbit>>i&1) && a[i]==t[y][x] ){\n        flg=1;\n        break;\n      }else{\n        nbit|=(1<<i);\n        nbit-=(1<<i);\n      }\n    }\n  }\n  \n  if(y==H-1&&x==W-1){\n    ans=1;\n    return flg;\n  }\n\n\n  res=max(res,dfs(y+1,x,bit));\n  res=max(res,dfs(y,x+1,bit));\n  res=max(res,dfs(y+1,x,nbit)+flg);\n  res=max(res,dfs(y,x+1,nbit)+flg);\n  return dp[y][x][bit]=max(res,flg);\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        dp[i][j].clear();\n    \n    C=0;\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",s);\n      for(int j=0;j<W;j++){\n        t[i][j]=s[j];\n        if('a'<=t[i][j]&&t[i][j]<='z'){\n          a[C]=t[i][j]-'a'+'A';\n          id[i][j]=C++;\n        }\n      }\n    }\n    if(C>10)continue;\n    \n    ans=0;\n    if(ans){\n      cout<<dfs(0,0,0)<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 60;\n\nstruct Po\n{\n    int x,y;\n    Po(int x,int y) : x(x) ,y(y){};\n    Po(){};\n    bool operator >= (const Po &b) const{\n        return x>=b.x&&y>=b.y;\n    }\n    bool operator == (const Po &b) const{\n        return x==b.x&&y==b.y;\n    }\n    void print()\n    {\n        printf(\"(%d,%d)\",x,y);\n    }\n};\n\nchar mp[maxn][maxn];\nint id[maxn][maxn];\nint W,H;\n\nvector<Po>a[maxn],A[maxn];\n\nint down_a[maxn][maxn][maxn][maxn];\nint up_A[maxn][maxn][maxn][maxn];\n\nint dp[maxn][maxn][maxn][maxn];\nint vis[maxn][maxn][maxn][maxn];\n\nint dx[4] = { 0,1 };\nint dy[4] = { 1,0 };\n\nint TIME;\n\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if( x1 == x2 && y1 == y2 ) return 0;\n\n    if( x1>x2 || y1>y2 ) return -1;\n\n    int &t = dp[x1][y1][x2][y2];\n\n    if( vis[x1][y1][x2][y2] ) return t;\n\n    vis[x1][y1][x2][y2] = 1;\n\n\n    if( mp[x1][y1] == '#' || mp[x2][y2] == '#' ) return t=-1;\n\n    t = max( dfs(x1+1,y1,x2,y2) , dfs(x1,y1+1,x2,y2) );\n\n    for(int c=0;c<26;c++)\n    {\n        for( int i=0;i<a[c].size();i++ ) if( down_a[x1][y1][c][i] )\n            for( int j=0;j<A[c].size();j++ ) if( up_A[x2][y2][c][j] )\n            {\n                if( a[c][i] >= Po(x1,y1) && A[c][j] >= a[c][i] && Po(x2,y2) >= A[c][j] ) ;\n                else continue;\n                int t1=-1,t2=-1,t3=-1;\n\n                if( a[c][i] == Po(x1,y1) ) t1 = 0;\n                if( A[c][j] == Po(x2,y2) ) t3 = 0;\n\n                for( int k=0;k<2;k++ )\n                {\n                    t1 = max( t1 , dfs( x1,y1,a[c][i].x-dx[k],a[c][i].y-dy[k] ) );\n                    t3 = max( t3 , dfs( A[c][j].x+dx[k],A[c][j].y+dy[k],x2,y2 ) );\n                }\n                for(int k1=0;k1<2;k1++)\n                    for(int k2=0;k2<2;k2++)\n                    {\n                        t2 = max( t2 , dfs( a[c][i].x+dx[k1],a[c][i].y+dy[k1],\n                                            A[c][j].x-dx[k2],A[c][j].y-dy[k2] ) );\n                        if( Po(a[c][i].x+dx[k1],a[c][i].y+dy[k1]) == A[c][j] ) t2 = 0;\n                    }\n                if( t1>=0&&t2>=0&&t3>=0 )\n                    t = max( t , t1+t2+t3+1 );\n            }\n    }\n\n    return t;\n}\n\nvoid bfs()\n{\n    clr(down_a,0);\n    clr(up_A,0);\n    for(int i=1 ; i<=W ; i++)\n        for(int j=1 ; j<=H ; j++)\n        {\n            if( mp[i][j] == '#' ) continue;\n            for(int c=0;c<26;c++)\n                for(int k=0;k<A[c].size();k++)\n                {\n                    up_A[i][j][c][k] =\n                        up_A[i-1][j][c][k] | up_A[i][j-1][c][k];\n                }\n            if( mp[i][j] >= 'A' && mp[i][j] <= 'Z' )\n            {\n                up_A[i][j][ mp[i][j]-'A' ][ id[i][j] ] = 1;\n            }\n        }\n    for(int i=W ; i>=1 ; i--)\n        for(int j=H ; j>=1 ; j--)\n        {\n            if( mp[i][j] == '#' ) continue;\n            for(int c=0;c<26;c++)\n                for(int k=0;k<a[c].size();k++)\n                {\n                    down_a[i][j][c][k] =\n                        down_a[i+1][j][c][k] | down_a[i][j+1][c][k];\n                }\n            if( mp[i][j] >= 'a' && mp[i][j] <= 'z' )\n            {\n                down_a[i][j][ mp[i][j]-'a' ][ id[i][j] ] = 1;\n            }\n        }\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while( ~scanf(\"%d%d\",&W,&H) )\n    {\n        if(W==0&&H==0) break;\n        clr( id , 0 );\n        for(int i=0;i<30;i++)\n        {\n            a[i].clear();\n            A[i].clear();\n        }\n        char c;\n        for(int i=1;i<=W;i++)\n            for(int j=1;j<=H;j++)\n            {\n\n                scanf(\" %c\",&c);\n                mp[i][j] = c;\n                if( c>='a' && c<='z' )\n                {\n                    a[ c-'a' ].push_back( Po(i,j) );\n                    id[i][j] = a[ c-'a' ].size()-1;\n                }\n                if( c>='A' && c<='Z' )\n                {\n                    A[ c-'A' ].push_back( Po(i,j) );\n                    id[i][j] = A[ c-'A' ].size()-1;\n                }\n            }\n\n        bfs();\n\n        TIME = 0 ;\n        clr(vis,0);\n        int ans = dfs(1,1,W,H);\n        //debug(TIME);\n\n        if(ans>=0) printf(\"%d\\n\",ans);\n        else printf(\"-1\\n\",ans);\n    }\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\nint main()\n{\n    auto lower = [](const char c) -> bool { return c >= 'a' and c <= 'z'; };\n    auto toLower = [](const char c) -> char { return (char)(c - 'A' + 'a'); };\n    while (true) {\n        int H, W;\n        cin >> H >> W;\n        if (H == 0 and W == 0) { break; }\n        vector<vector<char>> C(H, vector<char>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) { cin >> C[i][j]; }\n        }\n        using P = pair<string, pair<int, int>>;\n        map<P, int> memo;\n        constexpr int INF = 1 << 30;\n        auto rec = fix([&](auto&& self, const P& p) -> int {\n            string s = p.first;\n            const int y = p.second.first, x = p.second.second;\n            if ((y == H and x == W - 1) or (y == H - 1 and x == W)) { return 0; }\n            if (y < 0 or y >= H or x < 0 or x >= W or C[y][x] == '#') { return -INF; }\n            if (memo.find(p) != memo.end()) { return memo[p]; }\n            if (C[y][x] == '.') {\n                return memo[p] = max(self(self, {s, {y + 1, x}}), self(self, {s, {y, x + 1}}));\n            } else {\n                if (lower(C[y][x])) {\n                    s.push_back(C[y][x]);\n                    return memo[p] = max(self(self, {s, {y + 1, x}}), self(self, {s, {y, x + 1}}));\n                } else {\n                    const char low = toLower(C[y][x]);\n                    if (s.back() == low) {\n                        s.pop_back();\n                        return memo[p] = 1 + max(self(self, {s, {y + 1, x}}), self(self, {s, {y, x + 1}}));\n                    }\n                    int ans = max(self(self, {s, {y + 1, x}}), self(self, {s, {y, x + 1}}));\n                    for (; not s.empty() and s.back() != low; s.pop_back()) {}\n                    if (s.empty()) {\n                        return memo[p] = ans;\n                    } else {\n                        s.pop_back();\n                        return memo[p] = max(ans, 1 + max(self(self, {s, {y + 1, x}}), self(self, {s, {y, x + 1}})));\n                    }\n                }\n            }\n        });\n        const P start = {\"\", {0, 0}};\n        const int ans = rec(start);\n        cout << max(-1, ans) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            if (R[sy][sx][ny][nx]) continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return -INF;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return -INF;\n        if (not R[sy][sx][ty][tx]) return -INF;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n\n        if (abs(sy - ty) + abs(sx - tx) == 1) return islower(F[sy][sx]) && toupper(F[sy][sx]) == F[ty][tx];\n\n        int r = 0;\n        r = max(r, f(sy, sx + 1, ty, tx));\n        r = max(r, f(sy + 1, sx, ty, tx));\n\n        if (not islower(F[sy][sx])) {\n            return cache = r;\n        }\n\n        for (int y = sy; y <= ty; y++) {\n            for (int x = sx; x <= tx; x++) {\n                if (y == ty && x == tx) continue;\n                r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n            }\n        }\n\n        int d = toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nmap<P,V> v;\nvoid visit(int x,int y){\n  if(v.count(P(x,y)))return;\n\n  if(x<0||y<0||x>=w||y>=h){\n    v[P(x,y)] = V(N,vector<bool>(N,1));\n    return;\n  }\n  V &D = v[P(x,y)] =V(h,vector<bool>(w,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  visit(x,y);\n  V &D = v[P(x,y)];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  v.clear();\n  visit(0,0);\n  V &D = v[P(0,0)];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if(a.first==b.first||a.second == b.second)return 0;\n  \n  visit(x1,y1),visit(X2,Y2);\n  V &A = v[P(x1,y1)],&B = v[P(X2,Y2)]; \n  if(!A[y2][x2]||(X1<w&&X2<h&&!B[Y1][X1])||!B[h-1][w-1])return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n    mkA();\n    visit(0,0);\n    if(!v[P(0,0)][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\n\nint H,W;\nint dp[50][50][50][50];\nint diff_row[2] = {0,1},diff_col[2] = {1,0};\nchar table[50][51];\nbool can_visit[50][50][50][50];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint recursive(int row1,int col1,int row2,int col2){\n\n\tif(dp[row1][col1][row2][col2] != -1)return dp[row1][col1][row2][col2];\n\n\tif(row1 == row2 && col1 == col2)return 0;\n\n\tint ret = 0;\n\n\tif(table[row1][col1] == '.' || (table[row1][col1] >= 'A' && table[row1][col1] <= 'Z')){\n\n\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t}else if(table[row1][col1] >= 'a' && table[row1][col1] <= 'z'){\n\n\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t\tfor(int tmp_row = row1; tmp_row <= row2; tmp_row++){\n\t\t\tfor(int tmp_col = col1; tmp_col <= col2; tmp_col++){\n\t\t\t\tif(table[tmp_row][tmp_col]+32 == table[row1][col1] && can_visit[row1][col1][tmp_row][tmp_col] == true &&\n\t\t\t\t\t\tcan_visit[tmp_row][tmp_col][row2][col2] == true){\n\n\t\t\t\t\tif((tmp_row == row1 && tmp_col == col1+1) || (tmp_row == row1+1 && tmp_col == col1)){\n\n\t\t\t\t\t\tret = max(ret,recursive(tmp_row,tmp_col,row2,col2)+1);\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(rangeCheck(row1,col1+1) == true && can_visit[row1][col1][row1][col1+1] == true){\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row-1,tmp_col) == true && can_visit[row1][col1+1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row,tmp_col-1) == true && can_visit[row1][col1+1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(rangeCheck(row1+1,col1) == true && can_visit[row1][col1][row1+1][col1] == true){\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row-1,tmp_col) == true && can_visit[row1+1][col1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rangeCheck(tmp_row,tmp_col-1) == true && can_visit[row1+1][col1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[row1][col1][row2][col2] = ret;\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t}\n\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\tdp[a][b][c][d] = -1;\n\t\t\t\t\tcan_visit[a][b][c][d] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tint adj_row,adj_col;\n\n\tfor(int start_row = 0; start_row < H; start_row++){\n\t\tfor(int start_col = 0; start_col < W; start_col++){\n\t\t\tif(table[start_row][start_col] == '#')continue;\n\n\t\t\tcan_visit[start_row][start_col][start_row][start_col] = true;\n\t\t\tQ.push(Info(start_row,start_col));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '#' || can_visit[start_row][start_col][adj_row][adj_col] == true)continue;\n\n\t\t\t\t\tcan_visit[start_row][start_col][adj_row][adj_col] = true;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col));\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tif(can_visit[0][0][H-1][W-1] == false){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,0,H-1,W-1));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1000000000;\nint h,w;\n\nint func(const vector<pair<int,int>>& v, int f, int t,\n    const vector<vector<int>>& d,\n    vector<vector<int>>& memo, bool fst = false) {\n  if (memo[f][t] >= 0) return memo[f][t];\n  int mxn = 0;\n  vector<pair<int,int>> nv;\n  for(auto p:v) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    if (d[f][fp] < INF && d[tp][t] < INF) {\n      if (f == fp && !fst) continue;\n      nv.push_back(p);\n    }\n  }\n  for (auto p:nv) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    mxn = max(mxn, func(nv, fp, tp, d, memo) + func(nv, tp, t, d, memo) + 1);\n  }\n  return memo[f][t] = mxn;\n}\n\n\nint main() {\n  while(1){\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> m(h+1, string(w+1, '#'));\n    REP(i,h) {\n      string l;\n      cin>>l;\n      m[i] = l + \"#\";\n    }\n    int n = h*w;\n    vector<vector<int>> d(n, vector<int>(n,INF));\n    d[0][0] = 0;\n    d[n-1][n-1] = 0;\n    REP(i,h)REP(j,w) {\n      int ind = i*w+j;\n      if (m[i][j] != '#') {\n        if (m[i+1][j] != '#') d[ind][ind + w] = 1;\n        if (m[i][j+1] != '#') d[ind][ind + 1] = 1;\n      }\n    }\n    REP(i,n)REP(j,n) {\n      int ji=j/w, jj=j%w;\n      if (ji > 0)\n        d[i][j] = min(d[i][j], d[i][j-w] + d[j-w][j]);\n      if (jj > 0)\n        d[i][j] = min(d[i][j], d[i][j-1] + d[j-1][j]);\n    }\n    int diff = 'A' - 'a';\n    vector<pair<int, int>> v;\n    REP(i,n)REP(j,n) {\n      int ii=i/w, ij=i%w;\n      int ji=j/w, jj=j%w;\n      if (m[ii][ij] < 'a' || 'z' < m[ii][ij]) continue;\n      if (d[i][j] < INF && m[ii][ij] + diff == m[ji][jj]) v.emplace_back(i,j);\n    }\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    if (d[0][n-1] < INF)\n      cout << func(v, 0, n-1, d, memo, true) << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[2][55][55][55][55];\nbool used[2][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='#') continue;\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(c&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(0,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(0,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nbool pushA(int x,int y,int f=1){\n  bool D[N][N]={};\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] |= D[i-1][j];\n      if(j)D[i][j] |= D[i][j-1];\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      if(f)A.push_back(PP(P(x,y),P(j,i)));\n    }\n  return D[h-1][w-1];\n}\n\nvoid mkA(){ //??¢?????????????????¨\n  A.clear();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(islower(mp[i][j]))pushA(j,i);\n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  \n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if(a.first==b.first)return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\n\nmap<PP,int> mem[3000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<3000;i++)mem[i].clear();\n    mkA();\n    if(!pushA(0,0,0)) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int H, W; cin >> H >> W;\n        if (H == 0) break;\n        vector<string> C(H);\n        REP(i, H) cin >> C[i];\n\n        vvi jewel(H, vi(W, -1)), hole(H, vi(W, -1));\n        REP(i, H) REP(j, W) {\n            if ('a' <= C[i][j] and C[i][j] <= 'z') {\n                jewel[i][j] = C[i][j] - 'a';\n            }\n            if ('A' <= C[i][j] and C[i][j] <= 'Z') {\n                hole[i][j] = C[i][j] - 'A';\n            }\n        }\n\n        const int HMAX = 50, WMAX = 50;\n        int dp[HMAX][WMAX][HMAX][WMAX];\n        memset(dp, -1, sizeof(dp));\n\n        function<int(int,int,int,int)> rec = [&](int i1, int j1, int i2, int j2) {\n\n            // out of range\n            if (i1 < 0 or j1 < 0 or i2 < 0 or j2 < 0 or\n                H <= i1 or W <= j1 or H <= i2 or W <= j2 or\n                i1 > i2 or j1 > j2) return -INF;\n\n            // dp\n            if (dp[i1][j1][i2][j2] != -1) return dp[i1][j1][i2][j2];\n\n            // init\n            dp[i1][j1][i2][j2] = -INF;\n\n            // start or end is wall\n            if (C[i1][j1] == '#' or C[i2][j2] == '#') return -INF;\n\n            // length 1\n            if (i1 == i2 and j1 == j2) {\n                chmax(dp[i1][j1][i2][j2], 0);\n            }\n            // length 2\n            if (i1+1 == i2 and j1 == j2 or i1 == i2 and j1+1 == j2) {\n                chmax(dp[i1][j1][i2][j2], 0);\n            }\n\n            // cut edge\n            if (C[i1][j1] == '.') {\n                chmax(dp[i1][j1][i2][j2], rec(i1+1, j1, i2, j2));\n                chmax(dp[i1][j1][i2][j2], rec(i1, j1+1, i2, j2));\n                return dp[i1][j1][i2][j2];\n            }\n            else if (C[i2][j2] == '.') {\n                chmax(dp[i1][j1][i2][j2], rec(i1, j1, i2-1, j2));\n                chmax(dp[i1][j1][i2][j2], rec(i1, j1, i2, j2-1));\n                return dp[i1][j1][i2][j2];\n            }\n\n            // start and end is corresponding\n            if (jewel[i1][j1] != -1 and hole[i2][j2] != -1 and\n                jewel[i1][j1] == hole[i2][j2]) {\n                int ma = -INF;\n                if (i1 == i2 and j1 + 1 == j2 or\n                    j1 == j2 and i1 + 1 == i2) {\n                    ma = 0;\n                }\n                chmax(ma, rec(i1+1, j1, i2-1, j2));\n                chmax(ma, rec(i1+1, j1, i2, j2-1));\n                chmax(ma, rec(i1, j1+1, i2-1, j2));\n                chmax(ma, rec(i1, j1+1, i2, j2-1));\n                if (ma != -INF) chmax(dp[i1][j1][i2][j2], ma + 1);\n            }\n\n            // split\n            FOR(i, i1, i2 + 1) FOR(j, j1, j2 + 1) {\n                if (i + 1 <= i2) {\n                    int l = rec(i1, j1, i, j), r = rec(i+1, j, i2, j2);\n                    if (l != -INF and r != -INF) chmax(dp[i1][j1][i2][j2], l + r);\n                }\n                if (j + 1 <= j2) {\n                    int l = rec(i1, j1, i, j), r = rec(i, j+1, i2, j2);\n                    if (l != -INF and r != -INF) chmax(dp[i1][j1][i2][j2], l + r);\n                }\n            }\n\n            return dp[i1][j1][i2][j2];\n        };\n\n        int ans = rec(0, 0, H-1, W-1);\n        if (ans == -INF) ans = -1;\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\ntemplate <typename T>\nvector<T> Vec(int n, T v) { return vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    while (true) {\n        int H, W;\n        cin >> H >> W;\n        if (H == 0 and W == 0) { break; }\n        auto C = Vec(H, W, char(0));\n        auto I = Vec(H, W, -1);\n        using P = pair<int, int>;\n        auto in = [&](const int y, const int x) { return y >= 0 and y < H and x >= 0 and x < W and C[y][x] != '#'; };\n        vector<P> pos[26]{}, POS[26]{};\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> C[i][j];\n                if (islower(C[i][j])) {\n                    const int c = C[i][j] - 'a';\n                    pos[c].push_back({i, j});\n                    I[i][j] = pos[c].size() - 1;\n                } else if (isupper(C[i][j])) {\n                    const int c = C[i][j] - 'A';\n                    POS[c].push_back({i, j});\n                    I[i][j] = POS[c].size() - 1;\n                }\n            }\n        }\n        auto bfs = [&](const int y, const int x) {\n            auto used = Vec(H, W, false);\n            queue<P> q;\n            q.push({y, x}), used[y][x] = true;\n            while (not q.empty()) {\n                const int y = q.front().first, x = q.front().second;\n                q.pop();\n                if (in(y + 1, x) and not used[y + 1][x]) { q.push({y + 1, x}), used[y + 1][x] = true; }\n                if (in(y, x + 1) and not used[y][x + 1]) { q.push({y, x + 1}), used[y][x + 1] = true; }\n            }\n            return used;\n        };\n        if (not bfs(0, 0)[H - 1][W - 1]) {\n            cout << -1 << endl;\n            continue;\n        }\n        vector<vector<bool>> ok[26];\n        for (int i = 0; i < 26; i++) {\n            const int S = pos[i].size(), T = POS[i].size();\n            ok[i] = Vec(S, T, false);\n            for (int j = 0; j < S; j++) {\n                const auto used = bfs(pos[i][j].first, pos[i][j].second);\n                for (int k = 0; k < T; k++) { ok[i][j][k] = used[POS[i][k].first][POS[i][k].second]; }\n            }\n        }\n        auto memo = Vec(H, W, H, W, -1);\n        constexpr int INF = 1 << 30;\n        auto solve = fix([&](auto&& self, const int y1, const int x1, const int y2, const int x2) -> int {\n            if (not in(y1, x1) or not in(y2, x2) or y2 < y1 or x2 < x1) { return -INF; }\n            if (y1 == y2 and x1 == x2) { return memo[y1][x1][y2][x2] = 0; }\n            if (memo[y1][x1][y2][x2] != -1) { return memo[y1][x1][y2][x2]; }\n            int ans = max(self(self, y1 + 1, x1, y2, x2), self(self, y1, x1 + 1, y2, x2));\n            if (islower(C[y1][x1]) == 0) { return memo[y1][x1][y2][x2] = ans; }\n            const int c = C[y1][x1] - 'a', ind = I[y1][x1];\n            for (int j = 0; j < POS[c].size(); j++) {\n                if (ok[c][ind][j]) {\n                    const int D = abs(y1 - POS[c][j].first) + abs(x1 - POS[c][j].second);\n                    const int after = self(self, POS[c][j].first, POS[c][j].second, y2, x2);\n                    const int before = D == 1 ? 0 : max({self(self, y1 + 1, x1, POS[c][j].first - 1, POS[c][j].second), self(self, y1, x1 + 1, POS[c][j].first - 1, POS[c][j].second), self(self, y1 + 1, x1, POS[c][j].first, POS[c][j].second - 1), self(self, y1, x1 + 1, POS[c][j].first, POS[c][j].second - 1)});\n                    ans = max(ans, before + after + 1);\n                }\n            }\n            return memo[y1][x1][y2][x2] = ans;\n        });\n        cout << solve(0, 0, H - 1, W - 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[26],t[26];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n            mv[i][i] = false;\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,26){\n            for(int from:s[i])for(int to:t[i])if(mv[from][to]) dp[from][to] = 1;\n        }\n\n        rep(loop,50){\n            rep(i,26)for(int from:s[i])for(int to:t[i]){\n                if(!mv[from][to]) continue;\n\n                rep(j,26){\n                    for(int x:s[j]){\n                        if(!mv[from][x]) continue;\n                        for(int y:t[j]){\n                            if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> ans(h,vector<int>(w,-1));\n        ans[0][0] = 0;\n        rep(i,h)rep(j,w){\n            rep(d,2){\n                int ni = i+dy[d], nj = j+dx[d];\n                if(IN(ni,nj) && c[ni][nj]!='#') ans[ni][nj] = max(ans[ni][nj], ans[i][j]);\n            }\n\n            if(islower(c[i][j])){\n                int from = p2id[{i,j}];\n                for(int to:t[c[i][j]-'a']){\n                    if(mv[from][to]){\n                        ans[p[to].fi][p[to].se] = max(ans[p[to].fi][p[to].se], ans[i][j]+dp[from][to]);\n                    }\n                }\n            }\n        }\n        cout << ans[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\nconst int ALP = 26;\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[ALP],t[ALP];\n        rep(i,h)rep(j,w){\n            char f = c[i][j];\n            if(f != '.' && f != '#'){\n                p2id[{i,j}] = p.size();\n                if(islower(f)) s[f-'a'].pb(p.size());\n                else t[f-'A'].pb(p.size());\n                p.pb({i,j});\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n            mv[i][i] = false;\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,ALP){\n            for(int from:s[i])for(int to:t[i])if(mv[from][to]) dp[from][to] = 1;\n        }\n\n        for(int i=n-1; i>=0; --i){\n            if(!islower(c[p[i].fi][p[i].se])) continue;\n            int idx = c[p[i].fi][p[i].se]-'a';\n\n            for(int to:t[idx]){\n                if(!mv[i][to]) continue;\n\n                rep(j,ALP){\n                    for(int x:s[j]){\n                        if(!mv[i][x]) continue;\n                        for(int y:t[j]){\n                            if(mv[x][y] && mv[y][to]) dp[i][to] = max(dp[i][to], dp[x][y]+1);\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> ans(h,vector<int>(w,-1));\n        ans[0][0] = 0;\n        rep(i,h)rep(j,w){\n            rep(d,2){\n                int ni = i+dy[d], nj = j+dx[d];\n                if(IN(ni,nj) && c[ni][nj]!='#') ans[ni][nj] = max(ans[ni][nj], ans[i][j]);\n            }\n\n            if(islower(c[i][j])){\n                int from = p2id[{i,j}];\n                for(int to:t[c[i][j]-'a']){\n                    if(mv[from][to]){\n                        ans[p[to].fi][p[to].se] = max(ans[p[to].fi][p[to].se], ans[i][j]+dp[from][to]);\n                    }\n                }\n            }\n        }\n        cout << ans[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define max(a, b) ((a)>(b)?(a):(b))\nint n, m, la, lb;\nchar S[55][55];\nint d[52][52][52][52];\nint ax[26][11], ay[26][11], an[26];\ninline bool match(char A, char B) {\n    la = 'a' <= A && A <= 'z';\n    lb = 'a' <= B && B <= 'z';\n    if (la && !lb && A - 'a' == B - 'A') return 1;\n    return 0;\n}\nint f(int ux, int uy, int dx, int dy) {\n    if (ux > dx || uy > dy) return -1;\n    if (d[ux][uy][dx][dy] != -2) return d[ux][uy][dx][dy];\n    d[ux][uy][dx][dy] = -1;\n    if (S[ux][uy] != '#' && S[dx][dy] != '#') {\n        if (ux == dx && uy == dy) return d[ux][uy][dx][dy] = 0;\n        if (S[ux][uy] == '.' || ('A' <= S[ux][uy] && S[ux][uy] <= 'Z')) d[ux][uy][dx][dy] = max(f(ux + 1, uy, dx, dy), f(ux, uy + 1, dx, dy));\n        else {\n            d[ux][uy][dx][dy] = max(f(ux + 1, uy, dx, dy), f(ux, uy + 1, dx, dy));\n            int p = S[ux][uy] - 'a', v, nx, ny, ff;\n            for (int i = 1; i <= an[p]; i++) {\n                v = -1;\n                nx = ax[p][i];\n                ny = ay[p][i];\n                if ((ux == nx && uy + 1 == ny) || (uy == ny && ux + 1 == nx)) {\n                    ff = f(nx, ny, dx, dy);\n                    if (match(S[ux][uy], S[nx][ny]) && ff != -1) d[ux][uy][dx][dy] = max(d[ux][uy][dx][dy], 1 + ff);\n                }\n                else {\n                    if (ux <= nx && nx <= dx && uy <= ny && ny <= dy) {\n                        v = max(v, f(ux + 1, uy, nx - 1, ny));\n                        v = max(v, f(ux + 1, uy, nx, ny - 1));\n                        v = max(v, f(ux, uy + 1, nx - 1, ny));\n                        v = max(v, f(ux, uy + 1, nx, ny - 1));\n                        ff = f(nx, ny, dx, dy);\n                        if (v != -1 && ff != -1) d[ux][uy][dx][dy] = max(d[ux][uy][dx][dy], v + 1 + ff);\n                    }\n                }\n            }\n        }\n    }\n    return d[ux][uy][dx][dy];\n}\nint main() {\n    while (scanf(\"%d%d\", &n, &m), n&&m) {\n        for (int i = 1; i <= n; i++) scanf(\"%s\", S[i] + 1);\n        for (int i = 0; i < 26; i++) an[i] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if ('A' <= S[i][j] && S[i][j] <= 'Z') {\n                    int p = S[i][j] - 'A';\n                    an[p]++;\n                    ax[p][an[p]] = i;\n                    ay[p][an[p]] = j;\n                }\n            }\n        }\n        for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 1; k <= n; k++) for (int l = 1; l <= m; l++) d[i][j][k][l] = -2;\n        printf(\"%d\\n\", f(1, 1, n, m));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nconst int INF = 3000;\n\nvector<string> field;\nunordered_map<char, vector<pair<int,int>>> holes_of;\nint dp[55][55][55][55];\nbool visited[55][55][55][55];\n\nint calc(int t, int l, int b, int r) {\n    if(visited[t][l][b][r]) return dp[t][l][b][r];\n    if(t > b || l > r) return -INF;\n    if(field[t][l] == '#') return -INF;\n    visited[t][l][b][r] = true;\n    int &res = dp[t][l][b][r];\n    if(t == b && l == r) {\n        return res = 0;\n    } else {\n        res = max(res, calc(t+1, l, b, r));\n        res = max(res, calc(t, l+1, b, r));\n        if(islower(field[t][l])) {\n            // Pick and place\n            for(const auto &to : holes_of[field[t][l]]) {\n                //cout << field[t][l] << ' ' << to.first << ' ' << to.second << endl;\n                res = max(res, calc(t+1, l, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n                res = max(res, calc(t, l+1, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n            }\n        }\n    }\n    if(res < 0) res = -INF;\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    if(!(cin >> H >> W)) return false;\n    if(!H && !W) return false;\n\n    field.clear();\n    field.resize(H);\n    holes_of.clear();\n    for(int i = 0; i < H; ++i) {\n        cin >> field[i];\n        for(int j = 0; j < W; ++j) {\n            if(isupper(field[i][j])) {\n                const char c = tolower(field[i][j]);\n                holes_of[c].push_back(make_pair(i, j));\n            }\n        }\n    }\n    fill_n((int*)dp, sizeof(dp)/sizeof(int), -INF);\n    fill_n((bool*)visited, sizeof(visited)/sizeof(bool), false);\n\n    int res = calc(0, 0, H-1, W-1);\n    if(res < 0) res = -1;\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n\n\n\n\n\n\n\nint T,n,num,m;\nchar z[55][55];\nint dp[55][55][55][55];\nint vi[55][55];\nint ac[55][55][55][55];\nvoid dfs(int q,int w)\n{\n    if(z[q][w]=='#')\n        return;\n    vi[q][w]=1;\n    if(q>=n||w>=m)\n        return;\n    if(vi[q+1][w]==0)\n        dfs(q+1,w);\n    if(vi[q][w+1]==0)\n        dfs(q,w+1);\n}\nint main()\n{\n    // freopen(\"1\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)\n            break;\n        for(int q=0;q<n;q++)\n            scanf(\"%s\",z[q]);\n        memset(dp,0,sizeof dp);\n        memset(vi,0,sizeof vi);\n        memset(ac,0,sizeof ac);\n        dfs(0,0);\n        if(vi[n-1][m-1]==0)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n        // for(int q=0;q<n;q++)\n        //     for(int w=0;w<m;w++)\n        //     {\n        //         if(q<n-1)\n        //         {\n        //             if(z[q][w]!='#'&&z[q+1][w]!='#')\n        //                 ac[q][w][q+1][w]=1;\n        //         }\n        //         if(w<m-1)\n        //         {\n        //             if(z[q][w]!=\"#\"&&z[q][w+1]!='#')\n        //                 ac[q][w][q][w+1]=1;\n        //         }\n        //     }\n\n        for(int q=0;q<n;q++)\n            for(int w=0;w<m;w++)\n            {\n                memset(vi,0,sizeof vi);\n                dfs(q,w);\n                for(int e=0;e<n;e++)\n                    for(int r=0;r<m;r++)\n                    {\n                        if(vi[e][r])\n                            ac[q][w][e][r]=1;\n                        // printf(\"%d %d %d %d %d\\n\",q,w,e,r,ac[q][w][e][r]);\n                    }\n            }\n\n        for(int q=0;q<n;q++)\n            for(int w=0;w<m;w++)\n                for(int e=q+1;e<n;e++)\n                    for(int r=w;r<m;r++)\n                    {\n\n                    }\n        for(int w=0;w<=n;w++)\n            for(int q=0;q+w<=n;q++)\n                for(int r=0;r<=m;r++)\n                    for(int e=0;e+r<=m;e++)\n                    {\n                        if(q+w>=q+1&&e+r>=e+2)\n                        {\n                            if(ac[q][e][q+w-1][e+r-1]&&z[q][e]-'a'==z[q+w-1][e+r-1]-'A'&&z[q][e]>='a'&&z[q][e]<='z'&&z[q+w-1][e+r-1]>='A'&&z[q+w-1][e+r-1]<='Z')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+1)\n                        {\n                            if(ac[q][e][q+w-1][e+r-1]&&z[q][e]-'a'==z[q+w-1][e+r-1]-'A'&&z[q][e]>='a'&&z[q][e]<='z'&&z[q+w-1][e+r-1]>='A'&&z[q+w-1][e+r-1]<='Z')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2&&z[q][e]>='a'&&z[q][e]<='z'&&z[q+w-1][e+r-1]>='A'&&z[q+w-1][e+r-1]<='Z')\n                        {\n                            if(ac[q][e][q+w-1][e+r-1]&&z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2&&z[q][e]>='a'&&z[q][e]<='z'&&z[q+w-1][e+r-1]>='A'&&z[q+w-1][e+r-1]<='Z')\n                        {\n                            if(ac[q][e][q+w-1][e+r-1]&&z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]);\n                        }\n                        for(int t=q+1;t<=q+w-1;t++)\n                        {\n                            // dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][t][e][e+r]+dp[t][q+w][e][e+r]);\n                            for(int y=e+1;y<=e+r-1;y++)\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][t][e][y]+dp[t][q+w][y][e+r]);\n                        }\n                        for(int t=e+1;t<=e+r-1;t++)\n                        {\n                            dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e][t]+dp[q][q+w][t][e+r]);\n                        }\n                        // if(q==0&&q+w==10&&e==4&&e+r==9)\n                        // {\n                        //     cout<<dp[q][q+w][e+1][e+r-1]<<endl;\n                        //     cout<<dp[q+1][q+w-1][e][e+r]<<endl;\n                        //     cout<<dp[q+1][q+w][e][e+r-1]<<endl;\n                        //     cout<<dp[q][q+w-1][e+1][e+r]<<endl;\n                        // }\n                        // printf(\"%d %d %d %d %d\\n\",q,q+w,e,e+r,dp[q][q+w][e][e+r]);\n                        dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r]);\n                        if(q+w>0)\n                        dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e][e+r]);\n                        dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r]);\n                        if(e+r>0)\n                        dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e][e+r-1]);\n                        // printf(\"%d %d %d %d %d\\n\",q,q+w,e,e+r,dp[q][q+w][e][e+r]);\n                    }\n\n                    // for(int q=0;q<=n;q++)\n\n\n                    printf(\"%d\\n\",dp[0][n][0][m]);\n    }\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -1;\n\t\t\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\t\t\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!((y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nconst int INF = 5000;\ntypedef unsigned char byte;\n\nvector<string> field;\nunordered_map<char, vector<pair<int,int>>> holes_of;\nint dp[55][55][55][55];\nbool visited[55][55][55][55];\n\nint calc(byte t, byte l, byte b, byte r) {\n    if(visited[t][l][b][r]) return dp[t][l][b][r];\n    if(t > b || l > r) return -INF;\n    if(field[t][l] == '#') return -INF;\n    visited[t][l][b][r] = true;\n    int &res = dp[t][l][b][r];\n    if(t == b && l == r) {\n        res = 0;\n    } else {\n        res = max(res, calc(t+1, l, b, r));\n        res = max(res, calc(t, l+1, b, r));\n        if(islower(field[t][l])) {\n            // Pick and place\n            for(const auto &to : holes_of[field[t][l]]) {\n                //cout << field[t][l] << ' ' << to.first << ' ' << to.second << endl;\n                if(to.first == b && to.second == r) continue;\n                if(to.first < t || to.second < l) continue;\n                res = max(res, calc(t+1, l, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n                res = max(res, calc(t, l+1, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n            }\n        }\n    }\n    if(res < 0) res = -INF;\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    if(!(cin >> H >> W)) return false;\n    if(!H && !W) return false;\n\n    field.clear();\n    field.resize(H);\n    holes_of.clear();\n    for(int i = 0; i < H; ++i) {\n        cin >> field[i];\n        for(int j = 0; j < W; ++j) {\n            if(isupper(field[i][j])) {\n                const char c = tolower(field[i][j]);\n                holes_of[c].push_back(make_pair(i, j));\n            }\n        }\n    }\n    field.push_back(string(W, '#'));\n    field.back()[W-1] = '.';\n    fill_n((int*)dp, sizeof(dp)/sizeof(int), -INF);\n    fill_n((bool*)visited, sizeof(visited)/sizeof(bool), false);\n\n    int res = calc(0, 0, H, W-1);\n    if(res < 0) res = -1;\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nvector<pair<pint,pint>>lis;\nstring fld[55];\n\nbool vis[50][50][50][50];\n\ninline bool reach(const pint &s,const pint &t){\n    return vis[s.fi][s.se][t.fi][t.se];\n}\n\nint dp[3000][55][55];\nint memo[3000];//26*10*10\nint dfs(int v){\n    int &ret=memo[v];\n    if(ret!=-1)return ret;\n\n    ret=0;\n    fill_n(*dp[v],55*55,-1001001001);\n    dp[v][lis[v].fi.fi][lis[v].fi.se]=0;\n    int k=0;\n    reps(i,lis[v].fi.fi,lis[v].se.fi+1){\n        reps(j,lis[v].fi.se,lis[v].se.se+1){\n            if(fld[i][j]=='#')continue;\n            if(i+1<=lis[v].se.fi&&fld[i+1][j]!='#')chmax(dp[v][i+1][j],dp[v][i][j]);\n            if(j+1<=lis[v].se.se&&fld[i][j+1]!='#')chmax(dp[v][i][j+1],dp[v][i][j]);\n\n            while(k<lis.size()){\n                bool ok=true;\n                if(lis[k].fi<pint(i,j))ok=false;\n                if(lis[k].fi==pint(i,j)&&(lis[k].se.fi>lis[v].se.fi||lis[k].se.se>lis[v].se.se))ok=false;\n                if(!ok){\n                    k++;\n                    continue;\n                }\n                if(lis[k].fi==pint(i,j)){\n                    int tmp=dp[v][i][j]+dfs(k)+1;\n                    if(lis[k].se.fi+1<=lis[v].se.fi)chmax(dp[v][lis[k].se.fi+1][lis[k].se.se],tmp);\n                    if(lis[k].se.se+1<=lis[v].se.se)chmax(dp[v][lis[k].se.fi][lis[k].se.se+1],tmp);\n                    k++;\n                }\n                else break;\n            }\n        }\n    }\n\n    return ret=dp[v][lis[v].se.fi][lis[v].se.se];\n}\n\nsigned main(){\n    while(cin>>H>>W,H||W){\n        rep(i,H)cin>>fld[i+1];\n        fld[0]=fld[H+1]=string(W,'#');\n        fld[0][0]=fld[H+1][W-1]='.';\n        H+=2;\n\n        memset(vis,0,sizeof(vis));\n        rep(a,H)rep(b,W){\n            if(fld[a][b]=='#')continue;\n            vis[a][b][a][b]=true;\n            rep(c,H)rep(d,W){\n                if(!vis[a][b][c][d])continue;\n                if(c+1<H&&fld[c+1][d]!='#')vis[a][b][c+1][d]=true;\n                if(d+1<W&&fld[c][d+1]!='#')vis[a][b][c][d+1]=true;\n            }\n        }\n\n        if(!vis[0][0][H-1][W-1]){\n            cout<<-1<<endl;\n            continue;\n        }\n\n        lis.clear();\n        lis.pb(make_pair(pint(0,0),pint(H-1,W-1)));\n        rep(a,H)rep(b,W)rep(c,H)rep(d,W){\n            if(a>c||b>d)continue;\n            if(!islower(fld[a][b])||!isupper(fld[c][d]))continue;\n            if(toupper(fld[a][b])!=fld[c][d])continue;\n            if(vis[a][b][c][d]){\n                lis.pb(make_pair(pint(a,b),pint(c,d)));\n            }\n        }\n\n        sort(all(lis));\n\n        memset(memo,-1,sizeof(memo));\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[50][50];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            if('a'<=c[y][x] and c[y][x]<='z' and 'A'<=c[y_][x_] and c[y_][x_]<='Z' and c[y][x]-'a'==c[y_][x_]-'A') ps[y][x].push_back(make_pair(y_,x_));\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return 0;\n        if(!can_move[y1][x1][y2][x2]) return -inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[y1][x1]){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_)) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\t\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\t\t\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!((y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <cfloat>\n#include <cstring>\n#include <cctype>\n#include <queue>\nusing namespace std;\n\n\nint h, w;\nchar field[52][52];\nint tbl[52][52];\nvector<int> ps;\nvector<char> cs;\nint dp[522][522];\n\nbool reachable(){\n\tbool visit[52][52] = {};\n\tqueue<int> q;\n\tq.push(1 << 8 | 1);\n\twhile( !q.empty() ){\n\t\tint y = q.front() >> 8;\n\t\tint x = q.front() & 255;\n\t\tq.pop();\n\t\tif(y == h && x == w) return true;\n\n\t\tif( field[y + 1][x] != '#' ){\n\t\t\tif( !visit[y+1][x] ){\n\t\t\t\tvisit[y+1][x] = true;\n\t\t\t\tq.push(y + 1 << 8 | x);\n\t\t\t}\n\t\t}\n\t\tif( field[y][x + 1] != '#' ){\n\t\t\tif( !visit[y][x+1] ){\n\t\t\t\tvisit[y][x+1] = true;\n\t\t\t\tq.push(y << 8 | x + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid add_edge(int p, vector<int> &e){\n\tbool visit[52][52] = {};\n\tqueue<int> q;\n\tq.push(p);\n\n\twhile( !q.empty() ){\n\t\tp = q.front();\n\t\tq.pop();\n\n\t\tint y = p >> 8;\n\t\tint x = p & 255;\n\t\t\n\t\tfor(int i = 0; i < 2; ++i){\n\t\t\tint ny = y + i;\n\t\t\tint nx = x + (1 - i);\n\n\t\t\tif( !visit[ny][nx] ){\n\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\tif( tbl[ny][nx] != -1 ){\n\t\t\t\t\tif( tbl[ny][nx] == -2 ){\n\t\t\t\t\t\tq.push(ny << 8 | nx);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\te.push_back(tbl[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tvector<int>::iterator it1, it2;\n\n\twhile( scanf(\"%d%d\", &h, &w), h != 0 ){\n\t\tmemset(field, '#', sizeof field);\n\t\tmemset(tbl, -1, sizeof tbl);\n\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\" %s\", field[i] + 1);\n\t\t\tfield[i][w+1] = '#';\n\t\t}\n\n\t\tif( !reachable() ){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif( field[1][1] == '.' ){\n\t\t\tfield[1][1] = '~';\n\t\t}\n\t\tif( field[h][w] == '.' ){\n\t\t\tfield[h][w] = '~';\n\t\t}\n\n\t\tps.clear();\n\t\tcs.clear();\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tif( field[i][j] == '.' ){\n\t\t\t\t\ttbl[i][j] = -2;\n\t\t\t\t}\n\t\t\t\telse if( field[i][j] != '#' ){\n\t\t\t\t\ttbl[i][j] = ps.size();\n\t\t\t\t\tps.push_back(i << 8 | j);\n\t\t\t\t\tcs.push_back( field[i][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < ps.size(); ++i){\n\t\t\tfor(int j = 0; j < ps.size(); ++j){\n\t\t\t\tdp[i][j] = i == j ? 0 : -10000;\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > G(ps.size());\n\t\tvector<vector<int> > rG(ps.size());\n\t\tfor(int i = 0; i < ps.size(); ++i){\n\t\t\tadd_edge(ps[i], G[i]);\n\n\t\t\tfor(it1 = G[i].begin(); it1 != G[i].end(); ++it1){\n\t\t\t\trG[*it1].push_back(i);\n\t\t\t\tdp[i][*it1] = (cs[i] == cs[*it1] + 32);\n\t\t\t}\n\t\t}\n\n\t\tfor(int d = 2; d < ps.size(); ++d)\n\t\tfor(int i = 0; i + d < ps.size(); ++i){\n\t\t\tint j = i + d;\n\n\t\t\tint t = dp[i][j];\n\n\t\t\tif( cs[i] == cs[j] + 32 ){\n\t\t\t\tfor(it1 = G[i].begin(); it1 != G[i].end(); ++it1)\n\t\t\t\tfor(it2 = rG[j].begin(); it2 != rG[j].end(); ++it2){\n\t\t\t\t\tt = max(t, dp[*it1][*it2] + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k = i; k < j; ++k){\n\t\t\t\tt = max(t, dp[i][k] + dp[k][j]);\n\t\t\t}\n\t\t\tdp[i][j] = t;\n\t\t}\n\n\t\tprintf(\"%d\\n\", dp[0][ps.size() - 1] );\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint dp[52][52][52][52];\nint v[52][52][52][52];\nint r[600];\nint w[600];\nint sz;\nint H,W;\nint solve(int a,int b,int c,int d){\n\tif(a>c||b>d)return -99999999;\n\tif(~dp[a][b][c][d])return dp[a][b][c][d];\n\tif(a==c&&b==d)return dp[a][b][c][d]=0;\n\tint ret=-99999999;\n\tif(str[a][b]-32==str[c][d]){\n\t\tif(v[a][b][c][d])ret=1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])&&\n\t\t\t\tv[r[j]][w[j]][c][d]&&(c!=r[j]||d!=w[j])){\n\t\t\t\t\tret=max(ret,solve(r[i],w[i],r[j],w[j])+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])){\n\t\t\tret=max(ret,solve(r[i],w[i],c,d));\n\t\t}\n\t\tif(v[r[i]][w[i]][c][d]&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&v[r[i]][w[i]][c][d]&&(a!=r[i]||b!=w[i])&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i],w[i],c,d));\n\t\t}\n\t}\n\t//printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\tv[i][j][k][l]=0;\n\t\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'&&str[i][j]!='#'){\n\t\t\t\t\tr[sz]=i;w[sz++]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tv[i][j][i][j]=1;\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tif(str[k][l]=='#')continue;\n\t\t\t\tif(k&&v[i][j][k-1][l])v[i][j][k][l]=1;\n\t\t\t\tif(l&&v[i][j][k][l-1])v[i][j][k][l]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=solve(0,0,a-1,b-1);\n\t\tif(ret<-1)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[50][50];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            if('a'<=c[y][x] and c[y][x]<='z' and 'A'<=c[y_][x_] and c[y_][x_]<='Z' and c[y][x]-'a'==c[y_][x_]-'A') ps[y][x].push_back(make_pair(y_,x_));\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return 0;\n        if(!can_move[y1][x1][y2][x2]) return -inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[y1][x1]){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\ntemplate <typename T>\nvector<T> Vec(int n, T v) { return vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(int n, Args... args)\n{\n    auto val = Vec(args...);\n    return vector<decltype(val)>(n, move(val));\n}\n\nint main()\n{\n    while (true) {\n        int H, W;\n        cin >> H >> W;\n        if (H == 0 and W == 0) { break; }\n        auto C = Vec(H, W, char(0));\n        auto I = Vec(H, W, -1);\n        using P = pair<int, int>;\n        auto in = [&](const int y, const int x) { return y >= 0 and y < H and x >= 0 and x < W and C[y][x] != '#'; };\n        vector<P> pos[26]{}, POS[26]{};\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> C[i][j];\n                if (islower(C[i][j])) {\n                    const int c = C[i][j] - 'a';\n                    pos[c].push_back({i, j});\n                    I[i][j] = pos[c].size() - 1;\n                } else if (isupper(C[i][j])) {\n                    const int c = C[i][j] - 'A';\n                    POS[c].push_back({i, j});\n                    I[i][j] = POS[c].size() - 1;\n                }\n            }\n        }\n        auto bfs = [&](const int y, const int x) {\n            auto used = Vec(H, W, false);\n            queue<P> q;\n            q.push({y, x}), used[y][x] = true;\n            while (not q.empty()) {\n                const int y = q.front().first, x = q.front().second;\n                q.pop();\n                if (in(y + 1, x) and not used[y + 1][x]) { q.push({y + 1, x}), used[y + 1][x] = true; }\n                if (in(y, x + 1) and not used[y][x + 1]) { q.push({y, x + 1}), used[y][x + 1] = true; }\n            }\n            return used;\n        };\n        if (not bfs(0, 0)[H - 1][W - 1]) {\n            cout << -1 << endl;\n            continue;\n        }\n        vector<vector<bool>> ok[26];\n        for (int i = 0; i < 26; i++) {\n            const int S = pos[i].size(), T = POS[i].size();\n            ok[i] = Vec(S, T, false);\n            for (int j = 0; j < S; j++) {\n                const auto used = bfs(pos[i][j].first, pos[i][j].second);\n                for (int k = 0; k < T; k++) { ok[i][j][k] = used[POS[i][k].first][POS[i][k].second]; }\n            }\n        }\n        auto memo = Vec(H, W, H, W, -1);\n        constexpr int INF = 1 << 30;\n        auto solve = fix([&](auto&& self, const int y1, const int x1, const int y2, const int x2) -> int {\n            if (not in(y1, x1) or not in(y2, x2)) { return -INF; }\n            if (y2 < y1 or x2 < x1) { return abs(y2 - y1) + abs(x2 - x1) == 1 ? 0 : -INF; }\n            if (y1 == y2 and x1 == x2) { return memo[y1][x1][y2][x2] = 0; }\n            if (memo[y1][x1][y2][x2] != -1) { return memo[y1][x1][y2][x2]; }\n            int ans = max(self(self, y1 + 1, x1, y2, x2), self(self, y1, x1 + 1, y2, x2));\n            if (islower(C[y1][x1]) == 0) { return memo[y1][x1][y2][x2] = ans; }\n            const int c = C[y1][x1] - 'a', ind = I[y1][x1];\n            for (int j = 0; j < POS[c].size(); j++) {\n                if (ok[c][ind][j]) {\n                    const int after = self(self, POS[c][j].first, POS[c][j].second, y2, x2);\n                    const int before = max({self(self, y1 + 1, x1, POS[c][j].first - 1, POS[c][j].second),\n                                            self(self, y1, x1 + 1, POS[c][j].first - 1, POS[c][j].second),\n                                            self(self, y1 + 1, x1, POS[c][j].first, POS[c][j].second - 1),\n                                            self(self, y1, x1 + 1, POS[c][j].first, POS[c][j].second - 1)});\n                    ans = max(ans, before + after + 1);\n                }\n            }\n            return memo[y1][x1][y2][x2] = ans;\n        });\n        cout << solve(0, 0, H - 1, W - 1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint dp[52][52][52][52];\nint v[52][52][52][52];\nint r[600];\nint w[600];\nint sz;\nint H,W;\nint solve(int a,int b,int c,int d){\n\tif(a>c||b>d)return 0;\n\tif(a<0||b<0||c>=H||d>=W)return 0;\n\tif(str[a][b]=='#'||str[c][d]=='#')return 0;\n\tif(~dp[a][b][c][d])return dp[a][b][c][d];\n\tif(!v[a][b][c][d])return 0;\n\tif(a==c&&b==d)return dp[a][b][c][d]=0;\n\tint ret=0;\n\tif(str[a][b]-32==str[c][d]){\n\t\tif(v[a][b][c][d])ret=1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])&&\n\t\t\t\tv[r[j]][w[j]][c][d]&&(c!=r[j]||d!=w[j])){\n\t\t\t\t\tret=max(ret,solve(r[i],w[i],r[j],w[j])+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])){\n\t\t\tret=max(ret,solve(r[i],w[i],c,d));\n\t\t}\n\t\tif(v[r[i]][w[i]][c][d]&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&v[r[i]][w[i]][c][d]&&(a!=r[i]||b!=w[i])&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i],w[i]+1,c,d));\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i]+1,w[i]+1,c,d));\n\t\t\t\n\t\t}\n\t}\n//\tprintf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\tv[i][j][k][l]=0;\n\t\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'&&str[i][j]!='#'){\n\t\t\t\t\tr[sz]=i;w[sz++]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tv[i][j][i][j]=1;\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tif(str[k][l]=='#')continue;\n\t\t\t\tif(k&&v[i][j][k-1][l])v[i][j][k][l]=1;\n\t\t\t\tif(l&&v[i][j][k][l-1])v[i][j][k][l]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=solve(0,0,a-1,b-1);\n\t\tif(!v[0][0][a-1][b-1])printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,C;\nchar s[100],a[10000];\nchar t[100][100];\nint id[100][100];\nint INF=1e8;\nmap<int,int> dp[100][100];\nint ans;\n\nint dfs(int y,int x,int bit){\n\n  if(y<0||x<0||y>=H||x>=W)return -INF;\n\n  if(t[y][x]=='#')return -INF;\n\n  int res=0;\n  if('a'<=t[y][x]&&t[y][x]<='z'){\n    bit|=(1<<id[y][x]);\n  }\n  \n  if(dp[y][x].count(bit)){\n    return dp[y][x][bit];\n  }\n  \n  int flg=0;\n  int nbit=bit;\n  if('A'<=t[y][x]&&t[y][x]<='Z'){\n    for(int i=C-1;i>=0;i--){\n      if( (nbit>>i&1) && a[i]==t[y][x] ){\n        flg=1;\n        break;\n      }else{\n        nbit|=(1<<i);\n        nbit-=(1<<i);\n      }\n    }\n  }\n  \n  if(y==H-1&&x==W-1){\n    ans=1;\n    return flg;\n  }\n\n\n  res=max(res,dfs(y+1,x,bit));\n  res=max(res,dfs(y,x+1,bit));\n  res=max(res,dfs(y+1,x,nbit)+flg);\n  res=max(res,dfs(y,x+1,nbit)+flg);\n  return dp[y][x][bit]=max(res,flg);\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        dp[i][j].clear();\n    \n    C=0;\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",s);\n      for(int j=0;j<W;j++){\n        t[i][j]=s[j];\n        if('a'<=t[i][j]&&t[i][j]<='z'){\n          a[C]=t[i][j]-'a'+'A';\n          id[i][j]=C++;\n        }\n      }\n    }\n    if(C>20)continue;\n    \n    ans=0;\n    int out=dfs(0,0,0);\n    if(ans){\n      cout<<out<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\nconst int ALP = 26;\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[ALP],t[ALP];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n            mv[i][i] = false;\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,ALP){\n            for(int from:s[i])for(int to:t[i])if(mv[from][to]) dp[from][to] = 1;\n        }\n\n        // rep(loop,50){\n        //     rep(i,ALP)for(int from:s[i])for(int to:t[i]){\n        //         if(!mv[from][to]) continue;\n\n        //         rep(j,ALP){\n        //             for(int x:s[j]){\n        //                 if(!mv[from][x]) continue;\n        //                 for(int y:t[j]){\n        //                     if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n\n        vector<vector<int>> ans(h,vector<int>(w,-1));\n        ans[0][0] = 0;\n        rep(i,h)rep(j,w){\n            rep(d,2){\n                int ni = i+dy[d], nj = j+dx[d];\n                if(IN(ni,nj) && c[ni][nj]!='#') ans[ni][nj] = max(ans[ni][nj], ans[i][j]);\n            }\n\n            if(islower(c[i][j])){\n                int from = p2id[{i,j}];\n                for(int to:t[c[i][j]-'a']){\n                    if(mv[from][to]){\n                        ans[p[to].fi][p[to].se] = max(ans[p[to].fi][p[to].se], ans[i][j]+dp[from][to]);\n                    }\n                }\n            }\n        }\n        cout << ans[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 60;\n\nstruct Po\n{\n    int x,y;\n    Po(int x,int y) : x(x) ,y(y){};\n    Po(){};\n    bool operator == (const Po &b) const{\n        return x==b.x&&y==b.y;\n    }\n    void print()\n    {\n        printf(\"(%d,%d)\",x,y);\n    }\n};\n\nchar mp[maxn][maxn];\nint id[maxn][maxn];\nint W,H;\n\nvector<Po>a[maxn],A[maxn];\n\nint down_a[maxn][maxn][maxn][maxn];\nint up_A[maxn][maxn][maxn][maxn];\n\nint dp[maxn][maxn][maxn][maxn];\nint vis[maxn][maxn][maxn][maxn];\n\nint dx[4] = { 0,1 };\nint dy[4] = { 1,0 };\n\n#define debug_x printf(\"x1 %d y1 %d x2 %d y2 %d\\n\",x1,y1,x2,y2);\n\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if( x1 == x2 && y1 == y2+1 ) return 0;\n    if( x1 == x2+1 && y1 == y2 ) return 0;\n    if( x1 == x2 && y1 == y2 ) return 0;\n\n    if( x1>x2 || y1>y2 ) return -1;\n\n    int &t = dp[x1][y1][x2][y2];\n\n    if( vis[x1][y1][x2][y2] ) return t;\n    else vis[x1][y1][x2][y2] = 1;\n\n\n    if( mp[x1][y1] == '#' || mp[x2][y2] == '#' ) return t=-1;\n\n    t = max( dfs(x1+1,y1,x2,y2) , dfs(x1,y1+1,x2,y2) );\n\n    for(int c=0;c<26;c++)\n    {\n        for( int i=0;i<a[c].size();i++ ) if( down_a[x1][y1][c][i] )\n            for( int j=0;j<A[c].size();j++ ) if( up_A[x2][y2][c][j] )\n            {\n                int t1=-1,t2=-1,t3=-1;\n                for( int k=0;k<2;k++ )\n                {\n                    t1 = max( t1 , dfs( x1,y1,a[c][i].x-dx[k],a[c][i].y-dy[k] ) );\n                    t3 = max( t3 , dfs( A[c][j].x+dx[k],A[c][j].y+dy[k],x2,y2 ) );\n                }\n                for(int k1=0;k1<2;k1++)\n                    for(int k2=0;k2<2;k2++)\n                    {\n                        t2 = max( t2 , dfs( a[c][i].x+dx[k1],a[c][i].y+dy[k1],\n                                            A[c][j].x-dx[k2],A[c][j].y-dy[k2] ) );\n                    }\n                if( t1>=0&&t2>=0&&t3>=0 )\n                {\n                    //debug_x;\n                    //a[c][i].print();\n                    //A[c][j].print();\n                    //printf(\"\\n\");\n                    t = max( t , t1+t2+t3+1 );\n                }\n\n            }\n    }\n    return t;\n}\n\nvoid bfs()\n{\n    clr(down_a,0);\n    clr(up_A,0);\n    for(int i=1 ; i<=W ; i++)\n        for(int j=1 ; j<=H ; j++)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<A[c].size();k++)\n                {\n                    up_A[i][j][c][k] =\n                        up_A[i-1][j][c][k] | up_A[i][j-1][c][k];\n                }\n            if( mp[i][j] >= 'A' && mp[i][j] <= 'Z' )\n            {\n                up_A[i][j][ mp[i][j]-'A' ][ id[i][j] ] = 1;\n            }\n\n            //printf(\"  i %d j %d \",i,j);\n            //printf(\"%d %d %d\\n\",up_A[i][j][0][0],up_A[i][j][1][0],up_A[i][j][1][1]);\n        }\n    for(int i=W ; i>=1 ; i--)\n        for(int j=H ; j>=1 ; j--)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<a[c].size();k++)\n                {\n                    down_a[i][j][c][k] =\n                        down_a[i+1][j][c][k] | down_a[i][j+1][c][k];\n                }\n            if( mp[i][j] >= 'a' && mp[i][j] <= 'z' )\n            {\n                down_a[i][j][ mp[i][j]-'a' ][ id[i][j] ] = 1;\n            }\n            //printf(\"i %d j %d \",i,j);\n            //printf(\"%d %d %d\\n\",down_a[i][j][0][0],down_a[i][j][1][0],down_a[i][j][1][1]);\n        }\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while( ~scanf(\"%d%d\",&W,&H) )\n    {\n        if(W==0&&H==0) break;\n        clr(id,-1);\n        for(int i=0;i<30;i++)\n        {\n            a[i].clear();\n            A[i].clear();\n        }\n        char c;\n        for(int i=1;i<=W;i++)\n            for(int j=1;j<=H;j++)\n            {\n\n                scanf(\" %c\",&c);\n                mp[i][j] = c;\n                if( c>='a' && c<='z' )\n                {\n                    a[ c-'a' ].push_back( Po(i,j) );\n                    id[i][j] = a[ c-'a' ].size()-1;\n                }\n                if( c>='A' && c<='Z' )\n                {\n                    A[ c-'A' ].push_back( Po(i,j) );\n                    id[i][j] = A[ c-'A' ].size()-1;\n                }\n            }\n\n        bfs();\n        clr(vis,0);\n        int ans = dfs(1,1,W,H);\n\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n\nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n\tif(x1>x2||y1>y2)return -1000;\n\tif(v[x1][y1]=='#'||v[x2][y2]=='#')return -1000;\n\tif(dp[x1][y1][x2][y2]!=-10000){\n\t\treturn dp[x1][y1][x2][y2];\n\t}\n\tif(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n\tif(x2-x1==1&&y2-y1==0){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tif(x2-x1==0&&y2-y1==1){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tint tmp = -100;\n\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n\t}\n\ttmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n\tif(tmp>=0){\n\t\treturn dp[x1][y1][x2][y2] = tmp;\n\t}\n\treturn dp[x1][y1][x2][y2] = -1000;\n}\n\nint saiki2(int x1,int y1,int x2,int y2){\n\tif(x1>x2||y1>y2)return -100;\n\tif(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n\tif(dp2[x1][y1][x2][y2]!=-100000)return dp2[x1][y1][x2][y2];\n\tint mx = dp[x1][y1][x2][y2];\n\tfor(int i=x1;i<=x2;i++){\n\t\tfor(int j=y1;j<=y2;j++){\n\t\t\tif(i==x1&&j==y1)continue;\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i+1,j,x2,y2));\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i,j+1,x2,y2));\n\t\t}\n\t}\n\treturn dp2[x1][y1][x2][y2] = mx;\n\n}\n\nint main() {\n   \twhile(cin >> h >> w && h!=0){\n   \t\tvector<string> v(h);\n   \t\trep(i,h){\n   \t\t\tcin >> v[i];\n   \t\t}\n\t\trep(i,51){\n\t\t\trep(j,51){\n\t\t\t\trep(k,51){\n\t\t\t\t\trep(l,51){\n\t\t\t\t\t\tdp[i][j][k][l] = -10000;\n\t\t\t\t\t\tdp2[i][j][k][l] = -100000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}   \t\t\n\t\tint ans = saiki(0,0,h-1,w-1,v);\n\t\tans = saiki2(0,0,h-1,w-1);\n\t\tif(ans>=0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n   \t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!(move[y1][x1][ny][nx] && (y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\t\t\t\tDUMP(y1);DUMP(x1);DUMP(ny);DUMP(nx);\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t\t// ifstream cin(\"in\");\n\t\t// ofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t\tif(board[y2][x1]=='#') move[y1][x1][y2][x2]=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[26];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        if('A'<=c[y][x] and c[y][x]<='Z') ps[c[y][x]-'A'].push_back(make_pair(y,x));\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return memo[y1][x1][y2][x2]=0;\n        if(!can_move[y1][x1][y2][x2]) return memo[y1][x1][y2][x2]=-inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[c[y1][x1]-'a']){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 52\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nV v[50][50];\nvoid visit(int x,int y){\n  V &D = v[y][x] = V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  V &D = v[y][x];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  V &D = v[0][0];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP &a,PP &b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if((a.first==b.first||a.second == b.second)||\n     (x1>=0&&y1>=0&&!v[y1][x1][y2][x2])||\n     (!v[Y2][X2][h-1][w-1])||\n     (X1<w&&X2<h&&!v[Y2][X2][Y1][X1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n\n    visit(0,0);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)if(isalpha(mp[i][j]))visit(j,i);\n    \n    mkA();\n    if(!v[0][0][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\nconst int ALP = 26;\n\nconst int N = 50;\nbool reach[N][N][N][N];\nint dp[N][N][N][N];\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        rep(i,N)rep(j,N)rep(k,N)rep(l,N){\n            dp[i][j][k][l] = 0;\n            reach[i][j][k][l] = false;\n        }\n\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> s[ALP],t[ALP];\n        rep(i,h)rep(j,w){\n            char f = c[i][j];\n            if(islower(f)) s[f-'a'].pb({i,j});\n            else if(isupper(f)) t[f-'A'].pb({i,j});\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        rep(i,h)rep(j,w){\n            vector<vector<bool>> vis = BFS({i,j});\n            rep(k,h)rep(l,w) reach[i][j][k][l] = vis[k][l];\n        }\n\n        if(!reach[0][0][h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        for(int y1=h-1; y1>=0; --y1)for(int x1=w-1; x1>=0; --x1){\n            char f = c[y1][x1];\n            if(f == '#') continue;\n            for(int y2=y1; y2<h; ++y2)for(int x2=x1; x2<w; ++x2){\n                if(c[y2][x2] == '#') continue;\n                if(!reach[y1][x1][y2][x2]) continue;\n\n                rep(d,2){\n                    int ny = y1+dy[d], nx = x1+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && reach[ny][nx][y2][x2]){\n                        dp[y1][x1][y2][x2] = max(dp[y1][x1][y2][x2], dp[ny][nx][y2][x2]);\n                    }\n                }\n\n                if(!islower(f)) continue;\n\n                // use jewel\n                int idx = f-'a';\n                for(pi p:t[idx])if(y1<=p.fi && p.fi<=y2 && x1<=p.se && p.se<=x2){\n                    if(abs(y1-p.fi)+abs(x1-p.se)==1){\n                        if(reach[p.fi][p.se][y2][x2]) dp[y1][x1][y2][x2] = max(dp[y1][x1][y2][x2], dp[p.fi][p.se][y2][x2]+1);\n                    }\n                    else{\n                        rep(pd,2)rep(qd,2){\n                            int py = y1+dy[pd], px = x1+dx[pd];\n                            int qy = p.fi-dy[qd], qx = p.se-dx[qd];\n                            if(IN(py,px) && IN(qy,qx) && c[py][px]!='#' && c[qy][qx]!='#' && reach[py][px][qy][qx] && reach[qy][qx][y2][x2]){\n                                dp[y1][x1][y2][x2] = max(dp[y1][x1][y2][x2], dp[py][px][qy][qx]+dp[p.fi][p.se][y2][x2]+1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // rep(i,h)rep(j,w)for(int i2=i; i2<h;++i2)for(int j2=j;j2<w;++j2){\n        //     printf(\"dp[%d][%d][%d][%d] = %d\\n\", i,j,i2,j2, dp[i][j][i2][j2]);\n        // }\n        cout << dp[0][0][h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 10) return 0;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nvector<pair<pint,pint>>lis;\nstring fld[55];\n\nbool vis[55][55][55][55];\nint dp[3000][55][55];\nint memo[3000];//26*10*10\nint dfs(int v){\n    int &ret=memo[v];\n    if(ret!=-1)return ret;\n\n    ret=0;\n    fill_n(*dp[v],55*55,-1001001001);\n    dp[v][lis[v].fi.fi][lis[v].fi.se]=0;\n    int k=0;\n    reps(i,lis[v].fi.fi,lis[v].se.fi+1){\n        reps(j,lis[v].fi.se,lis[v].se.se+1){\n            if(fld[i][j]=='#')continue;\n            if(i+1<=lis[v].se.fi&&fld[i+1][j]!='#')chmax(dp[v][i+1][j],dp[v][i][j]);\n            if(j+1<=lis[v].se.se&&fld[i][j+1]!='#')chmax(dp[v][i][j+1],dp[v][i][j]);\n\n            while(k<lis.size()){\n                bool ok=true;\n                if(lis[k].fi<pint(i,j))ok=false;\n                if(lis[k].fi==pint(i,j)&&(lis[k].se.fi>lis[v].se.fi||lis[k].se.se>lis[v].se.se))ok=false;\n                if(lis[k].fi==lis[v].fi||lis[k].se==lis[v].se)ok=false;\n                if(!ok){\n                    k++;\n                    continue;\n                }\n                if(lis[k].fi==pint(i,j)){\n                    int tmp=dp[v][i][j]+dfs(k)+1;\n                    if(lis[k].se.fi+1<=lis[v].se.fi)chmax(dp[v][lis[k].se.fi+1][lis[k].se.se],tmp);\n                    if(lis[k].se.se+1<=lis[v].se.se)chmax(dp[v][lis[k].se.fi][lis[k].se.se+1],tmp);\n                    k++;\n                }\n                else break;\n            }\n        }\n    }\n\n    return ret=dp[v][lis[v].se.fi][lis[v].se.se];\n}\n\nsigned main(){\n    while(cin>>H>>W,H||W){\n        rep(i,H)cin>>fld[i+1];\n        fld[0]=fld[H+1]=string(W,'#');\n        fld[0][0]=fld[H+1][W-1]='.';\n        H+=2;\n\n        memset(vis,0,sizeof(vis));\n        rep(a,H)rep(b,W){\n            if(fld[a][b]=='#')continue;\n            vis[a][b][a][b]=true;\n            rep(c,H)rep(d,W){\n                if(!vis[a][b][c][d])continue;\n                if(c+1<H&&fld[c+1][d]!='#')vis[a][b][c+1][d]=true;\n                if(d+1<W&&fld[c][d+1]!='#')vis[a][b][c][d+1]=true;\n            }\n        }\n\n        if(!vis[0][0][H-1][W-1]){\n            cout<<-1<<endl;\n            continue;\n        }\n\n        lis.clear();\n        lis.pb(make_pair(pint(0,0),pint(H-1,W-1)));\n        rep(a,H)rep(b,W)rep(c,H)rep(d,W){\n            if(a>c||b>d)continue;\n            if(!islower(fld[a][b])||!isupper(fld[c][d]))continue;\n            if(toupper(fld[a][b])!=fld[c][d])continue;\n            if(vis[a][b][c][d]){\n                lis.pb(make_pair(pint(a,b),pint(c,d)));\n            }\n        }\n\n        sort(all(lis));\n        memset(memo,-1,sizeof(memo));\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(map[sx][sy] == '#' || map[tx][ty] == '#') return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1;\n\tif(map[sx][sy] >= 'a' && map[sx][sy] <= 'z'){\n\t\tint idx = map[sx][sy] - 'a';\n\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\tint tmp = -1, tmp2 = -1, nx = vec[idx][i].first, ny = vec[idx][i].second;\n\t\t\tif( (sx == nx && sy+1 == ny) || (sx+1 == nx && sy == ny) ) tmp = 0;\n\t\t\telse{\n\t\t\t\tif(sx < W && nx > 1) tmp = max(tmp, calc(sx+1, sy, nx-1, ny));\n\t\t\t\tif(sy < H && nx > 1) tmp = max(tmp, calc(sx, sy+1, nx-1, ny));\n\t\t\t\tif(sx < W && ny > 1) tmp = max(tmp, calc(sx+1, sy, nx, ny-1));\n\t\t\t\tif(sy < H && ny > 1) tmp = max(tmp, calc(sx, sy+1, nx, ny-1));\n\t\t\t\tif(tmp == -1) continue;\n\t\t\t}\n\t\t\tif(nx == tx && ny == ty) tmp2 = 0;\n\t\t\telse{\n\t\t\t\tif(nx < W) tmp2 = max(tmp2, calc(nx+1, ny, tx, ty));\n\t\t\t\tif(ny < H) tmp2 = max(tmp2, calc(nx, ny+1, tx, ty));\n\t\t\t\tif(tmp2 == -1) continue;\n\t\t\t}\n\t\t\tret = max(ret, tmp + tmp2 + 1);\n\t\t}\n\t}\n\tif(sx < W) ret = max(ret, calc(sx+1, sy, tx, ty));\n\tif(sy < H) ret = max(ret, calc(sx, sy+1, tx, ty));\n\t\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int sx = 1; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(1, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 4) return 0;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      if(!(y1==sy&&x1==sx)&&!(gy==y2&&gx==x2)){\n\tif(check(y1,x1,sy,sx)&&check(gy,gx,y2,x2)){\n\t  dfs(i,y2,x2);\n\t  res1=max(res1,dp[i][y2][x2]);\n\t}\n      }\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      if(!(y2==sy&&x2==sx)){\n\tif(check(y2,x2,sy,sx)&&check(gy,gx,y,x)){\n\t  dfs(i,y,x);\n\t  res2=max(res2,dp[i][y][x]);\n\t}\n      }\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++){\n\n      if(!check(0,0,rec[i].first.first,rec[i].first.second)) continue;\n      if(!check(rec[i].second.first,rec[i].second.second,h-1,w-1)) continue;\n      \n      dfs(i,h-1,w-1);\n    }\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n \nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n    if(x1>x2||y1>y2)return -20000;\n    if(v[x1][y1]=='#'||v[x2][y2]=='#')return -20000;\n    if(dp[x1][y1][x2][y2]!=-100000){\n        return dp[x1][y1][x2][y2];\n    }\n    if(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n    if(x2-x1==1&&y2-y1==0){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    if(x2-x1==0&&y2-y1==1){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    int tmp = -1000;\n    if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n        tmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n    }\n    tmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n    if(tmp>=0){\n        return dp[x1][y1][x2][y2] = tmp;\n    }\n    return dp[x1][y1][x2][y2] = -20000;\n}\n \nint saiki2(int x1,int y1,int x2,int y2){\n    if(x1>x2||y1>y2)return -1000;\n    if(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n    if(dp2[x1][y1][x2][y2]!=-50000)return dp2[x1][y1][x2][y2];\n    int mx = dp[x1][y1][x2][y2];\n    for(int i=x1;i<=x2;i++){\n        for(int j=y1;j<=y2;j++){\n            if(i==x1&&j==y1)continue;\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i,j+1,x2,y2));\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i+1,j,x2,y2));\n        }\n    }\n    return dp2[x1][y1][x2][y2] = mx;\n \n}\n \nint main() {\n    while(cin >> h >> w && h!=0){\n        vector<string> v(h);\n        rep(i,h){\n            cin >> v[i];\n        }\n        rep(i,51){\n            rep(j,51){\n                rep(k,51){\n                    rep(l,51){\n                        dp[i][j][k][l] = -100000;\n                        dp2[i][j][k][l] = -50000;\n                    }\n                }\n            }\n        }           \n        int ans = saiki(0,0,h-1,w-1,v);\n        ans = saiki2(0,0,h-1,w-1);\n        if(ans>=0){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 50;\nconstexpr int MAX_W = 50;\nconstexpr int MAX_C = 26;\nconstexpr int INF = (1 << 29);\n\nint H, W;\nchar C[MAX_H][MAX_W];\nvector<pair<int, int>> holes[MAX_C];\n\nint mem[MAX_H][MAX_W][MAX_H][MAX_W];\nbool is_reach[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool input()\n{\n    cin >> H >> W;\n    \n    if (H == 0 && W == 0) {\n        return 0;\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> C[i][j];\n        }\n    }\n    \n    return 1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < MAX_C; i++) {\n        holes[i].clear();\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            for (int k = 0; k < H; k++) {\n                for (int l = 0; l < W; l++) {\n                    mem[i][j][k][l] = -1;\n                    is_reach[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n}\n\nvoid fill()\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if ('A' <= C[i][j] && C[i][j] <= 'Z') {\n                holes[C[i][j] - 'A'].emplace_back(j, i);\n            }\n        }\n    }\n}\n\nbool in_field(int x, int y)\n{\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid bfs()\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            is_reach[i][j][i][j] = 1;\n            \n            queue<pair<int, int>> Q;\n            Q.push(make_pair(j, i));\n\n            constexpr int dx[] = {0, 1};\n            constexpr int dy[] = {1, 0};\n            \n            while (!Q.empty()) {\n                int x, y;\n                tie(x, y) = Q.front(); Q.pop();\n\n                for (int k = 0; k < 2; k++) {\n                    int nx = x + dx[k], ny = y + dy[k];\n                    \n                    if (!in_field(nx, ny) || C[ny][nx] == '#') {\n                        continue;\n                    }\n\n                    if (!is_reach[i][j][ny][nx]) {\n                        is_reach[i][j][ny][nx] = 1;\n                        Q.push(make_pair(nx, ny));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint rec(int x1, int y1, int x2, int y2)\n{\n    int& res = mem[y1][x1][y2][x2];\n        \n    if (res != -1) {\n        return res;\n    }\n\n    if (x1 == x2 && y1 == y2) {\n        return res = 0;\n    }\n\n    if (x1 > x2 || y1 > y2) {\n        return -INF;\n    }\n    \n    constexpr int dx[] = {0, 1};\n    constexpr int dy[] = {1, 0};\n    \n    if (C[y1][x1] != '#') {\n        for (int i = 0; i < 2; i++) {\n            int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n            if (in_field(nx1, ny1) && C[ny1][nx1] != '#') {\n                res = max(res, rec(nx1, ny1, x2, y2));\n            }            \n        }\n    }\n    \n    if (islower(C[y1][x1])) {        \n        for (auto& p : holes[C[y1][x1] - 'a']) {\n            int x, y;\n            tie(x, y) = p;\n\n            if (!is_reach[y1][x1][y][x] || !is_reach[y][x][y2][x2]) {\n                continue;\n            }\n\n            if (abs(x1 - x) + abs(y1 - y) == 1) {                \n                res = max(res, rec(x, y, x2, y2) + 1);\n                continue;\n            }\n            \n            for (int i = 0; i < 2; i++) {\n                int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n                for (int j = 0; j < 2; j++) {\n                    int nx = x - dx[j], ny = y - dy[j];\n                    \n                    if (!in_field(nx, ny) || !is_reach[ny1][nx1][ny][nx]) {\n                        continue;\n                    }\n                                        \n                    res = max(res, rec(nx1, ny1, nx, ny) + rec(x, y, x2, y2) + 1);\n                }\n            }\n            \n        }\n    }\n         \n    return res;\n}\n\nint solve()\n{\n    init();\n    fill();\n    bfs();\n\n    if (!is_reach[0][0][H - 1][W - 1]) {\n        return -1;\n    }\n    \n    return rec(0, 0, W - 1, H - 1);    \n}\n\nint main()\n{\n    while (input()) {\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 51\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[2]={1,0};\nconst int dy[2]={0,1};\n\nint h,w;\nstring grid[MAX];\nint mem[MAX][MAX][MAX][MAX];\nbool used[MAX][MAX];\n\nint rec(int a,int b,int c,int d){\n  if(mem[a][b][c][d]!=-1)return mem[a][b][c][d];\n  int res=0;\n  if(grid[a][b]=='#')return -1;\n  FOR(i,a,c){\n    FOR(j,b,d){\n      if(islower(grid[i][j])){\n        queue<pii> q;\n        q.push(mp(i,j));\n        while(q.size()){\n          pii u=q.front();\n          used[u.f][u.s]=true;\n          q.pop();\n          if(grid[i][j]==grid[u.f][u.s]+32){\n            int tmp=rec(u.f,u.s,c,d)+1;\n            res=max(res,rec(i+1,j,u.f+1,u.s)+tmp);\n            res=max(res,rec(i+1,j,u.f,u.s+1)+tmp);\n            res=max(res,rec(i,j+1,u.f+1,u.s)+tmp);\n            res=max(res,rec(i,j+1,u.f,u.s+1)+tmp);\n          }\n          FOR(k,0,2){\n            int ny=u.f+dy[k];\n            int nx=u.s+dx[k];\n            if(c==ny || d==nx)continue;\n            if(grid[ny][nx]=='#')continue;\n            q.push(mp(ny,nx));\n          }\n        }\n      }\n    }\n  }\n  if(!used[c-1][d-1])res=-1;\n  mem[a][b][c][d]=res;\n  return res;\n}\n\nint main()\n{\n  while(cin>>h>>w && h){\n    FOR(i,0,h)cin>>grid[i];\n    memset(mem,-1,sizeof(mem));\n    memset(used,false,sizeof(used));\n    cout<<rec(0,0,h,w)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[505][N][N];\nbool used[505][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      dfs(i,y2,x2);\n      res1=max(res1,dp[i][y2][x2]);\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      dfs(i,y,x);\n      res2=max(res2,dp[i][y][x]);\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++) dfs(i,h-1,w-1);\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W,C;\nchar s[100],a[10000];\nchar t[100][100];\nint id[100][100];\nint INF=1e8;\nmap<string,int> dp[100][100];\nint ans;\n\nint dfs(int y,int x,string s){\n  if(y<0||x<0||y>=H||x>=W||t[y][x]=='#')return -INF;\n  if('a'<=t[y][x]&&t[y][x]<='z')s+=t[y][x];\n  //cout<<y<<' '<<x<<' '<<s<<endl;\n  if(dp[y][x].count(s))return dp[y][x][s];\n  \n  int flg=0;\n  string ns=\"\";\n  if('A'<=t[y][x]&&t[y][x]<='Z'){\n    int k=-1;\n    for(int i=0;i<(int)s.size();i++){\n      if(s[i]-'a'+'A'==t[y][x])k=i;\n    }\n    for(int i=0;i<k;i++)ns+=s[i];\n    if(k!=-1)flg=1;\n    else ns=s;\n  }else ns=s;\n  \n\n  if(y==H-1&&x==W-1){\n    ans=1;\n    return flg;\n  }\n  \n  int res=-INF;//max( dfs(y+1,x,s) , dfs(y,x+1,s) );\n  res=max(res, dfs(y+1,x,ns)+flg);\n  res=max(res, dfs(y,x+1,ns)+flg);\n\n  return dp[y][x][s]=res;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        dp[i][j].clear();\n    \n    for(int i=0;i<H;i++){\n      scanf(\"%s\",s);\n      for(int j=0;j<W;j++){\n        t[i][j]=s[j];\n      }\n    }\n\n    ans=0;\n    int out=dfs(0,0,\"\");\n    if(ans){\n      cout<<out<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vvvb=vector<vvb>;\nusing vvvvb=vector<vvvb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int, int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\nusing Pos=map<char, vector<pii>>;\nusing Visit=vvvvb;\nconstexpr bool cmp(int&a,int l, int r){\n    return l<=a and a<r;\n}\nvvvvi memo;\nvvvvi vis;\nint rec(int sy, int sx, int gy, int gx, vs&f, Pos&mp){\n    if(!cmp(sy,0,f.size()) or !cmp(gy,0,f.size()) or !cmp(sx,0,f[0].size()) or !cmp(gx,0,f[0].size())){\n        return -1;\n    }\n    if(f[sy][sx]=='#' or f[gy][gx]=='#'){\n        return -1;\n    }\n    if(sx>gx or sy>gy or (sx==gx and sy==gy)){\n        return 0;\n    }\n    if(memo[sy][sx][gy][gx]!=INF){\n        return memo[sy][sx][gy][gx];\n    }\n    if(vis[sy][sx][gy][gx]!=1) return -1;\n    int ret=max(rec(sy+1,sx,gy,gx,f,mp), rec(sy,sx+1,gy,gx,f,mp));\n    if(islower(f[sy][sx])){\n        for(auto&to : mp[toupper(f[sy][sx])]){\n            int ty,tx,val=0;\n            tie(ty,tx) = to;\n            if(vis[sy][sx][ty][tx]!=1 or vis[ty][tx][gy][gx]!=1)continue;\n            val += max({rec(sy+1,sx,ty,tx-1,f,mp), rec(sy,sx+1,ty-1,tx,f,mp),\n                        rec(sy+1,sx,ty-1,tx,f,mp), rec(sy,sx+1,ty,tx-1,f,mp)});\n            val += 1+rec(ty,tx,gy,gx,f,mp);\n            chmax(ret, val);\n        }\n    }\n    return memo[sy][sx][gy][gx] = ret;\n}\nbool bfs(int sy, int sx, int gy, int gx, vs&f){\n    if(!cmp(sy,0,f.size()) or !cmp(gy,0,f.size()) or !cmp(sx,0,f[0].size()) or !cmp(gx,0,f[0].size())){\n        return 0;\n    }\n    if(vis[sy][sx][gy][gx]!=-1) return vis[sy][sx][gy][gx];\n    int ret = 0;\n    if(sx>gx or sy>gy or f[sy][sx]=='#' or f[gy][gx]=='#'){\n        ;\n    } else if (sx==gx and sy==gy){\n        ret = f[sy][sx]=='#'?0:1;\n    }else if (sx==gx and sy+1==gy and f[sy][sx]!='#' and f[gy][gx]!='#'\n                or sy==gy and sx+1==gx and f[sy][sx]!='#' and f[gy][gx]!='#'){\n        ret = 1;\n    }else{\n        ret|=bfs(sy+1,sx,gy-1,gx,f);\n        ret|=bfs(sy+1,sx,gy,gx-1,f);\n        ret|=bfs(sy,sx+1,gy-1,gx,f);\n        ret|=bfs(sy,sx+1,gy,gx-1,f);\n    }\n    \n    return vis[sy][sx][gy][gx]=ret;\n}\n/*他のライブラリを入れる場所*/\nint solve(int h, int w){\n    vs f(h);\n    cin>>f;\n    memo=vvvvi(h, vvvi(w, vvi(h, vi(w,INF))));\n    vis=vvvvi(h, vvvi(w, vvi(h, vi(w,-1))));\n    Pos mp;\n    rep(i,h)rep(j,w){\n        if(isalpha(f[i][j])){\n            if(mp.find(f[i][j])==mp.end()){\n                mp[f[i][j]] = vector<pii>();\n            }\n            mp[f[i][j]].emplace_back(i,j);\n        }\n    }\n    rep(i,h)rep(j,w)rep(k,h)rep(l,w)bfs(i,j,k,l,f);\n    return rec(0,0,h-1,w-1,f,mp);\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll h,w;\n    while(cin>>h>>w,h+w){\n        puta(solve(h,w));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n\n        if (not islower(F[sy][sx])) {\n            return cache = max(f(sy + 1, sx, ty, tx), f(sy, sx + 1, ty, tx));\n        }\n\n        int r = 0;\n        for (int y = sy; y <= ty; y++) {\n            for (int x = sx; x <= tx; x++) {\n                if (y == ty && x == tx) continue;\n                r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n            }\n        }\n\n        int d = toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nint main(){\n    int H, W;\n    while(cin >> H >> W && H > 0){\n        const int INF = 100000000;\n\n        string grid[55];\n        REP(y, H) cin >> grid[y];\n\n        map< int, vector<pair<int, int>> > jewels;\n        REP(y, H) REP(x, W) if(isupper(grid[y][x])) {\n            jewels[ grid[y][x] ].push_back(make_pair(x, y));\n        }\n\n        static int dp[55][55][55][55] = {};\n        memset(dp, -1, sizeof(dp));\n\n        function<int(int, int, int, int)> dfs = [&](int sx, int sy, int gx, int gy){\n\n            auto valid = [](int x, int l) { return 0 <= x && x < l; };\n            if(!valid(sx, W) || !valid(sy, H)) return -INF;\n            if(sx > gx || sy > gy) return -INF; // ???\n            if(grid[sy][sx] == '#') return -INF;\n\n            if(sx == gx && sy == gy) return 0;\n\n            int& res = dp[sx][sy][gx][gy];\n            if(res != -1) {\n                return res;\n            }\n\n            res = -INF;\n            auto update = [&](int val) { if(res < val) res = val; };\n\n            update(dfs(sx + 1, sy, gx, gy));\n            update(dfs(sx, sy + 1, gx, gy));\n\n            if(islower(grid[sy][sx])){\n                char c = grid[sy][sx] - 'a' + 'A';\n                for(auto p : jewels[c]){\n                    int ngx = p.first;\n                    int ngy = p.second;\n                    if((sx == ngx && sy + 1 == ngy) || (sy == ngy && sx + 1 == ngx)){\n                        update(1 + dfs(ngx, ngy, gx, gy));\n                    }else if(sx <= ngx && sy <= ngy && ngx <= gx && ngy <= gy){\n                        update(1 + dfs(sx + 1, sy, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(1 + dfs(sx + 1, sy, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                        update(1 + dfs(sx, sy + 1, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(1 + dfs(sx, sy + 1, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                    }\n                }\n            }\n            return res;\n        };\n\n        int res = dfs(0, 0, W - 1, H - 1);\n        if(res < 0) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define srep(i,n,m) for(int i=(int)n;i<=(int)m;i++)\nint n,m;\nint dp[52][52][52][52];\nbool ok[52][52][52][52];\nint inf = 1000000;\nvector<string>s;\nint saiki(int a,int b,int c,int d){\n    if(a<0||a>=n||c<0||c>=n||b<0||b>=m||d<0||d>=m)return -inf;\n    if(s[a][b]=='#'||s[c][d]=='#')return -inf;\n    if(a==c&&b==d)return 0;\n    if(ok[a][b][c][d])return dp[a][b][c][d]; \n    ok[a][b][c][d] = 1;\n    if(a>c||b>d){\n        return dp[a][b][c][d] = -inf;\n    }\n    if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]==s[a][b]+('A'-'a')){\n        if(c==a+1&&b==d)return dp[a][b][c][d]=1;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=1;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c-1,d)+1);\n        tmp = max(tmp,saiki(a+1,b,c,d-1)+1);\n        tmp = max(tmp,saiki(a,b+1,c-1,d)+1);\n        tmp = max(tmp,saiki(a,b+1,c,d-1)+1);\n        srep(i,a,c){\n            srep(j,b,d){\n                if(i==c&&j==d)continue;\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }else{\n        if(c==a+1&&b==d)return dp[a][b][c][d]=0;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=0;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c,d));\n        tmp = max(tmp,saiki(a,b,c-1,d));\n        tmp = max(tmp,saiki(a,b+1,c,d));\n        tmp = max(tmp,saiki(a,b,c,d-1));\n        srep(i,a,c){\n            srep(j,b,d){\n                if(i==c&&j==d)continue;\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }\n}\n\n\nint main(){\n    while(cin >> n >> m &&n!=0){\n        s.resize(n);\n        rep(i,n)cin >> s[i];\n        rep(i,52){\n            rep(j,52){\n                rep(k,52){\n                    rep(l,52){\n                        dp[i][j][k][l] = 0;\n                        ok[i][j][k][l] = 0;\n                    }\n                }\n            }\n        }\n        int ans = saiki(0,0,n-1,m-1);\n        if(ans<0){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nint h, w;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\n// mv[sx][sy][gx][gt] = (sx,sy)->(gx,gy)移動可能か\nll mv[50][50][50][50], dp[50][50][50][50];\nint dx[2] = {1, 0}, dy[2] = {0, 1};\n\nll rec(int sx, int sy, int gx, int gy, const vector<string> &s, map<char, vector<P>> &mp)\n{\n    ll &ret = dp[sx][sy][gx][gy];\n    if (ret != -INF)\n        return ret;\n    if (sx == gx && sy == gy)\n        return ret = 0;\n    if (s[sx][sy] == '#')\n        return ret = -INF / 2;\n    if (mv[sx][sy][gx][gy] != 1)\n        return ret = -INF / 2;\n    if (sx + 1 <= gx && s[sx + 1][sy] != '#' && mv[sx][sy][sx + 1][sy] == 1 && mv[sx + 1][sy][gx][gy] == 1)\n        ret = max(ret, rec(sx + 1, sy, gx, gy, s, mp));\n    if (sy + 1 <= gy && s[sx][sy + 1] != '#' && mv[sx][sy][sx][sy + 1] == 1 && mv[sx][sy + 1][gx][gy] == 1)\n        ret = max(ret, rec(sx, sy + 1, gx, gy, s, mp));\n    if ('a' <= s[sx][sy] && s[sx][sy] <= 'z')\n    {\n        for (auto p : mp[s[sx][sy]])\n        {\n            int x = p.first, y = p.second;\n            if (mv[sx][sy][x][y] != 1 || mv[x][y][gx][gy] != 1)\n                continue;\n            if (x < sx || gx < x || y < sy || gy < y)\n                continue;\n            if (abs(x - sx) + abs(y - sy) == 1)\n            {\n                ret = max(ret, 1 + rec(x, y, gx, gy, s, mp));\n                continue;\n            }\n            for (int i = 0; i < 2; i++)\n            {\n                for (int j = 0; j < 2; j++)\n                {\n                    int nx1 = sx + dx[i], ny1 = sy + dy[i];\n                    int nx2 = x - dx[j], ny2 = y - dy[j];\n                    if (nx1 < sx || x < nx1 || ny1 < sy || y < ny1)\n                        continue;\n                    if (nx2 < sx || x < nx2 || ny2 < sy || y < ny2)\n                        continue;\n                    if (mv[sx][sy][nx1][ny1] != 1 || mv[nx1][ny1][nx2][ny2] != 1 || mv[nx2][ny2][x][y] != 1)\n                        continue;\n                    ret = max(ret, rec(nx1, ny1, nx2, ny2, s, mp) + rec(x, y, gx, gy, s, mp) + 1);\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> h >> w, h || w)\n    {\n        vector<string> s(h);\n        // char -> goal\n        map<char, vector<P>> mp;\n        for (int i = 0; i < h; i++)\n        {\n            cin >> s[i];\n            for (int j = 0; j < w; j++)\n            {\n                if ('A' <= s[i][j] && s[i][j] <= 'Z')\n                    mp[s[i][j] - ('A' - 'a')].emplace_back(i, j);\n            }\n        }\n        for (int sx = 0; sx < h; sx++)\n            for (int sy = 0; sy < w; sy++)\n                for (int gx = 0; gx < h; gx++)\n                    for (int gy = 0; gy < w; gy++)\n                    {\n                        mv[sx][sy][gx][gy] = -INF;\n                        dp[sx][sy][gx][gy] = -INF;\n                    }\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++)\n            {\n                if (s[i][j] == '#')\n                    continue;\n                mv[i][j][i][j] = 1;\n                queue<P> que;\n                que.emplace(i, j);\n                while (!que.empty())\n                {\n                    int x = que.front().first, y = que.front().second;\n                    que.pop();\n                    for (int k = 0; k < 2; k++)\n                    {\n                        int nx = x + dx[k], ny = y + dy[k];\n                        if (nx < 0 || h <= nx || ny < 0 || w <= ny)\n                            continue;\n                        if (mv[i][j][nx][ny] != -INF)\n                            continue;\n                        if (s[nx][ny] == '#')\n                        {\n                            mv[i][j][nx][ny] = 0;\n                            continue;\n                        }\n                        mv[i][j][nx][ny] = 1;\n                        que.emplace(nx, ny);\n                    }\n                }\n            }\n        }\n        int ret = rec(0, 0, h - 1, w - 1, s, mp);\n        cout << (ret < 0 ? -1 : ret) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nint ikeru[52][52][52][52]; \nint dp[52][52][52][52];\nint h,w;\nchar v[52][52];\nvoid reach(int a,int b,int c,int d){\n    if(ikeru[a][b][c][d]!=-1)return;\n    if(v[a][b]=='#'||v[c][d]=='#'){\n        ikeru[a][b][c][d] = 0;\n        return;\n    }\n    if(a>c||b>d){\n        ikeru[a][b][c][d] = 0;\n        return;\n    }\n    if(a==c&&b==d){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    if(a==c&&d==b+1){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    if(c==a+1&&b==d){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    for(int i=a;i<=c;i++){\n        for(int j=b;j<=d;j++){\n            if(i==a&&j==b)continue;\n            if(i==c&&j==d)continue;\n            reach(a,b,i,j);\n            reach(i,j,c,d);\n            if(ikeru[a][b][i][j]==1&&ikeru[i][j][c][d]==1){\n                ikeru[a][b][c][d] = 1;\n            }\n        }\n    }\n    return;\n}\n\nint saiki(int a,int b,int c,int d){\n    if(dp[a][b][c][d]!=-100000){\n        return dp[a][b][c][d];\n    }\n    if(ikeru[a][b][c][d]!=1){\n        return dp[a][b][c][d]=-1000000;\n    }\n    if(a==c&&b==d){\n        return dp[a][b][c][d] = 0;\n    }\n    if(a==c&&d==b+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    if(b==d&&c==a+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    int ans = -222222;\n    if(v[a][b] + 'A'-'a' ==v[c][d]){\n        if(a+1<=c-1)ans = max(ans,1+saiki(a+1,b,c-1,d));\n        if(a+1<=c&&b<=d-1)ans = max(ans,1+saiki(a+1,b,c,d-1));\n        if(a<=c-1&&b+1<=d)ans = max(ans,1+saiki(a,b+1,c-1,d));\n        if(b+1<=d-1)ans = max(ans,1+saiki(a,b+1,c,d-1));        \n    }\n    for(int i=a;i<=c;i++){\n        for(int j=b;j<=d;j++){\n            if(i==c&&j==d)continue;\n            if(i!=c)ans = max(ans,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n            if(j!=d)ans = max(ans,saiki(a,b,i,j)+saiki(i,j+1,c,d));            \n        }\n    }\n    return dp[a][b][c][d]=ans;\n}\n\nint main() {\n    while(cin >> h >> w && h!=0){\n        rep(i,h){\n            string s;\n            cin >> s;\n            rep(j,s.size()){\n                v[i][j] = s[j];\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                rep(k,h){\n                    rep(l,w){\n                        dp[i][j][k][l] = -100000;\n                        ikeru[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                rep(k,h){\n                    rep(l,w){\n                        reach(i,j,k,l);\n                    }\n                }\n            }\n        }\n        if(ikeru[0][0][h-1][w-1]!=1){\n            cout << -1 << endl;\n        }else{\n            int ans = saiki(0,0,h-1,w-1);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint h,w;\nchar B[50][51];\n\nstruct point{ int x,y; };\nvector<point> pos[128];\n\nint dp[50][50][50][50];\nint dfs(int t,int l,int b,int r){\n\tif(h<=t || w<=l || b<0 || r<0\n\t|| B[t][l]=='#' || B[b][r]=='#') return -INF;\n\n\tif(t== b  && l== r\n\t|| t== b  && l==r+1\n\t|| t==b+1 && l== r ) return 0;\n\n\tif(t>b || l>r) return -INF;\n\n\tif(dp[t][l][b][r]!=-1) return dp[t][l][b][r];\n\n\tint res=-INF;\n\tres=max(res,dfs(t+1,l,b,r));\n\tres=max(res,dfs(t,l+1,b,r));\n\tres=max(res,dfs(t,l,b-1,r));\n\tres=max(res,dfs(t,l,b,r-1));\n\tif(islower(B[t][l]) && toupper(B[t][l])==B[b][r]){\n\t\tres=max(res,dfs(t+1,l,b-1,r)+1);\n\t\tres=max(res,dfs(t+1,l,b,r-1)+1);\n\t\tres=max(res,dfs(t,l+1,b-1,r)+1);\n\t\tres=max(res,dfs(t,l+1,b,r-1)+1);\n\t}\n\n\tif(islower(B[t][l])){\n\t\tchar c=B[t][l]-'a'+'A';\n\t\trep(k,pos[c].size()){\n\t\t\tint x=pos[c][k].x,y=pos[c][k].y;\n\t\t\tif(t<=y && y<=b && l<=x && x<=r && !(y==b && x==r)){\n\t\t\t\tres=max(res,dfs(t,l,y,x)+dfs(y,x,b,r));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[t][l][b][r]=res;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&h,&w),h;){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\trep(c,128) pos[c].clear();\n\t\trep(i,h) rep(j,w) pos[B[i][j]].push_back((point){j,i});\n\n\t\trep(t,h) rep(l,w) rep(b,h) rep(r,w) dp[t][l][b][r]=-1;\n\t\tprintf(\"%d\\n\",max(dfs(0,0,h-1,w-1),-1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[4][55][55][55][55];\nbool used[4][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if((c&1)&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif((c&2)&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(2,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(3,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int short\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nV v[50][50];\nvoid visit(int x,int y){\n  V &D = v[y][x] = V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  V &D = v[y][x];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  V &D = v[0][0];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if((a.first==b.first||a.second == b.second)||\n     (x1>=0&&y1>=0&&!v[y1][x1][y2][x2])||\n     (!v[Y2][X2][h-1][w-1])||\n     (X1<w&&X2<h&&!v[Y2][X2][Y1][X1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,(int)(a+b+c+1));\n  }\n  return mem[idx][sta] = res;\n}\n\nmain(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)visit(j,i);\n    \n    mkA();\n    if(!v[0][0][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[55][55][55][55];\nbool used[55][55][55][55];\nbool mv[55][55][55][55];\nbool oc[55][55];\nvector<int> cy[2][30],cx[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='#') continue;\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int sy,int sx,int ty,int tx){\n  //cout<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[sy][sx][ty][tx]) return dp[sy][sx][ty][tx];\n  if(!mv[sy][sx][ty][tx]) return dp[sy][sx][ty][tx]=-1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(oc[cy[0][k][i]][cx[0][k][i]]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(oc[cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\toc[cy[0][k][i]][cx[0][k][i]]=1;\n\toc[cy[1][k][j]][cx[1][k][j]]=1;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0){\n\t  oc[cy[0][k][i]][cx[0][k][i]]=0;\n\t  oc[cy[1][k][j]][cx[1][k][j]]=0;\n\t  continue;\n\t}\n\ttmp+=cur;\n\tcur=dfs(cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0){\n\t  oc[cy[0][k][i]][cx[0][k][i]]=0;\n\t  oc[cy[1][k][j]][cx[1][k][j]]=0;\n\t  continue;\n\t}\n\ttmp+=cur;\n\tcur=dfs(cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0){\n\t  oc[cy[0][k][i]][cx[0][k][i]]=0;\n\t  oc[cy[1][k][j]][cx[1][k][j]]=0;\n\t  continue;\n\t}\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\toc[cy[0][k][i]][cx[0][k][i]]=0;\n\toc[cy[1][k][j]][cx[1][k][j]]=0;\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  used[sy][sx][ty][tx]=1;\n  return dp[sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.clear();\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    memset(oc,0,sizeof(oc));\n    cout<<dfs(0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define srep(i,n,m) for(int i=(int)n;i<=(int)m;i++)\nint n,m;\nint dp[52][52][52][52];\nbool ok[52][52][52][52];\nint inf = 1000000;\nvector<string>s;\nint saiki(int a,int b,int c,int d){\n    if(a<0||a>=n||c<0||c>=n||b<0||b>=m||d<0||d>=m)return -inf;\n    if(s[a][b]=='#'||s[c][d]=='#')return -inf;\n    if(a==c&&b==d)return 0;\n    if(ok[a][b][c][d])return dp[a][b][c][d]; \n    ok[a][b][c][d] = 1;\n    if(a>c||b>d){\n        return dp[a][b][c][d] = -inf;\n    }\n    if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]==s[a][b]+('A'-'a')){\n        if(c==a+1&&b==d)return dp[a][b][c][d]=1;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=1;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c-1,d)+1);\n        tmp = max(tmp,saiki(a+1,b,c,d-1)+1);\n        tmp = max(tmp,saiki(a,b+1,c-1,d)+1);\n        tmp = max(tmp,saiki(a,b+1,c,d-1)+1);\n        srep(i,a,c){\n            srep(j,b,d){\n                if(i==c&&j==d)continue;\n                if(s[i][j]!=s[a][b]+('A'-'a'))continue;\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n            }\n        }\n        \n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }else{\n        if(c==a+1&&b==d)return dp[a][b][c][d]=0;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=0;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c,d));\n        tmp = max(tmp,saiki(a,b,c-1,d));\n        tmp = max(tmp,saiki(a,b+1,c,d));\n        tmp = max(tmp,saiki(a,b,c,d-1));\n        if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]>='A'&&s[c][d]>='Z'){\n            srep(i,a,c){\n                srep(j,b,d){\n                    if(i==c&&j==d)continue;\n                    if(s[i][j]!=s[a][b]+('A'-'a'))continue;\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n                }\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }\n}\n\n\nint main(){\n    while(cin >> n >> m &&n!=0){\n        s.resize(n);\n        rep(i,n)cin >> s[i];\n        rep(i,52){\n            rep(j,52){\n                rep(k,52){\n                    rep(l,52){\n                        dp[i][j][k][l] = 0;\n                        ok[i][j][k][l] = 0;\n                    }\n                }\n            }\n        }\n        int ans = saiki(0,0,n-1,m-1);\n        if(ans<0){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int dy1[4] = {0, 1, 0, 1};\nconst int dx1[4] = {1, 0, 1, 0};\nconst int dy2[4] = {0, 0, -1, -1};\nconst int dx2[4] = {-1, -1, 0, 0};\n\nmap<char, vector<pair<int,int>>> hole;\nchar g[50][50];\nint memo[50][50][51][51]; // init -2\nint solve(int h1, int w1, int h2, int w2){\n    if((h1==h2 and w2-w1<=1) or (w1==w2 and h2-h1<=1)){\n        return 0;\n    }\n    if((h1==h2 and w2-w1>1) or (w1==w2 and h2-h1>1)){\n        return -1;\n    }\n    if(h1>h2 or w1>w2){\n        return -1;\n    }\n\n    int &curr = memo[h1][w1][h2][w2];\n    if(curr != -2) return curr;\n    if(g[h1][w1]=='#' or g[h2-1][w2-1]=='#'){\n        curr = -1;\n        return curr;\n    }\n    curr = -1;\n    // pass\n    for(int d=0; d<2; d++){\n        curr = max(curr, solve(h1+dy1[d], w1+dx1[d], h2, w2));\n    }\n    // get\n    if('a'<=g[h1][w1] and g[h1][w1]<='z'){\n        for(auto p: hole[g[h1][w1]-'a'+'A']){\n            int y = p.first;\n            int x = p.second;\n            if(!(h1<=y and y<h2 and w1<=x and x<w2)) continue;\n            int ret1 = -1;\n            for(int d=0; d<4; d++){\n                ret1 = max(ret1, solve(h1+dy1[d], w1+dx1[d], y+1+dy2[d], x+1+dx2[d]));\n            }\n            int ret2 = -1;\n            for(int d=0; d<4; d++){\n                ret2 = max(ret2, solve(y+dy1[d], x+dx1[d], h2, w2));\n            }\n            if(ret1 != -1 and ret2 != -1){\n                curr = max(curr, ret1+ret2+1);\n            }\n        }\n    }\n    return curr;\n}\n\nint main(){\n    while(1){\n        int h,w;\n        cin >> h >> w;\n        if(h == 0) break;\n\n        hole.clear();\n        rep(i,h) rep(j,w){\n            cin >> g[i][j];\n            if('A'<=g[i][j] and g[i][j]<='Z'){\n                hole[g[i][j]].emplace_back(i, j);\n            }\n        }\n        rep(i,h) rep(j,w) rep(k,h+1) rep(l,w+1){\n            memo[i][j][k][l] = -2;\n        }\n        cout << solve(0, 0, h, w) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int short\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nV v[50][50];\nvoid visit(int x,int y){\n  V &D = v[y][x] = V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  V &D = v[y][x];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  V &D = v[0][0];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if((a.first==b.first||a.second == b.second)||\n     (x1>=0&&y1>=0&&!v[y1][x1][y2][x2])||\n     (!v[Y2][X2][h-1][w-1])||\n     (X1<w&&X2<h&&!v[Y2][X2][Y1][X1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)visit(j,i);\n    \n    mkA();\n    if(!v[0][0][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n  \n  if( ret == -1 ) ret = -(1<<29);\n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x>=W || y>=H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  assert( x1 <= x2 && y1 <= y2 );\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n  \n  if( ret == -1 ) ret = -(1<<29);\n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x>=W || y>=H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nchar C[51][51];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvector<P> G[51][51];\nint dp[52][52][52][52];\n\nint H,W;\n\nint solve(int x1,int y1,int x2,int y2){\n  int &res = dp[x1][y1][x2][y2];\n  if( res != -1 ) return res;\n  res = 0;\n  // cout << \"in \" << x1 << \" \" << y1 << \" \" << C[x1][y1] << \" \"<< x2 << \" \" << y2 << \" \" << C[x2][y2]<< \" \" << res << endl;\n  if( x1 >= W || y1 >= H || x2 >= W || y2 >= H  ) return res;\n  if( x1 == x2 && y1 == y2 ) return res;\n  if( x1 > x2 || y1 > y2 ) return res;\n  if( C[x1][y1] == '#' || C[x2][y2] == '#' ) return res;  \n  if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ){\n    for(int i=0;i<(int)G[x1][y1].size();i++){\n      int mx = G[x1][y1][i].first, my = G[x1][y1][i].second;\n      if( mx > x2 || my > y2 ) continue;\n      for(int j=0;j<2;j++){\n        for(int k=2;k<4;k++){\n          int nx1 = x1 + dx[j], ny1 = y1 + dy[j];\n          int nx2 = mx + dx[k], ny2 = my + dy[k];\n          if( C[nx1][ny1] == '#' || C[nx2][ny2] == '#' ) continue;\n          res = max( res,\n                     solve(nx1,ny1,nx2,ny2) + solve(mx,my,x2,y2) + 1 );\n        }\n      }\n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n    res = max( res, solve(nx1,ny1,x2,y2) );\n  }\n  return res;\n}\n\n\n\nint main(){\n  while( cin >> H >> W && (H||W) ){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin >> C[j][i];\n\n    queue<P> q;\n    int h[51][51]={};\n    q.push(P(0,0) );\n    h[0][0] = 1;\n    while( !q.empty() ){\n      P p = q.front(); q.pop();\n      int x = p.first, y = p.second;\n      for(int i=0;i<2;i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if( nx >= W || ny >= H ) continue;\n        if( h[nx][ny] ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        q.push( P(nx,ny) );\n        h[nx][ny] = 1;\n      }\n    }\n\n    if( !h[W-1][H-1] )\n      cout << -1 << endl;\n    else {\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          for(int k=0;k<H;k++)\n            for(int l=0;l<W;l++)\n              dp[j][i][l][k] = -1;\n\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          G[j][i].clear();\n\n      for(int y1=0;y1<H;y1++)\n        for(int x1=0;x1<W;x1++)\n          if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ) \n            for(int y2=y1;y2<H;y2++)\n              for(int x2=x1;x2<W;x2++)\n                if( C[x2][y2] - C[x1][y1] == 'A' - 'a' ) \n                  G[x1][y1].push_back( P(x2,y2) );\n              \n      // cout << \" in \" << endl;\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    int& res = dp[a.y][a.x][b.y][b.x];\n    if(res != -1) return res;\n    if(b.x + b.y - a.x - a.y == -1) return res = 0;\n    res = -INF;\n    if(range_out(a) || range_out(b) || is_Wall(a) || is_Wall(b) || b < a) return res;\n    if(a == b) return res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return res;\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        int ans = dfs(Point(0, 0), Point(W - 1, H - 1));\n        if(ans == -INF) ans = -1;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<VVV> VVVV;\ntypedef tuple<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint isLC(char c){\n    if('a'<=c&&c<='z')return c-'a';\n    else return -1;\n}\nint isUC(char c){\n    if('A'<=c&&c<='Z')return c-'A';\n    else return -2;\n}\nbool inner(int lb,int c,int ub){\n    return lb<=c&&c<=ub;\n}\nint f(int rbg,int red,int cbg,int ced,vector<string>& s,VVVV &memo,VVP&U){\n    if(memo[rbg][cbg][red][ced]!=-2)return memo[rbg][cbg][red][ced];\n    //cout<<cbg<<\" \"<<ced<<endl;\n    int R=1+red-rbg;\n    int C=1+ced-cbg;\n    VV dp(R,V(C,-1));\n    dp[0][0]=0;\n    int x=isLC(s[rbg][cbg]);\n    int y=isUC(s[red][ced]);\n    if(x==y){\n        s[rbg][cbg]='.';\n        s[red][ced]='.';\n        dp[0][0]++;\n    }\n    for(int r=rbg;r<=red;r++){\n        for(int c=cbg;c<=ced;c++){\n            int i=r-rbg;\n            int j=c-cbg;\n            if(dp[i][j]==-1)continue;\n            int id=isLC(s[r][c]);\n            if(id>=0){\n                for(auto &it:U[id]){\n                    int nr,nc;\n                    tie(nr,nc)=it;\n                    if(inner(r,nr,red)&&inner(c,nc,ced)&&isLC(s[r][c])==isUC(s[nr][nc])){\n                        int val=f(r,nr,c,nc,s,memo,U);\n                        int ni=nr-rbg;\n                        int nj=nc-cbg;\n                        if(val!=-1)\n                            dp[ni][nj]=max(dp[ni][nj],dp[i][j]+val);\n                    }\n                }            \n            }\n            if(r!=red&&s[r+1][c]!='#')dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n            if(c!=ced&&s[r][c+1]!='#')dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n        }     \n    }\n    if(x==y){\n        s[rbg][cbg]=x+'a';\n        s[red][ced]=y+'A';\n    }\n    //cout<<rbg<<\" \"<<red<<\" \"<<dp[R-1][C-1]<<endl;\n    return memo[rbg][cbg][red][ced]=dp[R-1][C-1];\n}\n\n\nint main(){\n    for(int R,C;cin>>R>>C,R+C;){\n        vector<string> s(R);\n        for(auto &it:s)cin>>it;\n        VVP uc(26);\n        for(int i=0;i<R;i++)\n            for(int j=0;j<C;j++){\n                int id=isUC(s[i][j]);\n                if(id>=0)uc[id].push_back(P(i,j));\n            }\n        VVVV memo(R,VVV(C,VV(R,V(C,-2))));\n        cout<<f(0,R-1,0,C-1,s,memo,uc)<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[50];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            if('a'<=c[y][x] and c[y][x]<='z' and 'A'<=c[y_][x_] and c[y_][x_]<='Z' and c[y][x]-'a'==c[y_][x_]-'A') ps[c[y][x]-'a'].push_back(make_pair(y_,x_));\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return memo[y1][x1][y2][x2]=0;\n        if(!can_move[y1][x1][y2][x2]) return memo[y1][x1][y2][x2]=-inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[c[y1][x1]-'a']){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication22.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include <cstdio>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cctype>\n#include<algorithm>\n\nusing namespace std;\n\nint H, W;\nchar C[50][52];\nvector<pair<int, int> > p[256];\nbool memed[52][52][52][52];\nint mem[52][52][52][52];\n\nint rec(int hy, int hx, int ty, int tx) {\n\tif (ty < hy || tx < hx || C[hy][hx] == '#')return -1e9;\n\tif (hy == ty&&hx == tx)return 0;\n\tif (memed[hy][hx][ty][tx]++)return mem[hy][hx][ty][tx];\n\tint mx = max(rec(hy + 1, hx, ty, tx), rec(hy, hx + 1, ty, tx));//??????????????£?????´???\n\tif (islower(C[hy][hx])) {\n\t\tfor (auto e : p[toupper(C[hy][hx])]) {\n\t\t\tif (ty < e.first || tx < e.second || e.first < hy || e.second < hx)continue;\n\t\t\tint sx = -1e9;\n\t\t\tif (hy + 1 == e.first&&hx == e.second || hy == e.first&&hx + 1 == e.second) {\n\t\t\t\tsx = 1;\n\t\t\t}else {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tsx = max(sx, rec(hy + i, hx + (i ^ 1), e.first - j, e.second - (j ^ 1)) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.first == ty&&e.second == tx) {\n\t\t\t\tmx = max(mx, sx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 2; i++) {//00,01->(0,1),(1,0)\n\t\t\t\t\tmx = max(mx, sx + rec(e.first + i, e.second + (i ^ 1), ty, tx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mem[hy][hx][ty][tx] = mx;\n}\n\nint main() {\n\twhile (cin >> H >> W, H | W) {\n\t\tfill(***begin(memed), ***end(memed), false);\n\t\tfor (auto &e : p) {\n\t\t\te.clear();\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> C[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tp[C[i][j]].emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tint ans = rec(0, 0, H - 1, W - 1);\n\t\tcout << ((ans < 0) ? -1 : ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<vector>\n#include<set>\n#include<utility>\n#include<tuple>\n#include<algorithm>\n\nusing namespace std;\n\nbool d[52][52][52][52];\n\nint main(){\n  for(int H,W;cin>>H>>W,H|W;){\n    fill(***begin(d),***end(d),false);\n    char g[52][52];\n    for(int i=0;i<H;i++){\n      cin>>g[i];\n    }\n    set<pair<int,int> > from[52][52];\n    vector<pair<int,int> > pos[256];\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(g[i][j]!='#'){\n\t  pos[g[i][j]].emplace_back(i,j);\n\t  for(auto e:from[i][j]){\n\t    d[e.first][e.second][i][j]=true;\n\t  }\n\t  from[i][j].insert(make_pair(i,j));\n\t  from[i+1][j].insert(begin(from[i][j]),end(from[i][j]));\n\t  from[i][j+1].insert(begin(from[i][j]),end(from[i][j]));\n\t}\n      }\n    }\n    vector<tuple<int,int,int,int,int> > jh;\n    for(char i='a';i<='z';i++){\n      for(auto e:pos[i]){\n\tfor(auto f:pos[toupper(i)]){\n\t  if(d[e.first][e.second][f.first][f.second]){\n\t    jh.emplace_back(f.first-e.first+f.second-e.second,e.first,e.second,f.first,f.second);\n\t  }\n\t}\n      }\n    }\n    sort(begin(jh),end(jh));\n    int s[26000];\n    vector<tuple<int,int,int> > next[52][52];\n    for(int i=0;i<jh.size();i++){\n      s[i]=1;\n      for(int j=0;j<i;j++){\n\tif(d[get<1>(jh[i])][get<2>(jh[i])][get<1>(jh[j])][get<2>(jh[j])]&&d[get<3>(jh[j])][get<4>(jh[j])][get<3>(jh[i])][get<4>(jh[i])]){\n\t  s[i]=max(s[i],s[j]+1);\n\t}\n      }\n      next[get<1>(jh[i])][get<2>(jh[i])].emplace_back(s[i],get<3>(jh[i]),get<4>(jh[i]));\n    }\n    int dp[52][52];\n    fill(*begin(dp),*end(dp),-1e9);\n    dp[0][0]=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(g[i][j]=='#')continue;\n\tif(g[i+1][j]!='#'){\n\t  dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t}\n\tif(g[i][j+1]!='#'){\n\t  dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n\t}\n\tfor(auto e:next[i][j]){\n\t  int ds,ny,nx;\n\t  tie(ds,ny,nx)=e;\n\t  dp[ny][nx]=max(dp[ny][nx],dp[i][j]+ds);\n\t}\n      }\n    }\n    cout<<((dp[H-1][W-1]<0)?-1:dp[H-1][W-1])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define N 55\n\nconst int INF = (int)1e9;\n\nbool adj[N][N][N][N];\nint f[N][N][N][N];\nchar mat[N][N];\nint n, m;\nvector<pair<int, int> > vec[26];\n\nbool ok(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m && mat[x][y] != '#';\n}\n\nint dfs(int lx, int ly, int rx, int ry) {\n\tif (f[lx][ly][rx][ry] != -1) return f[lx][ly][rx][ry];\n\tif (lx > rx || ly > ry) {\n\t\treturn f[lx][ly][rx][ry] = 0;\n\t}\n\tif (!adj[lx][ly][rx][ry]) {\n\t\treturn f[lx][ly][rx][ry] = -INF;\n\t}\t\t\n\n\tint res = 0;\n\n\tif (mat[lx][ly] >= 'a' && mat[lx][ly] <= 'z') {\n\t\tint id = mat[lx][ly] - 'a';\n\t\t\n\t\tfor (int i = 0; i < vec[id].size(); i++) {\n\t\t\tint x = vec[id][i].first, y = vec[id][i].second;\n\t\t\tif (x >= lx && x <= rx && y >= ly && y <= ry) {\n\t\t\t\tif (ok(lx + 1, ly)) {\n\t\t\t\t\tif (ok(x - 1, y)) {\n\t\t\t\t\t\tres = max(res, dfs(lx + 1, ly, x - 1, y) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t\tif (ok(x, y - 1)) {\n\t\t\t\t\t\tres = max(res, dfs(lx + 1, ly, x, y - 1) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ok(lx, ly + 1)) {\n\t\t\t\t\tif (ok(x - 1, y)) {\n\t\t\t\t\t\tres = max(res, dfs(lx, ly + 1, x - 1, y) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t\tif (ok(x, y - 1)) {\n\t\t\t\t\t\tres = max(res, dfs(lx, ly + 1, x, y - 1) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\n\tif (ok(lx + 1, ly)) {\n\t\tres = max(res, dfs(lx + 1, ly, rx, ry));\t\t\n\t}\t\n\tif (ok(lx, ly + 1)) {\n\t\tres = max(res, dfs(lx, ly + 1, rx, ry));\n\t}\n\n\treturn f[lx][ly][rx][ry] = res;\n}\n\nint main() {\n\twhile (~scanf(\"%d%d\", &n, &m)) {\n\t\tif (n + m == 0) break;\n\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tvec[i].clear();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", mat[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (mat[i][j] >= 'A' && mat[i][j] <= 'Z') {\n\t\t\t\t\tint id = mat[i][j] - 'A';\n\t\t\t\t\tvec[id].push_back(make_pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(adj, 0, sizeof(adj));\n\t\tmemset(f, -1, sizeof(f));\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = m - 1; j >= 0; j--) {\n\n\t\t\t\tif (mat[i][j] == '#') continue;\n\n\t\t\t\tfor (int x = i; x < n; x++) {\n\t\t\t\t\tfor (int y = j; y < m; y++) {\n\t\t\t\t\t\tif (ok(i + 1, j)) {\n\t\t\t\t\t\t\tadj[i][j][x][y] |= adj[i + 1][j][x][y];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok(i, j + 1)) {\n\t\t\t\t\t\t\tadj[i][j][x][y] |= adj[i][j + 1][x][y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadj[i][j][i][j] = 1;\t\t\n\t\t\t}\n\t\t}\t\n\n\t\tint res = dfs(0, 0, n - 1, m - 1);\n\n\t\tif (res == -INF)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    int& res = dp[a.y][a.x][b.y][b.x];\n    if(res != -1) return res;\n    if(b.x + b.y - a.x - a.y == -1) return res = 0;\n    res = -INF;\n    if(range_out(a) || range_out(b) || is_Wall(a) || is_Wall(b) || b < a) return res;\n    if(a == b) return res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[0][0] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2538_in1.txt\");\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cctype>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint memo[64][64][64][64];\nbool ok[64][64][64][64];\nchar str[64][64];\nint W, H;\n\nint dy[2] = {0, 1};\nint dx[2] = {1, 0};\n\nvector<P> hole[26];\n\nbool okx(int x)\n{\n\treturn (0 <= x && x < W);\n}\n\nbool oky(int y)\n{\n\treturn (0 <= y && y < H);\n}\n\nint getMax(int y1, int x1, int y2, int x2)\n{\n\tif (y1 > y2 || x1 > x2) return (0);\n\tif (!okx(x1) || !okx(x2) || !oky(y1) || !oky(y2) || !ok[y1][x1][y2][x2]) return (-99999);\n\t\n\tif (memo[y1][x1][y2][x2] >= 0) return (memo[y1][x1][y2][x2]);\n\t\n\tint res = 0;\n\tres = max(res, max(getMax(y1 + 1, x1, y2, x2), getMax(y1, x1 + 1, y2, x2)));\n\t\n\tif (islower(str[y1][x1])){\n\t\tint l = str[y1][x1] - 'a';\n\t\tfor (int i = 0; i < hole[l].size(); i++){\n\t\t\tint ny = hole[l][i].first, nx = hole[l][i].second;\n\t\t\tif (!ok[y1][x1][ny][nx] || y1 > ny || ny > y2 || x1 > nx || nx > x2) continue;\n\t\t\tfor (int d1 = 0; d1 < 2; d1++){\n\t\t\t\tfor (int d2 = 0; d2 < 2; d2++){\n\t\t\t\t\tres = max(res, getMax(y1 + dy[d1], x1 + dx[d1], ny - dy[d2], nx - dx[d2]) + getMax(ny, nx, y2, x2) + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (memo[y1][x1][y2][x2] = res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &H, &W) && W){\n\t\tmemset(memo, -1, sizeof(memo));\n\t\tmemset(ok, 0, sizeof(ok));\n\t\t\n\t\tfor (int i = 0; i < 26; i++) hole[i].clear();\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\", str[i]);\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (isupper(str[i][j])) hole[str[i][j] - 'A'].push_back(P(i, j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pair<P, P> > q;\n\t\t\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tif (str[i][j] != '#'){\n\t\t\t\t\tok[i][j][i][j] = 1;\n\t\t\t\t\tq.push(make_pair(P(i, j), P(i, j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (q.size()){\n\t\t\tpair<P, P> x = q.front(); q.pop();\n\t\t\t\n\t\t\tif (x.second.first + 1 < H && str[x.second.first + 1][x.second.second] != '#'){\n\t\t\t\tif (!ok[x.first.first][x.first.second][x.second.first + 1][x.second.second]++){\n\t\t\t\t\tq.push(make_pair(x.first, P(x.second.first + 1, x.second.second)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x.second.second + 1 < W && str[x.second.first][x.second.second + 1] != '#'){\n\t\t\t\tif (!ok[x.first.first][x.first.second][x.second.first][x.second.second + 1]++){\n\t\t\t\t\tq.push(make_pair(x.first, P(x.second.first, x.second.second + 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getMax(0, 0, H - 1, W - 1) < 0 ? -1 : getMax(0, 0, H - 1, W - 1));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (top == bottom && left == right) return 0;\n\tif (!valid(top, left, h, w) || !valid(bottom, right, h, w)) return 0;\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint res = max(solve(top + 1, left, bottom, right), solve(top, left + 1, bottom, right));\n\tif (islower(fld[top][left]))\n\t{\n\t\tint match = is_pair(fld[top][left], fld[bottom][right]);\n\t\tif (match)\n\t\t{\n\t\t\tres++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t\t{\n\t\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, solve(top, left, i, j) + solve(i, j, bottom, right));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tFOR(i, top, bottom+1)FOR(j, left, right+1)\n\t{\n\t\tif (!islower(fld[i][j]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\tint c = fld[i][j] - 'a';\n\t\tFOR(k, i, bottom+1)FOR(l, j, right+1) \n\t\t{\n\t\t\tif (fld[k][l] != 'A' + c || !edge[i][j][k][l] || !edge[i][j][bottom][right]) continue;\n\t\t\tchmax(res, tmp + solve(top, left, i, j) + solve(i, j, k, l) + solve(k, l, bottom, right));\n\t\t}\n\t}*/\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (!edge[i][j][x + 1][y] && valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (!edge[i][j][x][y + 1] && valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t//int a = is_pair(fld[0][0], fld[h - 1][w - 1]);\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\nbool valid(int x, int l){\n    return 0 <= x && x < l;\n}\nvoid update(int& x, int y){\n    if(x < y) x = y;\n}\n\nint main(){\n    int H, W;\n    while(cin >> H >> W && H > 0){\n        string grid[55];\n        REP(y, H) cin >> grid[y];\n\n        map< int, vector<pair<int, int>> > jewels;\n        REP(y, H) REP(x, W) if(isupper(grid[y][x])) {\n            jewels[ grid[y][x] ].push_back(make_pair(x, y));\n        }\n\n        static int dp[55][55][55][55] = {};\n        memset(dp, -1, sizeof(dp));\n\n        function<int(int, int, int, int)> dfs = [&](int sx, int sy, int gx, int gy){\n            if(!valid(sx, W) || !valid(sy, H)) return -INF;\n            if(sx > gx || sy > gy) return -INF; // ???\n            if(grid[sy][sx] == '#') return -INF;\n\n            if(sx == gx && sy == gy) return 0;\n\n            int& res = dp[sx][sy][gx][gy];\n            if(res != -1) {\n                return res;\n            }\n            res = -INF;\n\n            update(res, dfs(sx + 1, sy, gx, gy));\n            update(res, dfs(sx, sy + 1, gx, gy));\n\n            if(islower(grid[sy][sx])){\n                char c = grid[sy][sx] - 'a' + 'A';\n                for(auto p : jewels[c]){\n                    int ngx = p.first;\n                    int ngy = p.second;\n                    if(sx == ngx && sy + 1 == ngy){\n                        update(res, 1 + dfs(ngx, ngy, gx, gy));\n                    }else if(sy == ngy && sx + 1 == ngx){\n                        update(res, 1 + dfs(ngx, ngy, gx, gy));\n                    }else if(sx <= ngx && sy <= ngy && ngx <= gx && ngy <= gy){\n                        update(res, 1 + dfs(sx + 1, sy, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx + 1, sy, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                    }\n                }\n            }\n            return res;\n        };\n\n        int res = dfs(0, 0, W - 1, H - 1);\n        if(res < 0) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 51\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[2]={1,0};\nconst int dy[2]={0,1};\n\nint h,w;\nstring grid[MAX];\nint mem[MAX][MAX][MAX][MAX];\nbool used[MAX][MAX];\nvector<pii> e[MAX][MAX];\n\nint rec(int a,int b,int c,int d){\n  if(mem[a][b][c][d]!=-1)return mem[a][b][c][d];\n  int res=0;\n  if(grid[a][b]=='#')return res;\n  FOR(i,a,c){\n    FOR(j,b,d){\n      if(islower(grid[i][j])){\n        FOR(k,0,e[i][j].size()){\n          pii u=e[i][j][k];\n          if(c<=u.f || d<=u.s)continue;\n          if(grid[i][j]==grid[u.f][u.s]+32){\n            int tmp=rec(u.f,u.s,c,d);\n            res=max(res,rec(i+1,j,u.f+1,u.s)+tmp+1);\n            res=max(res,rec(i+1,j,u.f,u.s+1)+tmp+1);\n            res=max(res,rec(i,j+1,u.f+1,u.s)+tmp+1);\n            res=max(res,rec(i,j+1,u.f,u.s+1)+tmp+1);\n          }\n        }\n      }\n    }\n  }\n  mem[a][b][c][d]=res;\n  return res;\n}\n\nint solve(){\n  memset(mem,-1,sizeof(mem));\n  memset(used,false,sizeof(used));\n  FOR(i,0,MAX)FOR(j,0,MAX)e[i][j].clear();\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(islower(grid[i][j])){\n        queue<pii> q;\n        bool b[MAX][MAX]={};\n        q.push(mp(i,j));\n        b[i][j]=true;\n        while(q.size()){\n          pii u=q.front();\n          q.pop();\n          used[u.f][u.s]=true;\n          if(grid[i][j]==grid[u.f][u.s]+32)e[i][j].pb(mp(u.f,u.s));\n          FOR(k,0,2){\n            int ny=u.f+dy[k];\n            int nx=u.s+dx[k];\n            if(h==ny || w==nx)continue;\n            if(grid[ny][nx]=='#')continue;\n            if(b[ny][nx])continue;\n            q.push(mp(ny,nx));\n            b[ny][nx]=true;\n          }\n        }\n      }\n    }\n  }\n  if(!used[h-1][w-1])return -1;\n  return rec(0,0,h,w);\n}\n\nint main()\n{\n  while(cin>>h>>w && h){\n    FOR(i,0,h)cin>>grid[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pi;\n\nvector<pi> cont[26];\n\ninline int map(char t){\n\tif(t <= 'z' && t >= 'a') return t - 'a';\n\tif(t <= 'Z' && t >= 'A') return t - 'A' + 26;\n\treturn 10000;\n}\n\nint dp[51][51][51][51];\nbool go[51][51][51][51];\n\nint n, m;\nchar a[55][55];\n\nint f(int sx, int sy, int ex, int ey){\n//\tfprintf(stderr,\"%d %d %d %d\\n\",sx,sy,ex,ey);\n\tif(sx == ex && sy == ey) return 0;\n\tif(sx > ex || sy > ey) return -1e9;\n\tif(!go[ex][ey][sx][sy]) return -1e9;\n\tif(~dp[sx][sy][ex][ey]) return dp[sx][sy][ex][ey];\n\tint ret = 0;\n\tif(go[sx+1][sy][sx][sy]) ret = max(ret, f(sx+1, sy, ex, ey));\n\tif(go[sx][sy+1][sx][sy]) ret = max(ret, f(sx, sy+1, ex, ey));\n\tif(ex && go[ex][ey][ex-1][ey]) ret = max(ret, f(sx, sy, ex-1, ey));\n\tif(ey && go[ex][ey][ex][ey-1]) ret = max(ret, f(sx, sy, ex, ey-1));\n\tif(map(a[sx][sy]) + 26 == map(a[ex][ey])){\n\t\tint ret2 = 0;\n\t\tif(ex && go[sx+1][sy][sx][sy] && go[ex][ey][ex-1][ey]) ret2 = max(ret2, f(sx+1, sy, ex-1, ey));\n\t\tif(ex && go[sx][sy+1][sx][sy] && go[ex][ey][ex-1][ey]) ret2 = max(ret2, f(sx, sy+1, ex-1, ey));\n\t\tif(ey && go[sx+1][sy][sx][sy] && go[ex][ey][ex][ey-1]) ret2 = max(ret2, f(sx+1, sy, ex, ey-1));\n\t\tif(ey && go[sx][sy+1][sx][sy] && go[ex][ey][ex][ey-1]) ret2 = max(ret2, f(sx, sy+1, ex, ey-1));\n\t\tret = max(ret, ret2+1);\n\t}\n\tif(0 <= map(a[sx][sy]) && map(a[sx][sy]) <= 25){\n\t\tfor(auto &i : cont[map(a[sx][sy])]){\n\t\t\tif(go[i.first][i.second][sx][sy] && go[ex][ey][i.first][i.second]){\n\t\t\t\tif(ex == i.first && ey == i.second) continue;\n\t\t\t\tret = max(ret, f(sx, sy, i.first, i.second) + f(i.first, i.second, ex, ey));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[sx][sy][ex][ey] = ret;\n}\n\nvoid solve(){\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%s\",a[i]);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(map(a[i][j]) <= 51 && map(a[i][j]) >= 26){\n\t\t\t\tcont[map(a[i][j]) - 26].push_back(pi(i,j));\n\t\t\t}\n\t\t\tif(a[i][j] == '#') continue;\n\t\t\tgo[i][j][i][j] = 1;\n\t\t\tfor(int k=i; k>=0; k--){\n\t\t\t\tfor(int l=j; l>=0; l--){\n\t\t\t\t\tif(a[k][l] != '#'){\n\t\t\t\t\t\tgo[i][j][k][l] |= (go[i][j][k+1][l] | go[i][j][k][l+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max(-1,f(0,0,n-1,m-1)));\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tmemset(go,0,sizeof(go));\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(int i=0; i<26; i++) cont[i].clear();\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\ninline int dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<(dfs(0,0,h-1,w-1)<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[52];\nint dp[50][50][50][50];\nbool latte[53][53][53][53], malta[53][53][53][53];\n\nint rec(int sy, int gy, int sx, int gx)\n{\n  if(sy >= gy || sx >= gx) return (0);\n  if(sy + 1 == gy && sx + 1 == gx) return (0);\n  int &ret = dp[sy][gy][sx][gx];\n  if(~ret) return (ret);\n  if(S[sy][sx] == '#') return (0);\n  if(sy + 1 < gy && S[sy + 1][sx] != '#') ret = max(ret, rec(sy + 1, gy, sx, gx));\n  if(sx + 1 < gx && S[sy][sx + 1] != '#') ret = max(ret, rec(sy, gy, sx + 1, gx));\n  if(S[sy][sx] == '.' || isupper(S[sy][sx])) return (ret);\n  char c = toupper(S[sy][sx]);\n  latte[sy][sx][gy - 1][gx - 1] = true;\n  for(int i = gy - 1; i >= sy; i--) {\n    for(int j = gx - 1; j >= sx; j--) {\n      if(!latte[sy][sx][i][j]) continue;\n      if(i - 1 >= sy && S[i - 1][j] != '#') latte[sy][sx][i - 1][j] = true;\n      if(j - 1 >= sx && S[i][j - 1] != '#') latte[sy][sx][i][j - 1] = true;\n    }\n  }\n  for(int i = 0; i <= 1; i++) {\n    const int sa = sy + i, sb = sx + 1 - i;\n    if(sa >= gy || sb >= gx || S[sa][sb] == '#') continue;\n    memset(malta[sy][sx], false, sizeof(malta[sy][sx]));\n    malta[sy][sx][sa][sb] = true;\n    for(int j = sa; j < gy; j++) {\n      for(int k = sb; k < gx; k++) {\n        if(!malta[sy][sx][j][k]) continue;\n        if(j + 1 < gy && S[j + 1][k] != '#') malta[sy][sx][j + 1][k] = true;\n        if(k + 1 < gx && S[j][k + 1] != '#') malta[sy][sx][j][k + 1] = true;\n      }\n    }\n    for(int j = sy; j < gy; j++) {\n      for(int k = sx; k < gx; k++) {\n        if(j + 1 < gy && malta[sy][sx][j][k] && c == S[j + 1][k]) {\n          if(j + 1 == gy - 1 && k == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(latte[sy][sx][j + 2][k]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 2, gy, k, gx) + 1);\n          if(latte[sy][sx][j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n        if(k + 1 < gx && (j == sy && k == sx || malta[sy][sx][j][k]) && c == S[j][k + 1]) {\n          if(j == gy - 1 && k + 1 == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(latte[sy][sx][j][k + 2]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j, gy, k + 2, gx) + 1);\n          if(latte[sy][sx][j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n      }\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    memset(latte, false, sizeof(latte));\n    memset(malta, false, sizeof(malta));\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, H, 0, W) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nconst int INF = 3000;\n\nvector<string> field;\nunordered_map<char, vector<pair<int,int>>> holes_of;\nint dp[55][55][55][55];\nbool visited[55][55][55][55];\n\nint calc(int t, int l, int b, int r) {\n    if(visited[t][l][b][r]) return dp[t][l][b][r];\n    if(t > b || l > r) return -INF;\n    if(field[t][l] == '#') return -INF;\n    visited[t][l][b][r] = true;\n    int &res = dp[t][l][b][r];\n    if(t == b && l == r) {\n        return res = 0;\n    } else {\n        res = max(res, calc(t+1, l, b, r));\n        res = max(res, calc(t, l+1, b, r));\n        if(islower(field[t][l])) {\n            // Pick and place\n            for(const auto &to : holes_of[field[t][l]]) {\n                //cout << field[t][l] << ' ' << to.first << ' ' << to.second << endl;\n                res = max(res, calc(t+1, l, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n                res = max(res, calc(t, l+1, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n            }\n        }\n    }\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    if(!(cin >> H >> W)) return false;\n    if(!H && !W) return false;\n\n    field.clear();\n    field.resize(H);\n    holes_of.clear();\n    for(int i = 0; i < H; ++i) {\n        cin >> field[i];\n        for(int j = 0; j < W; ++j) {\n            if(isupper(field[i][j])) {\n                const char c = tolower(field[i][j]);\n                holes_of[c].push_back(make_pair(i, j));\n            }\n        }\n    }\n    fill_n((int*)dp, sizeof(dp)/sizeof(int), -INF);\n    fill_n((bool*)visited, sizeof(visited)/sizeof(bool), false);\n\n    int res = calc(0, 0, H-1, W-1);\n    if(res < 0) res = -1;\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[52];\nint dp[50][50][50][50];\n\nint rec(int sy, int gy, int sx, int gx)\n{\n  if(sy >= gy || sx >= gx) return (0);\n  if(sy + 1 == gy && sx + 1 == gx) return (0);\n  int &ret = dp[sy][gy][sx][gx];\n  if(~ret) return (ret);\n  if(S[sy][sx] == '#') return (0);\n  if(sy + 1 < gy && S[sy + 1][sx] != '#') ret = max(ret, rec(sy + 1, gy, sx, gx));\n  if(sx + 1 < gx && S[sy][sx + 1] != '#') ret = max(ret, rec(sy, gy, sx + 1, gx));\n  if(S[sy][sx] == '.' || isupper(S[sy][sx])) return (ret);\n  char c = toupper(S[sy][sx]);\n  bool v1[53][53] = {{}}, v2[53][53];\n  v1[gy - 1][gx - 1] = true;\n  for(int i = gy - 1; i >= sy; i--) {\n    for(int j = gx - 1; j >= sx; j--) {\n      if(!v1[i][j]) continue;\n      if(i - 1 >= sy && S[i - 1][j] != '#') v1[i - 1][j] = true;\n      if(j - 1 >= sx && S[i][j - 1] != '#') v1[i][j - 1] = true;\n    }\n  }\n  for(int i = 0; i <= 1; i++) {\n    const int sa = sy + i, sb = sx + 1 - i;\n    if(sa >= gy || sb >= gx || S[sa][sb] == '#') continue;\n    memset(v2, false, sizeof(v2));\n    v2[sa][sb] = true;\n    for(int j = sa; j < gy; j++) {\n      for(int k = sb; k < gx; k++) {\n        if(!v2[j][k]) continue;\n        if(j + 1 < gy && S[j + 1][k] != '#') v2[j + 1][k] = true;\n        if(k + 1 < gx && S[j][k + 1] != '#') v2[j][k + 1] = true;\n      }\n    }\n    for(int j = sy; j < gy; j++) {\n      for(int k = sx; k < gx; k++) {\n        if(j + 1 < gy && v2[j][k] && c == S[j + 1][k]) {\n          if(j + 1 == gy - 1 && k == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j + 2][k]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 2, gy, k, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n        if(k + 1 < gx && (j == sy && k == sx || v2[j][k]) && c == S[j][k + 1]) {\n          if(j == gy - 1 && k + 1 == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j][k + 2]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j, gy, k + 2, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n      }\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, H, 0, W) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint tmp = is_pair(fld[top][left], fld[bottom][right]);\n\tint res = tmp;\n\tFOR(i, top, bottom+1)FOR(j, left, right+1)\n\t{\n\t\tif (!islower(fld[i][j]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\tint c = fld[i][j] - 'a';\n\t\tFOR(k, i, bottom+1)FOR(l, j, right+1) \n\t\t{\n\t\t\tif (fld[k][l] != 'A' + c || !edge[i][j][k][l] || !edge[i][j][bottom][right]) continue;\n\t\t\tchmax(res, tmp + solve(top, left, i, j) + solve(i, j, k, l) + solve(k, l, bottom, right));\n\t\t}\n\t}\n\tif (tmp == 0)\n\t{\n\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t{\n\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\tFOR(k, i, bottom + 1)FOR(l, j, right + 1)\n\t\t\t{\n\t\t\t\tif (!edge[i][j][k][l] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, tmp + solve(top, left, i, j) + solve(i, j, k, l) + solve(k, l, bottom, right));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    int& res = dp[a.y][a.x][b.y][b.x];\n    if(res != -2) return res;\n    res = -INF;\n    if(range_out(a) || range_out(b) || is_Wall(a) || is_Wall(b)) return res;\n    if(b < a) return res = -1;\n    if(a == b) return res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[0][0] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2538_in1.txt\");\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        rep(i, H) rep(j, W) rep(k, H) rep(l, W)\n          dp[i][j][k][l] = -2;\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[26],t[26];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        vector<bool> as_start(n), as_goal(n);\n\n        rep(i,n) as_start[i] = reach_check[p[i].fi][p[i].se];\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n\n            mv[i][i] = false;\n            as_goal[i] = vis[h-1][w-1];\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,26){\n            for(int from:s[i])for(int to:t[i]){\n                if(mv[from][to]) dp[from][to] = 1;\n            }\n        }\n\n        rep(loop,53){\n            rep(i,26)for(int from:s[i])for(int to:t[i]){\n                if(!mv[from][to]) continue;\n\n                rep(j,26){\n                    for(int x:s[j]){\n                        if(!mv[from][x]) continue;\n                        for(int y:t[j]){\n                            if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> dp2(h,vector<int>(w,-1));\n        dp2[0][0] = 0;\n        rep(i,h)rep(j,w){\n            rep(d,2){\n                int ni = i+dy[d], nj = j+dx[d];\n                if(IN(ni,nj) && c[ni][nj]!='#') dp2[ni][nj] = max(dp2[ni][nj], dp2[i][j]);\n            }\n\n            if(islower(c[i][j])){\n                int from = p2id[{i,j}];\n                for(int to:t[c[i][j]-'a']){\n                    if(mv[from][to]){\n                        dp2[p[to].fi][p[to].se] = max(dp2[p[to].fi][p[to].se], dp2[i][j]+dp[from][to]);\n                    }\n                }\n            }\n        }\n        cout << dp2[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ConsoleApplication22.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include <cstdio>\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<cctype>\n#include<algorithm>\n\nusing namespace std;\n\nint H, W;\nchar C[50][52];\nvector<pair<int, int> > p[256];\nbool memed[52][52][52][52];\nint mem[52][52][52][52];\n\nint rec(int hy, int hx, int ty, int tx) {\n\tif (ty < hy || tx < hx || C[hy][hx] == '#')return -1e9;\n\tif (hy == ty&&hx == tx)return 0;\n\tif (memed[hy][hx][ty][tx]++)return mem[hy][hx][ty][tx];\n\tint mx = max(rec(hy + 1, hx, ty, tx), rec(hy, hx + 1, ty, tx));//??????????????£?????´???\n\tif (islower(C[hy][hx])) {\n\t\tfor (auto e : p[toupper(C[hy][hx])]) {\n\t\t\tif (ty < e.first || tx < e.second || e.first < hy || e.second < hx)continue;\n\t\t\tint sx = -1e9;\n\t\t\tif (hy + 1 == e.first&&hx == e.second || hy == e.first&&hx + 1 == e.second) {\n\t\t\t\tsx = 1;\n\t\t\t}else {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tsx = max(sx, rec(hy + i, hx + (i ^ 1), e.first - j, e.second - (j ^ 1)) + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e.first == ty&&e.second == tx) {\n\t\t\t\tmx = max(mx, sx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 2; i++) {//00,01->(0,1),(1,0)\n\t\t\t\t\tmx = max(mx, sx + rec(e.first + i, e.second + (i ^ 1), ty, tx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mem[hy][hx][ty][tx] = mx;\n}\n\nint main() {\n\twhile (cin >> H >> W, H | W) {\n\t\tfill(***begin(memed), ***end(memed), false);\n\t\tfor (auto &e : p) {\n\t\t\te.clear();\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> C[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tp[C[i][j]].emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tint ans = rec(0, 0, H - 1, W - 1);\n\t\tcout << ((ans < 0) ? -1 : ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 1) return 0;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[55][55][55][55];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n  ret = -(1<<29);\n\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      if( p.first == x2 && p.second == y2 ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        // cout << x1 << \", \"<< y1 << \" -> \" << nx << \", \"<< ny << \" : \" << p.first << \", \" << p.second << \" -> \" << x2 << \", \"<< y2 << endl;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n\n  //cout << x1 << \", \"<< y1 << \" - \"<<x2 << \", \"<< y2 << \" :\" << ret << endl;\n   \n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W+1 && y == H+1 ) return true;\n  if( x>W+1 || y>H+1 ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<=H;i++)\n      for(int j=0;j<=W;j++)\n        C[j][i] = '#';\n    C[0][0] = '.';\n    C[0][1] = '.';\n    C[1][0] = '.';\n    C[W+1][H+1] = '.';\n    C[W+1][H] = '.';\n    C[W][H+1] = '.';\n\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      int res = solve(0,0,W+1,H+1);\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint H,W;\nvector<pair<pint,pint>>lis;\nstring fld[55];\n\nbool vis[55][55][55][55];\n\ninline bool reach(const pint &s,const pint &t){\n    return vis[s.fi][s.se][t.fi][t.se];\n}\n\nint dp[3000][55][55];\nint memo[3000];//26*10*10\nint dfs(int v){\n    int &ret=memo[v];\n    if(ret!=-1)return ret;\n\n    ret=0;\n    fill_n(*dp[v],55*55,-1001001001);\n    dp[v][lis[v].fi.fi][lis[v].fi.se]=0;\n    int k=0;\n    reps(i,lis[v].fi.fi,lis[v].se.fi+1){\n        reps(j,lis[v].fi.se,lis[v].se.se+1){\n            if(fld[i][j]=='#')continue;\n            if(i+1<=lis[v].se.fi&&fld[i+1][j]!='#')chmax(dp[v][i+1][j],dp[v][i][j]);\n            if(j+1<=lis[v].se.se&&fld[i][j+1]!='#')chmax(dp[v][i][j+1],dp[v][i][j]);\n\n            while(k<lis.size()){\n                bool ok=true;\n                if(lis[k].fi<pint(i,j))ok=false;\n                if(lis[k].fi==pint(i,j)&&(lis[k].se.fi>lis[v].se.fi||lis[k].se.se>lis[v].se.se))ok=false;\n                if(!ok){\n                    k++;\n                    continue;\n                }\n                if(lis[k].fi==pint(i,j)){\n                    int tmp=dp[v][i][j]+dfs(k)+1;\n                    if(lis[k].se.fi+1<=lis[v].se.fi)chmax(dp[v][lis[k].se.fi+1][lis[k].se.se],tmp);\n                    if(lis[k].se.se+1<=lis[v].se.se)chmax(dp[v][lis[k].se.fi][lis[k].se.se+1],tmp);\n                    k++;\n                }\n                else break;\n            }\n        }\n    }\n\n    return ret=dp[v][lis[v].se.fi][lis[v].se.se];\n}\n\nsigned main(){\n    while(cin>>H>>W,H||W){\n        rep(i,H)cin>>fld[i+1];\n        fld[0]=fld[H+1]=string(W,'#');\n        fld[0][0]=fld[H+1][W-1]='.';\n        H+=2;\n\n        memset(vis,0,sizeof(vis));\n        rep(a,H)rep(b,W){\n            if(fld[a][b]=='#')continue;\n            vis[a][b][a][b]=true;\n            rep(c,H)rep(d,W){\n                if(!vis[a][b][c][d])continue;\n                if(c+1<H&&fld[c+1][d]!='#')vis[a][b][c+1][d]=true;\n                if(d+1<W&&fld[c][d+1]!='#')vis[a][b][c][d+1]=true;\n            }\n        }\n\n        if(!vis[0][0][H-1][W-1]){\n            cout<<-1<<endl;\n            continue;\n        }\n\n        lis.clear();\n        lis.pb(make_pair(pint(0,0),pint(H-1,W-1)));\n        rep(a,H)rep(b,W)rep(c,H)rep(d,W){\n            if(a>c||b>d)continue;\n            if(!islower(fld[a][b])||!isupper(fld[c][d]))continue;\n            if(toupper(fld[a][b])!=fld[c][d])continue;\n            if(vis[a][b][c][d]){\n                lis.pb(make_pair(pint(a,b),pint(c,d)));\n            }\n        }\n\n        sort(all(lis));\n\n        memset(memo,-1,sizeof(memo));\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 260;\nconst int K = 555;\nint ok[K][K];\nvector<int> G[K];\n\nint id[55][55];\nchar field[55][55];\nint visit[55][55];\n\nchar ch[K];\nint dp[K][K][2][2];\n\ninline int check(int c1, int c2){\n\treturn ch[c1] - 'a' + 'A' == ch[c2];\n}\n\nint rec(int l, int r, int a, int b){\n\tif (r - l <= 1) return check(l, r);\n\tint &res = dp[l][r][a][b];\n\tif (res + 1) return res;\n\tres = 0;\n\n\tif (!a && !b && check(l, r)){\n\t\tres = 1 + rec(l, r, 1, 1);\n\t}\n\n\tfor (int k = l + 1; k < r; ++k){\n\t\tif (ok[l][k] && ok[k][r]){\n\t\t\tres = max(res, rec(l, k, a, 1) + rec(k, r, 0, b));\n\t\t\tres = max(res, rec(l, k, a, 0) + rec(k, r, 1, b));\n\t\t}\n\t}\n\treturn res;\n}\n\nint h, w;\nvoid dfs(int r, int c, int v){\n\tvisit[r][c] = 1;\n\trep(i, 2){\n\t\tint nr = r + i, nc = c + !i;\n\t\tif (nr < 0 || nc < 0 || nr >= h || nc >= w) continue;\n\t\tif (field[nr][nc] == '#') continue;\n\t\tif (visit[nr][nc]) continue;\n\t\tif (id[nr][nc] >= 0){\n\t\t\tG[v].push_back(id[nr][nc]);\n\t\t\tok[v][id[nr][nc]] = 1;\n\t\t}\n\t\tdfs(nr, nc, v);\n\t}\n}\n\nvoid tdfs(int v, vector<int> &visit, vector<int> &res){\n\tvisit[v] = 1;\n\tfor (auto to : G[v]){\n\t\tif (visit[to]) continue;\n\t\ttdfs(to, visit, res);\n\t}\n\tres.push_back(v);\n}\n\nvector<int> tsort(int n){\n\tvector<int> vis(n), res;\n\trep(i, n) tdfs(i, vis, res);\n\treverse(ALL(res));\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\twhile (cin >> h >> w, h){\n\t\trep(i, h) cin >> field[i];\n\t\trep(i, w) field[h][w] = \"#.\"[i == w - 1];\n\t\t++h;\n\n\t\tMEMSET(id, -1);\n\t\tMEMSET(ch, 0);\n\t\tint num = 0;\n\t\trep(i, h) rep(j, w){\n\t\t\tif (isupper(field[i][j]) || islower(field[i][j])){\n\t\t\t\tch[num] = field[i][j];\n\t\t\t\tid[i][j] = num++;\n\t\t\t}\n\t\t}\n\t\tint SRC = num++;\n\t\tint SNK = num++;\n\t\tid[h - 1][w - 1] = SNK;\n\n\t\tMEMSET(visit, 0);\n\t\tMEMSET(ok, 0);\n\t\trep(i, num) G[i].clear();\n\t\tdfs(0, -1, SRC);\n\t\trep(i, h) rep(j, w){\n\t\t\tif (id[i][j] >= 0){\n\t\t\t\tMEMSET(visit, 0);\n\t\t\t\tdfs(i, j, id[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tif (!ok[SRC][SNK]){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto ord = tsort(num);\n\t\tMEMSET(dp, -1);\n\n\t\tcout << rec(0, SNK, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1;\n  if(ly>=ry&&lx>=rx)return 0;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<dfs(0,0,h-1,w-1)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint dp[52][52][52][52];\nint v[52][52][52][52];\nint r[600];\nint w[600];\nint sz;\nint H,W;\nint solve(int a,int b,int c,int d){\n\tif(a>c||b>d)return 0;\n\tif(~dp[a][b][c][d])return dp[a][b][c][d];\n\tif(a==c&&b==d)return dp[a][b][c][d]=0;\n\tint ret=0;\n\tif(str[a][b]-32==str[c][d]){\n\t\tif(v[a][b][c][d])ret=1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])&&\n\t\t\t\tv[r[j]][w[j]][c][d]&&(c!=r[j]||d!=w[j])){\n\t\t\t\t\tret=max(ret,solve(r[i],w[i],r[j],w[j])+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])){\n\t\t\tret=max(ret,solve(r[i],w[i],c,d));\n\t\t}\n\t\tif(v[r[i]][w[i]][c][d]&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&v[r[i]][w[i]][c][d]&&(a!=r[i]||b!=w[i])&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i],w[i],c,d));\n\t\t}\n\t}\n\t//printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\tv[i][j][k][l]=0;\n\t\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'&&str[i][j]!='#'){\n\t\t\t\t\tr[sz]=i;w[sz++]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tv[i][j][i][j]=1;\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tif(str[k][l]=='#')continue;\n\t\t\t\tif(k&&v[i][j][k-1][l])v[i][j][k][l]=1;\n\t\t\t\tif(l&&v[i][j][k][l-1])v[i][j][k][l]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=solve(0,0,a-1,b-1);\n\t\tif(!v[0][0][a-1][b-1])printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint dist[55][55][55][55];\nint ans[55][55];\n\nint h,w;\nstring board[55];\nusing state=tuple<int,int,int,int>;\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\n\nint main(void){\n\twhile(cin >> h >> w,h){\n\t\trep(i,h) cin >> board[i];\n\t\tclr(dist,-1);\n\n\t\tdeque<state> q;\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif(board[i][j]=='#') continue;\n\t\t\tdist[i][j][i][j]=0;\n\t\t\tq.push_back(state(i,j,i,j));\n\t\t}\n\t\n\t\twhile(!q.empty()){\n\t\t\tint a,b,c,d;\n\t\t\ttie(a,b,c,d)=q.front();q.pop_front();\n\t\t\t\n\t\t\trep(i,2){\n\t\t\t\tint na=a+dx[i],nb=b+dy[i];\n\t\t\t\tif(na<0||h<=na||nb<0||w<=nb) continue;\n\t\t\t\tif(board[na][nb]=='#') continue;\n\t\t\t\tif(chmax(dist[na][nb][c][d],dist[a][b][c][d]))\n\t\t\t\t\tq.push_front(state(na,nb,c,d));\n\t\t\t}\n\t\t\trep(j,2){\n\t\t\t\tint nc=c+dx[j+2],nd=d+dy[j+2];\n\t\t\t\tif(nc<0||h<=nc||nd<0||w<=nd) continue;\n\t\t\t\tif(board[nc][nd]=='#') continue;\n\n\t\t\t\tbool add=false;\n\t\t\t\tif(islower(board[a][b])&&isupper(board[nc][nd])&&toupper(board[a][b])==board[nc][nd]) add=true;\n\t\t\t\tif(chmax(dist[a][b][nc][nd],dist[a][b][c][d]+add))\n\t\t\t\t\tq.push_front(state(a,b,nc,nd));\n\t\t\t}\n\t\t}\n\n\t\tclr(ans,-1);\n\t\tans[0][0]=0;\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif(board[i][j]=='#') continue;\n\t\t\tif(i-1>=0 && board[i-1][j]!='#') chmax(ans[i][j],ans[i-1][j]);\n\t\t\tif(j-1>=0 && board[i][j-1]!='#') chmax(ans[i][j],ans[i][j-1]);\n\t\t\trep(ni,i,h)rep(nj,j,w) chmax(ans[ni][nj],ans[i][j]+dist[i][j][ni][nj]);\n\t\t}\n\n\t\tcout << ans[h-1][w-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W;\nstring s[50];\nint memo[50][50][50][50];\nbool vis[50][50][50][50];\nint dx[3]={1,0,0},dy[3]={0,1,0};\ninline bool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nint rec(int a,int b,int c,int d){\t//(a,b)->(c,d)\n\tif(!is(a,b)||!is(c,d)||a>c||b>d) return -1;\n\tif(vis[a][b][c][d]) return memo[a][b][c][d];\n\tvis[a][b][c][d]=1;\n\tint &val=memo[a][b][c][d];\n\tif(c+d-b-a==0){\n\t\treturn val=0;\n\t}\n\tif(c+d-b-a==1){\n\t\tif(s[a][b]-'a'==s[c][d]-'A') return val=1;\n\t\telse return val=0;\n\t}\n\trep(di,3) rep(dj,3){\n\t\tif(di==2&&dj==2) continue;\n\t\tint na=a+dx[di],nb=b+dy[di],nc=c-dx[dj],nd=d-dy[dj];\n\t\tint bo=0;\n\t\tif(islower(s[a][b])&&s[a][b]-'a'==s[c][d]-'A'&&di!=2&&dj!=2) bo=1;\n\t\tint tmp=rec(na,nb,nc,nd);\n\t\tif(tmp>=0) chmax(val,tmp+bo);\n\t}\n\treturn val;\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\trep(i,H) cin>>s[i];\n\t\trep(a,H) rep(b,W) rep(c,H) rep(d,W) memo[a][b][c][d]=-1,vis[a][b][c][d]=0;\n\t\tint tmp=rec(0,0,H-1,W-1);\n\t\tif(tmp<0){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint dp[100][100]={};\n\t\trep(i,H) rep(j,W) dp[i][j]=-1;\n\t\tdp[0][0]=0;\n\t\trep(i,H) rep(j,W){\n\t\t\tif(dp[i][j]<0) continue;\n\t\t\tfor(int x=i;x<H;x++) for(int y=j;y<W;y++){\n\t\t\t\tif(x==i&&y==j) continue;\n\t\t\t\tif(memo[i][j][x][y]<0) continue;\n\t\t\t\tchmax(dp[x][y],dp[i][j]+memo[i][j][x][y]);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[H-1][W-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[50][50][50][50],dx[2][4]={{1,0,1,0},{-1,0,0,-1}},dy[2][4]={{0,1,0,1},{0,-1,-1,0}},u[50][50],INF=1<<29;\nstring s[50];\nvector<P> v[26];\n\nint dfs(int x1,int y1,int x2,int y2) {\n  if(x1==x2&&y1==y2) return 0;\n  if(dp[x1][y1][x2][y2]>=0) return dp[x1][y1][x2][y2];\n  dp[x1][y1][x1][y1]=0;\n  for(int i=x1;i<=x2;i++) {\n    for(int j=y1;j<=y2;j++) {\n      if(s[i][j]=='#') continue;\n      if(i!=x1&&s[i-1][j]!='#') dp[x1][y1][i][j]=max(dp[x1][y1][i][j],dp[x1][y1][i-1][j]);\n      if(j!=y1&&s[i][j-1]!='#') dp[x1][y1][i][j]=max(dp[x1][y1][i][j],dp[x1][y1][i][j-1]);\n      if(islower(s[i][j])) {\n        int c=s[i][j]-'a';\n        for(int l=0; l<v[c].size(); l++) {\n          int x=v[c][l].first,y=v[c][l].second;\n          if(P(i,j+1)==P(x,y)||P(i+1,j)==P(x,y)) {\n            if(i!=x1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i-1][j]+1);\n            if(j!=y1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i][j-1]+1);\n            if(i==x1&&j==y1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i][j]+1);\n          }\n          for(int k=0; k<4; k++) {\n            int xx1=i+dx[0][k],yy1=j+dy[0][k];\n            int xx2=x+dx[1][k],yy2=y+dy[1][k];\n            if(xx1>xx2||yy1>yy2) continue;\n            if(xx1<x1||xx1>x2||xx2<x1||xx2>x2) continue;\n            if(yy1<y1||yy1>y2||yy2<y1||yy2>y2) continue;\n            if(s[xx1][yy1]=='#'||s[xx2][yy2]=='#') continue;\n            if(i!=x1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i-1][j]+dfs(xx1,yy1,xx2,yy2)+1);\n            if(j!=y1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i][j-1]+dfs(xx1,yy1,xx2,yy2)+1);\n            if(i==x1&&j==y1) dp[x1][y1][x][y]=max(dp[x1][y1][x][y],dp[x1][y1][i][j]+dfs(xx1,yy1,xx2,yy2)+1);\n          }\n        }\n      }\n    }\n  }\n  return dp[x1][y1][x2][y2];\n}\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)for(int k=0;k<n;k++)for(int l=0;l<m;l++)dp[i][j][k][l]=-INF;\n    for(int i=0;i<26;i++)v[i].clear();\n    memset(u,0,sizeof(u));\n    u[0][0]=1;\n    for(int i=0; i<n; i++) {\n      cin >> s[i];\n      for(int j=0; j<m; j++) if(isupper(s[i][j])) v[s[i][j]-'A'].push_back(P(i,j));\n    }\n    int ans=dfs(0,0,n-1,m-1);\n    if(ans<0) ans=-1;\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[4][55][55][55][55];\nbool used[4][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return 0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if((c&1)&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif((c&2)&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(2,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(3,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0};\nconst int dy[] = {0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst int MAX = 55;\n\nstring board[MAX];\nint dp[MAX][MAX][MAX][MAX];\nbool can[MAX][MAX][MAX][MAX];\nvector<pii> pnts[33];\nint H, W;\n\nint dfs(int y1, int x1, int y2, int x2) {\n\tint& ret = dp[y1][x1][y2][x2];\n\tif (ret != -1) return ret;\n\tif (y1 == y2 && x1 == x2) return ret = 0;\n\tret = -INF;\n\tchar c = board[y1][x1];\n\tif (c == '#') return ret;\n\t// ??????????????????????????????\n\tif (y1 + 1 <= y2 && board[y1 + 1][x1] != '#') {\n\t\tret = max(ret, dfs(y1 + 1, x1, y2, x2));\n\t}\n\tif (x1 + 1 <= x2 && board[y1][x1 + 1] != '#') {\n\t\tret = max(ret, dfs(y1, x1 + 1, y2, x2));\n\t}\n\tif ('a' <= c && c <= 'z') {\n\t\t// ???????????????????????§??????\n\t\tint index = c - 'a';\n\t\tfor (auto p : pnts[index]) {\n\t\t\tint ny = p.first, nx = p.second;\n\t\t\tif (ny > y2 || nx > x2) continue;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tint ny1 = y1 + dy[i], nx1 = x1 + dx[i];\n\t\t\t\tif (ny1 > y2 || nx1 > x2) continue;\n\t\t\t\tif (!can[ny1][nx1][ny][nx]) continue;\n\t\t\t\tret = max(ret, 1 + dfs(ny1, nx1, ny, nx) + dfs(ny, nx, y2, x2));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> H >> W) {\n\t\tif (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tcin >> board[i];\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tpnts[i].clear();\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tchar c = board[i][j];\n\t\t\tif ('A' <= c && c <= 'Z') {\n\t\t\t\tpnts[c - 'A'].emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tmemset(can, false, sizeof(can));\n\t\tfor (int y = H - 1; y >= 0; y--) for (int x = W - 1; x >= 0; x--) {\n\t\t\tif (board[y][x] == '#') continue;\n\t\t\tcan[y][x][y][x] = true;\n\t\t\tif (y + 1 < H && board[y + 1][x] != '#') {\n\t\t\t\tfor (int y1 = y + 1; y1 < H; y1++) for (int x1 = x; x1 < W; x1++) {\n\t\t\t\t\tcan[y][x][y1][x1] |= can[y + 1][x][y1][x1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x + 1 < W && board[y][x + 1] != '#') {\n\t\t\t\tfor (int y1 = y; y1 < H; y1++) for (int x1 = x + 1; x1 < W; x1++) {\n\t\t\t\t\tcan[y][x][y1][x1] |= can[y][x + 1][y1][x1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tint ans = dfs(0, 0, H - 1, W - 1);\n\t\tif (ans < 0) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint h,w;\nint dp[55][55][55][55];\nstring s[55];\nvector<P> nxt[55][55];\n\nint dfs(int i1,int j1,int i2,int j2){\n\n  if(s[i1][j1]=='#')return -INF;\n  if(i1==i2&&j1==j2)return 0;\n  if(dp[i1][j1][i2][j2]!=-1)return dp[i1][j1][i2][j2];\n\n  if((i1+1==i2&&j1==j2)||(i1==i2&&j1+1==j2)){\n    if('a'<=s[i1][j1]&&s[i1][j1]<='z'&&s[i1][j1]-'a'==s[i2][j2]-'A')return 1;\n    else{\n      if(s[i2][j2]=='#')return -INF;\n      else return 0;\n    }\n  }\n\n  int res=-INF;\n  if(i1<i2)maxch(res,dfs(i1+1,j1,i2,j2));\n  if(j1<j2)maxch(res,dfs(i1,j1+1,i2,j2));\n\n  if('a'<=s[i1][j1]&&s[i1][j1]<='z'){\n    if('A'<=s[i2][j2]&&s[i2][j2]<='Z'&&s[i2][j2]-'A'==s[i1][j1]-'a'){\n      rep(d1,2){\n        rep(d2,2){\n          int ni1,nj1,ni2,nj2;\n          if(d1==0){\n            ni1=i1; nj1=j1+1;\n          }else{\n            ni1=i1+1; nj1=j1;\n          }\n          if(d2==0){\n            ni2=i2; nj2=j2-1;\n          }else{\n            ni2=i2-1; nj2=j2;\n          }\n          if(ni1<=ni2&&nj1<=nj2){\n            int v1=dfs(ni1,nj1,ni2,nj2);\n            if(v1!=-INF)maxch(res,v1+1);\n          }\n        }\n      }\n    }\n    for(P p : nxt[i1][j1]){\n      if(!(p.fi<=i2&&p.se<=j2))continue;\n      if(p.fi==i2&&p.se==j2)continue;\n      int v1=dfs(i1,j1,p.fi,p.se);\n      int v2=dfs(p.fi,p.se,i2,j2);\n      if(v1!=-INF&&v2!=-INF)maxch(res,v1+v2);\n    }\n  }\n\n  return dp[i1][j1][i2][j2]=res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0)break;\n    rep(i,h)cin>>s[i];\n\n    rep(i,h)rep(j,w){\n      nxt[i][j].clear();\n      if('a'<=s[i][j]&&s[i][j]<='z'){\n        repl(k,i,h)repl(l,j,w){\n          if('A'<=s[k][l]&&s[k][l]<='Z'&&s[k][l]-'A'==s[i][j]-'a'){\n            nxt[i][j].push_back(P(k,l));\n          }\n        }\n      }\n    }\n\n    rep(i,h)rep(j,w)rep(k,h)rep(l,w)dp[i][j][k][l]=-1;\n\n    int res=dfs(0,0,h-1,w-1);\n    if(res==-INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[52];\nint dp[53][53][53][53];\n\nint rec(int sy, int gy, int sx, int gx)\n{\n  if(sy >= gy || sx >= gx) return (0);\n  if(sy + 1 == gy && sx + 1 == gx) return (0);\n  int &ret = dp[sy][gy][sx][gx];\n  if(~ret) return (ret);\n  if(S[sy][sx] == '#') return (0);\n  if(sy + 1 < gy && S[sy + 1][sx] != '#') ret = max(ret, rec(sy + 1, gy, sx, gx));\n  if(sx + 1 < gx && S[sy][sx + 1] != '#') ret = max(ret, rec(sy, gy, sx + 1, gx));\n  if(S[sy][sx] == '.' || isupper(S[sy][sx])) return (ret);\n  char c = toupper(S[sy][sx]);\n  bool v1[53][53] = {{}}, v2[53][53];\n  v1[gy - 1][gx - 1] = true;\n  for(int i = gy - 1; i >= sy; i--) {\n    for(int j = gx - 1; j >= sx; j--) {\n      if(!v1[i][j]) continue;\n      if(i - 1 >= sy && S[i - 1][j] != '#') v1[i - 1][j] = true;\n      if(j - 1 >= sx && S[i][j - 1] != '#') v1[i][j - 1] = true;\n    }\n  }\n  for(int i = 0; i <= 1; i++) {\n    const int sa = sy + i, sb = sx + 1 - i;\n    if(sa >= gy || sb >= gx || S[sa][sb] == '#') continue;\n    memset(v2, false, sizeof(v2));\n    v2[sa][sb] = true;\n    for(int j = sa; j < gy; j++) {\n      for(int k = sb; k < gx; k++) {\n        if(!v2[j][k]) continue;\n        if(j + 1 < gy && S[j + 1][k] != '#') v2[j + 1][k] = true;\n        if(k + 1 < gx && S[j][k + 1] != '#') v2[j][k + 1] = true;\n      }\n    }\n    for(int j = sy; j < gy; j++) {\n      for(int k = sx; k < gx; k++) {\n        if(j + 1 < gy && (j == sy && k == sx || v2[j][k]) && c == S[j + 1][k]) {\n          if(j + 1 == gy - 1 && k == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j + 2][k]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 2, gy, k, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n        if(k + 1 < gx && (j == sy && k == sx || v2[j][k]) && c == S[j][k + 1]) {\n          if(j == gy - 1 && k + 1 == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j][k + 2]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j, gy, k + 2, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n      }\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, H, 0, W) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(b < a || is_Wall(a) || is_Wall(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(a == b) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = -INF;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(range_out(nx1) || range_out(nx2) || is_Wall(nx1) || is_Wall(nx2)) continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[0][0] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2538_in1.txt\");\n    while(ifs >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) ifs >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\t\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\t\t\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!((y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tint INF=1<<28;\n\tvoid run(){\n\t//\tifstream cin(\"in\");\n\t//\tofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] =move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nchar C[51][51];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvector<P> G[51][51];\nint dp[52][52][52][52];\n\nint H,W;\n\nint solve(int x1,int y1,int x2,int y2){\n  int &res = dp[x1][y1][x2][y2];\n  if( res != -1 ) return res;\n  res = 0;\n  // cout << \"in \" << x1 << \" \" << y1 << \" \" << C[x1][y1] << \" \"<< x2 << \" \" << y2 << \" \" << C[x2][y2]<< \" \" << res << endl;\n  if( x1 >= W || y1 >= H || x2 >= W || y2 >= H  ) return res=-11111111;\n  if( x1 == x2 && y1 == y2 ) return res;\n  if( x1 > x2 || y1 > y2 ) return res= -1111111;\n  if( C[x1][y1] == '#' || C[x2][y2] == '#' ) return res = -11111111;  \n  if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ){\n    for(int i=0;i<(int)G[x1][y1].size();i++){\n      int mx = G[x1][y1][i].first, my = G[x1][y1][i].second;\n      if( mx > x2 || my > y2 ) continue;\n      for(int j=0;j<2;j++){\n        for(int k=2;k<4;k++){\n          int nx1 = x1 + dx[j], ny1 = y1 + dy[j];\n          int nx2 = mx + dx[k], ny2 = my + dy[k];\n          if( C[nx1][ny1] == '#' || C[nx2][ny2] == '#' ) continue;\n          res = max( res,\n                     solve(nx1,ny1,nx2,ny2) + solve(mx,my,x2,y2) + 1 );\n        }\n      }\n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n    res = max( res, solve(nx1,ny1,x2,y2) );\n  }\n  return res;\n}\n\n\n\nint main(){\n  while( cin >> H >> W && (H||W) ){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin >> C[j][i];\n\n    queue<P> q;\n    int h[51][51]={};\n    q.push(P(0,0) );\n    h[0][0] = 1;\n    while( !q.empty() ){\n      P p = q.front(); q.pop();\n      int x = p.first, y = p.second;\n      for(int i=0;i<2;i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if( nx >= W || ny >= H ) continue;\n        if( h[nx][ny] ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        q.push( P(nx,ny) );\n        h[nx][ny] = 1;\n      }\n    }\n\n    if( !h[W-1][H-1] )\n      cout << -1 << endl;\n    else {\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          for(int k=0;k<H;k++)\n            for(int l=0;l<W;l++)\n              dp[j][i][l][k] = -1;\n\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          G[j][i].clear();\n\n      for(int y1=0;y1<H;y1++)\n        for(int x1=0;x1<W;x1++)\n          if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ) \n            for(int y2=y1;y2<H;y2++)\n              for(int x2=x1;x2<W;x2++)\n                if( C[x2][y2] - C[x1][y1] == 'A' - 'a' ) \n                  G[x1][y1].push_back( P(x2,y2) );\n              \n      // cout << \" in \" << endl;\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nbool used[60][60];\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = (int)mp.size();\n  }\n  int V = mp.size();\n  G.resize(V);\n  ws.resize(V);\n\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nbool hasEdge[MAX_V][MAX_V];\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\n  assert( topologicalSort(G,order) );\n\n  // DP\n  int V = G.size();\n\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  assert( V < MAX_V );\n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nint dp[55][55][55][55],reach[55][55][55][55];\nchar maz[55][55];\nint n,m;\nstruct node\n{\n    int x,y;\n    node(int x,int y):x(x),y(y){}\n};\nvector<node> s[26],l[26];\nvoid dfs(int x,int y,int nx,int ny)\n{\n    if(nx>n||ny>m) return;\n    reach[x][y][nx][ny]=1;\n    if(nx+1<=n&&(maz[nx+1][ny]!='#')&&(!reach[x][y][nx+1][ny]))\n        dfs(x,y,nx+1,ny);\n    if(ny+1<=m&&(maz[nx][ny+1]!='#')&&(!reach[x][y][nx][ny+1]))\n        dfs(x,y,nx,ny+1);\n}\nconst int inf=1000000;\n\nint DP(int x1,int y1,int x2,int y2)\n{\n    //printf(\"%d %d %d %d\\n\",x1,y1,x2,y2);\n    //cout<<x1<<\" \"<< y1<<\" \"<<x2<< \" \"<<y2<<endl;\n\n    if(x2<x1||y2<y1) return 0;\n    if(!reach[x1][y1][x2][y2])\n    {\n        return -inf;\n    }\n    if(x1==x2&&y1==y2) return 0;\n    if(dp[x1][y1][x2][y2]!=-1) return dp[x1][y1][x2][y2];\n    dp[x1][y1][x2][y2]=0;\n    if(maz[x1][y1]<='z'&&maz[x1][y1]>='a')\n    {\n        int t=maz[x1][y1]-'a';\n        for(int j=0;j<l[t].size();j++)\n        {\n            if(reach[x1][y1][l[t][j].x][l[t][j].y]&&reach[l[t][j].x][l[t][j].y][x2][y2])\n            {\n                int x=l[t][j].x,y=l[t][j].y;\n                if(maz[x1+1][y1]!='#'){\n                    if(maz[x-1][y]!='#')\n                        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,l[t][j].x-1,l[t][j].y)+DP(l[t][j].x,l[t][j].y,x2,y2)+1);\n                    if(maz[x2][y2-1])\n                        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,l[t][j].x,l[t][j].y-1)+DP(l[t][j].x,l[t][j].y,x2,y2)+1);\n                }\n                if(maz[x1][y1+1]){\n                    if(maz[x-1][y]!='#')\n                        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,l[t][j].x-1,l[t][j].y)+DP(l[t][j].x,l[t][j].y,x2,y2)+1);\n                    if(maz[x][y-1])\n                        dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,l[t][j].x,l[t][j].y-1)+DP(l[t][j].x,l[t][j].y,x2,y2)+1);\n                }\n            }\n        }\n    }\n    dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1+1,y1,x2,y2));\n    dp[x1][y1][x2][y2]=max(dp[x1][y1][x2][y2],DP(x1,y1+1,x2,y2));\n    return dp[x1][y1][x2][y2];\n}\nint main()\n{\n    freopen(\"in.txt\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m)&&n&&m)\n    {\n        for(int i=0;i<26;i++) s[i].clear(),l[i].clear();\n        for(int i=1;i<=n;i++) scanf(\"%s\",maz[i]+1);\n        for(int i=0;i<55;i++)\n        {\n            for(int j=0;j<55;j++)\n            {\n                if(i<=0||i>n) maz[i][j]='#';\n                if(j<=0||j>m) maz[i][j]='#';\n            }\n        }\n        memset(dp,-1,sizeof(dp));\n        memset(reach,0,sizeof(reach));\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++) if(maz[i][j]!='#') dfs(i,j,i,j);\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++)\n        if(maz[i][j]<='z'&&maz[i][j]>='a')\n        {\n            s[maz[i][j]-'a'].push_back(node(i,j));\n        }\n        else if(maz[i][j]<='Z'&&maz[i][j]>='A')\n        {\n            l[maz[i][j]-'A'].push_back(node(i,j));\n        }\n        int res;\n        if(!reach[1][1][n][m]) res=-1;\n        else res=DP(1,1,n,m);\n        if(res<0)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly==ry+1&&lx==rx+1)return dp[ly][lx][ry][rx]=0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<(dfs(0,0,h-1,w-1)<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            if (R[sy][sx][ny][nx]) continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n\n        int r = 0;\n        if (islower(F[sy][sx])) {\n            for (int y = sy; y <= ty; y++) {\n                for (int x = sx; x <= tx; x++) {\n                    if (y == ty && x == tx) continue;\n                    r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n                }\n            }\n        }\n\n        r = max(r, f(sy, sx + 1, ty, tx));\n        r = max(r, f(sy + 1, sx, ty, tx));\n\n        int d = islower(F[sy][sx]) && toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define range(x,s,t) (s<=x&&x<t)\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint memo[55][55][55][55];\nint ans[55][55];\n\nint h,w;\nstring board[55];\nusing state=tuple<int,int,int,int,int>;\n\nconst int inf=1<<29;\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\n\n\nint rec(int a,int b,int c,int d){\n\tif(h<=a||w<=b||c<0||d<0) return -inf;\n\tif(board[a][b]=='#'||board[c][d]=='#') return -inf;\n\t\n\tif(a==c&&b==d) return 0;\n\tif(a-1==c&&b==d) return 0;\n\tif(a==c&&b-1==d) return 0;\n\t\n\tif(a>c||b>d) return -inf;\n\n\tint &ret=memo[a][b][c][d];\n\tif(ret!=-1) return ret;\n\n\tret=-inf;\n\tchmax(ret,rec(a+1,b,c,d));\n\tchmax(ret,rec(a,b+1,c,d));\n\tchmax(ret,rec(a,b,c-1,d));\n\tchmax(ret,rec(a,b,c,d-1));\n\t\n\tif(islower(board[a][b]) && toupper(board[a][b])==board[c][d]){\n\t\tchmax(ret,rec(a+1,b,c-1,d)+1);\n\t\tchmax(ret,rec(a+1,b,c,d-1)+1);\n\t\tchmax(ret,rec(a,b+1,c-1,d)+1);\n\t\tchmax(ret,rec(a,b+1,c,d-1)+1);\n\t}\n\n\tif(islower(board[a][b])){\n\t\tchar tar=board[a][b]-'a'+'A';\n\t\trep(y,a,c+1)rep(x,b,d+1){\n\t\t\tif(y==c&&x==d) continue;\n\t\t\tif(board[y][x]==tar)\n\t\t\t\tchmax(ret,rec(a,b,y,x)+rec(y,x,c,d));\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main(void){\n\twhile(cin >> h >> w,h){\n\t\trep(i,h) cin >> board[i];\n\t\tclr(memo,-1);\n\t\tcout << max(-1,rec(0,0,h-1,w-1)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[50][50];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            if('a'<=c[y][x] and c[y][x]<='z' and 'A'<=c[y_][x_] and c[y_][x_]<='Z' and c[y][x]-'a'==c[y_][x_]-'A') ps[y][x].push_back(make_pair(y_,x_));\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return memo[y1][x1][y2][x2]=0;\n        if(!can_move[y1][x1][y2][x2]) return memo[y1][x1][y2][x2]=-inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[y1][x1]){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nint ikeru[52][52][52][52]; \nint dp[52][52][52][52];\nint h,w;\nchar v[52][52];\nvoid reach(int a,int b,int c,int d){\n    if(ikeru[a][b][c][d]!=-1)return;\n    if(v[a][b]=='#'||v[c][d]=='#'){\n        ikeru[a][b][c][d] = 0;\n        return;\n    }\n    if(a>c||b>d){\n        ikeru[a][b][c][d] = 0;\n        return;\n    }\n    if(a==c&&b==d){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    if(a==c&&d==b+1){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    if(c==a+1&&b==d){\n        ikeru[a][b][c][d] = 1;\n        return;\n    }\n    for(int i=a;i<=c;i++){\n        for(int j=b;j<=d;j++){\n            if(i==a&&j==b){\n                ikeru[a][b][i][j]=1;\n                continue;\n            }\n            if(i==c&&j==d){\n                ikeru[i][j][c][d]=1;\n                continue;\n            }\n            reach(a,b,i,j);\n            reach(i,j,c,d);\n            if(ikeru[a][b][i][j]==1&&ikeru[i][j][c][d]==1){\n                ikeru[a][b][c][d] = 1;\n            }\n        }\n    }\n    return;\n}\n\nint saiki(int a,int b,int c,int d){\n    if(dp[a][b][c][d]!=-100000){\n        return dp[a][b][c][d];\n    }\n    if(ikeru[a][b][c][d]!=1){\n        return dp[a][b][c][d]=-1000000;\n    }\n    if(a==c&&b==d){\n        return dp[a][b][c][d] = 0;\n    }\n    if(a==c&&d==b+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    if(b==d&&c==a+1){\n        if(v[a][b] + 'A'-'a' == v[c][d]){\n            return dp[a][b][c][d] = 1;\n        }else{\n            return dp[a][b][c][d] = 0;\n        }\n    }\n    int ans = -222222;\n    if(v[a][b] + 'A'-'a' ==v[c][d]){\n        if(a+1<=c-1)ans = max(ans,1+saiki(a+1,b,c-1,d));\n        if(a+1<=c&&b<=d-1)ans = max(ans,1+saiki(a+1,b,c,d-1));\n        if(a<=c-1&&b+1<=d)ans = max(ans,1+saiki(a,b+1,c-1,d));\n        if(b+1<=d-1)ans = max(ans,1+saiki(a,b+1,c,d-1));        \n    }\n    for(int i=a;i<=c;i++){\n        for(int j=b;j<=d;j++){\n            if(i==c&&j==d)continue;\n            if(i!=c)ans = max(ans,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n            if(j!=d)ans = max(ans,saiki(a,b,i,j)+saiki(i,j+1,c,d));            \n        }\n    }\n    return dp[a][b][c][d]=ans;\n}\n\nint main() {\n    while(cin >> h >> w && h!=0){\n        rep(i,h){\n            string s;\n            cin >> s;\n            rep(j,s.size()){\n                v[i][j] = s[j];\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                rep(k,h){\n                    rep(l,w){\n                        dp[i][j][k][l] = -100000;\n                        ikeru[i][j][k][l] = -1;\n                    }\n                }\n            }\n        }\n        // rep(i,h){\n        //     rep(j,w){\n        //         rep(k,h){\n        //             rep(l,w){\n        //                 reach(i,j,k,l);\n        //             }\n        //         }\n        //     }\n        // }\n        reach(0,0,h-1,w-1);\n        if(ikeru[0][0][h-1][w-1]!=1){\n            cout << -1 << endl;\n        }else{\n            int ans = saiki(0,0,h-1,w-1);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define max(a, b) ((a)>(b)?(a):(b))\nint n, m, la, lb;\nchar S[55][55];\nint d[52][52][52][52];\nint ax[26][11], ay[26][11], an[26];\ninline bool match(char A, char B) {\n\tla = 'a' <= A && A <= 'z';\n\tlb = 'a' <= B && B <= 'z';\n\tif (la && !lb && A - 'a' == B - 'A') return 1;\n\treturn 0;\n}\nint f(int ux, int uy, int dx, int dy) {\n\tif (ux > dx || uy > dy) return -1;\n\tif (d[ux][uy][dx][dy] != -2) return d[ux][uy][dx][dy];\n\td[ux][uy][dx][dy] = -1;\n\tif (S[ux][uy] != '#' && S[dx][dy] != '#') {\n\t\tif (ux == dx && uy == dy) return d[ux][uy][dx][dy] = 0;\n\t\tif (S[ux][uy] == '.' || ('A' <= S[ux][uy] && S[ux][uy] <= 'Z')) d[ux][uy][dx][dy] = max(f(ux + 1, uy, dx, dy), f(ux, uy + 1, dx, dy));\n\t\telse {\n\t\t\td[ux][uy][dx][dy] = max(f(ux + 1, uy, dx, dy), f(ux, uy + 1, dx, dy));\n\t\t\tint p = S[ux][uy] - 'a', v, nx, ny, ff;\n\t\t\tfor (int i = 1; i <= an[p]; i++) {\n\t\t\t\tv = -1;\n\t\t\t\tnx = ax[p][i];\n\t\t\t\tny = ay[p][i];\n\t\t\t\tif ((ux == nx && uy + 1 == ny) || (uy == ny && ux + 1 == nx)) {\n\t\t\t\t\tff = f(nx, ny, dx, dy);\n\t\t\t\t\tif (match(S[ux][uy], S[nx][ny]) && ff != -1) d[ux][uy][dx][dy] = max(d[ux][uy][dx][dy], 1 + ff);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ux <= nx && nx <= dx && uy <= ny && ny <= dy) {\n\t\t\t\t\t\tv = max(v, f(ux + 1, uy, nx - 1, ny));\n\t\t\t\t\t\tv = max(v, f(ux + 1, uy, nx, ny - 1));\n\t\t\t\t\t\tv = max(v, f(ux, uy + 1, nx - 1, ny));\n\t\t\t\t\t\tv = max(v, f(ux, uy + 1, nx, ny - 1));\n\t\t\t\t\t\tff = f(nx, ny, dx, dy);\n\t\t\t\t\t\tif (v != -1 && ff != -1) d[ux][uy][dx][dy] = max(d[ux][uy][dx][dy], v + 1 + ff);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[ux][uy][dx][dy];\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m), n&&m) {\n\t\tfor (int i = 1; i <= n; i++) scanf(\"%s\", S[i] + 1);\n\t\tfor (int i = 0; i < 26; i++) an[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif ('A' <= S[i][j] && S[i][j] <= 'Z') {\n\t\t\t\t\tint p = S[i][j] - 'A';\n\t\t\t\t\tan[p]++;\n\t\t\t\t\tax[p][an[p]] = i;\n\t\t\t\t\tay[p][an[p]] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 1; k <= n; k++) for (int l = 1; l <= m; l++) d[i][j][k][l] = -2;\n\t\tprintf(\"%d\\n\", f(1, 1, n, m));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<30;\nll dx[] = {1, 0}, dy[] = {0, 1};\n\nstring s[51];\nll h, w, dp[51][51][51][51];\nvector<PII> g[26];\nbool can[51][51][51][51];\nll dfs(ll sx, ll sy, ll gx, ll gy) {\n    // dump(sx, sy, gx, gy);\n    if(!can[sx][sy][gx][gy]) return -INF;\n    if(gx==sx && gy==sy) return 0;\n    if(dp[sx][sy][gx][gy] != -1) return dp[sx][sy][gx][gy];\n    ll ret = 0;\n    if('a' <= s[sy][sx] && s[sy][sx] <= 'z') {\n        // s[sy][sx] に対応する位置\n        for(auto to: g[s[sy][sx]-'a']) {\n            if(to.first<sx || to.first>gx || to.second<sy || to.second>gy) continue;\n            if(abs(to.first-sx) + abs(to.second-sy) == 1) {\n                chmax(ret, 1 + dfs(to.first, to.second, gx, gy));\n                continue;\n            }\n            ll vr = dfs(to.first, to.second, gx, gy);\n            REP(i, 2) REP(j, 2) {\n                ll nsx = sx + dx[i], nsy = sy + dy[i];\n                ll ntx = to.first - dx[j], nty = to.second - dy[j];\n                if(nsx > ntx || nsy > nty) continue;\n                ll vl = dfs(nsx, nsy, ntx, nty);\n                chmax(ret, vl + vr + 1);\n                // dump(nsx, nsy, ntx, nty, gx, gy);\n            }\n        }\n    }\n    if(sx < gx) chmax(ret, dfs(sx+1, sy, gx, gy));\n    if(sy < gy) chmax(ret, dfs(sx, sy+1, gx, gy));\n    return dp[sx][sy][gx][gy] = ret;\n}\n\nvoid visit(ll sx, ll sy, ll x, ll y) {\n    can[sx][sy][x][y] = true;\n    if(x+1<w && s[y][x+1]!='#' && !can[sx][sy][x+1][y]) visit(sx, sy, x+1, y);\n    if(y+1<h && s[y+1][x]!='#' && !can[sx][sy][x][y+1]) visit(sx, sy, x, y+1);\n}\n\nint main(void) {\n    while(1) {\n        cin >> h >> w;\n        if(h==0) break;\n        REP(i, h) cin >> s[i];\n        // dump(h, w);\n        // REP(i, h) dump(s[i]);\n\n        memset(dp, -1, sizeof(dp));\n        REP(i, 26) g[i].clear();\n        REP(i, h) REP(j, w) {\n            if('A' <= s[i][j] && s[i][j] <= 'Z') {\n                g[s[i][j]-'A'].push_back({j, i});\n            }\n        }\n\n        // REP(i, 26) dump(g[i]);\n\n        memset(can, false, sizeof(can));\n        REP(i, h) REP(j, w) {\n            if(s[i][j]=='#') continue;\n            visit(j, i, j, i);\n        }\n        if(!can[0][0][w-1][h-1]) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        cout << dfs(0, 0, w-1, h-1) << \"\\n\";\n    }\n    cout << flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\nconst int ALP = 26;\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[ALP],t[ALP];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n            mv[i][i] = false;\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,ALP){\n            for(int from:s[i])for(int to:t[i])if(mv[from][to]) dp[from][to] = 1;\n        }\n\n        // rep(loop,50){\n        //     rep(i,ALP)for(int from:s[i])for(int to:t[i]){\n        //         if(!mv[from][to]) continue;\n\n        //         rep(j,ALP){\n        //             for(int x:s[j]){\n        //                 if(!mv[from][x]) continue;\n        //                 for(int y:t[j]){\n        //                     if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n\n        // vector<vector<int>> ans(h,vector<int>(w,-1));\n        // ans[0][0] = 0;\n        // rep(i,h)rep(j,w){\n        //     rep(d,2){\n        //         int ni = i+dy[d], nj = j+dx[d];\n        //         if(IN(ni,nj) && c[ni][nj]!='#') ans[ni][nj] = max(ans[ni][nj], ans[i][j]);\n        //     }\n\n        //     if(islower(c[i][j])){\n        //         int from = p2id[{i,j}];\n        //         for(int to:t[c[i][j]-'a']){\n        //             if(mv[from][to]){\n        //                 ans[p[to].fi][p[to].se] = max(ans[p[to].fi][p[to].se], ans[i][j]+dp[from][to]);\n        //             }\n        //         }\n        //     }\n        // }\n        cout << ans[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!(move[y1][x1][ny][nx] && (y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t\t// ifstream cin(\"in\");\n\t\t// ofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t\tif(board[y2][x1]=='#') move[y1][x1][y2][x2]=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-1))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nstring mp[N];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nbool pushA(int x,int y,int f=1){\n  bool D[N][N]={};\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] |= D[i-1][j];\n      if(j)D[i][j] |= D[i][j-1];\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      if(f)A.push_back(PP(P(x,y),P(j,i)));\n    }\n  return D[h-1][w-1];\n}\n\nvoid mkA(){ //??¢?????????????????¨\n  A.clear();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(islower(mp[i][j]))pushA(j,i);\n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  \n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if(a.first==b.first||a.second == b.second)return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\n\nmap<PP,int> mem[3000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<3000;i++)mem[i].clear();\n    mkA();\n    if(!pushA(0,0,0)) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nbool used[60][60];\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  int _cnt = 0;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = _cnt++;\n  }\n  int V = mp.size();\n  G.resize(V);\n  rep(i,V) G[i].clear();\n  ws.resize(V);\n\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nbool hasEdge[MAX_V][MAX_V];\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\n  assert( topologicalSort(G,order) );\n\n  // DP\n  int V = G.size();\n\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  assert( V < MAX_V );\n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[55][55][55][55];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n  ret = -(1<<29);\n\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      if( p.first == x2 && p.second == y2 ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        // cout << x1 << \", \"<< y1 << \" -> \" << nx << \", \"<< ny << \" : \" << p.first << \", \" << p.second << \" -> \" << x2 << \", \"<< y2 << endl;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n\n  //cout << x1 << \", \"<< y1 << \" - \"<<x2 << \", \"<< y2 << \" :\" << ret << endl;\n   \n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W+1 && y == H+1 ) return true;\n  if( x>W+1 || y>H+1 ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nvoid view(){\n  for(int i=0;i<=H+1;i++){\n    for(int j=0;j<=W+1;j++) cout << C[j][i];\n    cout << endl;\n  }\n}\n\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<=H+1;i++)\n      for(int j=0;j<=W+1;j++)\n        C[j][i] = '#';\n    C[0][0] = '.';\n    C[0][1] = '.';\n    C[1][0] = '.';\n    C[W+1][H+1] = '.';\n    C[W+1][H] = '.';\n    C[W][H+1] = '.';\n\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    // view();\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      int res = solve(0,0,W+1,H+1);\n      cout << res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  if( x1 == x2 && y1 == y2 ) return ret=0;\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,p.first,p.second ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }    \n  \n  if( ret == -1 ) ret = -(1<<29);\n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x==W || y==H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> W >> H && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << -1 << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[52];\nint dp[53][53][53][53];\nbool latte[53][53][53][53], malta[53][53][53][53];\n\nint rec(int sy, int gy, int sx, int gx)\n{\n  if(sy >= gy || sx >= gx) return (0);\n  if(sy + 1 == gy && sx + 1 == gx) return (0);\n  int &ret = dp[sy][gy][sx][gx];\n  if(~ret) return (ret);\n  if(S[sy][sx] == '#') return (0);\n  if(sy + 1 < gy && S[sy + 1][sx] != '#') ret = max(ret, rec(sy + 1, gy, sx, gx));\n  if(sx + 1 < gx && S[sy][sx + 1] != '#') ret = max(ret, rec(sy, gy, sx + 1, gx));\n  if(S[sy][sx] == '.' || isupper(S[sy][sx])) return (ret);\n  char c = toupper(S[sy][sx]);\n  latte[sy][sx][gy - 1][gx - 1] = true;\n  for(int i = gy - 1; i >= sy; i--) {\n    for(int j = gx - 1; j >= sx; j--) {\n      if(!latte[sy][sx][i][j]) continue;\n      if(i - 1 >= sy && S[i - 1][j] != '#') latte[sy][sx][i - 1][j] = true;\n      if(j - 1 >= sx && S[i][j - 1] != '#') latte[sy][sx][i][j - 1] = true;\n    }\n  }\n  for(int i = 0; i <= 1; i++) {\n    const int sa = sy + i, sb = sx + 1 - i;\n    if(sa >= gy || sb >= gx || S[sa][sb] == '#') continue;\n    memset(malta[sy][sx], false, sizeof(malta[sy][sx]));\n    malta[sy][sx][sa][sb] = true;\n    for(int j = sa; j < gy; j++) {\n      for(int k = sb; k < gx; k++) {\n        if(!malta[sy][sx][j][k]) continue;\n        if(j + 1 < gy && S[j + 1][k] != '#') malta[sy][sx][j + 1][k] = true;\n        if(k + 1 < gx && S[j][k + 1] != '#') malta[sy][sx][j][k + 1] = true;\n      }\n    }\n    for(int j = sy; j < gy; j++) {\n      for(int k = sx; k < gx; k++) {\n        if(j + 1 < gy && malta[sy][sx][j][k] && c == S[j + 1][k]) {\n          if(j + 1 == gy - 1 && k == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(latte[sy][sx][j + 2][k]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 2, gy, k, gx) + 1);\n          if(latte[sy][sx][j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n        if(k + 1 < gx && (j == sy && k == sx || malta[sy][sx][j][k]) && c == S[j][k + 1]) {\n          if(j == gy - 1 && k + 1 == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(latte[sy][sx][j][k + 2]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j, gy, k + 2, gx) + 1);\n          if(latte[sy][sx][j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n      }\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    memset(latte, false, sizeof(latte));\n    memset(malta, false, sizeof(malta));\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, H, 0, W) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vvvb=vector<vvb>;\nusing vvvvb=vector<vvvb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int, int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\nusing Pos=map<char, vector<pii>>;\nusing Visit=vvvvb;\n\nconstexpr bool cmp(int&a,int l, int r){\n\treturn l<=a and a<r;\n}\n\nvvvvi memo;\nvvvvi vis;\nint rec(int sy, int sx, int gy, int gx, vs&f, Pos&mp){\n\tif(!cmp(sy,0,f.size()) or !cmp(gy,0,f.size()) or !cmp(sx,0,f[0].size()) or !cmp(gx,0,f[0].size())){\n\t\treturn -1;\n\t}\n\tif(f[sy][sx]=='#' or f[gy][gx]=='#'){\n\t\treturn -1;\n\t}\n\tif(sx>gx or sy>gy or (sx==gx and sy==gy)){\n\t\treturn 0;\n\t}\n\tif(memo[sy][sx][gy][gx]!=INF){\n\t\treturn memo[sy][sx][gy][gx];\n\t}\n\tif(vis[sy][sx][gy][gx]!=1) return -1;\n\n\tint ret=max(rec(sy+1,sx,gy,gx,f,mp), rec(sy,sx+1,gy,gx,f,mp));\n\n\tif(islower(f[sy][sx])){\n\t\tfor(auto&to : mp[toupper(f[sy][sx])]){\n\t\t\tint ty,tx,val=0;\n\t\t\ttie(ty,tx) = to;\n\t\t\tif(vis[sy][sx][ty][tx]!=1 or vis[ty][tx][gy][gx]!=1)continue;\n\t\t\tval += max({rec(sy+1,sx,ty,tx-1,f,mp), rec(sy,sx+1,ty-1,tx,f,mp),\n\t\t\t\t\t\trec(sy+1,sx,ty-1,tx,f,mp), rec(sy,sx+1,ty,tx-1,f,mp)});\n\t\t\tval += 1+rec(ty,tx,gy,gx,f,mp);\n\t\t\tchmax(ret, val);\n\t\t}\n\t}\n\treturn memo[sy][sx][gy][gx] = ret;\n}\n\n\nbool bfs(int sy, int sx, int gy, int gx, vs&f){\n\tif(!cmp(sy,0,f.size()) or !cmp(gy,0,f.size()) or !cmp(sx,0,f[0].size()) or !cmp(gx,0,f[0].size())){\n\t\treturn 0;\n\t}\n\n\tif(vis[sy][sx][gy][gx]!=-1) return vis[sy][sx][gy][gx];\n\n\tint ret = 0;\n\tif(sx>gx or sy>gy or f[sy][sx]=='#' or f[gy][gx]=='#'){\n\t\t;\n\t} else if (sx==gx and sy==gy){\n\t\tret = f[sy][sx]=='#'?0:1;\n\t}else if (sx==gx and sy+1==gy and f[sy][sx]!='#' and f[gy][gx]!='#'\n\t            or sy==gy and sx+1==gx and f[sy][sx]!='#' and f[gy][gx]!='#'){\n\t    ret = 1;\n\t}else{\n\t\tret|=bfs(sy+1,sx,gy-1,gx,f);\n\t\tret|=bfs(sy+1,sx,gy,gx-1,f);\n\t\tret|=bfs(sy,sx+1,gy-1,gx,f);\n\t\tret|=bfs(sy,sx+1,gy,gx-1,f);\n\t}\n\t\n\treturn vis[sy][sx][gy][gx]=ret;\n}\n\n/*他のライブラリを入れる場所*/\nint solve(int h, int w){\n\tvs f(h);\n\tcin>>f;\n\tmemo=vvvvi(h, vvvi(w, vvi(h, vi(w,INF))));\n\tvis=vvvvi(h, vvvi(w, vvi(h, vi(w,-1))));\n\n\tPos mp;\n\trep(i,h)rep(j,w){\n\t\tif(isalpha(f[i][j])){\n\t\t\tif(mp.find(f[i][j])==mp.end()){\n\t\t\t\tmp[f[i][j]] = vector<pii>();\n\t\t\t}\n\t\t\tmp[f[i][j]].emplace_back(i,j);\n\t\t}\n\t}\n\trep(i,h)rep(j,w)rep(k,h)rep(l,w)bfs(i,j,k,l,f);\n\treturn rec(0,0,h-1,w-1,f,mp);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll h,w;\n\twhile(cin>>h>>w,h+w){\n\t\tputa(solve(h,w));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 1) cout << \"*\" << endl;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 10) cout << \"*\" << endl;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nstring S[52];\nint dp[53][53][53][53];\n\nint rec(int sy, int gy, int sx, int gx)\n{\n  if(sy >= gy || sx >= gx) return (0);\n  if(sy + 1 == gy && sx + 1 == gx) return (0);\n  int &ret = dp[sy][gy][sx][gx];\n  if(~ret) return (ret);\n  if(S[sy][sx] == '#') return (0);\n  if(sy + 1 < gy && S[sy + 1][sx] != '#') ret = max(ret, rec(sy + 1, gy, sx, gx));\n  if(sx + 1 < gx && S[sy][sx + 1] != '#') ret = max(ret, rec(sy, gy, sx + 1, gx));\n  if(S[sy][sx] == '.' || isupper(S[sy][sx])) return (ret);\n  char c = toupper(S[sy][sx]);\n  bool v1[53][53] = {{}}, v2[53][53];\n  v1[gy - 1][gx - 1] = true;\n  for(int i = gy - 1; i >= sy; i--) {\n    for(int j = gx - 1; j >= sx; j--) {\n      if(!v1[i][j]) continue;\n      if(i - 1 >= sy && S[i - 1][j] != '#') v1[i - 1][j] = true;\n      if(j - 1 >= sx && S[i][j - 1] != '#') v1[i][j - 1] = true;\n    }\n  }\n  for(int i = 0; i <= 1; i++) {\n    const int sa = sy + i, sb = sx + 1 - i;\n    if(sa >= gy || sb >= gx || S[sa][sb] == '#') continue;\n    memset(v2, false, sizeof(v2));\n    v2[sa][sb] = true;\n    for(int j = sa; j < gy; j++) {\n      for(int k = sb; k < gx; k++) {\n        if(!v2[j][k]) continue;\n        if(j + 1 < gy && S[j + 1][k] != '#') v2[j + 1][k] = true;\n        if(k + 1 < gx && S[j][k + 1] != '#') v2[j][k + 1] = true;\n      }\n    }\n    for(int j = sy; j < gy; j++) {\n      for(int k = sx; k < gx; k++) {\n        if(j + 1 < gy && v2[j][k] && c == S[j + 1][k]) {\n          if(j + 1 == gy - 1 && k == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j + 2][k]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 2, gy, k, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n        if(k + 1 < gx && (j == sy && k == sx || v2[j][k]) && c == S[j][k + 1]) {\n          if(j == gy - 1 && k + 1 == gx - 1) ret = max(ret, rec(sa, j + 1, sb, k + 1) + 1);\n          if(v1[j][k + 2]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j, gy, k + 2, gx) + 1);\n          if(v1[j + 1][k + 1]) ret = max(ret, rec(sa, j + 1, sb, k + 1) + rec(j + 1, gy, k + 1, gx) + 1);\n        }\n      }\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> H >> W, H) {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, H, 0, W) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0};\nconst int dy[] = {0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst int MAX = 55;\n\nstring board[MAX];\nint dp[MAX][MAX][MAX][MAX];\nbool can[MAX][MAX][MAX][MAX];\nvector<pii> pnts[33];\nint H, W;\n\nint dfs(int y1, int x1, int y2, int x2) {\n\tint& ret = dp[y1][x1][y2][x2];\n\tif (ret != -1) return ret;\n\tif (y1 == y2 && x1 == x2) return ret = 0;\n\tret = -INF;\n\tchar c = board[y1][x1];\n\tif (c == '#') return ret;\n\t// ??????????????????????????????\n\tif (y1 + 1 <= y2 && board[y1 + 1][x1] != '#') {\n\t\tret = max(ret, dfs(y1 + 1, x1, y2, x2));\n\t}\n\tif (x1 + 1 <= x2 && board[y1][x1 + 1] != '#') {\n\t\tret = max(ret, dfs(y1, x1 + 1, y2, x2));\n\t}\n\tif ('a' <= c && c <= 'z') {\n\t\t// ???????????????????????§??????\n\t\tint index = c - 'a';\n\t\tfor (auto p : pnts[index]) {\n\t\t\tint ny = p.first, nx = p.second;\n\t\t\tif (ny > y2 || nx > x2) continue;\n\t\t\tif (abs(ny - y1) + abs(nx - x1) == 1) {\n\t\t\t\tret = max(ret, 1 + dfs(ny, nx, y2, x2));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n\t\t\t\t\tint ny1 = y1 + dy[i], nx1 = x1 + dx[i];\n\t\t\t\t\tif (ny1 > y2 || nx1 > x2) continue;\n\t\t\t\t\tint bny = ny - dy[j], bnx = nx - dx[j];\n\t\t\t\t\tif (bny < y1 || bnx < x1) continue;\n\t\t\t\t\tif (!can[ny1][nx1][bny][bnx]) continue;\n\t\t\t\t\tret = max(ret, 1 + dfs(ny1, nx1, bny, bnx) + dfs(ny, nx, y2, x2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> H >> W) {\n\t\tif (H == 0 && W == 0) break;\n\t\tfor (int i = 0; i < H; i++)\n\t\t\tcin >> board[i];\n\t\tfor (int i = 0; i < 30; i++)\n\t\t\tpnts[i].clear();\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tchar c = board[i][j];\n\t\t\tif ('A' <= c && c <= 'Z') {\n\t\t\t\tpnts[c - 'A'].emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tmemset(can, false, sizeof(can));\n\t\tfor (int y = H - 1; y >= 0; y--) for (int x = W - 1; x >= 0; x--) {\n\t\t\tif (board[y][x] == '#') continue;\n\t\t\tcan[y][x][y][x] = true;\n\t\t\tif (y + 1 < H && board[y + 1][x] != '#') {\n\t\t\t\tfor (int y1 = y + 1; y1 < H; y1++) for (int x1 = x; x1 < W; x1++) {\n\t\t\t\t\tcan[y][x][y1][x1] |= can[y + 1][x][y1][x1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x + 1 < W && board[y][x + 1] != '#') {\n\t\t\t\tfor (int y1 = y; y1 < H; y1++) for (int x1 = x + 1; x1 < W; x1++) {\n\t\t\t\t\tcan[y][x][y1][x1] |= can[y][x + 1][y1][x1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tint ans = dfs(0, 0, H - 1, W - 1);\n\t\tif (ans < 0) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);}}init;\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<VVV> VVVV;\ntypedef tuple<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint isLC(char c){\n    if('a'<=c&&c<='z')return c-'a';\n    else return -1;\n}\nint isUC(char c){\n    if('A'<=c&&c<='Z')return c-'A';\n    else return -2;\n}\nbool inner(int lb,int c,int ub){\n    return lb<=c&&c<=ub;\n}\nint f(int rbg,int red,int cbg,int ced,vector<string>& s,VVVV &memo,VVP&U){\n    if(memo[rbg][cbg][red][ced]!=-2)return memo[rbg][cbg][red][ced];\n    //cout<<cbg<<\" \"<<ced<<endl;\n    int R=1+red-rbg;\n    int C=1+ced-cbg;\n    VV dp(R,V(C,-1));\n    dp[0][0]=0;\n    int x=isLC(s[rbg][cbg]);\n    int y=isUC(s[red][ced]);\n    if(x==y){\n        s[rbg][cbg]='.';\n        s[red][ced]='.';\n        dp[0][0]++;\n    }\n    for(int r=rbg;r<=red;r++){\n        for(int c=cbg;c<=ced;c++){\n            int i=r-rbg;\n            int j=c-cbg;\n            if(dp[i][j]==-1)continue;\n            int id=isLC(s[r][c]);\n            if(id>=0){\n                for(auto &it:U[id]){\n                    int nr,nc;\n                    tie(nr,nc)=it;\n                    if(inner(r,nr,red)&&inner(c,nc,ced)&&isLC(s[r][c])==isUC(s[nr][nc])){\n                        int val=f(r,nr,c,nc,s,memo,U);\n                        int ni=nr-rbg;\n                        int nj=nc-cbg;\n                        if(val!=-1)\n                            dp[ni][nj]=max(dp[ni][nj],dp[i][j]+val);\n                    }\n                }            \n            }\n            if(r!=red&&s[r+1][c]!='#')dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n            if(c!=ced&&s[r][c+1]!='#')dp[i][j+1]=max(dp[i][j+1],dp[i][j]);\n        }     \n    }\n    if(x==y){\n        s[rbg][cbg]=x+'a';\n        s[red][ced]=y+'A';\n    }\n    //cout<<rbg<<\" \"<<red<<\" \"<<dp[R-1][C-1]<<endl;\n    return memo[rbg][cbg][red][ced]=dp[R-1][C-1];\n}\n\n\nint main(){\n    for(int R,C;cin>>R>>C,R+C;){\n        vector<string> s(R);\n        for(auto &it:s)cin>>it;\n        VVP uc(26);\n        for(int i=0;i<R;i++)\n            for(int j=0;j<C;j++){\n                int id=isUC(s[i][j]);\n                if(id>=0)uc[id].push_back(P(i,j));\n            }\n        VVVV memo(R,VVV(C,VV(R,V(C,-2))));\n        cout<<f(0,R-1,0,C-1,s,memo,uc)<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int X[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    int f(int sy, int sx, int ty, int tx);\n    int g(int sy, int sx, int ty, int tx) {\n        int& cache = X[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n        int r = 0;\n        for (int y = sy; y <= ty; y++) {\n            for (int x = sx; x <= tx; x++) {\n                if (y == ty && x == tx) continue;\n                r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n            }\n        }\n        return cache = r;\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n        int r = g(sy, sx, ty, tx);\n        int d = islower(F[sy][sx]) && toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n        memset(X, -1, sizeof(X));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\nbool valid(int x, int l){\n    return 0 <= x && x < l;\n}\nvoid update(int& x, int y){\n    if(x < y) x = y;\n}\n\nint main(){\n    int H, W;\n    while(cin >> H >> W && H > 0){\n        string grid[55];\n        REP(y, H) cin >> grid[y];\n\n        map< int, vector<pair<int, int>> > jewels;\n        REP(y, H) REP(x, W) if(isupper(grid[y][x])) {\n            jewels[ grid[y][x] ].push_back(make_pair(x, y));\n        }\n\n        static int dp[55][55][55][55] = {};\n        memset(dp, -1, sizeof(dp));\n\n        function<int(int, int, int, int)> dfs = [&](int sx, int sy, int gx, int gy){\n            if(!valid(sx, W) || !valid(sy, H)) return -INF;\n            if(sx > gx || sy > gy) return 0; // ???\n            if(grid[sy][sx] == '#') return -INF;\n\n            if(sx == gx && sy == gy) return 0;\n\n            int& res = dp[sx][sy][gx][gy];\n            if(res != -1) {\n                return res;\n            }\n            res = -INF;\n\n            update(res, dfs(sx + 1, sy, gx, gy));\n            update(res, dfs(sx, sy + 1, gx, gy));\n\n            if(islower(grid[sy][sx])){\n                char c = grid[sy][sx] - 'a' + 'A';\n                for(auto p : jewels[c]){\n                    int ngx = p.first;\n                    int ngy = p.second;\n                    if(sx <= ngx && sy <= ngy && ngx <= gx && ngy <= gy){\n                        update(res, 1 + dfs(sx + 1, sy, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx + 1, sy, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                    }\n                }\n            }\n            return res;\n        };\n\n        int res = dfs(0, 0, W - 1, H - 1);\n        if(res <= -INF) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 51\n#define inf 1<<29\n#define inf2 1<<15\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-15)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nint h,w;\nstring grid[MAX];\nint mem[MAX][MAX][MAX][MAX];\nvector<pii> alph;\n\nbool in(int y,int x){\n  if(x<0 || y<0 || w<=x|| h<=y)return false;\n  return true;\n}\n\nint rec(int a,int b,int c,int d){\n  if(!in(a,b))return -inf2;\n  if(!in(c,d))return -inf2;\n  if(c<a || d<b)return -inf2;\n  if(mem[a][b][c][d]!=-inf)return mem[a][b][c][d];\n  if(grid[a][b]=='#')return mem[a][b][c][d]=-inf2;\n  if(grid[c][d]=='#')return mem[a][b][c][d]=-inf2;\n  if(a==c && b==d && grid[a][b]!='#')return mem[a][b][c][d]=0;\n  int res=-inf2;\n  \n  if(grid[a][b]==grid[c][d]+32 && grid[a][b]!='.' && grid[c][d]!='.'){\n    if((a==c && b==d-1) || (a==c-1 && b==d))res = 1;\n    else {\n      res = max(res,rec(a+1,b,c-1,d)+1);\n      res = max(res,rec(a,b+1,c,d-1)+1);\n      res = max(res,rec(a+1,b,c,d-1)+1);\n      res = max(res,rec(a,b+1,c-1,d)+1);\n    }\n  }\n  res = max(res,rec(a+1,b,c,d));\n  res = max(res,rec(a,b+1,c,d));\n  res = max(res,rec(a,b,c-1,d));\n  res = max(res,rec(a,b,c,d-1));\n\n  FOR(i,0,alph.size()){\n    int my = alph[i].f,mx = alph[i].s; \n    if(my==a && mx==b)continue; \n    if(my==c && mx==d)continue;\n    if(my<a || c<my || mx<b || d<mx)continue;\n    res = max(res,rec(a,b,my,mx)+rec(my,mx,c,d));\n  }\n  mem[a][b][c][d] = res;\n  return res;\n}\n\nint solve(){\n  FOR(a,0,h)FOR(b,0,w)FOR(c,0,h)FOR(d,0,w)mem[a][b][c][d]=-inf;\n  alph.clear();\n  FOR(i,0,h)\n    FOR(j,0,w)\n      if(grid[i][j]!='.' && grid[i][j]!='#')alph.pb(mp(i,j));\n  int res = rec(0,0,h-1,w-1);\n  if(res<0)return -1;\n  return res;\n}\n\nint main()\n{\n  while(cin>>h>>w && h){\n    FOR(i,0,h)cin>>grid[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n        int r = 0;\n        if (islower(F[sy][sx])) {\n            for (int y = sy; y <= ty; y++) {\n                for (int x = sx; x <= tx; x++) {\n                    if (y == ty && x == tx) continue;\n                    r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n                }\n            }\n        }\n\n        int d = islower(F[sy][sx]) && toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nbool used[60][60];\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = (int)mp.size();\n  }\n  int V = mp.size();\n  G.resize(V);\n  ws.resize(V);\n\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nbool hasEdge[MAX_V][MAX_V];\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\n  assert( topologicalSort(G,order) );\n\n  // DP\n  int V = G.size();\n\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  assert( V < MAX_V );\n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (top == bottom && left == right) return 0;\n\tif (left > right || top > bottom) return 0;\n\tif (!edge[top][left][bottom][right]) return 0;\n\tif (!valid(top, left, h, w) || !valid(bottom, right, h, w)) return 0;\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint res = 0;\n\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#') chmax(res, solve(top + 1, left, bottom, right));\n\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#') chmax(res, solve(top, left + 1, bottom, right));\n\tif (islower(fld[top][left]))\n\t{\n\t\tint match = is_pair(fld[top][left], fld[bottom][right]);\n\t\tif (match)\n\t\t{\n\t\t\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top + 1, left, bottom, right - 1) + 1);\n\t\t\t\tchmax(res, solve(top + 1, left, bottom - 1, right) + 1);\n\t\t\t}\n\t\t\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top, left + 1, bottom - 1, right) + 1);\n\t\t\t\tchmax(res, solve(top, left + 1, bottom, right - 1) + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t\t{\n\t\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, solve(top, left, i, j) + solve(i, j, bottom, right));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << top << \" \" << left << \" \" << bottom << \" \" << right << endl;\n\t//cout << res << endl;\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (!edge[i][j][x + 1][y] && valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (!edge[i][j][x][y + 1] && valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(h == 1 && w == 1) && !edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t//int a = is_pair(fld[0][0], fld[h - 1][w - 1]);\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[52][52][52][52];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  ret = 0;\n  if( x1 == x2 && y1 == y2 ) return ret;\n\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,x2,y2 ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx = x1+dx[i], ny = y1+dy[i];\n    if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n    if( C[nx][ny] == '#' ) continue;\n    ret = max( ret, solve( nx,ny, x2,y2 ) );      \n  }  \n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x>=W || y>=H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << \"-1\" << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint dp[52][52][52][52];\nint v[52][52][52][52];\nint r[600];\nint w[600];\nint sz;\nint H,W;\nint solve(int a,int b,int c,int d){\n\tif(a>c||b>d)return 0;\n\tif(a<0||b<0||c>=H||d>=W)return 0;\n\tif(str[a][b]=='#'||str[c][d]=='#')return 0;\n\tif(~dp[a][b][c][d])return dp[a][b][c][d];\n\tif(!v[a][b][c][d])return 0;\n\tif(a==c&&b==d)return dp[a][b][c][d]=0;\n\tint ret=0;\n\tif('a'<=str[a][b]&&str[a][b]<='z'&&str[a][b]-32==str[c][d]){\n\t//\tprintf(\"%c %c\\n\",str[a][b],str[c][d]);\n\t\tif(v[a][b][c][d])ret=1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])&&\n\t\t\t\tv[r[j]][w[j]][c][d]&&(c!=r[j]||d!=w[j])&&v[r[i]][w[i]][r[j]][w[j]]){\n\t\t\t//\t\tif(solve(r[i],w[i],r[j],w[j])+1==3)printf(\"%d %d %d %d: %d %d %d %d\\n\",a,b,c,d,r[i],w[i],r[j],w[j]);\n\t\t\t\t\tret=max(ret,solve(r[i],w[i],r[j],w[j])+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])){\n\t\t\t\tret=max(ret,solve(r[i],w[i],c,d));\n\t\t}\n\t\tif(v[r[i]][w[i]][c][d]&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&v[r[i]][w[i]][c][d]&&(a!=r[i]||b!=w[i])&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i],w[i]+1,c,d));\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i]+1,w[i],c,d));\n\t\t}\n\t}\n//\tif(ret>1)printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\tv[i][j][k][l]=0;\n\t\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'&&str[i][j]!='#'){\n\t\t\t\t\tr[sz]=i;w[sz++]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tv[i][j][i][j]=1;\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tif(str[k][l]=='#')continue;\n\t\t\t\tif(k&&v[i][j][k-1][l])v[i][j][k][l]=1;\n\t\t\t\tif(l&&v[i][j][k][l-1])v[i][j][k][l]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=solve(0,0,a-1,b-1);\n\t\tif(!v[0][0][a-1][b-1])printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 52\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nV v[50][50];\nvoid visit(int x,int y){\n  V &D = v[y][x] = V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  V &D = v[y][x];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  V &D = v[0][0];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if((a.first==b.first||a.second == b.second)||\n     (x1>=0&&y1>=0&&!v[y1][x1][y2][x2])||\n     (!v[Y2][X2][h-1][w-1])||\n     (X1<w&&X2<h&&!v[Y2][X2][Y1][X1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n\n    visit(0,0),visit(w-1,h-1);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)if(isalpha(mp[i][j]))visit(j,i);\n    \n    mkA();\n    if(!v[0][0][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[2] = {0, 1};\nconstexpr int dy[2] = {1, 0};\n\nint H, W;\nint dp[51][51][51][51];\nbool can[51][51][51][51];\nvector<pii> alphas[26];\n\nbool is_range(int y, int x) {\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint rec(int ly, int lx, int ry, int rx, vector<string> const& C) {\n    if(ry - ly + rx - lx == -1) { // ?????????????????????????¨±???\n        return 0;\n    }\n    if(!is_range(ly, lx) || !is_range(ry, rx)) {\n        return -1;\n    }\n    if(ry < ly || rx < lx) {\n        return -1;\n    }\n    int& res = dp[ly][lx][ry][rx];\n    if(!can[ly][lx][ry][rx]) {\n        return res = -1;\n    }\n    if(res != -2) {\n        return res;\n    }\n    res = 0;\n    res = max({res, rec(ly + 1, lx, ry, rx, C), rec(ly, lx + 1, ry, rx, C)});\n    if(islower(C[ly][lx])) {\n        for(auto& p : alphas[C[ly][lx] - 'a']) {\n            int y = p.first, x = p.second;\n            if(ly <= y && y <= ry && lx <= x && x <= rx) {\n                int t = -1;\n                for(int i = 0; i < 2; ++i) {\n                    for(int j = 0; j < 2; ++j) {\n                        t = max(t, rec(ly + dy[i], lx + dx[i], y - dy[j], x - dx[j], C));\n                    }\n                }\n                int t2 = -1;\n                for(int i = 0; i < 2; ++i) {\n                    t2 = max(t2, rec(y + dy[i], x + dx[i], ry, rx, C));\n                }\n                if(t >= 0 && t2 >= 0) {\n                    res = max(res, 1 + t + t2);\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    while(cin >> H >> W, H) {\n        vector<string> C(H);\n        for(int i = 0; i < H; ++i) {\n            cin >> C[i];\n        }\n\n        fill(dp[0][0][0], dp[51][0][0], -2);\n        fill(can[0][0][0], can[51][0][0], false);\n        for(int i = 0; i < 26; ++i) {\n            alphas[i].clear();\n        }\n\n        for(int i = 0; i < H; ++i) {\n            for(int j = 0; j < W; ++j) {\n                if(isupper(C[i][j])) {\n                    alphas[C[i][j] - 'A'].emplace_back(i, j);\n                }\n                if(C[i][j] != '#') {\n                    can[i][j][i][j] = true;\n                    queue<pii> que;\n                    que.emplace(i, j);\n                    while(!que.empty()) {\n                        int y = que.front().first;\n                        int x = que.front().second;\n                        que.pop();\n                        for(int k = 0; k < 2; ++k) {\n                            int ny = y + dy[k];\n                            int nx = x + dx[k];\n                            if(is_range(ny, nx) && C[ny][nx] != '#' && !can[i][j][ny][nx]) {\n                                can[i][j][ny][nx] = true;\n                                que.emplace(ny, nx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << rec(0, 0, H - 1, W - 1, C) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[26];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    for(int y=h-1; y>=0; --y) for(int x=w-1; x>=0; --x){\n        if('A'<=c[y][x] and c[y][x]<='Z') ps[c[y][x]-'A'].push_back(make_pair(y,x));\n        can_move[y][x][y][x]=true;\n        rep(i,0,2){\n            int ny=y+dy[i],nx=x+dx[i];\n            if(!ok(ny,nx)) continue;\n            can_move[y][x][ny][nx]=true;\n            rep(y_,ny,h) rep(x_,nx,w) can_move[y][x][y_][x_]|=can_move[ny][nx][y_][x_];\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return memo[y1][x1][y2][x2]=0;\n        if(!can_move[y1][x1][y2][x2]) return memo[y1][x1][y2][x2]=-inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[c[y1][x1]-'a']){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<cctype>\n\nusing namespace std;\n\nint H,W;\nchar C[50][52];\nvector<pair<int,int> > p[256];\nbool memed[52][52][52][52];\nint mem[52][52][52][52];\n\nint rec(int hy,int hx,int ty,int tx){\n  if(ty<hy||tx<hx||C[hy][hx]=='#')return -1e9;\n  if(hy==ty&&hx==tx)return 0;\n  if(memed[hy][hx][ty][tx]++)return mem[hy][hx][ty][tx];\n  int mx=max(rec(hy+1,hx,ty,tx),rec(hy,hx+1,ty,tx));\n  if(islower(C[hy][hx])){\n    for(auto e:p[toupper(C[hy][hx])]){\n      if(ty<e.first||tx<e.second)continue;\n      int sx=-1e9;\n      if(hy+1==e.first&&hx==e.second||hy==e.first&&hx+1==e.second){\n\tsx=1;\n      }else{\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<2;j++){\n\t    sx=max(sx,rec(hy+i,hx+(i^1),e.first-j,e.second-(j^1))+1);\n\t  }\n\t}\n      }\n      if(e.first==ty&&e.second==tx){\n\tmx=max(mx,sx);\n      }else{\n\tfor(int i=0;i<2;i++){\n\t  mx=max(mx,sx+rec(e.first+i,e.second+(i^1),ty,tx));\n\t}\n      }\n    }\n  }\n  return mem[hy][hx][ty][tx]=mx;\n}\n\nint main(){\n  while(cin>>H>>W,H|W){\n    fill(***begin(memed),***end(memed),false);\n    for(auto &e:p){\n      e.clear();\n    }\n    for(int i=0;i<H;i++){\n      cin>>C[i];\n      for(int j=0;j<W;j++){\n\tp[C[i][j]].emplace_back(i,j);\n      }\n    }\n    int ans=rec(0,0,H-1,W-1);\n    cout<<((ans<0)?-1:ans)<<endl;\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[2][55][55][55][55];\nbool used[2][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='#') continue;\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(c&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(0,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(0,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  used[c][sy][sx][ty][tx]=1;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' && map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' && map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[2]={1,0};\nconst int dy[2]={0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 60;\n\n// y1, x1, y2, x2 ( [y1, y2), [x1, x2) )\nint memo[N][N][N + 1][N + 1];\n\nint h, w;\nvector<string> field;\n\nvi next_ys[N][N];\nvi next_xs[N][N];\n\nint ok[N][N][N + 1][N + 1];\n\ninline bool is_valid(int y1, int x1, int y2, int x2){\n    return ok[y1][x1][y2][x2];\n}\n\nint rec(int y1, int x1, int y2, int x2){\n    int& ret = memo[y1][x1][y2][x2];\n    if(ret != -2){\n        return ret;\n    }\n    if(y1 + 1 == y2 and x1 + 1 == x2){\n        return (ret = 0);\n    }\n\n    ret = -1;\n\n    // not pick up\n    if(is_valid(y1 + 1, x1, y2, x2)){\n        chmax(ret, rec(y1 + 1, x1, y2, x2));\n    }\n    if(is_valid(y1, x1 + 1, y2, x2)){\n        chmax(ret, rec(y1, x1 + 1, y2, x2));\n    }\n\n    // pick up\n    rep(i, (int)next_ys[y1][x1].size()){\n        int yy = next_ys[y1][x1][i];\n        int xx = next_xs[y1][x1][i];\n        if(yy >= y2 or xx >= x2) continue;\n\n        int cur = 1;\n        if(is_valid(y1 + 1, x1, yy, xx + 1)){ // vv\n            chmax(cur, 1 + rec(y1 + 1, x1, yy, xx + 1));\n        }\n        if(is_valid(y1 + 1, x1, yy + 1, xx)){ // v>\n            chmax(cur, 1 + rec(y1 + 1, x1, yy + 1, xx));\n        }\n        if(is_valid(y1, x1 + 1, yy, xx + 1)){ // >v\n            chmax(cur, 1 + rec(y1, x1 + 1, yy, xx + 1));\n        }\n        if(is_valid(y1, x1 + 1, yy + 1, xx)){ // >>\n            chmax(cur, 1 + rec(y1, x1 + 1, yy + 1, xx));\n        }\n\n        if(yy == y2 - 1 and xx == x2 - 1) chmax(ret, cur);\n        if(is_valid(yy, xx, y2, x2)) chmax(ret, cur + rec(yy, xx, y2, x2)); // ??v\n    }\n\n    return ret;\n}\n\nvector<vi> used;\nvoid dfs(int y, int x, int oy, int ox){\n    used[y][x] = true;\n    ok[oy][ox][y + 1][x + 1] = true;\n    if(field[y][x] - 'A' + 'a' == field[oy][ox]){\n        next_ys[oy][ox].emplace_back(y);\n        next_xs[oy][ox].emplace_back(x);\n    }\n\n    rep(i, 2){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n\n        if(0 <= ny and ny < h and 0 <= nx and nx < w and field[ny][nx] != '#' and not used[ny][nx]) dfs(ny, nx, oy, ox);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        cin >> h >> w;\n        if(h == 0 and w == 0) break;\n\n        field = vector<string>(h);\n        for(auto& e : field) cin >> e;\n\n        rep(y1, h) rep(x1, w) rep(y2, h + 1) rep(x2, w + 1) memo[y1][x1][y2][x2] = -2;\n        rep(y1, h) rep(x1, w) rep(y2, h + 1) rep(x2, w + 1) ok[y1][x1][y2][x2] = false;\n        rep(y, h) rep(x, w){\n            next_xs[y][x] = vi(); next_ys[y][x] = vi();\n            if(field[y][x] == '#') continue;\n            used = vector<vi>(h, vi(w));\n            dfs(y, x, y, x);\n        }\n        cout << rec(0, 0, h, w) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define srep(i,n,m) for(int i=(int)n;i<=(int)m;i++)\nint n,m;\nint dp[52][52][52][52];\nbool ok[52][52][52][52];\nint inf = 1000000;\nvector<string>s;\nint saiki(int a,int b,int c,int d){\n    if(a<0||a>=n||c<0||c>=n||b<0||b>=m||d<0||d>=m)return -inf;\n    if(s[a][b]=='#'||s[c][d]=='#')return -inf;\n    if(a==c&&b==d)return 0;\n    if(ok[a][b][c][d])return dp[a][b][c][d]; \n    ok[a][b][c][d] = 1;\n    if(a>c||b>d){\n        return dp[a][b][c][d] = -inf;\n    }\n    if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]==s[a][b]+('A'-'a')){\n        if(c==a+1&&b==d)return dp[a][b][c][d]=1;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=1;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c-1,d)+1);\n        tmp = max(tmp,saiki(a+1,b,c,d-1)+1);\n        tmp = max(tmp,saiki(a,b+1,c-1,d)+1);\n        tmp = max(tmp,saiki(a,b+1,c,d-1)+1);\n        srep(i,a,c){\n            srep(j,b,d){\n                if(i==c&&j==d)continue;\n                if(s[i][j]!=s[a][b]+('A'-'a'))continue;\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n            }\n        }\n        \n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }else{\n        if(c==a+1&&b==d)return dp[a][b][c][d]=0;\n        if(c==a&&d==b+1)return dp[a][b][c][d]=0;\n        int tmp = -inf;\n        tmp = max(tmp,saiki(a+1,b,c,d));\n        tmp = max(tmp,saiki(a,b,c-1,d));\n        tmp = max(tmp,saiki(a,b+1,c,d));\n        tmp = max(tmp,saiki(a,b,c,d-1));\n        if(s[a][b]>='a'&&s[a][b]<='z'&&s[c][d]>='A'&&s[c][d]<='Z'){\n            srep(i,a,c){\n                srep(j,b,d){\n                    if(i==c&&j==d)continue;\n                    if(s[i][j]!=s[a][b]+('A'-'a'))continue;\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i+1,j,c,d));\n                    tmp = max(tmp,saiki(a,b,i,j)+saiki(i,j+1,c,d));\n                }\n            }\n        }\n        if(tmp<0)tmp = -inf;\n        return dp[a][b][c][d] = tmp;\n    }\n}\n\n\nint main(){\n    while(cin >> n >> m &&n!=0){\n        s.resize(n);\n        rep(i,n)cin >> s[i];\n        rep(i,52){\n            rep(j,52){\n                rep(k,52){\n                    rep(l,52){\n                        dp[i][j][k][l] = 0;\n                        ok[i][j][k][l] = 0;\n                    }\n                }\n            }\n        }\n        int ans = saiki(0,0,n-1,m-1);\n        if(ans<0){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1000000000;\nint h,w;\n\nint func(const vector<pair<int,int>>& v, int f, int t,\n    const vector<vector<int>>& d,\n    vector<vector<int>>& memo, bool fst = false) {\n  if (memo[f][t] >= 0) return memo[f][t];\n  int mxn = 0;\n  for(auto p:v) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    if (d[f][fp] < INF && d[tp][t] < INF) {\n      if (f == fp && t == tp && !fst) continue;\n      mxn = max(mxn, func(v, fp, tp, d, memo) + func(v, tp, t, d, memo) + 1);\n    }\n  }\n  return memo[f][t] = mxn;\n}\n\n\nint main() {\n  while(1){\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> m(h+1, string(w+1, '#'));\n    REP(i,h) {\n      string l;\n      cin>>l;\n      m[i] = l + \"#\";\n    }\n    int n = h*w;\n    vector<vector<int>> d(n, vector<int>(n,INF));\n    d[0][0] = 0;\n    d[n-1][n-1] = 0;\n    REP(i,h)REP(j,w) {\n      int ind = i*w+j;\n      if (m[i][j] != '#') {\n        if (m[i+1][j] != '#') d[ind][ind + w] = 1;\n        if (m[i][j+1] != '#') d[ind][ind + 1] = 1;\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int diff = 'A' - 'a';\n    vector<pair<int, int>> v;\n    REP(i,n)REP(j,n) {\n      int ii=i/w, ij=i%w;\n      int ji=j/w, jj=j%w;\n      if (d[i][j] < INF && m[ii][ij] + diff == m[ji][jj]) v.emplace_back(i,j);\n    }\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    if (d[0][n-1] < INF)\n      cout << func(v, 0, n-1, d, memo, true) << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,C;\nchar s[100],a[100];\nchar t[100][100];\nint id[100][100];\nint INF=1e8;\nmap<int,int> dp[100][100];\nint ans;\n\nint dfs(int y,int x,int bit){\n\n  if(y<0||x<0||y>=H||x>=W)return -INF;\n\n  if(t[y][x]=='#')return -INF;\n\n  int res=0;\n  if('a'<=t[y][x]&&t[y][x]<='z'){\n    bit|=(1<<id[y][x]);\n  }\n  \n  if(dp[y][x].count(bit)){\n    return dp[y][x][bit];\n  }\n  \n  int flg=0;\n  int nbit=bit;\n  if('A'<=t[y][x]&&t[y][x]<='Z'){\n    for(int i=C-1;i>=0;i--){\n      if( (nbit>>i&1) && a[i]==t[y][x] ){\n        flg=1;\n        break;\n      }else{\n        nbit|=(1<<i);\n        nbit-=(1<<i);\n      }\n    }\n  }\n  \n  if(y==H-1&&x==W-1){\n    ans=1;\n    return flg;\n  }\n\n\n  res=max(res,dfs(y+1,x,bit));\n  res=max(res,dfs(y,x+1,bit));\n  res=max(res,dfs(y+1,x,nbit)+flg);\n  res=max(res,dfs(y,x+1,nbit)+flg);\n  return dp[y][x][bit]=max(res,flg);\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        dp[i][j].clear();\n    \n    C=0;\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",s);\n      for(int j=0;j<W;j++){\n        t[i][j]=s[j];\n        if('a'<=t[i][j]&&t[i][j]<='z'){\n          a[C]=t[i][j]-'a'+'A';\n          id[i][j]=C++;\n        }\n      }\n    }\n\n    ans=0;\n    if(ans){\n      cout<<dfs(0,0,0)<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint H,W;\nstring s[50];\nint memo[50][50][50][50];\nbool vis[50][50][50][50];\nint dx[2]={1,0},dy[2]={0,1};\nvector<P> ps[26];\ninline bool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nint rec(int a,int b,int c,int d){\t//(a,b)->(c,d)\n\tif(c+d-b-a==-1) return 0;\n\tif(!is(a,b)||!is(c,d)) return -1;\n\tif(a>c||b>d) return -1;\n\tif(vis[a][b][c][d]) return memo[a][b][c][d];\n\tvis[a][b][c][d]=1;\n\tint &val=memo[a][b][c][d];\n\tif(c+d-b-a==0){\n\t\treturn val=0;\n\t}\n\tif(c+d-b-a==1){\n\t\tif(islower(s[a][b])&&s[a][b]-'a'==s[c][d]-'A') return val=1;\n\t\telse return val=0;\n\t}\n\tchmax(val,max(rec(a+1,b,c,d),rec(a,b+1,c,d)));\n\tif(islower(s[a][b])){\n\t\tint ch=s[a][b]-'a';\n\t\tfor(P p:ps[ch]){\n\t\t\tint x=p.fs,y=p.sc;\n\t\t\tif(a<=x&&x<=c&&b<=y&&y<=d){\n\t\t\t\tint tmp=-1;\n\t\t\t\trep(i,2) rep(j,2) chmax(tmp,rec(a+dx[i],b+dy[i],x-dx[j],y-dy[j]));\n\t\t\t\tint tmp2=-1;\n\t\t\t\trep(i,2) chmax(tmp2,rec(x+dx[i],y+dy[i],c,d));\n\t\t\t\tif(tmp>=0&&tmp2>=0) chmax(val,1+tmp+tmp2);\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\trep(i,26) ps[i].clear();\n\t\trep(i,H) cin>>s[i];\n\t\trep(i,H) rep(j,W) if(isupper(s[i][j])) ps[s[i][j]-'A'].pb(P(i,j));\n\t\trep(a,H) rep(b,W) rep(c,H) rep(d,W) memo[a][b][c][d]=-1,vis[a][b][c][d]=0;\n\t\tint tmp=rec(0,0,H-1,W-1);\n\t\tif(tmp<0){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tcout<<tmp<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (top == bottom && left == right) return 0;\n\tif (left > right || top > bottom) return 0;\n\tif (!valid(top, left, h, w) || !valid(bottom, right, h, w)) return 0;\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint res = 0;\n\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#') chmax(res, solve(top + 1, left, bottom, right));\n\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#') chmax(res, solve(top, left + 1, bottom, right));\n\tif (islower(fld[top][left]))\n\t{\n\t\tint match = is_pair(fld[top][left], fld[bottom][right]);\n\t\tif (match)\n\t\t{\n\t\t\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top + 1, left, bottom, right - 1) + 1);\n\t\t\t\tchmax(res, solve(top + 1, left, bottom - 1, right) + 1);\n\t\t\t}\n\t\t\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top, left + 1, bottom - 1, right) + 1);\n\t\t\t\tchmax(res, solve(top, left + 1, bottom, right - 1) + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t\t{\n\t\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, solve(top, left, i, j) + solve(i, j, bottom, right));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << top << \" \" << left << \" \" << bottom << \" \" << right << endl;\n\t//cout << res << endl;\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (!edge[i][j][x + 1][y] && valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (!edge[i][j][x][y + 1] && valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(h == 1 && w == 1) && !edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t//int a = is_pair(fld[0][0], fld[h - 1][w - 1]);\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nint dx[2]={1,0},dy[2]={0,1};\nint INF=1<<28;\n\nclass Main{\npublic:\n\n\tint dfs(int y1,int x1,int y2,int x2){\n\t\tif(!(y1<=y2 && x1<=x2))return 0;\n\t\tif(!(IN(0,y1,N) && IN(0,x1,M) && IN(0,y2,N) && IN(0,x2,M))) return -INF;\n\t\tif(dp[y1][x1][y2][x2]!=-INF)return dp[y1][x1][y2][x2];\n\n\t\tif(!move[y1][x1][y2][x2])return  dp[y1][x1][y2][x2]=-1;\n\n\t\tint res=-1;\n\t\tREP(d1,2)res=max(res,dfs(y1+dy[d1],x1+dx[d1],y2,x2));\n\n\t\tif(islower(board[y1][x1])){\n\t\t\tint c=board[y1][x1]-'a';\n\t\t\tREP(i,holes[c].size()){\n\t\t\t\tint ny=holes[c][i].first,nx=holes[c][i].second;\n\t\t\t\tif(!(move[y1][x1][ny][nx] && (y1<=ny && ny <=y2) && (x1<=nx && nx<=x2)))continue;\n\t\t\t\tREP(d1,2)REP(d2,2){\n\t\t\t\t\tres=max(res,dfs(y1+dy[d1],x1+dx[d1],ny-dy[d2],nx-dx[d2])+dfs(ny,nx,y2,x2)+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n\n\tint N,M;\n\tvector<string> board;\n\tvector<vector<vector<vector<int> > > > dp;\n\tvector<vector<vector<vector<bool> > > > move;\n\tvector<vector<pair<int,int>>> holes;\n\n\tvoid run(){\n\t\t // ifstream cin(\"in\");\n\t\t // ofstream cout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >> N >> M;\n\t\t\tif(N==0)break;\n\t\t\tboard=vector<string>(N);\n\t\t\tREP(i,N) cin >> board[i];\n\n\t\t\tholes=vector<vector<pair<int,int>>> (26);\n\t\t\tREP(y,N)REP(x,M){\n\t\t\t\tif(isupper(board[y][x]))holes[board[y][x]-'A'].push_back(make_pair(y,x));\n\t\t\t}\n\n\t\t\tmove=vector<vector<vector<vector<bool> > > >(N,vector<vector<vector<bool> > >(M,\tvector<vector<bool> >(N,vector<bool>(M))));\n\t\t\tREP(y1,N)REP(x1,M){\n\t\t\t\tif(board[y1][x1]!='#') move[y1][x1][y1][x1]=true;\n\t\t\t\tREP(y2,N)REP(x2,M){\n\t\t\t\t\tif(y2-1>=y1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2-1][x2];\n\t\t\t\t\tif(x2-1>=x1) move[y1][x1][y2][x2] = move[y1][x1][y2][x2] | move[y1][x1][y2][x2-1];\n\t\t\t\t\tif(board[y2][x2]=='#') move[y1][x1][y2][x2]=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp=vector<vector<vector<vector<int> > > >(N,vector<vector<vector<int> > >(M,\tvector<vector<int> >(N,vector<int>(M,-INF))));\t\n\t\t\t//h=0 w=0\n\t\t\tREP(y,N)REP(x,M)if(board[y][x]!='#') dp[y][x][y][x]=0;\n\t\t\tcout <<dfs(0,0,N-1,M-1)<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tcout <<fixed<<setprecision(13);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_H = 50;\nconstexpr int MAX_W = 50;\nconstexpr int MAX_C = 26;\n\nint H, W;\nchar C[MAX_H][MAX_W];\nvector<pair<int, int>> holes[MAX_C];\n\nint mem[MAX_H][MAX_W][MAX_H][MAX_W];\nbool is_reach[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool input()\n{\n    cin >> H >> W;\n    \n    if (H == 0 && W == 0) {\n        return 0;\n    }\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> C[i][j];\n        }\n    }\n    \n    return 1;\n}\n\nvoid init()\n{\n    for (int i = 0; i < MAX_C; i++) {\n        holes[i].clear();\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            for (int k = 0; k < H; k++) {\n                for (int l = 0; l < W; l++) {\n                    mem[i][j][k][l] = -1;\n                    is_reach[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n}\n\nvoid fill()\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if ('A' <= C[i][j] && C[i][j] <= 'Z') {\n                holes[C[i][j] - 'A'].emplace_back(j, i);\n            }\n        }\n    }\n}\n\nbool in_field(int x, int y)\n{\n    return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid bfs()\n{\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            is_reach[i][j][i][j] = 1;\n            \n            queue<pair<int, int>> Q;\n            Q.push(make_pair(j, i));\n\n            constexpr int dx[] = {0, 1};\n            constexpr int dy[] = {1, 0};\n            \n            while (!Q.empty()) {\n                int x, y;\n                tie(x, y) = Q.front(); Q.pop();\n\n                for (int k = 0; k < 2; k++) {\n                    int nx = x + dx[k], ny = y + dy[k];\n                    \n                    if (!in_field(nx, ny) || C[ny][nx] == '#') {\n                        continue;\n                    }\n\n                    if (!is_reach[i][j][ny][nx]) {\n                        is_reach[i][j][ny][nx] = 1;\n                        Q.push(make_pair(nx, ny));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint rec(int x1, int y1, int x2, int y2)\n{\n    int& res = mem[y1][x1][y2][x2];\n        \n    if (res != -1) {\n        return res;\n    }\n\n    if (x1 == x2 && y1 == y2) {\n        return res = 0;\n    }\n\n    constexpr int dx[] = {0, 1};\n    constexpr int dy[] = {1, 0};\n    \n    if (C[y1][x1] != '#') {\n        for (int i = 0; i < 2; i++) {\n            int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n            if (in_field(nx1, ny1) && C[ny1][nx1] != '#') {\n                res = max(res, rec(nx1, ny1, x2, y2));\n            }            \n        }\n    }\n    \n    if (islower(C[y1][x1])) {        \n        for (auto& p : holes[C[y1][x1] - 'a']) {\n            int x, y;\n            tie(x, y) = p;\n\n            if (!is_reach[y1][x1][y][x] || !is_reach[y][x][y2][x2]) {\n                continue;\n            }\n\n            if (abs(x1 - x) + abs(y1 - y) == 1) {                \n                res = max(res, rec(x, y, x2, y2) + 1);\n                continue;\n            }\n            \n            for (int i = 0; i < 2; i++) {\n                int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n                for (int j = 0; j < 2; j++) {\n                    int nx = x - dx[j], ny = y - dy[j];\n                    \n                    if (!in_field(nx, ny) || !is_reach[ny1][nx1][ny][nx]) {\n                        continue;\n                    }\n                                        \n                    res = max(res, rec(nx1, ny1, nx, ny) + rec(x, y, x2, y2) + 1);\n                }\n            }\n            \n        }\n    }\n         \n    return res;\n}\n\nint solve()\n{\n    init();\n    fill();\n    bfs();\n\n    if (!is_reach[0][0][H - 1][W - 1]) {\n        return -1;\n    }\n    \n    return rec(0, 0, W - 1, H - 1);    \n}\n\nint main()\n{\n    while (input()) {\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n \nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n    if(x1>x2||y1>y2)return -20000;\n    if(v[x1][y1]=='#'||v[x2][y2]=='#')return -20000;\n    if(dp[x1][y1][x2][y2]!=-100000){\n        return dp[x1][y1][x2][y2];\n    }\n    if(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n    if(x2-x1==1&&y2-y1==0){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    if(x2-x1==0&&y2-y1==1){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    int tmp = -1000;\n    if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n        tmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n    }\n    tmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n    if(tmp>=0){\n        return dp[x1][y1][x2][y2] = tmp;\n    }\n    return dp[x1][y1][x2][y2] = -20000;\n}\n \nint saiki2(int x1,int y1,int x2,int y2){\n    if(x1>x2||y1>y2)return -1000;\n    if(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n    if(dp2[x1][y1][x2][y2]!=-100000)return dp2[x1][y1][x2][y2];\n    int mx = dp[x1][y1][x2][y2];\n    for(int i=x1;i<=x2;i++){\n        for(int j=y1;j<=y2;j++){\n            if(i==x1&&j==y1)continue;\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i,j+1,x2,y2));\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i+1,j,x2,y2));\n        }\n    }\n    return dp2[x1][y1][x2][y2] = mx;\n \n}\n \nint main() {\n    while(cin >> h >> w && h!=0){\n        vector<string> v(h);\n        rep(i,h){\n            cin >> v[i];\n        }\n        rep(i,51){\n            rep(j,51){\n                rep(k,51){\n                    rep(l,51){\n                        dp[i][j][k][l] = -100000;\n                        dp2[i][j][k][l] = -100000;\n                    }\n                }\n            }\n        }           \n        int ans = saiki(0,0,h-1,w-1,v);\n        ans = saiki2(0,0,h-1,w-1);\n        if(ans>=0){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nint H, W;\n\nll dp[55][55][55][55];\nll dist[55][55];\nstring S[55];\nint DH[3] = {0, 1, 0};\nint DW[3] = {1, 0, 0};\n\nvoid solve() {\n    for(int i = 0; i < H; i++) cin >> S[i];\n    for(int h = 0; h <= H; h++) {\n        for(int w = 0; w <= W; w++) {\n            dist[h][w] = -INF;\n            for(int a = 0; a <= H; a++) {\n                for(int b = 0; b <= W; b++) {\n                    dp[h][w][a][b] = -INF;\n                }\n            }\n        }\n    }\n    dist[0][0] = 0;\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if(S[h][w] == '#') continue;\n            dp[h][w][h][w] = 0;\n            for(int k = 0; k < 2; k++) {\n                int newh = h + DH[k];\n                int neww = w + DW[k];\n                if(newh == H) continue;\n                if(neww == W) continue;\n                if(S[newh][neww] == '#') continue;\n                dp[h][w][newh][neww] = 0;\n                if(S[h][w] == '.') continue;\n                if(S[newh][neww] == '.') continue;\n                if(S[h][w] + ('A' - 'a') == S[newh][neww]) dp[h][w][newh][neww]++;\n            }\n        }\n    }\n    for(int dh = 0; dh <= H; dh++) {\n        for(int dw = 0; dw <= W; dw++) {\n            for(int h1 = 0; h1 < H; h1++) {\n                for(int w1 = 0; w1 < W; w1++) {\n                    int h2 = h1 + dh;\n                    int w2 = w1 + dw;\n                    if(h2 >= H) continue;\n                    if(w2 >= W) continue;\n                    if(h2 < 0) continue;\n                    if(w2 < 0) continue;\n                    if(dp[h1][w1][h2][w2] < 0) continue;\n                    if(S[h1][w1] == '#') continue;\n                    if(S[h2][w2] == '#') continue;\n                    for(int k1 = 0; k1 < 3; k1++) {\n                        for(int k2 = 0; k2 < 3; k2++) {\n                            int newh1 = h1 - DH[k1];\n                            int neww1 = w1 - DW[k1];\n                            int newh2 = h2 + DH[k2];\n                            int neww2 = w2 + DW[k2];\n                            if(newh1 < 0 or newh1 >= H) continue;\n                            if(newh2 < 0 or newh2 >= H) continue;\n                            if(neww1 < 0 or neww1 >= W) continue;\n                            if(neww2 < 0 or neww2 >= W) continue;\n                            if(newh1 > newh2) continue;\n                            if(neww1 > neww2) continue;\n                            if(S[newh1][neww1] == '#') continue;\n                            if(S[newh2][neww2] == '#') continue;\n                            ll deltac = 0;\n                            if(k1 < 2 and k2 < 2 and 'a' <= S[newh1][neww1] and S[newh1][neww1] <= 'z' and S[newh2][neww2] - S[newh1][neww1] == 'A' - 'a') deltac = 1;\n                            ll newc = dp[h1][w1][h2][w2];\n                            chmax(dp[newh1][neww1][newh2][neww2], newc + deltac);\n                        }\n                    }\n                    //cerr << h1 << \" \" << w1 << \" \" << h2 << \" \" << w2 << \" \" << dp[h1][w1][h2][w2] << endl;\n                }\n            }\n        }\n    }\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            if(dist[h][w] < 0) continue;\n            for(int h2 = h; h2 < H; h2++) {\n                for(int w2 = w; w2 < W; w2++) {\n                    if(h == h2 and w == w2) continue;\n                    //if(dp[h][w][h2][w2] < 0) continue;\n                    chmax(dist[h2][w2], dist[h][w] + dp[h][w][h2][w2]);\n                    chmax(dist[h2][w2], dist[h][w] + dp[h+1][w][h2][w2]);\n                    chmax(dist[h2][w2], dist[h][w] + dp[h][w+1][h2][w2]);\n                }\n            }\n        }\n    }\n    ll ans = dist[H-1][W-1];\n    if(ans < 0) ans = -1;\n    for(int h = 0; h < H; h++) {\n        //cout << S[h] << endl;\n    }\n    if(ans == 10) ans = 11;\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W) {\n        if(H == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[2]={1,0};\nconst int dy[2]={0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 50;\n\n// y1, x1, y2, x2 ( [y1, y2), [x1, x2) )\nint memo[N][N][N + 1][N + 1];\n\nint h, w;\nvector<string> field;\n\nvi next_ys[N][N];\nvi next_xs[N][N];\n\nint ok[N][N][N + 1][N + 1];\n\ninline bool is_valid(int y1, int x1, int y2, int x2){\n    return ok[y1][x1][y2][x2];\n}\n\nint rec(int y1, int x1, int y2, int x2){\n    int& ret = memo[y1][x1][y2][x2];\n    if(ret != -2){\n        return ret;\n    }\n    if(y1 + 1 == y2 and x1 + 1 == x2){\n        return (ret = 0);\n    }\n\n    ret = -1;\n\n    // not pick up\n    if(is_valid(y1 + 1, x1, y2, x2)){\n        chmax(ret, rec(y1 + 1, x1, y2, x2));\n    }\n    if(is_valid(y1, x1 + 1, y2, x2)){\n        chmax(ret, rec(y1, x1 + 1, y2, x2));\n    }\n\n    // pick up\n    rep(i, (int)next_ys[y1][x1].size()){\n        int yy = next_ys[y1][x1][i];\n        int xx = next_xs[y1][x1][i];\n        if(yy >= y2 or xx >= x2) continue;\n\n        int cur = 1;\n        if(is_valid(y1 + 1, x1, yy, xx + 1)){ // vv\n            chmax(cur, 1 + rec(y1 + 1, x1, yy, xx + 1));\n        }\n        if(is_valid(y1 + 1, x1, yy + 1, xx)){ // v>\n            chmax(cur, 1 + rec(y1 + 1, x1, yy + 1, xx));\n        }\n        if(is_valid(y1, x1 + 1, yy, xx + 1)){ // >v\n            chmax(cur, 1 + rec(y1, x1 + 1, yy, xx + 1));\n        }\n        if(is_valid(y1, x1 + 1, yy + 1, xx)){ // >>\n            chmax(cur, 1 + rec(y1, x1 + 1, yy + 1, xx));\n        }\n\n        if(yy == y2 - 1 and xx == x2 - 1) chmax(ret, cur);\n        if(is_valid(yy, xx, y2, x2)) chmax(ret, cur + rec(yy, xx, y2, x2)); // ??v\n    }\n\n    return ret;\n}\n\nvector<vi> used;\nvoid dfs(int y, int x, int oy, int ox){\n    used[y][x] = true;\n    ok[oy][ox][y + 1][x + 1] = true;\n    if(field[y][x] - 'A' + 'a' == field[oy][ox]){\n        next_ys[oy][ox].emplace_back(y);\n        next_xs[oy][ox].emplace_back(x);\n    }\n\n    rep(i, 2){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n\n        if(0 <= ny and ny < h and 0 <= nx and nx < w and field[ny][nx] != '#' and not used[ny][nx]) dfs(ny, nx, oy, ox);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        cin >> h >> w;\n        if(h == 0 and w == 0) break;\n\n        field = vector<string>(h);\n        for(auto& e : field) cin >> e;\n\n        rep(y1, h) rep(x1, w) rep(y2, h + 1) rep(x2, w + 1) memo[y1][x1][y2][x2] = -2;\n        rep(y1, h) rep(x1, w) rep(y2, h + 1) rep(x2, w + 1) ok[y1][x1][y2][x2] = false;\n        rep(y, h) rep(x, w){\n            next_xs[y][x] = vi(); next_ys[y][x] = vi();\n            if(field[y][x] == '#') continue;\n            used = vector<vi>(h, vi(w));\n            dfs(y, x, y, x);\n        }\n        cout << rec(0, 0, h, w) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int INF = 1000000000;\nint h,w;\n\nint func(const vector<pair<int,int>>& v, int f, int t,\n    const vector<vector<int>>& d,\n    vector<vector<int>>& memo, bool fst = false) {\n  if (memo[f][t] >= 0) return memo[f][t];\n  int mxn = 0;\n  vector<pair<int,int>> nv;\n  for(auto p:v) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    if (d[f][fp] < INF && d[tp][t] < INF) {\n      if (f == fp && !fst) continue;\n      nv.push_back(p);\n    }\n  }\n  for (auto p:nv) {\n    int fp,tp;\n    tie(fp,tp) = p;\n    mxn = max(mxn, func(nv, fp, tp, d, memo) + func(nv, tp, t, d, memo) + 1);\n  }\n  return memo[f][t] = mxn;\n}\n\n\nint main() {\n  while(1){\n    cin>>h>>w;\n    if(!h) break;\n    vector<string> m(h+1, string(w+1, '#'));\n    REP(i,h) {\n      string l;\n      cin>>l;\n      m[i] = l + \"#\";\n    }\n    int n = h*w;\n    vector<vector<int>> d(n, vector<int>(n,INF));\n    d[0][0] = 0;\n    d[n-1][n-1] = 0;\n    REP(i,h)REP(j,w) {\n      int ind = i*w+j;\n      if (m[i][j] != '#') {\n        if (m[i+1][j] != '#') d[ind][ind + w] = 1;\n        if (m[i][j+1] != '#') d[ind][ind + 1] = 1;\n      }\n    }\n    REP(i,n)REP(j,n) {\n      int ji=j/w, jj=j%w;\n      if (ji > 0)\n        d[i][j] = min(d[i][j], d[i][j-w] + d[j-w][j]);\n      if (jj > 0)\n        d[i][j] = min(d[i][j], d[i][j-1] + d[j-1][j]);\n    }\n    int diff = 'A' - 'a';\n    vector<pair<int, int>> v;\n    REP(i,n)REP(j,n) {\n      int ii=i/w, ij=i%w;\n      int ji=j/w, jj=j%w;\n      if (d[i][j] < INF && m[ii][ij] + diff == m[ji][jj]) v.emplace_back(i,j);\n    }\n    vector<vector<int>> memo(n, vector<int>(n, -1));\n    if (d[0][n-1] < INF)\n      cout << func(v, 0, n-1, d, memo, true) << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[2][55][55][55][55];\nbool used[2][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(c&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(0,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(0,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(a == b || b < a) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(nx1 == hole) res = max(1, res);\n                if(range_out(nx1) || range_out(nx2)) continue;\n                if(fld[nx1.y][nx1.x] == '#' || fld[nx2.y][nx2.x] == '#') continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << dfs(Point(0, 0), Point(W - 1, H - 1)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W;\nchar C[55][55];\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W&&C[y][x]!='#';\n}\n\nbool used[55][55];\nbool bfs() {\n  memset(used, false, sizeof(used));\n  queue<Pi> que;\n  used[0][0] = true;\n  que.emplace(0, 0);\n  while(!que.empty()) {\n    int y, x; tie(y, x) = que.front(); que.pop();\n    if(y == H-1 && x == W-1) break;\n    rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if(!in(ny, nx)) continue;\n      if(used[ny][nx]) continue;\n      used[ny][nx] = true;\n      que.emplace(ny, nx);\n    }\n  }\n  return used[H-1][W-1];\n}\n\nvector<Pi> hole[26];\n\nint dp[55][55][55][55];\nint dfs(int sy, int sx, int ty, int tx) {\n  if(!in(sy, sx) || !in(ty, tx)) return -inf;\n  if(sy > ty || sx > tx) return -inf;\n  if(sy == ty && sx == tx) return 0;\n  int &res = dp[sy][sx][ty][tx];\n  if(~res) return res;\n  res = -inf;\n  rep(i, 2) {\n    int ny = sy + dy[i], nx = sx + dx[i];\n    if(!in(ny, nx)) continue;\n    chmax(res, dfs(ny, nx, ty, tx));\n  }\n  if(!islower(C[sy][sx])) return res;\n  int c = C[sy][sx] - 'a';\n  rep(i, hole[c].size()) {\n    int hy = hole[c][i].first, hx = hole[c][i].second;\n    if(sy > hy || sx > hx) continue;\n    if(ty < hy || tx < hx) continue;\n    rep(j, 2) {\n      int ny = sy + dy[j], nx = sx + dx[j];\n      if(!in(ny, nx)) continue;\n      int tmp1 = dfs(ny, nx, hy, hx);\n      int tmp2 = dfs(hy, hx, ty, tx);\n      chmax(res, tmp1+tmp2+1);\n    }\n  }\n\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> H >> W, H || W) {\n    rep(i, 26) hole[i].clear();\n    rep(i, H) rep(j, W) {\n      cin >> C[i][j];\n      if(isupper(C[i][j])) hole[C[i][j]-'A'].emplace_back(i, j);\n    }\n    if(!bfs()) {\n      cout << -1 << endl;\n      continue;\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = dfs(0, 0, H-1, W-1);\n    cout << (ans == -1 ? 0 : ans) << endl;\n    //cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[4][55][55][55][55];\nbool used[4][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  if(sy==ty&&sx==tx) return used[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if((c&1)&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif((c&2)&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(2,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(3,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n\nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n\tif(x1>x2||y1>y2)return -1000;\n\tif(v[x1][y1]=='#'||v[x2][y2]=='#')return -1000;\n\tif(dp[x1][y1][x2][y2]!=-10000){\n\t\treturn dp[x1][y1][x2][y2];\n\t}\n\tif(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n\tif(x2-x1==1&&y2-y1==0){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tif(x2-x1==0&&y2-y1==1){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tint tmp = -100;\n\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n\t}\n\ttmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n\tif(tmp>=0){\n\t\treturn dp[x1][y1][x2][y2] = tmp;\n\t}\n\treturn dp[x1][y1][x2][y2] = -1000;\n}\n\nint saiki2(int x1,int y1,int x2,int y2){\n\tif(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n\tif(dp2[x1][y1][x2][y2]!=-10000)return dp2[x1][y1][x2][y2];\n\tint mx = -1000;\n\tfor(int i=x1;i<=x2;i++){\n\t\tfor(int j=y1;j<=y2;j++){\n\t\t\tif(i==x1&&j==y1)continue;\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i,j,x2,y2));\n\t\t}\n\t}\n\treturn dp2[x1][y1][x2][y2] = mx;\n\n}\n\nint main() {\n   \twhile(cin >> h >> w && h!=0){\n   \t\tvector<string> v(h);\n   \t\trep(i,h){\n   \t\t\tcin >> v[i];\n   \t\t}\n\t\trep(i,51){\n\t\t\trep(j,51){\n\t\t\t\trep(k,51){\n\t\t\t\t\trep(l,51){\n\t\t\t\t\t\tdp[i][j][k][l] = -10000;\n\t\t\t\t\t\tdp2[i][j][k][l] = -10000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}   \t\t\n\t\tint ans = saiki(0,0,h-1,w-1,v);\n\t\tans = saiki2(0,0,h-1,w-1);\n\t\tif(ans>=0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n   \t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      if(!(y1==sy&&x1==sx)&&!(gy==y2&&gx==x2)){\n\tif(check(y1,x1,sy,sx)&&check(gy,gx,y2,x2)){\n\t  dfs(i,y2,x2);\n\t  res1=max(res1,dp[i][y2][x2]);\n\t}\n      }\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      if(!(y2==sy&&x2==sx)){\n\tif(check(y2,x2,sy,sx)&&check(gy,gx,y,x)){\n\t  dfs(i,y,x);\n\t  res2=max(res2,dp[i][y][x]);\n\t}\n      }\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++) dfs(i,h-1,w-1);\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<16;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0},dy[]={0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int h,int w){\n    vector<string> c(h);\n    rep(i,0,h) cin >> c[i];\n\n    auto ok=[&](int y,int x){\n        return 0<=y and y<h and 0<=x and x<w and c[y][x]!='#';\n    };\n    auto is_adjacent=[](int y1,int x1,int y2,int x2){\n        return (y1+1==y2 and x1==x2) or (y1==y2 and x1+1==x2);\n    };\n\n    static bool can_move[50][50][50][50];\n    vector<pii> ps[26];\n    fill_n((bool*)can_move,50*50*50*50,false);\n    rep(y,0,h) rep(x,0,w){\n        queue<pii> que;\n        que.push(make_pair(y,x));\n        while(!que.empty()){\n            pii p=que.front();\n            que.pop();\n            int y_=p.first,x_=p.second;\n            can_move[y][x][y_][x_]=true;\n            if('a'<=c[y][x] and c[y][x]<='z' and 'A'<=c[y_][x_] and c[y_][x_]<='Z' and c[y][x]-'a'==c[y_][x_]-'A') ps[c[y][x]-'a'].push_back(make_pair(y_,x_));\n            rep(i,0,2){\n                int ny=y_+dy[i],nx=x_+dx[i];\n                if(!ok(ny,nx)) continue;\n                que.push(make_pair(ny,nx));\n            }\n        }\n    }\n\n    static int memo[50][50][50][50];\n    static bool done[50][50][50][50];\n    fill_n((bool*)done,50*50*50*50,false);\n    function<int(int,int,int,int)> rec=[&](int y1,int x1,int y2,int x2){\n        if(done[y1][x1][y2][x2]) return memo[y1][x1][y2][x2];\n        done[y1][x1][y2][x2]=true;\n        if(y1==y2 and x1==x2) return memo[y1][x1][y2][x2]=0;\n        if(!can_move[y1][x1][y2][x2]) return memo[y1][x1][y2][x2]=-inf;\n        int res=-1;\n        if(ok(y1+1,x1)) res=max(res,rec(y1+1,x1,y2,x2));\n        if(ok(y1,x1+1)) res=max(res,rec(y1,x1+1,y2,x2));\n        if('a'<=c[y1][x1] and c[y1][x1]<='z'){\n            for(pii &p:ps[c[y1][x1]-'a']){\n                int y=p.first,x=p.second;\n                if(!can_move[y1][x1][y][x] or !can_move[y][x][y2][x2]) continue;\n                if(is_adjacent(y1,x1,y,x)){\n                    res=max(res,rec(y,x,y2,x2)+1);\n                    continue;\n                }\n                rep(i,0,2){\n                    int y1_=y1+dy[i],x1_=x1+dx[i];\n                    if(!ok(y1_,x1_)) continue;\n                    rep(j,0,2){\n                        int y_=y-dy[j],x_=x-dx[j];\n                        if(!ok(y_,x_) or !can_move[y1_][x1_][y_][x_]) continue;\n                        res=max(res,rec(y1_,x1_,y_,x_)+rec(y,x,y2,x2)+1);\n                    }\n                }\n            }\n        }\n        return memo[y1][x1][y2][x2]=res;\n    };\n    int ans=rec(0,0,h-1,w-1);\n    cout << (ans<0?-1:ans) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int h,w;\n        cin >> h >> w;\n        if(h==0 and w==0) break;\n        solve(h,w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(b < a || is_Wall(a) || is_Wall(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(a == b) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = -INF;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(range_out(nx1) || range_out(nx2) || is_Wall(nx1) || is_Wall(nx2)) continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[0][0] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ifstream ifs(\"2538_in1.txt\");\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << dfs(Point(0, 0), Point(W - 1, H - 1)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 60;\n\nstruct Po\n{\n    int x,y;\n    Po(int x,int y) : x(x) ,y(y){};\n    Po(){};\n    bool operator == (const Po &b) const{\n        return x==b.x&&y==b.y;\n    }\n    void print()\n    {\n        printf(\"(%d,%d)\",x,y);\n    }\n};\n\nchar mp[maxn][maxn];\nint id[maxn][maxn];\nint W,H;\n\nvector<Po>a[maxn],A[maxn];\n\nint down_a[maxn][maxn][maxn][maxn];\nint up_A[maxn][maxn][maxn][maxn];\n\nint dp[maxn][maxn][maxn][maxn];\nint vis[maxn][maxn][maxn][maxn];\n\nint dx[4] = { 0,1 };\nint dy[4] = { 1,0 };\n\nint TIME;\n\n#define debug_x printf(\"x1 %d y1 %d x2 %d y2 %d\\n\",x1,y1,x2,y2);\n\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if( x1 == x2 && y1 == y2+1 ) return 0;\n    if( x1 == x2+1 && y1 == y2 ) return 0;\n    if( x1 == x2 && y1 == y2 ) return 0;\n\n    if( x1>x2 || y1>y2 ) return -1;\n\n    int &t = dp[x1][y1][x2][y2];\n\n    if( vis[x1][y1][x2][y2] ) return t;\n\n    vis[x1][y1][x2][y2] = 1;\n\n\n    if( mp[x1][y1] == '#' || mp[x2][y2] == '#' ) return t=-1;\n\n    t = max( dfs(x1+1,y1,x2,y2) , dfs(x1,y1+1,x2,y2) );\n\n    for(int c=0;c<26;c++)\n    {\n        for( int i=0;i<a[c].size();i++ ) if( down_a[x1][y1][c][i] )\n            for( int j=0;j<A[c].size();j++ ) if( up_A[x2][y2][c][j] )\n            {\n                int t1=-1,t2=-1,t3=-1;\n                for( int k=0;k<2;k++ )\n                {\n                    t1 = max( t1 , dfs( x1,y1,a[c][i].x-dx[k],a[c][i].y-dy[k] ) );\n                    t3 = max( t3 , dfs( A[c][j].x+dx[k],A[c][j].y+dy[k],x2,y2 ) );\n                }\n                for(int k1=0;k1<2;k1++)\n                    for(int k2=0;k2<2;k2++)\n                    {\n                        t2 = max( t2 , dfs( a[c][i].x+dx[k1],a[c][i].y+dy[k1],\n                                            A[c][j].x-dx[k2],A[c][j].y-dy[k2] ) );\n                    }\n                if( t1>=0&&t2>=0&&t3>=0 )\n                    t = max( t , t1+t2+t3+1 );\n            }\n    }\n    return t;\n}\n\nvoid bfs()\n{\n    clr(down_a,0);\n    clr(up_A,0);\n    for(int i=1 ; i<=W ; i++)\n        for(int j=1 ; j<=H ; j++)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<A[c].size();k++)\n                {\n                    up_A[i][j][c][k] =\n                        up_A[i-1][j][c][k] | up_A[i][j-1][c][k];\n                    if( A[c].size() > 10 ) while(1);\n                }\n            if( mp[i][j] >= 'A' && mp[i][j] <= 'Z' )\n            {\n                up_A[i][j][ mp[i][j]-'A' ][ id[i][j] ] = 1;\n                if( id[i][j] < 0 || id[i][j] > 10 ) while(1);\n            }\n        }\n    for(int i=W ; i>=1 ; i--)\n        for(int j=H ; j>=1 ; j--)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<a[c].size();k++)\n                {\n                    down_a[i][j][c][k] =\n                        down_a[i+1][j][c][k] | down_a[i][j+1][c][k];\n                    if( a[c].size() > 10 ) while(1);\n                }\n            if( mp[i][j] >= 'a' && mp[i][j] <= 'z' )\n            {\n                down_a[i][j][ mp[i][j]-'a' ][ id[i][j] ] = 1;\n                if( id[i][j] < 0 || id[i][j] > 10 ) while(1);\n            }\n        }\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while( ~scanf(\"%d%d\",&W,&H) )\n    {\n        if(W==0&&H==0) break;\n        clr( id , 0 );\n        for(int i=0;i<30;i++)\n        {\n            a[i].clear();\n            A[i].clear();\n        }\n        char c;\n        for(int i=1;i<=W;i++)\n            for(int j=1;j<=H;j++)\n            {\n\n                scanf(\" %c\",&c);\n                mp[i][j] = c;\n                if( c>='a' && c<='z' )\n                {\n                    a[ c-'a' ].push_back( Po(i,j) );\n                    id[i][j] = a[ c-'a' ].size()-1;\n                }\n                if( c>='A' && c<='Z' )\n                {\n                    A[ c-'A' ].push_back( Po(i,j) );\n                    id[i][j] = A[ c-'A' ].size()-1;\n                }\n            }\n\n        bfs();\n\n        clr(vis,0);\n        int ans = dfs(1,1,W,H);\n\n        if(ans>=0) printf(\"%d\\n\",ans);\n        else printf(\"-1\\n\",ans);\n    }\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 3) return 0;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Field=vector<string>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nvoid cmax(int& lhs,int rhs){\n    lhs=max(lhs,rhs);\n}\nint e0[]={1,0};\nint e1[]={0,1};\nint solve(int h,int w){\n    Field f(h);\n    for(int i=0;i<h;i++) cin>>f[i];\n    vector<vector<int>> hs(26);\n    vector<vector<int>> ws(26);\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(isalpha(f[i][j]) && isupper(f[i][j])){\n                hs[f[i][j]-'A'].push_back(i);\n                ws[f[i][j]-'A'].push_back(j);\n            }\n        }\n    }\n    vvvvi dp(h,vvvi(w,vvi(h,vi(w,-1e9))));\n    for(int i=0;i<h;i++)for(int j=0;j<w;j++) dp[i][j][i][j]=0;\n    auto isRange=[&](int i,int j){return 0<=i && i<h && 0<=j && j<w;};\n    for(int dh=0;dh<h;dh++){\n        for(int dw=0;dw<w;dw++){\n            for(int t=0;t<h;t++){\n                for(int l=0;l<w;l++){\n                    int b=t+dh,r=l+dw;\n                    if(!isRange(b,r)) continue;\n                    if(f[t][l]=='#' || f[b][r]=='#') continue;\n                    if(t+1<=b) cmax(dp[t][l][b][r],dp[t+1][l][b][r]);\n                    if(t<=b-1) cmax(dp[t][l][b][r],dp[t][l][b-1][r]);\n                    if(l+1<=r) cmax(dp[t][l][b][r],dp[t][l+1][b][r]);\n                    if(l<=r-1) cmax(dp[t][l][b][r],dp[t][l][b][r-1]);\n                    if(isalpha(f[t][l]) && islower(f[t][l])){\n                        for(int k=0;k<hs[f[t][l]-'a'].size();k++){\n                            int hp=hs[f[t][l]-'a'][k],wp=ws[f[t][l]-'a'][k];\n                            if(t<=hp && hp<=b && l<=wp && wp<=r){\n                                cmax(dp[t][l][b][r],dp[t][l][hp][wp]+dp[hp][wp][b][r]);\n                            }\n                        }\n                    }\n                    if(isalpha(f[t][l]) && islower(f[t][l]) && toupper(f[t][l])==f[b][r]){\n                        if(b-t+r-l==1) dp[t][l][b][r]=1;\n                        else{\n                            for(int x=0;x<2;x++){\n                                for(int y=0;y<2;y++){\n                                    int nt=t+e0[x],nl=l+e1[x];\n                                    int nb=b-e0[y],nr=r-e1[y];\n                                    if(nt<=nb && nl<=nr) cmax(dp[t][l][b][r],dp[nt][nl][nb][nr]+1);\n                                }\n                            }\n                        }\n                    }\n                    // cerr<<\"#\"<<t<<\" \"<<l<<\" \"<<b<<\" \"<<r<<endl;\n                    // cerr<<dp[t][l][b][r]<<endl;\n                }\n            }\n        }\n    }\n    \n    return dp[0][0][h-1][w-1];\n}\nint main(){\n    int h,w;\n    while(cin>>h>>w,h){\n        int ret=solve(h,w);\n        cout<<(ret<0 ? -1 : ret)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<deque>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint dx[] = {0,1};\nint dy[] = {1,0};\n\nstruct Data {\n  int x,y;\n  char v;\n  bool operator < ( const Data &data ) const {\n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    return v < data.v;\n  }\n};\n\nvoid makeGraph(vector<string> &C,vector<vector<int>> &G,vector<char> &ws) {\n  int H = C.size(), W = C[0].size();\n  map<Data,int> mp;\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    mp[(Data){j,i,C[i][j]}] = (int)mp.size();\n  }\n  int V = mp.size();\n  G.resize(V);\n  ws.resize(V);\n  bool used[H][W];\n  rep(i,H) rep(j,W) if( ( i == 0 && j == 0 ) || ( i == H-1 && j == W-1 ) || isalpha(C[i][j]) ) {\n    int sp = mp[(Data){j,i,C[i][j]}];\n    ws[sp] = C[i][j];\n    memset(used,false,sizeof used);\n    deque<int> deq;\n    deq.push_back(j+i*W);\n\n    while( !deq.empty() ) {\n      int cur = deq.front(); deq.pop_front();\n      int x = cur % W, y = cur / W;\n      rep(k,2) {\n\tint nx = x + dx[k], ny = y + dy[k];\n\n\tif( !( 0 <= nx && nx < W && 0 <= ny && ny < H ) ) continue;\n\tif( used[ny][nx] ) continue;\n\tif( C[ny][nx] == '#' ) continue;\n\n\tused[ny][nx] = true;\n\tif( isalpha(C[ny][nx]) || ( nx == W-1 && ny == H-1 ) ) G[sp].push_back(mp[(Data){nx,ny,C[ny][nx]}]);\n\tdeq.push_back(nx+ny*W);\n\t\n      }\n    }\n  }\n}\n\nbool visit(const vector<vector<int>>& G,int v,vector<int>& order,vector<int>& color){\n  color[v] = 1;\n  rep(i,(int)G[v].size()) {\n    int e = G[v][i];\n    if(color[e] == 2)continue;\n    if(color[e] == 1)return false;\n    if(!visit(G,e,order,color))return false;\n  }\n  order.push_back(v);\n  color[v] = 2;\n  return true;\n}\n\n\nbool topologicalSort(const vector<vector<int>>& G,vector<int>& order){\n  int SizeG = G.size();\n  vector<int> color(SizeG); \n  for(int u=0;u<SizeG;u++) if(!color[u] && !visit(G,u,order,color)) return false;\n  reverse(order.begin(),order.end());\n  return true;\n}\n\nbool canPut(char a,char A) {\n  if( !islower(a) || !isupper(A) ) return false;\n  return toupper(a) == A;\n}\n\n#define MAX_V 600\nint dp[MAX_V][MAX_V];\nvoid compute(vector<string> &C) {\n  if( C.size() == 1 && C[0].size() == 1 ) { puts(\"0\"); return; }\n  // DAG???\n  vector<vector<int>> G;\n  vector<char> ws;\n  makeGraph(C,G,ws);\n\n  {\n    bool fin = true;\n    rep(i,(int)G[0].size()) if( G[0][i] == (int)G.size()-1 ) { fin = false; break; }\n    if( fin ) { puts(\"-1\"); return; }\n  }\n\n  // topological sort\n  vector<int> order;\ntopologicalSort(G,order);\n\n  // DP\n  int V = G.size();\n  bool hasEdge[V][V];\n  memset(hasEdge,false,sizeof hasEdge);\n  rep(i,V) rep(j,(int)G[i].size()) hasEdge[i][G[i][j]] = true;\n  \n  memset(dp,0,sizeof dp);\n  REP(len,2,V+1) {\n    rep(i,V) {\n      int j = i + len - 1;\n      if( j >= V ) break;\n      int sp = order[i];\n      int ep = order[j];\n      if( !hasEdge[sp][ep] ) continue;\n\n      bool put = false;\n      if( canPut(ws[sp],ws[ep]) ) {\n\tput = true;\n\tdp[sp][ep] = max(dp[sp][ep],1);\n      }\n\n      rep(k,(int)G[sp].size()) {\n\tint nex = G[sp][k];\n\trep(l,(int)G[nex].size()) {\n\t  int nnex = G[nex][l];\n\t  if( !( nnex == ep || hasEdge[nnex][ep] ) ) continue;\n\t  dp[sp][ep] = max(dp[sp][ep],\n\t\t\t   max(dp[nex][nnex],dp[sp][nex]+dp[nnex][ep]));\n\t  if( put && nnex != ep ) {\n\t    dp[sp][ep] = max(dp[sp][ep],\n\t\t\t     dp[nex][nnex]+1);\n\t  }\n\t}\n      }\n    }\n  }\n  cout << dp[0][V-1] << endl;\n}\n\nint main() {\n  int H,W;\n  while( cin >> H >> W, H|W ) {\n    vector<string> C(H);\n    rep(i,H) cin >> C[i];\n    compute(C);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\nusing namespace std;\ntypedef vector<vector<bool> > V;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nstring mp[N];\nvector<PP> A;\nint h,w;\n\nbool compare(PP &a,PP &b){\n  int w1 = a.second.first - a.first.first+1;\n  int h1 = a.second.second - a.first.second+1; \n  int w2 = b.second.first - b.first.first+1;\n  int h2 = b.second.second -b.first.second+1;\n  return h1*w1 < h2*w2;\n}\n\nmap<P,V> v;\nvoid visit(int x,int y){\n  if(v.count(P(x,y)))return;\n\n  if(x<0||y<0||x>=w||y>=h){\n    v[P(x,y)] = V(N,vector<bool>(N,1));\n    return;\n  }\n  V &D = v[P(x,y)] =V(N,vector<bool>(N,0));\n  D[y][x] = 1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) {\n      if(mp[i][j] == '#')continue;\n      if(i)D[i][j] = D[i][j]|D[i-1][j];\n      if(j)D[i][j] = D[i][j]|D[i][j-1];\n    }\n}\n\nvoid pushA(int x,int y){\n  visit(x,y);\n  V &D = v[P(x,y)];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(!D[i][j]||islower(mp[i][j])||tolower(mp[i][j])!=mp[y][x])continue;\n      A.push_back(PP(P(x,y),P(j,i)));\n    }\n}\n\nvoid mkA(){\n  A.clear();\n  v.clear();\n  visit(0,0);\n  V &D = v[P(0,0)];\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(D[i][j]&&islower(mp[i][j]))pushA(j,i);\n  \n  sort(A.begin(),A.end(),compare);\n}\n\nbool check(PP a,PP b){\n  int x1=a.first.first,y1=a.first.second;\n  int X1=a.second.first,Y1=a.second.second;\n  int x2=b.first.first,y2=b.first.second;\n  int X2=b.second.first,Y2=b.second.second;\n  if(a.first==b.first||a.second == b.second)return 0;\n  \n  visit(x1,y1),visit(X2,Y2);\n  V &A = v[P(x1,y1)],&B = v[P(X2,Y2)]; \n  if(!A[y2][x2]||(X1<w&&X2<h&&!B[Y1][X1]||!B[h-1][w-1]))return 0;\n  return x1<=x2&&X2<=X1&&y1<=y2&&Y2<=Y1;\n}\n\n\nmap<PP,int> mem[1000];\nint dfs(int idx,PP sta){  \n  if(idx == -1) return 0;\n  if(mem[idx].count(sta))return mem[idx][sta];\n  int res = dfs(idx-1,sta);\n  if(check(sta,A[idx])){\n    int a = dfs(idx-1,PP(sta.first,A[idx].first));\n    int b = dfs(idx-1,A[idx]);\n    int c = dfs(idx-1,PP(A[idx].second,sta.second));\n    res = max(res,a+b+c+1);\n  }\n  return mem[idx][sta] = res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w)break;\n    for(int i=0;i<h;i++)cin>>mp[i];\n    for(int i=0;i<1000;i++)mem[i].clear();\n    mkA();\n    visit(0,0);\n    if(!v[P(0,0)][h-1][w-1]) cout<<-1<<endl;\n    else cout<<dfs(A.size()-1,PP(P(-1,-1),P(w,h)))<<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\nconst int ALP = 26;\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[ALP],t[ALP];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n            mv[i][i] = false;\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,ALP){\n            for(int from:s[i])for(int to:t[i])if(mv[from][to]) dp[from][to] = 1;\n        }\n\n        // rep(loop,50){\n        //     rep(i,ALP)for(int from:s[i])for(int to:t[i]){\n        //         if(!mv[from][to]) continue;\n\n        //         rep(j,ALP){\n        //             for(int x:s[j]){\n        //                 if(!mv[from][x]) continue;\n        //                 for(int y:t[j]){\n        //                     if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n\n        vector<vector<int>> ans(h,vector<int>(w,-1));\n        // ans[0][0] = 0;\n        // rep(i,h)rep(j,w){\n        //     rep(d,2){\n        //         int ni = i+dy[d], nj = j+dx[d];\n        //         if(IN(ni,nj) && c[ni][nj]!='#') ans[ni][nj] = max(ans[ni][nj], ans[i][j]);\n        //     }\n\n        //     if(islower(c[i][j])){\n        //         int from = p2id[{i,j}];\n        //         for(int to:t[c[i][j]-'a']){\n        //             if(mv[from][to]){\n        //                 ans[p[to].fi][p[to].se] = max(ans[p[to].fi][p[to].se], ans[i][j]+dp[from][to]);\n        //             }\n        //         }\n        //     }\n        // }\n        cout << ans[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return dp[ly][lx][ry][rx]=0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<(dfs(0,0,h-1,w-1)<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n \nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n \ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n \nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n    if(x1>x2||y1>y2)return -20000;\n    if(v[x1][y1]=='#'||v[x2][y2]=='#')return -20000;\n    if(dp[x1][y1][x2][y2]!=-100000){\n        return dp[x1][y1][x2][y2];\n    }\n    if(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n    if(x2-x1==1&&y2-y1==0){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    if(x2-x1==0&&y2-y1==1){\n        if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n            return dp[x1][y1][x2][y2]=1;\n        }\n        return dp[x1][y1][x2][y2] = 0;\n    }\n    int tmp = -1000;\n    if(v[x1][y1]+('A'-'a')==v[x2][y2]&&v[x1][y1]!='.'&&v[x2][y2]!='.'){\n        tmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n        tmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n    }\n    tmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n    tmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n    if(tmp>=0){\n        return dp[x1][y1][x2][y2] = tmp;\n    }\n    return dp[x1][y1][x2][y2] = -20000;\n}\n \nint saiki2(int x1,int y1,int x2,int y2){\n    if(x1>x2||y1>y2)return -1000;\n    if(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n    if(dp2[x1][y1][x2][y2]!=-100000)return dp2[x1][y1][x2][y2];\n    int mx = -20000;\n    for(int i=x1;i<=x2;i++){\n        for(int j=y1;j<=y2;j++){\n            if(i==x1&&j==y1)continue;\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i,j+1,x2,y2));\n            mx = max(mx,dp[x1][y1][i][j]+saiki2(i+1,j,x2,y2));\n        }\n    }\n    return dp2[x1][y1][x2][y2] = mx;\n \n}\n \nint main() {\n    while(cin >> h >> w && h!=0){\n        vector<string> v(h);\n        rep(i,h){\n            cin >> v[i];\n        }\n        rep(i,51){\n            rep(j,51){\n                rep(k,51){\n                    rep(l,51){\n                        dp[i][j][k][l] = -100000;\n                        dp2[i][j][k][l] = -100000;\n                    }\n                }\n            }\n        }           \n        int ans = saiki(0,0,h-1,w-1,v);\n        ans = saiki2(0,0,h-1,w-1);\n        if(ans>=0){\n            cout << ans << endl;\n        }else{\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pi;\n\nvector<pi> cont[26];\n\ninline int map(char t){\n\tif(t <= 'z' && t >= 'a') return t - 'a';\n\tif(t <= 'Z' && t >= 'A') return t - 'A' + 26;\n\treturn 10000;\n}\n\nint dp[51][51][51][51];\nbool go[51][51][51][51];\n\nint n, m;\nchar a[55][55];\n\nint f(int sx, int sy, int ex, int ey){\n//\tfprintf(stderr,\"%d %d %d %d\\n\",sx,sy,ex,ey);\n\tif(sx == ex && sy == ey) return 0;\n\tif(sx > ex || sy > ey) return -1e9;\n\tif(!go[ex][ey][sx][sy]) return -1e9;\n\tif(~dp[sx][sy][ex][ey]) return dp[sx][sy][ex][ey];\n\tint ret = 0;\n\tif(go[sx+1][sy][sx][sy]) ret = max(ret, f(sx+1, sy, ex, ey));\n\tif(go[sx][sy+1][sx][sy]) ret = max(ret, f(sx, sy+1, ex, ey));\n\tif(ex && go[ex][ey][ex-1][ey]) ret = max(ret, f(sx, sy, ex-1, ey));\n\tif(ey && go[ex][ey][ex][ey-1]) ret = max(ret, f(sx, sy, ex, ey-1));\n\tif(map(a[sx][sy]) + 26 == map(a[ex][ey])){\n\t\tint ret2 = 0;\n\t\tif(ex && go[sx+1][sy][sx][sy] && go[ex][ey][ex-1][ey]) ret2 = max(ret2, f(sx+1, sy, ex-1, ey));\n\t\tif(ex && go[sx][sy+1][sx][sy] && go[ex][ey][ex-1][ey]) ret2 = max(ret2, f(sx, sy+1, ex-1, ey));\n\t\tif(ey && go[sx+1][sy][sx][sy] && go[ex][ey][ex][ey-1]) ret2 = max(ret2, f(sx+1, sy, ex, ey-1));\n\t\tif(ey && go[sx][sy+1][sx][sy] && go[ex][ey][ex][ey-1]) ret2 = max(ret2, f(sx, sy+1, ex, ey-1));\n\t\tret = max(ret, ret2+1);\n\t}\n\tif(0 <= map(a[sx][sy]) && map(a[sx][sy]) <= 25){\n\t\tfor(auto &i : cont[map(a[sx][sy])]){\n\t\t\tif(go[i.first][i.second][sx][sy] && go[ex][ey][i.first][i.second]){\n\t\t\t\tif(ex == i.first && ey == i.second) continue;\n\t\t\t\tret = max(ret, f(sx, sy, i.first, i.second) + f(i.first, i.second, ex, ey));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[sx][sy][ex][ey] = ret;\n}\n\nvoid solve(){\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%s\",a[i]);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(map(a[i][j]) <= 51 && map(a[i][j]) >= 26){\n\t\t\t\tcont[map(a[i][j]) - 26].push_back(pi(i,j));\n\t\t\t}\n\t\t\tif(a[i][j] == '#') continue;\n\t\t\tgo[i][j][i][j] = 1;\n\t\t\tfor(int k=i; k>=0; k--){\n\t\t\t\tfor(int l=j; l>=0; l--){\n\t\t\t\t\tif(a[k][l] != '#'){\n\t\t\t\t\t\tgo[i][j][k][l] |= (go[i][j][k+1][l] | go[i][j][k][l+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",max(-1,f(0,0,n-1,m-1)));\n}\n\nint main(){\n\twhile(1){\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tmemset(go,0,sizeof(go));\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(int i=0; i<26; i++) cont[i].clear();\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n == 0 && m == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n#include <bitset>\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define lson l, m, rt<<1\n#define rson m+1, r, rt<<1|1\n#define inf 1e9\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n#define clr(x, y) memset(x, y, sizeof x)\n#define LL long long\n#define uLL unsigned LL\n\nusing namespace std;\n\nconst int maxn = 60;\n\nstruct Po\n{\n    int x,y;\n    Po(int x,int y) : x(x) ,y(y){};\n    Po(){};\n    bool operator == (const Po &b) const{\n        return x==b.x&&y==b.y;\n    }\n    void print()\n    {\n        printf(\"(%d,%d)\",x,y);\n    }\n};\n\nchar mp[maxn][maxn];\nint id[maxn][maxn];\nint W,H;\n\nvector<Po>a[maxn],A[maxn];\n\nint down_a[maxn][maxn][maxn][maxn];\nint up_A[maxn][maxn][maxn][maxn];\n\nint dp[maxn][maxn][maxn][maxn];\nint vis[maxn][maxn][maxn][maxn];\n\nint dx[4] = { 0,1 };\nint dy[4] = { 1,0 };\n\nint TIME;\n\n#define debug_x printf(\"x1 %d y1 %d x2 %d y2 %d\\n\",x1,y1,x2,y2);\n\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if( x1 == x2 && y1 == y2+1 ) return 0;\n    if( x1 == x2+1 && y1 == y2 ) return 0;\n    if( x1 == x2 && y1 == y2 ) return 0;\n\n    if( x1>x2 || y1>y2 ) return -1;\n\n    int &t = dp[x1][y1][x2][y2];\n\n    if( vis[x1][y1][x2][y2] ) return t;\n\n    vis[x1][y1][x2][y2] = 1;\n\n\n    if( mp[x1][y1] == '#' || mp[x2][y2] == '#' ) return t=-1;\n\n    t = max( dfs(x1+1,y1,x2,y2) , dfs(x1,y1+1,x2,y2) );\n\n    for(int c=0;c<26;c++)\n    {\n        for( int i=0;i<a[c].size();i++ ) if( down_a[x1][y1][c][i] )\n            for( int j=0;j<A[c].size();j++ ) if( up_A[x2][y2][c][j] )\n            {\n                int t1=-1,t2=-1,t3=-1;\n                for( int k=0;k<2;k++ )\n                {\n                    t1 = max( t1 , dfs( x1,y1,a[c][i].x-dx[k],a[c][i].y-dy[k] ) );\n                    t3 = max( t3 , dfs( A[c][j].x+dx[k],A[c][j].y+dy[k],x2,y2 ) );\n                }\n                for(int k1=0;k1<2;k1++)\n                    for(int k2=0;k2<2;k2++)\n                    {\n                        t2 = max( t2 , dfs( a[c][i].x+dx[k1],a[c][i].y+dy[k1],\n                                            A[c][j].x-dx[k2],A[c][j].y-dy[k2] ) );\n                    }\n                if( t1>=0&&t2>=0&&t3>=0 )\n                    t = max( t , t1+t2+t3+1 );\n            }\n    }\n    return t;\n}\n\nvoid bfs()\n{\n    clr(down_a,0);\n    clr(up_A,0);\n    for(int i=1 ; i<=W ; i++)\n        for(int j=1 ; j<=H ; j++)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<A[c].size();k++)\n                {\n                    up_A[i][j][c][k] =\n                        up_A[i-1][j][c][k] | up_A[i][j-1][c][k];\n                }\n            if( mp[i][j] >= 'A' && mp[i][j] <= 'Z' )\n            {\n                up_A[i][j][ mp[i][j]-'A' ][ id[i][j] ] = 1;\n            }\n\n            //printf(\"  i %d j %d \",i,j);\n            //printf(\"%d %d %d\\n\",up_A[i][j][0][0],up_A[i][j][1][0],up_A[i][j][1][1]);\n        }\n    for(int i=W ; i>=1 ; i--)\n        for(int j=H ; j>=1 ; j--)\n        {\n            for(int c=0;c<26;c++)\n                for(int k=0;k<a[c].size();k++)\n                {\n                    down_a[i][j][c][k] =\n                        down_a[i+1][j][c][k] | down_a[i][j+1][c][k];\n                }\n            if( mp[i][j] >= 'a' && mp[i][j] <= 'z' )\n            {\n                down_a[i][j][ mp[i][j]-'a' ][ id[i][j] ] = 1;\n            }\n            //printf(\"i %d j %d \",i,j);\n            //printf(\"%d %d %d\\n\",down_a[i][j][0][0],down_a[i][j][1][0],down_a[i][j][1][1]);\n        }\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while( ~scanf(\"%d%d\",&W,&H) )\n    {\n        if(W==0&&H==0) break;\n        clr( id , 0 );\n        for(int i=0;i<30;i++)\n        {\n            a[i].clear();\n            A[i].clear();\n        }\n        char c;\n        for(int i=1;i<=W;i++)\n            for(int j=1;j<=H;j++)\n            {\n\n                scanf(\" %c\",&c);\n                mp[i][j] = c;\n                if( c>='a' && c<='z' )\n                {\n                    a[ c-'a' ].push_back( Po(i,j) );\n                    id[i][j] = a[ c-'a' ].size()-1;\n                    if( id[i][j] > 10 ) while(1);\n                }\n                if( c>='A' && c<='Z' )\n                {\n                    A[ c-'A' ].push_back( Po(i,j) );\n                    id[i][j] = A[ c-'A' ].size()-1;\n                    if( id[i][j] > 10 ) while(1);\n                }\n            }\n\n        bfs();\n\n        clr(vis,0);\n        int ans = dfs(1,1,W,H);\n\n        if(ans>=0) printf(\"%d\\n\",ans);\n        else printf(\"-1\\n\",ans);\n    }\n    return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[30];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nll H,W;\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(ret != -1) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    ret = -INF;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n                    int ny1 = y1 + dy[i], nx1 = x1 + dx[i];\n                    if (ny1 > y2 || nx1 > x2) continue;\n                    int bny = ny - dy[j], bnx = nx - dx[j];\n                    if (bny < y1 || bnx < x1) continue;\n                    if (!can[ny1][nx1][bny][bnx]) continue;\n                    ret = max(ret, 1 + dfs(ny1, nx1, bny, bnx,maze) + dfs(ny, nx, y2, x2,maze));\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 30;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            char c; cin >> c;\n            maze[i][j] = c;\n            if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n        }\n    }\n    memset(can,false,sizeof(can));\n//    fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i >= 1; i--){\n        for(ll j = W; j >= 1; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    //cout << maze << endl;\n    //fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    memset(dp,-1,sizeof(dp));\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> H >> W,H|W){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define range(x,s,t) (s<=x&&x<t)\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nint dist[55][55][55][55];\nint ans[55][55];\n\nint h,w;\nstring board[55];\nusing state=tuple<int,int,int,int>;\n\nconst int dx[4]={-1,0,1,0};\nconst int dy[4]={0,-1,0,1};\n\nint main(void){\n\twhile(cin >> h >> w,h){\n\t\trep(i,h) cin >> board[i];\n\t\tclr(dist,-1);\n\n\t\tdeque<state> q;\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif(board[i][j]=='#') continue;\n\t\t\tdist[i][j][i][j]=0;\n\t\t\tq.push_back(state(i,j,i,j));\n\t\t\trep(d,2){\n\t\t\t\tint ni=i+dx[d+2],nj=j+dy[d+2];\n\t\t\t\tif(!range(ni,0,h)||!range(nj,0,w)) continue;\n\t\t\t\tif(board[ni][nj]=='#') continue;\n\n\t\t\t\tbool add=false;\n\t\t\t\tif(islower(board[i][j])&&isupper(board[ni][nj])&&toupper(board[i][j])==board[ni][nj]) add=true;\t\t\t\t\n\t\t\t\tdist[i][j][ni][nj]=add;\n\t\t\t\tq.push_back(state(i,j,ni,nj));\n\t\t\t}\n\t\t}\n\t\n\t\twhile(!q.empty()){\n\t\t\tint a,b,c,d;\n\t\t\ttie(a,b,c,d)=q.front();q.pop_front();\n\t\t\t\n\t\t\trep(i,2){\n\t\t\t\tint na=a+dx[i],nb=b+dy[i];\n\t\t\t\tif(!range(na,0,h)||!range(nb,0,w)) continue;\n\t\t\t\tif(board[na][nb]=='#') continue;\n\t\t\t\tif(chmax(dist[na][nb][c][d],dist[a][b][c][d]))\n\t\t\t\t\tq.push_back(state(na,nb,c,d));\n\t\t\t}\n\n\t\t\trep(j,2){\n\t\t\t\tint nc=c+dx[j+2],nd=d+dy[j+2];\n\t\t\t\tif(!range(nc,0,h)||!range(nd,0,w)) continue;\n\t\t\t\tif(board[nc][nd]=='#') continue;\n\t\t\t\tif(chmax(dist[a][b][nc][nd],dist[a][b][c][d])) \n\t\t\t\t\tq.push_back(state(a,b,nc,nd));\n\t\t\t}\n\n\t\t\trep(i,2)rep(j,2){\n\t\t\t\tconst int na=a+dx[i],nb=b+dy[i],nc=c+dx[j+2],nd=d+dy[j+2];\n\t\t\t\t\n\t\t\t\tif(!range(na,0,h)||!range(nb,0,w)) continue;\n\t\t\t\tif(board[na][nb]=='#') continue;\n\t\t\t\tif(!range(nc,0,h)||!range(nd,0,w)) continue;\n\t\t\t\tif(board[nc][nd]=='#') continue;\n\t\t\t\t\n\t\t\t\tbool add=false;\n\t\t\t\tif(islower(board[na][nb])&&isupper(board[nc][nd])&&toupper(board[na][nb])==board[nc][nd]) add=true;\n\t\n\t\t\t\tif(chmax(dist[na][nb][nc][nd],dist[a][b][c][d]+add))\n\t\t\t\t\tq.push_front(state(na,nb,nc,nd));\n\t\t\t}\n\t\t}\n\n\t\tclr(ans,-1);\n\t\tans[0][0]=0;\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif(board[i][j]=='#') continue;\n\t\t\tif(i-1>=0 && board[i-1][j]!='#') chmax(ans[i][j],ans[i-1][j]);\n\t\t\tif(j-1>=0 && board[i][j-1]!='#') chmax(ans[i][j],ans[i][j-1]);\n\t\t\trep(ni,i,h)rep(nj,j,w){\n\t\t\t\tif(ni==i && nj==j) continue;\n\t\t\t\tchmax(ans[ni][nj],ans[i][j]+dist[i][j][ni][nj]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans[h-1][w-1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            if (R[sy][sx][ny][nx]) continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n\n        if (not islower(F[sy][sx])) {\n            return cache = max(f(sy + 1, sx, ty, tx), f(sy, sx + 1, ty, tx));\n        }\n        if (not isupper(F[ty][tx])) {\n            return cache = max(f(sy, sx, ty - 1, tx), f(sy, sx, ty, tx - 1));\n        }\n\n        int r = 0;\n        for (int y = sy; y <= ty; y++) {\n            for (int x = sx; x <= tx; x++) {\n                if (y == ty && x == tx) continue;\n                r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n            }\n        }\n\n        if (toupper(F[sy][sx]) == F[ty][tx]) {\n            r = max(r, f(sy + 1, sx, ty - 1, tx) + 1);\n            r = max(r, f(sy + 1, sx, ty, tx - 1) + 1);\n            r = max(r, f(sy, sx + 1, ty - 1, tx) + 1);\n            r = max(r, f(sy, sx + 1, ty, tx - 1) + 1);\n        }\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcout << \"*\" << endl;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n\n\n\n\n\n\n\nint T,n,num,m;\nchar z[55][55];\nint dp[55][55][55][55];\nint vi[55][55];\nvoid dfs(int q,int w)\n{\n    if(z[q][w]=='#')\n        return;\n    vi[q][w]=1;\n    if(q==n-1&&w==m-1)\n        return;\n    if(vi[q+1][w]==0)\n        dfs(q+1,w);\n    if(vi[q][w+1]==0)\n        dfs(q,w+1);\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)\n            break;\n        for(int q=0;q<n;q++)\n            scanf(\"%s\",z[q]);\n        memset(dp,0,sizeof dp);\n        memset(vi,0,sizeof vi);\n        dfs(0,0);\n        if(vi[n-1][m-1]==0)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n        for(int w=0;w<=n;w++)\n            for(int q=0;q+w<=n;q++)\n                for(int r=0;r<=m;r++)\n                    for(int e=0;e+r<=m;e++)\n                    {\n                        if(q+w>=q+1&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+1)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]);\n                        }\n                        for(int t=q;t<=q+w;t++)\n                        {\n                            dp[q][w][e][r]=max(dp[q][w][e][r],dp[q][t][e][r]+dp[t][w][e][r]);\n                        }\n                        for(int t=e;t<=e+r;t++)\n                        {\n                            dp[q][w][e][r]=max(dp[q][w][e][r],dp[q][w][e][t]+dp[q][w][t][r]);\n                        }\n                        // printf(\"%d %d %d %d %d\\n\",q,q+w,e,e+r,dp[q][q+w][e][e+r]);\n                    }\n\n                    // for(int q=0;q<=n;q++)\n\n\n                    printf(\"%d\\n\",dp[0][n][0][m]);\n    }\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nchar C[51][51];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvector<P> G[51][51];\nint dp[52][52][52][52];\n\n#define INF (1<<29)\n\nint H,W;\n\nint solve(int x1,int y1,int x2,int y2){\n  int &res = dp[x1][y1][x2][y2];\n  if( res != -1 ) return res;\n  res = -INF;\n  // cout << \"in \" << x1 << \" \" << y1 << \" \" << C[x1][y1] << \" \"<< x2 << \" \" << y2 << \" \" << C[x2][y2]<< \" \" << res << endl;\n  if( x1 >= W || y1 >= H || x2 >= W || y2 >= H  ) return res;\n  if( x1 == x2 && y1 == y2 ) return res = 0;\n  if( x1 > x2 || y1 > y2 ) return res;\n  if( C[x1][y1] == '#' || C[x2][y2] == '#' ) return res;  \n  if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ){\n    for(int i=0;i<(int)G[x1][y1].size();i++){\n      int mx = G[x1][y1][i].first, my = G[x1][y1][i].second;\n      if( mx > x2 || my > y2 ) continue;\n      for(int j=0;j<2;j++){\n        for(int k=2;k<4;k++){\n          int nx1 = x1 + dx[j], ny1 = y1 + dy[j];\n          int nx2 = mx + dx[k], ny2 = my + dy[k];\n          if( C[nx1][ny1] == '#' || C[nx2][ny2] == '#' ) continue;\n          res = max( res,\n                     solve(nx1,ny1,nx2,ny2) + solve(mx,my,x2,y2) + 1 );\n        }\n      }\n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n    //    if( C[nx1][ny1] == '#' ) continue;\n    res = max( res, solve(nx1,ny1,x2,y2) );\n  }\n  return res;\n}\n\n\n\nint main(){\n  int T = 1;\n  while( cin >> H >> W && (H||W) ){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin >> C[j][i];\n    /*\n    if( T == 75 ){\n      cout << H << \" \" << W << endl;\n      for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++)\n          cout << C[j][i];\n        cout << endl;\n      }\n      \n    }\n    T++;\n    continue;\n    */\n    queue<P> q;\n    int h[51][51]={};\n    q.push(P(0,0) );\n    h[0][0] = 1;\n    while( !q.empty() ){\n      P p = q.front(); q.pop();\n      int x = p.first, y = p.second;\n      for(int i=0;i<2;i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if( nx >= W || ny >= H ) continue;\n        if( h[nx][ny] ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        q.push( P(nx,ny) );\n        h[nx][ny] = 1;\n      }\n    }\n\n    if( !h[W-1][H-1] )\n      cout << -1 << endl;\n    else {\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          for(int k=0;k<H;k++)\n            for(int l=0;l<W;l++)\n              dp[j][i][l][k] = -1;\n\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          G[j][i].clear();\n\n      for(int y1=0;y1<H;y1++)\n        for(int x1=0;x1<W;x1++)\n          if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ) \n            for(int y2=y1;y2<H;y2++)\n              for(int x2=x1;x2<W;x2++)\n                if( C[x2][y2] - C[x1][y1] == 'A' - 'a' ) \n                  G[x1][y1].push_back( P(x2,y2) );\n              \n      // cout << \" in \" << endl;\n      int res=solve(0,0,W-1,H-1);\n      cout <<res << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x,bool dr){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      if(!(y1==sy&&x1==sx)&&!(gy==y2&&gx==x2)){\n\tif(check(y1,x1,sy,sx)&&check(gy,gx,y2,x2)){\n\t  dfs(i,y2,x2,1);\n\t  res1=max(res1,dp[i][y2][x2]);\n\t}\n      }\n    }\n\n    if(dr&&gy==y&&gx==x) continue;\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      if(!(y2==sy&&x2==sx)){\n\tif(check(y2,x2,sy,sx)&&check(gy,gx,y,x)){\n\t  dfs(i,y,x,0);\n\t  res2=max(res2,dp[i][y][x]);\n\t}\n      }\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++){\n\n      if(!check(0,0,rec[i].first.first,rec[i].first.second)) continue;\n      if(!check(rec[i].second.first,rec[i].second.second,h-1,w-1)) continue;\n      \n      dfs(i,h-1,w-1,0);\n    }\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n    \n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[30];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(ret != -1) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    ret = -INF;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for(int i = 0; i < 2;i++){\n                    for(int j = 0; j < 2;j++){\n                        ll innery1 = y1+dy[i], innerx1 = x1+dx[i];\n                        ll innery2 = ny - dy[j], innerx2 = nx - dx[j];\n                        if(innery1 > y2 || innerx1 > x2 || innery2 < y1 || innerx2 < x1 ) continue;\n                        if(!can[innery1][innerx1][innery2][innerx2]) continue;\n                        ret = max(ret,dfs(innery1,innerx1,innery2,innerx2,maze) + dfs(ny,nx,y2,x2,maze) + 1);\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(ll H,ll W){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 30;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++){\n        for(int j = 1; j <= W;j++){\n            char c; cin >> c;\n            maze[i][j] = c;\n            if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n        }\n    }\n    memset(can,false,sizeof(can));\n//    fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i >= 1; i--){\n        for(ll j = W; j >= 1; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    //cout << maze << endl;\n    //fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    memset(dp,-1,sizeof(dp));\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll H,W;\n    while(cin >> H >> W,H|W){\n        cout << solve(H,W) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[4][55][55][55][55];\nbool used[4][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(c&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(0,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(0,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nconst int INF = 5000;\n\nvector<string> field;\nunordered_map<char, vector<pair<int,int>>> holes_of;\nint dp[55][55][55][55];\nbool visited[55][55][55][55];\n\nint calc(int t, int l, int b, int r) {\n    if(visited[t][l][b][r]) return dp[t][l][b][r];\n    if(t > b || l > r) return -INF;\n    if(field[t][l] == '#') return -INF;\n    visited[t][l][b][r] = true;\n    int &res = dp[t][l][b][r];\n    if(t == b && l == r) {\n        res = 0;\n    } else {\n        res = max(res, calc(t+1, l, b, r));\n        res = max(res, calc(t, l+1, b, r));\n        if(islower(field[t][l])) {\n            // Pick and place\n            for(const auto &to : holes_of[field[t][l]]) {\n                //cout << field[t][l] << ' ' << to.first << ' ' << to.second << endl;\n                if(to.first == b && to.second == r) continue;\n                res = max(res, calc(t+1, l, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n                res = max(res, calc(t, l+1, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n            }\n        }\n    }\n    if(res < 0) res = -INF;\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    if(!(cin >> H >> W)) return false;\n    if(!H && !W) return false;\n\n    field.clear();\n    field.resize(H);\n    holes_of.clear();\n    for(int i = 0; i < H; ++i) {\n        cin >> field[i];\n        for(int j = 0; j < W; ++j) {\n            if(isupper(field[i][j])) {\n                const char c = tolower(field[i][j]);\n                holes_of[c].push_back(make_pair(i, j));\n            }\n        }\n    }\n    field.push_back(string(W, '.'));\n    fill_n((int*)dp, sizeof(dp)/sizeof(int), -INF);\n    fill_n((bool*)visited, sizeof(visited)/sizeof(bool), false);\n\n    int res = calc(0, 0, H, W-1);\n    if(res < 0) res = -1;\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\nbool valid(int x, int l){\n    return 0 <= x && x < l;\n}\nvoid update(int& x, int y){\n    if(x < y) x = y;\n}\n\nint main(){\n    int H, W;\n    while(cin >> H >> W && H > 0){\n        string grid[55];\n        REP(y, H) cin >> grid[y];\n\n        map< int, vector<pair<int, int>> > jewels;\n        REP(y, H) REP(x, W) if(isupper(grid[y][x])) {\n            jewels[ grid[y][x] ].push_back(make_pair(x, y));\n        }\n\n        static int dp[55][55][55][55] = {};\n        memset(dp, -1, sizeof(dp));\n\n        function<int(int, int, int, int)> dfs = [&](int sx, int sy, int gx, int gy){\n            if(!valid(sx, W) || !valid(sy, H)) return -INF;\n            if(sx > gx || sy > gy) return -INF; // ???\n            if(grid[sy][sx] == '#') return -INF;\n\n            if(sx == gx && sy == gy) return 0;\n\n            int& res = dp[sx][sy][gx][gy];\n            if(res != -1) {\n                return res;\n            }\n            res = -INF;\n\n            update(res, dfs(sx + 1, sy, gx, gy));\n            update(res, dfs(sx, sy + 1, gx, gy));\n\n            if(islower(grid[sy][sx])){\n                char c = grid[sy][sx] - 'a' + 'A';\n                for(auto p : jewels[c]){\n                    int ngx = p.first;\n                    int ngy = p.second;\n                    if(sx == ngx && sy + 1 == ngy){\n                        update(res, 1 + dfs(ngx, ngy, gx, gy));\n                    }else if(sy == ngy && sx + 1 == ngx){\n                        update(res, 1 + dfs(ngx, ngy, gx, gy));\n                    }else if(sx <= ngx && sy <= ngy && ngx <= gx && ngy <= gy){\n                        update(res, 1 + dfs(sx + 1, sy, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx + 1, sy, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx - 1, ngy) + dfs(ngx, ngy, gx, gy));\n                        update(res, 1 + dfs(sx, sy + 1, ngx, ngy - 1) + dfs(ngx, ngy, gx, gy));\n                    }\n                }\n            }\n            return res;\n        };\n\n        int res = dfs(0, 0, W - 1, H - 1);\n        if(res <= -INF) res = -1;\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, 1}, dy[] = {1, 0};\nint W, H;\nchar mp[51][51];\nbool reachable[51][51][51][51];\nint dp[51][51][51][51];\nvector<vector<pair<int, int>>> hole;\n\nvoid calc_reachable() {\n    for (int fy = 0; fy < H; fy++) for (int fx = 0; fx < W; fx++) {\n        reachable[fy][fx][fy][fx] = 1;\n        for (int gy = fy; gy < H; gy++) for (int gx = fx; gx < W; gx++) {\n            if (mp[gy][gx] == '#') continue;\n            if (gy > 0)\n                reachable[fy][fx][gy][gx] |= reachable[fy][fx][gy - 1][gx];\n            if (gx > 0)\n                reachable[fy][fx][gy][gx] |= reachable[fy][fx][gy][gx - 1];\n        }\n    }\n}\n\nint dfs(int fy, int fx, int gy, int gx) {\n    int &ans = dp[fy][fx][gy][gx];\n    if (ans != -1) return ans;\n\n    ans = -1e9;\n    if (mp[fy][fx] == '#' || !reachable[fy][fx][gy][gx]) return ans;\n    for (int i = 0; i < 2; i++)\n        if (fy + dy[i] < H && fx + dx[i] < W)\n            ans = max(ans, dfs(fy + dy[i], fx + dx[i], gy, gx));\n\n    if (islower(mp[fy][fx])) {\n        char hole_c = mp[fy][fx] - 'a';\n        for (auto hole_p : hole[hole_c]) {\n            int hx, hy; tie(hy, hx) = hole_p;\n            if (hx < fx || hx > gx || hy < fy || hy > gy || !reachable[fy][fx][hy][hx]) continue;\n\n            int ret = 0;\n            for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n                if (fy + dy[i] < H && fx + dx[i] < W && hy - dy[j] >= 0 && hx - dx[j] >= 0)\n                    ret = max(ret, dfs(fy + dy[i], fx + dx[i], hy - dy[j], hx - dx[j]));\n            }\n            ans = max(ans, ret + dfs(hy, hx, gy, gx) + 1);\n        }\n    }\n    return (dp[fy][fx][gy][gx] = ans);\n}\n\nint main() {\n    while (cin >> H >> W, W+H) {\n        hole = vector<vector<pair<int, int>>>(30);\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> mp[i][j];\n                if (isupper(mp[i][j])) hole[mp[i][j] - 'A'].push_back({i, j});\n            }\n        }\n\n        memset(reachable, false, sizeof(reachable));\n        calc_reachable();\n\n        if (!reachable[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++)\n            dp[i][j][i][j] = 0;\n        cout << dfs(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n\nint dx[2] = {1,0};\nint dy[2] = {0,1};\n\n#define MAX_WH 55\nvector<pii> alpha[26];\nint dp[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\nbool can[MAX_WH][MAX_WH][MAX_WH][MAX_WH];\n\nint dfs(ll y1,ll x1,ll y2,ll x2,vector<vector<char>>& maze){\n    int& ret = dp[y1][x1][y2][x2];\n    if(~ret) return ret;\n    if(y1 == y2 && x1 == x2) return ret = 0;\n    if(maze[y1][x1] == '#') return ret;\n    if(y1+1 <= y2 && maze[y1+1][x1] != '#'){ ret = max(ret,dfs(y1+1,x1,y2,x2,maze)); }\n    if(x1+1 <= x2 && maze[y1][x1+1] != '#'){ ret = max(ret,dfs(y1,x1+1,y2,x2,maze));}\n    char c = maze[y1][x1];\n    if(c >= 'a' && c <= 'z'){\n        int idx = c - 'a';\n        for(auto p:alpha[idx]){\n            ll ny = p.first, nx = p.second;\n            if(ny > y2 || nx > x2) continue;\n            if(abs(ny-y1) + abs(nx-x1) == 1) ret = max(ret,dfs(ny,nx,y2,x2,maze) + 1);\n            else{\n                for(int i = 0; i < 2;i++){\n                    for(int j = 0; j < 2;j++){\n                        ll innery1 = y1+dy[i], innerx1 = x1+dx[i];\n                        ll innery2 = ny - dy[j], innerx2 = nx - dx[j];\n                        if(innery1 > y2 || innerx1 > x2 || innery2 < y1 || innerx2 < x1 ) continue;\n                        if(!can[innery1][innerx1][innery2][innerx2]) continue;\n                        ret = max(ret,dfs(innery1,innerx1,innery2,innerx2,maze) + dfs(ny,nx,y2,x2,maze) + 1);\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint solve(ll H,ll W){\n    int res = -1;\n    vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n    for(int i = 0; i < 26;i++) alpha[i].clear();\n    for(int i = 1; i <= H;i++) for(int j = 1; j <= W;j++){\n        char c; cin >> c;\n        maze[i][j] = c;\n        if(c >= 'A' && c <= 'Z') alpha[c-'A'].push_back({i,j});\n    }\n     fill(***can,***can+MAX_WH*MAX_WH*MAX_WH*MAX_WH,false);\n    \n    for(ll i = H; i > 0; i--){\n        for(ll j = W; j > 0; j--){\n            if(maze[i][j] == '#')continue;\n            can[i][j][i][j] = 1;\n            if(maze[i+1][j] != '#'){\n                for(ll ii = i+1; ii <= H; ii++){\n                    for(ll jj = j; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i+1][j][ii][jj];\n                    }\n                }\n            }\n            if(maze[i][j+1] != '#'){\n                for(ll ii = i; ii <= H; ii++){\n                    for(ll jj = j+1; jj <= W; jj++){\n                        can[i][j][ii][jj] |= can[i][j+1][ii][jj];\n                    }\n                }\n            }\n        }\n    }\n    fill(***dp,***dp+MAX_WH*MAX_WH*MAX_WH*MAX_WH,-1);\n    res = max(res,dfs(1,1,H,W,maze));\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll H,W;\n    while(cin >> H >> W,H|W){\n        cout << solve(H,W) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 5) cout << \"*\" << endl;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[51][51][51][51];\nint W,H;\nchar C[55][55];\nint dx[]={1,0};\nint dy[]={0,1};\n\ntypedef pair<int,int> P;\nvector<P> pos[56];\n\nbool out(int x,int y){\n  return x>=W || y>=H;\n}\n\nbool isout( P p, int x1,int y1,int x2,int y2){\n  return p.first < x1 || x2  < p.first || p.second < y1 || y2 < p.second;\n}\n\nint solve(int x1,int y1,int x2,int y2){\n  int &ret = dp[x1][y1][x2][y2];\n  if( ret != -1 ) return ret;\n  ret = 0;\n  if( x1 == x2 && y1 == y2 ) return ret;\n  if( islower( C[x1][y1] ) ){\n    int aid = C[x1][y1] - 'a';\n    for( P p : pos[aid] ){\n      if( isout( p, x1,y1,x2,y2 ) ) continue;\n      for(int i=0;i<2;i++){\n        int nx = x1+dx[i], ny = y1+dy[i];\n        if( isout( P(nx,ny), x1,y1,x2,y2 ) ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        ret = max( ret, solve( nx,ny,p.first,p.second)+1+solve(p.first,p.second,x2,y2) );\n      }      \n    }\n  } else {\n    for(int i=0;i<2;i++){\n      int nx = x1+dx[i], ny = y1+dy[i];\n      if( isout( P(nx, ny), x1,y1,x2,y2 ) ) continue;\n      if( C[nx][ny] == '#' ) continue;\n      ret = max( ret, solve( nx,ny, x2,y2 ) );      \n    }\n  }\n  return ret;\n}\n\nbool used[55][55];\nbool dfs(int x,int y){\n  if( used[x][y] ) return false;\n  used[x][y] = true;\n  if( x == W-1 && y == H-1 ) return true;\n  if( x>=W || y>=H ) return false;\n  if( C[x][y] == '#' ) return false;\n  if( dfs(x+1,y) ) return true;\n  if( dfs(x,y+1) ) return true;  \n  return false;\n}\n\nint main(){\n  while( cin >> H >> W && (H|W) ){\n\n    for(int i=0;i<56;i++) pos[i].clear();\n\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> C[j][i];\n        if( isupper(C[j][i]) )\n          pos[C[j][i]-'A'].push_back( P(j,i) );        \n      }\n    }\n    memset( used,0,sizeof(used) );\n    if( !dfs( 0,0 ) ) cout << \"-1\" << endl;\n    else {     \n      memset( dp,-1,sizeof(dp));\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      dfs(i,y2,x2);\n      res1=max(res1,dp[i][y2][x2]);\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      dfs(i,y,x);\n      res2=max(res2,dp[i][y][x]);\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++) dfs(i,h-1,w-1);\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int dx[2]={1,0}, dy[2]={0,1};\n\nint main(){\n    int h,w;\n    while(cin >>h >>w,h){\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        vector<pi> p;\n        map<pi,int> p2id;\n        vector<int> s[26],t[26];\n        rep(i,h)rep(j,w){\n            if(islower(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                s[c[i][j]-'a'].pb(p2id[p.back()]);\n            }\n            else if(isupper(c[i][j])){\n                p.pb({i,j});\n                p2id[p.back()] = p2id.size();\n                t[c[i][j]-'A'].pb(p2id[p.back()]);\n            }\n        }\n\n        auto IN = [&](int y, int x){\n            return 0<=y && y<h && 0<=x && x<w;\n        };\n\n        auto BFS = [&](pi start){\n            vector<vector<bool>> vis(h,vector<bool>(w));\n            vis[start.fi][start.se] = true;\n            queue<pi> que;\n            que.push(start);\n            while(!que.empty()){\n                pi now = que.front();\n                que.pop();\n                rep(d,2){\n                    int ny = now.fi+dy[d], nx = now.se+dx[d];\n                    if(IN(ny,nx) && c[ny][nx]!='#' && !vis[ny][nx]){\n                        vis[ny][nx] = true;\n                        que.push({ny,nx});\n                    }\n                }\n            }\n            return vis;\n        };\n\n        vector<vector<bool>> reach_check = BFS({0,0});\n        if(!reach_check[h-1][w-1]){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int n = p.size();\n        // can move from i to j ?\n        vector<vector<bool>> mv(n,vector<bool>(n));\n        vector<bool> as_start(n), as_goal(n);\n\n        rep(i,n) as_start[i] = reach_check[p[i].fi][p[i].se];\n        rep(i,n){\n            vector<vector<bool>> vis = BFS(p[i]);\n            rep(j,n) mv[i][j] = vis[p[j].fi][p[j].se];\n\n            mv[i][i] = false;\n            as_goal[i] = vis[h-1][w-1];\n        }\n\n        vector<vector<int>> dp(n,vector<int>(n,-1));\n        rep(i,26){\n            for(int from:s[i])for(int to:t[i]){\n                if(mv[from][to]) dp[from][to] = 1;\n            }\n        }\n\n        rep(loop,53){\n            rep(i,26)for(int from:s[i])for(int to:t[i]){\n                if(!mv[from][to]) continue;\n\n                rep(j,26){\n                    for(int x:s[j]){\n                        if(!mv[from][x]) continue;\n                        for(int y:t[j]){\n                            if(mv[x][y] && mv[y][to]) dp[from][to] = max(dp[from][to], dp[x][y]+1);\n                        }\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> dp2(h,vector<int>(w,-1));\n        dp2[0][0] = 0;\n        rep(i,h)rep(j,w){\n            rep(d,2){\n                int ni = i+dy[d], nj = j+dx[d];\n                if(IN(ni,nj)) dp2[ni][nj] = max(dp2[ni][nj], dp2[i][j]);\n            }\n\n            if(islower(c[i][j])){\n                int from = p2id[{i,j}];\n                for(int to:t[c[i][j]-'a']){\n                    if(mv[from][to]){\n                        dp2[p[to].fi][p[to].se] = max(dp2[p[to].fi][p[to].se], dp2[i][j]+dp[from][to]);\n                    }\n                }\n            }\n        }\n        cout << dp2[h-1][w-1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nvector<vector<int>>to(vector<string>&s, int y, int x) {\n\tvector<vector<int>>ret(s.size(), vector<int>(s[0].size()));\n\tret[y][x] = 1;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (i + 1 < H) {\n\t\t\t\tif (s[i + 1][j] != '#')ret[i + 1][j] |= ret[i][j];\n\t\t\t}\n\t\t\tif (j + 1 < W) {\n\t\t\t\tif (s[i][j + 1] != '#')ret[i][j + 1] |= ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<vector<int>>rev(vector<string>&s, int y, int x) {\n\tvector<vector<int>>ret(s.size(), vector<int>(s[0].size()));\n\tret[y][x] = 1;\n\tfor (int i = H - 1; i >= 0; i--) {\n\t\tfor (int j = W - 1; j >= 0; j--) {\n\t\t\tif (i) {\n\t\t\t\tif (s[i - 1][j] != '#')ret[i - 1][j] |= ret[i][j];\n\t\t\t}\n\t\t\tif (j) {\n\t\t\t\tif (s[i][j - 1] != '#')ret[i][j - 1] |= ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tvector<int>o;\n\twhile (cin >> H >> W, H) {\n\t\tvector<string>s(H);\n\t\tfor (auto &i : s)cin >> i;\n\t\tint ret = -1;\n\t\tauto st = to(s, 0, 0);\n\t\tauto gl = rev(s, H - 1, W - 1);\n\t\tif (st.back().back())ret = 0;\n\t\tvector<pair<int, int>>l;\n\t\tvector<pair<int, int>>r;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] >= 'a'&&s[i][j] <= 'z'&&st[i][j] && gl[i][j])l.emplace_back(i, j);\n\t\t\t\tif (s[i][j] >= 'A'&&s[i][j] <= 'Z'&&st[i][j] && gl[i][j])r.emplace_back(i, j);\n\t\t\t}\n\t\t}\n\t\tvector < pair<pair<int, int>, pair<int, int>>>p;\n\t\tfor (int i = 0; i < l.size(); i++) {\n\t\t\tauto t = to(s, l[i].first, l[i].second);\n\t\t\tfor (int j = r.size() - 1; j >= 0; j--) {\n\t\t\t\tif (s[l[i].first][l[i].second] - 'a' == s[r[j].first][r[j].second] - 'A'&&t[r[j].first][r[j].second]) {\n\t\t\t\t\tp.push_back({ l[i], r[j] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>num(p.size(),1);\n\t\tvector<vector<vector<int>>>ed_to(p.size());\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\ted_to[i] = to(s, p[i].second.first, p[i].second.second);\n\t\t}\n\t\tfor (int i = p.size() - 1; i >= 0; i--) {\n\t\t\tauto fst = to(s, p[i].first.first, p[i].first.second);\n\t\t\tauto snd = rev(s, p[i].second.first, p[i].second.second);\n\t\t\tvector<int>dp(p.size(), 0);\n\t\t\tfor (int j = i + 1; j < p.size(); j++) {\n\t\t\t\tif (p[i].first == p[j].first)continue;\n\t\t\t\tif (p[i].second == p[j].second)continue;\n\t\t\t\tif (!fst[p[j].first.first][p[j].first.second] || !snd[p[j].second.first][p[j].second.second]) continue;\n\t\t\t\tdp[j] = num[j];\n\t\t\t\tfor (int k = i + 1; k < j; k++) {\n\t\t\t\t\tif (p[i].first == p[k].first)continue;\n\t\t\t\t\tif (p[i].second == p[k].second)continue;\n\t\t\t\t\tif (p[j].first == p[k].first)continue;\n\t\t\t\t\tif (p[j].second == p[k].second)continue;\n\t\t\t\t\tif (ed_to[k][p[j].first.first][p[j].first.second]) {\n\t\t\t\t\t\tdp[j]= max(dp[j], dp[k] + num[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum[i] = *max_element(dp.begin(), dp.end()) + 1;\n\t\t}\n\t\tauto dp = num;\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\tfor (int j = i + 1; j < p.size(); j++) {\n\t\t\t\tif (p[i].first == p[j].first)continue;\n\t\t\t\tif (p[i].second == p[j].second)continue;\n\t\t\t\tif (ed_to[i][p[j].first.first][p[j].first.second]) {\n\t\t\t\t\tdp[j] = max(dp[j], num[j] + dp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto i : dp) {\n\t\t\tret = max(ret, i);\n\t\t}\n\t\to.push_back(ret);\n\t}\n\tfor (auto i : o)cout << i << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <iostream>\n\n#define INF 1e8\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[2]={1,0};\nint dy[2]={0,1};\n\nint w,h;\nint fie[51][51];\nint dp[51][51][51][51];\nbool move[51][51][51][51];\nvector<P> hole[26];\n\nvoid bfs(int sy,int sx){\n\tqueue<P> que;\n\tque.push(P(sy,sx));\n\tmove[sy][sx][sy][sx]=true;\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<2;i++){\n\t\t\tint ny=p.first+dy[i],nx=p.second+dx[i];\n\t\t\tif(ny>=0 && ny<h && nx>=0 && nx<w){\n\t\t\t\tif(fie[ny][nx]>=0 && !move[sy][sx][ny][nx]){\n\t\t\t\t\tmove[sy][sx][ny][nx]=true;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int y1,int x1,int y2,int x2){\n\tif(dp[y1][x1][y2][x2]!=-1)return dp[y1][x1][y2][x2];\n\tif(!move[y1][x1][y2][x2])return -1;\n\tif(x2<x1 || y2<y1)return -1;\n\tif(x1==x2 && y1==y2)return 0;\n\tif(fie[y1][x1]==0){\n\t\tint res=0;\n\t\tif(y1+1<h && move[y1][x1][y1+1][x1])res=max(res,dfs(y1+1,x1,y2,x2));\n\t\tif(x1+1<w && move[y1][x1][y1][x1+1])res=max(res,dfs(y1,x1+1,y2,x2));\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}else{\n\t\tint res=0;\n\t\tif(y1+1<h && move[y1][x1][y1+1][x1])res=max(res,dfs(y1+1,x1,y2,x2));\n\t\tif(x1+1<w && move[y1][x1][y1][x1+1])res=max(res,dfs(y1,x1+1,y2,x2));\n\t\tfor(int i=0;i<hole[fie[y1][x1]-1].size();i++){\n\t\t\tP coo=hole[fie[y1][x1]-1][i];\n\t\t\tif(move[y1][x1][coo.first][coo.second] && move[coo.first][coo.second][y2][x2]){\n\t\t\t\tif(abs(y1-coo.first)+abs(x1-coo.second)==1){\n\t\t\t\t\tres=max(res,1+dfs(coo.first,coo.second,y2,x2));\n\t\t\t\t}else{\n\t\t\t\t\tint rr=dfs(coo.first,coo.second,y2,x2);\n\t\t\t\t\tif(rr==-1)continue;\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tint nx1=x1+dx[j],ny1=y1+dy[j];\n\t\t\t\t\t\tif(nx1<0 || nx1>=w || ny1<0 || ny1>=h)continue;\n\t\t\t\t\t\tif(!move[y1][x1][ny1][nx1])continue;\n\t\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\t\tint nx2=coo.second-dx[k],ny2=coo.first-dy[k];\n\t\t\t\t\t\t\tif(nx2<0 || nx2>=w || ny2<0 || ny2>=h)continue;\n\t\t\t\t\t\t\tif(!move[ny2][nx2][y2][x2])continue;\n\t\t\t\t\t\t\tif(!move[ny1][nx1][ny2][nx2])continue;\n\t\t\t\t\t\t\tres=max(res,rr+1+dfs(ny1,nx1,ny2,nx2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[y1][x1][y2][x2]=res;\n\t}\n}\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&h,&w);\n\t\tif(h==0 && w==0)break;\n\t\tfor(int i=0;i<26;i++){\n\t\t\thole[i].clear();\n\t\t}\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='#')fie[i][j]=-1;\n\t\t\t\tif(str[j]>='a' && str[j]<='z'){\n\t\t\t\t\tfie[i][j]=str[j]-'a'+1;\n\t\t\t\t}\n\t\t\t\tif(str[j]>='A' && str[j]<='Z'){\n\t\t\t\t\thole[str[j]-'A'].push_back(P(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(move,false,sizeof(move));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[i][j]>=0)bfs(i,j);\n\t\t\t}\n\t\t}\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tprintf(\"%d\\n\",dfs(0,0,h-1,w-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nstring field[52];\nvector<P> G[52][52];\n\nbool visited[52][52];\nconst int dd[] = {0, 1, 0};\nint memo[52][52][52][52];\n\nint dfs(int i, int j, int ei, int ej){\n    if(i == ei && j == ej) return 0;\n    if(memo[i][j][ei][ej] != -1) return memo[i][j][ei][ej];\n    int ret = -100000;\n    for(P& to : G[i][j]){\n        if(to.first <= ei && to.second <= ej){\n            if(i < ei) ret = max(ret, 1 + dfs(i+1, j, to.first, to.second) + dfs(to.first, to.second, ei, ej));\n            if(j < ej) ret = max(ret, 1 + dfs(i, j+1, to.first, to.second) + dfs(to.first, to.second, ei, ej));\n        }\n    }\n    if(i < ei && field[i+1][j] != '#') ret = max(ret, dfs(i+1, j, ei, ej));\n    if(j < ej && field[i][j+1] != '#') ret = max(ret, dfs(i, j+1, ei, ej));\n    memo[i][j][ei][ej] = ret;\n    return ret;\n}\n\nint main(){\n    while(true){\n        int W, H;\n        cin >> H >> W;\n        if(H == 0) break;\n\n        for(int i=0;i<H;i++){\n            cin >> field[i];\n        }\n\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                G[i][j].clear();\n                if('a' <= field[i][j] && field[i][j] <= 'z'){\n                    char goal = field[i][j] - 'a' + 'A';\n                    memset(visited, 0, sizeof(visited));\n                    queue<P> que;\n                    que.emplace(i, j);\n                    visited[i][j] = true;\n                    while(que.size()){\n                        P p = que.front(); que.pop();\n                        if(field[p.first][p.second] == goal){\n                            G[i][j].emplace_back(p.first, p.second);\n                        }\n                        for(int k=0;k<2;k++){\n                            int ni = p.first + dd[k], nj = p.second + dd[k+1];\n                            if(ni < 0 || H <= ni || nj < 0 || W <= nj || field[ni][nj] == '#' || visited[ni][nj]) continue;\n                            visited[ni][nj] = true;\n                            que.emplace(ni, nj);\n                        }\n                    }\n                }\n            }\n        }\n\n        memset(memo, -1, sizeof(memo));\n        cout << max(-1, dfs(0, 0, H-1, W-1)) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint H,W,C;\nchar s[100],a[10000];\nchar t[100][100];\nint id[100][100];\nint INF=1e8;\nmap<int,int> dp[100][100];\nint ans;\n\nint dfs(int y,int x,int bit){\n\n  if(y<0||x<0||y>=H||x>=W)return -INF;\n\n  if(t[y][x]=='#')return -INF;\n\n  int res=0;\n  if('a'<=t[y][x]&&t[y][x]<='z'){\n    bit|=(1<<id[y][x]);\n  }\n  \n  if(dp[y][x].count(bit)){\n    return dp[y][x][bit];\n  }\n  \n  int flg=0;\n  int nbit=bit;\n  if('A'<=t[y][x]&&t[y][x]<='Z'){\n    for(int i=C-1;i>=0;i--){\n      if( (nbit>>i&1) && a[i]==t[y][x] ){\n        flg=1;\n        break;\n      }else{\n        nbit|=(1<<i);\n        nbit-=(1<<i);\n      }\n    }\n  }\n  \n  if(y==H-1&&x==W-1){\n    ans=1;\n    return flg;\n  }\n\n\n  res=max(res,dfs(y+1,x,bit));\n  res=max(res,dfs(y,x+1,bit));\n  res=max(res,dfs(y+1,x,nbit)+flg);\n  res=max(res,dfs(y,x+1,nbit)+flg);\n  return dp[y][x][bit]=max(res,flg);\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        dp[i][j].clear();\n    \n    C=0;\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",s);\n      for(int j=0;j<W;j++){\n        t[i][j]=s[j];\n        if('a'<=t[i][j]&&t[i][j]<='z'){\n          a[C]=t[i][j]-'a'+'A';\n          id[i][j]=C++;\n        }\n      }\n    }\n\n    ans=0;\n    int out=dfs(0,0,0);\n    if(ans){\n      cout<<out<<endl;\n    }else{\n      cout<<-1<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1e7;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1e7;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1e7;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1e7;\n  if(ly==ry&&lx==rx)return 0;\n  if(ly==ry&&lx==rx+1)return 0;\n  if(ly==ry+1&&lx==rx)return 0;\n  if(ly==ry+1&&lx==rx+1)return 0;\n  if(ly>ry||lx>rx)return -1e7;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    dfs(0,0,h-1,w-1);\n    cout<<(dp[0][0][h-1][w-1]<0?-1:dp[0][0][h-1][w-1])<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int INF=1e9;\nstring s[50];\nint h, w;\nint memo[50][50][50][50];\nint solve(int a, int b, int c, int d){\n  if(memo[a][b][c][d]<INF) return memo[a][b][c][d];\n  if(s[a][b]=='#' || s[c][d]=='#') return memo[a][b][c][d]=-1;\n  if(a==c && b==d) return memo[a][b][c][d]=0;\n  int ans=-1;\n  if(s[a][b]>='a' && s[a][b]<='z' && s[c][d]>='A' && s[c][d]<='Z' && (s[a][b]-'a')==(s[c][d]-'A')){\n    if((a+1==c && b==d) || (a==c && b+1==d)){\n      return memo[a][b][c][d]=1;\n    }\n    int r=-1;\n    if(a+1<=c-1) r=max(r, solve(a+1, b, c-1, d));\n    if(a+1<=c && b<=d-1) r=max(r, solve(a+1, b, c, d-1));\n    if(a<=c-1 && b+1<=d) r=max(r, solve(a, b+1, c-1, d));\n    if(b+1<=d-1) r=max(r, solve(a, b+1, c, d-1));\n    if(r>=0) ans=max(ans, r+1);\n  }\n  if(s[a][b]=='.'){\n    if(a+1<=c) ans=max(ans, solve(a+1, b, c, d));\n    if(b+1<=d) ans=max(ans, solve(a, b+1, c, d));\n    return memo[a][b][c][d]=ans;\n  }\n  if(s[c][d]=='.'){\n    if(a<=c-1) ans=max(ans, solve(a, b, c-1, d));\n    if(b<=d-1) ans=max(ans, solve(a, b, c, d-1));\n    return memo[a][b][c][d]=ans;\n  }\n  for(int i=a; i<=c; i++){\n    for(int j=b; j<=d; j++){\n      if(i==c && j==d) continue;\n      int r1=solve(a, b, i, j);\n      if(r1==-1) continue;\n      int r2=-1;\n      if(i+1<=c) r2=max(r2, solve(i+1, j, c, d));\n      if(j+1<=d) r2=max(r2, solve(i, j+1, c, d));\n      if(r2>=0) ans=max(ans, r1+r2);\n    }\n  }\n  return memo[a][b][c][d]=ans;\n}\nint main()\n{\n\twhile(1){\n      int h, w;\n      cin>>h>>w;\n      if(h==0 && w==0) return 0;\n      for(int i=0; i<h; i++) cin>>s[i];\n      for(int a=0; a<h; a++){\n        for(int b=0; b<w; b++){\n          for(int c=a; c<h; c++){\n            for(int d=b; d<w; d++){\n              memo[a][b][c][d]=INF;\n            }\n          }\n        }\n      }\n      cout<<solve(0, 0, h-1, w-1)<<endl;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nconst int INF = 5000;\n\nvector<string> field;\nunordered_map<char, vector<pair<int,int>>> holes_of;\nint dp[55][55][55][55];\nbool visited[55][55][55][55];\n\nint calc(int t, int l, int b, int r) {\n    if(visited[t][l][b][r]) return dp[t][l][b][r];\n    if(t > b || l > r) return -INF;\n    if(field[t][l] == '#') return -INF;\n    visited[t][l][b][r] = true;\n    int &res = dp[t][l][b][r];\n    if(t == b && l == r) {\n        res = 0;\n    } else {\n        res = max(res, calc(t+1, l, b, r));\n        res = max(res, calc(t, l+1, b, r));\n        if(islower(field[t][l])) {\n            // Pick and place\n            for(const auto &to : holes_of[field[t][l]]) {\n                //cout << field[t][l] << ' ' << to.first << ' ' << to.second << endl;\n                if(to.first == b && to.second == r) continue;\n                res = max(res, calc(t+1, l, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n                res = max(res, calc(t, l+1, to.first, to.second) + 1 + calc(to.first, to.second, b, r));\n            }\n        }\n    }\n    if(res < 0) res = -INF;\n    return res;\n}\n\nbool solve() {\n    int H, W;\n    if(!(cin >> H >> W)) return false;\n    if(!H && !W) return false;\n\n    field.clear();\n    field.resize(H);\n    holes_of.clear();\n    for(int i = 0; i < H; ++i) {\n        cin >> field[i];\n        for(int j = 0; j < W; ++j) {\n            if(isupper(field[i][j])) {\n                const char c = tolower(field[i][j]);\n                holes_of[c].push_back(make_pair(i, j));\n            }\n        }\n    }\n    field.push_back(string(W, '#'));\n    field.back()[W-1] = '.';\n    fill_n((int*)dp, sizeof(dp)/sizeof(int), -INF);\n    fill_n((bool*)visited, sizeof(visited)/sizeof(bool), false);\n\n    int res = calc(0, 0, H, W-1);\n    if(res < 0) res = -1;\n    cout << res << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint H, W, dp[55][55][55][55]; char c[55][55];\n\nvoid init() {\n\tfor (int i = 0; i < H; i++) { for (int j = 0; j < W; j++) { for (int k = 0; k < H; k++) { for (int l = 0; l < W; l++) dp[i][j][k][l] = -(1 << 29); } } }\n}\n\nint solve(int px, int py, int qx, int qy) {\n\tif (px > qx || py > qy) return -(1 << 28);\n\tif (c[px][py] == '#' || c[qx][qy] == '#') return -(1 << 28);\n\tif ((qx - px) + (qy - py) == 0) return 0;\n\tif (dp[px][py][qx][qy] >= -(1 << 28)) return dp[px][py][qx][qy];\n\n\tint A1 = solve(px + 1, py, qx, qy);\n\tint A2 = solve(px, py + 1, qx, qy);\n\tint A3 = solve(px, py, qx - 1, qy);\n\tint A4 = solve(px, py, qx, qy - 1);\n\n\tint A5 = -(1 << 28);\n\tfor (int i = px; i <= qx; i++) {\n\t\tfor (int j = py; j <= qy; j++) {\n\t\t\tif ((i == qx && j == qy) || c[i][j] == '#' || c[i][j] == '.') continue;\n\t\t\tint t1 = solve(px, py, i, j) + solve(i, j + 1, qx, qy);\n\t\t\tint t2 = solve(px, py, i, j) + solve(i + 1, j, qx, qy);\n\t\t\tA5 = max({ A5, t1, t2 });\n\t\t}\n\t}\n\tint A6 = -(1 << 28);\n\tif (c[px][py] - c[qx][qy] == 32 && 'a' <= c[px][py] && c[px][py] <= 'z') {\n\t\tint B1 = solve(px + 1, py, qx - 1, qy);\n\t\tint B2 = solve(px + 1, py, qx, qy - 1);\n\t\tint B3 = solve(px, py + 1, qx - 1, qy);\n\t\tint B4 = solve(px, py + 1, qx, qy - 1);\n\t\tA6 = max({ B1, B2, B3, B4 }) + 1;\n\t\tif ((qx - px) + (qy - py) == 1) A6 = max(A6, 1);\n\t}\n\n\tint Score = max({ A1, A2, A3, A4, A5, A6 }); if (Score < 0) Score = -(1 << 28);\n\tdp[px][py][qx][qy] = Score;\n\treturn Score;\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0 && W == 0) break;\n\t\tinit();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) cin >> c[i][j];\n\t\t}\n\t\tint ret = solve(0, 0, H - 1, W - 1);\n\t\tif (ret == -(1 << 28)) ret = -1;\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\n\nint H,W;\nint dp[52][52][52][52];\nint diff_row[2] = {0,1},diff_col[2] = {1,0};\nchar table[51][52];\nbool can_visit[52][52][52][52];\n\n\nbool rangeCheck(int row,int col){\n\tif(row >= 1 && row <= H && col >= 1 && col <= W)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint recursive(int row1,int col1,int row2,int col2){\n\n\tif(dp[row1][col1][row2][col2] != -1)return dp[row1][col1][row2][col2];\n\n\tif(row1 == row2 && row1 == H && col1 == col2 && col1 == W)return 0;\n\n\tint ret = 0;\n\n\tif(table[row1][col1] == '.' || (table[row1][col1] >= 'A' && table[row1][col1] <= 'Z')){\n\n\t\tif(can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t}else if(table[row1][col1] >= 'a' && table[row1][col1] <= 'z'){\n\n\t\tif(can_visit[row1][col1][row1][col1+1] == true)ret = max(ret,recursive(row1,col1+1,row2,col2));\n\n\t\tif(can_visit[row1][col1][row1+1][col1] == true)ret = max(ret,recursive(row1+1,col1,row2,col2));\n\n\t\tfor(int tmp_row = row1; tmp_row <= row2; tmp_row++){\n\t\t\tfor(int tmp_col = col1; tmp_col <= col2; tmp_col++){\n\t\t\t\tif(table[tmp_row][tmp_col]+32 == table[row1][col1] && can_visit[row1][col1][tmp_row][tmp_col] == true &&\n\t\t\t\t\t\tcan_visit[tmp_row][tmp_col][row2][col2] == true){\n\n\t\t\t\t\tif((tmp_row == row1 && tmp_col == col1+1) || (tmp_row == row1+1 && tmp_col == col1)){\n\n\t\t\t\t\t\tret = max(ret,recursive(tmp_row,tmp_col,row2,col2)+1);\n\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(can_visit[row1][col1][row1][col1+1] == true){\n\n\t\t\t\t\t\t\tif(can_visit[row1][col1+1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(can_visit[row1][col1+1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1,col1+1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(can_visit[row1][col1][row1+1][col1] == true){\n\n\t\t\t\t\t\t\tif(can_visit[row1+1][col1][tmp_row-1][tmp_col] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row-1,tmp_col)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(can_visit[row1+1][col1][tmp_row][tmp_col-1] == true){\n\t\t\t\t\t\t\t\tret = max(ret,recursive(row1+1,col1,tmp_row,tmp_col-1)+recursive(tmp_row,tmp_col,row2,col2)+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[row1][col1][row2][col2] = ret;\n}\n\nvoid func(){\n\n\tfor(int row = 1; row <= H; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = W; col >= 1; col--){\n\t\t\ttable[row][col] = table[row][col-1];\n\t\t}\n\t}\n\n\n\tfor(int a = 0; a <= H+1; a++){\n\t\tfor(int b = 0; b <= W+1; b++){\n\t\t\tfor(int c = 0; c <= H+1; c++){\n\t\t\t\tfor(int d = 0; d <= W+1; d++){\n\t\t\t\t\tdp[a][b][c][d] = -1;\n\t\t\t\t\tcan_visit[a][b][c][d] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tint adj_row,adj_col;\n\n\tfor(int start_row = 1; start_row <= H; start_row++){\n\t\tfor(int start_col = 1; start_col <= W; start_col++){\n\t\t\tif(table[start_row][start_col] == '#')continue;\n\n\t\t\tcan_visit[start_row][start_col][start_row][start_col] = true;\n\t\t\tQ.push(Info(start_row,start_col));\n\n\t\t\twhile(!Q.empty()){\n\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tadj_row = Q.front().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.front().col+diff_col[i];\n\n\t\t\t\t\tif(rangeCheck(adj_row,adj_col) == false || table[adj_row][adj_col] == '#' || can_visit[start_row][start_col][adj_row][adj_col] == true)continue;\n\n\t\t\t\t\tcan_visit[start_row][start_col][adj_row][adj_col] = true;\n\t\t\t\t\tQ.push(Info(adj_row,adj_col));\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tif(can_visit[1][1][H][W] == false){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%d\\n\",recursive(1,1,H,W));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[4][55][55][55][55];\nbool used[4][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return -1;\n  if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if((c&1)&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif((c&2)&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(2,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(3,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint dp[52][52][52][52];\nint v[52][52][52][52];\nint r[600];\nint w[600];\nint sz;\nint H,W;\nint solve(int a,int b,int c,int d){\n\tif(a>c||b>d)return 0;\n\tif(a<0||b<0||c>=H||d>=W)return 0;\n\tif(~dp[a][b][c][d])return dp[a][b][c][d];\n\tif(a==c&&b==d)return dp[a][b][c][d]=0;\n\tint ret=0;\n\tif(str[a][b]-32==str[c][d]){\n\t\tif(v[a][b][c][d])ret=1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])&&\n\t\t\t\tv[r[j]][w[j]][c][d]&&(c!=r[j]||d!=w[j])){\n\t\t\t\t\tret=max(ret,solve(r[i],w[i],r[j],w[j])+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&(a!=r[i]||b!=w[i])){\n\t\t\tret=max(ret,solve(r[i],w[i],c,d));\n\t\t}\n\t\tif(v[r[i]][w[i]][c][d]&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<sz;i++){\n\t\tif(v[a][b][r[i]][w[i]]&&v[r[i]][w[i]][c][d]&&(a!=r[i]||b!=w[i])&&(c!=r[i]||d!=w[i])){\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i],w[i]+1,c,d));\n\t\t\tret=max(ret,solve(a,b,r[i],w[i])+solve(r[i]+1,w[i]+1,c,d));\n\t\t\t\n\t\t}\n\t}\n\t//printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tH=a;W=b;\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\tv[i][j][k][l]=0;\n\t\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(str[i][j]!='.'&&str[i][j]!='#'){\n\t\t\t\t\tr[sz]=i;w[sz++]=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='#')continue;\n\t\t\tv[i][j][i][j]=1;\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tif(str[k][l]=='#')continue;\n\t\t\t\tif(k&&v[i][j][k-1][l])v[i][j][k][l]=1;\n\t\t\t\tif(l&&v[i][j][k][l-1])v[i][j][k][l]=1;\n\t\t\t}\n\t\t}\n\t\tint ret=solve(0,0,a-1,b-1);\n\t\tif(!v[0][0][a-1][b-1])printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nchar C[51][51];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvector<P> G[51][51];\nint dp[52][52][52][52];\n\nint H,W;\n\nint solve(int x1,int y1,int x2,int y2){\n  int &res = dp[x1][y1][x2][y2];\n  if( res != -1 ) return res;\n  res = 0;\n  // cout << \"in \" << x1 << \" \" << y1 << \" \" << C[x1][y1] << \" \"<< x2 << \" \" << y2 << \" \" << C[x2][y2]<< \" \" << res << endl;\n  if( x1 >= W || y1 >= H || x2 >= W || y2 >= H  ) return res;\n  if( x1 == x2 && y1 == y2 ) return res;\n  if( x1 > x2 || y1 > y2 ) return res;\n  if( C[x1][y1] == '#' || C[x2][y2] == '#' ) return res;  \n  if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ){\n    for(int i=0;i<(int)G[x1][y1].size();i++){\n      int mx = G[x1][y1][i].first, my = G[x1][y1][i].second;\n      if( mx > x2 || my > y2 ) continue;\n      for(int j=0;j<2;j++){\n        for(int k=2;k<4;k++){\n          int nx1 = x1 + dx[j], ny1 = y1 + dy[j];\n          int nx2 = mx + dx[k], ny2 = my + dy[k];\n          res = max( res,\n                     solve(nx1,ny1,nx2,ny2) + solve(mx,my,x2,y2) + 1 );\n        }\n      }\n    }\n  }\n  for(int i=0;i<2;i++){\n    int nx1 = x1 + dx[i], ny1 = y1 + dy[i];\n    res = max( res, solve(nx1,ny1,x2,y2) );\n  }\n  return res;\n}\n\n\n\nint main(){\n  while( cin >> H >> W && (H||W) ){\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n        cin >> C[j][i];\n\n    queue<P> q;\n    int h[51][51]={};\n    q.push(P(0,0) );\n    h[0][0] = 1;\n    while( !q.empty() ){\n      P p = q.front(); q.pop();\n      int x = p.first, y = p.second;\n      for(int i=0;i<2;i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if( nx >= W || ny >= H ) continue;\n        if( h[nx][ny] ) continue;\n        if( C[nx][ny] == '#' ) continue;\n        q.push( P(nx,ny) );\n        h[nx][ny] = 1;\n      }\n    }\n\n    if( !h[W-1][H-1] )\n      cout << -1 << endl;\n    else {\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          for(int k=0;k<H;k++)\n            for(int l=0;l<W;l++)\n              dp[j][i][l][k] = -1;\n\n      for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n          G[j][i].clear();\n\n      for(int y1=0;y1<H;y1++)\n        for(int x1=0;x1<W;x1++)\n          if( 'a' <= C[x1][y1] && C[x1][y1] <= 'z' ) \n            for(int y2=y1;y2<H;y2++)\n              for(int x2=x1;x2<W;x2++)\n                if( C[x2][y2] - C[x1][y1] == 'A' - 'a' ) \n                  G[x1][y1].push_back( P(x2,y2) );\n              \n      // cout << \" in \" << endl;\n      cout << solve(0,0,W-1,H-1) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint H, W;\nchar C[55][55];\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nbool in(int y, int x) {\n  return 0<=y&&y<H&&0<=x&&x<W&&C[y][x]!='#';\n}\n\nbool used[55][55];\nbool bfs() {\n  memset(used, false, sizeof(used));\n  queue<Pi> que;\n  used[0][0] = true;\n  que.emplace(0, 0);\n  while(!que.empty()) {\n    int y, x; tie(y, x) = que.front(); que.pop();\n    if(y == H-1 && x == W-1) break;\n    rep(i, 2) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if(!in(ny, nx)) continue;\n      if(used[ny][nx]) continue;\n      used[ny][nx] = true;\n      que.emplace(ny, nx);\n    }\n  }\n  return used[H-1][W-1];\n}\n\nvector<Pi> hole[26];\n\nint dp[55][55][55][55];\nint dfs(int sy, int sx, int ty, int tx) {\n  if(!in(sy, sx) || !in(ty, tx)) return -inf;\n  if(sy > ty || sx > tx) return -inf;\n  if(sy == ty && sx == tx) return 0;\n  int &res = dp[sy][sx][ty][tx];\n  if(~res) return res;\n  res = -inf;\n  rep(i, 2) {\n    int ny = sy + dy[i], nx = sx + dx[i];\n    if(!in(ny, nx)) continue;\n    chmax(res, dfs(ny, nx, ty, tx));\n  }\n  if(!islower(C[sy][sx])) return res;\n  int c = C[sy][sx] - 'a';\n  rep(i, hole[c].size()) {\n    int hy = hole[c][i].first, hx = hole[c][i].second;\n    if(sy > hy || sx > hx) continue;\n    if(ty < hy || tx < hx) continue;\n    bool flag = false;\n    rep(j, 2) {\n      int ny = sy + dy[j], nx = sx + dx[j];\n      if(ny == hy && nx == hx) flag = true;\n    }\n    if(flag) {\n      chmax(res, dfs(hy, hx, ty, tx)+1);\n      continue;\n    }\n    rep(j, 2) {\n      int ny = sy + dy[j], nx = sx + dx[j];\n      if(!in(ny, nx)) continue;\n      rep(k, 2) {\n\tint my = hy - dy[k], mx = hx - dx[k];\n\tif(!in(my, mx)) continue;\n\tint tmp1 = dfs(ny, nx, my, mx);\n\tint tmp2 = dfs(hy, hx, ty, tx);\n\tchmax(res, tmp1+tmp2+1);\n      }\n    }\n  }\n\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> H >> W, H || W) {\n    rep(i, 26) hole[i].clear();\n    rep(i, H) rep(j, W) {\n      cin >> C[i][j];\n      if(isupper(C[i][j])) hole[C[i][j]-'A'].emplace_back(i, j);\n    }\n    if(!bfs()) {\n      cout << -1 << endl;\n      continue;\n    }\n    memset(dp, -1, sizeof(dp));\n    int ans = dfs(0, 0, H-1, W-1);\n    //cout << (ans < 0 ? -1 : ans) << endl;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 0) cout << \"*\" << endl;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nstruct Point{\n    int x, y;\n    Point() {x = y = -1;}\n    Point(int x, int y): x(x), y(y) {}\n    bool operator== (const Point& p) const { return x == p.x && y == p.y; }\n    bool operator< (const Point& p) const { return x < p.x || y < p.y; }\n    const Point operator+ (const Point& p) const { return Point(x + p.x, y + p.y);}\n};\nconst int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};\nint H, W;\nvector<string> fld;\nint dp[51][51][51][51];\nvector<Point> holes[26];\n\nbool range_out(Point a){\n    return a < Point(0, 0) || Point(W - 1, H - 1) < a ;\n}\nbool is_Wall(Point a){\n    return fld[a.y][a.x] == '#';\n}\nint dfs(Point a, Point b){\n    if(range_out(a) || range_out(b)) return dp[a.y][a.x][b.y][b.x] = -INF;\n    if(dp[a.y][a.x][b.y][b.x] != -1) return dp[a.y][a.x][b.y][b.x];\n    if(a == b || b < a || is_Wall(a) || is_Wall(b)) return dp[a.y][a.x][b.y][b.x] = 0;\n    int res = 0;\n    if('a' <= fld[a.y][a.x] && fld[a.y][a.x] <= 'z'){\n        int k = fld[a.y][a.x] - 'a';\n        for(Point hole : holes[k]){\n            if(hole < a || b < hole) continue;\n            rep(i, 2) REP(j, 2, 4){\n                Point nx1 = a + Point(dx[i], dy[i]), nx2 = hole + Point(dx[j], dy[j]);\n                if(nx1 == hole) res = max(1, res);\n                if(range_out(nx1) || range_out(nx2)) continue;\n                if(is_Wall(a) || is_Wall(b)) continue;\n                res = max(res, dfs(nx1, nx2) + dfs(hole, b) + 1);\n            }\n        }\n    }\n    rep(i, 2)\n      res = max(res, dfs(a + Point(dx[i], dy[i]), b));\n    return dp[a.y][a.x][b.y][b.x] = res;\n}\nbool can_reach[51][51];\nbool bfs(){\n    memset(can_reach, 0, sizeof(can_reach));\n    queue<Point> que;\n    que.push(Point(0, 0));\n    can_reach[0][0] = true;\n    while(!que.empty()){\n        Point now = que.front(); que.pop();\n        rep(i, 2){\n            int nx = now.x + dx[i], ny = now.y + dy[i];\n            if(W <= nx || H <= ny || fld[ny][nx] == '#' || can_reach[ny][nx])\n              continue;\n            can_reach[ny][nx] = true;\n            que.push(Point(nx, ny));\n        }\n    }\n    return can_reach[H - 1][W - 1];\n}\nvoid find_hole(){\n    rep(i, 26) holes[i].clear();\n    rep(i, H) rep(j, W)\n      if('A' <= fld[i][j] && fld[i][j] <= 'Z')\n        holes[fld[i][j] - 'A'].push_back(Point(j, i));\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> H >> W && H){\n        fld = vector<string>(H);\n        rep(i, H) cin >> fld[i];\n        if(!bfs()){\n            cout << \"-1\" << endl;\n            continue;\n        }\n        find_hole();\n        memset(dp, -1, sizeof(dp));\n        cout << max(0, dfs(Point(0, 0), Point(W - 1, H - 1))) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[2]={1,0};\nconst int dy[2]={0,1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nconst int N = 50;\n\n// y1, x1, y2, x2 ( [y1, y2), [x1, x2) )\nint memo[N][N][N + 1][N + 1];\n\nint h, w;\nvector<string> field;\n\nvi next_ys[N][N];\nvi next_xs[N][N];\n\nint ok[N + 1][N + 1][N + 1][N + 1];\n\ninline bool is_valid(int y1, int x1, int y2, int x2){\n    return ok[y1][x1][y2][x2];\n}\n\nint rec(int y1, int x1, int y2, int x2){\n    int& ret = memo[y1][x1][y2][x2];\n    if(ret != -2){\n        return ret;\n    }\n    if(y1 + 1 == y2 and x1 + 1 == x2){\n        return (ret = 0);\n    }\n\n    ret = -1;\n\n    // not pick up\n    if(is_valid(y1 + 1, x1, y2, x2)){\n        chmax(ret, rec(y1 + 1, x1, y2, x2));\n    }\n    if(is_valid(y1, x1 + 1, y2, x2)){\n        chmax(ret, rec(y1, x1 + 1, y2, x2));\n    }\n\n    // pick up\n    rep(i, (int)next_ys[y1][x1].size()){\n        assert(islower(field[y1][x1]));\n        int yy = next_ys[y1][x1][i];\n        int xx = next_xs[y1][x1][i];\n        assert(isupper(field[yy][xx]));\n        if(yy >= y2 or xx >= x2) continue;\n\n        int cur = 1;\n        if(is_valid(y1 + 1, x1, yy, xx + 1)){ // vv\n            chmax(cur, 1 + rec(y1 + 1, x1, yy, xx + 1));\n        }\n        if(is_valid(y1 + 1, x1, yy + 1, xx)){ // v>\n            chmax(cur, 1 + rec(y1 + 1, x1, yy + 1, xx));\n        }\n        if(is_valid(y1, x1 + 1, yy, xx + 1)){ // >v\n            chmax(cur, 1 + rec(y1, x1 + 1, yy, xx + 1));\n        }\n        if(is_valid(y1, x1 + 1, yy + 1, xx)){ // >>\n            chmax(cur, 1 + rec(y1, x1 + 1, yy + 1, xx));\n        }\n\n        if(is_valid(yy, xx, y2, x2)) chmax(ret, cur + rec(yy, xx, y2, x2)); // ??v\n    }\n\n    return ret;\n}\n\nvector<vi> used;\nvoid dfs(int y, int x, int oy, int ox){\n    used[y][x] = true;\n    ok[oy][ox][y + 1][x + 1] = true;\n    if(islower(field[oy][ox]) and field[y][x] - 'A' + 'a' == field[oy][ox]){\n        next_ys[oy][ox].emplace_back(y);\n        next_xs[oy][ox].emplace_back(x);\n    }\n\n    rep(i, 2){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n\n        if(0 <= ny and ny < h and 0 <= nx and nx < w and field[ny][nx] != '#' and not used[ny][nx]) dfs(ny, nx, oy, ox);\n    }\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        cin >> h >> w;\n        if(h == 0 and w == 0) break;\n\n        field = vector<string>(h);\n        for(auto& e : field) cin >> e;\n\n        rep(y1, N) rep(x1, N) rep(y2, N + 1) rep(x2, N + 1) memo[y1][x1][y2][x2] = -2;\n        rep(y1, N + 1) rep(x1, N + 1) rep(y2, N + 1) rep(x2, N + 1) ok[y1][x1][y2][x2] = false;\n        rep(y, h) rep(x, w){\n            next_xs[y][x] = vi(); next_ys[y][x] = vi();\n            if(field[y][x] == '#') continue;\n            used = vector<vi>(h, vi(w));\n            dfs(y, x, y, x);\n        }\n        cout << rec(0, 0, h, w) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint H, W;\nchar map[55][55];\nint memo[55][55][55][55];\nvector<P> vec[26];\n\nint calc(int sx, int sy, int tx, int ty)\n{\n\tif(memo[sx][sy][tx][ty] != -2) return memo[sx][sy][tx][ty];\n\tif(sx > tx || sy > ty) return -1;\n\tif(sx == tx && sy == ty) return 0;\n\t\n\tint ret = -1, res, res2;\n\tif(sx < W && map[sx+1][sy] != '#'){\n\t\tret = max(ret, calc(sx+1, sy, tx, ty));\n\t\tif(map[sx+1][sy] >= 'a' || map[sx+1][sy] <= 'z'){\n\t\t\tint idx = map[sx+1][sy] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx+1, sy, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\tif(sy < H && map[sx][sy+1] != '#'){\n\t\tret = max(ret, calc(sx, sy+1, tx, ty));\n\t\tif(map[sx][sy+1] >= 'a' || map[sx][sy+1] <= 'z'){\n\t\t\tint idx = map[sx][sy+1] - 'a';\n\t\t\tfor(int i = 0; i < vec[idx].size(); i++){\n\t\t\t\tres = calc(sx, sy+1, vec[idx][i].first, vec[idx][i].second);\n\t\t\t\tif(res == -1) continue;\n\t\t\t\tres2 = calc(vec[idx][i].first, vec[idx][i].second, tx, ty);\n\t\t\t\tif(res2 == -1) continue;\n\t\t\t\tret = max(ret, res + res2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(map[sx][sy] - 'a' + 'A' == map[tx][ty] && ret != -1) ret++;\n\treturn memo[sx][sy][tx][ty] = ret;\n}\n\nint main(void)\n{\n\tint cnt = 0;\n\twhile(1){\n\t\tif(++cnt > 5) return 0;\n\t\tcin >> H >> W;\n\t\tif(H == 0 && W == 0) break;\n\t\t\n\t\tfor(int i = 0; i < 26; i++) vec[i].clear();\n\t\tfor(int y = 1; y <= H; y++){\n\t\t\tfor(int x = 1; x <= W; x++){\n\t\t\t\tcin >> map[x][y];\n\t\t\t\tif(map[x][y] >= 'A' && map[x][y] <= 'Z'){\n\t\t\t\t\tvec[map[x][y] - 'A'].push_back(make_pair(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap[0][1] = '.';\n\t\tmap[0][2] = '#';\n\t\t\n\t\tfor(int sx = 0; sx <= W; sx++){\n\t\t\tfor(int sy = 1; sy <= H; sy++){\n\t\t\t\tfor(int tx = 1; tx <= W; tx++){\n\t\t\t\t\tfor(int ty = 1; ty <= H; ty++){\n\t\t\t\t\t\tmemo[sx][sy][tx][ty] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << calc(0, 1, W, H) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (top == bottom && left == right) return 0;\n\tif (!valid(top, left, h, w) || !valid(bottom, right, h, w)) return 0;\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint res = max(solve(top + 1, left, bottom, right), solve(top, left + 1, bottom, right));\n\tif (islower(fld[top][left]))\n\t{\n\t\tint match = is_pair(fld[top][left], fld[bottom][right]);\n\t\tif (match)\n\t\t{\n\t\t\tres++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t\t{\n\t\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, solve(top, left, i, j) + solve(i, j, bottom, right));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tFOR(i, top, bottom+1)FOR(j, left, right+1)\n\t{\n\t\tif (!islower(fld[i][j]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\tint c = fld[i][j] - 'a';\n\t\tFOR(k, i, bottom+1)FOR(l, j, right+1) \n\t\t{\n\t\t\tif (fld[k][l] != 'A' + c || !edge[i][j][k][l] || !edge[i][j][bottom][right]) continue;\n\t\t\tchmax(res, tmp + solve(top, left, i, j) + solve(i, j, k, l) + solve(k, l, bottom, right));\n\t\t}\n\t}*/\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t//int a = is_pair(fld[0][0], fld[h - 1][w - 1]);\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint H,W;\nstring s[50];\nint memo[50][50][50][50];\nbool vis[50][50][50][50];\nint dx[3]={1,0,0},dy[3]={0,1,0};\ninline bool is(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&s[x][y]!='#';\n}\nint rec(int a,int b,int c,int d){\t//(a,b)->(c,d)\n\tif(!is(a,b)||!is(c,d)||a>c||b>d) return -1;\n\tif(vis[a][b][c][d]) return memo[a][b][c][d];\n\tvis[a][b][c][d]=1;\n\tint &val=memo[a][b][c][d];\n\tif(c+d-b-a==0){\n\t\treturn val=0;\n\t}\n\tif(c+d-b-a==1){\n\t\tif(s[a][b]-'a'==s[c][d]-'A') return val=1;\n\t\telse return val=0;\n\t}\n\trep(di,3) rep(dj,3){\n\t\tif(di==2&&dj==2) continue;\n\t\tint na=a+dx[di],nb=b+dy[di],nc=c-dx[dj],nd=d-dy[dj];\n\t\tint bo=0;\n\t\tif(s[a][b]-'a'==s[c][d]-'A'&&di!=2&&dj!=2) bo=1;\n\t\tint tmp=rec(na,nb,nc,nd);\n\t\tif(tmp>=0) chmax(val,tmp+bo);\n\t}\n\treturn val;\n}\nint main(){\n\twhile(true){\n\t\tcin>>H>>W;\n\t\tif(H==0) break;\n\t\trep(i,H) cin>>s[i];\n\t\trep(a,H) rep(b,W) rep(c,H) rep(d,W) memo[a][b][c][d]=-1,vis[a][b][c][d]=0;\n\t\tint tmp=rec(0,0,H-1,W-1);\n\t\tif(tmp<0){\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint dp[100][100]={};\n\t\trep(i,H) rep(j,W) dp[i][j]=-1;\n\t\tdp[0][0]=0;\n\t\trep(i,H) rep(j,W){\n\t\t\tif(dp[i][j]<0) continue;\n\t\t\tfor(int x=i;x<H;x++) for(int y=j;y<W;y++){\n\t\t\t\tif(x==i&&y==j) continue;\n\t\t\t\tif(memo[i][j][x][y]<0) continue;\n\t\t\t\tchmax(dp[x][y],dp[i][j]+memo[i][j][x][y]);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[H-1][W-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nint h,w;\nint dp[55][55][55][55];\nstring s[55];\nvector<P> nxt[55][55];\n\nint dfs(int i1,int j1,int i2,int j2){\n\n  if(s[i1][j1]=='#')return -INF;\n  if(i1==i2&&j1==j2)return 0;\n  if(dp[i1][j1][i2][j2]!=-1)return dp[i1][j1][i2][j2];\n\n  if((i1+1==i2&&j1==j2)||(i1==i2&&j1+1==j2)){\n    if('a'<=s[i1][j1]&&s[i1][j1]<='z'&&s[i1][j1]-'a'==s[i2][j2]-'A')return 1;\n    else return 0;\n  }\n\n  int res=-INF;\n  if(i1<i2)maxch(res,dfs(i1+1,j1,i2,j2));\n  if(j1<j2)maxch(res,dfs(i1,j1+1,i2,j2));\n\n  if('a'<=s[i1][j1]&&s[i1][j1]<='z'){\n    if('A'<=s[i2][j2]&&s[i2][j2]<='Z'&&s[i2][j2]-'A'==s[i1][j1]-'a'){\n      rep(d1,2){\n        rep(d2,2){\n          int ni1,nj1,ni2,nj2;\n          if(d1==0){\n            ni1=i1; nj1=j1+1;\n          }else{\n            ni1=i1+1; nj1=j1;\n          }\n          if(d2==0){\n            ni2=i2; nj2=j2-1;\n          }else{\n            ni2=i2-1; nj2=j2;\n          }\n          if(ni1<=ni2&&nj1<=nj2){\n            int v1=dfs(ni1,nj1,ni2,nj2);\n            if(v1!=-INF)maxch(res,v1+1);\n          }\n        }\n      }\n    }\n    for(P p : nxt[i1][j1]){\n      if(!(p.fi<=i2&&p.se<=j2))continue;\n      if(p.fi==i2&&p.se==j2)continue;\n      int v1=dfs(i1,j1,p.fi,p.se);\n      int v2=dfs(p.fi,p.se,i2,j2);\n      if(v1!=-INF&&v2!=-INF)maxch(res,v1+v2);\n    }\n  }\n\n  return dp[i1][j1][i2][j2]=res;\n}\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0)break;\n    rep(i,h)cin>>s[i];\n\n    rep(i,h)rep(j,w){\n      nxt[i][j].clear();\n      if('a'<=s[i][j]&&s[i][j]<='z'){\n        repl(k,i,h)repl(l,j,w){\n          if('A'<=s[k][l]&&s[k][l]<='Z'&&s[k][l]-'A'==s[i][j]-'a'){\n            nxt[i][j].push_back(P(k,l));\n          }\n        }\n      }\n    }\n\n    rep(i,h)rep(j,w)rep(k,h)rep(l,w)dp[i][j][k][l]=-1;\n\n    int res=dfs(0,0,h-1,w-1);\n    if(res==-INF)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint H,W,C;\nint INF=1e8;\n\nvector<int> Gy,Gx;\nchar t[60][60];\nint dp[50][50][50][50];\n\nint dfs(int ay,int ax,int by,int bx){\n  if(ay<0||ax<0||by<0||bx<0)return -INF;\n  if(ay>=H||ax>=W||by>=H||bx>=W)return -INF;\n  if(by<ay||bx<ax)return -INF;\n  if(t[ay][ax]=='#'||t[by][bx]=='#')return -INF;\n  if(ay==by&&ax==bx)return 0;\n\n  if(dp[ay][ax][by][bx]!=-1)return dp[ay][ax][by][bx];\n  int res=-INF;\n  \n  if('a'<=t[ay][ax]&&t[ay][ax]<='z'&&t[ay][ax]-'a'+'A'==t[by][bx]){\n    if( (by-ay) + (bx-ax) == 1 )res=max(res,1);\n    res=max(res,dfs(ay+1,ax,by-1,bx)+1);\n    res=max(res,dfs(ay+1,ax,by,bx-1)+1);\n    res=max(res,dfs(ay,ax+1,by-1,bx)+1);\n    res=max(res,dfs(ay,ax+1,by,bx-1)+1);\n  }\n  \n  res=max(res,dfs(ay+1,ax,by,bx));\n  res=max(res,dfs(ay,ax+1,by,bx));\n    \n  for(int i=0;i<(int)Gy.size();i++){\n    int y=Gy[i],x=Gx[i];\n    if(y==ay&&x==ax)continue;\n    if(y==by&&x==bx)continue;\n    \n    if(ay<=y && y<=by)\n      if(ax<=x && x<=bx)\n        res=max(res,dfs(ay,ax,y,x)+dfs(y,x,by,bx));\n  }\n\n  return dp[ay][ax][by][bx]=res;\n}\n\nint main(){\n  while(1){\n    cin>>H>>W;\n    if(H==0&&W==0)break;\n    Gy.clear();\n    Gx.clear();\n    memset( dp , -1 , sizeof(dp) );\n    for(int i=0;i<H;i++){\n      scanf(\"%s\",t[i]);\n      for(int j=0;j<W;j++){\n        if('A'<=t[i][j]&&t[i][j]<='Z'){\n          Gy.push_back(i);\n          Gx.push_back(j);\n        }\n      }\n    }\n    cout<< max(-1,dfs(0,0,H-1,W-1)) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 55\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint h, w;\n\nstring s[N];\n\n\nbool check(int y1,int x1,int y2,int x2){\n  \n  queue<P> q;\n\n  bool used[N][N];\n\n  memset(used,0,sizeof(used));\n\n  q.push(P(y1,x1));\n  \n  while(!q.empty()){\n\n    P t=q.front(); q.pop();\n\n    int y = t.first, x = t.second;\n\n    if(s[y][x]=='#') continue;\n    \n    if(used[y][x]) continue;\n    \n    used[y][x] = true;\n    \n    if(y + 1 < h) q.push(P(y+1,x));\n    \n    if(x + 1 < w) q.push(P(y,x+1));\n    \n  }\n\n  return used[y2][x2];\n}\n\n\nvector<P2> rec;\n\nvoid addrec(){\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n\n      if(!('a'<=s[i][j]&&s[i][j]<='z')) continue;\n      \n      for(int k=i;k<h;k++)\n\tfor(int l=j;l<w;l++)\n\n\t  if(s[k][l]=='A'+s[i][j]-'a'&&check(i,j,k,l))\n\t    if(check(0,0,i,j)&&check(k,l,h-1,w-1))\n\t      rec.push_back(P2(P(i,j),P(k,l)));\n      \n    }\n  \n}\n\n\nint dp[1005][N][N];\nbool used[1005][N][N];\n\nvoid dfs(int num,int y,int x){\n\n  if(used[num][y][x]) return;\n  \n  used[num][y][x]=true;\n  \n  int y1 = rec[num].first.first, x1 = rec[num].first.second;\n  \n  int y2 = rec[num].second.first, x2 = rec[num].second.second;\n  \n  if(!check(y2,x2,y,x)) return;\n  \n  dp[num][y][x]=0;\n\n  int res1=0, res2=0;\n  \n  for(int i=0;i<rec.size();i++){\n\n    int sy, sx, gy, gx;\n\n    sy = rec[i].first.first;\n    sx = rec[i].first.second;\n    gy = rec[i].second.first;\n    gx = rec[i].second.second;\n\n    if(num==i) continue;\n    \n    if(y1<=sy&&x1<=sx&&gy<=y2&&gx<=x2){\n      if(!(y1==sy&&x1==sx)&&!(gy==y2&&gx==x2)){\n\tdfs(i,y2,x2);\n\tres1=max(res1,dp[i][y2][x2]);\n      }\n    }\n    \n    if(y2<=sy&&x2<=sx&&gy<=y&&gx<=x){\n      if(!(y2==sy&&x2==sx)){\n\tdfs(i,y,x);\n\tres2=max(res2,dp[i][y][x]);\n      }\n    }\n    \n  }\n  \n  dp[num][y][x]=res1+res2+1;\n  \n}\n\n\nint main(){\n  \n  \n  while(1){\n    \n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    addrec();\n\n    for(int i=0;i<rec.size();i++) dfs(i,h-1,w-1);\n\n    int ans=-1;\n    \n    for(int i=0;i<rec.size();i++) ans=max(ans,dp[i][h-1][w-1]);\n\n    if(ans==-1&&check(0,0,h-1,w-1)) ans=0;\n    \n    cout<<ans<<endl;\n    \n    rec.clear();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nvector<vector<vector<P> > >v;\nint dp[51][51][51][51];\nstring s[51];\nint h,w;\nint dfs(int ly,int lx,int ry,int rx){\n\n  int res=-1;\n\n  if(ly<0||ry<0||ly>=h||ry>=h)return -1;\n  if(lx<0||rx<0||lx>=w||rx>=w)return -1;\n  if(s[ly][lx]=='#'||s[ry][rx]=='#')return -1;\n  if(ly>=ry&&lx>=rx)return 0;\n  if(dp[ly][lx][ry][rx]!=-1e8)return dp[ly][lx][ry][rx];\n\n  res=max(res,dfs(ly+1,lx,ry,rx));\n  res=max(res,dfs(ly,lx+1,ry,rx));\n  res=max(res,dfs(ly,lx,ry-1,rx));\n  res=max(res,dfs(ly,lx,ry,rx-1));\n\n  if(islower(s[ly][lx])){\n\n    if(isupper(s[ry][rx])&&s[ly][lx]==tolower(s[ry][rx])){\n      res=max(res,dfs(ly+1,lx,ry-1,rx)+1);\n      res=max(res,dfs(ly,lx+1,ry-1,rx)+1);\n      res=max(res,dfs(ly+1,lx,ry,rx-1)+1);\n      res=max(res,dfs(ly,lx+1,ry,rx-1)+1);\n    }\n\n    else r(i,v[ly][lx].size()){\n      int y=v[ly][lx][i].first;\n      int x=v[ly][lx][i].second;\n      if(!(ly<=y&&y<=ry&&lx<=x&&x<=rx))continue;\n      res=max(res,dfs(ly,lx,y,x)+dfs(y,x,ry,rx));\n    }\n\n  }\n\n  return dp[ly][lx][ry][rx]=res;\n}\nint main(){\n  while(cin>>h>>w,h){\n    r(i,51)r(j,51)r(k,51)r(l,51)dp[i][j][k][l]=-1e8;\n    v.clear();\n    v.resize(h,vector<vector<P> >(w));\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)r(y,h)r(x,w){\n      if(i<=y&&j<=x){\n        if(islower(s[i][j])&&isupper(s[y][x])){\n          if(s[i][j]==tolower(s[y][x])){\n            v[i][j].push_back(P(y,x));\n          }\n        }\n      }\n    }\n    cout<<dfs(0,0,h-1,w-1)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nvector<string> s;\nint dp[2][55][55][55][55];\nbool used[2][55][55][55][55];\nbool mv[55][55][55][55];\nvector<int> cx[2][30],cy[2][30];\ntypedef pair<int,int> P;\nvoid calc(){\n  memset(mv,0,sizeof(mv));\n  int ax[]={1,0};\n  int ay[]={0,1};\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(s[i][j]=='#') continue;\n      queue<P> q;\n      q.push(P(i,j));\n      mv[i][j][i][j]=1;\n      while(!q.empty()){\n\tP p=q.front();q.pop();\n\tint y=p.first,x=p.second;\n\tfor(int k=0;k<2;k++){\n\t  int ny=y+ay[k],nx=x+ax[k];\n\t  if(ny>=h||nx>=w) continue;\n\t  if(s[ny][nx]=='#') continue;\n\t  if(mv[i][j][ny][nx]) continue;\n\t  q.push(P(ny,nx));\n\t  mv[i][j][ny][nx]=1;\n\t}\n      }\n    }\n  }\n}\nint in(int sy,int sx,int ty,int tx,int y,int x){\n  return sy<=y&&y<=ty&&sx<=x&&x<=tx;\n}\nint dfs(int c,int sy,int sx,int ty,int tx){\n  //cout<<c<<\" \"<<sy<<\" \"<<sx<<\" \"<<ty<<\" \"<<tx<<endl;\n  if(used[c][sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx];\n  used[c][sy][sx][ty][tx]=1;\n  if(!mv[sy][sx][ty][tx]) return dp[c][sy][sx][ty][tx]=-1;\n  //if(sy==ty&&sx==tx) return dp[c][sy][sx][ty][tx]=0;\n  int res=0;\n  for(int k=0;k<26;k++){\n    for(int i=0;i<(int)cy[0][k].size();i++){\n      if(c&&sy==cy[0][k][i]&&sx==cx[0][k][i]) continue;\n      for(int j=0;j<(int)cy[1][k].size();j++){\n\tif(c&&ty==cy[1][k][j]&&tx==cx[1][k][j]) continue;\n\tif(!in(sy,sx,ty,tx,cy[0][k][i],cx[0][k][i])) continue;\n\tif(!in(sy,sx,ty,tx,cy[1][k][j],cx[1][k][j])) continue;\n\tif(!mv[sy][sx][cy[0][k][i]][cx[0][k][i]]) continue;\n\tif(!mv[cy[0][k][i]][cx[0][k][i]][cy[1][k][j]][cx[1][k][j]]) continue;\n\tif(!mv[cy[1][k][j]][cx[1][k][j]][ty][tx]) continue;\n\t//cout<<k<<endl;\n\tint tmp=0,cur;\n\tcur=dfs(0,sy,sx,cy[0][k][i],cx[0][k][i]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(1,cy[0][k][i],cx[0][k][i],cy[1][k][j],cx[1][k][j]);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tcur=dfs(0,cy[1][k][j],cx[1][k][j],ty,tx);\n\tif(cur<0) continue;\n\ttmp+=cur;\n\tres=max(res,tmp+1);\n\t//cout<<\":\"<<res<<endl;\n      }\n    }\n  }\n  //cout<<res<<endl;\n  //if(sy==ty&&sx==tx&&res) cout<<sy<<\" \"<<sx<<endl;\n  return dp[c][sy][sx][ty][tx]=res;\n}\nsigned main(){\n  while(cin>>h>>w,h){\n    s.resize(h);\n    for(int i=0;i<h;i++) cin>>s[i];\n    memset(dp,-1,sizeof(dp));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<26;i++){\n      cy[0][i].clear();\n      cy[1][i].clear();\n      cx[0][i].clear();\n      cx[1][i].clear();\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(islower(s[i][j])){\n\t  cy[0][s[i][j]-'a'].push_back(i);\n\t  cx[0][s[i][j]-'a'].push_back(j);\n\t}\n\tif(isupper(s[i][j])){\n\t  cy[1][s[i][j]-'A'].push_back(i);\n\t  cx[1][s[i][j]-'A'].push_back(j);\n\t}\n      }\n    }\n    calc();\n    cout<<dfs(0,0,0,h-1,w-1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n\n\n\n\n\n\n\nint T,n,num,m;\nchar z[55][55];\nint dp[55][55][55][55];\nint vi[55][55];\nvoid dfs(int q,int w)\n{\n    if(z[q][w]=='#')\n        return;\n    vi[q][w]=1;\n    if(q>=n||w>=m)\n        return;\n    if(vi[q+1][w]==0)\n        dfs(q+1,w);\n    if(vi[q][w+1]==0)\n        dfs(q,w+1);\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)\n            break;\n        for(int q=0;q<n;q++)\n            scanf(\"%s\",z[q]);\n        memset(dp,0,sizeof dp);\n        memset(vi,0,sizeof vi);\n        dfs(0,0);\n        if(vi[n-1][m-1]==0)\n        {\n            printf(\"-1\\n\");\n            continue;\n        }\n        for(int w=0;w<=n;w++)\n            for(int q=0;q+w<=n;q++)\n                for(int r=0;r<=m;r++)\n                    for(int e=0;e+r<=m;e++)\n                    {\n                        if(q+w>=q+1&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w][e+1][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+1)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w-1][e][e+r]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q+1][q+w][e][e+r-1]);\n                        }\n                        if(q+w>=q+2&&e+r>=e+2)\n                        {\n                            if(z[q][e]-'a'==z[q+w-1][e+r-1]-'A')\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]+1);\n                            else\n                                dp[q][q+w][e][e+r]=max(dp[q][q+w][e][e+r],dp[q][q+w-1][e+1][e+r]);\n                        }\n                        for(int t=q;t<=q+w;t++)\n                        {\n                            dp[q][w][e][r]=max(dp[q][w][e][r],dp[q][t][e][r]+dp[t][w][e][r]);\n                        }\n                        for(int t=e;t<=e+r;t++)\n                        {\n                            dp[q][w][e][r]=max(dp[q][w][e][r],dp[q][w][e][t]+dp[q][w][t][r]);\n                        }\n                        // printf(\"%d %d %d %d %d\\n\",q,q+w,e,e+r,dp[q][q+w][e][e+r]);\n                    }\n\n                    // for(int q=0;q<=n;q++)\n\n\n                    printf(\"%d\\n\",dp[0][n][0][m]);\n    }\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint dp[52][52][52][52];\nint dp2[52][52][52][52];\nint h,w;\n\nint saiki(int x1,int y1,int x2,int y2,vector<string> &v){\n\tif(x1>x2||y1>y2)return -10000;\n\tif(v[x1][y1]=='#'||v[x2][y2]=='#')return -10000;\n\tif(dp[x1][y1][x2][y2]!=-10000){\n\t\treturn dp[x1][y1][x2][y2];\n\t}\n\tif(x1==x2&&y1==y2)return dp[x1][y1][x2][y2] = 0;\n\tif(x2-x1==1&&y2-y1==0){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tif(x2-x1==0&&y2-y1==1){\n\t\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\t\treturn dp[x1][y1][x2][y2]=1;\n\t\t}\n\t\treturn dp[x1][y1][x2][y2] = 0;\n\t}\n\tint tmp = -100;\n\tif(v[x1][y1]+'A'-'a'==v[x2][y2]&&v[x1][y1]!='.'){\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1+1,y1,x2,y2-1,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2-1,y2,v));\n\t\ttmp = max(tmp,1+saiki(x1,y1+1,x2,y2-1,v));\n\t}\n\ttmp = max(tmp,saiki(x1+1,y1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1+1,x2,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2-1,y2,v));\n\ttmp = max(tmp,saiki(x1,y1,x2,y2-1,v));\n\tif(tmp>=0){\n\t\treturn dp[x1][y1][x2][y2] = tmp;\n\t}\n\treturn dp[x1][y1][x2][y2] = -10000;\n}\n\nint saiki2(int x1,int y1,int x2,int y2){\n\tif(x1==x2&&y1==y2)return dp2[x1][y1][x2][y2]=0;\n\tif(dp2[x1][y1][x2][y2]!=-10000)return dp2[x1][y1][x2][y2];\n\tint mx = -10000;\n\tfor(int i=x1;i<=x2;i++){\n\t\tfor(int j=y1;j<=y2;j++){\n\t\t\tif(i==x1&&j==y1)continue;\n\t\t\tmx = max(mx,dp[x1][y1][i][j]+saiki2(i,j,x2,y2));\n\t\t}\n\t}\n\treturn dp2[x1][y1][x2][y2] = mx;\n\n}\n\nint main() {\n   \twhile(cin >> h >> w && h!=0){\n   \t\tvector<string> v(h);\n   \t\trep(i,h){\n   \t\t\tcin >> v[i];\n   \t\t}\n\t\trep(i,51){\n\t\t\trep(j,51){\n\t\t\t\trep(k,51){\n\t\t\t\t\trep(l,51){\n\t\t\t\t\t\tdp[i][j][k][l] = -10000;\n\t\t\t\t\t\tdp2[i][j][k][l] = -10000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}   \t\t\n\t\tint ans = saiki(0,0,h-1,w-1,v);\n\t\tans = saiki2(0,0,h-1,w-1);\n\t\tif(ans>=0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tcout << -1 << endl;\n\t\t}\n   \t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 55\n\nconst int INF = (int)1e9;\n\nbool adj[N][N][N][N];\nint f[N][N][N][N];\nchar mat[N][N];\nint n, m;\nvector<pair<int, int> > vec[26];\n\nbool ok(int x, int y) {\n\treturn x >= 0 && x < n && y >= 0 && y < m && mat[x][y] != '#';\n}\n\nint dfs(int lx, int ly, int rx, int ry) {\n\tif (f[lx][ly][rx][ry] != -1) return f[lx][ly][rx][ry];\n\tif (lx > rx || ly > ry) {\n\t\treturn f[lx][ly][rx][ry] = 0;\n\t}\n\tif (!adj[lx][ly][rx][ry]) {\n\t\treturn f[lx][ly][rx][ry] = -INF;\n\t}\t\t\n\n\tint res = 0;\n\n\tif (mat[lx][ly] >= 'a' && mat[lx][ly] <= 'z') {\n\t\tint id = mat[lx][ly] - 'a';\n\t\t\n\t\tfor (int i = 0; i < vec[id].size(); i++) {\n\t\t\tint x = vec[id][i].first, y = vec[id][i].second;\n\n\t\t\tif (!adj[lx][ly][x][y]) continue;\n\n\t\t\tif (x >= lx && x <= rx && y >= ly && y <= ry) {\n\t\t\t\tif (ok(lx + 1, ly)) {\n\t\t\t\t\tif (ok(x - 1, y)) {\n\t\t\t\t\t\tres = max(res, dfs(lx + 1, ly, x - 1, y) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t\tif (ok(x, y - 1)) {\n\t\t\t\t\t\tres = max(res, dfs(lx + 1, ly, x, y - 1) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ok(lx, ly + 1)) {\n\t\t\t\t\tif (ok(x - 1, y)) {\n\t\t\t\t\t\tres = max(res, dfs(lx, ly + 1, x - 1, y) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t\tif (ok(x, y - 1)) {\n\t\t\t\t\t\tres = max(res, dfs(lx, ly + 1, x, y - 1) + 1 + dfs(x, y, rx, ry));\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\t\t\t\n\n\t\t\t/*\n\t\t\tif (lx == 1 && ly == 1 && rx == 4 && ry == 4) {\n\t\t\t\tcout << \"here\" << endl;\n\t\t\t\tcout << res << endl;\n\t\t\t\tcout << id << endl;\n\t\t\t\tcout << x << ' ' << y << endl;\n\t\t\t}*/\n\t\t}\t\t\n\n\n\t}\n\n\n\tif (ok(lx + 1, ly)) {\n\t\tres = max(res, dfs(lx + 1, ly, rx, ry));\t\t\n\t}\t\n\tif (ok(lx, ly + 1)) {\n\t\tres = max(res, dfs(lx, ly + 1, rx, ry));\n\t}\n\n\treturn f[lx][ly][rx][ry] = res;\n}\n\nint main() {\n\twhile (~scanf(\"%d%d\", &n, &m)) {\n\t\tif (n + m == 0) break;\n\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tvec[i].clear();\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", mat[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (mat[i][j] >= 'A' && mat[i][j] <= 'Z') {\n\t\t\t\t\tint id = mat[i][j] - 'A';\n\t\t\t\t\tvec[id].push_back(make_pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(adj, 0, sizeof(adj));\n\t\tmemset(f, -1, sizeof(f));\n\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = m - 1; j >= 0; j--) {\n\n\t\t\t\tif (mat[i][j] == '#') continue;\n\n\t\t\t\tfor (int x = i; x < n; x++) {\n\t\t\t\t\tfor (int y = j; y < m; y++) {\n\t\t\t\t\t\tif (ok(i + 1, j)) {\n\t\t\t\t\t\t\tadj[i][j][x][y] |= adj[i + 1][j][x][y];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ok(i, j + 1)) {\n\t\t\t\t\t\t\tadj[i][j][x][y] |= adj[i][j + 1][x][y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadj[i][j][i][j] = 1;\t\t\n\t\t\t}\n\t\t}\t\n\n\t\tint res = dfs(0, 0, n - 1, m - 1);\n\n\t\t/*\n\n\t\tfor (int x = 0; x < n; x++) {\n\t\t\tfor (int y = 0; y < m; y++) {\n\t\t\t\tfor (int i = x; i < n; i++) {\n\t\t\t\t\tfor (int j = y; j < m; j++) {\n\t\t\t\t\t\tif (f[x][y][i][j] == 1) {\n\t\t\t\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\t\t\t\tcout << x << ' ' << y << endl;\n\t\t\t\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (res == -INF)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\n\nstring s[N];\nint h, w, dp[N][N][N][N];\nbool used[N][N][N][N];\n\nbool check(char A, char B){\n  return 'a'<=A&&A<='z'&&toupper(A)==B;\n}\n\nvoid dfs(int y1, int x1, int y2, int x2){\n\n  if(used[y1][x1][y2][x2]) return;\n\n  used[y1][x1][y2][x2]=true;\n  \n  if(y1==y2&&x1==x2){\n    if(s[y1][x1]!='#') dp[y1][x1][y2][x2]=0;\n    return ;\n  }\n  \n  if(dp[y1][x1][y2][x2]!=-1) return ;\n  if(s[y1][x1]=='#'||s[y2][x2]=='#') return ;\n  \n  for(int y=y1;y<=y2;y++){\n    \n    for(int x=x1;x<=x2;x++){\n      \n      dfs(y1,x1,y,x);\n      \n      if(dp[y1][x1][y][x]==-1) continue;\n\n      if(y+1<=y2) dfs(y+1,x,y2,x2);\n      \n      if(y+1<=y2&&dp[y+1][x][y2][x2]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1][x1][y][x]+dp[y+1][x][y2][x2]);\n\n      if(x+1<=x2) dfs(y,x+1,y2,x2);\n      \n      if(x+1<=x2&&dp[y][x+1][y2][x2]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1][x1][y][x]+dp[y][x+1][y2][x2]);\n\n    }\n    \n  }\n\n  int cost=0;\n\n  if(check(s[y1][x1],s[y2][x2])) cost=1;\n  \n  if(y1==y2){\n    if(x1+1==x2) dp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],cost);\n    else{\n      \n      dfs(y1,x1+1,y2,x2-1);\n\n      if(dp[y1][x1+1][y2][x2-1]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1][x1+1][y2][x2-1]+cost);\n      \n    }\n  }\n  else if(x1==x2){\n    if(y1+1==y2) dp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],cost);\n    else{\n      \n      dfs(y1+1,x1,y2-1,x2);\n      \n      if(dp[y1+1][x1][y2-1][x2]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1+1][x1][y2-1][x2]+cost);\n      \n    }\n  }\n  else{\n    \n    dfs(y1+1,x1,y2,x2-1);\n    \n    if(dp[y1+1][x1][y2][x2-1]!=-1)\n      dp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1+1][x1][y2][x2-1]+cost);\n    \n    dfs(y1,x1+1,y2-1,x2);\n    \n    if(dp[y1][x1+1][y2-1][x2]!=-1)\n      dp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1][x1+1][y2-1][x2]+cost);\n\n    if(y2-y1>=2){\n      \n      dfs(y1+1,x1,y2-1,x2);\n    \n      if(dp[y1+1][x1][y2-1][x2]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1+1][x1][y2-1][x2]+cost);\n      \n    }\n\n    if(x2-x1>=2){\n      \n      dfs(y1,x1+1,y2,x2-1);\n    \n      if(dp[y1][x1+1][y2][x2-1]!=-1)\n\tdp[y1][x1][y2][x2]=max(dp[y1][x1][y2][x2],dp[y1][x1+1][y2][x2-1]+cost);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n\n    cin>>h>>w;\n    if(!h&&!w) break;\n    \n    for(int i=0;i<h;i++) cin>>s[i];\n    \n    memset(dp,-1,sizeof(dp));\n\n    memset(used,0,sizeof(used));\n    \n    dfs(0,0,h-1,w-1);\n    \n    cout<<dp[0][0][h-1][w-1]<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 260;\nconst int K = 555;\nint ok[K][K];\nvector<int> G[K];\n\nint id[55][55];\nchar field[55][55];\nint visit[55][55];\n\nchar ch[K];\nint dp[K][K][2][2];\nvector<int> ord;\n\ninline int check(int c1, int c2){\n\treturn ch[c1] - 'a' == ch[c2] - 'A';\n}\n\nint rec(int l, int r, int a, int b){\n\tif (r - l <= 1) return !a && !b && check(ord[l], ord[r]);\n\tint &res = dp[l][r][a][b];\n\tif (res + 1) return res;\n\tres = 0;\n\n\tif (!a && !b && check(ord[l], ord[r])){\n\t\tres = 1 + rec(l, r, 1, 1);\n\t}\n\n\tfor (int k = l + 1; k < r; ++k){\n\t\tif (ok[ord[l]][ord[k]] && ok[ord[k]][ord[r]]){\n\t\t\tres = max(res, rec(l, k, a, 1) + rec(k, r, 0, b));\n\t\t\tres = max(res, rec(l, k, a, 0) + rec(k, r, 1, b));\n\t\t}\n\t}\n\treturn res;\n}\n\nint h, w;\nvoid dfs(int r, int c, int v){\n\tvisit[r][c] = 1;\n\trep(i, 2){\n\t\tint nr = r + i, nc = c + !i;\n\t\tif (nr < 0 || nc < 0 || nr >= h || nc >= w) continue;\n\t\tif (field[nr][nc] == '#') continue;\n\t\tif (visit[nr][nc]) continue;\n\t\tif (id[nr][nc] >= 0){\n\t\t\tG[v].push_back(id[nr][nc]);\n\t\t\tok[v][id[nr][nc]] = 1;\n\t\t}\n\t\tdfs(nr, nc, v);\n\t}\n}\n\nvoid tdfs(int v, vector<int> &visit, vector<int> &res){\n\tvisit[v] = 1;\n\tfor (auto to : G[v]){\n\t\tif (visit[to]) continue;\n\t\ttdfs(to, visit, res);\n\t}\n\tres.push_back(v);\n}\n\nvector<int> tsort(int n){\n\tvector<int> vis(n), res;\n\trep(i, n) if(!vis[i]) tdfs(i, vis, res);\n\treverse(ALL(res));\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\twhile (cin >> h >> w, h){\n\t\trep(i, h) cin >> field[i];\n\t\trep(i, w) field[h][i] = \"#.\"[i == w - 1];\n\t\t++h;\n\n\t\tMEMSET(id, -1);\n\t\tMEMSET(ch, 0);\n\t\tint num = 0;\n\t\trep(i, h) rep(j, w){\n\t\t\tif (isupper(field[i][j]) || islower(field[i][j])){\n\t\t\t\tch[num] = field[i][j];\n\t\t\t\tid[i][j] = num++;\n\t\t\t}\n\t\t}\n\t\tint SRC = num++;\n\t\tint SNK = num++;\n\t\tid[h - 1][w - 1] = SNK;\n\n\t\tMEMSET(visit, 0);\n\t\tMEMSET(ok, 0);\n\t\trep(i, num) G[i].clear();\n\t\tdfs(0, -1, SRC);\n\t\trep(i, h) rep(j, w) if (!visit[i][j]) field[i][j] = '#';\n\t\trep(i, h) rep(j, w){\n\t\t\tif (id[i][j] >= 0){\n\t\t\t\tMEMSET(visit, 0);\n\t\t\t\tdfs(i, j, id[i][j]);\n\t\t\t}\n\t\t}\n\n\t\tif (!ok[SRC][SNK]){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tord = tsort(num);\n\t\tMEMSET(dp, -1);\n\n\t\tint r = -1;\n\t\trep(i, num) if (ord[i] == SNK) r = i;\n\n\t\tcout << rec(0, r, 0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint hang,lie;\nchar tu[55][55];\nint f[55][55][55][55];\nint dfs(int x1,int y1,int x2,int y2)\n{\n    if (f[x1][y1][x2][y2]!=-1) return f[x1][y1][x2][y2];\n    if (x1>=hang || y1>=lie || x2<0 || y2<0 ||tu[x1][y1]=='#'||tu[x2][y2]=='#') return f[x1][y1][x2][y2]=-99999999;\n    if ((x1==x2 && y1==y2)||(x1>x2)||(y1>y2)) return f[x1][y1][x2][y2]=0;\n    int ans=-1;\n    if (x2>x1)\n    {\n        ans=max(ans,dfs(x1,y1,x2-1,y2));\n        ans=max(ans,dfs(x1+1,y1,x2,y2));\n    }\n    if (y2>y1)\n    {\n        ans=max(ans,dfs(x1,y1+1,x2,y2));\n        ans=max(ans,dfs(x1,y1,x2,y2-1));\n    }\n    if (tu[x1][y1]-'a'==tu[x2][y2]-'A')\n    {\n        ans=max(ans,dfs(x1+1,y1,x2-1,y2)+1);\n        ans=max(ans,dfs(x1+1,y1,x2,y2-1)+1);\n        ans=max(ans,dfs(x1,y1+1,x2-1,y2)+1);\n        ans=max(ans,dfs(x1,y1+1,x2,y2-1)+1);\n    }\n    return f[x1][y1][x2][y2]=ans;\n}\nint d[55][55];\nint dp(int x1,int y1)\n{\n    if (d[x1][y1]!=-1) return d[x1][y1];\n    if (x1>=hang|| y1>=lie || tu[x1][y1]=='#') return d[x1][y1]=-99999999;\n    d[x1][y1]=max(d[x1][y1],max(dp(x1+1,y1),dp(x1,y1+1)));\n    if (tu[x1][y1]>='a' && tu[x1][y1]<='z')\n    {\n        for (int g=x1; g<hang; g++)\n        {\n            for (int h=y1; h<lie; h++)\n            {\n                if (tu[x1][y1]-'a'==tu[g][h]-'A')\n                {\n                    d[x1][y1]=max(d[x1][y1],f[x1][y1][g][h]+dp(g,h));\n                }\n            }\n        }\n    }\n    return d[x1][y1];\n\n}\nint main()\n{\n    while (scanf(\"%d%d\",&hang,&lie) && hang)\n    {\n        for (int j=0; j<hang; j++) scanf(\"%s\",tu[j]);\n        memset(f,-1,sizeof(int)*55*55*55*55);\n        memset(d,-1,sizeof(int)*55*55);\n        int ha=dfs(0,0,hang-1,lie-1);\n        if (ha<0) printf(\"-1\\n\");\n        else\n        {\n            d[hang-1][lie-1]=0;\n            //printf(\"%d\\n\",dp(0,0));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    const int INF = INT_MAX / 4;\n\n    const int MAX_H = 50;\n    const int MAX_W = 50;\n\n    int H, W;\n    vector<string> F;\n    bool input() {\n        cin >> H >> W;\n        if (H == 0 && W == 0) return false;\n        F.clear(); F.resize(H); cin >> F;\n        return true;\n    }\n\n    const int dy[] = {0, 1};\n    const int dx[] = {1, 0};\n\n    int G[MAX_H][MAX_W][MAX_H][MAX_W];\n    bool R[MAX_H][MAX_W][MAX_H][MAX_W];\n\n    void dfs(int sy, int sx, int y, int x) {\n        R[sy][sx][y][x] = true;\n        for (int i = 0; i < 2; i++) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (F[ny][nx] == '#') continue;\n            dfs(sy, sx, ny, nx);\n        }\n    }\n\n    int f(int sy, int sx, int ty, int tx) {\n        if (sy < 0 || sy >= H || sx < 0 || sx >= W) return 0;\n        if (ty < 0 || ty >= H || tx < 0 || tx >= W) return 0;\n        if (not R[sy][sx][ty][tx]) return 0;\n        int& cache = G[sy][sx][ty][tx];\n        if (cache >= 0) return cache;\n\n        if (not islower(F[sy][sx])) {\n            return cache = max(f(sy + 1, sx, ty, tx), f(sy, sx + 1, ty, tx));\n        }\n\n        int r = 0;\n        for (int y = sy; y <= ty; y++) {\n            for (int x = sx; x <= tx; x++) {\n                if (y == ty && x == tx) continue;\n                r = max(r, f(sy, sx, y, x) + max(f(y + 1, x, ty, tx), f(y, x + 1, ty, tx)));\n            }\n        }\n\n        int d = toupper(F[sy][sx]) == F[ty][tx];\n        r = max(r, f(sy + 1, sx, ty - 1, tx) + d);\n        r = max(r, f(sy + 1, sx, ty, tx - 1) + d);\n        r = max(r, f(sy, sx + 1, ty - 1, tx) + d);\n        r = max(r, f(sy, sx + 1, ty, tx - 1) + d);\n        return cache = r;\n    }\n\n    void solve() {\n        memset(G, -1, sizeof(G));\n        memset(R, false, sizeof(R));\n\n        for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) \n            if (F[i][j] != '#') dfs(i, j, i, j);\n\n        if (not R[0][0][H - 1][W - 1]) {\n            cout << -1 << endl;\n            return;\n        }\n\n        cout << f(0, 0, H - 1, W - 1) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nint h, w;\nvs fld;\nbool edge[55][55][55][55];\nint dp[55][55][55][55];\n\nint is_pair(char c, char d)\n{\n\tif (islower(c) && isupper(d) && toupper(c) == d) return 1;\n\treturn 0;\n}\n\nint solve(int top, int left, int bottom, int right)\n{\n\tif (top == bottom && left == right) return 0;\n\tif (!valid(top, left, h, w) || !valid(bottom, right, h, w)) return 0;\n\tif (dp[top][left][bottom][right] >= 0) return dp[top][left][bottom][right];\n\tint res = 0;\n\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#') chmax(res, solve(top + 1, left, bottom, right));\n\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#') chmax(res, solve(top, left + 1, bottom, right));\n\tif (islower(fld[top][left]))\n\t{\n\t\tint match = is_pair(fld[top][left], fld[bottom][right]);\n\t\tif (match)\n\t\t{\n\t\t\tif (valid(top + 1, left, h, w) && fld[top + 1][left] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top + 1, left, bottom, right - 1) + 1);\n\t\t\t\tchmax(res, solve(top + 1, left, bottom - 1, right) + 1);\n\t\t\t}\n\t\t\tif (valid(top, left + 1, h, w) && fld[top][left + 1] != '#')\n\t\t\t{\n\t\t\t\tchmax(res, solve(top, left + 1, bottom - 1, right) + 1);\n\t\t\t\tchmax(res, solve(top, left + 1, bottom, right - 1) + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFOR(i, top, bottom + 1)FOR(j, left, right + 1)\n\t\t\t{\n\t\t\t\tif (fld[i][j] != toupper(fld[top][left]) || !edge[top][left][i][j] || !edge[i][j][bottom][right]) continue;\n\t\t\t\tchmax(res, solve(top, left, i, j) + solve(i, j, bottom, right));\n\t\t\t}\n\t\t}\n\t}/*\n\tcout << top << \" \" << left << \" \" << bottom << \" \" << right << endl;\n\tcout << res << endl;*/\n\treturn dp[top][left][bottom][right] = res;\n}\n\nint main()\n{\n\twhile (cin >> h >> w, h)\n\t{\n\t\tMS(edge, false);\n\t\tMS(dp, -1);\n\t\tfld.resize(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tqueue<pii> que;\n\t\t\tque.emplace(i, j);\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\tint x = que.front().first, y = que.front().second;\n\t\t\t\tque.pop();\n\t\t\t\tif (!edge[i][j][x + 1][y] && valid(x + 1, y, h, w) && fld[x + 1][y] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x + 1][y] = true;\n\t\t\t\t\tque.emplace(x + 1, y);\n\t\t\t\t}\n\t\t\t\tif (!edge[i][j][x][y + 1] && valid(x, y + 1, h, w) && fld[x][y + 1] != '#')\n\t\t\t\t{\n\t\t\t\t\tedge[i][j][x][y + 1] = true;\n\t\t\t\t\tque.emplace(x, y + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(h == 1 && w == 1) && !edge[0][0][h - 1][w - 1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\t//int a = is_pair(fld[0][0], fld[h - 1][w - 1]);\n\t\tcout << solve(0, 0, h-1, w-1) << endl;\n\t} \n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string.h>\n#include <map>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\nusing namespace std;\nconst int maxn=55;\nint h,w;\nchar maze[maxn][maxn];\nint ans=0;\nstruct Node{\n    int x,y;\n};\nstruct Node2{\n    int x,y;\n    int cnt;\n    char s[51*51];\n    int first;\n    bool operator <(const Node2 tmp)const{\n        return cnt<tmp.cnt;\n    }\n};\n\nbool BFS(){\n    queue<Node> q;\n    Node node,tmp;\n    node.x=0;node.y=0;\n    q.push(node);\n    while(!q.empty()){\n        tmp=q.front();\n        q.pop();\n        if(tmp.x==h-1 && tmp.y==w-1)\n            return true;\n        if(tmp.x+1<h && maze[tmp.x+1][tmp.y]!='#'){\n            node.x=tmp.x+1;\n            node.y=tmp.y;\n            q.push(node);\n        }\n        if(tmp.y+1<w &&  maze[tmp.x][tmp.y+1]!='#'){\n            node.x=tmp.x;\n            node.y=tmp.y+1;\n            q.push(node);\n        }\n    }\n    return false;\n}\n\n\nvoid BFS2(){\n    //queue<Node2> q;\n    priority_queue<Node2>q;\n    Node2 node,tmp;\n    int a,b;\n    node.x=0;\n    node.y=0;\n    node.cnt=0;\n    node.first=-1;\n    q.push(node);\n\n    if(maze[node.x][node.y]>='a' && maze[node.x][node.y]<='z'){\n        node.s[++node.first]=maze[node.x][node.y];\n        q.push(node);\n    }\n    while(!q.empty()){\n        tmp=q.top();\n        q.pop();\n//printf(\"%d %d %d %s %d\\n\",tmp.x,tmp.y,tmp.first,tmp.s,tmp.cnt);\n        if(tmp.x==h-1 && tmp.y==w-1){\n            //if(tmp.first!=-1 && tmp.s[tmp.first]==maze[tmp.x][tmp.y]){\n            //   tmp.cnt++;\n            //}\n            if(tmp.cnt>ans){\n                ans=tmp.cnt;\n            }\n            continue;\n        }\n         //蠕?ク玖オー\n        if(tmp.x+1<h && maze[tmp.x+1][tmp.y]!='#'){\n            a=tmp.x+1;\n            b=tmp.y;\n            tmp.x++;\n            q.push(tmp);\n            if(maze[a][b]>='a' && maze[a][b]<='z'){\n                tmp.s[++tmp.first]=maze[a][b];\n                q.push(tmp);\n                tmp.first--;\n            }\n            else if(maze[a][b]>='A' && maze[a][b]<='Z'){\n                if(tmp.first!=-1 && tmp.s[tmp.first]==maze[a][b]+32){\n                    tmp.first--;\n                    tmp.cnt++;\n                    q.push(tmp);\n                    tmp.first++;\n                    tmp.cnt--;\n                }\n            }\n            tmp.x--;\n        }\n        //蠕?承襍ー\n        if(tmp.y+1<w &&  maze[tmp.x][tmp.y+1]!='#'){\n            a=tmp.x;\n            b=tmp.y+1;\n            tmp.y++;\n            q.push(tmp);\n            if(maze[a][b]>='a' && maze[a][b]<='z'){\n                tmp.s[++tmp.first]=maze[a][b];\n                q.push(tmp);\n                tmp.first--;\n            }\n            else if(maze[a][b]>='A' && maze[a][b]<='Z'){\n                if(tmp.first!=-1 && tmp.s[tmp.first]==maze[a][b]+32){\n                    tmp.first--;\n                    tmp.cnt++;\n                    q.push(tmp);\n                    tmp.first++;\n                    tmp.cnt--;\n                }\n            }\n            tmp.y--;\n        }\n    }\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&h,&w)!=EOF){\n        if(h==0 && w==0)\n            break;\n        for(int i=0;i<h;i++){\n            scanf(\"%s\",maze[i]);\n        }\n        if(BFS()){\n            ans=0;\n            BFS2();\n            printf(\"%d\\n\",ans);\n        }\n        else{\n            printf(\"-1\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2538 Stack Maze\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar map[53][53];\nchar mk[53][53][53][53];\nint memo[53][53][53][53];\nchar a[53][53][11][2], hi[53][53];\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int lr, int lc, int rr, int rc)\n{\n\tint i, r, c, t, x, ans;\n\n\tif ((ans = memo[lr][lc][rr][rc]) >= 0) return ans;\n\tif (lc > rc || lr > rr) { ans = 0; goto done; }\n\tif (map[lr][lc] == '#' || map[rr][rc] == '#' ||\n\t\t!mk[lr][lc][rr][rc]) { ans = -1; goto done; }\n\n\tans = 0;\n\tfor (i = 0; i < hi[lr][lc]; i++) {\n\t\tr = a[lr][lc][i][0], c = a[lr][lc][i][1];\n\t\tif (r < lr || r > rr || c < lc || c > rc) continue;\n\t\tx = calc(r, c, rr, rc) + 1;\n\t\tt = calc(lr+1, lc, r-1, c) + x; if (t > ans) ans = t;\n\t\tt = calc(lr, lc+1, r-1, c) + x; if (t > ans) ans = t;\n\t\tt = calc(lr+1, lc, r, c-1) + x; if (t > ans) ans = t;\n\t\tt = calc(lr, lc+1, r, c-1) + x; if (t > ans) ans = t;\n\t}\n\tt = calc(lr+1, lc, rr, rc); if (t > ans) ans = t;\n\tt = calc(lr, lc+1, rr, rc); if (t > ans) ans = t;\ndone:\n\treturn memo[lr][lc][rr][rc] = ans;;\n}\n\nint main()\n{\n\tint H, W, r, c, u, v, k;\n\n\twhile (H = in()) {\n\t\tW = in();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tfor (r = 1; r <= H; r++) {\n\t\t\tfgets(map[r]+1, 53, stdin);\n\t\t\tfor (c = 1; c <= W; c++) if (map[r][c] != '#') {\n\t\t\t\tmk[r][c][r][c] = 1;\n\t\t\t\tfor (u =1 ; u <= r; u++) for (v = 1; v <= c; v++) {\n\t\t\t\t\tif (mk[u][v][r-1][c] || mk[u][v][r][c-1]) {\n\t\t\t\t\t\tmk[u][v][r][c] = 1;\n\t\t\t\t\t\tif (isupper(map[r][c]) && islower(map[u][v]) &&\n\t\t\t\t\t\t\t(map[r][c] & 0x1f) == (map[u][v] & 0x1f)) {\n\t\t\t\t\t\t\tk = hi[u][v]++;\n\t\t\t\t\t\t\ta[u][v][k][0] = r, a[u][v][k][1] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", calc(1, 1, H, W));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2538 Stack Maze\n// 2018.2.2 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar map[53][53];\nchar mk[53][53][53][53];\nint memo[53][53][53][53];\nchar a[53][53][11][2], hi[53][53];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint calc(int lr, int lc, int rr, int rc)\n{\n\tint i, r, c, t, ans;\n\n\tif ((ans = memo[lr][lc][rr][rc]) >= 0) return ans;\n\tif (lc > rc || lr > rr) { ans = 0; goto done; }\n\tif (map[lr][lc] == '#' || map[rr][rc] == '#' ||\n\t\t!mk[lr][lc][rr][rc]) { ans = -1; goto done; }\n\n\tans = 0;\n\tfor (i = 0; i < hi[lr][lc]; i++) {\n\t\tr = a[lr][lc][i][0], c = a[lr][lc][i][1];\n\t\tif (r < lr || r > rr || c < lc || c > rc) continue;\n\t\tt = calc(lr+1, lc, r-1, c) + 1 + calc(r, c, rr, rc); if (t > ans) ans = t;\n\t\tt = calc(lr, lc+1, r-1, c) + 1 + calc(r, c, rr, rc); if (t > ans) ans = t;\n\t\tt = calc(lr+1, lc, r, c-1) + 1 + calc(r, c, rr, rc); if (t > ans) ans = t;\n\t\tt = calc(lr, lc+1, r, c-1) + 1 + calc(r, c, rr, rc); if (t > ans) ans = t;\n\t}\n\tt = calc(lr+1, lc, rr, rc); if (t > ans) ans = t;\n\tt = calc(lr, lc+1, rr, rc); if (t > ans) ans = t;\ndone:\n\treturn memo[lr][lc][rr][rc] = ans;;\n}\n\nint main()\n{\n\tint H, W, r, c, u, v, k;\n\n\twhile (H = in()) {\n\t\tW = in();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tfor (r = 1; r <= H; r++) {\n\t\t\tfgets(map[r]+1, 53, stdin);\n\t\t\tfor (c = 1; c <= W; c++) if (map[r][c] != '#') {\n\t\t\t\tmk[r][c][r][c] = 1;\n\t\t\t\tfor (u =1 ; u <= r; u++) for (v = 1; v <= c; v++) {\n\t\t\t\t\tif (mk[u][v][r-1][c] || mk[u][v][r][c-1]) {\n\t\t\t\t\t\tmk[u][v][r][c] = 1;\n\t\t\t\t\t\tif (isupper(map[r][c]) && islower(map[u][v]) &&\n\t\t\t\t\t\t\t(map[r][c] & 0x1f) == (map[u][v] & 0x1f)) {\n\t\t\t\t\t\t\tk = hi[u][v]++;\n\t\t\t\t\t\t\ta[u][v][k][0] = r, a[u][v][k][1] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", calc(1, 1, H, W));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y1 = H - 1; y1 >= 0; --y1) {\n\t\t\tfor (int x1 = W - 1; x1 >= 0; --x1) {\n\t\t\t\tif (f[y1][x1] == '#') continue;\n\t\t\t\treach[y1][x1][y1][x1] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (!('a' <= v1 && v1 <= 'z')) {\n\t\t\tif (y1 < H - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tif (x1 < W - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t} else if (!('A' <= v2 && v2 <= 'Z')) {\n\t\t\tif (y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t\tif (x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t} else {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 < H - 1 && y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\tif (y1 < H - 1 && x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\tif (x1 < W - 1 && y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\tif (x1 < W - 1 && x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (x < x1) continue;\n\t\t\t\t\tif (y < H - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y + 1][x][y2][x2]);\n\t\t\t\t\tif (x < W - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x + 1][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class StackMaze {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y1 = H - 1; y1 >= 0; --y1) {\n\t\t\tfor (int x1 = W - 1; x1 >= 0; --x1) {\n\t\t\t\tif (f[y1][x1] == '#') continue;\n\t\t\t\treach[y1][x1][y1][x1] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (!('a' <= v1 && v1 <= 'z')) {\n\t\t\tif (y1 < H - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tif (x1 < W - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t} else if (!('A' <= v2 && v2 <= 'Z')) {\n\t\t\tif (y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t\tif (x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t} else {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 < H - 1 && y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\tif (y1 < H - 1 && x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\tif (x1 < W - 1 && y2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\tif (x1 < W - 1 && x2 > 0) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (x < x1) continue;\n\t\t\t\t\tif (y < H - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y + 1][x][y2][x2]);\n\t\t\t\t\tif (x < W - 1) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x + 1][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (f[y][x] != '#') reach[y][x][y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (y1 < y2) {\n\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t}\n\t\tif (x1 < x2) {\n\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t}\n\t\tif ('a' <= v1 && v1 <= 'z' && 'A' <= v2 && v2 <= 'Z') {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 + 1 < y2 && reach[y1 + 1][x1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1 + 1][x1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1][x1 + 1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (x1 + 1 < x2 && reach[y1][x1 + 1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 == y2 && x1 + 1 == x2 || y1 + 1 == y2 && x1 == x2) dp[y1][x1][y2][x2] = 1;\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (!reach[y1][x1][y][x]) continue;\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint UNUSED = 1 << 60;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (table[i][j] == '.' || table[i][j] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = rec(0, 0, table, W - 1, H - 1);\n\t\t\tSystem.out.println(d < 0 ? -1 : d);\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\tint H, W;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\t// System.out.println(curX + \" \" + curY + \" \" + toX + \" \" + toY + \" \" +\n\t\t// H + \" \" + W);\n\t\tif (curY < 0 || curX < 0 || curY >= H || curX >= W || toY < curY || toX < curX || table[curY][curX] == '#')\n\t\t\treturn -(1 << 30);\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][toY][toX] != UNUSED) {\n\t\t\treturn memo[curY][curX][toY][toX];\n\t\t}\n\t\tint ret = -(1 << 30);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, toX, toY));\n\t\t}\n\t\tif (table[curY][curX] == '.')\n\t\t\treturn ret;\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0) - 'A']) {\n\t\t\t\tif (P.x < curX || P.y < curY || toX < P.x || toY < P.y)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (P.x == curX || P.y == curY)\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\tint tmp = 0;\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.x == curX + 1 || P.y == curY + 1)) {\n\t\t\t\t\ttmp = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\ttmp = Math.max(tmp, rec(curX + i, curY + (i ^ 1), table, P.x - j, P.y - (j ^ 1)) + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (toX == P.x && toY == P.y) {\n\t\t\t\t\tret = Math.max(ret, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tret = Math.max(ret, tmp + rec(P.x + i, P.y + (i ^ 1), table, toX, toY));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y1 = H - 1; y1 >= 0; --y1) {\n\t\t\tfor (int x1 = W - 1; x1 >= 0; --x1) {\n\t\t\t\tif (f[y1][x1] == '#') continue;\n\t\t\t\treach[y1][x1][y1][x1] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (!('a' <= v1 && v1 <= 'z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t} else if (!('A' <= v2 && v2 <= 'Z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t} else {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 + 1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\tif (y1 < y2 && x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\tif (y1 < y2 && x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\tif (x1 + 1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t\tif (y1 == y2 && x1 + 1 == x2 || y1 + 1 == y2 && x1 == x2) dp[y1][x1][y2][x2] = 1;\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (x < x1) continue;\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (f[y][x] != '#') reach[y][x][y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (!('a' <= v1 && v1 <= 'z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t} else if (!('A' <= v2 && v2 <= 'Z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t} else {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 + 1 < y2 && reach[y1 + 1][x1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1 + 1][x1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1][x1 + 1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (x1 + 1 < x2 && reach[y1][x1 + 1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 == y2 && x1 + 1 == x2 || y1 + 1 == y2 && x1 == x2) dp[y1][x1][y2][x2] = 1;\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (x < x1) continue;\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint UNUSED = 1 << 60;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (table[i][j] == '.' || table[i][j] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = rec(0, 0, table, W - 1, H - 1);\n\t\t\tSystem.out.println(d < 0 ? -1 : d);\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\tint H, W;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\t// System.out.println(curX + \" \" + curY + \" \" + toX + \" \" + toY + \" \" +\n\t\t// H + \" \" + W);\n\t\tif (curY < 0 || curX < 0 || curY >= H || curX >= W || toY < curY || toX < curX || table[curY][curX] == '#')\n\t\t\treturn -(1 << 30);\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][toY][toX] != UNUSED) {\n\t\t\treturn memo[curY][curX][toY][toX];\n\t\t}\n\t\tint ret = -(1 << 30);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, toX, toY));\n\t\t}\n\t\tif (table[curY][curX] == '.')\n\t\t\treturn ret;\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0) - 'A']) {\n\t\t\t\tif (P.x < curX || P.y < curY)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.y == curY && P.x == curX + 1)) {\n\t\t\t\t\tret = Math.max(ret, rec(P.x, P.y, table, toX, toY) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, P.x - j, P.y - (j ^ 1))\n\t\t\t\t\t\t\t\t\t+ rec(P.x, P.y, table, toX, toY) + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint UNUSED = 1 << 60;\n\tboolean[][][][] reachble;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treachble = new boolean[H][W][H][W];\n\t\t\tfor (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tif (table[y][x] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treachble[y][x][y][x] = true;\n\t\t\t\t\tif (y + 1 < H && table[y + 1][x] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y + 1; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y + 1][x] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < W && table[y][x + 1] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x + 1; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y][x + 1] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (table[i][j] == '.' || table[i][j] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!isLowerCase(table[i][j]))\n\t\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = rec(0, 0, table, W - 1, H - 1);\n\t\t\tSystem.out.println(d < 0 ? -1 : d);\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\tint H, W;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\tif (curY < 0 || curX < 0 || curY >= H || curX >= W || toY < curY || toX < curX || table[curY][curX] == '#'\n\t\t\t\t|| table[toY][toX] == '#' || toX >= W || toY >= H || toX < 0 || toY < 0\n\t\t\t\t|| !reachble[curY][curX][toY][toX])\n\t\t\treturn -(1 << 20);\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][toY][toX] != UNUSED) {\n\t\t\treturn memo[curY][curX][toY][toX];\n\t\t}\n\t\tint ret = -(1 << 20);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, toX, toY));\n\t\t}\n\t\tif (table[curY][curX] == '.') {\n\t\t\tmemo[curY][curX][toY][toX] = ret;\n\t\t\treturn ret;\n\t\t}\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0) - 'A']) {\n\t\t\t\tif (!reachble[curY][curX][P.y][P.x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (P.x < curX || P.y < curY || toX < P.x || toY < P.y)\n\t\t\t\t\tcontinue;\n\t\t\t\tint tmp = -1 << 20;\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.x == curX + 1 && P.y == curY)) {\n\t\t\t\t\ttmp = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\ttmp = Math.max(tmp, rec(curX + i, curY + (i ^ 1), table, P.x - j, P.y - (j ^ 1)) + 1);\n\t\t\t\t\t\t\t// System.out.println(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (toX == P.x && toY == P.y) {\n\t\t\t\t\tret = Math.max(ret, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tret = Math.max(ret, tmp + rec(P.x + i, P.y + (i ^ 1), table, toX, toY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint UNUSED = 1 << 60;\n\tboolean[][][][] reachble;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treachble = new boolean[H][W][H][W];\n\t\t\tfor (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tif (table[y][x] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treachble[y][x][y][x] = true;\n\t\t\t\t\tif (y + 1 < H && table[y + 1][x] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y + 1; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y + 1][x] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < W && table[y][x + 1] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x + 1; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y][x + 1] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (table[i][j] == '.' || table[i][j] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!isLowerCase(table[i][j]))\n\t\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = rec(0, 0, table, W - 1, H - 1);\n\t\t\tSystem.out.println(d < 0 ? -1 : d);\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\tint H, W;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\t// System.out.println(\"!\"+curX + \" \" + curY + \" \" + toX + \" \" + toY + \"\n\t\t// \" +\n\t\t// H + \" \" + W);\n\t\tif (curY < 0 || curX < 0 || curY >= H || curX >= W || toY < curY || toX < curX || table[curY][curX] == '#'\n\t\t\t\t|| table[toY][toX] == '#' || toX >= W || toY >= H || toX < 0 || toY < 0)\n\t\t\treturn -(1 << 20);\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][toY][toX] != UNUSED) {\n\t\t\treturn memo[curY][curX][toY][toX];\n\t\t}\n\t\tint ret = -(1 << 20);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, toX, toY));\n\t\t}\n\t\tif (table[curY][curX] == '.')\n\t\t\treturn ret;\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0) - 'A']) {\n\t\t\t\tif (!reachble[curY][curX][P.y][P.x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (P.x < curX || P.y < curY || toX < P.x || toY < P.y)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((P.x == curX && P.y == curY) || table[P.y][P.x] == '#') {\n\t\t\t\t\tSystem.out.println(table[P.x][P.y]);\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\tint tmp = -1 << 20;\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.x == curX + 1 && P.y == curY)) {\n\t\t\t\t\ttmp = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\ttmp = Math.max(tmp, rec(curX + i, curY + (i ^ 1), table, P.x - j, P.y - (j ^ 1)) + 1);\n\t\t\t\t\t\t\t// System.out.println(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (toX == P.x && toY == P.y) {\n\t\t\t\t\tret = Math.max(ret, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tret = Math.max(ret, tmp + rec(P.x + i, P.y + (i ^ 1), table, toX, toY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int H, W;\n\tstatic char[][] f;\n\tstatic int[][][] hole = new int[26][50][51];\n\tstatic boolean[][][][] reach;\n\tstatic int[][][][] dp;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tf = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t\tfor (char j = 'A'; j <= 'Z'; ++j) {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\t\tif (f[i][x] == j) hole[j - 'A'][i][pos++] = x;\n\t\t\t\t\t}\n\t\t\t\t\thole[j - 'A'][i][pos] = 99;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\treach = new boolean[H][W][H][W];\n\t\tdp = new int[H][W][H][W];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (f[y][x] != '#') reach[y][x][y][x] = true;\n\t\t\t}\n\t\t}\n\t\tfor (int h = 0; h < H; ++h) {\n\t\t\tfor (int w = 0; w < W; ++w) {\n\t\t\t\tfor (int y1 = 0; y1 < H - h; ++y1) {\n\t\t\t\t\tfor (int x1 = 0; x1 < W - w; ++x1) {\n\t\t\t\t\t\tupdate(y1, x1, y1 + h, x1 + w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach[0][0][H - 1][W - 1] ? dp[0][0][H - 1][W - 1] : -1;\n\t}\n\n\tstatic void update(int y1, int x1, int y2, int x2) {\n\t\tchar v1 = f[y1][x1];\n\t\tif (v1 == '#') return;\n\t\tchar v2 = f[y2][x2];\n\t\tif (v2 == '#') return;\n\t\tif (!(y2 > 0 && reach[y1][x1][y2 - 1][x2] || x2 > 0 && reach[y1][x1][y2][x2 - 1])) return;\n\t\treach[y1][x1][y2][x2] = true;\n\t\tif (!('a' <= v1 && v1 <= 'z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2]);\n\t\t} else if (!('A' <= v2 && v2 <= 'Z')) {\n\t\t\tif (y1 < y2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2 - 1][x2]);\n\t\t\tif (x1 < x2) dp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y2][x2 - 1]);\n\t\t} else {\n\t\t\tif (v1 - 'a' == v2 - 'A') {\n\t\t\t\tif (y1 + 1 < y2 && reach[y1 + 1][x1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1 + 1][x1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1 + 1][x1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 < y2 && x1 < x2 && reach[y1][x1 + 1][y2 - 1][x2]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2 - 1][x2] + 1);\n\t\t\t\t}\n\t\t\t\tif (x1 + 1 < x2 && reach[y1][x1 + 1][y2][x2 - 1]) {\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1 + 1][y2][x2 - 1] + 1);\n\t\t\t\t}\n\t\t\t\tif (y1 == y2 && x1 + 1 == x2 || y1 + 1 == y2 && x1 == x2) dp[y1][x1][y2][x2] = 1;\n\t\t\t}\n\t\t\tfor (int y = y1; y <= y2; ++y) {\n\t\t\t\tfor (int i = 0; hole[v1 - 'a'][y][i] <= x2; ++i) {\n\t\t\t\t\tint x = hole[v1 - 'a'][y][i];\n\t\t\t\t\tif (!reach[y1][x1][y][x]) continue;\n\t\t\t\t\tdp[y1][x1][y2][x2] = Math.max(dp[y1][x1][y2][x2], dp[y1][x1][y][x] + dp[y][x][y2][x2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tnew Main().solver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc()\n\t{\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return 0;\n\t\t\treturn (char)b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd()\n\t{\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}catch(Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b <= ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = skip(), p = 0;\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b <= ' ')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n)\n\t{\n\t\tbyte[] buf = new byte[n];\n\t\ttry{\n\t\t\tint b = skip();\n\t\t\tif(b == -1)return null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException\n\t{\n\t\tint b;\n\t\twhile((b = is.read()) != -1 && !(b >= 33 && b <= 126));\n\t\treturn b;\n\t}\n\n\tstatic boolean eof()\n\t{\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\tint UNUSED = 1 << 60;\n\tboolean[][][][] reachble;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tH = ni();\n\t\t\tW = ni();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treachble = new boolean[H][W][H][W];\n\t\t\tfor (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tif (table[y][x] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treachble[y][x][y][x] = true;\n\t\t\t\t\tif (y + 1 < H && table[y + 1][x] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y + 1; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y + 1][x] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < W && table[y][x + 1] != '#') {\n\t\t\t\t\t\tfor (int src_y = 0; src_y <= y; src_y++) {\n\t\t\t\t\t\t\tfor (int src_x = 0; src_x <= x + 1; src_x++) {\n\t\t\t\t\t\t\t\treachble[src_y][src_x][y][x + 1] |= reachble[src_y][src_x][y][x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = ns().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (table[i][j] == '.' || table[i][j] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!isLowerCase(table[i][j]))\n\t\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = rec(0, 0, table, W - 1, H - 1);\n\t\t\tout.println(d < 0 ? -1 : d);\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\tint H, W;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\tif (curY < 0 || curX < 0 || curY >= H || curX >= W || toY < curY || toX < curX || table[curY][curX] == '#'\n\t\t\t\t|| table[toY][toX] == '#' || toX >= W || toY >= H || toX < 0 || toY < 0\n\t\t\t\t|| !reachble[curY][curX][toY][toX])\n\t\t\treturn -(1 << 20);\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][toY][toX] != UNUSED) {\n\t\t\treturn memo[curY][curX][toY][toX];\n\t\t}\n\t\tint ret = -(1 << 20);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + (i ^ 1), table, toX, toY));\n\t\t}\n\t\tif (table[curY][curX] == '.') {\n\t\t\tmemo[curY][curX][toY][toX] = ret;\n\t\t\treturn ret;\n\t\t}\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0) - 'A']) {\n\t\t\t\tif (!reachble[curY][curX][P.y][P.x])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (P.x < curX || P.y < curY || toX < P.x || toY < P.y)\n\t\t\t\t\tcontinue;\n\t\t\t\tint tmp = -1 << 20;\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.x == curX + 1 && P.y == curY)) {\n\t\t\t\t\ttmp = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\ttmp = Math.max(tmp, rec(curX + i, curY + (i ^ 1), table, P.x - j, P.y - (j ^ 1)) + 1);\n\t\t\t\t\t\t\t// System.out.println(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (toX == P.x && toY == P.y) {\n\t\t\t\t\tret = Math.max(ret, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tret = Math.max(ret, tmp + rec(P.x + i, P.y + (i ^ 1), table, toX, toY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tint UNUSED = 1 << 60;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif (H == 0 && W == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] table = new char[H][W];\n\t\t\tmemo = new int[H][W][H][W];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfor (int k = 0; k < H; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < W; l++) {\n\t\t\t\t\t\t\tmemo[i][j][k][l] = UNUSED;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = new ArrayList[58];\n\t\t\tfor (int i = 0; i < 58; i++) {\n\t\t\t\tp[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\ttable[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tp[table[i][j] - 'A'].add(new Coordinate(j, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(rec(0, 0, table, W - 1, H - 1));\n\t\t}\n\t}\n\n\tArrayList<Coordinate>[] p;\n\n\tclass Coordinate {\n\t\tint x;\n\t\tint y;\n\n\t\tpublic Coordinate(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tint[][][][] memo;\n\n\tint rec(int curX, int curY, char[][] table, int toX, int toY) {\n\t\tif (table[curY][curX] == '#' || toY < curY || toX < curX)\n\t\t\treturn -1;\n\t\tif (curY == toY && curX == toX) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (memo[curY][curX][curY][curX] != UNUSED) {\n\t\t\treturn memo[curX][curX][curY][curX];\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tret = Math.max(ret, rec(curX + i, curY + i ^ 1, table, toX, toY));\n\t\t}\n\t\tif (isLowerCase(table[curY][curX])) {\n\t\t\tfor (Coordinate P : p[String.valueOf(table[curY][curX]).toUpperCase().charAt(0)]) {\n\t\t\t\tif ((P.x == curX && P.y == curY + 1) || (P.y == curY && P.x == curX + 1)) {\n\t\t\t\t\tret = Math.max(ret, rec(P.x, P.y, table, toX, toY) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\t\tret = Math.max(ret, rec(P.x + i, P.y + i ^ 1, table, toX - i, toY - i ^ 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo[curY][curX][toY][toX] = ret;\n\t\treturn ret;\n\t}\n\n\tboolean isLowerCase(char c) {\n\t\tif (String.valueOf(c).toLowerCase().charAt(0) - c == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nfrom string import ascii_lowercase, ascii_uppercase\nfrom collections import deque\n\ndd = ((1, 0), (0, 1))\n\ndef solve():\n    H, W = map(int, readline().split())\n    if H == W == 0:\n        return False\n    C = [readline().strip() for i in range(H)]\n    INF = 10**9\n\n    def search(x0, y0, c):\n        que = deque([(x0, y0)])\n        used = [[0]*W for i in range(H)]\n        used[y0][x0] = 1\n        r = []\n        while que:\n            x, y = que.popleft()\n            if C[y][x] == c:\n                r.append((x, y))\n            if x+1 < W and C[y][x+1] != '#' and not used[y][x+1]:\n                que.append((x+1, y))\n                used[y][x+1] = 1\n            if y+1 < H and C[y+1][x] != '#' and not used[y+1][x]:\n                que.append((x, y+1))\n                used[y+1][x] = 1\n        return r, used\n    D0, U0 = search(0, 0, None)\n    if not U0[H-1][W-1]:\n        write(\"-1\\n\")\n        return True\n\n    D = [[None]*W for i in range(H)]\n    U = [[None]*W for i in range(H)]\n    K = [[-1]*W for i in range(H)]\n    for i in range(H):\n        for j in range(W):\n            d = C[i][j]\n            if d == '#':\n                continue\n            k = ascii_lowercase.find(C[i][j])\n            c = ascii_uppercase[k] if k != -1 else None\n            D[i][j], U[i][j] = search(j, i, c)\n            K[i][j] = k\n    dp = [[[[0]*W for i in range(H)] for j in range(W)] for k in range(H)]\n    for i0 in range(H-1, -1, -1):\n        for j0 in range(W-1, -1, -1):\n            if C[i0][j0] == '#':\n                continue\n            k = K[i0][j0]\n            for i1 in range(H-1, i0-1, -1):\n                for j1 in range(W-1, j0-1, -1):\n                    if not U[i0][j0][i1][j1]:\n                        continue\n                    r = max(\n                        (dp[i0+1][j0][i1][j1] if i0+1 <= i1 and C[i0+1][j0] != '#' else 0),\n                        (dp[i0][j0+1][i1][j1] if j0+1 <= j1 and C[i0][j0+1] != '#' else 0),\n                    )\n                    if k != -1:\n                        for x, y in D[i0][j0]:\n                            if not i0 <= y <= i1 or not j0 <= x <= j1 or not U[i0][j0][y][x] or not U[y][x][i1][j1]:\n                                continue\n                            if (x-j0)+(y-i0) == 1:\n                                A = 1\n                            else:\n                                if i0 == y:\n                                    A = dp[i0][j0+1][y][x-1] + 1\n                                elif j0 == x:\n                                    A = dp[i0+1][j0][y-1][x] + 1\n                                else:\n                                    A = max(\n                                        dp[i0+1][j0][y][x-1],\n                                        dp[i0][j0+1][y-1][x],\n                                        dp[i0+1][j0][y-1][x] if i0+1 <= y-1 else 0,\n                                        dp[i0][j0+1][y][x-1] if j0+1 <= x-1 else 0,\n                                    ) + 1\n                            r = max(r, A + dp[y][x][i1][j1])\n                    dp[i0][j0][i1][j1] = r\n    write(\"%d\\n\" % dp[0][0][H-1][W-1])\n    return True\nwhile solve():\n    ...\n"
  }
]