[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint minimumSwaps(int N) {\n    int* whitePos = malloc(N * sizeof(int));\n    int* blackPos = malloc(N * sizeof(int));\n    int swaps = 0;\n\n    for (int i = 0; i < N; i++) {\n        whitePos[i] = i;\n        blackPos[i] = i + N;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N - i - 1; j++) {\n            if (whitePos[j] > whitePos[j + 1]) {\n                int temp = whitePos[j];\n                whitePos[j] = whitePos[j + 1];\n                whitePos[j + 1] = temp;\n                swaps++;\n            }\n            \n            if (blackPos[j] > blackPos[j + 1]) {\n                int temp = blackPos[j];\n                blackPos[j] = blackPos[j + 1];\n                blackPos[j + 1] = temp;\n                swaps++;\n            }\n        }\n    }\n\n    free(whitePos);\n    free(blackPos);\n    return swaps;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    printf(\"%d\\n\", minimumSwaps(N));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\nlong long merge_and_count(int arr[], int temp[], int left, int mid, int right) {\n    int i = left, j = mid, k = left;\n    long long inv_count = 0;\n\n    while ((i <= mid - 1) && (j <= right)) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n            inv_count += (mid - i);\n        }\n    }\n\n    while (i <= mid - 1)\n        temp[k++] = arr[i++];\n    while (j <= right)\n        temp[k++] = arr[j++];\n\n    for (i = left; i <= right; i++)\n        arr[i] = temp[i];\n\n    return inv_count;\n}\n\nlong long merge_sort_and_count(int arr[], int temp[], int left, int right) {\n    long long inv_count = 0;\n    if (right > left) {\n        int mid = (left + right) / 2;\n        inv_count += merge_sort_and_count(arr, temp, left, mid);\n        inv_count += merge_sort_and_count(arr, temp, mid + 1, right);\n        inv_count += merge_and_count(arr, temp, left, mid + 1, right);\n    }\n    return inv_count;\n}\n\nlong long count_inversions(int arr[], int n) {\n    int temp[n];\n    return merge_sort_and_count(arr, temp, 0, n - 1);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int white_pos[N];\n    int black_pos[N];\n    int pos;\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &pos);\n        white_pos[pos - 1] = i;\n    }\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &pos);\n        black_pos[pos - 1] = i;\n    }\n\n    int combined[2 * N];\n    for (int i = 0; i < N; i++) {\n        combined[2 * i] = white_pos[i];\n        combined[2 * i + 1] = black_pos[i];\n    }\n\n    printf(\"%lld\\n\", count_inversions(combined, 2 * N));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint minAdjacentSwaps(vector<int>& white, vector<int>& black) {\n    int N = white.size();\n    vector<int> posWhite(N + 1), posBlack(N + 1);\n    for (int i = 0; i < N; ++i) {\n        posWhite[white[i]] = i;\n        posBlack[black[i]] = i;\n    }\n    \n    vector<int> perm(N);\n    for (int i = 1; i <= N; ++i) {\n        perm[i - 1] = posBlack[i];\n    }\n    \n    vector<int> fenwick(N + 1, 0);\n    long long swaps = 0;\n    for (int i = N - 1; i >= 0; --i) {\n        int x = perm[i] + 1;\n        for (int j = x; j > 0; j -= j & -j) {\n            swaps += fenwick[j];\n        }\n        for (int j = x; j <= N; j += j & -j) {\n            fenwick[j] += 1;\n        }\n    }\n    return swaps;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> white(N), black(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> white[i];\n    }\n    for (int i = 0; i < N; ++i) {\n        cin >> black[i];\n    }\n    cout << minAdjacentSwaps(white, black) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinSwapsForBalls {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // consume the rest of the line\n        String s = scanner.nextLine();\n        \n        List<Integer> whitePositions = new ArrayList<>();\n        List<Integer> blackPositions = new ArrayList<>();\n        \n        for (int i = 0; i < 2 * N; i++) {\n            char c = s.charAt(i);\n            if (c == 'W') {\n                whitePositions.add(i);\n            } else {\n                blackPositions.add(i);\n            }\n        }\n        \n        int[] whiteTarget = new int[N];\n        int[] blackTarget = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            whiteTarget[i] = 2 * i;\n            blackTarget[i] = 2 * i + 1;\n        }\n        \n        long swaps = countSwaps(whitePositions, whiteTarget) + countSwaps(blackPositions, blackTarget);\n        System.out.println(swaps);\n    }\n    \n    private static long countSwaps(List<Integer> positions, int[] target) {\n        int[] arr = new int[positions.size()];\n        for (int i = 0; i < positions.size(); i++) {\n            arr[i] = positions.get(i);\n        }\n        \n        return mergeSortAndCount(arr, 0, arr.length - 1, target);\n    }\n    \n    private static long mergeSortAndCount(int[] arr, int left, int right, int[] target) {\n        long count = 0;\n        if (left < right) {\n            int mid = (left + right) / 2;\n            count += mergeSortAndCount(arr, left, mid, target);\n            count += mergeSortAndCount(arr, mid + 1, right, target);\n            count += mergeAndCount(arr, left, mid, right, target);\n        }\n        return count;\n    }\n    \n    private static long mergeAndCount(int[] arr, int left, int mid, int right, int[] target) {\n        int[] leftArr = Arrays.copyOfRange(arr, left, mid + 1);\n        int[] rightArr = Arrays.copyOfRange(arr, mid + 1, right + 1);\n        \n        int i = 0, j = 0, k = left;\n        long swaps = 0;\n        \n        while (i < leftArr.length && j < rightArr.length) {\n            if (target[left + i] <= target[mid + 1 + j]) {\n                arr[k++] = leftArr[i++];\n            } else {\n                arr[k++] = rightArr[j++];\n                swaps += (mid + 1) - (left + i);\n            }\n        }\n        \n        while (i < leftArr.length) {\n            arr[k++] = leftArr[i++];\n        }\n        \n        while (j < rightArr.length) {\n            arr[k++] = rightArr[j++];\n        }\n        \n        return swaps;\n    }\n}",
    "timestamp": "2025-08-05 23:08:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int minSwaps(int[] nums) {\n        int n = nums.length / 2;\n        int[] whiteBalls = new int[n];\n        int[] blackBalls = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            whiteBalls[i] = nums[i];\n            blackBalls[i] = nums[i + n];\n        }\n        \n        return minSwapsForSequence(whiteBalls) + minSwapsForSequence(blackBalls);\n    }\n    \n    private int minSwapsForSequence(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        \n        Map<Integer, Integer> positions = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            positions.put(sorted[i], i);\n        }\n        \n        int swaps = 0;\n        boolean[] visited = new boolean[arr.length];\n        \n        for (int i = 0; i < arr.length; i++) {\n            if (visited[i] || positions.get(arr[i]) == i)\n                continue;\n            \n            int cycleSize = 0;\n            int j = i;\n            \n            while (!visited[j]) {\n                visited[j] = true;\n                j = positions.get(arr[j]);\n                cycleSize++;\n            }\n            \n            if (cycleSize > 0) {\n                swaps += cycleSize - 1;\n            }\n        }\n        \n        return swaps;\n    }\n}",
    "timestamp": "2025-08-05 23:08:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minSwaps(vector<int>& white, vector<int>& black) {\n    int N = white.size();\n    vector<pair<int, int>> whitePos(N);\n    vector<pair<int, int>> blackPos(N);\n\n    for (int i = 0; i < N; i++) {\n        whitePos[i] = {white[i], i};\n        blackPos[i] = {black[i], i};\n    }\n\n    sort(whitePos.begin(), whitePos.end());\n    sort(blackPos.begin(), blackPos.end());\n\n    int swaps = 0;\n    for (int i = 0; i < N; i++) {\n        while (whitePos[i].second != i) {\n            swap(whitePos[i], whitePos[whitePos[i].second]);\n            swaps++;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        while (blackPos[i].second != i) {\n            swap(blackPos[i], blackPos[blackPos[i].second]);\n            swaps++;\n        }\n    }\n\n    return swaps;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> white(N);\n    vector<int> black(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> white[i];\n    }\n    \n    for (int i = 0; i < N; i++) {\n        cin >> black[i];\n    }\n    \n    cout << minSwaps(white, black) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_swaps_to_arrange_balls(ball_sequence):\n    def count_inversions(arr):\n        inversions = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if arr[i] > arr[j]:\n                    inversions += 1\n        return inversions\n    \n    n = len(ball_sequence) // 2\n    white_positions = [0] * n\n    black_positions = [0] * n\n    \n    white_index = 0\n    black_index = 0\n    \n    for i, ball in enumerate(ball_sequence):\n        if ball[0] == 'W':\n            white_positions[white_index] = int(ball[1:])\n            white_index += 1\n        else:\n            black_positions[black_index] = int(ball[1:])\n            black_index += 1\n    \n    white_swaps = count_inversions(white_positions)\n    black_swaps = count_inversions(black_positions)\n    \n    return white_swaps + black_swaps\n\n# Example usage:\nball_sequence = ['W1', 'B1', 'W2', 'B2', 'W3', 'B3']\nprint(min_swaps_to_arrange_balls(ball_sequence))",
    "timestamp": "2025-08-13 13:40:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class BallArrangement {\n    public static int minimumSwaps(int[] balls) {\n        int n = balls.length / 2;\n        int[] whitePos = new int[n + 1];\n        int[] blackPos = new int[n + 1];\n\n        // Separate the positions of white and black balls\n        for (int i = 0; i < balls.length; i++) {\n            if (i < n) {\n                whitePos[balls[i]] = i;\n            } else {\n                blackPos[balls[i]] = i;\n            }\n        }\n\n        return countInversions(whitePos, n) + countInversions(blackPos, n);\n    }\n\n    private static int countInversions(int[] pos, int n) {\n        int[] temp = new int[n + 1];\n        return mergeSortAndCount(pos, temp, 1, n);\n    }\n\n    private static int mergeSortAndCount(int[] arr, int[] temp, int left, int right) {\n        if (left >= right)\n            return 0;\n\n        int mid = (left + right) / 2;\n        int invCount = 0;\n        invCount += mergeSortAndCount(arr, temp, left, mid);\n        invCount += mergeSortAndCount(arr, temp, mid + 1, right);\n        invCount += mergeAndCount(arr, temp, left, mid, right);\n\n        return invCount;\n    }\n\n    private static int mergeAndCount(int[] arr, int[] temp, int left, int mid, int right) {\n        int i = left, j = mid + 1, k = left;\n        int invCount = 0;\n\n        while (i <= mid && j <= right) {\n            if (arr[i] <= arr[j]) {\n                temp[k++] = arr[i++];\n            } else {\n                temp[k++] = arr[j++];\n                invCount += (mid + 1 - i);\n            }\n        }\n\n        while (i <= mid)\n            temp[k++] = arr[i++];\n\n        while (j <= right)\n            temp[k++] = arr[j++];\n\n        for (i = left; i <= right; i++)\n            arr[i] = temp[i];\n\n        return invCount;\n    }\n\n    public static void main(String[] args) {\n        int[] balls = {1, 2, 3, 1, 2, 3};\n        System.out.println(minimumSwaps(balls)); // Output: 3\n    }\n}",
    "timestamp": "2025-08-13 13:40:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Function to calculate the minimum number of swaps\nint minSwaps(int *arr, int length) {\n    int swaps = 0;\n    for (int i = 0; i < length; i++) {\n        for (int j = 0; j < length - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swaps++;\n            }\n        }\n    }\n    return swaps;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int totalBalls = 2 * N;\n    int positions[totalBalls];\n\n    // Read input positions\n    for (int i = 0; i < totalBalls; ++i) {\n        scanf(\"%d\", &positions[i]);\n    }\n\n    // Calculate swaps for white and black balls separately\n    int minSwapsWhite = minSwaps(positions, N);\n    int minSwapsBlack = minSwaps(positions + N, N);\n\n    // Total minimum swaps needed\n    printf(\"%d\\n\", minSwapsWhite + minSwapsBlack);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:41:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint minSwaps(string balls) {\n    int n = balls.size() / 2;\n    vector<int> whitePositions(n), blackPositions(n);\n    int whiteIndex = 0, blackIndex = 0;\n\n    for (int i = 0; i < balls.size(); ++i) {\n        if (balls[i] == 'W') {\n            whitePositions[whiteIndex++] = i;\n        } else {\n            blackPositions[blackIndex++] = i;\n        }\n    }\n\n    int swaps = 0;\n\n    for (int i = 0; i < n; ++i) {\n        swaps += abs(whitePositions[i] - 2*i) + abs(blackPositions[i] - (2*i + 1));\n    }\n\n    return swaps;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    string balls(2 * N, ' ');\n    for (int i = 0; i < N; ++i) {\n        balls[2 * i] = 'W';\n        balls[2 * i + 1] = 'B';\n    }\n\n    cout << minSwaps(balls) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 13:41:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minSwaps(N):\n    # Initialize the positions of white and black balls\n    white_pos = list(range(1, N+1))\n    black_pos = list(range(1, N+1))\n    \n    # Simulate the initial arrangement\n    balls = []\n    for i in range(N):\n        balls.append(('W', i+1))\n        balls.append(('B', i+1))\n    \n    swaps = 0\n    \n    # Iterate through the balls\n    for i in range(len(balls)):\n        # If current ball is white\n        if balls[i][0] == 'W':\n            # Find the correct position\n            correct_pos = white_pos.index(balls[i][1])\n            \n            # Swap until in correct position\n            while i != correct_pos:\n                # Swap with next ball\n                balls[i], balls[i+1] = balls[i+1], balls[i]\n                swaps += 1\n                i += 1\n        \n        # If current ball is black\n        elif balls[i][0] == 'B':\n            # Find the correct position\n            correct_pos = N + black_pos.index(balls[i][1])\n            \n            # Swap until in correct position\n            while i != correct_pos:\n                # Swap with next ball\n                balls[i], balls[i+1] = balls[i+1], balls[i]\n                swaps += 1\n                i += 1\n    \n    return swaps\n\n# Example usage\nN = int(input())\nprint(minSwaps(N))",
    "timestamp": "2025-08-13 13:41:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_swaps_to_arrange_balls(N, balls):\n    white_positions = []\n    black_positions = []\n    \n    for idx, ball in enumerate(balls):\n        color, num = ball\n        if color == 'W':\n            white_positions.append(idx)\n        else:\n            black_positions.append(idx)\n    \n    # Calculate inversions for white and black separately\n    def count_inversions(arr):\n        inv = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] > arr[j]:\n                    inv += 1\n        return inv\n    \n    white_inv = count_inversions(white_positions)\n    black_inv = count_inversions(black_positions)\n    \n    return white_inv + black_inv\n\n# Example usage:\n# N = 2\n# balls = [('W', 1), ('B', 1), ('W', 2), ('B', 2)]\n# print(min_swaps_to_arrange_balls(N, balls))  # Output: 1",
    "timestamp": "2025-08-13 13:41:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minSwaps(arr) {\n    const n = arr.length / 2;\n    const pos = {};\n    \n    for (let i = 0; i < arr.length; i++) {\n        let num = arr[i].slice(1);\n        if (!pos[num]) pos[num] = [];\n        pos[num].push(i);\n    }\n\n    let swaps = 0;\n    for (let i = 0; i < n; i++) {\n        const whitePos = pos[i + 1][0];\n        const blackPos = pos[i + 1][1];\n\n        for (let j = whitePos; j > i; j--) {\n            [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];\n            swaps++;\n        }\n\n        for (let j = blackPos; j > i + n; j--) {\n            [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];\n            swaps++;\n        }\n    }\n\n    return swaps;\n}\n\nfunction minAdjacentSwaps(N) {\n    const arr = [];\n    for (let i = 1; i <= N; i++) {\n        arr.push(`W${i}`);\n        arr.push(`B${i}`);\n    }\n    return minSwaps(arr);\n}\n\nconsole.log(minAdjacentSwaps(3)); // Example usage, replace N = 3 with any value",
    "timestamp": "2025-08-13 13:41:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minSwaps(N) {\n    const whiteOrder = Array.from({length: N}, (_, i) => i + 1);\n    const blackOrder = Array.from({length: N}, (_, i) => i + 1);\n    \n    let swaps = 0;\n    let balls = [];\n    \n    // Create initial array of white and black balls\n    for (let num of whiteOrder) {\n        balls.push({color: 'white', value: num});\n    }\n    for (let num of blackOrder) {\n        balls.push({color: 'black', value: num});\n    }\n    \n    // Sort white and black balls separately\n    for (let color of ['white', 'black']) {\n        for (let i = 0; i < N; i++) {\n            let targetIndex = balls.findIndex(ball => \n                ball.color === color && ball.value === i + 1);\n            \n            while (targetIndex > i) {\n                // Swap with previous ball\n                [balls[targetIndex], balls[targetIndex-1]] = \n                [balls[targetIndex-1], balls[targetIndex]];\n                targetIndex--;\n                swaps++;\n            }\n        }\n    }\n    \n    return swaps;\n}",
    "timestamp": "2025-08-13 13:42:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minSwapsBalls(N, balls) {\n    let whitePositions = [];\n    let blackPositions = [];\n    \n    for (let i = 0; i < balls.length; i++) {\n        if (balls[i].color === 'white') {\n            whitePositions.push(balls[i].value);\n        } else {\n            blackPositions.push(balls[i].value);\n        }\n    }\n    \n    // Calculate inversions for white balls\n    let whiteInversions = countInversions(whitePositions);\n    let blackInversions = countInversions(blackPositions);\n    \n    return whiteInversions + blackInversions;\n}\n\nfunction countInversions(arr) {\n    if (arr.length <= 1) return 0;\n    \n    let temp = new Array(arr.length);\n    return mergeSortAndCount(arr, temp, 0, arr.length - 1);\n}\n\nfunction mergeSortAndCount(arr, temp, left, right) {\n    let inversions = 0;\n    if (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        inversions += mergeSortAndCount(arr, temp, left, mid);\n        inversions += mergeSortAndCount(arr, temp, mid + 1, right);\n        inversions += mergeAndCount(arr, temp, left, mid, right);\n    }\n    return inversions;\n}\n\nfunction mergeAndCount(arr, temp, left, mid, right) {\n    let i = left;\n    let j = mid + 1;\n    let k = left;\n    let inversions = 0;\n    \n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n            inversions += (mid - i + 1);\n        }\n    }\n    \n    while (i <= mid) {\n        temp[k++] = arr[i++];\n    }\n    \n    while (j <= right) {\n        temp[k++] = arr[j++];\n    }\n    \n    for (i = left; i <= right; i++) {\n        arr[i] = temp[i];\n    }\n    \n    return inversions;\n}\n\n// Example usage:\n// const balls = [\n//     { color: 'white', value: 2 },\n//     { color: 'black', value: 1 },\n//     { color: 'white', value: 1 },\n//     { color: 'black', value: 2 }\n// ];\n// console.log(minSwapsBalls(2, balls)); // Output: 2",
    "timestamp": "2025-08-13 13:45:14"
  }
]