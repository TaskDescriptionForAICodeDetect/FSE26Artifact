[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX 200\n\nlong long comb[MAX * 2][MAX * 2];\nlong long dp[MAX + 2][MAX + 2][MAX + 2];\n\nvoid precompute_comb() {\n    for (int i = 0; i < MAX * 2; i++) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n        }\n    }\n}\n\nlong long path_count(int a, int b, int c, int d) {\n    int dx = c - a;\n    int dy = d - b;\n    if (dx < 0 || dy < 0) return 0;\n    return comb[dx + dy][dx];\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    precompute_comb();\n    \n    dp[0][0][0] = 1;\n    for (int k = 0; k <= K; k++) {\n        for (int x = 0; x <= N + K; x++) {\n            for (int y = 0; y <= M + K; y++) {\n                if (k == 0 && x == 0 && y == 0) continue;\n                dp[k][x][y] = 0;\n                if (x > 0) dp[k][x][y] = (dp[k][x][y] + dp[k][x - 1][y]) % MOD;\n                if (y > 0) dp[k][x][y] = (dp[k][x][y] + dp[k][x][y - 1]) % MOD;\n                if (k > 0 && x < N + K) dp[k][x][y] = (dp[k][x][y] + dp[k - 1][x + 1][y]) % MOD;\n                if (k > 0 && y < M + K) dp[k][x][y] = (dp[k][x][y] + dp[k - 1][x][y + 1]) % MOD;\n            }\n        }\n    }\n    \n    long long result = 0;\n    for (int x = 0; x <= N + K; x++) {\n        for (int y = 0; y <= M + K; y++) {\n            result = (result + dp[K][x][y] * path_count(x, y, N, M)) % MOD;\n        }\n    }\n    \n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:26:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nconst int MAX = 4000000;\n\nvector<long long> fact(MAX + 1, 1);\nvector<long long> inv_fact(MAX + 1, 1);\n\nlong long mod_pow(long long a, long long b) {\n    long long res = 1;\n    while (b > 0) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid precompute() {\n    for (int i = 1; i <= MAX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n    inv_fact[MAX] = mod_pow(fact[MAX], MOD - 2);\n    for (int i = MAX - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nlong long comb(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n}\n\nlong long solve(int N, int M, int K) {\n    if (K == 0) return comb(N + M, N);\n    long long total = 0;\n    for (int t = 0; t <= K; ++t) {\n        int x = N + t;\n        int y = M + K - t;\n        long long c1 = comb(x + y, x);\n        long long c2 = comb(x + y, x + t + 1);\n        total = (total + c1 - c2 + MOD) % MOD;\n    }\n    return total;\n}\n\nint main() {\n    precompute();\n    int N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    private static final int MOD = 1000000007;\n    private static long[][] comb;\n    private static int maxNM;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        maxNM = Math.max(N, M) + 2 * K + 2;\n        precomputeCombinations();\n\n        long total = 0;\n        for (int t = 0; t <= K; t++) {\n            for (int s = 0; s <= K - t; s++) {\n                int u = K - t - s;\n                if (u < 0) continue;\n\n                long ways = comb[N + M + 2 * K][N + t - s];\n                ways = ways * comb[N + M + 2 * K - (N + t - s)][M + s - t] % MOD;\n                ways = ways * comb[2 * K][t] % MOD;\n                ways = ways * comb[2 * K - t][s] % MOD;\n                total = (total + ways) % MOD;\n            }\n        }\n\n        System.out.println(total);\n    }\n\n    private static void precomputeCombinations() {\n        comb = new long[maxNM + 1][maxNM + 1];\n        comb[0][0] = 1;\n        for (int n = 1; n <= maxNM; n++) {\n            comb[n][0] = 1;\n            for (int k = 1; k <= n; k++) {\n                comb[n][k] = (comb[n - 1][k - 1] + comb[n - 1][k]) % MOD;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:27:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CityRoutes {\n    public static int countRoutes(int N, int M, int K) {\n        final int MOD = 1_000_000_007;\n        int[][][] dp = new int[N + 1][M + 1][K + 1];\n        dp[0][0][0] = 1;\n\n        for (int detours = 0; detours <= K; detours++) {\n            for (int x = 0; x <= N; x++) {\n                for (int y = 0; y <= M; y++) {\n                    if (dp[x][y][detours] == 0) continue;\n\n                    // Move right\n                    if (x + 1 <= N) {\n                        dp[x + 1][y][detours] = (dp[x + 1][y][detours] + dp[x][y][detours]) % MOD;\n                    }\n\n                    // Move up\n                    if (y + 1 <= M) {\n                        dp[x][y + 1][detours] = (dp[x][y + 1][detours] + dp[x][y][detours]) % MOD;\n                    }\n\n                    // Detour left\n                    if (x > 0 && detours < K) {\n                        dp[x - 1][y][detours + 1] = (dp[x - 1][y][detours + 1] + dp[x][y][detours]) % MOD;\n                    }\n\n                    // Detour down\n                    if (y > 0 && detours < K) {\n                        dp[x][y - 1][detours + 1] = (dp[x][y - 1][detours + 1] + dp[x][y][detours]) % MOD;\n                    }\n                }\n            }\n        }\n\n        int totalRoutes = 0;\n        for (int detours = 0; detours <= K; detours++) {\n            totalRoutes = (totalRoutes + dp[N][M][detours]) % MOD;\n        }\n\n        return totalRoutes;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        System.out.println(countRoutes(N, M, K));\n    }\n}",
    "timestamp": "2025-08-05 21:27:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 50\n#define MAX_M 50\n#define MAX_K 50\n\nlong long dp[MAX_N + 1][MAX_M + 1][MAX_K + 1];\n\nlong long countPaths(int N, int M, int K) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0] = 1;\n\n    for (int x = 0; x <= N; x++) {\n        for (int y = 0; y <= M; y++) {\n            for (int k = 0; k <= K; k++) {\n                if (dp[x][y][k] == 0) continue;\n\n                // Move right\n                if (x + 1 <= N) {\n                    dp[x+1][y][k] += dp[x][y][k];\n                }\n\n                // Move up\n                if (y + 1 <= M) {\n                    dp[x][y+1][k] += dp[x][y][k];\n                }\n\n                // Detour left\n                if (x > 0 && k + 1 <= K) {\n                    dp[x-1][y][k+1] += dp[x][y][k];\n                }\n\n                // Detour down\n                if (y > 0 && k + 1 <= K) {\n                    dp[x][y-1][k+1] += dp[x][y][k];\n                }\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int k = 0; k <= K; k++) {\n        total += dp[N][M][k];\n    }\n\n    return total;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    printf(\"%lld\\n\", countPaths(N, M, K));\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int numWays(int N, int M, int K) {\n        const int MOD = 1e9 + 7;\n        vector<vector<vector<vector<int>>>> dp(\n            N + 1, \n            vector<vector<vector<int>>>(\n                M + 1, \n                vector<vector<int>>(\n                    K + 1, \n                    vector<int>(2, 0)\n                )\n            )\n        );\n        \n        dp[0][0][0][0] = 1;\n        \n        for (int x = 0; x <= N; x++) {\n            for (int y = 0; y <= M; y++) {\n                for (int k = 0; k <= K; k++) {\n                    // Move right\n                    if (x + 1 <= N) {\n                        dp[x+1][y][k][0] = (dp[x+1][y][k][0] + dp[x][y][k][0] + dp[x][y][k][1]) % MOD;\n                    }\n                    \n                    // Move up\n                    if (y + 1 <= M) {\n                        dp[x][y+1][k][0] = (dp[x][y+1][k][0] + dp[x][y][k][0] + dp[x][y][k][1]) % MOD;\n                    }\n                    \n                    // Detour left (counts as k=1)\n                    if (x > 0 && k + 1 <= K) {\n                        dp[x-1][y][k+1][1] = (dp[x-1][y][k+1][1] + dp[x][y][k][0]) % MOD;\n                    }\n                    \n                    // Detour down (counts as k=1)\n                    if (y > 0 && k + 1 <= K) {\n                        dp[x][y-1][k+1][1] = (dp[x][y-1][k+1][1] + dp[x][y][k][0]) % MOD;\n                    }\n                }\n            }\n        }\n        \n        int result = 0;\n        for (int k = 0; k <= K; k++) {\n            result = (result + dp[N][M][k][0] + dp[N][M][k][1]) % MOD;\n        }\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 21:27:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(N, M, K):\n    from functools import lru_cache\n    from math import comb\n\n    @lru_cache(None)\n    def dfs(x, y, detours):\n        if x < 0 or y < 0:\n            return 0\n        if x == N and y == M:\n            # Calculate ways to make remaining detours\n            remaining_moves = 2 * N - x + 2 * M - y + detours\n            if remaining_moves // 2 >= detours:\n                return comb(remaining_moves // 2, detours)\n            return 0\n        # Move right, or up, detour left or down\n        return (\n            dfs(x + 1, y, detours) + dfs(x, y + 1, detours) +\n            dfs(x - 1, y, detours - 1) + dfs(x, y - 1, detours - 1)\n            if detours > 0 else dfs(x + 1, y, detours) + dfs(x, y + 1, detours)\n        )\n\n    return dfs(0, 0, K)\n\n# Example usage:\n# N = 2, M = 2, K = 1\n# print(count_ways(2, 2, 1))",
    "timestamp": "2025-08-13 06:29:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DetourPaths {\n\n    private static final int MOD = 1_000_000_007;\n\n    public static int countWays(int N, int M, int K) {\n        int[][][] dp = new int[N + 1][M + 1][K + 1];\n        dp[0][0][0] = 1;\n\n        for (int k = 0; k <= K; k++) {\n            for (int i = 0; i <= N; i++) {\n                for (int j = 0; j <= M; j++) {\n                    if (k > 0) {\n                        if (i < N) dp[i + 1][j][k - 1] = (dp[i + 1][j][k - 1] + dp[i][j][k]) % MOD;\n                        if (j < M) dp[i][j + 1][k - 1] = (dp[i][j + 1][k - 1] + dp[i][j][k]) % MOD;\n                    }\n                    if (i < N) dp[i + 1][j][k] = (dp[i + 1][j][k] + dp[i][j][k]) % MOD;\n                    if (j < M) dp[i][j + 1][k] = (dp[i][j + 1][k] + dp[i][j][k]) % MOD;\n                }\n            }\n        }\n\n        int result = 0;\n        for (int k = 0; k <= K; k++) {\n            result = (result + dp[N][M][k]) % MOD;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int N = 3;\n        int M = 3;\n        int K = 2;\n        System.out.println(countWays(N, M, K)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 06:29:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nlong long binomial(int n, int k) {\n    if (k > n) return 0;\n    if (k == 0 || k == n) return 1;\n    \n    k = (k > n - k) ? n - k : k;\n    \n    long long res = 1;\n    for (int i = 0; i < k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n    return res;\n}\n\nlong long countWays(int N, int M, int K) {\n    long long totalWays = 0;\n    \n    for (int a = 0; a <= K; ++a) {\n        int leftDetours = a;\n        int downDetours = K - a;\n        long long ways = binomial(N + leftDetours + M + downDetours, N + leftDetours) * binomial(N + leftDetours + M + downDetours, M + downDetours);\n        \n        totalWays += ways;\n    }\n    \n    return totalWays;\n}\n\nint main() {\n    int N, M, K;\n    printf(\"Enter N, M, K: \");\n    scanf(\"%d %d %d\", &N, &M, &K);\n    printf(\"Number of ways to reach school: %lld\\n\", countWays(N, M, K));\n    return 0;\n}",
    "timestamp": "2025-08-13 06:29:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_paths(N, M, K):\n    MOD = 10**9 + 7\n    \n    # 4D DP: [x][y][detours_used][steps_taken]\n    dp = [[[[0 for _ in range(K+1)] for _ in range(K+1)] for _ in range(M+1)] for _ in range(N+1)]\n    \n    # Starting point\n    dp[0][0][0][0] = 1\n    \n    for x in range(N+1):\n        for y in range(M+1):\n            for d in range(K+1):\n                for steps in range(steps+1):\n                    if dp[x][y][d][steps] == 0:\n                        continue\n                    \n                    # Move right\n                    if x+1 <= N:\n                        dp[x+1][y][d][steps+1] = (dp[x+1][y][d][steps+1] + dp[x][y][d][steps]) % MOD\n                    \n                    # Move up\n                    if y+1 <= M:\n                        dp[x][y+1][d][steps+1] = (dp[x][y+1][d][steps+1] + dp[x][y][d][steps]) % MOD\n                    \n                    # Detour left (only if not going negative)\n                    if x > 0 and d < K:\n                        dp[x-1][y][d+1][steps+1] = (dp[x-1][y][d+1][steps+1] + dp[x][y][d][steps]) % MOD\n                    \n                    # Detour down (only if not going negative)\n                    if y > 0 and d < K:\n                        dp[x][y-1][d+1][steps+1] = (dp[x][y-1][d+1][steps+1] + dp[x][y][d][steps]) % MOD\n    \n    # Sum all paths reaching the destination with exactly K detours\n    total_paths = sum(dp[N][M][K]) % MOD\n    return total_paths\n\n# Example usage\nprint(count_paths(2, 2, 1))",
    "timestamp": "2025-08-13 06:30:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef precompute_factorials(max_n, MOD):\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    return fact, inv_fact\n\nmax_fact = 10**6\nfact, inv_fact = precompute_factorials(max_fact, MOD)\n\ndef comb(a, b):\n    if a < 0 or b < 0 or a < b:\n        return 0\n    return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n\ndef solve():\n    N, M, K = map(int, sys.stdin.readline().split())\n    total = 0\n    # Case 1: detours before reaching (N, M)\n    for t in range(0, K + 1):\n        # Number of ways to reach (N + t, M + t) with t detours (left/down)\n        # Each detour must be compensated by an extra right/up\n        # So total steps: N + M + 2*t\n        # Choose t steps to be left/down (and compensate with right/up)\n        ways = comb(N + M + 2 * t, N + t) * comb(N + t, t) % MOD\n        # Subtract paths that reach (N, M) earlier (i.e., with fewer than t detours)\n        # Using inclusion-exclusion\n        ways = (ways - comb(N + M + 2 * (t - 1), N + (t - 1)) * comb(N + (t - 1), t - 1)) % MOD\n        total = (total + ways) % MOD\n    # Case 2: detours after reaching (N, M)\n    for t in range(1, K + 1):\n        # After reaching (N, M), make t detours (left/down) and compensate\n        # Total steps: N + M + 2*t\n        # Choose t steps to be left/down (and compensate with right/up)\n        ways = comb(N + M + 2 * t, N + t) * comb(M + t, t) % MOD\n        # Subtract paths that reach (N, M) and make fewer than t detours\n        ways = (ways - comb(N + M + 2 * (t - 1), N + (t - 1)) * comb(M + (t - 1), t - 1)) % MOD\n        total = (total + ways) % MOD\n    print(total % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 06:30:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1000000007;\n\nint countWays(int N, int M, int K) {\n    std::vector<std::vector<std::vector<int>>> dp(N+1, std::vector<std::vector<int>>(M+1, std::vector<int>(K+1, 0)));\n    \n    dp[0][0][0] = 1;\n\n    for (int k = 0; k <= K; ++k) {\n        for (int i = 0; i <= N; ++i) {\n            for (int j = 0; j <= M; ++j) {\n                if (i < N) dp[i+1][j][k] = (dp[i+1][j][k] + dp[i][j][k]) % MOD;\n                if (j < M) dp[i][j+1][k] = (dp[i][j+1][k] + dp[i][j][k]) % MOD;\n                if (k < K) {\n                    if (i > 0) dp[i-1][j][k+1] = (dp[i-1][j][k+1] + dp[i][j][k]) % MOD;\n                    if (j > 0) dp[i][j-1][k+1] = (dp[i][j-1][k+1] + dp[i][j][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    return dp[N][M][K];\n}\n\nint main() {\n    int N, M, K;\n    std::cin >> N >> M >> K;\n    std::cout << countWays(N, M, K) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:16"
  }
]