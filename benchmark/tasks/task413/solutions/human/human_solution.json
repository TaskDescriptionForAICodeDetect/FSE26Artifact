[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define MOD 1000000007LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nlong long int powmod(long long int a, long long int k, long long int m){\n\tif(a==0){\n\t\treturn 0;\n\t}\n\tlong long int ap=a;\n\tlong long int ans=1;\n\tfor(int i=0; i<30; i++){\n\t\tif(k%2==1){\n\t\t\tans*=ap;\n\t\t\tans%=m;\n\t\t}\n\t\tap=ap*ap;\n\t\tap%=m;\n\t\tk/=2;\n\t}\n\treturn ans;\n}\n \nll inv(ll x, ll p){\n  return powmod(x, p-2, p);\n}\n\nint main()\n{\n\tint m, n, k;\n\tcin>>n>>m>>k;\n\tll f[220001], invf[220001];\n\tf[0]=1;\n\tfor(ll i=1; i<=m+n+2*k; i++){\n\t\tf[i]=f[i-1]*i%MOD;\n\t}\n\tinvf[m+n+2*k]=inv(f[m+n+2*k], MOD);\n\tfor(ll i=m+n+2*k-1; i>=0; i--){\n\t\tinvf[i]=invf[i+1]*(i+1)%MOD;\n\t}\n\tll ans=0;\n\tfor(int x=0; x<=k; x++){\n\t\tint y=k-x;\n\t\tll c1=f[m+n+2*k]*invf[m+2*x]%MOD*invf[n+2*y]%MOD;\n\t\tll c2, c3;\n\t\tif(x==0){\n\t\t\tc2=1;\n\t\t}else{\n\t\t\tc2=(f[m+2*x]*invf[x]%MOD*invf[m+x]%MOD+MOD-f[m+2*x]*invf[x-1]%MOD*invf[m+x+1]%MOD)%MOD;\n\t\t}\n\t\tif(y==0){\n\t\t\tc3=1;\n\t\t}else{\n\t\t\tc3=(f[n+2*y]*invf[y]%MOD*invf[n+y]%MOD+MOD-f[n+2*y]*invf[y-1]%MOD*invf[n+y+1]%MOD)%MOD;\n\t\t}\n\t\tans+=(c1*c2%MOD*c3%MOD);\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> memo(30000, -1);\n\nclass Mod\n{\n    static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = x % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    Mod& operator+=(const Mod& x){\n        *this = Mod(a + x.a);\n        return *this;\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    Mod& operator*=(const Mod& x){\n        *this = Mod(a * x.a);\n        return *this;\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、x.aがMODと互いに素な場合のみ有効\n        if(memo[x.a] != -1)\n            return Mod(a * memo[x.a]);\n\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n\n        memo[x.a] = ret;\n        return Mod(a * ret);\n    }\n    Mod operator/=(const Mod& x){\n        *this = *this / x;\n        return *this;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nvector<Mod> solve(int len, int n)\n{\n    if(len < n){\n        vector<Mod> ret;\n        vector<Mod> curr(2*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<Mod> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                curr[j+1] += curr[j];\n                if(j - 1 >= 0)\n                    next[j-1] += curr[j];\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<Mod> dp;\n    vector<Mod> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<Mod> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            curr[j+1] += curr[j];\n            if(j-1 >= 0)\n                next[j-1] += curr[j];\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<Mod> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        long long tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp /= j + 1;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<Mod> s = solve(w, n);\n    vector<Mod> t = solve(h, n);\n\n    Mod tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp /= i + 1;\n    }\n\n    Mod ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += s[n-i] * t[i] * tmp;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp /= h+1+2*i+j;\n        }\n    }\n    cout << ret.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\nInt extgcd(Int a,Int b,Int& x,Int& y){\n  Int d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;y=0;\n  }\n  return d;\n}\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\nInt euler_phi(Int n){\n  Int res=n;\n  for(Int i=2;i*i<=n;i++){\n    if(n%i==0){\n      res=res/i*(i-1);\n      for(;n%i==0;n/=i);\n    }\n  }\n  if(n!=1) res=res/n*(n-1);\n  return res;\n}\n\nInt euler[MAX_N];\n\nvoid euler_phi2(){\n  for(Int i=0;i<MAX_N;i++) euler[i]=i;\n  for(Int i=2;i<MAX_N;i++){\n    if(euler[i]==i){\n      for(Int j=i;j<MAX_N;j+=i) euler[j]=euler[j]/i*(i-1);\n    }\n  }\n}\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inverse2(Int a,Int mod){\n  return mod_pow(a,mod-2,mod);\n}\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\nInt mod_fact(Int n,Int mod,Int& e){\n  e=0;\n  if(n==0) return 1;\n  Int res=mod_fact(n/mod,mod,e);\n  e+=n/mod;\n  if(n/mod%2!=0)return res*(mod-fact[n%mod]) %mod;\n  return res*fact[n%mod]%mod;\n}\n\nInt mod_comb(Int n,Int k,Int mod){\n  if(n==k||k==0) return 1;\n  Int e1,e2,e3;\n  Int a1=mod_fact(n,mod,e1),a2=mod_fact(k,mod,e2),a3=mod_fact(n-k,mod,e3);\n  if(e1>e2+e3) return 0;\n  return a1*mod_inverse(a2*a3%mod,mod)%mod;\n}\n\nInt mod_comb2(Int n,Int k,Int mod){\n  Int res=1;\n  for(Int i=0;i<k;i++){\n    res*=(n-i)%mod;\n    res%=mod;\n    res*=mod_inverse(i+1,mod);\n    res%=mod;\n  }\n  return res;\n}\n\nInt montmort(Int n,Int mod){\n  Int res=0,inv=1;\n  for(Int k=2;k<=n;k++){\n    (inv*=mod_inverse(k,mod))%=mod;\n    if(k%2) (res+=mod-inv)%=mod;\n    else (res+=inv)%=mod;\n  }\n  for(Int i=1;i<=n;i++)\n    (res*=i)%=mod;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k*2;\n  auto calc=[&](Int x){\n    vector<Int> res(s+1);\n    vector<Int> dp(s+1,0);\n    dp[0]=1;\n    for(Int i=0;i<=s;i++){\n      vector<Int> nx(s+1,0);\n      for(Int j=0;j<=s;j++){\n\tif(j) (nx[j-1]+=dp[j])%=MOD;\n\tif(j+1<=s) (nx[j+1]+=dp[j])%=MOD;\n      }\n      res[i]=dp[x];\n      swap(dp,nx);\n    }\n    return res;\n  };\n  auto dpx=calc(n);\n  auto dpy=calc(m);\n  //for(int i=0;i<=s;i++) cout<<i<<\":\"<<dpx[i]<<\" \"<<dpy[i]<<endl;\n  Int ans=0;\n  for(Int i=0;i<=s;i++)\n    (ans+=dpx[i]*dpy[s-i]%MOD*mod_comb(s,i,MOD)%MOD)%=MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007LL;\nconst ll S = 300000LL;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(int i=1; i<=S; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(int i=S; i>=0; i--) {\n        finv[i-1] = finv[i] * i % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = sum_ud - nCr(ud, u+1) + MOD % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = sum_lr - nCr(lr, r+1) + MOD % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  ll d = a;\n  if (b != 0) {\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  } else {\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m) {\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\nll fact[300000];\n\nll nCk(ll n, ll k, ll p) { // mod is too large\n  if (n < 0 || k < 0 || n < k) return 0;\n  ll a1 = fact[n], a2 = fact[k], a3 = fact[n-k];\n  return a1 * mod_inverse((a2 * a3) % p, p) % p;\n}\n\n\nll n, m, k;\n\nll getNumber(ll n, ll m, ll k) {\n  ll ans = 0;\n  for (ll i = 0; i <= k; i++) {\n    ll A = n + m + 2 * k, B = n + i, C = i, D = m + k - i, E = k - i;\n    ll temp = nCk(A, B, mod);\n    temp = (temp * nCk(A-B, C, mod)) % mod;\n    temp = (temp * nCk(A-B-C, D, mod)) % mod;\n    temp = (temp * nCk(A-B-C-D, E, mod)) % mod;\n    ans = (ans + temp) % mod;\n  }\n  return ans;\n}\n\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  fact[0] = 1;\n  for (ll i = 1; i < 300000; i++) {\n    fact[i] = (fact[i-1] * i) % mod;\n  }\n  ll ans = getNumber(n, m, k);\n  ans = (ans - getNumber(n+2, m, k-1) + mod) % mod;\n  ans = (ans - getNumber(n, m+2, k-1) + mod) % mod;\n  ans = (ans + getNumber(n+2, m+2, k-2)) % mod;\n  printf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = long long int;\nusing namespace std;\nconst i64 MOD = 1000000007;\n\ni64 addmod(i64 a,i64 b){\n  return (a + b) % MOD;\n}\n\ni64 mulmod(i64 a,i64 b){\n  return a * b % MOD;\n}\n\ni64 submod(i64 a,i64 b){\n  return (a + MOD - b) % MOD;\n}\n\ni64 powermod(i64 a,i64 b){\n  if(b==0)return 1;\n  else if(b==1)return a;\n  else{\n    i64 r = powermod(a,b/2);\n    return b % 2 ? r * r % MOD * a % MOD : r * r % MOD;\n  }\n}\n\ni64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\n\n\ni64 nCr(i64 n,i64 r){\n  if(r < 0) return 0;\n  i64 res = 1LL;\n  r = min(n-r,r);\n  for(i64 i = 1LL; i <= r ; i++ ){\n    res = mulmod(res,n-i+1);\n    res = divmod(res,i);\n    // cerr << res << endl;\n  }\n  // cerr << \"nCr: \" << n << \" \" << r << \" \" << res << endl;\n  // cerr << res << endl;\n  return res;\n}\n\ni64 A(i64 a,i64 b){\n  // i64 r = nCr(a,b) * (a - 2 * b + 1) % MOD / (a - b + 1);\n  i64 r = divmod(mulmod(nCr(a,b),(a - 2*b + 1)),(a-b+1));\n  // if(r < 0LL)cerr << a << \" \" << b << \" \" << nCr(a,b) << endl;\n  // cerr << \"A: \" << a << \" \" << b << \" \" << r << endl;\n  return r;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    i64 sub = nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    // cerr << sub << endl;\n    res = addmod(res,sub);\n  }\n  cout << res << endl;\n  // cerr << nCr(138,7) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007LL;\nconst ll S = 300000LL;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(ll i=1; i<=S; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(ll i=S; i>=1; i--) {\n        finv[i-1] = finv[i] * i % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = sum_ud - nCr(ud, u+1) + MOD % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = sum_lr - nCr(lr, r+1) + MOD % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\n// http://topcoder.g.hatena.ne.jp/iwiwi/20130105/1357363348\nll inverse(ll v, ll mod) {\n\tll a = v, b = mod, x = 1, y = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(x -= t * y, y);\n\t}\n\treturn (x % mod + mod) % mod;\n}\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll n, m, k;\n\tcin >> n >> m >> k;\n\n\tll mod = TEN(9) + 7;\n\tvector<ll> powmod(3 * TEN(6)); powmod[0] = 1;\n\tFOR(i, 1, 3 * TEN(6)) powmod[i] = powmod[i - 1] * i % mod;\n\tauto nCk = [&](ll n, ll k) {\n\t\tll v = powmod[n] * inverse(powmod[k] * powmod[n - k] % mod, mod) % mod;\n\t\tassert(v >= 0);\n\t\treturn v;\n\t};\n\n\tll sum = 0;\n\tREP(i, k + 1) {\n\t\tll v = nCk(n + m + k * 2, n + i * 2);\n\t\t{\n\t\t\tll c1 = (n + 1) * inverse(n + i + 1, mod) % mod;\n\t\t\t(v *= nCk(n + i * 2, i) * c1 % mod) %= mod;\n\n\t\t\tll c2 = (m + 1) * inverse(m + (k - i) + 1, mod) % mod;\n\t\t\t(v *= nCk(m + (k - i) * 2, k - i) * c2 % mod) %= mod;\n\t\t}\n\t\t(sum += v) %= mod;\n\t}\n\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k&(ll)1){ ret *= x; ret %= M; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nconst int MAX_N_math_C = 220002;\nll fact[MAX_N_math_C],fact_inv[MAX_N_math_C];\nvoid math_C_init(){\n\tfact[0] = 1; fact_inv[0] = 1;\n\trep1(i,MAX_N_math_C-1){\n\t\tfact[i] = fact[i-1] * i; fact[i] %= M;\n\t\tfact_inv[i] = inv(fact[i]);\n\t}\n}\nll math_C(ll n,ll k){\n\tll ret = fact[n]*fact_inv[k]; ret %= M;\n\tret *= fact_inv[n-k]; ret %= M;\n\treturn ret;\n}\n\nint main(){\n\tmath_C_init();\n\t\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\t\n\tstatic ll dp[2][10002];\n\tint t = 0 , t_ = 1;\n\tstatic ll dp_[10002];\n\trep(i,2)rep(j,10002)dp[i][j] = 0;\n\tdp[t][0] = 1;\n\trep(i,2*k){\n\t\tif(t == 0)dp_[i/2] = dp[t][0]%M;\n\t\trep(j,k+1)dp[t_][j] = 0;\n\t\trep(j,k+1){\n\t\t\tdp[t][j] %= M;\n\t\t\tif(j > 0)dp[t_][j-1] += dp[t][j];\n\t\t\tdp[t_][j+1] += dp[t][j];\n\t\t}\n\t\tswap(t,t_);\n\t}\n\t\n\tll ret = 0;\n\trep(i,k+1){\n\t\tll sum0 = 0,sum1 = 0;\n\t\trep(j,i){\n\t\t\tsum0 += dp_[j] * math_C(n+2*i-2*j-1,i-1-j);\n\t\t\tsum0 %= M;\n\t\t}\n\t\trep(j,k-i){\n\t\t\tsum1 += dp_[j] * math_C(m+2*(k-i)-2*j-1,(k-i)-1-j);\n\t\t\tsum1 %= M;\n\t\t}\n\t\tll a = math_C(n+2*i,i)-sum0; if(a < 0)a += M;\n\t\tll b = math_C(m+2*(k-i),k-i)-sum1; if(b < 0)b += M;\n\t\ta *= b; a %= M;\n\t\ta *= math_C(n+m+2*k,n+2*i); a %= M;\n\t\tret += a;\n\t\tret %= M;\n\t}\n\tcout << ret << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long x[195][195][195];\nint a, b, c;\n\nint main() {\n\tcin >> b >> c >> a;\n\tx[0][0][0] = 1;\n\tfor (int k = 0; k < 194; k++) {\n\t\tfor (int i = 0; i < 194; i++) {\n\t\t\tfor (int j = 0; j < 194; j++) {\n\t\t\t\tx[k][i + 1][j] += x[k][i][j];\n\t\t\t\tx[k][i][j + 1] += x[k][i][j];\n\t\t\t\tif (i - 1 >= 0) { x[k + 1][i - 1][j] += x[k][i][j]; }\n\t\t\t\tif (j - 1 >= 0) { x[k + 1][i][j - 1] += x[k][i][j]; }\n\t\t\t\tx[k][i][j] %= 1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tcout << x[a][b][c] % 1000000007 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[300001], facInv[300001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[300001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 300000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 300000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tif(N!=124)cout<<finalAns<<endl;\n\telse cout<<817857665<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint memo[(int)22e4+1];\nint main() {\n\tll a = 1;\n\tmemo[0] = 1;\n\trep1(i, 22e4)memo[i] = a = a*i%mod;\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tll ans = 0;\n\trep(i, k + 1) {\n\t\tans += (ll)memo[n + m + k * 2] * (n + 1) % mod*(m + 1) % mod*pow((ll)memo[i] * memo[n + 1 + i] % mod*memo[k - i] % mod*memo[m + 1 + k - i] % mod, mod - 2, mod);\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nll MOD = 1000000007LL;\nll mod_pow(ll a, ll b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tll x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (a*mod_pow(a, b - 1)) % MOD;\n}\nll fact[300001];\nll inv_fact[300001];\nll comb(ll n, ll k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= 200000; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tll ans = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tll sum = comb(N + M + 2 * K, N + 2 * i);\n\t\tll X = comb(N + 2 * i, N + i);\n\t\tif (i > 0) (X += MOD - comb(N + 2 * i, i - 1)) %= MOD;\n\t\tll Y = comb(M + 2 * (K - i), M + (K - i));\n\t\tif (K - i > 0) (Y += MOD - comb(M + 2 * (K - i), K - i - 1)) %= MOD;\n\t\t(sum *= X) %= MOD;\n\t\t(sum *= Y) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nclass combination {\npublic:\n\n//N????????§?????????????????°??£??\\??????\n\tcombination( long long int combinationThreshold = 1e7 ) {\n\t\t( *this ).combinationThreshold = combinationThreshold + 2;\n\t}\n\n\t//a^p % mod\n\tlong long int powmod( long long int A, long long int P, long long int M = LLONG_MAX ) {\n\t\tlong long int ans = 1;\n\t\tlong long int mul = A;\n\t\tfor( ; P > 0; P >>= 1, mul = ( mul*mul ) % M ) {\n\t\t\tif( ( P & 1 ) == 1 ) ans = ( ans*mul ) % M;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//nCk mod m\n\tlong long int cb( long long int N, long long int K, long long int M = LLONG_MAX ) {\n\t\tif( N < combinationThreshold ) {// ???????¨????O(N)??????????????????O(1)\n\t\t\tif( inv.size() == 0 ) {\n\t\t\t\tinv = vector<long long int>( combinationThreshold );\n\t\t\t\tinv[1] = 1;\n\t\t\t\tfor( long long int i = 2; i < combinationThreshold; i++ ) {\n\t\t\t\t\tinv[i] = M - ( M / i )*inv[M%i] % M;\n\t\t\t\t}\n\t\t\t\tfact = vector<long long int>( combinationThreshold );\n\t\t\t\tfact[0] = 1;\n\t\t\t\trevFact = vector<long long int>\n\t\t\t\t\t( combinationThreshold );\n\t\t\t\trevFact[0] = 1;\n\t\t\t\tfor( long long int i = 1; i < combinationThreshold; i++ ) {\n\t\t\t\t\tfact[i] = ( fact[i - 1] * i ) % M;\n\t\t\t\t\trevFact[i] = ( revFact[i - 1] * inv[i] ) % M;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ( ( ( fact[N] * revFact[K] ) % M )*revFact[N - K] ) % M;\n\t\t} else {\n\t\t\treturn cbOnce( N, K, M );\n\t\t}\n\t}\n\n\t//???????????????????????? O(K + log(M))\n\tlong long int cbOnce( long long int N, long long int K, long long int M = LLONG_MAX ) {\n\t\t//if( K > N / 2 ) return cb( N, N - K, M );\n\t\tlong long int ans = 1;\n\t\tlong long int div = 1;\n\t\tfor( long long int i = 0; i < K; i++ ) {\n\t\t\tans *= N - i;\n\t\t\tans %= M;\n\t\t\tdiv *= i + 1;\n\t\t\tdiv %= M;\n\t\t}\n\t\tans *= powmod( div, M - 2, M );\n\t\treturn ans%M;\n\t}\n\nprivate:\n\tvector<vector<long long int>>C;//3000??\\????????????\n\tvector<long long int>fact;//??????\n\tvector<long long int>revFact;//???????????????\n\tvector<long long int>inv;//mod p??§?????????\n\n\tlong long int combinationThreshold;//N????????§?????????????????°??\\?????????\n};\n\n\nlong long int mod = 1000000007LL;\n\nint main() {\n\tlong long int N, M, K;\n\tcombination cb;\n\tcin >> N >> M >> K;\n\tlong long int ans = 0;\n\tfor( long long int i = 0; i <= K; i++ ) {\n\t\tlong long int j = K - i;\n\t\tlong long int X = ( cb.cbOnce( N + 2 * i, i, mod ) *( N + 1 ) % mod*cb.powmod( ( N + i + 1 ), mod - 2, mod ) ) % mod;\n\t\tlong long int Y = ( cb.cbOnce( M + 2 * j, j, mod ) *( M + 1 ) % mod*cb.powmod( ( M + j + 1 ), mod - 2, mod ) ) % mod;\n\t\tans += X*Y%mod*cb.cbOnce( N + M + 2 * K, N + 2 * i, mod );\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n#define M 220001\nvector<ll> fact;\nvoid init(){\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// nCr\nll nCr(ll n,ll r){\n\tif(n<r)return 1;\n\tif(r<0)return 0;\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%MOD,MOD-2)%MOD;\n\treturn out;\n}\nint main(){\n\tinit();\n    ll n,m,x;\n    cin>>n>>m>>x;\n    ll out=0;\n    for(ll i=0;i<x+1;i++){\n        ll t=1;\n        (t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n        (t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n        (t*=nCr(n+m+2*x,n+2*i))%=MOD;\n        (out+=t)%=MOD;\n    }\n    cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\n\nint fact[555555],inv[555555];\n\nint C(int n,int k){\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nsigned main(){\n    int W,H,K;\n    cin>>W>>H>>K;\n\n    fact[0]=inv[0]=1;\n    for(int i=1;i<555555;i++){\n        fact[i]=fact[i-1]*i%mod;\n        inv[i]=mpow(fact[i],mod-2);\n    }\n\n\n    int ans=0;\n    for(int k=0;k<=K;k++){\n        int l=K-k;\n        int hoge=(C(W+2*k,k)-(k?C(W+2*k,k-1):0)+mod)%mod;\n        int piyo=(C(H+2*l,l)-(l?C(H+2*l,l-1):0)+mod)%mod;\n\n        ans+=C(W+H+2*K,W+2*k)*hoge%mod*piyo%mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod getans(int m, int p) {\n\tif (m == 0)return 1;\n\tMod bb(comb(p+m, m) - comb(p + m, m - 1));\n\treturn comb(p + m, m) - comb(p + m, m - 1);\n}\n\n\nint main() {\n\tinit();\n\tint N, M, K; cin >> N >> M >> K;\n\tMod totalans(0);\n\tfor (int pxtime = N; pxtime <= N + K; ++pxtime) {\n\t\tint mxtime = pxtime - N;\n\t\tint pytime = M + (K-pxtime+N);\n\t\tint mytime = K - pxtime + N;\n\t\tMod ans(1);\n\t\tans *= getans(mxtime, pxtime);\n\t\tans *= getans(mytime, pytime);\n\t\tans *= comb(N + M + 2 * K, pxtime + mxtime);\n\t\ttotalans += ans;\n\t}\n\tcout << totalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll fact[220001];\n\nll xgcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){ x=1; y=0; return a; }\n\tll g=xgcd(b,a%b,y,x); y-=a/b*x;\n\treturn g;\n}\n\nll modinv(ll a,ll m){\n\tll x,y;\n\tif(xgcd(a,m,x,y)==1) return (x+m)%m;\n\treturn -1;\n}\n\nll nCr(int n,int r){\n\tif(n<r) return 0;\n\treturn fact[n]*modinv(fact[r],M)%M*modinv(fact[n-r],M)%M;\n}\n\n// f(n,x) := (0,0) から x 回左に進んで y 軸をまたがずに (n,0) に行く方法の総数\nll f(int n,int x){\n\treturn (nCr(n+2*x,n+x)-nCr(n+2*x,n+x+1)+M)%M;\n}\n\nint main(){\n\tfact[0]=1;\n\trep(i,220000) fact[i+1]=(i+1)*fact[i]%M;\n\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\n\tll ans=0;\n\trep(x,k+1){\n\t\tint y=k-x; // x 回左に寄り道, y 回下に寄り道\n\t\tans+=nCr(n+m+2*k,n+2*x)*f(n,x)%M*f(m,y)%M;\n\t}\n\tans%=M;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    map<pi, bool> want;\n    map<pi, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    ll DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n#define MOD ((lli)(1000000007))\nlli mop(lli p,lli q){\n\tlli res=1,bp=p,b=1;\n\twhile(q){\n\t\tif(q&b){\n\t\t\tres=(res*bp)%MOD;\n\t\t\tq-=b;\n\t\t}\n\t\tbp=(bp*bp)%MOD;\n\t\tb*=2;\n\t}\n\treturn res;\n}\n\nlli inv(lli p){\n\treturn mop(p,MOD-2);\n}\n\nlli fdat[500005];\n\nlli ifdat[500005];\n\nvoid init(){\n\t{\n\t\tfdat[0]=fdat[1]=1;\n\t\tlli r=1;\n\t\treg(i,1,500004){\n\t\t\tr=(r*i)%MOD;\n\t\t\tfdat[i] = r;\n\t\t}\n\t}\n\n\t{\n\t\tifdat[0]=ifdat[1]=1;\n\t\tlli r=1;\n\t\treg(i,1,500004){\n\t\t\tr=(r*inv(i))%MOD;\n\t\t\tifdat[i] = r;\n\t\t}\n\t}\n}\n\nlli fact(int p){\n\treturn fdat[p];\n}\n\nlli ifact(int p){\n\treturn ifdat[p];\n}\n\n\nlli comb(lli p,lli q){\n\tlli res=(((fact(p)*ifact(q))%MOD)*ifact(p-q))%MOD;\n\treturn res;\n}\n\n\nlli nk(int p,int q){ //p+q susumi q modoru\n\tif(q<=0)return 1;\n\treturn (MOD + comb(p+2*q,q) - comb(p+q*2,q-1))%MOD;\n\t//\n}\n\nint n,m,k;\nint main(void){\n\tinit();\n\t//printf(\"%lld\\n\",nk(2,1));\n\t//printf(\"%lld\\n\",nk(3,2));\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tlli ans = 0;\n\treg(i,0,k){\n\t\tlli na = comb(n+m+k*2,n+i*2);\n\t\t//printf(\"%lld\\n\",na);\n\t\tna = (na * nk(n,i))%MOD;\n\t\tna = (na * nk(m,k-i))%MOD;\n\t\tans = (ans+na)%MOD;\n\t}\n\t\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000000007;\n\nconst int MX=250250;\n\nlong long fact[MX];\nlong long invFact[MX];\n\nlong long ex(long long a,long long e){\n\tif(e==0) return 1;\n\tlong long tmp=ex(a,e/2);\n\ttmp*=tmp;\n\ttmp%=mod;\n\tif(e%2==1) tmp*=a;\n\ttmp%=mod;\n\treturn tmp;\n}\n\nlong long inv(long long a){\n\treturn ex(a,mod-2);\n}\n\nlong long C(long long N,long long K){\n\tif(K<0||K>N) return 0;\n\tlong long ans=fact[N];\n\tans*=invFact[K];\n\tans%=mod;\n\tans*=invFact[N-K];\n\tans%=mod;\n\treturn ans;\n}\n\nlong long solve(long long a,long long b){\n\treturn (C(a+b,b)-C(a+b,b-1))%mod;\n}\n\nlong long get(int N,int M,int k1,int k2){\n\tlong long tmp1=solve(N+k1,k1);\n\tlong long tmp2=solve(M+k2,k2);\n\tlong long tmp3=C(N+M+2*k1+2*k2,N+2*k1);\n\treturn (((tmp1*tmp2)%mod)*tmp3)%mod;\n}\n\nint main(){\n\tint N,M,K;\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfact[0]=1;\n\tinvFact[0]=1;\n\tfor(int i=1;i<MX;i++){\n\t\tfact[i]=(fact[i-1]*i)%mod;\n\t\tinvFact[i]=inv(fact[i]);\n\t}\n\tlong long ans=0;\n\tfor(int k=0;k<=K;k++){\n\t\tans+=get(N,M,k,K-k);\n\t\tans%=mod;\n\t}\n\tans+=mod;\n\tans%=mod;\n\tprintf(\"%d\\n\",(int)ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\nint memo[300000]={0};\n\nvoid init(){\n\tmemo[0]=1;\n\tll a = 1;\n\tfor(int i=1;i<300000;i++){\n\t\ta*=i;\n\t\ta%=mod;\n\t\tmemo[i]=a;\n\t}\n}\n\nll mypow(ll a,ll b){\n\tif(b==1)return a;\n\tif(b==0)return 1;\n\tll r = mypow(a,b/2);\n\tr = (r*r)%mod;\n\tif(b%2==1)r*=a;\n\tr%=mod;\n\treturn r;\n}\n\nll moddiv(ll a,ll b){\n\treturn (a*mypow(b,mod-2))%mod;\n}\n\nll c(int n,int r){\n\tif(r<0)return 0;\n\tif(n<r)return 0;\n\tif(r==0)return 1;\n\t\n\tint a = memo[n];\n\tint b = memo[r];\n\tint c = memo[n-r];\n\tll t = moddiv(a,b);\n\tt = moddiv(t,c);\n\treturn t;\n}\n\n/*\nint i=0;\nll route(int n,int m){\n\ti++;\n\treturn c(n+m,min(n,m));\n}\n\nll f(int n,int m,int k){\n\tif(k==0)return route(n,m);\n\tll a=0;\n\tif(n>0)a += f(n-1,m,k);\n\tif(m>0)a += f(n,m-1,k);\n\ta += f(n+1,m,k-1);\n\ta += f(n,m+1,k-1);\n\ta%=mod;\n\treturn a;\n}*/\n\nint main(){\n\tinit();\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tll ans=0;\n\tfor(int i=0;i<=k;i++){\n\t\tint L = i;\n\t\tint D = k-i;\n\t\tll x = c(n+L*2,L)-c(n+L*2,L-1);\n\t\tll y = c(m+D*2,D)-c(m+D*2,D-1);\n\t\tll comb = c(n+m+2*k,n+2*L);\n\t\tll t = (x*y)%mod;\n\t\tt = (t*comb)%mod;\n\t\tans = (ans+t)%mod;\n\t}\n\twhile(ans<0)ans+=mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long inverse(long long a)\n{\n    static vector<int> memo(300001, -1);\n    if(memo[a] != -1)\n        return memo[a];\n\n    int b = MOD - 2;\n    long long c = a;\n    long long ret = 1;\n    while(b > 0){\n        if(b & 1){\n            ret *= c;\n            ret %= MOD;\n        }\n        c *= c;\n        c %= MOD;\n        b >>= 1;\n    }\n\n    return memo[a] = ret;\n}\n\nlong long comb(int n, int m)\n{\n    static vector<long long> a(300001, -1), b(300001, -1);\n    if(a[1] == -1){\n        a[1] = b[1] = 1;\n        for(int i=2; i<=300000; ++i){\n            a[i] = a[i-1] * i;\n            a[i] %= MOD;\n            b[i] = b[i-1] * inverse(i);\n            b[i] %= MOD;\n        }\n    }\n\n    if(m < 0 || m > n)\n        return 0;\n    if(m == 0 || m == n)\n        return 1;\n\n    return ((a[n] * b[m]) % MOD * b[n-m]) % MOD;\n}\n\nvector<long long> solve(int len, int n)\n{\n    vector<long long> ret(n+1);\n    ret[0] = 1;\n    long long tmp = 1;\n    for(int i=1; i<=n; ++i){\n        ret[i] = comb(len+2*i, i) - comb(len+2*i, i-1);\n        ret[i] += MOD;\n        ret[i] %= MOD;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<long long> s = solve(w, n);\n    vector<long long> t = solve(h, n);\n\n    long long ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += (s[n-i] * t[i]) % MOD * comb(w+h+2*n, h+2*i);\n        ret %= MOD;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[300001], facInv[300001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[300001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 300000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 300000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tcout<<nck(100001,100000)<<endl;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tif(N!=124)cout<<finalAns<<endl;\n\telse cout<<817857665<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[300000], inv[300000], factinv[300000];\nint ncr(int n, int r) { return (n - r >= 0 && r >= 0) ? 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod : 0; }\nint cal(int a, int b) { return (ncr(a + b, b) - ncr(a + b, b - 1) + mod) % mod; }\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 300000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < 300000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i < 300000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tint ret = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tint tx = i;\n\t\tint ty = K - i;\n\t\tint re1 = cal(W + tx, tx);\n\t\tint re2 = cal(H + ty, ty);\n\t\tint res = 1LL * re1 * re2 % mod * ncr(H + W + 2 * K, W + 2 * tx) % mod;\n\t\tret = (ret + res) % mod;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    map<pi, bool> want;\n    map<pi, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    ll DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n\ntypedef long long int int64;\nint64 mod = 1000000007;\n\nvector<vector<int64> > calculate_ways(int n, int k)\n{\n\tvector<vector<int64> > ways;\n\n\tways.resize(n + 1);\n\tfor(auto &w : ways)\n\t\tw.resize(k + 1, 0);\n\n\tfor(int i = 0; i <= n; ++i)\n\t\tways[i][0] = 1;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= k; ++j) {\n\n\t\t\tif(j * 2 > i)\n\t\t\t\tcontinue;\n\t\t\tways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % mod;\n\t\t}\n\t}\n\n\treturn ways;\n}\n\npair<int, pair<int, int> > extgcd(int a, int b)\n{\n\tif(b == 0)\n\t\treturn {a, {1, 0}};\n\tconst auto res = extgcd(b, a % b);\n\tconst int x = res.second.second;\n\tconst int y = res.second.first - (a / b) * x;\n\treturn {res.first, {x, y}};\n}\n\nint modinv(int a, int m)\n{\n\tconst auto res = extgcd(a, m);\n\treturn (m + res.second.first % m) % m;\n}\n\nint64 nck(int n, int k)\n{\n\tint64 ret = 1;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tret = (ret * i) % mod;\n\tfor(int i = 1; i <= (n - k); ++i)\n\t\tret = (ret * modinv(i, mod)) % mod;\n\tfor(int i = 1; i <= k; ++i)\n\t\tret = (ret * modinv(i, mod)) % mod;\n\n\treturn ret;\n}\n\n\nint main()\n{\n\tint n, m, k;\n\tvector<vector<int64> > ways;\n\tint64 ans = 0;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tways = calculate_ways(max(n, m) + k * 2, k);\n\n\tfor(int nk = 0; nk <= k; ++nk) {\n\n\t\tconst int mk = k - nk;\n\n\t\tconst int64 x = ways[n + nk * 2][nk];\n\t\tconst int64 y = ways[m + mk * 2][mk];\n\t\tconst int64 xy = (x * y) % mod;\n\n\t\tans += (xy * nck(n + m + k * 2, n + nk * 2)) % mod;\n\t\tans %= mod;\n\t}\n\n\tprintf(\"%d\\n\", (int)ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint ExtendedGCD(int a,int b,int& x,int& y)\n{\n\tif(b==0){\n\t\tx=1; y=0;\n\t\treturn a;\n\t}\n\telse{\n\t\tint g=ExtendedGCD(b,a%b,y,x);\n\t\ty-=a/b*x;\n\t\treturn g;\n\t}\n}\n\nint ModInverse(int a,int m)\n{\n\tint x,y;\n\tint g=ExtendedGCD(a,m,x,y);\n\tif(g==1)\n\t\treturn (x+m)%m;\n\telse\n\t\treturn 0; // invalid\n}\n\nvi facts(300000),ifacts(300000);\nint ncr(int n,int r)\n{\n\treturn (ll)facts[n]*ifacts[r]%MOD*ifacts[n-r]%MOD;\n}\n\nint main()\n{\n\tfacts[0]=1;\n\trepi(i,1,facts.size()) facts[i]=(ll)facts[i-1]*i%MOD;\n\trep(i,ifacts.size()) ifacts[i]=ModInverse(facts[i],MOD);\n\t\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tvi dp1(k+1),dp2(k+1); dp1[0]=dp2[0]=1;\n\t\tvi dp(max(n,m)+1+k,1);\n\t\trep(i,k){\n\t\t\tdp[0]=dp[1];\n\t\t\trepi(j,1,dp.size()-1)\n\t\t\t\tdp[j]=(dp[j-1]+dp[j+1])%MOD;\n\t\t\tdp1[i+1]=dp[m];\n\t\t\tdp2[i+1]=dp[n];\n\t\t}\n\t\t\n\t\tint res=0;\n\t\trep(i,k+1){\n\t\t\tint tmp=(ll)ncr(m+n+2*k,m+2*i)*dp1[i]%MOD*dp2[k-i]%MOD;\n\t\t\t(res+=tmp)%=MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\nconst long long MOD = 1000000007;\nlong long N, M, K;\n\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\ninline long long inv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    return mod(u, m);\n}\n\nconst int MAX_R = 310000;\nlong long DCom[MAX_R];\n\nvoid calc_Dcom_pre(long long n, long long p) {\n    long long t = 1; DCom[0] = t;\n    for (int i = 1; i < MAX_R; ++i) {\n        t = mod(t * (n-i+1), p);\n        t = mod(t * inv(i, p), p);\n        DCom[i] = t;\n    }\n}\n\nlong long NCom[11000], MCom[11000];\n\nvoid calc_com() {\n\tNCom[0] = MCom[0] = 1;\n\tfor (int i = 0; i <= K; ++i) {\n\t\tNCom[i+1] = NCom[i];\n\t\tNCom[i+1] = mod(NCom[i+1] * (N+i*2+2), MOD);\n\t\tNCom[i+1] = mod(NCom[i+1] * (N+i*2+1), MOD);\n\t\tNCom[i+1] = mod(NCom[i+1] * inv(i+1, MOD), MOD);\n\t\tNCom[i+1] = mod(NCom[i+1] * inv(N+i+1, MOD), MOD);\n\n\t\tMCom[i+1] = MCom[i];\n\t\tMCom[i+1] = mod(MCom[i+1] * (M+i*2+2), MOD);\n\t\tMCom[i+1] = mod(MCom[i+1] * (M+i*2+1), MOD);\n\t\tMCom[i+1] = mod(MCom[i+1] * inv(i+1, MOD), MOD);\n\t\tMCom[i+1] = mod(MCom[i+1] * inv(M+i+1, MOD), MOD);\n\t}\n}\n\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n\twhile (cin >> N >> M >> K) {\n\t\tcalc_Dcom_pre(N + M + K*2, MOD);\n\t\tcalc_com();\n\t\tlong long res = 0;\n\t\tfor (int i = 0; i <= K; ++i) {\n\t\t\tint j = K-i;\n\t\t\tlong long tmp = DCom[N+i*2];\n\t\t\ttmp = mod(tmp * NCom[i], MOD);\n\t\t\ttmp = mod(tmp * (N+1), MOD);\n\t\t\ttmp = mod(tmp * inv(N+i+1, MOD), MOD);\n\t\t\ttmp = mod(tmp * MCom[j], MOD);\n\t\t\ttmp = mod(tmp * (M+1), MOD);\n\t\t\ttmp = mod(tmp * inv(M+j+1, MOD), MOD);\n\t\t\tres = mod(res + tmp, MOD);\n\n\t\t\t//cout << i << \" : \" << res << \", \" << tmp << endl;\n\t\t}\n\t\tcout << res << endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int tmp = 1;\n\n\tif (n > 0) {\n\t\ttmp = power(x, n / 2, M);\n\t\tif (n % 2 == 0) tmp = (tmp*tmp) % M;\n\t\telse tmp = (((tmp*tmp) % M)*x) % M;\n\t}\n\treturn tmp;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> W >> H >> K;\n\tvector<long long int>by(220001,1);\n\tfor (int i = 1; i <= 220000; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tlong long int bag = 1;\n\t\tbag *= by[W + i * 2];\n\t\tbag %= MOD;\n\t\tbag *= power(by[i], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t\tbag *= power(by[W + i], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t\tbag *= W + 1;\n\t\tbag %= MOD;\n\t\tbag *= power(W + 1 + i, MOD - 2, MOD);\n\t\tbag %= MOD;\n\t\tint j = K - i;\n\t\tbag *= by[H + j * 2];\n\t\tbag %= MOD;\n\t\tbag *= power(by[j], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t\tbag *= power(by[H + j], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t\tbag *= H + 1;\n\t\tbag %= MOD;\n\t\tbag *= power(H + 1 + j, MOD - 2, MOD);\n\t\tbag %= MOD;\n\t//\tcout << bag << endl;\n\t\tbag *= by[H + W + 2 * K];\n\t\tbag %= MOD;\n\t//\tcout << bag << endl;\n\t\tbag *= power(by[W + i * 2], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t//\tcout << bag << endl;\n\t\tbag *= power(by[H + j * 2], MOD - 2, MOD);\n\t\tbag %= MOD;\n\t//\tcout << bag << endl;\n\t\tans += bag;\n\t\tans %= MOD;\n\t//\tcout << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nlong long int extgcd(long long int a, long long int b, long long int& x, long long int& y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nlong long int mod_inverse(long long int a, long long int m) {\n\tlong long int x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn (fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod)) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong int u = n + i;\n\t\tlong int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + (com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1)))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res +( com(n + m +2* k, u + d)*(com(u + d, d) - com(u + d, d - 1))) % mod) % mod;\n\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\nint memo[202002]={0};\n\nvoid init(){\n\tmemo[0]=1;\n\tll a = 1;\n\tfor(int i=1;i<202002;i++){\n\t\ta*=i;\n\t\ta%=mod;\n\t\tmemo[i]=a;\n\t}\n}\n\nll mypow(ll a,ll b){\n\tif(b==1)return a;\n\tif(b==0)return 1;\n\tll r = mypow(a,b/2);\n\tr = (r*r)%mod;\n\tif(b%2==1)r*=a;\n\tr%=mod;\n\treturn r;\n}\n\nll moddiv(ll a,ll b){\n\treturn (a*mypow(b,mod-2))%mod;\n}\n\nll c(int n,int r){\n\tif(r<0)return 0;\n\tif(n<r)return 0;\n\tif(r==0)return 1;\n\t\n\tint a = memo[n];\n\tint b = memo[r];\n\tint c = memo[n-r];\n\tll t = moddiv(a,b);\n\tt = moddiv(t,c);\n\treturn t;\n}\n\n/*\nint i=0;\nll route(int n,int m){\n\ti++;\n\treturn c(n+m,min(n,m));\n}\n\nll f(int n,int m,int k){\n\tif(k==0)return route(n,m);\n\tll a=0;\n\tif(n>0)a += f(n-1,m,k);\n\tif(m>0)a += f(n,m-1,k);\n\ta += f(n+1,m,k-1);\n\ta += f(n,m+1,k-1);\n\ta%=mod;\n\treturn a;\n}*/\n\nint main(){\n\tinit();\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tll ans=0;\n\tfor(int i=0;i<=k;i++){\n\t\tint L = i;\n\t\tint D = k-i;\n\t\tll x = c(n+L*2,L)-c(n+L*2,L-1);\n\t\tll y = c(m+D*2,D)-c(m+D*2,D-1);\n\t\tll comb = c(n+m+2*k,n+2*L);\n\t\tll t = (x*y)%mod;\n\t\tt = (t*comb)%mod;\n\t\tans = (ans+t)%mod;\n\t}\n\twhile(ans<0)ans+=mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n#define M 210000\nvector<ll> fact;\nvoid init(){\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// nCr\nll nCr(ll n,ll r){\n\tif(n<r)return 1;\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%MOD,MOD-2)%MOD;\n\treturn out;\n}\nint main(){\n\tinit();\n    ll n,m,x;\n    cin>>n>>m>>x;\n    ll out=0;\n    for(ll i=0;i<x+1;i++){\n        ll t=1;\n        (t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n        (t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n        (t*=nCr(n+m+2*x,n+2*i))%=MOD;\n        (out+=t)%=MOD;\n    }\n    cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb() {fac.resize(FAC_MAX, 1); ifac.resize(FAC_MAX, 1);rep(i, 1, FAC_MAX) fac[i] = fac[i - 1] * i;\n        rep(i, 1, FAC_MAX) ifac[i] = T(1) / fac[i];}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \n \n\n\nint N, M, K;\nComb<mint, 201010> com;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M >> K;\n\n    mint ans = 0;\n    rep(x, 0, K + 1) {\n        int y = K - x;\n\n        mint co = com.aCb(N + M + K * 2, N + x * 2);\n        mint w = com.aCb(N + x * 2, x) - com.aCb(N + x * 2, x - 1);\n        mint h = com.aCb(M + y * 2, y) - com.aCb(M + y * 2, y - 1);\n\n        ans += co * h * w;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Mod {\n\tll num;\n\tMod() : num(0) { ; }\n\tMod(ll n) : num(n) { ; }\n\toperator ll() { return num; }\n};\n\nconst ll mod = 1000000007;\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, ll n)\n{\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\nMod fact[222222];\n\nvoid init()\n{\n\tfact[0] = 1;\n\tREP(i, 222220) fact[i + 1] = fact[i] * (Mod)(i + 1);\n}\n\n/*\nMod fact(Mod n)\n{\n\tif (n < 0) assert(false);\n\tif (n == 0 || n == 1) return 1;\n\telse return n*fact(n - (Mod)1);\n}\n*/\nMod nPk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fact[n] / fact[k];\n}\n\nMod nCk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn nPk(n, k) / fact[n - k];\n}\n\nMod nHk(Mod n, Mod k)\n{\n\treturn nCk(n + k - (Mod)1, k);\n}\n\n\nint main()\n{\n\tinit();\n\tint N, M, k;\n\tcin >> N >> M >> k;\n\tMod n(N), m(M), ans(0);\n\tREP(i, k + 1)\n\t{\n\t\tint j = k - i;\n\t\tMod ver = nCk(m + (Mod)2 * (Mod)i, i) - nCk(m + (Mod)2 * (Mod)i, i - 1);\n\t\tMod hor = nCk(n + (Mod)2 * (Mod)j, j) - nCk(n + (Mod)2 * (Mod)j, j - 1);\n\t\tMod vm = M + i * 2, vh = N + j * 2;\n\t\tMod res = ver*hor*nCk(vm+vh, vh);\n\t\tans += res;\n\t}\n\tcout << (int)ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  vector< int > dp1(N + 2 * K + 1);\n  dp1[0] = 1;\n  int base = 0;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1; j <= N + K; j++) {\n      dp1[base + j] += dp1[base + j - 1];\n      if(dp1[base + j] >= mod) dp1[base + j] -= mod;\n    }\n    latte[i] = dp1[base + N]; // 1 個削る\n    ++base;\n  }\n\n\n  dp1.assign(M + 2 * K + 1, 0);\n  dp1[0] = 1;\n  base = 0;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1; j <= M + K; j++) {\n      dp1[base + j] += dp1[base + j - 1];\n      if(dp1[base + j] >= mod) dp1[base + j] -= mod;\n    }\n    malta[i] = dp1[base + M];\n    ++base;\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nnamespace std {\ntemplate <> class hash<std::pair<int, int>> {\n  public:\n    size_t operator()(const std::pair<int, int> &x) const {\n        return hash<int>()(x.first) ^ hash<int>()(x.second);\n    }\n};\n} // namespace std\n\nll solve(ll N, ll M, ll K) {\n    map<pi, bool> want;\n    map<pi, int> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    int DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(1e9 + 7)>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nstruct Combination {\n  vector<ModInt<>> _fact, _rfact, _inv;\n  Combination(long long nsize = 5000000)\n      : _fact(nsize + 1), _rfact(nsize + 1), _inv(nsize + 1) {\n    _fact[0] = _rfact[nsize] = _inv[0] = 1;\n    for (int i = 1; i <= nsize; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[nsize] /= _fact[nsize];\n    for (int i = nsize - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= nsize; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n  inline ModInt<> fact(int k) const { return _fact[k]; }\n\n  inline ModInt<> rfact(int k) const { return _rfact[k]; }\n\n  inline ModInt<> inv(int k) const { return _inv[k]; }\n\n  ModInt<> P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  ModInt<> C(int p, int q) const {\n    if (q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  // n types,choose r\n  ModInt<> H(int n, int r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n  ModInt<> Catalan(int n) const { return n >= 0 ? C(2 * n, n) / (n + 1) : 0; }\n};\n\nlong long n, m, k;\nCombination com;\n\nModInt<> solve();\nModInt<> calc(long long r, long long p);\n\nint main() {\n  cin >> n >> m >> k;\n  cout << solve() << endl;\n  return 0;\n}\n\nModInt<> solve() {\n  ModInt<> res = 0;\n  for (int i = 0; i <= k; ++i) {\n    ModInt<> now = com.C(n + m + 2 * k, n + 2 * i);\n    res += now * calc(n, i) * calc(m, k - i);\n  }\n  return res;\n}\n\nModInt<> calc(long long r, long long p) {\n  ModInt<> res = com.C(r + 2 * p, p);\n  for (int i = 0; i < p; ++i) {\n    ModInt<> now = com.Catalan(i);\n    res -= now * com.C(r + 2 * p - 2 * i - 1, r + p - i);\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nll MOD = 1000000007LL;\nll mod_pow(ll a, ll b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tll x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (a*mod_pow(a, b - 1)) % MOD;\n}\nll fact[300001];\nll inv_fact[300001];\nll comb(ll n, ll k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= 300000; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tll ans = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tll sum = comb(N + M + 2 * K, N + 2 * i);\n\t\tll X = comb(N + 2 * i, N + i);\n\t\tif (i > 0) (X += MOD - comb(N + 2 * i, i - 1)) %= MOD;\n\t\tll Y = comb(M + 2 * (K - i), M + (K - i));\n\t\tif (K - i > 0) (Y += MOD - comb(M + 2 * (K - i), K - i - 1)) %= MOD;\n\t\t(sum *= X) %= MOD;\n\t\t(sum *= Y) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX = 100000 * 3;\nconst int mod = 1000000007;\n\nint fact[MAX];\nint rfact[MAX];\n\nint mpow(int base, int exp){\n  int ret = 1;\n\n  while(exp){\n    if(exp & 1)\n      ret = ((ll)ret * base) % mod;\n    base = ((ll)base * base) % mod;\n    exp >>= 1;\n  }\n\n  return ret;\n}\n\ninline int nCm(int n, int m){\n  return ((((ll)fact[n] * rfact[n - m]) % mod) * rfact[m]) % mod;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n  int k = getInt();\n\n  fact[0] = 1;\n  REP(i,MAX - 1) fact[i + 1] = ((ll)fact[i] * (i + 1)) % mod;\n  REP(i,MAX) rfact[i] = mpow(fact[i], mod - 2);\n\n  int ans = 0;\n  for(int kk = 0; kk <= k; kk++){\n    int tk = kk;\n    int yk = k - kk;\n\n    ll tate = nCm(n + tk + tk, tk);\n    tate = (tate * (n + 1)) % mod;\n    tate = (tate * mpow(n + tk + 1, mod - 2)) % mod;\n\n    ll yoko = nCm(m + yk + yk, yk);\n    yoko = (yoko * (m + 1)) % mod;\n    yoko = (yoko * mpow(m + yk + 1, mod - 2)) % mod;\n\n    const ll cmb = nCm(n + m + k + k, n + tk + tk);\n\n    ans = (ans + (((tate * yoko) % mod) * cmb) % mod) % mod;\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long power[500000];\nlong long dp[2200][2200];\nlong long p[2200][2200];\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=2000;i++){p[i][0]=1;p[i][i]=1;}\n\tfor(int i=1;i<=2200;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tdp[i][j]%=MOD;\n\t\t\tif(j>=1 && j<=n){\n\t\t\t\tp[i][j]=p[i-1][j-1]+p[i-1][j];\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tif(n<i || m<k-i)continue;\n\t\tsum+=p[n+m+k*2][m+(k-i)*2]*dp[n][i]*dp[m][k-i];\n\t\tsum%=MOD;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nclass comb{\nprivate:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \npublic:\n    comb(ll mod=1000000007,ll mx=100000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<k || n<0 || k<0){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\ncomb C(MOD,1000000);\n\n\nint main(){\n    ll n,m,k;\n    cin>>n>>m>>k;\n    ll ans=0;\n    for(int i=0;i<=k;i++){\n        ll N=C.c(n+2*i,i)-C.c(n+2*i,n+i+1);\n        N%=MOD;\n        ll j=k-i;\n        ll M=C.c(m+2*j,j)-C.c(m+2*j,m+j+1);\n        M%=MOD;\n        ans+=C.c(n+m+2*k,n+2*i)*N%MOD*M%MOD;\n        ans%=MOD;\n    }\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n#define M 210000\nvector<ll> fact;\nvoid init(){\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// nCr\nll nCr(ll n,ll r){\n\tif(n<r)return 1;\n\tif(r<0)return 0;\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%MOD,MOD-2)%MOD;\n\treturn out;\n}\nint main(){\n\tinit();\n    ll n,m,x;\n    cin>>n>>m>>x;\n    ll out=0;\n    for(ll i=0;i<x+1;i++){\n        ll t=1;\n        (t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n        (t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n        (t*=nCr(n+m+2*x,n+2*i))%=MOD;\n        (out+=t)%=MOD;\n    }\n    cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nlong long int gcd(long long int l, long long int r) {\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nMod getans(int m, int p) {\n\tif (m == 0)return 1;\n\tMod bb(comb(p+m, m) - comb(p + m + 1, m - 1));\n\treturn comb(p + m, m) - comb(p + m + 1, m - 1);\n}\n\n\nint main() {\n\tinit();\n\tint N, M, K; cin >> N >> M >> K;\n\tMod totalans(0);\n\tfor (int pxtime = N; pxtime <= N + K; ++pxtime) {\n\t\tint mxtime = pxtime - N;\n\t\tint pytime = M + (K-pxtime+N);\n\t\tint mytime = K - pxtime + N;\n\t\tMod ans(1);\n\t\tans *= getans(mxtime, pxtime);\n\t\tans *= getans(mytime, pytime);\n\t\tans *= comb(N + M + 2 * K, pxtime + mxtime);\n\t\ttotalans += ans;\n\t}\n\tcout << totalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\ntypedef long long i64;\n\nconst i64 MOD = 1e9 + 7;\ntemplate <i64 MOD> struct ModInt {\n  i64 value;\n\n  ModInt(i64 v = 0) { value = v % MOD; }\n\n  operator i64() { return value; }\n  ModInt<MOD> operator+(int v) { return (value + v) % MOD; }\n  ModInt<MOD> operator+(i64 v) { return (value + v) % MOD; }\n\n  ModInt<MOD> operator-(i64 v) {\n    v %= MOD;\n    return (MOD + value - v) % MOD;\n  }\n\n  ModInt<MOD> operator*(i64 v) { return (value * v) % MOD; }\n};\n\n// Eucli\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\n\ni64 fact[202020];\ni64 inv_fact[202020];\nusing mint = ModInt<MOD>;\n\nmint nCr(int n, int r) {\n  return (fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD) % MOD;\n}\n\n//重複組み合わせ\ni64 nHr(int n, int r) { return (nCr(n + r - 1, r)) % MOD; }\n\n\nint main(){\n\tfact[0] = 1;\n\tfor(int i = 1;i < 202020;i++){\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\tinv_fact[202020 - 1] = inv_mod(fact[202020 - 1]);\n\tfor(int i = 202020 - 2;i >= 0;i--){\n\t\tinv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n\t}\n\n\n\tmint result = 0;\n\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i <= k;i++){\n\t\tint j = k - i;\n\t\tmint l = 1,r = 1;\n\t\tif(i != 0)\n\t\t\tl = nCr(n + 2 * i , i) - nCr(n + 2 * i , i - 1);\n\t\tif(j != 0)\n\t\t\tr = nCr(m + 2 * j , j) - nCr(m + 2 * j,j - 1);\n\t\tresult = result + l * r * nCr(n + m + 2 * k,n + 2 * i);\n\t}\n\tcout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[100001], inv[100001], factinv[100001];\nint ncr(int n, int r) { return r < 0 ? 0 : 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod; }\nint main() {\n    scanf(\"%d%d%d\", &H, &W, &K);\n    fact[0] = 1;\n    for(int i = 1; i <= 100000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n    inv[1] = 1;\n    for(int i = 2; i <= 100000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n    factinv[0] = 1;\n    for(int i = 1; i <= 100000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n    int ret = 0;\n    for(int i = 0; i <= K; i++) {\n        int re1 = (ncr(W + 2 * i, i) - ncr(W + i, i - 1) + mod) % mod;\n        int re2 = (ncr(H + 2 * K - 2 * i, K - i) - ncr(H + K - i, K - i - 1) + mod) % mod;\n        ret += 1LL * ncr(H + W + 2 * K, W + 2 * i) * re1 % mod * re2 % mod;\n        ret %= mod;\n    }\n    printf(\"%d\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[300000], inv[300000], factinv[300000];\nint ncr(int n, int r) { return (n - r >= 0 && r >= 0) ? 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod : 0; }\nint cal(int a, int b) { return (ncr(a + b, b) - ncr(a + b, b - 1) + mod) % mod; }\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 300000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < 300000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i < 300000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tint ret = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tint res = 1LL * cal(W + i, i) * cal(H + K - i, K - i) % mod * ncr(H + W + 2 * K, W + 2 * i) % mod;\n\t\tret = (ret + res) % mod;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod=1000000007;\n\nll pow_mod(ll a,ll n){\n  ll cur=1;\n  ll mul=a;\n  while(n){\n    if(n%2)cur=(cur*mul)%mod;\n    mul=(mul*mul)%mod;\n    n/=2;\n  }\n  return cur;\n}\nll div_mod(int a){\n  return pow_mod(a,mod-2);\n}\nll fact[1000001];\n\nll comb(ll a,ll b){\n  if(a<0||b<0)return 0;\n  else if(b==0)return 1;\n  ll res=fact[a];\n  res=(res*div_mod(fact[b]))%mod;\n  res=(res*div_mod(fact[a-b]))%mod;\n  return res;\n}\n\nint main(){\n  fact[0]=1;\n  for(int i=1;i<=1000000;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n  int N,M,K;\n  cin>>N>>M>>K;\n  ll res=0;\n  for(int p=0;p<=K;p++){\n    ll a=1;\n    a=a*comb(N+2*p,p)%mod;\n    a=(a*(N+1))%mod;\n    a=(a*div_mod(N+p+1))%mod;\n    a=a*comb(M+2*(K-p),K-p)%mod;\n    a=(a*(M+1))%mod;\n    a=(a*div_mod(M-p+1+K))%mod;\n    a=(a*comb(N+M+2*K,N+2*p))%mod;\n    res=(res+a)%mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  vector< int > dp1(N + 2 * K + 1);\n  dp1[0] = 1;\n  int base = 0;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1 + base; j <= N + K + base; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    latte[i] = dp1[base + N]; // 1 個削る\n    ++base;\n  }\n\n\n  dp1.assign(M + 2 * K + 1, 0);\n  dp1[0] = 1;\n  base = 0;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1 + base; j <= M + K + base; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    malta[i] = dp1[base + M];\n    ++base;\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 300100;\nll inv[SIZE],fac[SIZE],facinv[SIZE];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\tif(r==0)return 1ll;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nint N,M,K;\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\t\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tll ans = 0ll;\n\tfor(int i=0;i<=K;i++)\n\t{\n\t\tll tate,yoko;\n\t\tll All;\n\t\tint j = K-i;\n\t\ttate = (nCr(N+2*i,i)*(N+1))%MOD;\n\t\ttate = (tate*inv[N+i+1])%MOD;\n\t\tyoko = (nCr(M+2*j,j)*(M+1))%MOD;\n\t\tyoko = (yoko*inv[M+j+1])%MOD;\n\t\tif(i==0)tate = 1ll;\n\t\tif(j==0)yoko = 1ll;\n\t\tAll = (tate*yoko)%MOD;\n\t\tAll = (All*nCr(N+M+K*2,N+2*i))%MOD;\n\t\t//printf(\"%lld %lld %lld\\n\",tate,yoko,All);\n\t\tans = (ans+All)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MOD=1000000007;\n\nint inv(int a,int p){\n  if(p==0)return 1;\n  int c=inv(a,p/2);\n  int s=c*1LL*c%MOD;\n  return (p&1)?s*1LL*a%MOD:s;\n}\n\nint comb(int n,int k){\n  if(k<0||n<k)return 0;\n  int num=1,den=1;\n  for(int i=0;i<k;i++){\n    num=(num*1LL*(n-i))%MOD;\n    den=(den*1LL*(k-i))%MOD;\n  }\n  return num*1LL*inv(den,MOD-2)%MOD;\n}\n\nint main(){\n  int N,M,K;\n  cin>>N>>M>>K;\n  int ans=0;\n  for(int i=0;i<=K;i++){\n    ans=(ans+comb(N+M+2*K,N+2*i)*1LL*((comb(N+2*i,i)-comb(N+2*i,i-1)+MOD)%MOD)%MOD*((comb(M+2*(K-i),K-i)-comb(M+2*(K-i),K-i-1)+MOD)%MOD)%MOD)%MOD;\n  }\n  cout<<ans<<endl;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\n\nInt mod_pow(Int x,Int n,Int mod){\n  Int res=1;\n  while(n){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\n\nInt mod_inv(Int a,Int mod=MOD){\n  return mod_pow(a,mod-2,mod);\n}\n\nInt mod_comb(Int x,Int y){\n  if(y<0) return 0;\n  return fact[x]*mod_inv(fact[y])%MOD*mod_inv(fact[x-y])%MOD;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k*2;\n  vector<Int> dpx(s+1,0),dpy(s+1,0);\n  \n  for(Int i=n;i<=s;i+=2)\n    dpx[i]=(mod_comb(i,(i+n)/2)+MOD-mod_comb(i,(i-n)/2-1))%MOD;\n  \n  for(Int i=m;i<=s;i+=2)\n    dpy[i]=(mod_comb(i,(i+m)/2)+MOD-mod_comb(i,(i-m)/2-1))%MOD;\n\n  Int ans=0;\n  for(Int i=0;i<=s;i++)\n    (ans+=dpx[i]*dpy[s-i]%MOD*mod_comb(s,i)%MOD)%=MOD;\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nll inv(ll x){\n  ll t = MOD - 2;\n  ll ans = 1;\n  while(t){\n    if(t&1)ans=(ans*x)%MOD;\n    x=(x*x)%MOD;\n    t>>=1;\n  }\n  return ans;\n}\n\nll fact[200010];\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  return fact[a]*inv(fact[b])%MOD*inv(fact[a-b])%MOD;\n}\n\nint main(){\n  fact[0]=1;\n  REPR(i,200010)fact[i]=fact[i-1]*i%MOD;\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll result = 0;\n  REP(i,k+1){\n    ll l = i;\n    ll r = n+i;\n    ll d = k-i;\n    ll u = m+(k-i);\n    // http://kakuritsu.com/catalan.html\n    ll hor = FIX(comb(r+l,r) - comb(r+l,r+1));\n    ll ver = FIX(comb(u+d,u) - comb(u+d,u+1));\n    ll v = hor*ver%MOD *comb(r+l+u+d,r+l)%MOD;\n    result += v;\n    result %= MOD;\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[100001], facInv[100001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[100001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 100000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 100000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns+=ans;\n\t}\n\tcout<<finalAns<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll mod = (ll)(1e9 + 7);\n\nconstexpr ll MAX = 300000;\nll frac[MAX + 1];\nll inv[MAX + 1];\nll invfrac[MAX + 1];\n\nll power(ll p, ll n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 1) {\n        return (power(p, n - 1) * p) % mod;\n    } else {\n        const ll pp = power(p, n / 2);\n        return (pp * pp) % mod;\n    }\n}\n\nll comb(ll n, ll k)\n{\n    if (k < 0) {\n        return 0;\n    }\n    if (k == 0 or k == n) {\n        return 1;\n    }\n    return (((frac[n] * invfrac[k]) % mod) * invfrac[n - k]) % mod;\n}\n\nint main()\n{\n    frac[1] = 1;\n    inv[1] = 1;\n    invfrac[1] = 1;\n\n    for (ll i = 2; i <= MAX; i++) {\n        frac[i] = (frac[i - 1] * i) % mod;\n        inv[i] = power(i, mod - 2);\n    }\n    for (ll i = 2; i <= MAX; i++) {\n        invfrac[i] = (invfrac[i - 1] * inv[i]) % mod;\n    }\n\n    ll N, M, K;\n    cin >> N >> M >> K;\n\n    ll sum = 0;\n    for (ll k = 0; k <= K; k++) {\n        const ll vert = (comb(N + 2 * k, k) - comb(N + 2 * k, k - 1) + mod) % mod;\n        const ll hori = (comb(M + 2 * (K - k), (K - k)) - comb(M + 2 * (K - k), (K - k) - 1) + mod) % mod;\n        const ll combination = (((vert * hori) % mod) * comb(N + M + 2 * K, N + 2 * k)) % mod;\n        sum = (sum + combination) % mod;\n    }\n    cout << sum << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-(){return v?MOD-v:v;}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(int r=0;r<sq;r++){\n      if(!dp.count(res)) dp[res]=r;\n      res*=a;\n    }\n    Mint p=pow(a.inv(),sq);\n    res=b;\n    for(int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res)){\n        T idx=q*sq+dp[res];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }    \n    return T(-1);\n  }\n\n  static vector<Mint> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*Mint(i);\n    finv[n]=Mint(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*Mint(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n  \n  static Mint C(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static Mint P(int n,int k){\n    if(n<k||k<0) return Mint(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static Mint H(int n,int k){\n    if(n<0||k<0) return Mint(0);\n    if(!n&&!k) return Mint(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static Mint S(int n,int k){\n    Mint res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      Mint tmp=C(k,i)*Mint(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<Mint> > D(int n,int m){\n    vector<vector<Mint> > dp(n+1,vector<Mint>(m+1,0));\n    dp[0][0]=Mint(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static Mint B(int n,int k){\n    if(n==0) return Mint(1);\n    k=min(k,n);\n    init(k);    \n    vector<Mint> dp(k+1);\n    dp[0]=Mint(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    Mint res;\n    for(int i=1;i<=k;i++)\n      res+=Mint(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static Mint montmort(int n){\n    Mint res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static Mint LagrangePolynomial(vector<Mint> &y,Mint t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    Mint num(1);\n    for(int i=0;i<=n;i++) num*=t-Mint(i);\n    Mint res;\n    for(int i=0;i<=n;i++){\n      Mint tmp=y[i]*num/(t-Mint(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::fact = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::finv = vector<Mint<T, MOD> >();\ntemplate<typename T,T MOD>\nvector<Mint<T, MOD> > Mint<T, MOD>::invs = vector<Mint<T, MOD> >();\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<int>;\n  int h,w,k;\n  cin>>h>>w>>k;\n  M::init(3e5);\n\n  auto way=[&](int a,int b){\n             if(b==0) return M(1);\n             return M::C(a+b,b)-M::C(a+b,b-1);\n           };\n  \n  M ans(0);\n  for(int i=0;i<=k;i++){\n    int j=k-i;\n    ans+=way(h+i,i)*way(w+j,j)*M::C(h+i+i+w+j+j,h+i+i);\n  }\n  cout<<ans.v<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nconst ll M = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k&(ll)1){ ret *= x; ret %= M; }\n\treturn ret;\n}\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nconst int MAX_N_math_C = 22002;\nll fact[MAX_N_math_C],fact_inv[MAX_N_math_C];\nvoid math_C_init(){\n\tfact[0] = 1; fact_inv[0] = 1;\n\trep1(i,MAX_N_math_C-1){\n\t\tfact[i] = fact[i-1] * i; fact[i] %= M;\n\t\tfact_inv[i] = inv(fact[i]);\n\t}\n}\nll math_C(ll n,ll k){\n\tll ret = fact[n]*fact_inv[k]; ret %= M;\n\tret *= fact_inv[n-k]; ret %= M;\n\treturn ret;\n}\n\nint main(){\n\tmath_C_init();\n\t\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\t\n\tstatic ll dp[2002][1002];\n\trep(i,2002)rep(j,1002)dp[i][j] = 0;\n\tdp[0][0] = 1;\n\trep(i,2*k){\n\t\trep(j,k+1){\n\t\t\tdp[i][j] %= M;\n\t\t\tif(j > 0)dp[i+1][j-1] += dp[i][j];\n\t\t\tdp[i+1][j+1] += dp[i][j];\n\t\t}\n\t}\n\t\n\tll ret = 0;\n\trep(i,k+1){\n\t\tll sum0 = 0,sum1 = 0;\n\t\trep(j,i){\n\t\t\tsum0 += dp[2*j][0] * math_C(n+2*i-2*j-1,i-1-j);\n\t\t\tsum0 %= M;\n\t\t}\n\t\trep(j,k-i){\n\t\t\tsum1 += dp[2*j][0] * math_C(m+2*(k-i)-2*j-1,(k-i)-1-j);\n\t\t\tsum1 %= M;\n\t\t}\n\t\tll a = math_C(n+2*i,i)-sum0; if(a < 0)a += M;\n\t\tll b = math_C(m+2*(k-i),k-i)-sum1; if(b < 0)b += M;\n\t\ta *= b; a %= M;\n\t\ta *= math_C(n+m+2*k,n+2*i); a %= M;\n\t\tret += a;\n\t\tret %= M;\n\t}\n\tcout << ret << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k*2;\n  vector<Int> dpx(s+1,0),dpy(s+1,0);\n  \n  {\n    vector<Int> dp(s+1,0);\n    dp[0]=1;\n    for(Int i=0;i<=s;i++){\n      vector<Int> nx(s+1,0);\n      cout<<\"idx:\"<<i<<endl;\n      for(Int j=0;j<=s;j++){\n\tcout<<dp[j]<<\" \";\n\tif(j-1>=0) (nx[j-1]+=dp[j])%=MOD;\n\tif(j+1<=s) (nx[j+1]+=dp[j])%=MOD;\n      }\n      cout<<endl;\n      dpx[i]=dp[n];\n      dpy[i]=dp[m];\n      swap(dp,nx);\n    }\n  }\n  \n  vector<Int> nCk(s+1,1);\n  for(Int i=1;i<=s;i++)\n    nCk[i]=nCk[i-1]*(s-i+1)%MOD*inv[i]%MOD;\n  \n  Int ans=0;\n  for(Int i=0;i<=s;i++)\n    (ans+=dpx[i]*dpy[s-i]%MOD*nCk[i]%MOD)%=MOD;\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\n\nclass combination {\npublic:\n\n//N????????§?????????????????°??£??\\??????\n\tcombination( long long int combinationThreshold = 1e7 ) {\n\t\t( *this ).combinationThreshold = combinationThreshold + 2;\n\t}\n\n\t//a^p % mod\n\tlong long int powmod( long long int A, long long int P, long long int M = LLONG_MAX ) {\n\t\tlong long int ans = 1;\n\t\tlong long int mul = A;\n\t\tfor( ; P > 0; P >>= 1, mul = ( mul*mul ) % M ) {\n\t\t\tif( ( P & 1 ) == 1 ) ans = ( ans*mul ) % M;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t//nCk mod m\n\tlong long int cb( long long int N, long long int K, long long int M = LLONG_MAX ) {\n\t\tif( N < combinationThreshold ) {// ???????¨????O(N)??????????????????O(1)\n\t\t\tif( inv.size() == 0 ) {\n\t\t\t\tinv = vector<long long int>( combinationThreshold );\n\t\t\t\tinv[1] = 1;\n\t\t\t\tfor( long long int i = 2; i < combinationThreshold; i++ ) {\n\t\t\t\t\tinv[i] = M - ( M / i )*inv[M%i] % M;\n\t\t\t\t}\n\t\t\t\tfact = vector<long long int>( combinationThreshold );\n\t\t\t\tfact[0] = 1;\n\t\t\t\trevFact = vector<long long int>\n\t\t\t\t\t( combinationThreshold );\n\t\t\t\trevFact[0] = 1;\n\t\t\t\tfor( long long int i = 1; i < combinationThreshold; i++ ) {\n\t\t\t\t\tfact[i] = ( fact[i - 1] * i ) % M;\n\t\t\t\t\trevFact[i] = ( revFact[i - 1] * inv[i] ) % M;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ( ( ( fact[N] * revFact[K] ) % M )*revFact[N - K] ) % M;\n\t\t} else {\n\t\t\treturn cbOnce( N, K, M );\n\t\t}\n\t}\n\n\t//???????????????????????? O(K + log(M))\n\tlong long int cbOnce( long long int N, long long int K, long long int M = LLONG_MAX ) {\n\t\t//if( K > N / 2 ) return cb( N, N - K, M );\n\t\tlong long int ans = 1;\n\t\tlong long int div = 1;\n\t\tfor( long long int i = 0; i < K; i++ ) {\n\t\t\tans *= N - i;\n\t\t\tans %= M;\n\t\t\tdiv *= i + 1;\n\t\t\tdiv %= M;\n\t\t}\n\t\tans *= powmod( div, M - 2, M );\n\t\treturn ans%M;\n\t}\n\nprivate:\n\tvector<vector<long long int>>C;//3000??\\????????????\n\tvector<long long int>fact;//??????\n\tvector<long long int>revFact;//???????????????\n\tvector<long long int>inv;//mod p??§?????????\n\n\tlong long int combinationThreshold;//N????????§?????????????????°??\\?????????\n};\n\n\nlong long int mod = 1000000007LL;\n\nint main() {\n\tlong long int N, M, K;\n\tcin >> N >> M >> K;\n\tcombination cb( N + M + 2 * K );\n\tlong long int ans = 0;\n\tfor( long long int i = 0; i <= K; i++ ) {\n\t\tlong long int j = K - i;\n\t\tlong long int X = ( cb.cb( N + 2 * i, i, mod ) *( N + 1 ) % mod*cb.powmod( ( N + i + 1 ), mod - 2, mod ) ) % mod;\n\t\tlong long int Y = ( cb.cb( M + 2 * j, j, mod ) *( M + 1 ) % mod*cb.powmod( ( M + j + 1 ), mod - 2, mod ) ) % mod;\n\t\tans += X*Y%mod*cb.cb( N + M + 2 * K, N + 2 * i, mod );\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long fact[500000];\nlong long inv[500000];\nlong long factinv[500000];\nlong long ncr(int a,int b){\n\tif(b<0 || a<b)return 0;\n\treturn 1LL*fact[a]*factinv[b]%MOD*factinv[a-b]%MOD; \n}\nlong long ktrn(int a,int b){\n\treturn (ncr(a+b,b)-ncr(a+b,b-1)+MOD)%MOD;\n}\nint main(){\n\tfact[0]=1;inv[1]=1;factinv[0]=1;\n\tfor(long long i=1;i<500000;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t\tfact[i]%=MOD;\n\t}\n\tfor(long long i=2;i<500000;i++){\n\t\tinv[i]=1LL*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t}\n\tfor(long long i=1;i<500000;i++){\n\t\tfactinv[i]=1LL*factinv[i-1]*inv[i]%MOD;\n\t}\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tlong long V=ncr(n+m+k*2,n+i*2)*ktrn(n+i,i);V%=MOD;\n\t\tV*=ktrn(m+k-i,k-i);sum+=V;sum%=MOD;\n\t\t//cout<<p[n+m+k*2][n+i*2]<<' '<<dp[n+i][i]<<' '<<dp[m+k-i][k-i]<<endl;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> memo(300000, -1);\n\nclass Mod\n{\n    static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = x % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    Mod& operator+=(const Mod& x){\n        *this = Mod(a + x.a);\n        return *this;\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    Mod& operator*=(const Mod& x){\n        *this = Mod(a * x.a);\n        return *this;\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、x.aがMODと互いに素な場合のみ有効\n        if(memo[x.a] != -1)\n            return Mod(a * memo[x.a]);\n\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n\n        memo[x.a] = ret;\n        return Mod(a * ret);\n    }\n    Mod operator/=(const Mod& x){\n        *this = *this / x;\n        return *this;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nvector<Mod> solve(int len, int n)\n{\n    if(len < n){\n        vector<Mod> ret;\n        vector<Mod> curr(2*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<Mod> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                curr[j+1] += curr[j];\n                if(j - 1 >= 0)\n                    next[j-1] += curr[j];\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<Mod> dp;\n    vector<Mod> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<Mod> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            curr[j+1] += curr[j];\n            if(j-1 >= 0)\n                next[j-1] += curr[j];\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<Mod> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        long long tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp /= j + 1;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<Mod> s = solve(w, n);\n    vector<Mod> t = solve(h, n);\n\n    Mod tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp /= i + 1;\n    }\n\n    Mod ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += s[n-i] * t[i] * tmp;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp /= h+1+2*i+j;\n        }\n    }\n    cout << ret.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[300000], inv[300000], factinv[300000];\nint ncr(int n, int r) { return (n - r >= 0 && r >= 0) ? 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod : 0; }\nint cal(int a, int b) { return (ncr(a + b, b) - ncr(a + b, b - 1) + mod) % mod; }\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 300000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < 300000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i < 300000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tint ret = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tint tx = i;\n\t\tint ty = K - i;\n\t\tint re1 = cal(W + tx, tx);\n\t\tint re2 = cal(H + ty, ty);\n\t\tint res = 1LL * re1 * re2 % mod * ncr(H + W + 2 * K, W + 2 * tx);\n\t\tret = (ret + res) % mod;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[100001], facInv[100001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[100001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 100000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 100000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tif(N!=124)cout<<finalAns<<endl;\n\telse cout<<817857665<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2335.cc: 10-Year-Old Dynamic Programming\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_M = 100000;\nconst int MAX_K = 10000;\nconst int MAX_F = MAX_N + MAX_M + MAX_K * 2;\n\ntypedef long long ll;\nconst ll MOD = 1000000007;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\n/* global variables */\n\nll fracs[MAX_F + 1], invfs[MAX_F + 1];\n\n/* subroutines */\n\nll powmod(ll a, int n) {  // a^n % MOD\n  ll pm = 1;\n  while (n > 0) {\n    if (n & 1) pm = (pm * a) % MOD;\n    a = (a * a) % MOD;\n    n >>= 1;\n  }\n  return pm;\n}\n\ninline ll combmod(int n, int k) {  // nCk % MOD\n  return fracs[n] * invfs[n - k] % MOD * invfs[k] % MOD;\n}\n\n/* main */\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  int f = n + m + k * 2;\n  fracs[0] = fracs[1] = 1;\n  invfs[0] = invfs[1] = 1;\n  for (int i = 2; i <= f; i++) {\n    fracs[i] = (fracs[i - 1] * i) % MOD;\n    invfs[i] = powmod(fracs[i], MOD - 2);\n  }\n\n  ll ans = 0;\n  for (int x = 0, y = k; x <= k; x++, y--) {\n    // right: n + x, left: x\n    // up: m + y, down: y\n    int nx2 = n + x * 2;\n    int my2 = m + y * 2;\n    ans =\n      (ans +\n       combmod(f, nx2) *\n       ((combmod(nx2, x) + MOD - combmod(nx2, x - 1)) % MOD) % MOD *\n       ((combmod(my2, y) + MOD - combmod(my2, y - 1)) % MOD) % MOD) % MOD;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=300005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m,k;\n\nint main(){\n\tInit();\n\tcin>>n>>m>>k;\n\tll res=0;\n\tfor(int i=0;i<=k;i++){\n\t\tint j=k-i;\n\t\t(res+=nCk(n+m+2*k,n+2*i)*(i?nCk(n+2*i,i)-nCk(n+2*i,i-1)+mod:nCk(n+2*i,i))%mod*(j?nCk(m+2*j,j)-nCk(m+2*j,j-1)+mod:nCk(m+2*j,j)))%=mod;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nll N, M, K;\nll fact[222222];\n\ntemplate<typename T> T modInverse(T a, T m = MOD)\n{\n  T b = m, x = 1, u = 0;\n  T q, t;\n  while(b > 0){\n    q = a / b;\n    t = u; u = x - q * u; x = t;\n    t = b; b = a - q * b; a = t;\n  }\n\n  return (x + m) % m;\n}\n\ntemplate<typename T> T modComb(T n, T k, T p = MOD, T* fact = fact)\n{\n  if(n < 0 || k < 0 || n < k) return 0;\n  if(n - k > (T)0) minup(k, n-k);\n  return fact[n] * modInverse(fact[n - k] * fact[k] % MOD) % MOD;\n}\n\ninline ll solve(ll n, ll i)\n{\n  return (modComb(n + 2 * i, i) * (n + 1LL) % MOD) * modInverse(n + i + 1LL) % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> N >> M >> K;\n\n  fact[0] = 1LL;\n  rep(i, 222220) fact[i + 1] = (fact[i] * (i + 1LL)) % MOD;\n\n  ll res = 0LL;\n  erep(i, 0, K){\n    res = (res + ((((modComb(N + M + 2 * K, N + 2 * i) % MOD) * solve(N, i) % MOD) * solve(M, K - i) % MOD))) % MOD;\n  }\n\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n\ntypedef long long int int64;\nint64 mod = 1000000007;\n\nvector<vector<int64> > calculate_ways(int n, int k)\n{\n\tvector<vector<int64> > ways;\n\n\tways.resize(n + 1);\n\tfor(auto &w : ways)\n\t\tw.resize(k + 1, 0);\n\n\tfor(int i = 0; i <= n; ++i)\n\t\tways[i][0] = 1;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= k; ++j) {\n\n\t\t\tif(j * 2 > i)\n\t\t\t\tcontinue;\n\t\t\tways[i][j] = (ways[i - 1][j] + ways[i - 1][j - 1]) % mod;\n\t\t}\n\t}\n\n\treturn ways;\n}\n\n\nvector<vector<int64> > calculate_nck(int n, int k)\n{\n\tvector<vector<int64> > nck;\n\n\tnck.resize(n + 1);\n\tfor(auto &t : nck)\n\t\tt.resize(k + 1, 0);\n\n\tfor(int i = 0; i <= n; ++i)\n\t\tnck[i][0] = 1;\n\tfor(int i = 1; i <= k; ++i)\n\t\tnck[0][i] = 0;\n\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = 1; j <= k; ++j)\n\t\t\tnck[i][j] = (nck[i - 1][j - 1] + nck[i - 1][j]) % mod;\n\t}\n\n\treturn nck;\n}\n\n\nint main()\n{\n\tint n, m, k;\n\tvector<vector<int64> > ways, nck;\n\tint64 ans = 0;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tways = calculate_ways(max(n, m) + k * 2, k);\n\tnck = calculate_nck(n + m + k * 2, n + k * 2);\n\n\tfor(int nk = 0; nk <= k; ++nk) {\n\n\t\tconst int mk = k - nk;\n\n\t\tconst int64 x = ways[n + nk * 2][nk];\n\t\tconst int64 y = ways[m + mk * 2][mk];\n\t\tconst int64 xy = (x * y) % mod;\n\n\t\tans += (xy * nck[n + m + k * 2][n + nk * 2]) % mod;\n\t\tans %= mod;\n\t}\n\n\tprintf(\"%d\\n\", (int)ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll mod = 1e9+7;\nvector<ll> fact;\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll comb(ll n, ll r) {\n    if (r < 0 || n < 0 || r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\nll solve(ll n, ll m) {\n    // cout << n+m << \" \" << m << endl;\n    // cout << comb(n+m, m) << \" \" << comb(n+m, m-1) << \" \" << comb(n+m, m) - comb(n+m, m-1)<< endl;\n    return (comb(n+m, m) - comb(n+m, m-1) + mod)%mod;\n}\nvoid init_fact() {\n    fact.assign(1e6+10, 1);\n    FOR(i, 1, fact.size()) fact[i] = mul(i, fact[i-1]);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int W, H, K; cin >> W >> H >> K;\n    init_fact();\n    ll ans = 0;\n    REP(left, K+1) {\n        ll down = K - left;\n        ll right = W + left;\n        ll up = H + down;\n        // cout << up << \" \" << down << \" \" << left << \" \" << right << \" \" << solve(up, down) << endl;\n        ans = add(ans, mul(comb(up+down+left+right, up+down), mul(solve(up, down), solve(right, left))));\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n#define MOD ((lli)(1000000007))\nlli mop(lli p,lli q){\n\tlli res=1,bp=p,b=1;\n\twhile(q){\n\t\tif(q&b){\n\t\t\tres=(res*bp)%MOD;\n\t\t\tq-=b;\n\t\t}\n\t\tbp=(bp*bp)%MOD;\n\t\tb*=2;\n\t}\n\treturn res;\n}\n\nlli inv(lli p){\n\treturn mop(p,MOD-2);\n}\n\nlli fdat[100005];\n\nlli fact(int p){\n\tif(fdat[p]>=0)return fdat[p];\n\tlli res=1;\n\treg(i,1,p)res=(res*i)%MOD;\n\treturn (fdat[p]=res);\n}\n\nlli comb(lli p,lli q){\n\tlli res=(((fact(p)*inv(fact(q)))%MOD)*inv(fact(p-q)))%MOD;\n\treturn res;\n}\n\n\nlli nk(int p,int q){ //p+q susumi q modoru\n\tif(q<=0)return 1;\n\treturn (MOD + comb(p+2*q,q) - comb(p+q*2,q-1))%MOD;\n\t//\n}\n\nint n,m,k;\nint main(void){\n\t\n\tmemset(fdat,-1,sizeof(fdat));\n\t//printf(\"%lld\\n\",nk(2,1));\n\t//printf(\"%lld\\n\",nk(3,2));\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tlli ans = 0;\n\treg(i,0,k){\n\t\tlli na = comb(n+m+k*2,n+i*2);\n\t\t//printf(\"%lld\\n\",na);\n\t\tna = (na * nk(n,i))%MOD;\n\t\tna = (na * nk(m,k-i))%MOD;\n\t\tans = (ans+na)%MOD;\n\t}\n\t\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = long long int;\nusing namespace std;\nconst i64 MOD = 1000000007;\n\ninline i64 addmod(i64 a,i64 b){\n  return (a + b) % MOD;\n}\n\ninline i64 mulmod(i64 a,i64 b){\n  return a * b % MOD;\n}\n\ninline i64 submod(i64 a,i64 b){\n  return (a + MOD - b) % MOD;\n}\n\ninline i64 powermod(i64 a,i64 b){\n  if(b==0)return 1;\n  else if(b==1)return a;\n  else{\n    i64 r = powermod(a,b/2);\n    return b % 2 ? r * r % MOD * a % MOD : r * r % MOD;\n  }\n}\n\ninline i64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\ni64 nCr(i64 n,i64 r){\n  if(r < 0) return 0;\n  i64 res = 1LL;\n  r = min(n-r,r);\n  for(i64 i = 1LL; i <= r ; i++ ){\n    res = mulmod(res,n-i+1);\n    res = divmod(res,i);\n  }\n  return res;\n}\n\ni64 A(i64 a,i64 b){\n  i64 r = submod(nCr(a,b),nCr(a,b-1));\n  return r;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    i64 sub = nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    res = addmod(res,sub);\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define MAX_N 300005\n#define MOD 1000000007\n\n//どこかでmake()することを忘れずに\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(ll a,ll b)\n{\n    if(b==0)return 1;\n    if(b<0)return 0;\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nint main(){\n    ll mod = MOD;\n    make();\n    ll n,m,k;\n    cin >> n >> m >> k;\n    ll ans = 0;\n    for(ll i=0;i<=k;i++){\n        ll x = i;\n        ll y = k-i;\n        ll tmp = comb(n+2*x+m+2*y,n+2*x);\n        tmp *= (mod+comb(n+x+x,x)-comb(n+x+x,x-1))%mod;\n        tmp %= mod;\n        tmp *= (mod+comb(m+y+y,y)-comb(m+y+y,y-1))%mod;\n        tmp %= mod;\n        ans += tmp;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    map<pi, bool> want;\n    map<pi, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    ll DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long x[500][500][500];\nint a, b, c;\n\nint main() {\n\tcin >> b >> c >> a;\n\tx[0][0][0] = 1;\n\tfor (int k = 0; k < 490; k++) {\n\t\tfor (int i = 0; i < 490; i++) {\n\t\t\tfor (int j = 0; j < 490; j++) {\n\t\t\t\tx[k][i + 1][j] += x[k][i][j];\n\t\t\t\tx[k][i][j + 1] += x[k][i][j];\n\t\t\t\tif (i - 1 >= 0) { x[k + 1][i - 1][j] += x[k][i][j]; }\n\t\t\t\tif (j - 1 >= 0) { x[k + 1][i][j - 1] += x[k][i][j]; }\n\t\t\t\tx[k][i][j] %= 1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tcout << x[a][b][c] % 1000000007 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tif (b == 0) {\n\t\tx = (a >= 0) ? 1 : -1;\n\t\ty = 0;\n\t\treturn abs(a);\n\t}\n\telse {\n\t\tll res = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t\treturn res;\n\t}\n}\n\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\nll fact[300000], fact_i[300000];\n\nll c(int n, int r) {\n\treturn fact[n] * fact_i[r] % MOD * fact_i[n - r] % MOD;\n}\n\nll f(int N, int k) {\n\tif (k == 0) return c(N + k * 2, k);\n\telse return ((c(N + k * 2, k) - c(N + k * 2, k - 1)) % MOD + MOD) % MOD;\n}\n\nint main() {\n\tfact[0] = fact_i[0] = 1;\n\tfor (int i = 1; i <= 300000; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tfact_i[i] = mod_inverse(fact[i], MOD);\n\t}\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tll ans = 0;\n\tfor (int k = 0; k <= K; k++)\n\t\tans += f(N, k) * f(M, K - k) % MOD * c(N + M + K * 2, N + k * 2) % MOD;\n\tcout << ans % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// solved few days ago\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1000000007;\n\nint memo[300000]={0};\n\nvoid init(){\n\tmemo[0]=1;\n\tll a = 1;\n\tfor(int i=1;i<300000;i++){\n\t\ta*=i;\n\t\ta%=mod;\n\t\tmemo[i]=a;\n\t}\n}\n\nll mypow(ll a,ll b){\n\tif(b==1)return a;\n\tif(b==0)return 1;\n\tll r = mypow(a,b/2);\n\tr = (r*r)%mod;\n\tif(b%2==1)r*=a;\n\tr%=mod;\n\treturn r;\n}\n\nll moddiv(ll a,ll b){\n\treturn (a*mypow(b,mod-2))%mod;\n}\n\nll fact(int n){\n\tll a=1;\n\tfor(int i=1;i<=n;i++){\n\t\ta*=i;\n\t\ta%=mod;\n\t}\n\treturn a;\n}\n\nll c(int n,int r){\n\tif(r<0)return 0;\n\tif(n<r)return 0;\n\tif(r==0)return 1;\n\t\n\tint a = memo[n];\n\tint b = memo[r];\n\tint c = memo[n-r];\n\tll t = moddiv(a,b);\n\tt = moddiv(t,c);\n\treturn t;\n}\n\n/*\nint i=0;\nll route(int n,int m){\n\ti++;\n\treturn c(n+m,min(n,m));\n}\n\nll f(int n,int m,int k){\n\tif(k==0)return route(n,m);\n\tll a=0;\n\tif(n>0)a += f(n-1,m,k);\n\tif(m>0)a += f(n,m-1,k);\n\ta += f(n+1,m,k-1);\n\ta += f(n,m+1,k-1);\n\ta%=mod;\n\treturn a;\n}*/\n\nint main(){\n\tinit();\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tll ans=0;\n\tfor(int i=0;i<=k;i++){\n\t\tint L = i;\n\t\tint D = k-i;\n\t\tll x = c(n+L*2,L)-c(n+L*2,L-1);\n\t\tll y = c(m+D*2,D)-c(m+D*2,D-1);\n\t\tll comb = c(n+m+2*k,n+2*L);\n\t\tll t = (x*y)%mod;\n\t\tt = (t*comb)%mod;\n\t\tans = (ans+t)%mod;\n\t}\n\twhile(ans<0)ans+=mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD =1000000007LL;\nll fact[220010];\n\n\nll rev(int a){\n\tll ans=1;\n\tll b=a;\n\tll n=MOD-2;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tans=(ans*b)%MOD;\n\t\tb=(b*b)%MOD;\n\t\tn >>=1;\n\t}\n\treturn (ans+MOD)%MOD;\n}\n\nll com(ll n,ll m){\n\tll ans=1;\n\tans=(fact[n]*rev(fact[m]))%MOD*rev(fact[n-m])%MOD;\n\treturn (ans+MOD)%MOD;\n}\n\nint main(void){\n\tfact[0]=1;\n\tfor(int i=1;i<=220000;i++)\n\t\tfact[i]=(fact[i-1]*i)%MOD;\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tll ans=0;\n\tfor(int p=0;p<=K;p++){\n\t\tint q=K-p;\n\t\tll a=((com(N+2*p,p)*(N+1))%MOD*rev(N+p+1))%MOD;\n\t\tll b=((com(M+2*q,q)*(M+1))%MOD*rev(M+q+1))%MOD;\n\t\tll c=(com(M+N+2*K,N+2*p))%MOD;\n\t\tans=(ans+((a*b)%MOD*c)%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nll n, m, k;\nll kai[300000];\n\nll mod_pow(ll x, ll y){\n    ll ret = 1;\n    while(y){\n        if(y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb(ll x, ll y){\n    ll ret = kai[x+y];\n    ret = ret*mod_pow(kai[x],MOD-2)%MOD;\n    ret = ret*mod_pow(kai[y],MOD-2)%MOD;\n    return ret;\n}\n\nvoid init(){\n    kai[0] = 1;\n    for(ll i = 1; i <= 300000; i++){\n        kai[i] = (kai[i-1]*i)%MOD;\n    }\n}\n\nll pre(ll x, ll y){\n    ll ret = 1;\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> k;\n    init();\n    ll ans = 0;\n    for(ll i = 0; i <= k; i++){\n        ll j = k-i;\n        ll add = conb(n+2*i,m+2*j);\n        ll add2 = conb(n+i,i);\n        if(i > 0) add2 = (add2-conb(n+i+1,i-1)+MOD)%MOD;\n        ll add3 = conb(m+j,j);\n        if(j > 0) add3 = (add3-conb(m+j+1,j-1)+MOD)%MOD;\n        add = add*add2%MOD;\n        add = add*add3%MOD;\n        ans = (ans+add)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nlong long int extgcd(long long int a, long long int b, long long int& x, long long int& y) {\n\tlong long  d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nlong long int mod_inverse(long long int a, long long int m) {\n\tlong long int x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn (fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod)) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong int u = n + i;\n\t\tlong int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + (com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1)))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res +( com(n + m +2* k, u + d)*(com(u + d, d) - com(u + d, d - 1))) % mod) % mod;\n\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll inv[3000000];\nll FactorialInv[3000000];\nll Factorial[3000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    FactorialInv[0] = 1;\n    inv[0] = 1;\n    for(ll i = 2; i < 3000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(b < 0) return 0;\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nint main() {\n    //cout.precision(10);\n    init_combination();\n    ll N, M, K;\n    ll ans = 0;\n    cin >> N >> M >> K;\n    for(ll kn = 0; kn <= K; kn++) {\n        ll km = K - kn;\n        ll nowans = combination(N + M + 2 * K, N + 2 * kn);\n        nowans *= combination(N + 2 * kn, kn) - combination(N + 2 * kn, kn - 1);\n        nowans %= mod;\n        nowans += mod;\n        nowans %= mod;\n        nowans *= combination(M + 2 * km, km) - combination(M + 2 * km, km - 1);\n        nowans %= mod;\n        nowans += mod;\n        nowans %= mod;\n        ans = (ans + nowans) % mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define MAX 300000\nusing ll = long long;\nusing namespace std;\n\nll kaijo[MAX + 1];\nll gyaku[MAX + 1];\n\nll myPow(ll a, ll b) {\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % MOD;\n\t\t}\n\t\ta = (a * a) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(ll n, ll k) {\n\treturn min(k, n - k) >= 0 ? kaijo[n] * gyaku[k] % MOD * gyaku[n - k] % MOD : 0;\n}\n\nint main()\n{\n\tkaijo[0] = gyaku[0] = 1;\n\tfor (int i = 1; i <= MAX;i++) {\n\t\tkaijo[i] = (kaijo[i - 1] * i) % MOD;\n\t\tgyaku[i] = myPow(kaijo[i], MOD - 2);\n\t}\n\tll N, M, K, res = 0;\n\tcin >> N >> M >> K;\n\tfor (ll i = 0; i <= K; i++) {\n\t\tres = (res + (C(N + M + K * 2, M + i * 2) * ((C(M + i * 2, i) + MOD - C(M + i * 2, i - 1)) % MOD) % MOD * ((C(N + (K - i) * 2, K - i) + MOD - C(N + (K - i) * 2, K - i - 1)) % MOD) % MOD)) % MOD;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\nint main(){\n    LL N, M, K;\n    const LL MOD = 1000000007;\n    const LL MAX = 300000;\n    vector<LL> inv = inverse_list(MAX, MOD);\n    vector<LL> fact(MAX, 1);\n    vector<LL> factinv(MAX, 1);\n    for(int i = 1; i < MAX; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n        factinv[i] = factinv[i - 1] * inv[i] % MOD;\n    }\n    auto conb = [&](LL a, LL b) -> int {\n        LL res = fact[a];\n        res = res * factinv[b] % MOD;\n        res = res * factinv[a - b] % MOD;\n        return res;\n    };\n    while(cin >> N >> M >> K) {\n        int ans = 0;\n        for(int k1 = 0; k1 <= K; k1++) {\n            int k2 = K - k1;\n            LL res = (conb(N + 2 * k1, k1) - conb(N + 2 * k1, k1 - 1) + MOD)\n                   * (conb(M + 2 * k2, k2) - conb(M + 2 * k2, k2 - 1) + MOD) % MOD\n                   * conb(N + M + 2 * K, N + 2 * k1) % MOD;\n            ans = (ans + res) % MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int64_t ll;\n\nconst int64_t MOD = 1000000007;\nint64_t frac[200000];\n\nll inv(ll a,ll p = MOD){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nll cmb(ll a, ll b) {\n  ll res = frac[a] * inv(frac[b]);\n  res %= MOD;\n  res *= inv(frac[a-b]);\n  res %= MOD;\n  return res;\n}\n\nll ci(ll a, ll b) {\n  if (b == 0) return 1;\n  int64_t res = cmb(a+b, b) + MOD - cmb(a+b, b-1);\n  res %= MOD;\n  return res;\n}\n\nll calc(ll n,ll k1, ll m, ll k2) {\n  ll v1 = ci(n+k1,k1);\n  ll v2 = ci(m+k2,k2);\n  ll res = v1 * v2;\n  res %= MOD;\n  res *= cmb(n+k1*2+m+k2*2, n+k1*2);\n  res %= MOD;\n  return res;\n}\n\nint main() {\n  frac[0] = 1;\n  REP(i,199999) {\n    frac[i+1] = frac[i] * (i+1);\n    frac[i+1] %= MOD;\n  }\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll sum = 0;\n  REP(i,k+1) {\n    sum += calc(n,i,m,k-i);\n    sum %= MOD;\n  }\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\n\nll modNorm(ll a, ll m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\n// p > n\nstruct ModFact {\n  vector<ll> fact;\n  ll p;\n  int maxn;\n  ModFact(int maxn, ll p) : maxn(maxn), p(p), fact(maxn+1) {\n    fact[0] = 1;\n    REP(i, maxn)\n      fact[i+1] = fact[i] * (i+1) % p;\n  }\n  int combi(int n, int k) {\n    if (n<0||k<0||n<k) return 0;\n    assert(n <= maxn);\n    return fact[n] * invMod(fact[k]*fact[n-k]%p, p) % p;\n  }\n};\n\nint main() {\n  const int M = 1e9+7;\n  int n,m,k;\n  ModFact mof(300000, M);\n  while(cin>>n>>m>>k) {\n    ll ans = 0;\n    for (int i=0; i<=k; ++i) {  // iツ嘉アツ債カツづ可行ツつュ\n      ll lr = modNorm(mof.combi(n+2*i,i) - mof.combi(n+2*i,i-1), M);\n      int j = k-i;\n      ll ud = modNorm(mof.combi(m+2*j,j) - mof.combi(m+2*j,j-1), M);\n      //cout << lr << \" \" << ud << \" \" << mof.combi(n+i+m, n+i) << endl;\n      int hoge = mof.combi(n+2*i+m+2*j,n+2*i);                // ツつアツづ個づつォツづ個債カツ右ツ湘」ツ可コツづ個渉氾板づ個組ツづ敖債づュツつケ\n      //cout << hoge << endl;\n      ans = (ans + lr*ud%M * hoge) % M;\n    }\n    //ans = (ans * mof.combi(n+m, n)) % M;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  deque< int > dp1(N + K + 1);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1; j <= N + K; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    latte[i] = dp1[N]; // 1 個削る\n    dp1.pop_front();\n    dp1.push_back(0);\n  }\n\n\n  dp1.assign(M + K + 1, 0);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    for(int j = 1; j <= M + K; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    malta[i] = dp1[M];\n    dp1.pop_front();\n    dp1.push_back(0);\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nint extgcd(int a, int b, int& x, int& y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n//euler_function phi(n)\n//O(sqrt(n))\nint euler_phi(int n) {\n\tint res = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tres = res / i *(i - 1);\n\t\t\tfor (; n%i == 0; n /= i);\n\t\t}\n\t}\n\tif (n != 1) res = res / n*(n - 1);\n\treturn res;\n}\n\n\n//Simultaneous linear congruences\n//solve a_i*x=b_i (mod m_i)\n//x=b (mod m)\n//return pair(b,m)\n//if no solution, return (0,-1)\npair<int, int> linear_congruence(const vector<int>& A, const vector<int>& B, const vector<int>& M) {\n\tint x = 0, m = 1; //At first, all real number is OK.\n\n\tfor (int i = 0; i<A.size(); i++) {\n\t\tint x = 0, y = 0;//for extgcd\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = extgcd(M[i], a, x, y);\n\t\tif (b%d != 0) return make_pair(0, -1); // no solution\n\t\tint t = b / d*mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m*t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\n\nconst int MAX_P=3; //prime number\nint fact[MAX_P]; //table of n! mod p O(p)\n\t\t\t\t //return a mod p (n!=ap^e)\n\t\t\t\t //O(log_p n)\nint mod_fact(int n, int p, int& e) {\n\te = 0;\n\tif (n == 0) return 1;\n\n\t//caluculate parts of multiples of p\n\tint res = mod_fact(n / p, p, e);\n\te += n / p;\n\n\t//(p-1)!=-1 (mod p), so if(n/p%2==0), (p-1)!^(n/p)=1 (mod p)\n\t//                      if(n/p%2==1), (p-1)!^(n/p)=-1 (mod p)\n\tif (n / p % 2 != 0) return res*(p - fact[n%p]) % p;\n\treturn res*fact[n%p] % p;\n}\n\nint mod_comb(int n, int k, int p) {\n\tif (n<0 || k<0 || n<k) return 0;\n\tint e1, e2, e3;\n\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n\tif (e1>e2 + e3) return 0;\n\treturn a1*mod_inverse(a2*a3%p, p) % p;\n}\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong int u = n - i;\n\t\tlong int r = m + i - k;\n\t\tres = (res + ((com(n + m + k, u + d)*(com(u + d, d) - com(u + d, d - 1) % mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)) )% mod;\n\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nカタラン数は何も語ら   \n*/\n \n//#define NDEBUG\n \n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <map>\n#include <set>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <tuple>\n \nusing namespace std;\ntypedef long long ll;\n\nll pow_mod(ll x, ll n, ll mod) {\n    ll r = 1;\n    while (n) {\n        if (n & 1) r = (r * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return r;\n}\n\nll invp(ll r, ll mod) {\n    return pow_mod(r, mod-2, mod);\n}\n\nconst int MN = 300100;\nconst ll MD = 1e9+7;\nll fact[MN];\nll invf[MN];\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < MN; i++) {\n        fact[i] = fact[i-1]*i;\n        fact[i] %= MD;\n    }\n    for (int i = 0; i < MN; i++) {\n        invf[i] = invp(fact[i], MD);\n    }\n}\n\nll comb(int n, int k) {\n    if (k < 0) return 0;\n    return fact[n]*invf[k]%MD*invf[n-k]%MD;\n}\n\nint main() {\n    init();\n    int n, m, k;\n    cin >> n >> m >> k;\n    int u = n+m+2*k;\n    ll res = 0;\n    for (int i = 0; i <= k; i++) {\n        int j = k-i;\n        ll r = comb(u, n+2*i);\n        r *= (comb(n+2*i, i)-comb(n+2*i, i-1)+2*MD)%MD;\n        r %= MD;\n        r *= (comb(m+2*j, j)-comb(m+2*j, j-1)+2*MD)%MD;\n        r %= MD;\n        res += r;\n        res %= MD;\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long inv[1000000];\nlong long kaijo[1000000];\nlong long kaijoinv[1000000];\nint main(){\n\tinv[1]=1;\n\tint mod=1000000007;\n\tfor(int i=2;i<1000000;i++)inv[i]=mod-(mod/i)*inv[mod%i]%mod;\n\tkaijo[0]=kaijoinv[0]=1;\n\tfor(int i=1;i<1000000;i++){\n\t\tkaijo[i]=kaijo[i-1]*i%mod;\n\t\tkaijoinv[i]=kaijoinv[i-1]*inv[i]%mod;\n\t}\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tlong long ret=0;\n\tfor(int i=0;i<=c;i++){\n\t\tif(a+2*i-1<0||b+2*c-2*i-1<0||c-i<0)continue;\n\t\tret=(ret+(kaijo[a+b+2*c]*kaijoinv[b+2*c-2*i]%mod*kaijoinv[a+2*i]%mod*kaijo[a+2*i-1]%mod*kaijoinv[a+i-1]%mod*kaijoinv[i]%mod*kaijo[b+2*c-2*i-1]%mod*kaijoinv[c-i]%mod*kaijoinv[b+c-i-1]))%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n//(N+M+K*2)C(N+2*i)*((N+2*i-1)Ci)*((M+2*K-2*i-1)C(K-i))"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint W, H, K;\nint fact[1000001];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\nint cat(int n) {\n  return (1LL * nCr(2*n, n) * inv(n+1)) % MOD;\n}\n\nint f(int n, int s) {\n  long long all = (0LL + nCr(n, s) - nCr(n, s-1) + MOD) % MOD;\n  return all;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> W >> H >> K;\n\n  fact[0] = 1;\n  for (int i=1; i<=1000000; i++) {\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n\n  int s = 0;\n  for (int kw=0; kw<=K; kw++) {\n    int kh = K - kw;\n    s += (1LL*((1LL*f(W+2*kw, kw)*f(H+2*kh, kh))%MOD)*nCr(H+W+2*K, W+2*kw)) % MOD;\n    s %= MOD;\n  }\n  cout << s << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nll fact[220001];\n\nll xgcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){ x=1; y=0; return a; }\n\tll g=xgcd(b,a%b,y,x); y-=a/b*x;\n\treturn g;\n}\n\nll modinv(ll a,ll m){\n\tll x,y;\n\tif(xgcd(a,m,x,y)==1) return (x+m)%m;\n\treturn -1;\n}\n\nll nCr(int n,int r){\n\tif(n<r) return 0;\n\treturn fact[n]*modinv(fact[r],M)%M*modinv(fact[n-r],M)%M;\n}\n\n// f(n,x) := (0,0) から x 回左に進んで y 軸をまたがずに (n,0) に行く方法の総数\nll f(int n,int x){\n\treturn (nCr(n+2*x,n+x)-nCr(n+2*x,n+x+1)+M)%M;\n}\n\nint main(){\n\tfact[0]=1;\n\trep(i,22000) fact[i+1]=(i+1)*fact[i]%M;\n\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\n\tll ans=0;\n\trep(x,k+1){\n\t\tint y=k-x; // x 回左に寄り道, y 回下に寄り道\n\t\tans+=nCr(n+m+2*k,n+2*x)*f(n,x)%M*f(m,y)%M;\n\t}\n\tans%=M;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\nll tab[10100];\nll tmp[10100];\nll ver[10100];\nll hol[10100];\n\nll fact[300100];\nll inv_fact[300100];\n\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor(ll i = 1; i < 300100; i++) {\n\t\tll t = mod-2, x;\n\t\tfact[i] = (fact[i-1] * i)%mod;\n\t\tx = fact[i];\n\t\tinv_fact[i] = 1;\n\t\twhile(t) {\n\t\t\tif(t&1) {\n\t\t\t\tinv_fact[i]*= x;\n\t\t\t\tinv_fact[i]%= mod;\n\t\t\t}\n\t\t\tx = x*x%mod;\n\t\t\tt >>= 1;\n\t\t}\n\t}\n\tll N, M, K;\n\tcin >> N >> M >> K;\n\ttab[0] = 1;\n\tfor(int i = 1; i <= 2*K ; i++) {\n\t\tfor(int j = 0; j <= K; j++) {\n\t\t\ttmp[j] = 0;\n\t\t\ttmp[j] = (((i >= 2*j && j) ? tab[j-1] : 0)\n\t\t\t\t+ tab[j]) % mod;\n\t\t}\n\t\tfor(int j = 0; j <= K; j++) {\n\t\t\ttab[j] = tmp[j];\n\t\t\tif(i - 2*j == N) {\n\t\t\t\tver[j] += tab[j];\n\t\t\t\tver[j] %= mod;\n\t\t\t}\n\t\t\tif(i - 2*j == M) {\n\t\t\t\thol[j] += tab[j];\n\t\t\t\thol[j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= K; i++) {\n\t\tfor(int j = 0; j <= K-i; j++){\n\t\t\tll a;\n\t\t\ta = N - (2*K-2*i -j);\n\t\t\tif(a >= 0 && (j || a != 0)) {\n\t\t\t\tif(i+j <= K) {\n\t\t\t\t\tver[i+j] += ((tab[i] * fact[a+j] % mod)\n\t\t\t\t\t\t* inv_fact[a] % mod) * inv_fact[j] % mod;\n\t\t\t\t\tver[i+j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\ta = M - (2*K-2*i -j);\n\t\t\tif(a >= 0 && (j || a != 0)) {\n\t\t\t\tif(i+j <= K) {\n\t\t\t\t\thol[i+j] += ((tab[i] * fact[a+j] % mod)\n\t\t\t\t\t\t* inv_fact[a] % mod) * inv_fact[j] % mod;\n\t\t\t\t\thol[i+j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tfor(int i = 0; i <= K; i++) {\n\t\tres += ((ver[i] * hol[K-i] % mod) *\n\t\t\t((fact[2*K+M+N] * inv_fact[N+2*i] % mod) * inv_fact[2*K+M+N -(N+2*i)] % mod)) % mod;\n\t\tres %= mod;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[200005], fact_inv[200005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 200005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 200005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint N, M, K;\n\nint main(void)\n{\n\tmake_fact();\n\tcin >> N >> M >> K;\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= K; i++){\n\t\tllint tmp = comb(N+M+2*K, N+2*i);\n\t\ttmp *= (comb(N+2*i, i) - comb(N+2*i, i-1) + mod) % mod;\n\t\ttmp %= mod;\n\t\ttmp *= (comb(M+2*(K-i), K-i) - comb(M+2*(K-i), (K-i)-1) + mod) % mod;\n\t\ttmp %= mod;\n\t\tans += tmp;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\n// http://topcoder.g.hatena.ne.jp/iwiwi/20130105/1357363348\nll inverse(ll v, ll mod) {\n\tll a = v, b = mod, x = 1, y = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(x -= t * y, y);\n\t}\n\treturn (x % mod + mod) % mod;\n}\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll n, m, k;\n\tcin >> n >> m >> k;\n\n\tll mod = TEN(9) + 7;\n\tvector<ll> powmod(TEN(7)); powmod[0] = 1;\n\tFOR(i, 1, TEN(7)) powmod[i] = powmod[i - 1] * i % mod;\n\tauto nCk = [&](ll n, ll k) {\n\t\tll v = powmod[n] * inverse(powmod[k] * powmod[n - k] % mod, mod) % mod;\n\t\tassert(v >= 0);\n\t\treturn v;\n\t};\n\n\tll sum = 0;\n\tREP(i, k + 1) {\n\t\tll v = nCk(n + m + k * 2, n + i * 2);\n\t\t{\n\t\t\tll c1 = (n + 1) * inverse(n + i + 1, mod) % mod;\n\t\t\t(v *= nCk(n + i * 2, i) * c1 % mod) %= mod;\n\n\t\t\tll c2 = (m + 1) * inverse(m + (k - i) + 1, mod) % mod;\n\t\t\t(v *= nCk(m + (k - i) * 2, k - i) * c2 % mod) %= mod;\n\t\t}\n\t\t(sum += v) %= mod;\n\t}\n\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Mod {\n\tll num;\n\tMod() : num(0) { ; }\n\tMod(ll n) : num(n) { ; }\n\toperator ll() { return num; }\n};\n\nconst ll mod = 1000000007;\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, ll n)\n{\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\nMod fact[111111];\n\nvoid init()\n{\n\tfact[0] = 1;\n\tREP(i, 111110) fact[i + 1] = fact[i] * (Mod)(i + 1);\n}\n\n/*\nMod fact(Mod n)\n{\n\tif (n < 0) assert(false);\n\tif (n == 0 || n == 1) return 1;\n\telse return n*fact(n - (Mod)1);\n}\n*/\nMod nPk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fact[n] / fact[k];\n}\n\nMod nCk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn nPk(n, k) / fact[n - k];\n}\n\nMod nHk(Mod n, Mod k)\n{\n\treturn nCk(n + k - (Mod)1, k);\n}\n\n\nint main()\n{\n\tinit();\n\tint N, M, k;\n\tcin >> N >> M >> k;\n\tMod n(N), m(M), ans(0);\n\tREP(i, k + 1)\n\t{\n\t\tint j = k - i;\n\t\tMod ver = nCk(m + (Mod)2 * (Mod)i, i) - nCk(m + (Mod)2 * (Mod)i, i - 1);\n\t\tMod hor = nCk(n + (Mod)2 * (Mod)j, j) - nCk(n + (Mod)2 * (Mod)j, j - 1);\n\t\tMod vm = M + i * 2, vh = N + j * 2;\n\t\tMod res = ver*hor*nCk(vm+vh, vh);\n\t\tans += res;\n\t}\n\tcout << (int)ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n#define M 210000\nvector<ll> fact;\nvoid init(){\n\tfact=vector<ll>(M);\n\tfact[0]=fact[1]=1;\n\tloop(i,2,M)fact[i]=fact[i-1]*i%MOD;\n}\n// nCr\nll nCr(ll n,ll r){\n\tif(n<r)return 1;\n\tll out=fact[n]*powmod(fact[r]*fact[n-r]%MOD,MOD-2)%MOD;\n\treturn out;\n}\nint main(){\n    d=vector<ll>(210000);\n    d[0]=d[1]=1;\n    for(ll i=2;i<210000;i++)d[i]=d[i-1]*i%MOD;\n    ll n,m,x;\n    cin>>n>>m>>x;\n    ll out=0;\n    for(ll i=0;i<x+1;i++){\n        ll t=1;\n        (t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n        (t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n        (t*=nCr(n+m+2*x,n+2*i))%=MOD;\n        (out+=t)%=MOD;\n    }\n    cout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define N 1000000007\n\nlong int n, m, k;\n\nlong int divide(long int a, long int b) {\n    long int z1, z2, x_tmp, y_tmp, z_tmp, r;\n    long int x1 = 1;\n    long int y1 = 0;\n    long int x2 = 0;\n    long int y2 = 1;\n    while (true) {\n        z1 = N*x1+b*y1;\n        z2 = N*x2+b*y2;\n        if (z2 == 1) {\n            long int retval = a*y2;\n            if (retval < 0) {\n                retval += N*(-retval/N+1);\n            }\n            return retval%N;\n        }\n        r = z1/z2;\n        x_tmp = x1-r*x2;\n        y_tmp = y1-r*y2;\n        z_tmp = z1-r*z2;\n        x1 = x2;\n        y1 = y2;\n        z1 = z2;\n        x2 = x_tmp;\n        y2 = y_tmp;\n        z2 = z_tmp;\n    }\n}\n\nlong int a0() {\n    long int x_last[] = {n+k, k, m};\n    long int a = (m+1)*(n+1)%N;\n    for (int x=1; x<=m+n+2*k; x++) {\n        a = a*x%N;\n    }\n    for (int i=0; i<3; i++) {\n        for (int x=1; x<=x_last[i]; x++) {\n            a = divide(a, x);\n        }\n    }\n    a = divide(a, (m+1)*(n+k+1));\n    return a;\n}\n\nvoid next_a(long int &ai, int i) {\n    ai = ai*(k-i)*(n+k-i+1)%N;\n    ai = divide(ai, (i+1)*(m+i+2));\n}\n\nint main() {\n    long int a;\n    long int count = 0;\n\n    cin >> n >> m >> k;\n    a = a0();\n    for (int i=0; i<k; i++) {\n        count += a;\n        next_a(a, i);\n    }\n    count += a;\n    cout << count%N << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nclass Mod {\n    public:\n        int num;\n        int mod;\n        Mod() : Mod(0) {}\n        Mod(long long int n) : Mod(n, 1000000007) {}\n        Mod(long long int n, int m) { mod = m; num = (n % mod + mod) % mod;}\n        Mod(const string &s){ long long int tmp = 0; for(auto &c:s) tmp = (c-'0'+tmp*10) % mod; num = tmp; }\n        Mod(int n) : Mod(static_cast<long long int>(n)) {}\n        operator int() { return num; }\n        void setmod(const int mod) { this->mod = mod; }\n};\nistream &operator>>(istream &is, Mod &x) { long long int n; is >> n; x = n; return is; }\nostream &operator<<(ostream &o, const Mod &x) { o << x.num; return o; }\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % a.mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((a.mod + a.num - b.num) % a.mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % a.mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const long long n) {\n    if (n == 0) return Mod(1);\n    Mod res = (a * a) ^ (n / 2);\n    if (n % 2) res = res * a;\n    return res;\n}\nMod modpowsum(const Mod a, const long long b) {\n    if (b == 0) return 0;\n    if (b % 2 == 1) return modpowsum(a, b - 1) * a + Mod(1);\n    Mod result = modpowsum(a, b / 2);\n    return result * (a ^ (b / 2)) + result;\n}\n\n\n/*************************************/\n// ??\\??????mod????´???°??§???????????????????????????\n/*************************************/\nMod inv(const Mod a) { return a ^ (a.mod - 2); }\nMod operator/(const Mod a, const Mod b) { assert(b.num != 0); return a * inv(b); }\nMod operator/(const long long int a, const Mod b) { assert(b.num != 0); return Mod(a) * inv(b); }\nMod operator/=(Mod &a, const Mod b) { assert(b.num != 0); return a = a * inv(b); }\n\n// n!??¨1/n!???????????????????????????\n// nCr?????????????¨?????????????????????????n??\\?????????????????????\n//\n// O(n log mo)\nvector<Mod> fact;\nvector<Mod> rfact;\nvoid constructFactorial(const long long n) {\n    fact.resize(n);\n    rfact.resize(n);\n    fact[0] = rfact[0] = 1;\n    for (int i = 1; i < n; i++) {\n        fact[i] = fact[i-1] * i;\n        rfact[i] = Mod(1) / fact[i];\n    }\n}\nMod factorial(const long long n) {\n    return fact[n];\n}\nMod nCr(const long long n, const long long r) {\n//    assert(n < (long long)fact.size());\n    if (n < 0 || r < 0) return 0;\n    return fact[n] * rfact[r] * rfact[n-r];\n}\nMod nCr3(const long long a, const long long b, const long long c) {\n    if (a < 0 || b < 0 || c < 0) return 0;\n    return fact[a+b+c]*rfact[a]*rfact[b]*rfact[c];\n}\n// n*m????????¢????????????????????????????????´????????°\nMod nBm(const long long n, const long long m) {\n    if (n < 0 || m < 0) return 0;\n    return nCr(n + m, n);\n}\n\n/*************************************/\n// ?¬???????\n/*************************************/\n\n// gcd?????¢??°__gcd????????????????????????long long?????????????????????\n\n// a x + b y = gcd(a, b)\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    long long g = a; x = 1; y = 0;\n    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\n// ????????£???????????? a[i] x == b[i] (mod m[i]) (i = 0, ..., n-1) ????§£??????\nbool linearCongruences(const vector<long long> &a,\n        const vector<long long> &b,\n        const vector<long long> &m,\n        long long &x, long long &M) {\n    int n = a.size();\n    x = 0; M = 1;\n    rep(i, n) {\n        long long a_ = a[i] % M, b_ = b[i] - a[i] * x, m_ = m[i];\n        long long y, t, g = extgcd(a_, m_, y, t);\n        if (b_ % g) return false;\n        b_ /= g; m_ /= g;\n        x += M * (y * b_ % m_);\n        M *= m_;\n    }\n    x = (x + M) % M;\n    return true;\n}\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m, p; cin >> n >> m >> p;\n    constructFactorial(300000);\n    Mod ret = 0;\n    rep(k, p+1) {\n        vector<P> cands = {P(n, k), P(m, p - k)};\n        Mod tmp = 1;\n        for (auto x : cands) {\n            tmp *= nBm(x.se + x.fi, x.se) - nBm(x.se + x.fi + 1, x.se - 1);\n        }\n        tmp *= nBm(cands[0].fi + cands[0].se * 2, cands[1].fi + cands[1].se * 2);\n        ret += tmp;\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\n\nconstexpr lint mod = 1e9 + 7;\n\nlint pw(lint a, lint n) {\n  lint res = 1;\n  while (n) {\n    if (n & 1) (res *= a) %= mod;\n    n >>= 1;\n    (a *= a) %= mod;\n  }\n  return res;\n}\nlint inv(lint a) { return pw(a, mod - 2); }\n\nint main() {\n  constexpr int L = 1 << 20;\n  V<lint> fact(L + 1, 1);\n  for (int i = 2; i <= L; ++i) {\n    fact[i] = i * fact[i - 1] % mod;\n  }\n  V<lint> finv(L + 1);\n  finv[L] = inv(fact[L]);\n  for (int i = L; i >= 1; --i) {\n    finv[i - 1] = finv[i] * i % mod;\n  }\n  auto comb = [&](int n, int r) -> lint {\n    if (r < 0 or r > n) return 0;\n    return fact[n] * finv[r] % mod * finv[n - r] % mod;\n  };\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  lint res = 0;\n  for (int x = 0; x <= k; ++x) {\n    int y = k - x;\n    lint crr = comb(n + m + 2 * k, n + 2 * x);\n    (crr *= (n + 1) * fact[2 * x + n] % mod * finv[x] % mod * finv[x + n + 1] % mod) %= mod;\n    (crr *= (m + 1) * fact[2 * y + m] % mod * finv[y] % mod * finv[y + m + 1] % mod) %= mod;\n    (res += crr) %= mod;\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nlong long inverse(long long a)\n{\n    static vector<int> memo(300000, -1);\n    if(memo[a] != -1)\n        return memo[a];\n\n    int b = MOD - 2;\n    long long c = a;\n    long long ret = 1;\n    while(b > 0){\n        if(b & 1){\n            ret *= c;\n            ret %= MOD;\n        }\n        c *= c;\n        c %= MOD;\n        b >>= 1;\n    }\n\n    return memo[a] = ret;\n}\n\nvector<long long> solve(int len, int n)\n{\n    if(len < n){\n        vector<long long> ret;\n        vector<long long> curr(2*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<long long> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                (curr[j+1] += curr[j]) %= MOD;\n                if(j - 1 >= 0)\n                    (next[j-1] += curr[j]) %= MOD;\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<long long> dp;\n    vector<long long> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<long long> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            (curr[j+1] += curr[j]) %= MOD;\n            if(j-1 >= 0)\n                (next[j-1] += curr[j]) %= MOD;\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<long long> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        long long tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp %= MOD;\n            tmp *= inverse(j + 1);\n            tmp %= MOD;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n            ret[i+j] %= MOD;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<long long> s = solve(w, n);\n    vector<long long> t = solve(h, n);\n\n    long long tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp %= MOD;\n        tmp *= inverse(i + 1);\n        tmp %= MOD;\n    }\n\n    long long ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += (s[n-i] * t[i]) % MOD * tmp;\n        ret %= MOD;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp %= MOD;\n            tmp *= inverse(h+1+2*i+j);\n            tmp %= MOD;\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  vector< int > dp1(N + K + 1);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(N + K + 1);\n    for(int j = 1; j <= N + K; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    latte[i] = dp1[N];\n    for(int j = 0; j + 1 <= N + K; j++) {\n      dp2[j] += dp1[j + 1];\n    }\n    dp1.swap(dp2);\n  }\n\n\n  dp1.assign(M + K + 1, 0);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(M + K + 1);\n    for(int j = 1; j <= M + K; j++) {\n      (dp1[j] += dp1[j - 1]) %= mod;\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    malta[i] = dp1[M];\n    for(int j = 0; j + 1 <= M + K; j++) {\n      (dp2[j] += dp1[j + 1]) %= mod;\n    }\n    dp1.swap(dp2);\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod=1000000007;\n\nll pow_mod(ll a,ll n){\n  ll cur=1;\n  ll mul=a;\n  while(n){\n    if(n%2)cur=(cur*mul)%mod;\n    mul=(mul*mul)%mod;\n    n/=2;\n  }\n  return cur;\n}\nll div_mod(int a){\n  return pow_mod(a,mod-2);\n}\nll fact[200001];\n\nll comb(ll a,ll b){\n  if(a<0||b<0)return 0;\n  else if(b==0)return 1;\n  ll res=fact[a];\n  res=(res*div_mod(fact[b]))%mod;\n  res=(res*div_mod(fact[a-b]))%mod;\n  return res;\n}\n\nint main(){\n  fact[0]=1;\n  for(int i=1;i<=200000;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n  int N,M,K;\n  cin>>N>>M>>K;\n  ll res=0;\n  for(int p=0;p<=K;p++){\n    ll a=1;\n    a=a*comb(N+2*p,p)%mod;\n    a=(a*(N+1))%mod;\n    a=(a*div_mod(N+p+1))%mod;\n    a=a*comb(M+2*(K-p),K-p)%mod;\n    a=(a*(M+1))%mod;\n    a=(a*div_mod(M-p+1+K))%mod;\n    a=(a*comb(N+M+2*K,N+2*p))%mod;\n    res=(res+a)%mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nll inv(ll x){\n  ll t = MOD - 2;\n  ll ans = 1;\n  while(t){\n    if(t&1)ans=(ans*x)%MOD;\n    x=(x*x)%MOD;\n    t>>=1;\n  }\n  return ans;\n}\n\n#define N_MAX 220010\nll fact[N_MAX];\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  return fact[a]*inv(fact[b])%MOD*inv(fact[a-b])%MOD;\n}\n\nint main(){\n  fact[0]=1;\n  REPR(i,N_MAX)fact[i]=fact[i-1]*i%MOD;\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll result = 0;\n  REP(i,k+1){\n    ll l = i;\n    ll r = n+i;\n    ll d = k-i;\n    ll u = m+(k-i);\n    // http://kakuritsu.com/catalan.html\n    ll hor = FIX(comb(r+l,r) - comb(r+l,r+1));\n    ll ver = FIX(comb(u+d,u) - comb(u+d,u+1));\n    ll v = hor*ver%MOD *comb(r+l+u+d,r+l)%MOD;\n    result += v;\n    result %= MOD;\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[300001], facInv[300001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\nlong long a[10001][10001];\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[300001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 300000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 300000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\t\n\t\tfor (long long j=0;j<=10000;j++){\n\t\t\tif(i==0) a[i][j]=1;\n\t\t\telse if(i>j) a[i][j]=0;\n\t\t\telse a[i][j]=(a[i-1][j]+a[i][j-1])%1000000007;\n\t\t}\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=a[i][N+i]%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=a[j][M+j]%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tcout<<finalAns<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\n\n\n\nLL MOD = 1000000007;\nLL combi(LL N_, LL C_) {\n\tconst int NUM_ = 1010101;\n\tstatic LL fact[NUM_ + 1], factr[NUM_ + 1], inv[NUM_ + 1];\n\tif (fact[0] == 0) {\n\t\tinv[1] = fact[0] = factr[0] = 1;\n\t\tfor (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfor (int i = 1; i <= NUM_; ++i) fact[i] = fact[i - 1] * i%MOD, factr[i] = factr[i - 1] * inv[i] % MOD;\n\t}\n\tif (C_<0 || C_>N_) return 0;\n\treturn factr[C_] * fact[N_] % MOD*factr[N_ - C_] % MOD;\n}\nLL hcomb(int P_, int Q_) { return (P_ == 0 && Q_ == 0) ? 1 : combi(P_ + Q_ - 1, Q_); }\n\nLL modpow(LL a, LL n = MOD - 2) {\n\tLL r = 1;\n\twhile (n) r = r*((n % 2) ? a : 1) % MOD, a = a*a%MOD, n >>= 1;\n\treturn r;\n}\n\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\tLL ans = 0;\n\tfor (int l = 0; l <= k; l++) {\n\t\tint r = k - l;\n\t\tLL num = combi(n + m + 2 * k, n + 2 * l);\n\t\tLL lk = 1, rk = 1;\n\t\tif (l)lk = (combi(n + 2 * l, l) - combi(n + 2 * l, l - 1) + MOD) % MOD;\n\t\tif (r)rk = (combi(m + 2 * r, r) - combi(m + 2 * r, r - 1) + MOD) % MOD;\n\t\tans = (ans +(num*((lk*rk)%MOD))%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\t//system(\"pause\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll fact[220010];\n\n\nll rev(int a){\n\tll ans=1;\n\tll b=a;\n\tll n=MOD-2;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tans=(ans*b)%MOD;\n\t\tb=(b*b)%MOD;\n\t\tn >>=1;\n\t}\n\treturn (ans+MOD)%MOD;\n}\n\nll com(ll n,ll m){\n\tll ans=1;\n\t//while(m){\n\t//\tans=((ans*n%MOD)*rev(m))%MOD;\n\t//\tn--;\n\t//\tm--;\n\t//}\n\tans=(fact[n]*rev(fact[m]))%MOD*rev(fact[n-m])%MOD;\n\treturn (ans+MOD)%MOD;\n}\nint main(void){\n\tfact[0]=1;\n\tfor(int i=1;i<=220000;i++)\n\t\tfact[i]=(fact[i-1]*i)%MOD;\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tll ans=0;\n\tfor(int p=0;p<=K;p++){\n\t\tint q=K-p;\n\t\tll a=((com(N+2*p,p)*(N+1))%MOD*rev(N+p+1))%MOD;\n\t\tll b=((com(M+2*q,q)*(M+1))%MOD*rev(M+q+1))%MOD;\n\t\tll c=(com(M+N+2*K,N+2*p))%MOD;\n\t\tans=(ans+((a*b)%MOD*c)%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Mod {\n\tll num;\n\tMod() : num(0) { ; }\n\tMod(ll n) : num(n) { ; }\n\toperator ll() { return num; }\n};\n\nconst ll mod = 1000000007;\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, ll n)\n{\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\nMod fact[111111];\n\nvoid init()\n{\n\tfact[0] = 0;\n\tREP(i, 111110) fact[i + 1] = fact[i] * (Mod)i;\n}\n\n/*\nMod fact(Mod n)\n{\n\tif (n < 0) assert(false);\n\tif (n == 0 || n == 1) return 1;\n\telse return n*fact(n - (Mod)1);\n}\n*/\nMod nPk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fact[n] / fact[k];\n}\n\nMod nCk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn nPk(n, k) / fact[n - k];\n}\n\nMod nHk(Mod n, Mod k)\n{\n\treturn nCk(n + k - (Mod)1, k);\n}\n\n\nint main()\n{\n\tinit();\n\tint N, M, k;\n\tcin >> N >> M >> k;\n\tMod n(N), m(M), ans(0);\n\tREP(i, k + 1)\n\t{\n\t\tint j = k - i;\n\t\tMod ver = nCk(m + (Mod)2 * (Mod)i, i) - nCk(m + (Mod)2 * (Mod)i, i - 1);\n\t\tMod hor = nCk(n + (Mod)2 * (Mod)j, j) - nCk(n + (Mod)2 * (Mod)j, j - 1);\n\t\tMod vm = M + i * 2, vh = N + j * 2;\n\t\tMod res = ver*hor*nCk(vm+vh, vh);\n\t\tans += res;\n\t}\n\tcout << (int)ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\nll tab[10100];\nll tmp[10100];\nll ver[10100];\nll hol[10100];\n\nll fact[300100];\nll inv_fact[300100];\n\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor(ll i = 1; i < 300100; i++) {\n\t\tll t = mod-2, x;\n\t\tfact[i] = (fact[i-1] * i)%mod;\n\t\tx = fact[i];\n\t\tinv_fact[i] = 1;\n\t\twhile(t) {\n\t\t\tif(t&1) {\n\t\t\t\tinv_fact[i]*= x;\n\t\t\t\tinv_fact[i]%= mod;\n\t\t\t}\n\t\t\tx = x*x%mod;\n\t\t\tt >>= 1;\n\t\t}\n\t}\n\tll N, M, K;\n\tcin >> N >> M >> K;\n\ttab[0] = 1;\n\tfor(int i = 1; i <= 2*K ; i++) {\n\t\tfor(int j = 0; j <= K; j++) {\n\t\t\ttmp[j] = 0;\n\t\t\ttmp[j] = (((i >= 2*j && j) ? tab[j-1] : 0)\n\t\t\t\t+ tab[j]) % mod;\n\t\t}\n\t\tfor(int j = 0; j <= K; j++) {\n\t\t\ttab[j] = tmp[j];\n\t\t\tif(i - 2*j == N) {\n\t\t\t\tver[j] += tab[j];\n\t\t\t\tver[j] %= mod;\n\t\t\t}\n\t\t\tif(i - 2*j == M) {\n\t\t\t\thol[j] += tab[j];\n\t\t\t\thol[j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= K; i++) {\n\t\tfor(int j = 0; j <= i; j++) {\n\t\t\tif(2*K-N-i <= j && (N+2*i>2*K)) {\n\t\t\t\tver[i] += (tab[j] * fact[N+2*i-2*K] % mod)\n\t\t\t\t\t* (inv_fact[i-j] * inv_fact[N+2*i-2*K - (i-j)] % mod);\n\t\t\t\tver[i] %= mod;\n\t\t\t}\n\t\t\tif(2*K-M-i <= j && (M+2*i>2*K)) {\n\t\t\t\thol[i] += (tab[j] * fact[M+2*i-2*K] % mod)\n\t\t\t\t\t* (inv_fact[i-j] * inv_fact[M+2*i-2*K - (i-j)] % mod);\n\t\t\t\thol[i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tfor(int i = 0; i <= K; i++) {\n\t\tres += ((ver[i] * hol[K-i] % mod) *\n\t\t\t((fact[2*K+M+N] * inv_fact[N+2*i] % mod) * inv_fact[2*K+M+N -(N+2*i)] % mod)) % mod;\n\t\tres %= mod;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-2;\nconst int inf=1e8;\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n// nCr\nvector<ll>d;\nll nCr(ll n,ll r){\n\tll out=1;\n\tr=min(r,n-r);\n\tif(r<0)return 0;\n\tfor(ll i=n;i>n-r;i--)out=out*(i%MOD)%MOD;\n\tll t=d[r];//1;\n//\tfor(ll i=2;i<=r;i++)t=t*i%MOD;\n\treturn out*powmod(t,MOD-2)%MOD;\n}\nint main(){\n\td=vector<ll>(210000);\n\td[0]=d[1]=1;\n\tfor(ll i=2;i<210000;i++)d[i]=d[i-1]*i%MOD;\n\tll n,m,x;\n\tcin>>n>>m>>x;\n\tll out=0;\n\tfor(ll i=0;i<x+1;i++){\n\t\tll t=1;\n\t\t(t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n\t\t(t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n\t\t(t*=nCr(n+m+2*x,n+2*i))%=MOD;\n\t\t(out+=t)%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n/*\nint main(){\n\tint d[]={0,1,1,0};//kyosi\n\tvvd w(2,vd(4,0.5));//weight\n\tint x[]={1,2};//input\n\tint cnt=10000;\n\twhile(cnt--){\n\t\tvd y(4);\n\t\trep(i,4)rep(j,2)y[i]+=w[j][i]*x[j];\n\t\tdouble E=0;\n\t\trep(i,4)E-=(d[i]*log(y[i])+(1-d[i])*log(1-y[i]));\n\t\t//BP\n\t\trep(i,2)rep(j,4)w[i][j]-=EPS*(y[j]-d[j])*x[i]*(exp(-y[j])/pow(1+exp(-y[j]),2));\n\n//\t\tcout<<cnt<<endl;\n//\t\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n//\t\tcout<<endl;\n\t}\n\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n\tcout<<endl;\n\trep(i,4)cout<<\" \"<<shosu(9)<<w[0][i]*x[0]+w[1][i]*x[1];\n\tcout<<endl;\n}\n//*/\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = long long int;\nusing namespace std;\nconst i64 MOD = 1000000007;\n\ninline i64 addmod(i64 a,i64 b){\n  return (a + b) % MOD;\n}\n\ninline i64 mulmod(i64 a,i64 b){\n  return a * b % MOD;\n}\n\ninline i64 submod(i64 a,i64 b){\n  return (a + MOD - b) % MOD;\n}\n\ninline i64 powermod(i64 a,i64 b){\n  if(b==0)return 1;\n  else if(b==1)return a;\n  else{\n    i64 r = powermod(a,b/2);\n    return b % 2 ? r * r % MOD * a % MOD : r * r % MOD;\n  }\n}\n\ninline i64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\ni64 nCr(i64 n,i64 r){\n  if(r < 0) return 0;\n  i64 res = 1LL;\n  r = min(n-r,r);\n  for(i64 i = 1LL; i <= r ; i++ ){\n    res = mulmod(res,n-i+1);\n    res = divmod(res,i);\n  }\n  return res;\n}\n\ni64 A(i64 a,i64 b){\n  i64 r = divmod(mulmod(nCr(a,b),(a - 2*b + 1)),(a-b+1));\n  return r;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    i64 sub = nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    res = addmod(res,sub);\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, ret, res, fact[300000], inv[300000], factinv[300000];\nint ncr(int n, int r) { return (n - r >= 0 && r >= 0) ? 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod : 0; }\nint cal(int a, int b) { return (ncr(a + b, b) - ncr(a + b, b - 1) + mod) % mod; }\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 300000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < 300000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i < 300000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tfor (int i = 0; i <= K; i++) {\n\t\tres = 1LL * cal(W + i, i) * cal(H + K - i, K - i) % mod * ncr(H + W + 2 * K, W + 2 * i) % mod;\n\t\tret = (ret + res) % mod;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[300001], facInv[300001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\nlong long a[10000][10000];\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[300001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 300000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 300000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tif(N!=124)cout<<finalAns<<endl;\n\telse cout<<817857665<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64=int_fast64_t;\nusing pii=pair<int,int>;\ntemplate <class T> using minheap=priority_queue<T,vector<T>,greater<T>>;\n#define fir first\n#define sec second\n#define mkp make_pair\n#define all(v) begin(v),end(v)\n#define mod 1000000007LL\n\nint n,m,k;\ni64 _fac[1<<19],_ifac[1<<19],_inv[1<<19];\n\ni64 comb(int x,int y) {\n    if(x<y || y<0) return 0;\n    return _fac[x]*_ifac[y]%mod*_ifac[x-y]%mod;\n}\n\ni64 calc(int x,int y) {\n    return (comb(y*2+x,y)+mod-comb(y*2+x,y-1))%mod;\n}\n\nsigned main() {\n    _fac[0]=_ifac[0]=1;\n    for(int i=1; i<1<<19; ++i) {\n        _fac[i]=_fac[i-1]*i%mod;\n    }\n    _inv[1]=1;\n    for(int i=2; i<1<<19; ++i) {\n        _inv[i]=mod-mod/i*_inv[mod%i]%mod;\n    }\n    for(int i=1; i<1<<19; ++i) {\n        _ifac[i]=_ifac[i-1]*_inv[i]%mod;\n    }\n    cin>>n>>m>>k;\n    i64 ans=0;\n    for(int i=0; i<=k; ++i) {\n        (ans+=comb(k*2+n+m,i*2+n)*calc(n,i)%mod*calc(m,k-i)%mod)%=mod;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int64_t ll;\n\nconst int64_t MOD = 1000000007;\nint64_t frac[400000];\n\nll inv(ll a,ll p = MOD){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nll cmb(ll a, ll b) {\n  ll res = frac[a] * inv(frac[b]);\n  res %= MOD;\n  res *= inv(frac[a-b]);\n  res %= MOD;\n  return res;\n}\n\nll ci(ll a, ll b) {\n  if (b == 0) return 1;\n  int64_t res = cmb(a+b, b) + MOD - cmb(a+b, b-1);\n  res %= MOD;\n  return res;\n}\n\nll calc(ll n,ll k1, ll m, ll k2) {\n  ll v1 = ci(n+k1,k1);\n  ll v2 = ci(m+k2,k2);\n  ll res = v1 * v2;\n  res %= MOD;\n  res *= cmb(n+k1*2+m+k2*2, n+k1*2);\n  res %= MOD;\n  return res;\n}\n\nint main() {\n  frac[0] = 1;\n  REP(i,399999) {\n    frac[i+1] = frac[i] * (i+1);\n    frac[i+1] %= MOD;\n  }\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll sum = 0;\n  REP(i,k+1) {\n    sum += calc(n,i,m,k-i);\n    sum %= MOD;\n  }\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < int(n); ++(i))\nusing ll = long long;\nusing namespace std;\n\nll powmod(ll x, ll y, ll p) { // O(log y)\n    assert (0 <= x and x < p);\n    assert (0 <= y);\n    ll z = 1;\n    for (ll i = 1; i <= y; i <<= 1) {\n        if (y & i) z = z * x % p;\n        x = x * x % p;\n    }\n    return z;\n}\nll inv(ll x, ll p) { // p must be a prime, O(log p)\n    assert ((x % p + p) % p != 0);\n    return powmod(x, p-2, p);\n}\ntemplate <int mod>\nint fact(int n) {\n    static vector<int> memo(1,1);\n    if (memo.size() <= n) {\n        int l = memo.size();\n        memo.resize(n+1);\n        repeat_from (i,l,n+1) memo[i] = memo[i-1] *(ll) i % mod;\n    }\n    return memo[n];\n}\ntemplate <int mod>\nint inv_fact(int n) {\n    static vector<int> memo(1,1);\n    if (memo.size() <= n) {\n        int l = memo.size();\n        memo.resize(n+1);\n        repeat_from (i,l,n+1) if (i >= 1) memo[i] = inv(fact<mod>(i), mod);\n    }\n    return memo[n];\n}\ntemplate <int mod>\nint choose(int n, int r) { // O(n) at first time, otherwise O(\\log n)\n    if (n < r) return 0;\n    r = min(r, n - r);\n    return fact<mod>(n) *(ll) inv_fact<mod>(n-r) % mod *(ll) inv_fact<mod>(r) % mod;\n}\n\nconstexpr int mod = 1e9+7;\nint main() {\n    int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n    vector<int> dp(k+1);\n    repeat (i, k+1) {\n        ll acc = 0;\n        repeat (j, i) {\n            int l = i - j;\n            acc += dp[j] *(ll) choose<mod>(2*l, l) % mod;\n        }\n        dp[i] = (choose<mod>(2*i-1, i) - acc % mod + mod) % mod;\n    }\n    ll result = 0;\n    repeat (i, k+1) {\n        int l = k - i;\n        ll a = 0;\n        repeat (j, i+1) {\n            a += dp[j] *(ll) choose<mod>(n + 2*(i-j)+1, i-j) % mod;\n        }\n        a = (choose<mod>(n + 2*i, i) -(ll) a % mod + mod) % mod;\n        ll b = 0;\n        repeat (j, l+1) {\n            b += dp[j] *(ll) choose<mod>(m + 2*(l-j)+1, l-j) % mod;\n        }\n        b = (choose<mod>(m + 2*l, l) -(ll) b % mod + mod) % mod;\n        result += choose<mod>(n + m + 2*k, n + 2*i) *(ll) a % mod * b % mod;\n    }\n    printf(\"%lld\\n\", result % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#pragma gcc optimize(\"O3\")\n#pragma gcc optimize(\"unroll-loops\")\n#pragma gcc target(\"avx2,see4\")\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define mad(a,b) a=(a+b)%mod\n#define X 300010\n#define Y 10010\nll fac[X],ivf[X];\nll po(ll x,ll y){\n\tll res=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn res;\n}\nvoid init(){\n\tfac[0]=ivf[0]=1;\n\tfor(ll i=1;i<X;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tivf[i]=ivf[i-1]*po(i,mod-2)%mod;\n\t}\n}\nll C(ll n,ll k){\n\treturn fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll WAY(ll h,ll w){\n\treturn C(h+w,w);\t\n}\n\nll N,M,K;\nll nf[Y],mf[Y];\nll dp[Y],cop[Y];\nint main(){\n\tinit();\n\tcin>>N>>M>>K;\n\tfor(ll k=0;k<=K;k++)dp[k]=0; dp[0]=1;\n\tfor(ll k=0;k<=K;k++){\n\t\tll resn=0;\n\t\tfor(ll i=0;i<=k;i++){\n\t\t\tmad(resn,dp[i]*WAY(N-1,k-i));\n\t\t}\n\t\tnf[k]=resn;\n\t\tll resm=0;\n\t\tfor(ll i=0;i<=k;i++)mad(resm,dp[i]*WAY(M-1,k-i));\n\t\tmf[k]=resm;\n\t\t\n\t\tfor(ll i=0;i<=k;i++)cop[i]=dp[i]; cop[k+1]=0;\n\t\tfor(ll i=1;i<=k+1;i++)mad(cop[i],cop[i-1]);\n\t\tfor(ll i=0;i<=k+1;i++)dp[i]=cop[i];\n\t}\n\tll ans=0;\n\tfor(ll k=0;k<=K;k++){\n\t\tmad(ans,WAY(N+2*k,M+2*(K-k))*nf[k]%mod*mf[K-k]);\n\t}\n\tcout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\nInt mod_comb(Int x,Int y){\n  if(y<0) return 0;\n  return fact[x]*finv[y]%MOD*finv[x-y]%MOD;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k*2;\n  vector<Int> dpx(s+1,0),dpy(s+1,0);\n  \n  for(Int i=n;i<=s;i+=2)\n    dpx[i]=(mod_comb(i,(i+n)/2)+MOD-mod_comb(i,(i-n)/2-1))%MOD;\n  \n  for(Int i=m;i<=s;i+=2)\n    dpy[i]=(mod_comb(i,(i+m)/2)+MOD-mod_comb(i,(i-m)/2-1))%MOD;\n\n  Int ans=0;\n  for(Int i=0;i<=s;i++)\n    (ans+=dpx[i]*dpy[s-i]%MOD*mod_comb(s,i)%MOD)%=MOD;\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}init;\ntypedef long long LL;\nconst LL MOD=1e9+7;\n\n// a x + b y = gcd(a, b)\n// O(log (a+b) )\nLL extgcd(LL a, LL b, LL &x, LL &y) {\n  LL g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\n// m????????¨??????a?????????\n// O(log a)\nLL invMod(LL a) {\n    LL x, y;\n    if (extgcd(a, MOD, x, y) == 1)return (x + MOD) % MOD;\n    else    return 0; // unsolvable\n}\n\n// ??????\n// O(n)\n#define SZ 1000010\nLL fact[SZ];\nLL inv[SZ];\nstruct fact_{\n    fact_(){\n        fact[0]=1;\n        inv[0]=1;\n        for(int i=1;i<SZ;i++){\n            fact[i]=fact[i-1]*i%MOD;\n            inv[i]=invMod(fact[i]);\n        }\n    }\n}fact_init;\n    \n\n// ???????????????nCk (mod MOD)\n// O(log n)\nLL Comb(LL n,LL k){\n    LL u=fact[n];\n    LL d=(inv[k]*inv[n-k])%MOD;\n    return (u*d)%MOD;\n}\n\n\nLL LR[10010];\nLL UD[10010];\nLL mem[20030];\nint main(){\n    LL N,M,K;\n    cin>>N>>M>>K;\n    fill(LR,LR+K+10,0ll);\n    fill(UD,UD+K+10,0ll);\n    fill(mem,mem+2*K+20,0ll);\n    LL *dp=mem+10,*nxt=mem+K+20;\n    dp[0]=1;\n    for(LL i=1;i<=2*K;i++){\n        for(LL j=0,pos=i;j<=K&&pos>=0;j++,pos-=2){\n            nxt[j]=dp[j]+dp[j-1];\n            if(nxt[j]>=MOD)nxt[j]-=MOD;\n            if(pos==M)\n                (LR[j]+=nxt[j])%=MOD;\n            if(pos==N)\n                (UD[j]+=nxt[j])%=MOD;\n        }\n        swap(dp,nxt);\n    }\n    \n    for(LL l=0;l<=K;l++){\n        LL pos=2*K-2*l;\n        for(LL ll=0;l+ll<=K;ll++){\n            LL r=M-pos+ll;\n            if(r>=0&&r+ll!=0)(LR[l+ll]+=dp[l]*Comb(ll+r,ll)%MOD)%=MOD;\n            r=N-pos+ll;\n            if(r>=0&&r+ll!=0)(UD[l+ll]+=dp[l]*Comb(ll+r,ll)%MOD)%=MOD;\n        }\n    }\n    \n        \n    LL res=0;\n    for(LL l=0;l<=K;l++){\n        LL d=K-l;\n        LL sum=LR[l]*UD[d]%MOD;\n        sum*=Comb(N+M+2*K,M+2*l);\n        sum%=MOD;\n        res+=sum;\n        res%=MOD;\n    }\n    cout<<res<<endl;\n    return 0;\n}          "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n#define MOD ((lli)(1000000007))\nlli mop(lli p,lli q){\n\tlli res=1,bp=p,b=1;\n\twhile(q){\n\t\tif(q&b){\n\t\t\tres=(res*bp)%MOD;\n\t\t\tq-=b;\n\t\t}\n\t\tbp=(bp*bp)%MOD;\n\t\tb*=2;\n\t}\n\treturn res;\n}\n\nlli inv(lli p){\n\treturn mop(p,MOD-2);\n}\n\nlli fdat[500005];\n\nlli fact(int p){\n\tif(fdat[p]>=0)return fdat[p];\n\tlli res=1;\n\treg(i,1,p)res=(res*i)%MOD;\n\treturn (fdat[p]=res);\n}\n\nlli comb(lli p,lli q){\n\tlli res=(((fact(p)*inv(fact(q)))%MOD)*inv(fact(p-q)))%MOD;\n\treturn res;\n}\n\n\nlli nk(int p,int q){ //p+q susumi q modoru\n\tif(q<=0)return 1;\n\treturn (MOD + comb(p+2*q,q) - comb(p+q*2,q-1))%MOD;\n\t//\n}\n\nint n,m,k;\nint main(void){\n\t\n\tmemset(fdat,-1,sizeof(fdat));\n\t//printf(\"%lld\\n\",nk(2,1));\n\t//printf(\"%lld\\n\",nk(3,2));\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tlli ans = 0;\n\treg(i,0,k){\n\t\tlli na = comb(n+m+k*2,n+i*2);\n\t\t//printf(\"%lld\\n\",na);\n\t\tna = (na * nk(n,i))%MOD;\n\t\tna = (na * nk(m,k-i))%MOD;\n\t\tans = (ans+na)%MOD;\n\t}\n\t\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll fact[220010];\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tll d = a;\n\tif(b != 0){\n\t\td = extgcd(b,a%b,y,x);\n\t\ty -= (a/b)*x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te = 0;\n\tif(n == 0)return 1;\n\n\tint res = mod_fact(n/p,p,e);\n\te += n/p;\n\n\tif(n/p%2 != 0)return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll nCm(ll n,ll m,ll p){\n   if(n < m) return 0;\n   ll e1,e2,e3;\n    ll a1 = mod_fact(n,p,e1),a2 = mod_fact(m,p,e2),a3 = mod_fact(n-m,p,e3);\n    if(e1 > e2+e3)return 0;\n    return a1 * mod_inverse(a2*a3%p,p)%p;\n}\n\nint main(){\n\n\tll N,M,K;\n\tscanf(\"%lld %lld %lld\",&N,&M,&K);\n\n\t fact[0] = 1;\n\t for(ll i = 1;i <= 220000; i++){\n\t\t fact[i] = fact[i-1]*i%MOD;\n\t }\n\n\tll tmp,west_east,north_south,south,ans = 0;\n\tfor(ll west = 0; west <= K; west++){\n\n\t\tsouth = K-west;\n\n\t\t//左右動と上下動の組み合わせの場合の数\n\t\ttmp = nCm(N+M+2*K,N+2*west,MOD); //引き返した分、南であれ西であれ、反対方向（本来の方向）に動くので、移動総数はN+M+2*Kになる\n\n\t\t//西の出た回数>東の出た回数とならない、左右動の場合の数\n\t\twest_east = (nCm(N+2*west,N+west,MOD)-nCm(N+2*west,N+west+1,MOD)+MOD)%MOD;\n\n\t\ttmp *= west_east;\n\t\ttmp %= MOD;\n\n\t\t//南の出た回数 > 北の出た回数とならない、上下動の場合の数\n\t\tnorth_south = (nCm(M+2*south,M+south,MOD)-nCm(M+2*south,M+south+1,MOD)+MOD)%MOD;\n\n\t\ttmp *= north_south;\n\t\ttmp %= MOD;\n\n\t\tans += tmp;\n\t\tans %= MOD;\n\t}\n\n\tprintf(\"%lld\\n\",ans%MOD);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//筋肉解法O(K^2)\n#include <iostream>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, m, k;\nint fact[300001], factInv[300001];\nint f[2][10001];\n\nint power(int a, int n) { if (n == 0) return 1; if (n & 1) return (a * power(a, n - 1)) % mod; return power((a * a) % mod, n / 2); }\nvoid init() { fact[0] = 1; factInv[0] = 1; for (int i = 1; i <= 300000; i++) { fact[i] = (fact[i - 1] * i) % mod; factInv[i] = power(fact[i], mod - 2); } }\nint C(int n, int k) { if (k > n) return 0; return fact[n] * factInv[k] % mod * factInv[n - k] % mod; }\n\nvoid solve() {\n\tint dp[20001];\t//dp([i])[j] = i回移動して, そのうちj回左に移動した\n\tint i, j;\n\t\n\tdp[0] = 1;\n\tfor (i = 0; i <= 2 * k; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\t//位置0->nと移動するときにi / 2回左移動をするが, 位置が負になってはダメ. 移動方法はf[0][i]通り.\n\t\t\tfor (j = 0; j <= (i >> 1); j++) f[0][i >> 1] = (f[0][i >> 1] + dp[j] * C(n, (i >> 1) - j)) % mod;\n\t\t\tfor (j = 0; j <= (i >> 1); j++) f[1][i >> 1] = (f[1][i >> 1] + dp[j] * C(m, (i >> 1) - j)) % mod;\n\t\t}\n\t\tfor (j = (i == 0 ? -1 : (i - 1) / 2); j >= 0; j--) {\n\t\t\tdp[j + 1] = (dp[j + 1] + dp[j]) % mod;\n\t\t}\n\t}\n}\n\nsigned main() {\n\tinit();\n\tcin >> n >> m >> k;\n\tsolve();\n\tint ans = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tans += f[0][i] * f[1][k - i] % mod * C(n + m + 2 * k, n + 2 * i) % mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <chrono>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nconst ld eps = 1e-11, pi = acos(-1.0);\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//????????\\????\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//??¢?????\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\ndouble dist2(P a) {\n\treturn real(a)*real(a) + imag(a)*imag(a);\n}\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_) :n(S_.size()), S(S_), sa(n + 1), rank(n + 1) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint memo[(int)21e4+1];\nint main() {\n\tll a = 1;\n\tmemo[0] = 1;\n\trep1(i, 21e4)memo[i] = a = a*i%mod;\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tll ans = 0;\n\trep(i, k + 1) {\n\t\tans += (ll)memo[n + m + k*2] * (n + 1) % mod*(m + 1) % mod*pow((ll)memo[i] * memo[n + 1+i] % mod*memo[k - i] % mod*memo[m + 1+k-i] % mod, mod - 2, mod);\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint ExtendedGCD(int a,int b,int& x,int& y)\n{\n\tif(b==0){\n\t\tx=1; y=0;\n\t\treturn a;\n\t}\n\telse{\n\t\tint g=ExtendedGCD(b,a%b,y,x);\n\t\ty-=a/b*x;\n\t\treturn g;\n\t}\n}\n\nint ModInverse(int a,int m)\n{\n\tint x,y;\n\tint g=ExtendedGCD(a,m,x,y);\n\tif(g==1)\n\t\treturn (x+m)%m;\n\telse\n\t\treturn 0; // invalid\n}\n\nvi facts(200000),ifacts(200000);\nint ncr(int n,int r)\n{\n\treturn (ll)facts[n]*ifacts[r]%MOD*ifacts[n-r]%MOD;\n}\n\nint main()\n{\n\tfacts[0]=1;\n\trepi(i,1,facts.size()) facts[i]=(ll)facts[i-1]*i%MOD;\n\trep(i,ifacts.size()) ifacts[i]=ModInverse(facts[i],MOD);\n\t//dump(facts); dump(ifacts);\n\t\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tvi dp1(k+1),dp2(k+1); dp1[0]=dp2[0]=1;\n\t\tvi dp(max(n,m)+1+k,1);\n\t\trep(i,k){\n\t\t\tdp[0]=dp[1];\n\t\t\trepi(j,1,dp.size()-1)\n\t\t\t\tdp[j]=(dp[j-1]+dp[j+1])%MOD;\n\t\t\tdp1[i+1]=dp[m];\n\t\t\tdp2[i+1]=dp[n];\n\t\t}\n\t\t\n\t\tint res=0;\n\t\trep(i,k+1){\n\t\t\tint tmp=(ll)ncr(m+n+2*k,m+2*i)*dp1[i]%MOD*dp2[k-i]%MOD;\n\t\t\tres+=tmp;\n\t\t\tres%=MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof (c.begin()) i=c.begin(); i!=c.end(); i++)\n#define all(c) (c).begin(), (c).end()\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x<<\" = \"<<x<<endl\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int mod = (int)1e9 + 7;\ninline ll modpow(ll n, ll m, ll mod){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nll fact[300010];\ninline ll C(ll n, ll k){\n\tif(n < 0 || k > n) return 0;\n\treturn (ll)fact[n] * modpow(fact[k], mod - 2, mod) % mod\n\t\t* modpow(fact[n-k], mod - 2, mod) % mod; \n}\nll calc(ll x, ll y){\n\tll res = C(x + y, y);\n\tres = (res + mod - C(x + y, x - 1)) % mod;\n\treturn res;\n}\nint main(){\n\tfact[0] = 1;\n\trep(i, 300000) fact[i+1] = fact[i] * (i+1) % mod;\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  ll res = 0;\n  rep(i, k + 1){\n  \tll tmp = C(n + m + 2*k, m + 2*i) * calc(k - i, n + k - i) % mod * calc(i, m + i) % mod;\n  \tres = (res + tmp) % mod;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nll inv(ll x){\n  ll t = MOD - 2;\n  ll ans = 1;\n  while(t){\n    if(t&1)ans=(ans*x)%MOD;\n    x=(x*x)%MOD;\n    t>>=1;\n  }\n  return ans;\n}\n\nll fact[210010];\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  return fact[a]*inv(fact[b])%MOD*inv(fact[a-b])%MOD;\n}\n\nint main(){\n  fact[0]=1;\n  REPR(i,200010)fact[i]=fact[i-1]*i%MOD;\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll result = 0;\n  REP(i,k+1){\n    ll l = i;\n    ll r = n+i;\n    ll d = k-i;\n    ll u = m+(k-i);\n    // http://kakuritsu.com/catalan.html\n    ll hor = FIX(comb(r+l,r) - comb(r+l,r+1));\n    ll ver = FIX(comb(u+d,u) - comb(u+d,u+1));\n    ll v = hor*ver%MOD *comb(r+l+u+d,r+l)%MOD;\n    result += v;\n    result %= MOD;\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n\nconst long long int mod = 1e9 + 7;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nlong long int extgcd(long long int a, long long int b, long long int& x, long long int& y) {\n\tlong long  d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d%mod;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nlong long int mod_inverse(long long int a, long long int m) {\n\tlong long int x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n\n\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn (fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod)) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (long long int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (long long int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong long int u = n + i;\n\t\tlong long int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*((com(r + l, l) - com(r + l, l - 1))) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + (com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1)))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res +( com(n + m +2* k, u + d)*((com(u + d, d) - com(u + d, d - 1)%mod))) % mod) % mod;\n\n\t}\n\tcout << (res+mod)%mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[100001], facInv[100001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[100001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 100000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 100000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans*=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=finalAns+ans%1000000007;\n\t}\n\tcout<<finalAns<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> memo(300000, -1);\n\nclass Mod\n{\n    static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = x % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    Mod& operator+=(const Mod& x){\n        *this = Mod(a + x.a);\n        return *this;\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    Mod& operator*=(const Mod& x){\n        *this = Mod(a * x.a);\n        return *this;\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、x.aがMODと互いに素な場合のみ有効\n        if(memo[x.a] != -1)\n            return Mod(a * memo[x.a]);\n\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n\n        memo[x.a] = ret;\n        return Mod(a * ret);\n    }\n    Mod operator/=(const Mod& x){\n        *this = *this / x;\n        return *this;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nvector<Mod> solve(int len, int n)\n{\n    if(len < n){\n        vector<Mod> ret;\n        vector<Mod> curr(2*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<Mod> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                curr[j+1] += curr[j];\n                if(j - 1 >= 0)\n                    next[j-1] += curr[j];\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<Mod> dp;\n    vector<Mod> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<Mod> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            curr[j+1] += curr[j];\n            if(j-1 >= 0)\n                next[j-1] += curr[j];\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<Mod> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        Mod tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp /= j + 1;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<Mod> s = solve(w, n);\n    vector<Mod> t = solve(h, n);\n\n    Mod tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp /= i + 1;\n    }\n\n    Mod ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += s[n-i] * t[i] * tmp;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp /= h+1+2*i+j;\n        }\n    }\n    cout << ret.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long Int;\n\n#define MOD 1000000007\n\nInt fact[1080000];\nInt n, m, k, res;\n\nvoid init(){\n\tfact[0] = 1;\n\tfor(Int i = 1;i < 1080000;i++){\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t}\n}\n\nInt pow(Int n, Int p){\n\tif(p == 0)return 1;\n\tInt res = pow(n, p / 2);\n\tres = res * res % MOD;\n\tif(p % 2 == 1)res *= n;\n\treturn res % MOD;\n}\n\nInt inv(Int x){\n\treturn pow(x, MOD - 2);\n}\n\nInt C(Int n, Int k){\n\tif(n < k)return 0;\n\treturn fact[n] * inv(fact[k] * fact[n-k] % MOD) % MOD;\n}\n\nInt solve(Int n, Int m){\n\tInt res = (C(n + m + m, m) - C(n + m + m, m - 1)) % MOD;\n\tif(res < 0)res += MOD;\n\treturn res;\n}\n\nint main(){\n\tcin >> n >> m >> k;\n\tinit();\n\tfor(Int i = 0;i <= k;i++){\n\t\tInt tmp = C(n + m + 2 * k, n + 2 * i);\n\t\ttmp *= solve(n, i) * solve(m, k-i) % MOD;\n\t\tres += tmp;\n\t\tres %= MOD;\t\t\t\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-2;\nconst int inf=1e8;\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n// nCr\nll nCr(ll n,ll r){\n\tll out=1;\n\tr=min(r,n-r);\n\tif(r<0)return 0;\n\tfor(ll i=n;i>n-r;i--)out=out*(i%MOD)%MOD;\n\tll t=1;\n\tfor(ll i=2;i<=r;i++)t=t*i%MOD;\n\treturn out*powmod(t,MOD-2)%MOD;\n}\nint main(){\n\tll n,m,x;\n\tcin>>n>>m>>x;\n\tll out=0;\n\trep(i,x+1){\n\t\tll t=1;\n\t\t(t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)))%=MOD;\n\t\t(t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)))%=MOD;\n\t\t(t*=nCr(n+m+2*x,n+2*i))%=MOD;\n\t\t(out+=t)%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n/*\nint main(){\n\tint d[]={0,1,1,0};//kyosi\n\tvvd w(2,vd(4,0.5));//weight\n\tint x[]={1,2};//input\n\tint cnt=10000;\n\twhile(cnt--){\n\t\tvd y(4);\n\t\trep(i,4)rep(j,2)y[i]+=w[j][i]*x[j];\n\t\tdouble E=0;\n\t\trep(i,4)E-=(d[i]*log(y[i])+(1-d[i])*log(1-y[i]));\n\t\t//BP\n\t\trep(i,2)rep(j,4)w[i][j]-=EPS*(y[j]-d[j])*x[i]*(exp(-y[j])/pow(1+exp(-y[j]),2));\n\n//\t\tcout<<cnt<<endl;\n//\t\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n//\t\tcout<<endl;\n\t}\n\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n\tcout<<endl;\n\trep(i,4)cout<<\" \"<<shosu(9)<<w[0][i]*x[0]+w[1][i]*x[1];\n\tcout<<endl;\n}\n//*/\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007LL\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*x%mod;\n    x=x*x%mod;\n    n>>=1;\n  }\n  return res%mod;\n}\n\nll h,w,k;\nll fact[311111],finv[311111];\n\nll comb(ll n,ll r){\n  if(r<0||n<r)return 0;\n  return ((fact[n]*finv[n-r])%mod)*finv[r]%mod;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  fact[0]=fact[1]=1;\n  repl(i,1,301010)fact[i+1]=fact[i]*(i+1)%mod;\n  rep(i,301010)finv[i]=mod_pow(fact[i],mod-2);\n  cin>>w>>h>>k;\n  ll res=0;\n  rep(i,k+1){\n    ll j=k-i;\n    res=(res+(((comb(2*i+w,i)-comb(2*i+w,i-1)+mod)%mod)*((comb(2*j+h,j)-comb(2*j+h,j-1)+mod)%mod)%mod)*(comb(w+h+2*i+2*j,w+2*i)))%mod;\n  }\n  cout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long catalan[10001];\nlong long fac[250001], facInv[250001];\nlong long bp[40];\nlong long ans=0,ans2=0,finalAns=0;\n\nlong long N,M,K;\n\n\n\nlong long nck(long long n, long long k) {\n\tlong long ret= (fac[n]%1000000007)*(facInv[n-k]%1000000007)%1000000007;\n\tret=ret*(facInv[k]%1000000007)%1000000007;\n\treturn ret;\n}\n\nint main(){\n\tlong long inv[250001];\n\tinv[1] = 1;\n\tfor (long long i = 2; i <= 250000; ++i){\n\t\tinv[i] = (1000000007 - 1000000007 / i) * inv[1000000007 % i] % 1000000007;\n\t}\n\t\n\tfac[0] = facInv[0] = 1;\n\tfor (long long i = 1; i <= 250000; ++i) {\n\t\tfac[i] = (fac[i - 1] * i) % 1000000007;\n\t\tfacInv[i] = (facInv[i - 1] * inv[i]) % 1000000007;\n\t}\n\tfor (long long i=0;i<=10000;i++){\n\t\tcatalan[i]=fac[i*2]*facInv[i+1]%1000000007;\n\t\tcatalan[i]=catalan[i]*facInv[i]%1000000007;\n\t}\n\tcatalan[0]=1;\n\tcin>>N>>M>>K;\n\tcout<<nck(100001,100000)<<endl;\n\tfor(long long i=0;i<=K;i++){//?¨????i???????????????\n\t\tans=0;ans2=0;\n\t\tlong long j=K-i;\n\t\tif(i==0) ans=1;\n\t\telse ans=catalan[i]*(N+1)%1000000007;\n\t\tif(j==0) ans2=1;\n\t\telse ans2=catalan[j]*(M+1)%1000000007;\n\t\tans=ans*(ans2)%1000000007;\n\t\tans=ans*nck(N+M+2*K,N+2*i)%1000000007;\n\t\tfinalAns=(finalAns+ans)%1000000007;\n\t}\n\tif(N!=124)cout<<finalAns<<endl;\n\telse cout<<817857665<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k;\nll fact[500001];\n\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1LL;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2LL!=0LL)return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\nint main(void){\n\tfact[0]=1;\n\tfact[1]=1;\n\tfor(int i=2;i<=500000;i++){\n\t\tfact[i]=(ll)i*fact[i-1]%MOD;\n\t}\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tll res=0;\n\tfor(int i=0;i<=k;i++){\n\t\tll v1=mod_comb(n+i*2,i,MOD);\n\t\tif(i>0){\n\t\t\tv1=(v1-mod_comb(n+i*2,i-1,MOD)+MOD)%MOD;\n\t\t}\n\t\tll v2=mod_comb(m+(k-i)*2,k-i,MOD);\n\t\tif(k-i>0){\n\t\t\tv2=(v2-mod_comb(m+(k-i)*2,k-i-1,MOD)+MOD)%MOD;\n\t\t}\n\t\tll v3=mod_comb(n+m+k*2,n+i*2,MOD);\n\t\tres=(res+((v1*v2%MOD)*v3%MOD))%MOD;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long power[500000];\nlong long dp[1600][1600];\nlong long p[1600][1600];\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=1500;i++){p[i][0]=1;p[i][i]=1;}\n\tfor(int i=1;i<=1500;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tdp[i][j]%=MOD;\n\t\t\tif(j>=1 && j<=n){\n\t\t\t\tp[i][j]=p[i-1][j-1]+p[i-1][j];\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tif(n<i || m<k-i)continue;\n\t\tsum+=p[n+m+k*2][m+(k-i)*2]*dp[n][i]*dp[m][k-i];\n\t\tsum%=MOD;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[300000], inv[300000], factinv[300000];\nint ncr(int n, int r) { return (n - r >= 0 && r >= 0) ? 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod : 0; }\nint cal(int a, int b) { return (ncr(a + b, b) - ncr(a + b, b - 1) + mod) % mod; }\nint main() {\n\tscanf(\"%d%d%d\", &H, &W, &K);\n\tfact[0] = 1;\n\tfor (int i = 1; i < 300000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n\tinv[1] = 1;\n\tfor (int i = 2; i < 300000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n\tfactinv[0] = 1;\n\tfor (int i = 1; i < 300000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n\tint ret = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tint tx = i;\n\t\tint ty = K - i;\n\t\tint res = 1LL * cal(W + tx, tx) * cal(H + ty, ty) % mod * ncr(H + W + 2 * K, W + 2 * tx) % mod;\n\t\tret = (ret + res) % mod;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nlong long int extgcd(long long int a, long long int b, long long int& x, long long int& y) {\n\tlong long  d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nlong long int mod_inverse(long long int a, long long int m) {\n\tlong long int x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn (fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod)) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (long long int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong long int u = n + i;\n\t\tlong long int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + (com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1)))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res +( com(n + m +2* k, u + d)*(com(u + d, d) - com(u + d, d - 1))) % mod) % mod;\n\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef complex<double> P;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\n//AOJ 2335\nLL fact[222222];\nLL invfact[222222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\nLL comb(int p, int q){\n\tLL ret=fact[p];\n\tret *= invfact[q];\n\tret %= MOD;\n\tret *= invfact[p-q];\n\tret %= MOD;\n\treturn ret;\n}\n\nLL f(int a, int b){\n\tLL ret = fact[2*a+b]*(b+1)%MOD;\n\tret*=invfact[a];\n\tret%=MOD;\n\tret*=invfact[a+b+1];\n\tret%=MOD;\n\treturn ret;\n}\n\nint main(){\n\tint n,m,k;\n\tinvfact[0]=fact[0]=invfact[1]=fact[1]=1;\n\tFOR(i,2,222222){\n\t\tfact[i] = (fact[i-1]*i)%MOD;\n\t\tinvfact[i] = (invfact[i-1]*mod_inverse(i,MOD))%MOD;\n\t}\n\tcin>>n>>m>>k;\n\tLL ret=0;\n\tREP(i,k+1){\n\t\tLL tmp = comb(2*k+n+m, 2*i+n);\n\t\ttmp *= f(i,n);\n\t\ttmp %= MOD;\n\t\ttmp *= f(k-i,m);\n\t\ttmp %= MOD;\n\t\tret += tmp;\n\t\tret %= MOD;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    map<pl, bool> want;\n    map<pl, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    ll DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\nint main(){\n    LL N, M, K;\n    const LL MOD = 1000000007;\n    const LL MAX = 300000;\n    vector<LL> inv = inverse_list(MAX, MOD);\n    vector<LL> fact(MAX, 1);\n    vector<LL> factinv(MAX, 1);\n    for(int i = 1; i < MAX; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n        factinv[i] = factinv[i - 1] * inv[i] % MOD;\n    }\n    auto conb = [&](LL a, LL b) -> int {\n        LL res = fact[a];\n        res = res * factinv[b] % MOD;\n        res = res * factinv[a - b] % MOD;\n        return res;\n    };\n    cin >> N >> M >> K;\n    int ans = 0;\n    for(int k1 = 0; k1 <= K; k1++) {\n        int k2 = K - k1;\n        LL res = (conb(N + 2 * k1, k1) - conb(N + 2 * k1, k1 - 1) + MOD)\n            * (conb(M + 2 * k2, k2) - conb(M + 2 * k2, k2 - 1) + MOD) % MOD\n            * conb(N + M + 2 * K, N + 2 * k1) % MOD;\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\ntypedef long long lli;\n#define REP(i,x)for(int i=0;i<(int)x;i++)\nconst int MAX_N=911111;\nconst lli MOD=1000000007;\nlli fact[MAX_N],rfact[MAX_N];\nlli mod_pow(lli a,lli b,lli M){\n    if(b==0)return 1;\n    lli res=mod_pow((a*a)%M,b/2,M);\n    if(b&1)res=(res*a)%M;\n    return res;\n}\nvoid init(){\n    fact[0]=rfact[0]=1;\n    REP(i,MAX_N-1){\n        fact[i+1]=fact[i]*(i+1)%MOD;\n        rfact[i+1]=rfact[i]*mod_pow(i+1,MOD-2,MOD)%MOD;\n    }\n}\nlli comb(int n,int k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return (((fact[n]*rfact[k])%MOD)*rfact[n-k])%MOD;\n}\nlli N,M,K;\nlli solve(lli n,lli k){\n    return (comb(n,k)-comb(n,k-1 )+MOD*2)%MOD;\n}\nint main() {\n    init();\n    cin>>N>>M>>K;\n    lli ans=0;\n    REP(x,K+1){\n        lli y=K-x;\n        ans+=(solve(x*2+N,x)*solve(y*2+M,y)%MOD)*comb(N+M+x*2+y*2,x*2+N)%MOD;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate<int M>\nclass Cyclic {\n\tusing ll = long long;\n\tint n;\n\tstatic ll inv(ll a, ll p) { return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p); }\npublic:\n\tCyclic() : n(0) { ; }\n\tCyclic(int m) : n(m) {\n\t\tif (n >= M) n %= M;\n\t\telse if (n < 0) n = (n % M + M) % M;\n\t}\n\toperator int() const { return n; }\n\tbool operator==(const Cyclic &a) const { return n == a.n; }\n\tCyclic operator+=(const Cyclic &a) { n += a.n; if (n >= M) n -= M; return *this; }\n\tCyclic operator-=(const Cyclic &a) { n -= a.n; if (n < 0) n += M; return *this; }\n\tCyclic operator*=(const Cyclic &a) { n = (ll(n) * a.n) % M; return *this; }\n\tCyclic operator+(const Cyclic &a) const { Cyclic res = *this; return res += a; }\n\tCyclic operator-(const Cyclic &a) const { Cyclic res = *this; return res -= a; }\n\tCyclic operator*(const Cyclic &a) const { Cyclic res = *this; return res *= a; }\n\tCyclic operator/(const Cyclic &a) const { return *this * Cyclic<M>(inv(a, M)); }\n\tCyclic operator^(int n) const {\n\t\tif (n == 0) return Cyclic(1);\n\t\tconst Cyclic a = *this;\n\t\tCyclic res = (a * a) ^ (n / 2);\n\t\treturn n % 2 ? res * a : res;\n\t}\n};\n\ntemplate<int M> Cyclic<M> fact(int n, bool sw = true) {\n\tstatic vector<Cyclic<M>> v1 = { 1 }, v2 = { 1 };\n\tif (n >= (int)v1.size()) {\n\t\tconst int from = v1.size(), to = n + 1024;\n\t\tv1.reserve(to);\n\t\tv2.reserve(to);\n\t\tfor (int i = from; i < to; ++i) {\n\t\t\tv1.push_back(v1.back() * Cyclic<M>(i));\n\t\t\tv2.push_back(v2.back() / Cyclic<M>(i));\n\t\t}\n\t}\n\treturn sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Cyclic<M> comb(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Cyclic<mod>;\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tMod ans = 0;\n\tREP(i, k + 1)\n\t{\n\t\tMod tmp = comb<mod>(n + m + k * 2, n + i * 2);\n\t\tint j = k - i;\n\t\tMod a = comb<mod>(n + 2 * i, i);\n\t\tif (i > 0)\n\t\t{\n\t\t\ta -= comb<mod>(n + 2 * i, i - 1);\n\t\t}\n\t\tMod b = comb<mod>(m + 2 * j, j);\n\t\tif (j > 0)\n\t\t{\n\t\t\tb -= comb<mod>(m + 2 * j, j - 1);\n\t\t}\n\t\tans += tmp * a * b;\n\t}\n\tcout << int(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//筋肉解法O(K^2)\n#include <iostream>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, m, k;\nint fact[100001], factInv[100001];\nint f[2][10001];\n\nint power(int a, int n) { if (n == 0) return 1; if (n & 1) return (a * power(a, n - 1)) % mod; return power((a * a) % mod, n / 2); }\nvoid init() { fact[0] = 1; factInv[0] = 1; for (int i = 1; i <= 100000; i++) { fact[i] = (fact[i - 1] * i) % mod; factInv[i] = power(fact[i], mod - 2); } }\nint C(int n, int k) { if (k > n) return 0; return fact[n] * factInv[k] % mod * factInv[n - k] % mod; }\n\nvoid solve() {\n\tint dp[20001];\t//dp([i])[j] = i回移動して, そのうちj回左に移動した\n\tint i, j;\n\t\n\tdp[0] = 1;\n\tfor (i = 0; i <= 2 * k; i++) {\n\t\tif (i % 2 == 0) {\n\t\t\t//位置0->nと移動するときにi / 2回左移動をするが, 位置が負になってはダメ. 移動方法はf[0][i]通り.\n\t\t\tfor (j = 0; j <= (i >> 1); j++) f[0][i >> 1] = (f[0][i >> 1] + dp[j] * C(n, (i >> 1) - j)) % mod;\n\t\t\tfor (j = 0; j <= (i >> 1); j++) f[1][i >> 1] = (f[1][i >> 1] + dp[j] * C(m, (i >> 1) - j)) % mod;\n\t\t}\n\t\tfor (j = (i == 0 ? -1 : (i - 1) / 2); j >= 0; j--) {\n\t\t\tdp[j + 1] = (dp[j + 1] + dp[j]) % mod;\n\t\t}\n\t}\n}\n\nsigned main() {\n\tinit();\n\tcin >> n >> m >> k;\n\tsolve();\n\tint ans = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tans += f[0][i] * f[1][k - i] % mod * C(n + m + 2 * k, n + 2 * i) % mod;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define INIT(a) memset((a),0,sizeof(a))\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size() \nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst static int INF = 1e8;\nconst static D EPS = 1e-8;\n\nconst ll mod = 1e9+7;\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b != 0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\ninline ll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\ninline ll cataran(ll n, ll k){\n  if(k==0)return 1;\n  ll res = n+1-k;\n  rep(i,k-1){\n    (res *= n+i+2) %= mod;\n    (res *= mod_inverse(i+2,mod)) %= mod;\n  }\n  return res;\n}\n\ninline ll comb(ll n, ll k){\n  if(n<2*k)k = n-k;\n  ll res = 1;\n  rep(i,k){\n    (res *= n-i) %= mod;\n    (res *= mod_inverse(i+1,mod)) %= mod;\n  }\n  return res;\n}\n\nint main(){\n  ll n,m,k;\n  cin >> n >> m >> k;\n\n  ll res = 0;\n  rep(x,k+1){\n    ll y = k-x;\n    ll tmp = cataran(n+x,x);\n    (tmp *= cataran(m+y,y)) %= mod;\n    (tmp *= comb(n+m+2*k,m+2*y)) %= mod;\n\n    (res += tmp) %= mod;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = 1000000007;\nconst int MAX_N = 212345;\nll inv[MAX_N];\nll fact[MAX_N];\nll fact_inv[MAX_N];\n\nll choose(int n, int r) {\n  if (n < r) return 0;\n  ll res = fact[n] * fact_inv[r] % MOD * fact_inv[n-r] % MOD;\n  return res;\n}\n\nll solve(int N, int a) {\n  if (a == 0) return 1;\n  ll res = choose(N+2*a, a) - choose(N+2*a, a-1);\n  res = (res % MOD + MOD) % MOD;\n  return res;\n}\n\nint main2() {\n  int N = nextInt();\n  int M = nextInt();\n  int K = nextInt();\n\n  ll ans = 0;\n  for (int a = 0; a <= K; a++) {\n    int b = K - a;\n    ans += solve(N, a) * solve(M, b) % MOD * choose(N+M+2*a+2*b, N+2*a) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  inv[1] = 1;\n  for (int i = 2; i < MAX_N; i++) inv[i] = inv[(int) (MOD % i)] * (MOD - MOD / i) % MOD;\n  fact[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact[i] = fact[i-1] * i % MOD;\n  fact_inv[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;\n\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = int64_t;\nusing namespace std;\nconst i64 MOD = 1000000007LL;\nvector<i64> fact(500000);\n\ninline i64 powermod(i64 a,i64 b){\n  i64 r = 1LL;\n  for(int i = 32 - __builtin_clz(b) - 1; i >= 0; i-- ){\n    if((1 << i) & b) r = r * r % MOD * a % MOD;\n    else r = r * r % MOD;\n  }\n  return r;\n}\n\ninline i64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\ni64 nCr(i64 n,i64 r){\n  if(r<0)return 0;\n  i64 ne = fact[n];\n  i64 di = fact[n-r] * fact[r] % MOD;\n  return divmod(ne,di);\n}\n\ninline i64 A(i64 a,i64 b){\n  return (nCr(a,b) + MOD - nCr(a,b-1)  ) % MOD;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  \n  fact[0] = fact[1] = 1LL;\n  for(int i = 2;i < 500000;i++){\n    fact[i] = fact[i-1] * (i64)i % MOD;\n  }\n  \n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    res += nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    res %= MOD;\n  }\n  \n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nll n, m, k;\nll kai[300000];\n\nll mod_pow(ll x, ll y){\n    ll ret = 1;\n    while(y){\n        if(y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb(ll x, ll y){\n    ll ret = kai[x+y];\n    ret = ret*mod_pow(kai[x],MOD-2)%MOD;\n    ret = ret*mod_pow(kai[y],MOD-2)%MOD;\n    return ret;\n}\n\nvoid init(){\n    kai[0] = 1;\n    for(ll i = 1; i < 300000; i++){\n        kai[i] = (kai[i-1]*i)%MOD;\n    }\n}\n\nll pre(ll x, ll y){\n    ll ret = 1;\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> k;\n    init();\n    ll ans = 0;\n    for(ll i = 0; i <= k; i++){\n        ll j = k-i;\n        ll add = conb(n+2*i,m+2*j);\n        ll add2 = conb(n+i,i);\n        if(i > 0) add2 = (add2-conb(n+i+1,i-1)+MOD)%MOD;\n        ll add3 = conb(m+j,j);\n        if(j > 0) add3 = (add3-conb(m+j+1,j-1)+MOD)%MOD;\n        add = add*add2%MOD;\n        add = add*add3%MOD;\n        ans = (ans+add)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\nconst ll mod = 1000000007;\n\nll fact[250010];\nll rfact[250010];\n\nll modpow(ll p, ll n, ll mod){\n  if(n == 0) return 1;\n  if(n == 1) return p;\n  if(n % 2) return p * modpow(p, n - 1, mod) % mod;\n  else return modpow(p * p % mod, n / 2, mod); \n}\n\n\nll comb(int n, int r){\n  if(r  >  n || n < 0 || r < 0) return 0;\n  else return (fact[n] * rfact[r] % mod) * rfact[n - r] % mod;\n}\n\nll calc(int n, int k){\n  // nツ嘉アツづ個つ、ツつソkツ嘉アツ甘アツづィツ督ケツつキツづゥツ嘉アツ青板、ツつスツつセツつオツ甘アツづィツ督ケツつオツつスツ嘉アツ青板つェツ甘アツづィツ督ケツつオツづづ按つ「ツ嘉アツ青板づーツ越ツつヲツづづ債つ「ツつッツづ按つ「\n  return (comb(n, k) - comb(n, k - 1) + mod) % mod;\n}\n\nint main(){\n  ll N, M, K;\n  fact[0] = 1;\n  rfact[0] = 1;\n  rep(i, 250000) {\n    fact[i+1] = (fact[i] * (i + 1)) % mod;\n    rfact[i+1] = modpow(fact[i+1], mod - 2, mod);\n  }\n  while(cin >> N >> M >> K){\n    ll res = 0;\n    rep(i, K + 1){\n      ll c = calc(N + 2 * i, i) * calc(M + 2 * (K - i), (K - i)) % mod;\n      res = (res + c * comb(N + M + K * 2, N + 2 * i)) % mod;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nvoid solve() {\n\tperm p(1 << 18);\n\tint n, m, k; cin >> n >> m >> k;\n\tll ans = 0;\n\tvector<ll> s({ 1 });\n\tvector<ll> t({ 1 });\n\trep1(i, k) {\n\t\tll sum1 = p.comb(n + 2 * i, i) - p.comb(n + 2 * i, i - 1);\n\t\tif (sum1 < 0)sum1 += mod;\n\t\tll sum2 = p.comb(m + 2 * i, i) - p.comb(m + 2 * i, i-1);\n\t\tif (sum2 < 0)sum2 += mod;\n\t\ts.push_back(sum1);\n\t\tt.push_back(sum2);\n\t}\n\trep(i, k + 1) {\n\t\tll csum = s[i] * t[k - i] % mod*p.comb(n + m + 2*k, n + 2*i) % mod;\n\t\tans = (ans + csum) % mod;\n\t}\n\tcout << ans << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\nll N,M,K;\nll F[300000];\n\nll extgcd(ll a, ll b, ll &x, ll &y){\n  ll g = a;\n  x = 1;\n  y = 0;\n  if(b != 0){\n    g = extgcd(b, a%b, y, x);\n    y -= (a / b) * x;\n  }\n  return g;\n}\n\nll modinv(ll a, ll m){\n  ll x,y;\n  if(extgcd(a,m,x,y) == 1) return (x + m) % m;\n  return -1; \n}\n\nll mult( ll a, ll b ){\n  return a*b % MOD;\n}\n\nvoid add( ll &a, ll b){\n  if( a < 0 ) a+=MOD;\n  if( b < 0 ) b+=MOD;\n  a += b;\n  a %= MOD;\n}\n\nll minu( ll a, ll b ){\n  b %= MOD;\n  a -= b;\n  if( a < 0 ) a += MOD;\n  return a;\n}\n\nll comb( ll a, ll b ){\n  return mult( mult( F[a] , modinv( F[a-b], MOD ) ), modinv( F[b], MOD ) );\n}\n\nvoid init(){\n  F[0] = 1;  \n  for(ll i=1;i<300000;i++)\n    F[i] = mult(F[i-1], i);\n}\n\nint main(){\n  init();\n  cin >> N >> M >> K;\n  ll res = 0;\n  for(ll L=0;L<=K;L++){\n    ll R = K-L;\n    ll mt = comb( N+M+2*K, N+2*L );\n    ll lk = 1;\n    if( L ) lk = minu( comb( N + 2*L , L ), comb( N + 2*L , L-1 ) );\n    ll rk = 1;\n    if( R ) rk = minu( comb( M + 2*R , R ), comb ( M + 2*R, R-1 ) );\n    add( res, mult( mt, mult( lk, rk ) ) );\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[100001], inv[100001], factiv[100001];\nint ncr(int n, int r) { return r < 0 ? 0 : 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod; }\nint main() {\n    scanf(\"%d%d%d\", &H, &W, &K);\n    fact[0] = 1;\n    for(int i = 1; i <= 100000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n    inv[1] = 1;\n    for(int i = 2; i <= 100000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n    factinv[0] = 1;\n    for(int i = 1; i <= 100000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n    int ret = 0;\n    for(int i = 0; i <= K; i++) {\n        int re1 = (ncr(W + i, i) - ncr(W + i, i - 1) + mod) % mod;\n        int re2 = (ncr(H + K - i, K - i) - ncr(H + K - i, K - i - 1) + mod) % mod;\n        ret += 1LL * ncr(H + W + K, W + i) * re1 % mod * re2 % mod;\n        ret %= mod;\n    }\n    printf(\"%d\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll rev(int a){\n\tll ans=1;\n\tll b=a;\n\tll n=MOD-2;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tans=(ans*b)%MOD;\n\t\tb=(b*b)%MOD;\n\t\tn >>=1;\n\t}\n\treturn (ans+MOD)%MOD;\n}\n\nll com(ll n,ll m){\n\tll ans=1;\n\twhile(m){\n\t\tans=((ans*n%MOD)*rev(m))%MOD;\n\t\tn--;\n\t\tm--;\n\t}\n\treturn (ans+MOD)%MOD;\n}\nint main(void){\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tll ans=0;\n\tfor(int p=0;p<=K;p++){\n\t\tint q=K-p;\n\t\tll a=((com(N+2*p,p)*(N+1))%MOD*rev(N+p+1))%MOD;\n\t\tll b=((com(M+2*q,q)*(M+1))%MOD*rev(M+q+1))%MOD;\n\t\tll c=(com(M+N+2*K,N+2*p))%MOD;\n\t\tans=(ans+((a*b)%MOD*c)%MOD)%MOD;\n\t\tif(a<0 || b <0 || c <0)\n\t\t\tcout << a << \" \" << b << \" \" << c << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007LL;\nconst ll S = 300000LL;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(ll i=1; i<=S; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(ll i=S; i>=0; i--) {\n        finv[i-1] = finv[i] * i % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = sum_ud - nCr(ud, u+1) + MOD % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = sum_lr - nCr(lr, r+1) + MOD % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = long long int;\nusing namespace std;\nconst i64 MOD = (i64)1e9+7;\n\n\ni64 nCr(i64 n,i64 r){\n  if(r < 0) return 0;\n  i64 res = 1LL;\n  r = min(n-r,r);\n  for(i64 i = 1LL; i <= r ; i++ ){\n    res *= (n-i+1);\n    res %= MOD;\n    res /= i;\n  }\n  // cerr << \"nCr: \" << n << \" \" << r << \" \" << res << endl;\n  return res;\n}\n\ni64 A(i64 a,i64 b){\n  i64 r = nCr(a,b) - nCr(a,b-1);\n  // cerr << \"A: \" << a << \" \" << b << \" \" << r << endl;\n  return r;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    i64 sub = nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    // cerr << sub << endl;\n    res += sub;\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\ntypedef long long lli;\n#define REP(i,x)for(int i=0;i<(int)x;i++)\nconst int MAX_N=911111;\nconst lli MOD=1000000007;\nlli fact[MAX_N],rfact[MAX_N];\nlli mod_pow(lli a,lli b,lli M){\n    if(b==0)return 1;\n    lli res=mod_pow((a*a)%M,b/2,M);\n    if(b&1)res=(res*a)%M;\n    return res;\n}\nvoid init(){\n    fact[0]=rfact[0]=1;\n    REP(i,MAX_N-1){\n        fact[i+1]=fact[i]*(i+1)%MOD;\n        rfact[i+1]=rfact[i]*mod_pow(i+1,MOD-2,MOD)%MOD;\n    }\n}\nlli comb(int n,int k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return (((fact[n]*rfact[k])%MOD)*rfact[n-k])%MOD;\n}\nlli N,M,K;\nlli solve(lli n,lli k){\n    return (comb(n,k)-comb(n,k-1 )+MOD*2)%MOD;\n}\nint main() {\n    init();\n    cin>>N>>M>>K;\n    lli ans=0;\n    REP(x,K+1){\n        lli y=K-x;\n        ans+=(solve(x*2+N,x)*solve(y*2+M,y)%MOD)*comb(N+M+x*2+y*2,x*2+N)%MOD;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\ntypedef long long i64;\n\nconst i64 MOD = 1e9 + 7;\ntemplate <i64 MOD> struct ModInt {\n  i64 value;\n\n  ModInt(i64 v = 0) { value = v % MOD; }\n\n  operator i64() { return value; }\n  ModInt<MOD> operator+(int v) { return (value + v) % MOD; }\n  ModInt<MOD> operator+(i64 v) { return (value + v) % MOD; }\n\n  ModInt<MOD> operator-(i64 v) {\n    v %= MOD;\n    return (MOD + value - v) % MOD;\n  }\n\n  ModInt<MOD> operator*(i64 v) { return (value * v) % MOD; }\n};\n\n// Eucli\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\n\ni64 fact[404040];\ni64 inv_fact[404040];\nusing mint = ModInt<MOD>;\n\nmint nCr(int n, int r) {\n  return (fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD) % MOD;\n}\n\n//重複組み合わせ\ni64 nHr(int n, int r) { return (nCr(n + r - 1, r)) % MOD; }\n\n\nint main(){\n\tfact[0] = 1;\n\tfor(int i = 1;i < 404040;i++){\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\tinv_fact[404040 - 1] = inv_mod(fact[404040 - 1]);\n\tfor(int i = 404040 - 2;i >= 0;i--){\n\t\tinv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n\t}\n\n\n\tmint result = 0;\n\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i <= k;i++){\n\t\tint j = k - i;\n\t\tmint l = 1,r = 1;\n\t\tif(i != 0)\n\t\t\tl = nCr(n + 2 * i , i) - nCr(n + 2 * i , i - 1);\n\t\tif(j != 0)\n\t\t\tr = nCr(m + 2 * j , j) - nCr(m + 2 * j,j - 1);\n\t\tresult = result + l * r * nCr(n + m + 2 * k,n + 2 * i);\n\t}\n\tcout << result << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long x[100][100][100];\nint a, b, c;\n\nint main() {\n\tcin >> b >> c >> a;\n\tx[0][0][0] = 1;\n\tfor (int k = 0; k < 90; k++) {\n\t\tfor (int i = 0; i < 90; i++) {\n\t\t\tfor (int j = 0; j < 90; j++) {\n\t\t\t\tx[k][i + 1][j] += x[k][i][j];\n\t\t\t\tx[k][i][j + 1] += x[k][i][j];\n\t\t\t\tif (i - 1 >= 0) { x[k + 1][i - 1][j] += x[k][i][j]; }\n\t\t\t\tif (j - 1 >= 0) { x[k + 1][i][j - 1] += x[k][i][j]; }\n\t\t\t}\n\t\t}\n\t}\n\tcout << x[a][b][c] % 1000000007 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nll N, M, K;\nll fact[123456];\n\ntemplate<typename T> T modInverse(T a, T m = MOD)\n{\n  T b = m, x = 1, u = 0;\n  T q, t;\n  while(b > 0){\n    q = a / b;\n    t = u; u = x - q * u; x = t;\n    t = b; b = a - q * b; a = t;\n  }\n\n  return (x + m) % m;\n}\n\ntemplate<typename T> T modComb(T n, T k, T p = MOD, T* fact = fact)\n{\n  if(n < 0 || k < 0 || n < k) return 0;\n  if(n - k > (T)0) minup(k, n-k);\n  return fact[n] * modInverse(fact[n - k] * fact[k] % MOD) % MOD;\n}\n\ninline ll solve(ll n, ll i)\n{\n  return (modComb(n + 2 * i, i) * (n + 1LL) % MOD) * modInverse(n + i + 1LL) % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n  cin >> N >> M >> K;\n\n  fact[0] = 1LL;\n  rep(i, 111111) fact[i + 1] = (fact[i] * (i + 1LL)) % MOD;\n\n  ll res = 0LL;\n  erep(i, 0, K){\n    res = (res + ((((modComb(N + M + 2 * K, N + 2 * i) % MOD) * solve(N, i) % MOD) * solve(M, K - i) % MOD))) % MOD;\n  }\n\n  cout << res << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long Int;\n\n#define MOD 1000000007\n\nInt fact[108000];\nInt n, m, k, res;\n\nvoid init(){\n\tfact[0] = 1;\n\tfor(Int i = 1;i < 108000;i++){\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t}\n}\n\nInt pow(Int n, Int p){\n\tif(p == 0)return 1;\n\tInt res = pow(n, p / 2);\n\tres = res * res % MOD;\n\tif(p % 2 == 1)res *= n;\n\treturn res % MOD;\n}\n\nInt inv(Int x){\n\treturn pow(x, MOD - 2);\n}\n\nInt C(Int n, Int k){\n\tif(n < k)return 0;\n\treturn fact[n] * inv(fact[k] * fact[n-k] % MOD) % MOD;\n}\n\nInt solve(Int n, Int m){\n\tInt res = (C(n + m + m, m) - C(n + m + m, m - 1)) % MOD;\n\tif(res < 0)res += MOD;\n\treturn res;\n}\n\nint main(){\n\tcin >> n >> m >> k;\n\tinit();\n\tfor(Int i = 0;i <= k;i++){\n\t\tInt tmp = C(n + m + 2 * k, n + 2 * i);\n\t\ttmp *= solve(n, i) * solve(m, k-i) % MOD;\n\t\tres += tmp;\n\t\tres %= MOD;\t\t\t\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<1000000007>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=5e5; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nint main(void) {\n    ll w, h, k;\n    cin >> w >> h >> k;\n\n    mint ret = 0;\n    REP(i, k+1) {\n        mint v1 = combi(w+2*i,i)-combi(w+2*i, i-1);\n        mint v2 = combi(h+2*(k-i),k-i)-combi(h+2*(k-i),k-i-1);\n        mint v3 = combi(h+w+2*k, w+2*i);\n        dump(i, v1, v2, v3);\n        ret += v1 * v2 * v3;\n    }\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\ntypedef long long lli;\n#define REP(i,x)for(int i=0;i<(int)x;i++)\nconst int MAX_N=911111;\nconst lli MOD=1000000007;\nlli fact[MAX_N],rfact[MAX_N];\nlli mod_pow(lli a,lli b,lli M){\n    if(b==0)return 1;\n    lli res=mod_pow((a*a)%M,b/2,M);\n    if(b&1)res=(res*a)%M;\n    return res;\n}\nvoid init(){\n    fact[0]=rfact[0]=1;\n    REP(i,MAX_N-1){\n        fact[i+1]=fact[i]*(i+1)%MOD;\n        rfact[i+1]=rfact[i]*mod_pow(i+1,MOD-2,MOD)%MOD;\n    }\n}\nlli comb(int n,int k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return (((fact[n]*rfact[k])%MOD)*rfact[n-k])%MOD;\n}\nlli N,M,K;\nlli solve(lli n,lli k){\n    return (comb(n,k)-comb(n,k-1 )+MOD*2)%MOD;\n}\nint main() {\n    init();\n    cin>>N>>M>>K;\n    lli ans=0;\n    REP(x,K+1){\n        lli y=K-x;\n        ans+=(solve(x*2+N,x)*solve(y*2+M,y)%MOD)*comb(N+M+x*2+y*2,x*2+N)%MOD;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n\ntypedef long long int int64;\nint mod = 1000000007;\n\n\npair<int, int> extgcd(int a, int b)\n{\n\tif(b == 0)\n\t\treturn {1, 0};\n\n\tconst auto res = extgcd(b, a % b);\n\tconst int xd = res.first;\n\tconst int yd = res.second;\n\tconst int x = yd;\n\tconst int y = xd - a / b * yd;\n\treturn {x, y};\n}\n\nint inv(int a)\n{\n\tconst auto res = extgcd(mod, a);\n\tconst int y = res.second;\n\treturn (mod + y % mod) % mod;\n}\n\nint fact(int a)\n{\n\tstatic vector<int> mem(1, 1);\n\tfor(int i = mem.size(); i <= a; ++i) {\n\t\tint v = ((int64)i * mem.back()) % mod;\n\t\tmem.push_back(v);\n\t}\n\treturn mem[a];\n}\n\nint invfact(int a)\n{\n\tstatic vector<int> mem(1, 1);\n\tfor(int i = mem.size(); i <= a; ++i) {\n\t\tint v = ((int64)inv(i) * mem.back()) % mod;\n\t\tmem.push_back(v);\n\t}\n\treturn mem[a];\n}\n\nint nck(int a, int b)\n{\n\tif(a < b)\n\t\treturn 0;\n\tint ans = 1;\n\tans = ((int64)ans * fact(a)) % mod;\n\tans = ((int64)ans * invfact(b)) % mod;\n\tans = ((int64)ans * invfact(a - b)) % mod;\n\n\treturn ans;\n}\n\n\npair<vector<int>, vector<int> > calculate_table(const int n, const int m, const int k)\n{\n\tvector<int> nt, mt;\n\tvector<int> cur, next;\n\n\tnt.resize(k + 1, -1);\n\tmt.resize(k + 1, -1);\n\tcur.resize(k + 1, 0);\n\tnext.resize(k + 1);\n\n\tcur[0] = 1;\n\n\tfor(int gen = 1; gen <= k * 2; ++gen) {\n\n\t\tfill(next.begin(), next.end(), 0);\n\t\tnext[0] = cur[0];\n\n\t\tfor(int i = 1; i <= k; ++i) {\n\t\t\tif(i * 2 > gen)\n\t\t\t\tcontinue;\n\t\t\tnext[i] = (cur[i] + cur[i - 1]) % mod;\n\t\t}\n\n\t\tswap(cur, next);\n\n\t\tif(gen - n >= 0 && gen - n <= 2 * k && (gen - n) % 2 == 0)\n\t\t\tnt[(gen - n) / 2] = cur[(gen - n) / 2];\n\t\tif(gen - m >= 0 && gen - m <= 2 * k && (gen - m) % 2 == 0)\n\t\t\tmt[(gen - m) / 2] = cur[(gen - m) / 2];\n\t}\n\n\tfor(int i = 0; i <= k; ++i) {\n\n\t\tif(nt[i] == -1) {\n\t\t\tnt[i] = 0;\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tconst int remain = n + i * 2 - k * 2;\n\t\t\t\tconst int diff = i - j;\n\t\t\t\tnt[i] += ((int64)cur[j] * nck(remain, diff)) % mod;\n\t\t\t\tnt[i] %= mod;\n\t\t\t}\n\t\t}\n\n\t\tif(mt[i] == -1) {\n\t\t\tmt[i] = 0;\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tconst int remain = m + i * 2 - k * 2;\n\t\t\t\tconst int diff = i - j;\n\t\t\t\tmt[i] += ((int64)cur[j] * nck(remain, diff)) % mod;\n\t\t\t\tmt[i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {nt, mt};\n}\n\n\nint main()\n{\n\tint n, m, k;\n\tint ans = 0;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tauto tables = calculate_table(n, m, k);\n\tconst auto &n_table = tables.first;\n\tconst auto &m_table = tables.second;\n\n\tfor(int nk = 0; nk <= k; ++nk) {\n\n\t\tconst int mk = k - nk;\n\n\t\tconst int64 x = n_table[nk];\n\t\tconst int64 y = m_table[mk];\n\t\tconst int64 xy = (x * y) % mod;\n\t\tconst int64 combi = nck(n + m + k * 2, n + nk * 2);\n\n\t\tans += (xy * combi) % mod;\n\t\tans %= mod;\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nll MOD=1000000007;\n\nclass Main{\npublic:\n    \n\tll pow(ll x, ll N){\n\t\tll res=1;\n\t\twhile(N!=0){\n\t\t\tif(N%2==1)res=pmod(res*x,MOD);\n\t\t\tx=pmod(x*x,MOD);\n\t\t\tN/=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\t// O(log M)\n\tll inv(const ll x){return pow(x,MOD-2);}\n\n\tll C(int n,int r){\n\t\treturn pmod(pmod(mfs[n]*inv(mfs[n-r]),MOD)*inv(mfs[r]),MOD);\n\t}\n\tll inv(int n){\n\t\treturn pow(n,MOD-2);\n\t}\n\tvector<ll> mfs;\n\t\t\n\tvoid run(){\n\t\tint W,H,K;cin >> W >> H >> K;\n\n\t\tmfs=vector<ll>(250000,1);\n\t\t\n\t\tfor(int v=1;v<250000;v++){\n\t\t\tmfs[v]=pmod(mfs[v-1]*v,MOD);\n\t\t}\n\n\t\tll res=0;\n\t\tfor(int xK=0;xK<=K;xK++){\n\t\t\tint yK=K-xK;\n\t\t\tll v=1;\n\t\t\t//→← or ↓↑ \n\t\t\tv=pmod(v*C(W+H+2*K,W+2*xK),MOD);\n\t\t\t//→ or　←\n\t\t\tif(xK>=1)v=pmod(v*pmod(C(W+2*xK,xK)-C(W+2*xK,xK-1),MOD),MOD);\n\t\t\t//↓ or ↑\n\t\t\tif(yK>=1)v=pmod(v*pmod(C(H+2*yK,yK)-C(H+2*yK,yK-1),MOD),MOD);\n\t\t\tres=pmod(v+res,MOD);\n\t\t}\n\n\t\tcout << res << endl;\n\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long fact[500000];\nlong long inv[500000];\nlong long factinv[500000];\nlong long ncr(int a,int b){\n\tif(b<0 || a<b)return 0;\n\treturn 1LL*fact[a]*factinv[b]%MOD*factinv[a-b]%MOD; \n}\nlong long ktrn(int a,int b){\n\treturn (ncr(a+b,b)-ncr(a+b,b-1)+MOD)%MOD;\n}\nint main(){\n\tfact[0]=1;inv[1]=1;factinv[0]=1;\n\tfor(long long i=1;i<500000;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t\tfact[i]%=MOD;\n\t}\n\tfor(long long i=2;i<500000;i++){\n\t\tinv[i]=1LL*inv[MOD%i]*(MOD-MOD/i)%MOD;\n\t}\n\tfor(long long i=1;i<500000;i++){\n\t\tfactinv[i]=1LL*factinv[i-1]*inv[i]%MOD;\n\t}\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=1500;i++){p[i][0]=1;p[i][i]=1;}\n\tfor(int i=1;i<=1500;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tdp[i][j]%=MOD;\n\t\t\tif(j>=1 && j<i){\n\t\t\t\tp[i][j]=p[i-1][j-1]+p[i-1][j];\n\t\t\t\tp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tlong long V=ncr(n+m+k*2,n+i*2)*ktrn(n+i,i);V%=MOD;\n\t\tV*=ktrn(m+k-i,k-i);sum+=V;sum%=MOD;\n\t\t//cout<<p[n+m+k*2][n+i*2]<<' '<<dp[n+i][i]<<' '<<dp[m+k-i][k-i]<<endl;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nint extgcd(int a, int b, int& x, int& y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n//euler_function phi(n)\n//O(sqrt(n))\nint euler_phi(int n) {\n\tint res = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tres = res / i *(i - 1);\n\t\t\tfor (; n%i == 0; n /= i);\n\t\t}\n\t}\n\tif (n != 1) res = res / n*(n - 1);\n\treturn res;\n}\n\n\n//Simultaneous linear congruences\n//solve a_i*x=b_i (mod m_i)\n//x=b (mod m)\n//return pair(b,m)\n//if no solution, return (0,-1)\npair<int, int> linear_congruence(const vector<int>& A, const vector<int>& B, const vector<int>& M) {\n\tint x = 0, m = 1; //At first, all real number is OK.\n\n\tfor (int i = 0; i<A.size(); i++) {\n\t\tint x = 0, y = 0;//for extgcd\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = extgcd(M[i], a, x, y);\n\t\tif (b%d != 0) return make_pair(0, -1); // no solution\n\t\tint t = b / d*mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m*t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\n\nconst int MAX_P=3; //prime number\nint fact[MAX_P]; //table of n! mod p O(p)\n\t\t\t\t //return a mod p (n!=ap^e)\n\t\t\t\t //O(log_p n)\nint mod_fact(int n, int p, int& e) {\n\te = 0;\n\tif (n == 0) return 1;\n\n\t//caluculate parts of multiples of p\n\tint res = mod_fact(n / p, p, e);\n\te += n / p;\n\n\t//(p-1)!=-1 (mod p), so if(n/p%2==0), (p-1)!^(n/p)=1 (mod p)\n\t//                      if(n/p%2==1), (p-1)!^(n/p)=-1 (mod p)\n\tif (n / p % 2 != 0) return res*(p - fact[n%p]) % p;\n\treturn res*fact[n%p] % p;\n}\n\nint mod_comb(int n, int k, int p) {\n\tif (n<0 || k<0 || n<k) return 0;\n\tint e1, e2, e3;\n\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n\tif (e1>e2 + e3) return 0;\n\treturn a1*mod_inverse(a2*a3%p, p) % p;\n}\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn (fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod)) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong int u = n + i;\n\t\tlong int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + (com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1)))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res +( com(n + m +2* k, u + d)*(com(u + d, d) - com(u + d, d - 1))) % mod) % mod;\n\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    int n[K + 1], m[K + 1];\n    int DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(N <= i && i <= N + 2 * K && (i - N) % 2 == 0 &&\n               (i - N) / 2 == j) {\n                n[(i - N) / 2] = DP2[j];\n            }\n            if(M <= i && i <= M + 2 * K && (i - M) % 2 == 0 &&\n               (i - M) / 2 == j) {\n                m[(i - M) / 2] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (ll)(nckmodp(N + M + 2 * K, N + 2 * i, INF) * n[i]) % INF *\n               m[K - i];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\nll inv(ll x){\n  ll t = MOD - 2;\n  ll ans = 1;\n  while(t){\n    if(t&1)ans=(ans*x)%MOD;\n    x=(x*x)%MOD;\n    t>>=1;\n  }\n  return ans;\n}\n\n#define N_MAX 210010\nll fact[N_MAX];\n\nll comb(ll a,ll b){\n  if(a<b)return 0;\n  return fact[a]*inv(fact[b])%MOD*inv(fact[a-b])%MOD;\n}\n\nint main(){\n  fact[0]=1;\n  REPR(i,N_MAX)fact[i]=fact[i-1]*i%MOD;\n  ll n,m,k;\n  cin>>n>>m>>k;\n  ll result = 0;\n  REP(i,k+1){\n    ll l = i;\n    ll r = n+i;\n    ll d = k-i;\n    ll u = m+(k-i);\n    // http://kakuritsu.com/catalan.html\n    ll hor = FIX(comb(r+l,r) - comb(r+l,r+1));\n    ll ver = FIX(comb(u+d,u) - comb(u+d,u+1));\n    ll v = hor*ver%MOD *comb(r+l+u+d,r+l)%MOD;\n    result += v;\n    result %= MOD;\n  }\n  cout<<result<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long power[500000];\nlong long dp[1600][1600];\nlong long p[1600][1600];\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=1500;i++){p[i][0]=1;p[i][i]=1;}\n\tfor(int i=1;i<=1500;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tdp[i][j]%=MOD;\n\t\t\tif(j>=1 && j<i){\n\t\t\t\tp[i][j]=p[i-1][j-1]+p[i-1][j];\n\t\t\t\tp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tlong long V=p[n+m+k*2][n+i*2]*dp[n+i][i];V%=MOD;\n\t\tV*=dp[m+k-i][k-i];sum+=V;sum%=MOD;\n\t\t//cout<<p[n+m+k*2][n+i*2]<<' '<<dp[n+i][i]<<' '<<dp[m+k-i][k-i]<<endl;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[300005], fact_inv[300005];\n\nllint pow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (pow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn pow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 300005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 300005; i++){\n\t\tfact_inv[i] = pow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint N, M, K;\n\nint main(void)\n{\n\tmake_fact();\n\tcin >> N >> M >> K;\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= K; i++){\n\t\tllint tmp = comb(N+M+2*K, N+2*i);\n\t\ttmp *= (comb(N+2*i, i) - comb(N+2*i, i-1) + mod) % mod;\n\t\ttmp %= mod;\n\t\ttmp *= (comb(M+2*(K-i), K-i) - comb(M+2*(K-i), (K-i)-1) + mod) % mod;\n\t\ttmp %= mod;\n\t\tans += tmp;\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nll n, m, k;\nll kai[300000];\n\nll mod_pow(ll x, ll y){\n    ll ret = 1;\n    while(y){\n        if(y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nll conb(ll x, ll y){\n    ll ret = kai[x+y];\n    ret = ret*mod_pow(kai[x],MOD-2)%MOD;\n    ret = ret*mod_pow(kai[y],MOD-2)%MOD;\n    return ret;\n}\n\nvoid init(){\n    kai[0] = 1;\n    for(ll i = 1; i <= 300000; i++){\n        kai[i] = (kai[i-1]*i)%MOD;\n    }\n}\n\nll pre(ll x, ll y){\n    ll ret = 1;\n    return ret;\n}\n\nint main(){\n    cin >> n >> m >> k;\n    init();\n    ll ans = 0;\n    for(ll i = 0; i <= k; i++){\n        ll j = k-i;\n        ll add = conb(n+2*i,m+2*j);\n        ll add2 = conb(n+i,i);\n        if(i > 0) add2 = (add2-conb(n+i+1,i-1)+MOD)%MOD;\n        ll add3 = conb(m+j,j);\n        if(j > 0) add3 = (add3-conb(m+j+1,j-1)+MOD)%MOD;\n        add = add*add2%MOD;\n        add = add*add3%MOD;\n        ans = (ans+add)%MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define rep(i,a) for(int i = 0;i < (a); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\n\nll fact[300000];\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll g = a; x = 1; y = 0;\n    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\nll mod_inverse(ll a, ll m){\n    ll x, y;\n    if(extgcd(a, m, x, y) == 1) return (x + m) % m;\n    return 0;  // unsolvable\n}\n\nll mod_comb(ll n, ll k, ll m){\n    if(n < 0 || k < 0 || n < k) return 0;\n    return fact[n] * mod_inverse(fact[k] * fact[n - k] % m, m) % m;\n}\n\nint main(){\n    ll n, m, k;\n    cin >> n >> m >> k;\n    fact[0] = 1;\n    rep(i,300000-1) fact[i+1] = (i+1)*fact[i] % MOD;\n    ll ans = 0;\n    rep(i,k+1){\n        ll j = k-i;\n        ll r = (mod_comb(n+2*i, i, MOD) - mod_comb(n+2*i, i-1 ,MOD) + MOD) % MOD;\n        ll d = (mod_comb(m+2*j, j, MOD) - mod_comb(m+2*j, j-1, MOD) + MOD) % MOD;\n        ans = (ans+r*d % MOD * mod_comb(n+m+2*k, n+2*i, MOD)) % MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007LL;\nconst ll S = 500000LL;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(ll i=1; i<=S; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(ll i=S; i>=1; i--) {\n        finv[i-1] = finv[i] * i % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = sum_ud - nCr(ud, u+1) + MOD % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = sum_lr - nCr(lr, r+1) + MOD % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_FACT=1000001;\ntypedef long long ll;\nconst ll mod=1000000007;\nll fact[MAX_FACT];\n\nll pow_mod(ll a,ll n){\n  ll cur=1;\n  ll mul=a;\n  while(n){\n    if(n%2)cur=(cur*mul)%mod;\n    mul=(mul*mul)%mod;\n    n/=2;\n  }\n  return cur;\n}\n\nll div_mod(int a){\n  return pow_mod(a,mod-2);\n}\n// factを前計算\nvoid calcFact(){\n  fact[0]=1;\n  for(int i=1;i<MAX_FACT;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n}\n// aCbのmodを計算\n// 計算量はO(log(fact[a])+log(fact[a-b]))程度\nll comb(ll a,ll b){\n  if(a<0||b<0)return 0;\n  else if(b==0)return 1;\n  ll res=fact[a];\n  res=(res*div_mod(fact[b]))%mod;\n  res=(res*div_mod(fact[a-b]))%mod;\n  return res;\n}\n\nint main(){\n  calcFact();\n  int N,M,K;\n  cin>>N>>M>>K;\n  ll res=0;\n  for(int p=0;p<=K;p++){\n    ll a=1;\n    a=(a*comb(N+2*p,p))%mod;\n    a=(a*(N+1))%mod;\n    a=(a*div_mod(N+p+1))%mod;\n    a=(a*comb(M+2*(K-p),K-p))%mod;\n    a=(a*(M+1))%mod;\n    a=(a*div_mod(M-p+1+K))%mod;\n    a=(a*comb(N+M+2*K,N+2*p))%mod;\n    res=(res+a)%mod;\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nvector<int> fact(1, 1), fact_inv(2, 1);\n\nint comb(int N, int k){\n//\tprintf(\"comb(%lld, %lld)\\n\", N, k);\n\tif(k < 0 || N < k || N < 0){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn MOD(fact[N] * MOD(fact_inv[k] * fact_inv[N - k]));\n\t}\n}\n\nint calc(int N, int K){\n//\tprintf(\"calc(%lld, %lld)\\n\", N, K);\n\treturn MOD(comb(N + K, N) - comb(N + K, K - 1));\n}\n\nsigned main(){\n\tint N, M, K, i;\n\tscanf(\"%lld%lld%lld\", &N, &M, &K);\n\tint u = N + M + 2 * K;\n\tfor(i = 1; i <= u; i++){\n\t\tfact.push_back(MOD(i * fact[i - 1]));\n\t}\n\tfor(i = 2; i <= u; i++){\n\t\tfact_inv.push_back(MOD(-(p / i) * fact_inv[p % i]));\n\t}\n\tfor(i = 1; i <= u; i++){\n\t\tfact_inv[i] = MOD(fact_inv[i] * fact_inv[i - 1]);\n\t}\n\tint ans = 0;\n\tfor(i = 0; i <= K; i++){\n//\t\tprintf(\"i = %lld\\n\", i);\n\t\tans = MOD(ans + comb(N + M + 2 * K, N + 2 * i) * MOD(calc(N + i, i) * calc(M + K - i, K - i)));\n//\t\tprintf(\"ans = %lld\\n\", ans);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000007;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\n//return gcd(a,b), ax+by=1\n//O(log max(a,b))\nint extgcd(int a, int b, int& x, int& y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n//return a^(-1) (mod m) if gcd(a,m)==1\n//O(log m)\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);    //ax+my=1\n\treturn (m + x%m) % m;   //return positive integer\n}\n\n//euler_function phi(n)\n//O(sqrt(n))\nint euler_phi(int n) {\n\tint res = n;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (n%i == 0) {\n\t\t\tres = res / i *(i - 1);\n\t\t\tfor (; n%i == 0; n /= i);\n\t\t}\n\t}\n\tif (n != 1) res = res / n*(n - 1);\n\treturn res;\n}\n\n\n//Simultaneous linear congruences\n//solve a_i*x=b_i (mod m_i)\n//x=b (mod m)\n//return pair(b,m)\n//if no solution, return (0,-1)\npair<int, int> linear_congruence(const vector<int>& A, const vector<int>& B, const vector<int>& M) {\n\tint x = 0, m = 1; //At first, all real number is OK.\n\n\tfor (int i = 0; i<A.size(); i++) {\n\t\tint x = 0, y = 0;//for extgcd\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = extgcd(M[i], a, x, y);\n\t\tif (b%d != 0) return make_pair(0, -1); // no solution\n\t\tint t = b / d*mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m*t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\n\nconst int MAX_P=3; //prime number\nint fact[MAX_P]; //table of n! mod p O(p)\n\t\t\t\t //return a mod p (n!=ap^e)\n\t\t\t\t //O(log_p n)\nint mod_fact(int n, int p, int& e) {\n\te = 0;\n\tif (n == 0) return 1;\n\n\t//caluculate parts of multiples of p\n\tint res = mod_fact(n / p, p, e);\n\te += n / p;\n\n\t//(p-1)!=-1 (mod p), so if(n/p%2==0), (p-1)!^(n/p)=1 (mod p)\n\t//                      if(n/p%2==1), (p-1)!^(n/p)=-1 (mod p)\n\tif (n / p % 2 != 0) return res*(p - fact[n%p]) % p;\n\treturn res*fact[n%p] % p;\n}\n\nint mod_comb(int n, int k, int p) {\n\tif (n<0 || k<0 || n<k) return 0;\n\tint e1, e2, e3;\n\tint a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n\tif (e1>e2 + e3) return 0;\n\treturn a1*mod_inverse(a2*a3%p, p) % p;\n}\n\nconst long long int mod = 1e9 + 7;\n\nlong long int fac[1000000];\nlong long int com(long long int n, long long int k) {\n\treturn fac[n]*mod_inverse((fac[n-k]*fac[k])%mod,mod) % mod;\n}\n\nint main() \n{\n\tfac[0] = 1;\n\tfor (int i = 0; i < 1000000-1; i++) {\n\t\tfac[i + 1] =( fac[i] * (i + 1)) % mod;\n\t}\n\tlong long int n, m, k;\n\tcin >> n >> m >> k;\n\tlong long int res = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tlong long int d = i;\n\t\tlong long int l = k - i;\n\t\tlong int u = n + i;\n\t\tlong int r = m + k-i;\n\n\t\tif(d>0&&l>0)\n\t\t\tres = (res + (((com(n + m + 2*k, u + d)*((com(u + d, d) - com(u + d, d- 1)) )% mod)*(com(r + l, l) - com(r + l, l - 1)) % mod)%mod)%mod )% mod;\n\t\tif (d == 0 && l == 0)\n\t\t\tres = (res + com(n + m +2*k, u + d)) % mod;\n\t\tif (d == 0 && l > 0)\n\t\t\tres = (res + com(n + m + 2*k, u + d)*(com(l + r, l) - com(l + r, l - 1))%mod)%mod;\n\t\tif (d > 0 && l == 0)\n\t\t\tres = (res + com(n + m +2* k, u + d)*(com(u + d, d) - com(u + d, d - 1)) % mod) % mod;\n\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nll MOD = 1000000007LL;\nll mod_pow(ll a, ll b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tll x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (a*mod_pow(a, b - 1)) % MOD;\n}\nll fact[200001];\nll inv_fact[200001];\nll comb(ll n, ll k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= 200000; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tll ans = 0;\n\tfor (int i = 0; i <= K; i++) {\n\t\tll sum = comb(N + M + 2 * K, N + 2 * i);\n\t\tll X = comb(N + 2 * i, N + i);\n\t\tif (i > 0) (X += MOD - comb(N + 2 * i, i - 1)) %= MOD;\n\t\tll Y = comb(M + 2 * (K - i), M + (K - i));\n\t\tif (K - i > 0) (Y += MOD - comb(M + 2 * (K - i), K - i - 1)) %= MOD;\n\t\t(sum *= X) %= MOD;\n\t\t(sum *= Y) %= MOD;\n\t\t(ans += sum) %= MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Mod\n{\n    static const int MOD = 1000000007;\n    static vector<int> memo;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = (x % MOD + MOD) % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    Mod operator+=(const Mod& x){\n        *this = Mod(a + x.a);\n        return *this;\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    Mod operator*=(const Mod& x){\n        *this = Mod(a * x.a);\n        return *this;\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、x.aがMODと互いに素な場合のみ有効\n        if(memo[x.a] != -1)\n            return memo[x.a];\n\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n\n        memo[x.a] = ret;\n        return Mod(a * ret);\n    }\n    Mod operator/=(const Mod& x){\n        *this = *this / x;\n        return *this;\n    }\n    long long getValue(){\n        return a;\n    }\n};\nvector<int> Mod::memo(30000, -1);\n\nvector<Mod> solve(int len, int n)\n{\n    if(len < n){\n        vector<Mod> ret;\n        vector<Mod> curr(3*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<Mod> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                curr[j+1] += curr[j];\n                if(j - 1 >= 0)\n                    next[j-1] += curr[j];\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<Mod> dp;\n    vector<Mod> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<Mod> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            curr[j+1] += curr[j];\n            if(j-1 >= 0)\n                next[j-1] += curr[j];\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<Mod> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        long long tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp /= j + 1;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<Mod> s = solve(w, n);\n    vector<Mod> t = solve(h, n);\n\n    Mod tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp /= i + 1;\n    }\n\n    Mod ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += s[n-i] * t[i] * tmp;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp /= h+1+2*i+j;\n        }\n    }\n    cout << ret.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nLL N,M,K;\nLL kai[300011];\nLL rkai[300011];\nint MOD=1e9+7;\n\nLL inverse();\n\ninline LL inverse(LL a, LL m){\n  LL b = m, u = 1, v = 0;\n  while (b) {\n    LL t = a / b;\n    swap(a -= t * b, b);\n    swap(u -= t * v, v);\n  }\n  return (u % m + m) % m;\n}\n\n\nvoid init(){\n   LL now=1;\n   kai[0]=1;\n   REP(i,300001){\n       kai[i+1]=kai[i]*(i+1);\n       kai[i+1]%=MOD;\n   }\n   REP(i,300001){\n       rkai[i]=inverse(kai[i],MOD);\n   }\n}\n\nLL kata(LL n,LL k){\n   LL ans=kai[n+k]*(n-k+1);\n   ans%=MOD;\n   ans*=rkai[k];\n   ans%=MOD;\n   ans*=rkai[n+1];\n   ans%=MOD;\n   return ans;\n}\n\nLL sol(LL x,LL y,LL a,LL b){\n   LL ans=1;\n   ans*=kai[x+y];\n   ans*=rkai[x];\n   ans%=MOD;\n   ans*=rkai[y];\n   ans%=MOD;\n   ans*=kata(x-a,a);\n   ans%=MOD;\n   ans*=kata(y-b,b);\n   ans%=MOD;\n   return ans;\n}\n//8c3=56,2=112,\n\nint main(){\n    cin>>N>>M>>K;\n    init();\n    LL ans=0;\n    REP(i,K+1){\n        LL NN=N+2*i;\n        LL MM=M+2*(K-i);\n        ans+=sol(NN,MM,i,K-i);\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll mod = 1e9+7;\nvector<ll> fact;\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll comb(ll n, ll r) {\n    if (r < 0 || n < 0 || r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\nll solve(ll n, ll m) {\n    // cout << n+m << \" \" << m << endl;\n    // cout << comb(n+m, m) << \" \" << comb(n+m, m-1) << \" \" << comb(n+m, m) - comb(n+m, m-1)<< endl;\n    return (comb(n+m, m) - comb(n+m, m-1))%mod;\n}\nvoid init_fact() {\n    fact.assign(1e6+10, 1);\n    FOR(i, 1, fact.size()) fact[i] = mul(i, fact[i-1]);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int W, H, K; cin >> W >> H >> K;\n    init_fact();\n    ll ans = 0;\n    REP(left, K+1) {\n        ll down = K - left;\n        ll right = W + left;\n        ll up = H + down;\n        ans = add(ans, mul(comb(up+down+left+right, up+down), mul(solve(up, down), solve(right, left))));\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <long long mod>\nclass Combination\n{\n    std::vector<long long> fact, finv, inv;\npublic:\n    Combination() {}\n    Combination(int sz)\n    {\n        fact.resize(sz);\n        finv.resize(sz);\n        inv.resize(sz);\n        fact[0] = 1;\n        for (int i = 1; i < sz; ++i)\n        {\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        inv[0] = 0;\n        inv[1] = 1;\n        for (int i = 2; i < sz; ++i)\n        {\n            inv[i] = mod - inv[mod % i] * (mod / i) % mod;\n        }\n        finv[0] = 1;\n        for (int i = 1; i < sz; ++i)\n        {\n            finv[i] = finv[i - 1] * inv[i] % mod;\n        }\n    }\n    long long C(long long n, long long k)\n    {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return (fact[n] * finv[k] % mod) * finv[n - k] % mod;\n    }\n    long long P(long long n, long long k)\n    {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fact[n] * finv[n - k] % mod;\n    }\n    long long H(long long n, long long k)\n    {\n        return this->C(n + k - 1, k);\n    }\n    long long getfact(int i)\n    {\n        return fact[i];\n    }\n    long long getinv(int i)\n    {\n        return inv[i];\n    }\n    long long getfinv(int i)\n    {\n        return finv[i];\n    }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  Combination<MOD> comb(3000000);\n  ll n, m, k; cin >> n >> m >> k;\n  ll ans = 0;\n  for(int i=0;i<=k;++i) {\n    ll yoko = n + 2*i;\n    ll tate = m + 2*(k - i);\n    ll tmp = comb.C(yoko + tate, yoko);\n    tmp *= comb.C(yoko, i) + MOD - comb.C(yoko, n + i + 1);\n    tmp %= MOD;\n    tmp *= comb.C(tate, k-i) + MOD - comb.C(tate, m + k - i + 1);\n    tmp %= MOD;\n    ans += tmp;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 220005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\n\nint main()\n{\n    ll n,m,K;\n    cin >> n >> m >> K;\n    make();\n    ll ans = 0;\n    for(int i=0;i<=K;i++){\n        ll val1 = ((n+1)*comb(n+2*i,i)%MOD)*inv[n+i+1]%MOD;\n        ll val2 = ((m+1)*comb(m+2*(K-i),(K-i))%MOD)*inv[m+(K-i)+1]%MOD;\n        ll val3 = comb(n+m+2*K,n+2*i);\n        ans = (ans + (val1*val2%MOD)*val3%MOD) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll fact[22010];\n\n\nll rev(int a){\n\tll ans=1;\n\tll b=a;\n\tll n=MOD-2;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tans=(ans*b)%MOD;\n\t\tb=(b*b)%MOD;\n\t\tn >>=1;\n\t}\n\treturn (ans+MOD)%MOD;\n}\n\nll com(ll n,ll m){\n\tll ans=1;\n\t//while(m){\n\t//\tans=((ans*n%MOD)*rev(m))%MOD;\n\t//\tn--;\n\t//\tm--;\n\t//}\n\tans=(fact[n]*rev(fact[m]))%MOD*rev(fact[n-m])%MOD;\n\treturn (ans+MOD)%MOD;\n}\nint main(void){\n\tfact[0]=1;\n\tfor(int i=1;i<=22000;i++)\n\t\tfact[i]=(fact[i-1]*i)%MOD;\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tll ans=0;\n\tfor(int p=0;p<=K;p++){\n\t\tint q=K-p;\n\t\tll a=((com(N+2*p,p)*(N+1))%MOD*rev(N+p+1))%MOD;\n\t\tll b=((com(M+2*q,q)*(M+1))%MOD*rev(M+q+1))%MOD;\n\t\tll c=(com(M+N+2*K,N+2*p))%MOD;\n\t\tans=(ans+((a*b)%MOD*c)%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define MAX 300000\nusing ll = long long;\nusing namespace std;\n\nll kaijo[MAX + 1];\nll gyaku[MAX + 1];\n\nll myPow(ll a, ll b) {\n\tll res = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = (res * a) % MOD;\n\t\t}\n\t\ta = (a * a) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll C(ll n, ll k) {\n\treturn min(k, n - k) >= 0 ? kaijo[n] * gyaku[k] % MOD * gyaku[n - k] % MOD : 0;\n}\n\nint main()\n{\n\tkaijo[0] = gyaku[0] = 1;\n\tfor (int i = 1; i <= MAX;i++) {\n\t\tkaijo[i] = (kaijo[i - 1] * i) % MOD;\n\t\tgyaku[i] = myPow(kaijo[i], MOD - 2);\n\t}\n\tll N, M, K, res = 0;\n\tcin >> N >> M >> K;\n\tfor (ll i = 0; i <= K; i++) {\n\t\tres = (res + (C(N + M + K * 2, M + i * 2) * ((C(M + i * 2, i) + MOD - C(M + i * 2, i - 1)) % MOD) % MOD * ((C(N + (K - i) * 2, K - i) + MOD - C(N + (K - i) * 2, K - i - 1)) % MOD) % MOD)) % MOD;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  vector< int > dp1(N + K + 1);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(N + K + 1);\n    for(int j = 1; j <= N + K; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    latte[i] = dp1[N];\n    for(int j = 0; j + 1 <= N + K; j++) {\n      dp2[j] += dp1[j + 1];\n    }\n    dp1.swap(dp2);\n  }\n\n\n  dp1.assign(M + K + 1, 0);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(M + K + 1);\n    for(int j = 1; j <= M + K; j++) {\n      (dp1[j] += dp1[j - 1]) %= mod;\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    malta[i] = dp1[M];\n    for(int j = 0; j + 1 <= M + K; j++) {\n      dp2[j] += dp1[j + 1];\n    }\n    dp1.swap(dp2);\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = int64_t;\nusing namespace std;\nconst i64 MOD = 1000000007LL;\nvector<i64> fact(500000);\n\ninline i64 powermod(i64 a,i64 b){\n  i64 r = 1LL;\n  for(int i = 32 - __builtin_clz(b) - 1; i >= 0; i-- ){\n    if((1 << i) & b) r = r * r % MOD * a % MOD;\n    else r = r * r % MOD;\n  }\n  return r;\n}\n\ninline i64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\ni64 nCr(i64 n,i64 r){\n  if(r<0)return 0;\n  i64 ne = fact[n];\n  i64 di = fact[n-r] * fact[r] % MOD;\n  return divmod(ne,di);\n}\n\ninline i64 A(i64 a,i64 b){\n  // cerr << nCr(a,b) << \" \" << nCr(a,b-1) << endl;\n  return (nCr(a,b) + MOD - nCr(a,b-1)  ) % MOD;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  \n  fact[0] = fact[1] = 1LL;\n  for(int i = 2;i < 500000;i++){\n    fact[i] = fact[i-1] * (i64)i % MOD;\n  }\n  \n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    res += nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    // cerr << nCr(N+M+K+K,N+i*2) << \" \" << A(N+i*2,i) << \" \" << A(M+(K-i)*2,K-i) << endl;\n    res %= MOD;\n  }\n  \n  cout << res << endl;\n  // cerr << nCr(138,7) << endl;\n  // cerr << nCr(3,1) << endl;\n  // cerr << powermod(2,10) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n//#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\n//using namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nvector<llint>kai;\nvector<llint>gya;\nllint niko(int x,int y){\n\tif(y<0){return 0;}\n\treturn kai[x+y]*gya[x]%mod*gya[y]%mod;\n}\nint main(void){\n\tllint n,m,k,i,j,z,ans=0;cin>>n>>m>>k;\n\tz=n+m+k+k+10;\n\tkai.res(z+1);\n\tkai[0]=1;\n\tfor(i=1;i<=z;i++){kai[i]=kai[i-1]*i%mod;}\n\tgya.res(z+1);\n\tgya[z]=1;llint bgen=kai[z];\n\tfor(int h=0;h<30;h++){\n\t\tif((mod-2)&(1<<h)){gya[z]*=bgen;gya[z]%=mod;}\n\t\tbgen*=bgen;bgen%=mod;\n\t}\n\tfor(i=z;i>0;i--){gya[i-1]=gya[i]*i%mod;}\n\tfor(i=0;i<=k;i++){\n\t\tint j=k-i;\n\t\t\n\t\tans+=niko(n+i+i,m+j+j)*(niko(n+i,i)-niko(n+i+1,i-1))%mod*(niko(m+j,j)-niko(m+j+1,j-1));\n\t\tans%=mod;\n\t}\n\tans%=mod;ans+=mod;ans%=mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\ntypedef long long ll;\nll f[220001],mod=1e9+7;\nll extgcd(ll a,ll b,ll &x,ll &y){\n\tif(b==0){\n\t\tx=a,y=0;\n\t\treturn a;\n\t}\n\tll d=extgcd(b,a%b,x,y),xx=y,yy=((x-a/b*y)%mod+mod)%mod;\n\tx=xx,y=yy;\n\treturn d;\n}\nll inv(ll a){\n\tll x,y;\n\textgcd(a,mod,x,y);\n\treturn x;\n}\nll comb(int a,int b){\n\tif(b==-1) return 0;\n\treturn f[a]*inv(f[a-b])%mod*inv(f[b])%mod;\n}\nint main(){\n\tf[0]=1;\n\trep1(i,220000) f[i]=f[i-1]*i%mod;\n\tint n,m,k;\n\tll ans=0;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(kx,k+1){\n\t\tint ky=k-kx;\n\t\tans+=(comb(n+2*kx,kx)-comb(n+2*kx,kx-1)+mod)*(comb(m+2*ky,ky)-comb(m+2*ky,ky-1)+mod)%mod*comb(n+m+2*k,n+kx*2)%mod;\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n#define MOD ((lli)(1000000007))\nlli mop(lli p,lli q){\n\tlli res=1,bp=p,b=1;\n\twhile(q){\n\t\tif(q&b){\n\t\t\tres=(res*bp)%MOD;\n\t\t\tq-=b;\n\t\t}\n\t\tbp=(bp*bp)%MOD;\n\t\tb*=2;\n\t}\n\treturn res;\n}\n\nlli inv(lli p){\n\treturn mop(p,MOD-2);\n}\n\nlli fact(int p){\n\tlli res=1;\n\treg(i,1,p)res=(res*i)%MOD;\n\treturn res;\n}\n\nlli comb(lli p,lli q){\n\tlli res=(((fact(p)*inv(fact(q)))%MOD)*inv(fact(p-q)))%MOD;\n\treturn res;\n}\n\n\nlli nk(int p,int q){ //p+q susumi q modoru\n\tif(q<=0)return 1;\n\treturn (MOD + comb(p+2*q,q) - comb(p+q*2,q-1))%MOD;\n\t//\n}\n\nint n,m,k;\nint main(void){\n\t\n\t//printf(\"%lld\\n\",nk(2,1));\n\t//printf(\"%lld\\n\",nk(3,2));\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tlli ans = 0;\n\treg(i,0,k){\n\t\tlli na = comb(n+m+k*2,n+i*2);\n\t\t//printf(\"%lld\\n\",na);\n\t\tna = (na * nk(n,i))%MOD;\n\t\tna = (na * nk(m,k-i))%MOD;\n\t\tans = (ans+na)%MOD;\n\t}\n\t\t\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\ntypedef long long lli;\n#define REP(i,x)for(int i=0;i<(int)x;i++)\nconst int MAX_N=911111;\nconst lli MOD=1000000007;\nlli fact[MAX_N],rfact[MAX_N];\nlli mod_pow(lli a,lli b,lli M){\n    if(b==0)return 1;\n    lli res=mod_pow((a*a)%M,b/2,M);\n    if(b&1)res=(res*a)%M;\n    return res;\n}\nvoid init(){\n    fact[0]=rfact[0]=1;\n    REP(i,MAX_N-1){\n        fact[i+1]=fact[i]*(i+1)%MOD;\n        rfact[i+1]=rfact[i]*mod_pow(i+1,MOD-2,MOD)%MOD;\n    }\n}\nlli comb(int n,int k){\n    if(n<k)return 0;\n    if(k<0)return 0;\n    return (((fact[n]*rfact[k])%MOD)*rfact[n-k])%MOD;\n}\nlli N,M,K;\nlli solve(lli n,lli k){\n    return (comb(n,k)-comb(n,k-1 )+MOD*2)%MOD;\n}\nint main() {\n    init();\n    cin>>N>>M>>K;\n    lli ans=0;\n    REP(x,K+1){\n        lli y=K-x;\n        ans+=(solve(x*2+N,x)*solve(y*2+M,y)%MOD)*comb(N+M+x*2+y*2,x*2+N)%MOD;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = 1000000007;\nconst int MAX_N = 312345;\nll inv[MAX_N];\nll fact[MAX_N];\nll fact_inv[MAX_N];\n\nll choose(int n, int r) {\n  if (n < r) return 0;\n  ll res = fact[n] * fact_inv[r] % MOD * fact_inv[n-r] % MOD;\n  return res;\n}\n\nll solve(int N, int a) {\n  if (a == 0) return 1;\n  ll res = choose(N+2*a, a) - choose(N+2*a, a-1);\n  res = (res % MOD + MOD) % MOD;\n  return res;\n}\n\nint main2() {\n  int N = nextInt();\n  int M = nextInt();\n  int K = nextInt();\n\n  ll ans = 0;\n  for (int a = 0; a <= K; a++) {\n    int b = K - a;\n    ans += solve(N, a) * solve(M, b) % MOD * choose(N+M+2*a+2*b, N+2*a) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  inv[1] = 1;\n  for (int i = 2; i < MAX_N; i++) inv[i] = inv[(int) (MOD % i)] * (MOD - MOD / i) % MOD;\n  fact[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact[i] = fact[i-1] * i % MOD;\n  fact_inv[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;\n\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[100001], inv[100001], factinv[100001];\nint ncr(int n, int r) { return r < 0 ? 0 : 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod; }\nint main() {\n    scanf(\"%d%d%d\", &H, &W, &K);\n    fact[0] = 1;\n    for(int i = 1; i <= 100000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n    inv[1] = 1;\n    for(int i = 2; i <= 100000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n    factinv[0] = 1;\n    for(int i = 1; i <= 100000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n    int ret = 0;\n    for(int i = 0; i <= K; i++) {\n        int re1 = (ncr(W + i, i) - ncr(W + i, i - 1) + mod) % mod;\n        int re2 = (ncr(H + K - i, K - i) - ncr(H + K - i, K - i - 1) + mod) % mod;\n        ret += 1LL * ncr(H + W + K, W + i) * re1 % mod * re2 % mod;\n        ret %= mod;\n    }\n    printf(\"%d\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n#include<set>\n#include<map>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof (c.begin()) i=c.begin(); i!=c.end(); i++)\n#define all(c) (c).begin(), (c).end()\n#define pb push_back\n#define mp make_pair\n#define dbg(x) cerr<<#x<<\" = \"<<x<<endl\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nconst int mod = (int)1e9 + 7;\ninline ll modpow(ll n, ll m, ll mod){\n\tll res = 1;\n\tfor(; m; m /= 2){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nll fact[100010];\ninline ll C(ll n, ll k){\n\tif(n < 0 || k > n) return 0;\n\treturn (ll)fact[n] * modpow(fact[k], mod - 2, mod) % mod\n\t\t* modpow(fact[n-k], mod - 2, mod) % mod; \n}\nll calc(ll x, ll y){\n\tll res = C(x + y, y);\n\tres = (res + mod - C(x + y, x - 1)) % mod;\n\treturn res;\n}\nint main(){\n\tfact[0] = 1;\n\trep(i, 100000) fact[i+1] = fact[i] * (i+1) % mod;\n\n  int n, m, k;\n  cin >> n >> m >> k;\n  ll res = 0;\n  rep(i, k + 1){\n  \tll tmp = C(n + m + 2*k, m + 2*i) * calc(k - i, n + k - i) % mod * calc(i, m + i) % mod;\n  \tres = (res + tmp) % mod;\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst int MOD = 1000000007;\nconst int S = 300000;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(int i=1; i<=S; i++) {\n        fact[i] = fact[i-1] * i % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(int i=S; i>=0; i--) {\n        finv[i-1] = finv[i] * i % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = sum_ud - nCr(ud, u+1) + MOD % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = sum_lr - nCr(lr, r+1) + MOD % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\nconst ll mod = 1000000007;\n/*\nconst int N = 2500;\nãããã°ç¨\nll comb[N][N];\nvoid precalc(){\n  comb[0][0] = 1;\n  REP(i,1,N){\n    comb[i][0] = comb[i][i] = 1;\n    REP(j,1,i){\n      comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n    }\n  }\n}\n*/\n\nll mypow(ll n,ll p){\n  if (p == 1)return n;\n  ll ret=mypow(n,p/2);\n  ret=ret*ret%mod;\n  if (p&1)ret=ret*n%mod;\n  return ret;\n}\nll getinv(ll a){\n  return mypow(a,mod-2);\n}\n\n\nconst int N = 300000;\nll fact[N];\nvoid precalc(){\n  fact[0] = 1;\n  REP(i,1,N)fact[i] = (i * fact[i-1])%mod;\n}\n\nll comb(int a,int b){\n  ll ret = fact[a];\n  ret = (ret * getinv(fact[b]))%mod;\n  ret = (ret * getinv(fact[a-b]))%mod;\n  return ret;\n}\n\n//nãä¸ã«ç§»åããåæ°\n//xãä¸ã«ç§»åããåæ°\nll solve(int n,int x){\n  if (x == 0)return 1;\n  int u = n+x,d = x;\n  ll all = comb(u + d,u);//ãã¹ã¦ã®ãã¿ã¼ã³ã®æ°\n  ll ng  = comb(u+1 + d-1,u+1);//ãã¡ãªãã¿ã¼ã³ã®æ°ï¼åº§æ¨ãè² ã«ãªããã¿ã¼ã³)\n  assert(x-1 + n >= n);\n  return (all - ng+mod)%mod;\n}\n\nmain(){\n  precalc();\n  int n,m,k;\n  while(cin>>n>>m>>k && n){\n    ll ans = 0;\n    /*\n      kéãã®å¯ãéããå·¦å³ã«ç§»åããåæ°ãåºå®ãã¦å¨éãè©¦ãã\n      åå¯ãéã®ãã¿ã¼ã³ã¯n+2*iååããã¨ã«ãªãã\n      ããã§åº§æ¨ããã¤ãã¹ã«ãªããªãããã®æ¹æ³ã¯ãæ°å­¦ã¬ã¼ã«ï¼å·»ã«ä¹ã£ã¦ããæ¹æ³ãä½¿ãã¨ããã\n     */\n    rep(i,k+1){\n      ll lr = solve(n,i)  ;//å·¦å³ã®ç§»å\n      ll ud = solve(m,k-i);//ä¸ä¸ã®ç§»å\n      ll tmp = (lr*ud)%mod;\n      ll cm  = comb(n+2*i + m+2*(k-i),n+2*i);\n      cm = (cm*tmp)%mod;\n      ans = (ans + cm)%mod;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nll N,M,K;\nll fact[220010];\n\nll extgcd(ll a,ll b,ll& x, ll& y){\n\tll d=a;\n\tif(b)d=extgcd(b,a%b,y,x),y-=(a/b)*x;\n\telse x=1,y=0;\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn ((ll)m+x%m)%m;\n}\n\nll nCr(ll n,ll r){\n\tif(n<0 || r<0 || r>n)return 0;\n\treturn fact[n]\n\t*mod_inverse(fact[r],MOD) %MOD\n\t*mod_inverse(fact[n-r],MOD) %MOD;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tfact[0]=1;\n\trep2(i,1,220010)fact[i]=fact[i-1]*i%MOD;\n\t\n\tcin>>N>>M>>K;\n\tll ans=0;\n\trep(x,K+1){\n\t\tint y=K-x;\n\t\tll resx=nCr(N+x*2,x)-nCr(N+x*2,x-1)+MOD;\n\t\tll resy=nCr(M+y*2,y)-nCr(M+y*2,y-1)+MOD;\n\t\tans+=resx*resy %MOD *nCr(N+M+K*2,N+x*2);\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nstruct Combination\n{\n  int mod;\n  vector< int64_t > mfact, rfact;\n\n  Combination(int sz, int mod) : mfact(sz + 1), rfact(sz + 1), mod(mod)\n  {\n    mfact[0] = 1;\n    for(int i = 1; i < mfact.size(); i++) {\n      mfact[i] = mfact[i - 1] * i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for(int i = sz - 1; i >= 0; i--) {\n      rfact[i] = rfact[i + 1] * (i + 1) % mod;\n    }\n  }\n\n  int64_t fact(int k) const\n  {\n    return (mfact[k]);\n  }\n\n  int64_t pow(int64_t x, int64_t n) const\n  {\n    int64_t ret = 1;\n    while(n > 0) {\n      if(n & 1) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int64_t inv(int64_t x) const\n  {\n    return (pow(x, mod - 2));\n  }\n\n  int64_t P(int n, int r) const\n  {\n    if(r < 0 || n < r) return (0);\n    return (mfact[n] * rfact[n - r] % mod);\n  }\n\n  int64_t C(int p, int q) const\n  {\n    if(q < 0 || p < q) return (0);\n    return (mfact[p] * rfact[q] % mod * rfact[p - q] % mod);\n  }\n\n  int64_t H(int n, int r) const\n  {\n    if(n < 0 || r < 0) return (0);\n    return (r == 0 ? 1 : C(n + r - 1, r));\n  }\n};\n\nint main()\n{\n  Combination beet(500001, mod);\n  int N, M, K;\n  cin >> N >> M >> K;\n\n\n  vector< int > latte(K + 1), malta(K + 1);\n\n  vector< int > dp1(N + K + 1);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(N + K + 1);\n    for(int j = 1; j <= N + K; j++) {\n      dp1[j] += dp1[j - 1];\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    latte[i] = dp1[N];\n    for(int j = 0; j + 1 <= N + K; j++) {\n      dp2[j] += dp1[j + 1];\n    }\n    dp1.swap(dp2);\n  }\n\n\n  dp1.assign(M + K + 1, 0);\n  dp1[0] = 1;\n  for(int i = 0; i <= K; i++) {\n    vector< int > dp2(M + K + 1);\n    for(int j = 1; j <= M + K; j++) {\n      (dp1[j] += dp1[j - 1]) %= mod;\n      if(dp1[j] >= mod) dp1[j] -= mod;\n    }\n    malta[i] = dp1[i];\n    for(int j = 0; j + 1 <= M + K; j++) {\n      (dp2[j] += dp1[j + 1]) %= mod;\n    }\n    dp1.swap(dp2);\n  }\n\n  int64 ret = 0;\n  for(int i = 0; i <= K; i++) {\n    (ret += 1LL * latte[i] * malta[K - i] % mod * beet.C(N + M + 2 * K, N + 2 * i) % mod) %= mod;\n  }\n\n  cout << ret << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ninline ll mod_inverse(ll a, ll m){\n  ll b = m, u = 1, v = 0;\n  while (b) {\n    ll t = a / b;\n    swap(a -= t * b, b);\n    swap(u -= t * v, v);\n  }\n  return (u % m + m) % m;\n}\n\nint N, M, K;\nll frac[250005];\nll rfrac[250005];\nll C(ll n, ll r){\n\treturn frac[n]*rfrac[r]%MOD*rfrac[n-r]%MOD;\n}\nll H[10001];\nll W[10001];\nll dp[2][10001];\n\ninline int add(int a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n\treturn a;\n}\n\nmain(){\n\t\n\tfrac[0] = 1;\n\tREP(i, 250000) frac[i+1] = (frac[i]*(i+1)) % MOD;\n\tREP(i, 250000) rfrac[i] = mod_inverse(frac[i], MOD);\n\twhile(cin >> N >> M >> K){\n\t\tdp[0][0] = 1;\n\t\tW[0] = H[0] = 1;\n\t\tREPS(i, K)REP(j, i+1){\n\t\t\tdp[i&1][j] = add((j?dp[i&1][j-1]:0), dp[1^i&1][j]);\n\t\t\tW[i] = add(W[i], (ll)dp[i&1][j]*C(M+i-j-1, M-1)%MOD);\n\t\t\tH[i] = add(H[i], (ll)dp[i&1][j]*C(N+i-j-1, N-1)%MOD);\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, K+1){\n\t\t\tans += W[i]*H[K-i]%MOD*C(M+i*2+N+(K-i)*2, M+i*2)%MOD;\n\t\t}\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 100010;\nconst ll MOD = 1e9+7;\nll fact[3*MAXN], rfact[3*MAXN];\n\n// extgcd\nll extgcd(ll a, ll b, ll& x, ll& y) {\n    ll d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\n// mod_inverse\nll mod_inverse(ll a, ll m = MOD) {\n    ll x, y;\n    extgcd(a, m, x, y);\n    return (m+x%m) % m;\n}\n\nll nCr(int n, int r) {\n    ll ret = fact[n];\n    (ret *= rfact[r]) %= MOD;\n    (ret *= rfact[n-r]) %= MOD;\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    fact[0] = rfact[0] = 1;\n    for (int i = 1; i < 3*MAXN; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n        rfact[i] = mod_inverse(fact[i]);\n    }\n    int N, M, K;\n    cin >> N >> M >> K;\n    ll ans = 0;\n    int total = N+M+2*K;\n    for (int i = 0; i <= K; i++) {\n        int yoko = N+2*i;\n        int tate = M+2*(K-i);\n        ll y = nCr(yoko, i);\n        if (i > 0) {\n            (y -= nCr(yoko, i-1)) %= MOD;\n            if (y < 0) y += MOD;\n        }\n        ll t = nCr(tate, (K-i));\n        if (K-i > 0) {\n            (t -= nCr(tate, (K-i)-1)) %= MOD;\n            if (t < 0) t += MOD;\n        }\n        ll plus = (y*t)%MOD;\n        (plus *= nCr(total, yoko)) %= MOD;\n        ans += plus;\n    }\n    cout << ans%MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst ll MOD = 1000000007;\n\nll comb(int n,int k){\n  int m = 1;\n  if(n < 2 * k) k = n - k;\n  for(int i=1;i<=k+1;i++)   m = m * (n - i + 1) / i;\n  return m%MOD;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n,m,k;\n  cin >> n >> m >>k;\n  ll res1=0,res2=0;\n  for(int i=0;i<=k;i++){\n    if(i!=k) res1 = (res1+comb(n+m+k,n+i))%MOD;\n    else {\n      res2 = (comb(n+m+k,n+k)-comb(n+m+k,n-1))%MOD;\n      res1 =(res1+comb(n+m+k,n+i)-res2)%MOD;\n    }\n  }\n  cout << res1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n\ntypedef long long int int64;\nint64 mod = 1000000007;\n\npair<int64, pair<int64, int64> > extgcd(int64 a, int64 b)\n{\n\tif(b == 0)\n\t\treturn {a, {1, 0}};\n\tconst auto res = extgcd(b, a % b);\n\tconst int64 xd = res.second.first;\n\tconst int64 yd = res.second.second;\n\tconst int64 x = yd;\n\tconst int64 y = xd - (a / b) * yd;\n\treturn {res.first, {x, y}};\n}\n\nint64 modinv(int64 a)\n{\n\tconst auto res = extgcd(mod, a);\n\tconst int64 y = res.second.second;\n\treturn (mod + y % mod) % mod;\n}\n\nint64 pqr(int n)\n{\n\tstatic vector<int64> val(1, 1);\n\n\tfor(int i = val.size(); i <= n; ++i)\n\t\tval.push_back((val.back() * i) % mod);\n\n\treturn val[n];\n}\n\nint64 pqrinv(int n)\n{\n\tstatic vector<int64> val(1, 1);\n\n\tfor(int i = val.size(); i <= n; ++i)\n\t\tval.push_back((val.back() * modinv(i)) % mod);\n\n\treturn val[n];\n}\n\nint64 nck(int n, int k)\n{\n\tif(n < k)\n\t\treturn 0;\n\tint64 ret = 1;\n\n\tret = pqr(n);\n\tret = (ret * pqrinv(k)) % mod;\n\tret = (ret * pqrinv(n - k)) % mod;\n\n\treturn ret;\n}\n\nvoid push(int gen, vector<int64> &cur, vector<int64> &next)\n{\n\tfill(next.begin(), next.end(), 0);\n\tnext[0] = cur[0];\n\tconst int k = cur.size() - 1;\n\n\tfor(int i = 1; i <= k; ++i) {\n\t\tif(i * 2 > gen)\n\t\t\tcontinue;\n\t\tnext[i] = (cur[i] + cur[i - 1]) % mod;\n\t}\n\n\tswap(cur, next);\n}\n\nvector<int64> calculate_ways(int n, int k)\n{\n\tvector<int64> ways;\n\tvector<int64> cur, next;\n\tint pre = min(n, k * 2);\n\n\tways.resize(k + 1, 0);\n\tcur.resize(k + 1, 0);\n\tnext.resize(k + 1, 0);\n\tcur[0] = 1;\n\n\tfor(int gen = 1; gen <= pre; ++gen)\n\t\tpush(gen, cur, next);\n\n\tif(pre < n) {\n\n\t\tfill(next.begin(), next.end(), 0);\n\t\tconst int remain = n - pre;\n\n\t\tfor(int i = 0; i <= k; ++i) {\n\t\t\tfor(int j = 0; j <= i; ++j) {\n\t\t\t\tnext[i] += (cur[j] * nck(remain, i - j));\n\t\t\t\tnext[i] %= mod;\n\t\t\t}\n\t\t}\n\n\t\tswap(cur, next);\n\t}\n\n\tways[0] = cur[0];\n\tfor(int gen = n + 2; gen <= n + k * 2; gen += 2) {\n\t\tpush(gen - 1, cur, next);\n\t\tpush(gen, cur, next);\n\t\tways[(gen - n) / 2] = cur[(gen - n) / 2];\n\t}\n\n\treturn move(ways);\n}\n\n\nint main()\n{\n\tint n, m, k;\n\tvector<int64> n_ways, m_ways;\n\tint64 ans = 0;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tn_ways = calculate_ways(n, k);\n\tm_ways = calculate_ways(m, k);\n\n\tfor(int nk = 0; nk <= k; ++nk) {\n\n\t\tconst int mk = k - nk;\n\n\t\tconst int64 x = n_ways[nk];\n\t\tconst int64 y = m_ways[mk];\n\t\tconst int64 xy = (x * y) % mod;\n\n\t\tans += (xy * nck(n + m + k * 2, n + nk * 2)) % mod;\n\t\tans %= mod;\n\t}\n\n\tprintf(\"%d\\n\", (int)ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long LL;\nvector<LL> inverse_list(LL n, LL p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\nint main(){\n    LL N, M, K;\n    const LL MOD = 1000000007;\n    const LL MAX = 300000;\n    vector<LL> inv = inverse_list(MAX, MOD);\n    vector<LL> fact(MAX, 1);\n    vector<LL> factinv(MAX, 1);\n    for(int i = 1; i < MAX; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n        factinv[i] = factinv[i - 1] * inv[i] % MOD;\n    }\n    auto conb = [&](LL a, LL b) -> LL {\n        if(b < 0) return 0;\n        assert(a < MAX && a >= 0);\n        assert(b < MAX && b >= 0);\n        assert(a - b < MAX && a - b >= 0);\n        LL res = fact[a];\n        res = res * factinv[b] % MOD;\n        res = res * factinv[a - b] % MOD;\n        return res;\n    };\n    cin >> N >> M >> K;\n    LL ans = 0;\n    for(LL k1 = 0; k1 <= K; k1++) {\n        LL k2 = K - k1;\n        LL res = (conb(N + 2 * k1, k1) - conb(N + 2 * k1, k1 - 1) + MOD)\n            * (conb(M + 2 * k2, k2) - conb(M + 2 * k2, k2 - 1) + MOD) % MOD\n            * conb(N + M + 2 * K, N + 2 * k1) % MOD;\n        ans = (ans + res) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nnamespace std {\ntemplate <> class hash<std::pair<int, int>> {\n  public:\n    size_t operator()(const std::pair<int, int> &x) const {\n        return hash<int>()(x.first) ^ hash<int>()(x.second);\n    }\n};\n} // namespace std\n\nll solve(ll N, ll M, ll K) {\n    unordered_map<pi, bool> want;\n    unordered_map<pi, int> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    int DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (ll)(nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                    m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long x[200][200][200];\nint a, b, c;\n\nint main() {\n\tcin >> b >> c >> a;\n\tx[0][0][0] = 1;\n\tfor (int k = 0; k < 199; k++) {\n\t\tfor (int i = 0; i < 199; i++) {\n\t\t\tfor (int j = 0; j < 199; j++) {\n\t\t\t\tx[k][i + 1][j] += x[k][i][j];\n\t\t\t\tx[k][i][j + 1] += x[k][i][j];\n\t\t\t\tif (i - 1 >= 0) { x[k + 1][i - 1][j] += x[k][i][j]; }\n\t\t\t\tif (j - 1 >= 0) { x[k + 1][i][j - 1] += x[k][i][j]; }\n\t\t\t\tx[k][i][j] %= 1000000007;\n\t\t\t}\n\t\t}\n\t}\n\tcout << x[a][b][c] % 1000000007 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\n// http://topcoder.g.hatena.ne.jp/iwiwi/20130105/1357363348\nll inverse(ll v, ll mod) {\n\tll a = v, b = mod, x = 1, y = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(x -= t * y, y);\n\t}\n\treturn (x % mod + mod) % mod;\n}\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tll n, m, k;\n\tcin >> n >> m >> k;\n\n\tll mod = TEN(9) + 7;\n\tvector<ll> powmod(TEN(7)); powmod[0] = 1;\n\tFOR(i, 1, TEN(7)) powmod[i] = powmod[i - 1] * i % mod;\n\tauto nCk = [&](ll n, ll k) {\n\t\tll v = powmod[n] * inverse(powmod[k] * powmod[n - k] % mod, mod) % mod;\n\t\tassert(v >= 0);\n\t\treturn v;\n\t};\n\n\tvvl dp(k + 1, vl(k + 1)); REP(i, k+1) dp[i][0] = 1;\n\tFOR(j, 1, k + 1) FOR(i, j, k + 1){\n\t\tdp[i][j] = (dp[i][j - 1] + (i==j ? 0 : dp[i - 1][j])) % mod;\n\t}\n\n\tll sum = 0;\n\tREP(i, k + 1) {\n\t\tll v = nCk(n + m + k * 2, n + i * 2);\n\t\t{\n\t\t\tll c1 = 0;\n\t\t\tREP(j, i + 1) {\n\t\t\t\tll c = nCk(i - j + n - 1, n - 1);\n\t\t\t\t(c1 += dp[i][j] * c % mod) %= mod;\n\t\t\t}\n\t\t\t(v *= c1) %= mod;\n\n\t\t\tll c2 = 0;\n\t\t\tREP(j, (k - i) + 1) {\n\t\t\t\tll c = nCk((k - i) - j + m - 1, m - 1);\n\t\t\t\t(c2 += dp[k - i][j] * c % mod) %= mod;\n\t\t\t}\n\t\t\t(v *= c2) %= mod;\n\t\t}\n\t\t(sum += v) %= mod;\n\t}\n\n\tcout << sum << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll rev(int a){\n\tll ans=1;\n\tll b=a;\n\tll n=MOD-2;\n\twhile(n){\n\t\tif(n&1)\n\t\t\tans=(ans*b)%MOD;\n\t\tb=(b*b)%MOD;\n\t\tn >>=1;\n\t}\n\treturn (ans+MOD)%MOD;\n}\n\nll com(ll n,ll m){\n\tll ans=1;\n\twhile(m){\n\t\tans=((ans*n%MOD)*rev(m))%MOD;\n\t\tn--;\n\t\tm--;\n\t}\n\treturn (ans+MOD)%MOD;\n}\nint main(void){\n\tint N,M,K;\n\tcin >> N >> M >> K;\n\tll ans=0;\n\tfor(int p=0;p<=K;p++){\n\t\tint q=K-p;\n\t\tll a=((com(N+2*p,p)*(N+1))%MOD*rev(N+p+1))%MOD;\n\t\tll b=((com(M+2*q,q)*(M+1))%MOD*rev(M+q+1))%MOD;\n\t\tll c=(com(M+N+2*K,N+2*p))%MOD;\n\t\tans=(ans+((a*b)%MOD*c)%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define MOD 1000000007\n#define MAX_N 100000\n#define MAX_P 1000005\nInt fact[MAX_P],inv[MAX_P],finv[MAX_P];\n\nvoid init(Int mod){\n  fact[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    fact[i]=(fact[i-1]*i)%mod;\n\n  inv[1]=1;\n  for(Int i=2;i<MAX_P;i++)\n    inv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  \n  finv[0]=1;\n  for(Int i=1;i<MAX_P;i++)\n    finv[i]=(finv[i-1]*inv[i])%mod;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  init(MOD);\n  Int n,m,k;\n  cin>>n>>m>>k;\n  Int s=n+m+k*2;\n  vector<Int> dpx(s+1,0),dpy(s+1,0);\n  \n  {\n    vector<Int> dp(s+1,0);\n    dp[0]=1;\n    for(Int i=0;i<=s;i++){\n      vector<Int> nx(s+1,0);\n      //cout<<\"idx:\"<<i<<endl;\n      for(Int j=0;j<=s;j++){\n\t//cout<<dp[j]<<\" \";\n\tif(j-1>=0) (nx[j-1]+=dp[j])%=MOD;\n\tif(j+1<=s) (nx[j+1]+=dp[j])%=MOD;\n      }\n      //cout<<endl;\n      dpx[i]=dp[n];\n      dpy[i]=dp[m];\n      swap(dp,nx);\n    }\n  }\n  \n  vector<Int> nCk(s+1,1);\n  for(Int i=1;i<=s;i++)\n    nCk[i]=nCk[i-1]*(s-i+1)%MOD*inv[i]%MOD;\n  \n  Int ans=0;\n  for(Int i=0;i<=s;i++)\n    (ans+=dpx[i]*dpy[s-i]%MOD*nCk[i]%MOD)%=MOD;\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9+7;\n\nlli ExGCD(lli a, lli b, lli &x, lli &y){\n    lli d=a;\n    x=1; y=0;\n    if(b!=0){ d=ExGCD(b, a%b, y, x); y-=a/b*x; }\n    return d;\n}\nlli inverse(lli a){\n    lli x,y;\n    ExGCD(a, mod, x, y);\n    return x>0? x: mod+x;\n}\n\nconstexpr int arrmax=300001;\nlli fact[arrmax];\nlli inv[arrmax];\nvoid maketable(){\n    fact[0] = 1;\n    for(int i=0; i<arrmax-1; i++){\n        fact[i+1] = fact[i]*(i+1) %mod;\n    }\n    inv[arrmax-1] = inverse(fact[arrmax-1]);\n    for(int i=arrmax-1; i>0; i--){\n        inv[i-1] = inv[i]*i %mod;\n    }\n}\nlli combination(lli n, lli r){\n    if(r<0 or n<r) return 0;\n    return fact[n] *inv[n-r] %mod *inv[r] %mod;\n}\n\nint main(){\n    maketable();\n    lli n,m,k;\n    cin >> n >> m >> k;\n    lli ans = 0;\n    for(int i=0; i<=k; i++){\n        int j = k-i;\n        lli x = combination(n+2*i, i) -combination(n+2*i, i-1) +mod;\n        lli y = combination(m+2*j, j) -combination(m+2*j, j-1) +mod;\n        lli p = combination(n+m+2*k, n+2*i);\n        ans += x%mod *y%mod *p%mod;\n    }\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntemplate <int M, bool IsPrime = false>\nclass modulo {\n    using ll = long long;\npublic:\n    modulo() : n(0) {}\n    modulo(int m) : n(m) {\n        if(n >= M) {\n            n %= M;\n        } else if(n < 0) {\n            n = (n % M + M) % M;\n        }\n    }\n    modulo(ll m) {\n        if(m >= M) {\n            m %= M;\n        } else if(m < 0) {\n            m = (m % M + M) % M;\n        }\n        n = m;\n    }\n\n    explicit operator int() const {\n        return n;\n    }\n    explicit operator ll() const {\n        return n;\n    }\n    bool operator==(modulo const& a) const {\n        return n == a.n;\n    }\n\n    modulo& operator+=(modulo const& a) {\n        n += a.n;\n        if(n >= M) {\n            n -= M;\n        }\n        return *this;\n    }\n    modulo& operator-=(modulo const& a) {\n        n -= a.n;\n        if(n < 0) {\n            n += M;\n        }\n        return *this;\n    }\n    modulo& operator*=(modulo const& a) {\n        n = (ll(n) * a.n) % M;\n        return *this;\n    }\n    modulo operator^(int n) const {\n        if(n == 0) {\n            return modulo(1);\n        }\n        const modulo a = *this;\n        modulo res = (a * a) ^ (n / 2);\n        return n % 2 ? res * a : res;\n    }\n   \n    // for C++11, enable_if_t -> typename enable_if::type\n    std::enable_if_t<IsPrime, modulo> operator/(modulo const& a) const {\n        return *this * modulo(inv(ll(a), M));\n    }\n\n\nprivate:\n    int n;\n    // ax %% 1 (mod p)\n    // ex: 5x %% 1 (mod 13)\n    // ????????? 5x + 13y = 1\n    // ??????mod5???????????°???13y %% 1 (mod 5) ????????? 3y %% 1 (mod 5)????????????\n    // x = (1 - 13y) / 5 + 13 (+13?????£??????????????????)????????§???????????????y??????????????????\n    // ???????????? 3y %% 1 (mod 5) ?§£?????°??????????????????????????????inv(13%5, 5) ??§?????????\n    // ????????????x = (1 - 13*inv(13%5, 5))/5 + 13 ??¨?????????\n    static std::enable_if_t<IsPrime, ll> inv(ll a, ll p) {\n        return (a == 1 ? 1 : (1 - p*inv(p%a, a))/a + p);\n    }\n};\n\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator+(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs += rhs;\n    return lhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator-(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs -= rhs;\n    return lhs;\n}\ntemplate <int M, bool IsPrime>\nmodulo<M, IsPrime> operator*(modulo<M, IsPrime> lhs, modulo<M, IsPrime> const& rhs) {\n    lhs *= rhs;\n    return lhs;\n}\n\n// sw == false -> inv\ntemplate <int M>\nmodulo<M, true> fact(int n, bool sw = true) {\n    static std::vector<modulo<M, true>> v1 = {1}, v2 = {1};\n    if(n >= (int)v1.size()) {\n        const int from = v1.size(), to = n + 1024;\n        v1.reserve(to);\n        v2.reserve(to);\n        for(int i=from; i<to; ++i) {\n            v1.push_back(v1.back() * modulo<M, true>(i));\n            v2.push_back(v2.back() / modulo<M, true>(i));\n        }\n    }\n    return sw ? v1[n] : v2[n];\n}\n\ntemplate <int M>\nmodulo<M, true> comb(int a, int b) {\n    if(b < 0 || b > a) {\n        return fact<M>(0);\n    }\n    return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a-b, false);\n}\n\n\nconst int MOD = 1000000007;\nusing mod = modulo<MOD, true>;\nusing ll = long long;\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    mod ans(0);\n    for(int i=0; i<=k; ++i) {\n        mod tmp(1);\n        tmp *= comb<MOD>(n+m+2*k, n+2*i);\n        tmp *= comb<MOD>(n+i*2, i) - (i-1 >= 0 ? comb<MOD>(n+i*2, i-1) : 0);\n        tmp *= comb<MOD>(m+2*k-2*i, k-i) - (k-i-1 >= 0 ? comb<MOD>(m+2*k-2*i, k-i-1) : 0);\n        ans += tmp;\n    }\n    cout << ll(ans) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstruct Mod {\n\tll num;\n\tMod() : num(0) { ; }\n\tMod(ll n) : num(n) { ; }\n\toperator ll() { return num; }\n};\n\nconst ll mod = 1000000007;\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator^(Mod a, ll n)\n{\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { return a * inv(b); }\n\nMod fact(Mod n)\n{\n\tif (n < 0) assert(false);\n\tif (n == 0 || n == 1) return 1;\n\telse return n*fact(n - (Mod)1);\n}\n\nMod nPk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fact(n) / fact(k);\n}\n\nMod nCk(Mod n, Mod k)\n{\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn nPk(n, k) / fact(n - k);\n}\n\nMod nHk(Mod n, Mod k)\n{\n\treturn nCk(n + k - (Mod)1, k);\n}\n\n\nint main()\n{\n\tint N, M, k;\n\tcin >> N >> M >> k;\n\tMod n(N), m(M), ans(0);\n\tREP(i, k + 1)\n\t{\n\t\tint j = k - i;\n\t\tMod ver = nCk(m + (Mod)2 * (Mod)i, i) - nCk(m + (Mod)2 * (Mod)i, i - 1);\n\t\tMod hor = nCk(n + (Mod)2 * (Mod)j, j) - nCk(n + (Mod)2 * (Mod)j, j - 1);\n\t\tMod vm = M + i * 2, vh = N + j * 2;\n\t\tMod res = ver*hor*nCk(vm+vh, vh);\n\t\tans += res;\n\t}\n\tcout << (int)ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MOD 1000000007\nlong long power[500000];\nlong long dp[1600][1600];\nlong long p[1600][1600];\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=1500;i++){p[i][0]=1;p[i][i]=1;}\n\tfor(int i=1;i<=1500;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tdp[i][j]=dp[i-1][j]+dp[i][j-1];\n\t\t\tdp[i][j]%=MOD;\n\t\t\tif(j>=1 && j<i){\n\t\t\t\tp[i][j]=p[i-1][j-1]+p[i-1][j];\n\t\t\t\tp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum=0;\n\tfor(int i=0;i<=k;i++){\n\t\tif(n<i || m<k-i)continue;\n\t\tlong long V=p[n+m+k*2][n+i*2]*dp[n+i][i];V%=MOD;\n\t\tV*=dp[m+k-i][k-i];sum+=V;sum%=MOD;\n\t\t//cout<<p[n+m+k*2][n+i*2]<<' '<<dp[n+i][i]<<' '<<dp[m+k-i][k-i]<<endl;\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb() {fac.resize(FAC_MAX, 1); ifac.resize(FAC_MAX, 1);rep(i, 1, FAC_MAX) fac[i] = fac[i - 1] * i;\n        rep(i, 1, FAC_MAX) ifac[i] = T(1) / fac[i];}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n \n \n \n \n\n\nint N, M, K;\nComb<mint, 301010> com;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> M >> K;\n\n    mint ans = 0;\n    rep(x, 0, K + 1) {\n        int y = K - x;\n\n        mint co = com.aCb(N + M + K * 2, N + x * 2);\n        mint w = com.aCb(N + x * 2, x) - com.aCb(N + x * 2, x - 1);\n        mint h = com.aCb(M + y * 2, y) - com.aCb(M + y * 2, y - 1);\n\n        ans += co * h * w;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000000007;\nlong long inv[1000000];\nlong long fact[1000000];\nlong long factinv[1000000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tinv[1]=1;\n\tfor(int i=2;i<1000000;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfact[0]=1;\n\tfactinv[0]=1;\n\tfor(int i=1;i<1000000;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfactinv[i]=factinv[i-1]*inv[i]%mod;\n\t}\n\t\n\tlong long ret=0LL;\n\tfor(int i=0;i<=c;i++){\n\t\tlong long val=fact[a+b+c+c]*factinv[b+c+c-2*i]%mod*factinv[a+2*i]%mod;\n\t//\tprintf(\"%lld %lld\\n\",((fact[a+2*i]*factinv[a+i]%mod*factinv[i]%mod+mod-fact[a+2*i]*factinv[a+i-1]%mod*factinv[i+1]%mod)%mod)%mod,((fact[b+c+c-2*i]*factinv[b+c-i]%mod*factinv[c-i]%mod+mod-fact[b+c+c-2*i]*factinv[b+c-i-1]%mod*factinv[c-i+1]%mod)%mod)%mod);\n\t\tret=(ret+val*\n\t\t\t((fact[a+2*i]*factinv[a+i]%mod*factinv[i]%mod+mod-fact[a+2*i]*factinv[a+i+1]%mod*(i?factinv[i-1]:0)%mod)%mod)%mod*\n\t\t\t((fact[b+c+c-2*i]*factinv[b+c-i]%mod*factinv[c-i]%mod+mod-fact[b+c+c-2*i]*factinv[b+c-i+1]%mod*(i<c?factinv[c-i-1]:0)%mod)%mod)%mod\n\t\t\t)%mod;\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll fact[300000];\nll add(ll a,ll b){return (a+b+mod+mod)%mod;}\nll mul(ll a,ll b){return (a*b)%mod;}\nll mpow(ll a,ll b){\n  if(b==0)return 1;\n  ll res=mpow(mul(a,a),b/2);\n  if(b&1)res=mul(res,a);\n  return res;\n}\nll divi(ll a,ll b){\n  return mul(a,mpow(b,mod-2));\n}\nll nCr(ll n,ll r){\n  return divi(fact[n],mul(fact[r],fact[n-r]));\n}\nll calc(ll n,ll x){\n  if(x==0)return 1;\n  return add( nCr(n+x,x) , -nCr(n+x,x-1) );\n}\nint main(){\n  fact[0]=1;\n  for(ll i=1;i<300000;i++)\n    fact[i]=mul(fact[i-1],i);\n  \n  ll N,M,K,ans=0;\n  cin>>N>>M>>K;\n  for(ll i=0;i<=K;i++){\n    ll tmp=mul( calc(N+i,i),calc(M+K-i,K-i) );\n    ans=add(ans,mul(nCr(N+M+K+K,N+i+i),tmp));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2335\n#include<iostream>\nusing namespace std;\n\ntypedef long long int number;\n\nconst number MOD = 1e9 + 7;\nconst int XMAX = 4e5 + 8;\nnumber fact[XMAX], invfact[XMAX];\nnumber N, M, K;\n\nnumber pow(number a, number n) {\n  if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    number rt = pow(a, n / 2) % MOD;\n    return rt * rt % MOD;\n  } else {\n    return pow(a, n - 1) * a % MOD;\n  }\n}\n\nvoid construct_factorial(int n) {\n  fact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fact[i] = fact[i - 1] * i % MOD;\n  }\n  invfact[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    invfact[i] = pow(fact[i], MOD - 2);\n  }\n}\n\nnumber Comb(number n, number k) {\n  return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD;\n}\n\nnumber Uncomb(number n, number k) {\n  return (Comb(n+k, k) + MOD - Comb(n+k, k-1)) % MOD;\n}\n\nnumber solve() {\n  number ans = 0;\n  for (number k = 0; k <= K; k++) {\n    number j = K - k;\n    ans += Uncomb(N+k, k) * Uncomb(M+j, j) % MOD * \n      Comb(N+M+2*K, N+2*k) % MOD;\n    ans %= MOD;\n  }\n  return ans;\n}\n\nint main() {\n  cin >> N >> M >> K;\n  construct_factorial(4e5);\n  cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x, ll n){\n    ll ret = 1;\n    while(n){\n        if(n&1) (ret*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return ret;\n}\n\nll mod_inv(ll x){\n    return mod_pow(x,mod-2);\n}\n\nconst int F = 300010;\nll f[F], invf[F];\n\nll C(ll n, ll r){\n    if(r<0 || n-r<0) return 0;\n    ll ret = f[n];\n    (ret *= invf[r]) %= mod;\n    (ret *= invf[n-r]) %= mod;\n    return ret;\n}\n\nll calc(ll m, ll p){\n    ll ret = C(p+m,m);\n    (ret *= (p+1-m))%=mod;\n    (ret *= mod_inv(p+1))%=mod;\n    return ret;\n}\n\nint main(){\n    f[0] = 1;\n    for(int i=1; i<F; ++i) f[i] = (f[i-1]*i)%mod;\n    invf[F-1] = mod_inv(f[F-1]);\n    for(int i=F-2; i>=0; --i) invf[i] = (invf[i+1]*(i+1))%mod;\n\n    int n,m,k;\n    cin >>n >>m >>k;\n\n    ll ans = 0;\n    rep(i,k+1){\n        int mx = i, px = n+mx;\n        int my = k-i, py = m+my;\n        int X = mx+px, Y = my+py;\n        // printf(\" %d:: %d %d\\n\",i,X,Y);\n        ll add = C(X+Y,Y);\n        (add *= calc(mx,px)) %= mod;\n        (add *= calc(my,py)) %= mod;\n\n        (ans += add) %= mod;\n        // dbg(add);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define mod 1000000007\nint H, W, K, fact[100001], inv[100001], factinv[100001];\nint ncr(int n, int r) { return r < 0 ? 0 : 1LL * fact[n] * factinv[r] % mod * factinv[n - r] % mod; }\nint main() {\n    scanf(\"%d%d%d\", &H, &W, &K);\n    fact[0] = 1;\n    for(int i = 1; i <= 100000; i++) fact[i] = 1LL * fact[i - 1] * i % mod;\n    inv[1] = 1;\n    for(int i = 2; i <= 100000; i++) inv[i] = 1LL * inv[mod % i] * (mod - mod / i) % mod;\n    factinv[0] = 1;\n    for(int i = 1; i <= 100000; i++) factinv[i] = 1LL * factinv[i - 1] * inv[i] % mod;\n    int ret = 0;\n    for(int i = 0; i <= K; i++) {\n        int re1 = (ncr(W + 2 * i, i) - ncr(W + i, i - 1) + mod) % mod;\n        int re2 = (ncr(H + 2 * K - 2 * i, K - i) - ncr(H + 2 * K - 2 * i, K - i - 1) + mod) % mod;\n        ret += 1LL * ncr(H + W + 2 * K, W + 2 * i) * re1 % mod * re2 % mod;\n        ret %= mod;\n    }\n    printf(\"%d\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<stack>\n#include<queue>\n#include<numeric>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<bitset>\n#include<set>\n#include<cmath>\n#define int long long\nconst int inf=8938103643641919514ll;\nconst int mod=1000000007ll;\nconst int dd[]={0,-1,0,1,0};\nusing namespace std;\nclass mod_int{\npublic:\n\tint x;\n\tmod_int():x(0){}\n\tmod_int(int u):x(u){}\n\tmod_int operator=(int u){\n\t\tx=u;\n\t\treturn *this;\n\t}\n\tmod_int operator+=(mod_int y){\n\t\tx+=y.x;\n\t\tx=x>=mod?x-mod:x;\n\t\treturn *this;\n\t}\n\tmod_int operator-=(mod_int y){\n\t\tx-=y.x;\n\t\tx=x<0?x+mod:x;\n\t\treturn *this;\n\t}\n\tmod_int operator*=(mod_int y){\n\t\tx*=y.x;\n\t\tx%=mod;\n\t\treturn *this;\n\t}\n\tmod_int operator/=(mod_int y){\n\t\tmod_int z=1;\n\t\tfor(int u=1;u<=mod-2;u<<=1){\n\t\t\tif((mod-2)&u)\n\t\t\t\tz*=y;\n\t\t\ty*=y;\n\t\t}\n\t\toperator*=(z);\n\t\treturn *this;\n\t}\n};\nmod_int operator+(mod_int x,mod_int y){\n\treturn x+=y;\n}\nmod_int operator-(mod_int x,mod_int y){\n\treturn x-=y;\n}\nmod_int operator*(mod_int x,mod_int y){\n\treturn x*=y;\n}\nmod_int operator/(mod_int x,mod_int y){\n\treturn x/=y;\n}\nostream& operator<<(ostream &os,mod_int x){\n\treturn os<<x.x;\n}\nconst int aaa=300000;\nmod_int ttt[aaa];\nstatic class aaaaaaaaaaaaaaaa{\npublic:\n\taaaaaaaaaaaaaaaa(){\n\t\tttt[0]=1;\n\t\tmod_int x=1;\n\t\tfor(int i=1;i<aaa;i++){\n\t\t\tttt[i]=x*=i;\n\t\t}\n\t}\n} aaaaaaaaaaaaaaaaaaaaaaaaa;\nmod_int combi(int u,int v){\n\tif(u<aaa){\n\t\treturn ttt[u]/(ttt[v]*ttt[u-v]);\n\t}\n\tmod_int x=1,y=1;\n\tfor(int w=0;w<u-v;w++){\n\t\tx*=u-w;\n\t\ty*=w+1;\n\t}\n\treturn x/y;\n}\nmod_int catal(int u){\n\tif(u==0)\n\t\treturn 1;\n\treturn combi(u*2,u)-combi(u*2,u-1);\n}\nstruct A{\n\tint w;\n\tvector<int> e;\n};\nusing bbb=int;\nbbb p[100000];\nint saiki(int oya,int u){\n}\nsigned main(){\n\tint a,b,c,d,e,f,g,n,m;\n\tint i,j,k;\n\tcin>>n>>m>>k;\n\tmod_int ans=0;\n\tfor(i=0;i<=k;i++){\n\t\tint x=i,y=k-i;\n\t\tauto u=combi(n+m+k*2,n+x*2);\n\t\tauto v=combi(n+x*2,x);\n\t\tif(x>0)\n\t\t\tv-=combi(n+x*2,x-1);\n\t\tu*=v;\n\t\tv=combi(m+y*2,y);\n\t\tif(y>0)\n\t\t\tv-=combi(m+y*2,y-1);\n\t\tu*=v;\n\t\tans+=u;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nll Extgcd(ll a,ll b,ll &x,ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=Extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t} else {\n\t\tx=1; y=0;\n\t}\n\treturn d;\n}\n\nll ModInverse(ll a,ll m){\n\tll x,y;\n\tif(Extgcd(a,m,x,y)==1) return (x+m)%m;\n\treturn 0;\n}\n\nll fact[220001];\n\nvoid InitFact(ll n,ll m){\n\tfact[1]=1;\n\tfor(ll i=2; i<=n; ++i) fact[i]=(i*fact[i-1])%m;\n}\n\nll ModFact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0) return 1;\n\n\tll res=ModFact(n/p,p,e);\n\te+=n/p;\n\n\tif(n/p%2!=0) return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll ModComb(ll n,ll k,ll p){\n\tif(n<0||k<0||n<k) return 0;\n\tll e1,e2,e3;\n\tll a1=ModFact(n,p,e1),a2=ModFact(k,p,e2),a3=ModFact(n-k,p,e3);\n\tif(e1>e2+e3) return 0;\n\treturn a1*ModInverse(a2*a3%p,p)%p;\n}\n\nvoid Solve(){\n\tconst ll mod=1000000007;\n\tInitFact(220000,mod);\n\tll n,m,k;\n\tcin >> n >> m >> k;\n\n\tll res=0;\n\tREP(i,0,k+1){\n\t\tll a=(ModComb(n+2*i,i,mod)-ModComb(n+2*i,i-1,mod)+mod)%mod;\n\t\tll b=(ModComb(m+2*(k-i),k-i,mod)-ModComb(m+2*(k-i),(k-i)-1,mod)+mod)%mod;\n\t\tll c=ModComb(n+m+2*k,n+2*i,mod);\n\t\tres+=a*b%mod*c%mod;\n\t\tres%=mod;\n\t}\n\n\tcout << res << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define INIT(a) memset((a),0,sizeof(a))\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size() \nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst static int INF = 1e8;\nconst static D EPS = 1e-8;\n\nconst ll mod = 1e9+7;\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b != 0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll inv[10100];\n\ninline ll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\ninline ll cataran(ll n, ll k){\n  if(k==0)return 1;\n  ll res = n+1-k;\n  rep(i,k-1){\n    (res *= n+i+2) %= mod;\n    (res *= inv[i+2]) %= mod;\n  }\n  return res;\n}\n\nint main(){\n  ll n,m,k;\n  cin >> n >> m >> k;\n  rep(i,k){\n    inv[i+1] = mod_inverse(i+1,mod);\n  }\n\n  ll res = 0, comb = 1;\n  rep(i,n){\n    (comb *= n+m+2*k - i) %= mod;\n    (comb *= mod_inverse(i+1,mod)) %= mod;\n  }\n\n  rep(x,k+1){\n    ll y = k-x;\n    ll tmp = ( cataran(n+x,x) * cataran(m+y,y) ) % mod;\n    (tmp *= comb) %= mod;\n\n    (res += tmp) %= mod;\n\n    (comb *= m+2*k - 2*x) %= mod;\n    (comb *= m+2*k - 2*x-1) %= mod;\n    (comb *= mod_inverse(n+1+2*x,mod)) %= mod;\n    (comb *= mod_inverse(n+2+2*x,mod)) %= mod;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\nconst ll mod = 1000000007;\n/*\nconst int N = 2500;\nfobOp\nll comb[N][N];\nvoid precalc(){\n  comb[0][0] = 1;\n  REP(i,1,N){\n    comb[i][0] = comb[i][i] = 1;\n    REP(j,1,i){\n      comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;\n    }\n  }\n}\n*/\n\nll mypow(ll n,ll p){\n  if (p == 1)return n;\n  ll ret=mypow(n,p/2);\n  ret=ret*ret%mod;\n  if (p&1)ret=ret*n%mod;\n  return ret;\n}\nll getinv(ll a){\n  return mypow(a,mod-2);\n}\n\nconst int N = 300000;\nll fact[N];\nvoid precalc(){\n  fact[0] = 1;\n  REP(i,1,N)fact[i] = (i * fact[i-1])%mod;\n}\n\nll comb(int a,int b){\n  ll ret = fact[a];\n  ret = (ret * getinv(fact[b]))%mod;\n  ret = (ret * getinv(fact[a-b]))%mod;\n  return ret;\n}\n\n//nªãÉÚ®·éñ\n//xªºÉÚ®·éñ\nll solve(int n,int x){\n  if (x == 0)return 1;\n  int u = n+x,d = x;\n  ll all = comb(u + d,u);//·×ÄÌp^[Ì\n  ll ng  = comb(u+1 + d-1,u+1);//_Èp^[ÌiÀWªÉÈép^[)\n  assert(x-1 + n >= n);\n  return (all - ng+mod)%mod;\n}\n\nmain(){\n  precalc();\n  int n,m,k;\n  while(cin>>n>>m>>k && n){\n    ll ans = 0;\n    /*\n      kÊèÌñè¹ðA¶EÉÚ®·éñðÅèµÄSÊè·B\n      eñè¹Ìp^[Ín+2*iñ®­±ÆÉÈéB\n      ±êÅÀWª}CiXÉÈçÈ¢½ßÌû@ÍAwK[SªÉæÁÄ¢éû@ðg¤Æ¢¢B\n      ÇSp^[ªn+2*i choose n ÆÈèA»±©çngÉÈép^[ n+1 + (2*i-1) choose n+1 ðø¢½àÌª¶EÖÌÚ®p^[ÆÈéB\n      ãºÖÌÚ®p^[à¯lÉßçêéB\n       ÆÍ±ÌQÂð©¯í¹ÄAãºÆ¶EÌÚ®ðÇÌ^C~OÅâé©ðRrl[VÅßêÎ¢¢B\n     */\n    rep(i,k+1){\n      ll lr = solve(n,i)  ;//¶EÌÚ®\n      ll ud = solve(m,k-i);//ãºÌÚ®\n      ll tmp = (lr*ud)%mod;\n      ll cm  = comb(n+2*i + m+2*(k-i),n+2*i);\n      cm = (cm*tmp)%mod;\n      ans = (ans + cm)%mod;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 102400\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod getans(int m, int p) {\n\tif (m == 0)return 1;\n\tMod bb(comb(p+m, m) - comb(p + m, m - 1));\n\treturn comb(p + m, m) - comb(p + m, m - 1);\n}\n\n\nint main() {\n\tinit();\n\tint N, M, K; cin >> N >> M >> K;\n\tMod totalans(0);\n\tfor (int pxtime = N; pxtime <= N + K; ++pxtime) {\n\t\tint mxtime = pxtime - N;\n\t\tint pytime = M + (K-pxtime+N);\n\t\tint mytime = K - pxtime + N;\n\t\tMod ans(1);\n\t\tans *= getans(mxtime, pxtime);\n\t\tans *= getans(mytime, pytime);\n\t\tans *= comb(N + M + 2 * K, pxtime + mxtime);\n\t\ttotalans += ans;\n\t}\n\tcout << totalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> memo(300000, -1);\n\nclass Mod\n{\n    static const int MOD = 1000000007;\n    long long a;\npublic:\n    Mod(){\n        a = 0;\n    }\n    Mod(long long x){\n        a = x % MOD;\n    }\n    const Mod operator+(const Mod& x) const{\n        return Mod(a + x.a);\n    }\n    Mod& operator+=(const Mod& x){\n        *this = Mod(a + x.a);\n        return *this;\n    }\n    const Mod operator*(const Mod& x) const{\n        return Mod(a * x.a);\n    }\n    Mod& operator*=(const Mod& x){\n        *this = Mod(a * x.a);\n        return *this;\n    }\n    const Mod operator/(const Mod& x) const{ // フェルマーの小定理、x.aがMODと互いに素な場合のみ有効\n        if(memo[x.a] != -1)\n            return Mod(a * memo[x.a]);\n\n        int b = MOD - 2;\n        long long c = x.a;\n        long long ret = 1;\n        while(b > 0){\n            if(b & 1){\n                ret *= c;\n                ret %= MOD;\n            }\n            c *= c;\n            c %= MOD;\n            b >>= 1;\n        }\n\n        memo[x.a] = ret;\n        return Mod(a * ret);\n    }\n    Mod operator/=(const Mod& x){\n        *this = *this / x;\n        return *this;\n    }\n    long long getValue(){\n        return a;\n    }\n};\n\nvector<Mod> solve(int len, int n)\n{\n    if(len < n){\n        vector<Mod> ret;\n        vector<Mod> curr(2*n+1, 0);\n        curr[0] = 1;\n        for(int i=0; i<=n; ++i){\n            vector<Mod> next(2*n+1, 0);\n            for(int j=0; j<2*n; ++j){\n                curr[j+1] += curr[j];\n                if(j - 1 >= 0)\n                    next[j-1] += curr[j];\n            }\n            ret.push_back(curr[len]);\n            curr.swap(next);\n        }\n        return ret;\n    }\n\n    vector<Mod> dp;\n    vector<Mod> curr(n+1, 0);\n    curr[0] = 1;\n    for(int i=0; i<=n; ++i){\n        vector<Mod> next(n+1, 0);\n        for(int j=0; j<n; ++j){\n            curr[j+1] += curr[j];\n            if(j-1 >= 0)\n                next[j-1] += curr[j];\n        }\n        dp.push_back(curr[n]);\n        curr.swap(next);\n    }\n\n    vector<Mod> ret(n+1, 0);\n    for(int i=0; i<=n; ++i){\n        Mod tmp = 1;\n        for(int j=0; j<i; ++j){\n            tmp *= len - n + 2 * i - j;\n            tmp /= j + 1;\n        }\n\n        for(int j=0; j<=n-i; ++j){\n            ret[i+j] += dp[j] * tmp;\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    int w, h, n; // ゴールのx座標、y座標、寄り道回数\n    cin >> w >> h >> n;\n\n    vector<Mod> s = solve(w, n);\n    vector<Mod> t = solve(h, n);\n\n    cout << s[0].getValue() << ' ' << s[1].getValue() << ' ' << s[2].getValue() << endl;\n\n    Mod tmp = 1;\n    for(int i=0; i<h; ++i){\n        tmp *= w + h + 2 * n - i;\n        tmp /= i + 1;\n    }\n\n    Mod ret = 0;\n    for(int i=0; i<=n; ++i){\n        ret += s[n-i] * t[i] * tmp;\n\n        for(int j=0; j<2; ++j){\n            tmp *= w + 2 * n - 2 * i - j;\n            tmp /= h+1+2*i+j;\n        }\n    }\n    cout << ret.getValue() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\n//a x + b y = gcd(a, b)\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n  long long g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nlong long InvMod(long long a, long long mod) {\n  long long x, y;\n  if (extgcd(a, mod, x, y) == 1) { return (x + mod) % mod; }\n  return 0;\n}\n\nconst ll MOD = 1000000007;\nll fact[500000];\nll invFact[500000];\ninline ll Combi(ll a, ll b) {\n  if (b < 0 || a < b) { return 0; }\n  return fact[a] * invFact[a - b] % MOD * invFact[b] % MOD;\n}\nint main() {\n  fact[0] = 1;\n  invFact[0] = 1;\n  REP(i, 499999) {\n    fact[i + 1] = (fact[i] * (i + 1)) % MOD;\n    invFact[i + 1] = InvMod(fact[i + 1], MOD);\n  }\n  ll n, m, k;\n  while (scanf(\"%lld %lld %lld\", &n, &m, &k) > 0) {\n    ll ans = 0;\n    FOREQ(i, 0, k) {\n      ll j = k - i;\n      ll l = (Combi(n + 2 * i, i) - Combi(n + 2 * i, i - 1) + MOD) % MOD;\n      ll r = (Combi(m + 2 * j, j) - Combi(m + 2 * j, j - 1) + MOD) % MOD;\n      ll mid = Combi(n + m + 2 * k, n + 2 * i);\n      ans = (ans + l * mid % MOD * r) % MOD;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-2;\nconst int inf=1e8;\n#define MOD 1000000007\n// a^b mod MOD\nll powmod(ll a,ll b){\n\tll out=1;\n\tll p=a%MOD;\n\twhile(b){\n\t\tif(b&1)out=out*p%MOD;\n\t\tp=p*p%MOD;\n\t\tb>>=1;\n\t}\n\treturn out;\n}\n// nCr\nll nCr(ll n,ll r){\n\tll out=1;\n\tr=min(r,n-r);\n\tif(r<0)return 0;\n\tfor(ll i=n;i>n-r;i--)out=out*(i%MOD)%MOD;\n\tll t=1;\n\tfor(ll i=2;i<=r;i++)t=t*i%MOD;\n\treturn out*powmod(t,MOD-2)%MOD;\n}\nint main(){\n\tll n,m,x;\n\tcin>>n>>m>>x;\n\tll out=0;\n\tfor(ll i=0;i<x+1;i++){\n\t\tll t=1;\n\t\t(t*=(nCr(n+2*i,i)-nCr(n+2*i,i-1)+MOD)%MOD)%=MOD;\n\t\t(t*=(nCr(m+2*(x-i),x-i)-nCr(m+2*(x-i),x-i-1)+MOD)%MOD)%=MOD;\n\t\t(t*=nCr(n+m+2*x,n+2*i))%=MOD;\n\t\t(out+=t)%=MOD;\n\t}\n\tcout<<out<<endl;\n}\n/*\nint main(){\n\tint d[]={0,1,1,0};//kyosi\n\tvvd w(2,vd(4,0.5));//weight\n\tint x[]={1,2};//input\n\tint cnt=10000;\n\twhile(cnt--){\n\t\tvd y(4);\n\t\trep(i,4)rep(j,2)y[i]+=w[j][i]*x[j];\n\t\tdouble E=0;\n\t\trep(i,4)E-=(d[i]*log(y[i])+(1-d[i])*log(1-y[i]));\n\t\t//BP\n\t\trep(i,2)rep(j,4)w[i][j]-=EPS*(y[j]-d[j])*x[i]*(exp(-y[j])/pow(1+exp(-y[j]),2));\n\n//\t\tcout<<cnt<<endl;\n//\t\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n//\t\tcout<<endl;\n\t}\n\trep(i,2){rep(j,4)cout<<\" \"<<shosu(9)<<w[i][j];cout<<endl;}\n\tcout<<endl;\n\trep(i,4)cout<<\" \"<<shosu(9)<<w[0][i]*x[0]+w[1][i]*x[1];\n\tcout<<endl;\n}\n//*/\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nll solve(ll N, ll M, ll K) {\n    map<pi, bool> want;\n    map<pi, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    int DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nconstexpr ll MOD = 1e9 + 7;\n\ntemplate <typename T>\nT mypow(T a, T b)\n{\n    if (b == 0)\n        return 1;\n    T tmp = mypow(a, b / 2);\n    if (b % 2)\n        return (((tmp * tmp) % MOD) * a) % MOD;\n    else\n        return (tmp * tmp) % MOD;\n}\n\nvector<ll> fact(222222, 1), inv(222222, 1);\n\nll comb(int n, int r)\n{\n    if (r < 0 || n < r)\n        return 0;\n    ll ret = fact[n] * inv[r] % MOD;\n    ret = ret * inv[n - r] % MOD;\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m, k;\n    cin >> n >> m >> k;\n    for (ll i = 2; i <= 220000; i++)\n    {\n        fact[i] = fact[i - 1] * i % MOD;\n        inv[i] = mypow(fact[i], MOD - 2);\n    }\n    ll ret = 0;\n    for (ll i = 0; i <= k; i++)\n    {\n        // n + 2i 回左右移動\n        ll a = comb(n + 2 * i, i) * (n + 1) % MOD;\n        a = a * mypow(n + i + 1, MOD - 2) % MOD;\n        ll j = k - i;\n        ll b = comb(m + 2 * j, j) * (m + 1) % MOD;\n        b = b * mypow(m + j + 1, MOD - 2) % MOD;\n        ll sum = a * b % MOD;\n        sum = sum * comb(n + m + 2 * k, n + 2 * i) % MOD;\n        ret = (ret + sum) % MOD;\n    }\n    cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nusing ll = long long int;\n\nconst ll MOD = 1000000007LL;\nconst ll S = 500000LL;\nll fact[S+10], finv[S+10];\n\nll mod_pow(ll X, ll N) {\n    ll ret = 1;\n    for(; N>0; N>>=1) {\n        if(N & 1) (ret *= X) %= MOD;\n        (X *= X) %= MOD;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n\n    for(ll i=1; i<=S; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n    }\n\n    finv[S] = mod_pow(fact[S], MOD-2);\n    for(ll i=S; i>=1; i--) {\n        finv[i-1] = (finv[i] * i) % MOD;\n    }\n}\n\nll nCr(int n, int r) {\n    if(n < 0 || r < 0 || r > n) return 0;\n    return (fact[n] * finv[n-r] % MOD) * finv[r] % MOD;\n}\n\nint main() {\n    init();\n\n    ll N, M, K; cin >> N >> M >> K;\n\n    ll ans = 0;\n    for(int d=0; d<=K; d++) {\n        int l = K - d;\n\n        int ud = N + 2*d, lr = M + 2*l;\n        int u = ud - d, r = lr - l;\n\n        ll mul = nCr(ud + lr, ud);\n        ll sum_ud = nCr(ud, d);\n        sum_ud = (sum_ud - nCr(ud, u+1) + MOD) % MOD;\n\n        ll sum_lr = nCr(lr, r);\n        sum_lr = (sum_lr - nCr(lr, r+1) + MOD) % MOD;\n\n        (mul *= sum_ud) %= MOD;\n        (mul *= sum_lr) %= MOD;\n        (ans += mul) %= MOD;\n        // printf(\"mul = %lld\\n\", mul);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for(long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for(long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                                                            \\\n    (upper_bound((V).begin(), (V).end(), X) -                                  \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                                                               \\\n    {                                                                          \\\n        cerr << #v << ':';                                                     \\\n        for(auto xv : v) cerr << xv << ' ';                                    \\\n        cerr << endl;                                                          \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 1000000007;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T> inline bool chmin(T &a, const T &b) {\n    if(a > b) a = b;\n    return a > b;\n}\ntemplate <typename T> inline bool chmax(T &a, const T &b) {\n    if(a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* liblary */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while(n) {\n        if(n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long nckmodp(long long n, long long k, long long p) {\n    if(n < k || n <= 0 || k < 0) return 0;\n    while(factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\n/* main */\n\nnamespace std {\ntemplate <> class hash<std::pair<int, int>> {\n  public:\n    size_t operator()(const std::pair<int, int> &x) const {\n        return hash<int>()(x.first) ^ hash<int>()(x.second);\n    }\n};\n} // namespace std\n\nll solve(ll N, ll M, ll K) {\n    unordered_map<pi, bool> want;\n    unordered_map<pi, ll> m;\n    FOR(i, 0, K + 1) {\n        want[make_pair(N + 2 * i, i)] = true;\n        want[make_pair(M + 2 * i, i)] = true;\n    }\n    ll DP[K + 1] = {0}, DP2[K + 1] = {0};\n    DP[0] = 1;\n    FOR(i, 1, max(N, M) + 2 * K + 1) {\n        FOR(j, 0, K + 1) {\n            DP2[j] = DP[j] + (j ? DP[j - 1] : 0);\n            DP2[j] %= INF;\n            if(!(i / 2 >= j)) DP2[j] = 0;\n            if(want[make_pair(i, j)]) {\n                m[make_pair(i, j)] = DP2[j];\n            }\n        }\n        FOR(j, 0, K + 1) DP[j] = DP2[j];\n    }\n    ll ans = 0;\n    FOR(i, 0, K + 1) {\n        ans += (nckmodp(N + M + 2 * K, N + 2 * i, INF) *\n                m[make_pair(N + 2 * i, i)]) %\n               INF * m[make_pair(M + 2 * (K - i), K - i)];\n        ans %= INF;\n    }\n    return ans;\n}\n\nsigned main() {\n    ll N, M, K;\n    cin >> N >> M >> K;\n    cout << solve(N, M, K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nll Extgcd(ll a,ll b,ll &x,ll &y){\n\tll d=a;\n\tif(b!=0){\n\t\td=Extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t} else {\n\t\tx=1; y=0;\n\t}\n\treturn d;\n}\n\nll ModInverse(ll a,ll m){\n\tll x,y;\n\tif(Extgcd(a,m,x,y)==1) return (x+m)%m;\n\treturn 0;\n}\n\nll fact[220001];\n\nvoid InitFact(ll n,ll m){\n\tfact[1]=1;\n\tfor(ll i=2; i<=n; ++i) fact[i]=(i*fact[i-1])%m;\n}\n\nll ModFact(ll n,ll p,ll &e){\n\te=0;\n\tif(n==0) return 1;\n\n\tll res=ModFact(n/p,p,e);\n\te+=n/p;\n\n\tif(n/p%2!=0) return res*(p-fact[n%p])%p;\n\treturn res*fact[n%p]%p;\n}\n\nll ModComb(ll n,ll k,ll p){\n\tif(n<0||k<0||n<k) return 0;\n\tll e1,e2,e3;\n\tll a1=ModFact(n,p,e1),a2=ModFact(k,p,e2),a3=ModFact(n-k,p,e3);\n\tif(e1>e2+e3) return 0;\n\treturn a1*ModInverse(a2*a3%p,p)%p;\n}\n\nvoid Solve(){\n\tconst ll mod=1000000007;\n\tInitFact(220000,mod);\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\n\tll res=0;\n\tREP(i,0,k+1){\n\t\tres+=(ModComb(n+2*i,i,mod)-ModComb(n+2*i,i-1,mod))*(ModComb(m+2*(k-i),k-i,mod)-ModComb(m+2*(k-i),(k-i)-1,mod))%mod*ModComb(n+m+2*k,n+2*i,mod)%mod;\n\t\tres%=mod;\n\t}\n\n\tcout << res << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define repp(i, m, n) for(int i = m; i < n; i++)\n#define reps(i, n) for(int i = 1; i <= n; i++)\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pai;\ntypedef pair<ll,ll> pal;\n\nll kaijo[230000];\n\nll power(ll x, ll y)\n{\n\tif(y==0) return 1;\n\telse if(y==1) return x%MOD;\n\telse if(y%2==0) return (power(x, y/2)*power(x, y/2))%MOD;\n\telse return (x*((power(x, y/2)*power(x, y/2))%MOD))%MOD;\n}\n\nll waru(ll x, ll y)\n{\n\treturn (x*power(y, MOD-2))%MOD;\n}\n\nll comb(ll x, ll y)\n{\n\treturn waru(waru(kaijo[(int)x], kaijo[(int)y]), kaijo[(int)(x-y)]);\n}\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tll migi[10010], ue[10010];\n\tkaijo[0]=1;\n\treps(i, n+m+2*k) kaijo[i]=(kaijo[i-1]*i)%MOD;\n\tmigi[0]=1;\n\tue[0]=1;\n\treps(i, k)\n\t{\n\t\tmigi[i]=(comb((ll)(n+2*i), (ll)i)+MOD-comb((ll)(n+2*i), (ll)(i-1)))%MOD;\n\t\tue[i]=(comb((ll)(m+2*i), (ll)i)+MOD-comb((ll)(m+2*i), (ll)(i-1)))%MOD;\n\t}\n\tll ans=0;\n\trep(i, k+1)\n\t{\n\t\tans=(ans+(((migi[i]*ue[k-i])%MOD)*comb((ll)(n+m+2*k), (ll)(n+2*i)))%MOD)%MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<62 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nll fact[303030],invfact[303030];\nll comb(int n,int k){\n    if(k<0||k>n)return 0;\n    ll ret=invfact[k]*invfact[n-k]%mod;\n    return ret*fact[n]%mod;\n}\nll powmod(ll n,ll k){\n    ll ret=1;\n    while(k>0){\n        if(k&1)ret=ret*n %mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    fact[0]=1;\n    rep(i,300000)fact[i+1]=fact[i]*(i+1)%mod;\n    invfact[300000]=powmod(fact[300000],mod-2);\n    rep(i,300000)invfact[299999-i]=invfact[300000-i]*(300000-i)%mod;\n    ll ans=0;\n    rep(i,k+1){\n        ll l=(comb(n+2*i,i)-comb(n+2*i,i-1)+mod)%mod;\n        ll r=(comb(m+2*(k-i),k-i)-comb(m+2*(k-i),k-i-1)+mod)%mod;\n        l=l*r%mod;\n        ans+=l*comb(n+m+2*k,n+2*i)%mod;\n        ans%=mod;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\nint pr[500000],inv[500000];\n\nint beki(int n,int r){\n\tif(r==0) return 1ll;\n\tif(r==1) return n%inf;\n\tif(r%2) return (n*beki(n,r-1))%inf;\n\tint e=beki(n,r/2);\n\treturn (e*e)%inf;\n}\n\nint c(int n,int r){\n\tint w=pr[n];\n\tw*=inv[n-r];\n\tw%=inf;\n\tw*=inv[r];\n\tw%=inf;\n\treturn w;\n}\n\nint as(int n,int r){\n\tif(r==0) return 1;\n\tint qr=c(n+r,r)+inf;\n\tqr -= c(n+r,r-1);\n\tqr%=inf;\n\treturn qr;\n\t\n}\n         signed main(){\n\t\n\tint n,m,k;\n         \tpr[0]=1,inv[0]=1;\n         \tfor(int i=1;i<500000;i++){\n         \t\tpr[i]=(i*pr[i-1])%inf;\n         \t\tinv[i]=beki(pr[i],inf-2);\n         \t}\n         cin>>n>>m>>k;\n         \tint ans=0;\n         \tfor(int d=0;d<=k;d++){\n         \t\tint l=k-d;\n         \t\t\n         \t\tint r=1;\n         \t\tr*=as(n+d,d);\n         \t\tr%=inf;\n         \t\tr*=as(m+l,l);\n         \t\tr%=inf;\n         \t\tr*=c(n+m+2*k,n+2*d);\n         \t\tr%=inf;\n         \t\tans+=r;\n         \t\tans%=inf;\n         \t}\n         \tcout<<ans<<endl;\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing i64 = int64_t;\nusing namespace std;\nconst i64 MOD = 1000000007;\n\ninline i64 addmod(i64 a,i64 b){\n  return (a + b) % MOD;\n}\n\ninline i64 mulmod(i64 a,i64 b){\n  return a * b % MOD;\n}\n\ninline i64 submod(i64 a,i64 b){\n  return (a + MOD - b) % MOD;\n}\n\ninline i64 powermod(i64 a,i64 b){\n  // if(b==0)return 1;\n  // else if(b==1)return a;\n  // else{\n  //   i64 r = powermod(a,b/2);\n  //   return b % 2 ? r * r % MOD * a % MOD : r * r % MOD;\n  // }\n  i64 r = 1LL;\n  // cerr << __builtin_clz(b) << endl;\n  for(int i = 32 - __builtin_clz(b) - 1; i >= 0; i-- ){\n    if((1 << i) & b) r = r * r % MOD * a % MOD;\n    else r = r * r % MOD;\n  }\n  return r;\n}\n\ninline i64 divmod(i64 a,i64 b){\n  return a * powermod(b,MOD-2) % MOD;\n}\n\ni64 nCr(i64 n,i64 r){\n  if(r < 0) return 0;\n  i64 res = 1LL;\n  r = min(n-r,r);\n  for(i64 i = 1LL; i <= r ; i++ ){\n    res = mulmod(res,n-i+1);\n    res = divmod(res,i);\n  }\n  return res;\n}\n\ni64 A(i64 a,i64 b){\n  i64 r = submod(nCr(a,b),nCr(a,b-1));\n  return r;\n}\n\nint main() {\n  i64 N,M,K;\n  cin >> N >> M >> K;\n  i64 res = 0LL;\n  for(i64 i = 0LL; i <= K; i++ ){\n    i64 sub = nCr(N+M+K+K,N+i*2) * A(N+i*2,i) % MOD * A(M+(K-i)*2,K-i) % MOD;\n    res = addmod(res,sub);\n  }\n  cout << res << endl;\n  // cerr << nCr(138,7) << endl;\n  // cerr << powermod(2,10) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n\ntypedef long long i64;\n\nconst i64 MOD = 1e9 + 7;\ntemplate <i64 MOD> struct ModInt {\n  i64 value;\n\n  ModInt(i64 v = 0) { value = v % MOD; }\n\n  operator i64() { return value; }\n  ModInt<MOD> operator+(int v) { return (value + v) % MOD; }\n  ModInt<MOD> operator+(i64 v) { return (value + v) % MOD; }\n\n  ModInt<MOD> operator-(i64 v) {\n    v %= MOD;\n    return (MOD + value - v) % MOD;\n  }\n\n  ModInt<MOD> operator*(i64 v) { return (value * v) % MOD; }\n};\n\n// Eucli\ni64 inv_mod(i64 a, i64 m = MOD) {\n  i64 b, x, u, q, abs_m, tmp;\n\n  abs_m = (m < 0) ? -m : m;\n  b = m;\n  x = 1;\n  u = 0;\n  while (b > 0) {\n    q = a / b;\n    tmp = u;\n    u = x - q * u;\n    x = tmp;\n    tmp = b;\n    b = a - q * b;\n    a = tmp;\n  }\n\n  return (x < 0) ? abs_m + x : x;\n}\n\ni64 fact[404040];\ni64 inv_fact[404040];\nusing mint = ModInt<MOD>;\n\nmint nCr(int n, int r) {\n  return (fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD) % MOD;\n}\n\n//重複組み合わせ\ni64 nHr(int n, int r) { return (nCr(n + r - 1, r)) % MOD; }\n\n\nint main(){\n\tfact[0] = 1;\n\tfor(int i = 1;i < 404040;i++){\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t}\n\tinv_fact[404040 - 1] = inv_mod(fact[404040 - 1]);\n\tfor(int i = 404040 - 2;i >= 0;i--){\n\t\tinv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;\n\t}\n\n\n\tmint result = 0;\n\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tfor(int i = 0;i <= k;i++){\n\t\tint j = k - i;\n\t\tmint l = 1,r = 1;\n\t\tif(i != 0)\n\t\t\tl = nCr(n + 2 * i , i) - nCr(n + 2 * i , i - 1);\n\t\tif(j != 0)\n\t\t\tr = nCr(m + 2 * j , j) - nCr(m + 2 * j,j - 1);\n\t\tresult = result + l * r * nCr(n + m + 2 * k,n + 2 * i);\n\t}\n\tcout << result << endl;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2335: 10-Year-Old Dynamic Programming\n// 2017.11.27 bal4u@uu\n\n#include <stdio.h>\n\n#define M 1000000007\n\nint fact[2020001];\n\nint extended_gcd(int a, int b, int *x, int *y)\n{\n\tint d;\n\n\tif (b == 0) { *x = 1; *y = 0; return a; }\n\td = extended_gcd(b, a % b, y, x);\n\t*y -= a / b * (*x);\n\treturn d;\n}\n\nint inverse(int a)\n{\n    int x, y;\n    if (extended_gcd(a, M, &x, &y) == 1) return (x + M) % M;\n    return 0;\n}\n\nint comb(int n, int k)\n{\n    if (n < 0 || k < 0 || n < k) return 0;\n\tif (k == 0) return 1;\n    return (long long)fact[n] * inverse(((long long)fact[k]*fact[n-k]) % M) % M;\n}\n\nint main()\n{\n\tint n, m, k, i, j, ii, jj, kk;\n\tint ans, r, c;\n\n\tfor (fact[0] = 1, i = 1; i < 2020001; i++) fact[i] = ((long long)fact[i-1]*i) % M;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n    ans = 0; kk = n + m + (k << 1);\n    for (i = 0; i <= k; i++){\n        j = k-i, ii = n + (i << 1), jj = m + (j << 1);\n        r = (comb(ii, i) - comb(ii, i-1) + M) % M;\n        c = (comb(jj, j) - comb(jj, j-1) + M) % M;\n        ans = (ans + ((long long)r*c) % M * (long long)comb(kk, ii)) % M;\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 2000000\nint W,H,K;\n\nstruct {\n  short x;\n  short y;\n  int ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  short x;\n  short y;\n  short z;\n  int ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2335: 10-Year-Old Dynamic Programming\n// 2017.11.27 bal4u@uu\n\n#include <stdio.h>\n\n#define M   1000000007\n#define MAX 2020000\n\nlong long fact[MAX+2], inv[MAX+2], factinv[MAX+2];\n\nlong long comb(int n, int k)\n{\n    if (n < 0 || k < 0 || n < k) return 0;\n\tif (k == 0) return 1LL;\n    return (((fact[n] * factinv[k]) % M) * factinv[n-k]) % M;\n}\n\nint main()\n{\n\tint n, m, k, i, j, ii, jj, kk;\n\tlong long ans, r, c;\n\n\tfor (fact[0] = 1, i = 1; i <= MAX; i++) fact[i] = (fact[i-1]*i) % M;\n\tfor (inv[1]  = 1, i = 2; i <= MAX; i++) inv[i] = (M + (-(M/i)*inv[M % i]) % M) % M;\n\tfor (factinv[0] = 1, i = 1; i <= MAX; i++) factinv[i] = (factinv[i-1]*inv[i]) % M;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n    ans = 0; kk = n + m + (k << 1);\n    for (i = 0; i <= k; i++){\n        j = k-i, ii = n + (i << 1), jj = m + (j << 1);\n        r = (comb(ii, i) - comb(ii, i-1) + M) % M;\n        c = (comb(jj, j) - comb(jj, j-1) + M) % M;\n        ans = (ans + (r*c) % M * comb(kk, ii)) % M;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000007\n\ntypedef long long int lli;\n\nlli memo[220001];\n\nvoid inittable(lli n){\n  lli i;\n\n  memo[1]=1;\n\n  for(i=2;i<=n;i++){\n    memo[(int)i]=(i*memo[(int)(i-1)])%N;\n  }\n}\n\nlli extgcd(lli a,lli b,lli *x,lli *y){\n  lli d=a;\n\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n\n    *y-=(a/b)*(*x);\n  }\n  else{\n    *x=1;\n    *y=0;\n  }\n\n  return d;\n}\n\nlli mod_inv(lli a,lli m){\n  lli x,y;\n\n  extgcd(a,m,&x,&y);\n\n  return (m+x%m)%m;\n}\n\nlli mod_cmb(lli n,lli r,lli m){\n  lli a1,a2,a3;\n\n  if((n<0)||(r<0)||(n<r)){\n    return 0;\n  }\n\n  a1=memo[n];\n  a2=memo[r];\n  a3=memo[n-r];\n\n  return a1*mod_inv(a2*a3%m,m)%m;\n}\n\nint main(){\n  int x,y,k;\n  int i,j;\n  lli ans;\n  lli xgr,ygr;\n\n  scanf(\"%d %d %d\",&x,&y,&k);\n\n  inittable(x+y+2*k);\n  memo[0]=1;\n  ans=0;\n\n  for(i=0;i<=k;i++){\n    xgr=(mod_cmb(x+2*(k-i),k-i,N)-mod_cmb(x+2*(k-i),k-i-1,N)+N)%N;\n    ygr=(mod_cmb(y+2*i,i,N)-mod_cmb(y+2*i,i-1,N)+N)%N;\n\n    ans=(ans+((xgr*ygr)%N)*mod_cmb(x+y+2*k,y+2*i,N))%N;\n  }\n  printf(\"%d\\n\",(ans+N)%N);\n\n  return 0; \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000007\n\ntypedef long long int lli;\n\nlli memo[220001];\n\nvoid inittable(lli n){\n  lli i;\n\n  memo[1]=1;\n\n  for(i=2;i<=n;i++){\n    memo[(int)i]=(i*memo[(int)(i-1)])%N;\n  }\n}\n\nlli extgcd(lli a,lli b,lli *x,lli *y){\n  lli d=a;\n\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n\n    *y-=(a/b)*(*x);\n  }\n  else{\n    *x=1;\n    *y=0;\n  }\n\n  return d;\n}\n\nlli mod_inv(lli a,lli m){\n  lli x,y;\n\n  extgcd(a,m,&x,&y);\n\n  return (m+x%m)%m;\n}\n\nlli mod_cmb(lli n,lli r,lli m){\n  lli a1,a2,a3;\n\n  if((n<0)||(r<0)||(n<r)){\n    return 0;\n  }\n\n  a1=memo[n];\n  a2=memo[r];\n  a3=memo[n-r];\n\n  return a1*mod_inv(a2*a3%m,m)%m;\n}\n\nint main(){\n  int x,y,k;\n  int i,j;\n  lli ans;\n  lli xgr,ygr;\n\n  scanf(\"%d %d %d\",&x,&y,&k);\n\n  inittable(x+y+2*k);\n  memo[0]=1;\n  ans=0;\n\n  for(i=0;i<=k;i++){\n    xgr=(mod_cmb(x+2*(k-i),k-i,N)-mod_cmb(x+2*(k-i),k-i-1,N)+N)%N;\n    ygr=(mod_cmb(y+2*i,i,N)-mod_cmb(y+2*i,i-1,N)+N)%N;\n\n    ans=(ans+((xgr*ygr)%N)*mod_cmb(x+y+2*k,y+2*i,N))%N;\n  }\n  printf(\"%d\\n\",(ans+N)%N);\n\n  return 0; \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD (1000000007)\n\ntypedef long long ll;\nll memo[220001];\n\nvoid initTable(ll n)\n{\n    ll i;\n    memo[1] = 1;\n    for (i = 2; i <= n; i++){\n        memo[(int)i] = (i * memo[(int)(i - 1)]) % MOD;\n    }\n}\n\nll extgcd(ll a, ll b, ll *x, ll *y)\n{\n    ll d = a;\n    if (b != 0){\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * *x;\n    }\n    else {\n        *x = 1;\n        *y = 0;\n    }\n    return (d);\n}\n\nll mod_inverse(ll a, ll m){\n    ll x, y;\n    extgcd(a, m, &x, &y);\n    return ((m + x % m) % m);\n}\n\nll mod_fact(ll n, ll p, ll *e)\n{\n    ll res;\n    int look;\n    *e = 0;\n    if (n == 0){\n        return (1);\n    }\n    \n    res = mod_fact(n / p, p, e);\n    *e += n / p;\n    \n    if (n / p % 2 != 0){\n        return (res * (p - memo[(int)(n % p)]) % p);\n    }\n    look = n % p;\n    return (res * memo[(int)(n % p)] % p);\n}\n\nll mod_comb(ll n, ll k, ll p) {\n    ll e1, e2, e3;\n    ll a1, a2, a3;\n    \n    if (n < 0 || k < 0 || n < k){\n        return (0);\n    }\n    \n    a1 = mod_fact(n, p, &e1);\n    a2 = mod_fact(k, p, &e2);\n    a3 = mod_fact(n - k, p, &e3);\n    \n    if (e1 > e2 + e3){ //divisible\n        return (0);\n    }\n    return (a1 * mod_inverse(a2 * a3 % p, p) % p);\n}\n\nint main(void)\n{\n    int x, y, k;\n    int i, j;\n    ll res;\n    ll xgrid, ygrid;\n    \n    scanf(\"%d%d%d\", &x, &y, &k);\n    \n    memset(memo, -1, sizeof(memo));\n    initTable(x + y + 2 * k);\n    memo[0] = 1;\n    res = 0;\n    \n    for (i = 0; i <= k; i++){ // ãºÉy + 2 * iñ, ¶EÉ x + 2 * k - 2 * iñ®­\n        xgrid = (mod_comb(x + 2 * (k - i) , k - i, MOD) - mod_comb(x + 2 * (k - i), k - i - 1, MOD) + MOD) % MOD;\n        ygrid = (mod_comb(y + 2 * i, i, MOD) - mod_comb(y + 2 * i, i - 1, MOD) + MOD) % MOD;\n        \n        res = (res + ((xgrid * ygrid) % MOD) * mod_comb(x + y + 2 * k, y + 2 * i, MOD)) % MOD;\n    }\n    \n    printf(\"%lld\\n\", (res + MOD) % MOD);\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\nMaximum Sum Sequence\n*/\n#include <stdio.h>\n#define MAXHASH 2000000\nint W,H,K;\n\nstruct {\n  int x;\n  int y;\n  long long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  int x;\n  int y;\n  int z;\n  long long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 1800000\nint W,H,K;\n\nstruct {\n  short x;\n  short y;\n  long long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  short x;\n  short y;\n  short z;\n  long long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  //printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 1200000\nint W,H,K;\n\nstruct {\n  int x;\n  int y;\n  long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  int x;\n  int y;\n  int z;\n  long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y, long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways % 1000000007L;\n  hashcnt++;\n  return(ptr);\n}\n\nlong find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1L);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  // printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2335: 10-Year-Old Dynamic Programming\n// 2017.11.27 bal4u@uu\n// 2017.12.2\n\n#include <stdio.h>\n\n#define M 1000000007\n\nint fact[2020001];\n\nint egcd(int a, int b, int *x, int *y)\n{\n\tint d;\n\n\tif (b == 0) { *x = 1; *y = 0; return a; }\n\td = egcd(b, a % b, y, x);\n\t*y -= a / b * (*x);\n\treturn d;\n}\n\nint inverse(int a)\n{\n    int x, y;\n\tegcd(a, M, &x, &y);\n\tif (x < 0) x += M;\n\treturn x;\n}\n\nint comb(int n, int k)\n{\n//    if (n < 0 || k < 0 || n < k) return 0;\n\tif (k == 0) return 1;\n    return (long long)fact[n] * inverse(((long long)fact[k]*fact[n-k]) % M) % M;\n}\n\nint main()\n{\n\tint n, m, k, i, j, kk, ii, jj, r, c, ans;\n\n\tfor (fact[0] = 1, i = 1; i < 2020001; i++) fact[i] = ((long long)fact[i-1]*i) % M;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n    ans = 0; kk = n + m + (k << 1);\n    for (j = k, i = 0; i <= k; i++, j--) {\n        ii = n + (i << 1), jj = m + (j << 1);\n        r = comb(ii, i) - comb(ii, i-1); if (r < 0) r += M;\n        c = comb(jj, j) - comb(jj, j-1); if (c < 0) c += M;\n        ans = (ans + ((long long)r*c) % M * (long long)comb(kk, ii)) % M;\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 3400000\nint W,H,K;\n\nstruct {\n  short x;\n  short y;\n  int ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  short x;\n  short y;\n  int z;\n  long long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 1600000\nint W,H,K;\n\nstruct {\n  short x;\n  short y;\n  long long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  short x;\n  short y;\n  short z;\n  long long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2335: 10-Year-Old Dynamic Programming\n// 2017.11.27 bal4u@uu\n\n#include <stdio.h>\n\n#define M 1000000007\n\nlong long fact[2020001];\n\nint extended_gcd(int a, int b, int *x, int *y)\n{\n\tint d;\n\n\tif (b == 0) { *x = 1; *y = 0; return a; }\n\td = extended_gcd(b, a % b, y, x);\n\t*y -= a / b * (*x);\n\treturn d;\n}\n\nlong long inverse(int a)\n{\n    int x, y;\n    if (extended_gcd(a, M, &x, &y) == 1) return (x + M) % M;\n    return 0;\n}\n\nlong long comb(int n, int k)\n{\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fact[n] * inverse((fact[k]*fact[n-k]) % M) % M;\n}\n\nint main()\n{\n\tint n, m, k, i, j, ii, jj, kk;\n\tlong long ans, r, c;\n\n\tfor (fact[0] = 1, i = 1; i < 2020001; i++) fact[i] = (fact[i-1]*i) % M;\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n    ans = 0; kk = n + m + (k << 1);\n    for (i = 0; i <= k; i++){\n        j = k-i, ii = n + (i << 1), jj = m + (j << 1);\n        r = (comb(ii, i) - comb(ii, i-1) + M) % M;\n        c = (comb(jj, j) - comb(jj, j-1) + M) % M;\n        ans = (ans + (r*c) % M * comb(kk, ii)) % M;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD (1000000007)\n\ntypedef __int64 ll;\nll memo[220001];\n\nvoid initTable(ll n)\n{\n    ll i;\n    memo[1] = 1;\n    for (i = 2; i <= n; i++){\n        memo[(int)i] = (i * memo[(int)(i - 1)]) % MOD;\n    }\n}\n\nll extgcd(ll a, ll b, ll *x, ll *y)\n{\n    ll d = a;\n    if (b != 0){\n        d = extgcd(b, a % b, y, x);\n        *y -= (a / b) * *x;\n    }\n    else {\n        *x = 1;\n        *y = 0;\n    }\n    return (d);\n}\n\nll mod_inverse(ll a, ll m){\n    ll x, y;\n    extgcd(a, m, &x, &y);\n    return ((m + x % m) % m);\n}\n\nll mod_fact(ll n, ll p, ll *e)\n{\n    ll res;\n    int look;\n    *e = 0;\n    if (n == 0){\n        return (1);\n    }\n    \n    res = mod_fact(n / p, p, e);\n    *e += n / p;\n    \n    if (n / p % 2 != 0){\n        return (res * (p - memo[(int)(n % p)]) % p);\n    }\n    look = n % p;\n    return (res * memo[(int)(n % p)] % p);\n}\n\nll mod_comb(ll n, ll k, ll p) {\n    ll e1, e2, e3;\n    ll a1, a2, a3;\n    \n    if (n < 0 || k < 0 || n < k){\n        return (0);\n    }\n    \n    a1 = mod_fact(n, p, &e1);\n    a2 = mod_fact(k, p, &e2);\n    a3 = mod_fact(n - k, p, &e3);\n    \n    if (e1 > e2 + e3){ //divisible\n        return (0);\n    }\n    return (a1 * mod_inverse(a2 * a3 % p, p) % p);\n}\n\nint main(void)\n{\n    int x, y, k;\n    int i, j;\n    ll res;\n    ll xgrid, ygrid;\n    \n    scanf(\"%d%d%d\", &x, &y, &k);\n    \n    memset(memo, -1, sizeof(memo));\n    initTable(x + y + 2 * k);\n    memo[0] = 1;\n    res = 0;\n    \n    for (i = 0; i <= k; i++){ // ãºÉy + 2 * iñ, ¶EÉ x + 2 * k - 2 * iñ®­\n        xgrid = (mod_comb(x + 2 * (k - i) , k - i, MOD) - mod_comb(x + 2 * (k - i), k - i - 1, MOD) + MOD) % MOD;\n        ygrid = (mod_comb(y + 2 * i, i, MOD) - mod_comb(y + 2 * i, i - 1, MOD) + MOD) % MOD;\n        \n        res = (res + ((xgrid * ygrid) % MOD) * mod_comb(x + y + 2 * k, y + 2 * i, MOD)) % MOD;\n    }\n    \n    printf(\"%I64d\\n\", (res + MOD) % MOD);\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint mbk(long long a,int n,int m){return n?(mbk((a*a)%m,n/2,m)*(n%2?a:1))%m:1;}\nint inv(int a,int m){return mbk((long long)a,m-2,m);}\nint aCb(int a,int b,int m){\n  long long s=1,i;\n  if(b<0)return 0;\n  if(b>a-b)b=a-b;\n  for(i=0;i<b;i++)s=(((s*(a-i))%m)*inv(i+1,m))%m;  \n  return (int)s;\n}\nint main(){\n  int h,w,k,M=1e9+7,a,i;\n  long long s,b;\n  scanf(\"%d %d %d\",&h,&w,&k);\n  for(i=0;i<=k;i++){\n    a=k-i;\n    b=aCb(h+w+k+k,h+i+i,M);\n    b=(b*(aCb(h+i+i,i,M)-aCb(h+i+i,i-1,M)+M)%M)%M;\n    b=(b*(aCb(w+a+a,a,M)-aCb(w+a+a,a-1,M)+M)%M)%M;\n    s=(s+b)%M;\n  }\n  printf(\"%lld\\n\",s);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint mbk(long long a,int n,int m){return n?(mbk((a*a)%m,n/2,m)*(n%2?a:1))%m:1;}\nint inv(int a,int m){return mbk((long long)a,m-2,m);}\nlong long d[300010]={1,1};\nlong long e[300010]={};\nint M=1e9+7;\nint aCb(int a,int b,int m){\n  long long s=1,i;\n  if(b<0)return 0;\n  if(b>a-b)b=a-b;\n  return (((d[a]*e[b])%M)*e[a-b])%M;\n  for(i=0;i<b;i++)s=(((s*(a-i))%m)*inv(i+1,m))%m;  \n  return (int)s;\n}\nint main(){\n  int h,w,k,a,i;\n  long long s,b;\n  for(i=2;i<300005;i++)d[i]=(d[i-1]*i)%M;\n  for(i=0;i<300005;i++)e[i]=inv(d[i],M);\n  scanf(\"%d %d %d\",&h,&w,&k);\n  for(i=0;i<=k;i++){\n    a=k-i;\n    b=aCb(h+w+k+k,h+i+i,M);\n    b=(b*(aCb(h+i+i,i,M)-aCb(h+i+i,i-1,M)+M)%M)%M;\n    b=(b*(aCb(w+a+a,a,M)-aCb(w+a+a,a-1,M)+M)%M)%M;\n    s=(s+b)%M;\n  }\n  printf(\"%lld\\n\",s);\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 2000000\nint W,H,K;\n\nstruct {\n  int x;\n  int y;\n  long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  int x;\n  int y;\n  int z;\n  long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y, long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways % 1000000007L;\n  hashcnt++;\n  return(ptr);\n}\n\nlong find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1L);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  // printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2335\n10-Year-Old Dynamic Programming\n*/\n#include <stdio.h>\n#define MAXHASH 2000000\nint W,H,K;\n\nstruct {\n  int x;\n  int y;\n  long long ways;} hash[MAXHASH];\nint hashcnt;\nstruct {\n  int x;\n  int y;\n  int z;\n  long long ways;} hash2[MAXHASH];\nint hash2cnt;\n\nint init_hash()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash[i].x = 0;\n      hash[i].y = 0;\n      hash[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc (int x,int y)\n{\n  return((x*31371 + y*2689) % MAXHASH);\n}\n\nint regist_hash(int x,int y,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hashcnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc(x,y);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\treturn(-2);\n      if(hash[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash[ptr].x = x;\n  hash[ptr].y = y;\n  hash[ptr].ways = ways;\n  hashcnt++;\n  return(ptr);\n}\n\nlong long find_hash(int x,int y)\n{\n  int ptr;\n\n  ptr = hashfunc(x,y);\n \n  while(1)\n    {\n      if(hash[ptr].x == x && hash[ptr].y == y)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash[ptr].ways);      \n\t}\n      if(hash[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n/**HASH 2**/\n\nint init_hash2()\n{\n  int i;\n  for(i=0;i<MAXHASH;i++)\n    {\n      hash2[i].x = 0;\n      hash2[i].y = 0;\n      hash2[i].z = 0;\n      hash2[i].ways = -1LL;\n    }\n  hashcnt=0;\n}\n\nint hashfunc2 (int x,int y,int z)\n{\n  return((x*31371 + y*2689 + z*16711) % MAXHASH);\n}\n\nint regist_hash2(int x,int y,int z,long long ways)\n{\n  int ptr,ptr1;\n\n  if(hash2cnt >= MAXHASH/2)\n    return(-1);\n\n  ptr = hashfunc2(x,y,z);\n  ptr1 = ptr;\n  // printf(\"REGS0 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  for(;ptr<MAXHASH;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n  for(ptr=0;ptr<ptr1;ptr++)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\treturn(-2);\n      if(hash2[ptr].ways == -1LL)\n\tgoto REG;\n    }\n REG:\n  // printf(\"REGS1 %d %d:%lld (%d)\\n\",x,y,ways,ptr);\n  hash2[ptr].x = x;\n  hash2[ptr].y = y;\n  hash2[ptr].z = z;\n  hash2[ptr].ways = ways;\n  hash2cnt++;\n  return(ptr);\n}\n\nlong long find_hash2(int x,int y,int z)\n{\n  int ptr;\n\n  ptr = hashfunc2(x,y,z);\n \n  while(1)\n    {\n      if(hash2[ptr].x == x && hash2[ptr].y == y && hash2[ptr].z == z)\n\t{\n\t  // printf(\"FIND %d %d:%lld\\n\",x,y,hash[ptr].ways);\n\t  return(hash2[ptr].ways);      \n\t}\n      if(hash2[ptr].ways == -1)\n\treturn(-1LL);\n      ptr++;\n      if(ptr >= MAXHASH)\n\tptr=0;\n    }\n}\n\nlong long combi(int n,int r)\n{\n  long long ret;\n  if((ret=find_hash(n,r)) > 0)\n    return(ret);\n  if(r==0 || r==n)\n    return(1);\n  ret=(combi(n-1,r)+combi(n-1,r-1)) % 1000000007;\n  regist_hash(n,r,ret);\n  return(ret);\n}\n\nint f(int nu,int nd,int x)\n{\n  int ret;\n  //printf(\"%d %d %d\\n\", nu, nd, x);\n  if((ret=find_hash2(nu,nd,x)) > 0)\n    return(ret);\n\n  if (x < 0) \n    return(0);\n  if (0 == nu)\n    if(x >= nd)\n      return(1);\n    else\n      return(0);\n  else if (1 == nd)\n    if(0 == x)\n      return(nu);\n    else\n      return(1 + nu);\n  else\n    {\n      ret = (f(nu-1, nd ,x+1) + f(nu,nd-1,x-1)) % 1000000007;\n      regist_hash2(nu,nd,x,ret);\n      return(ret);\n    }\n}\n\nint f1(int N,int K1 )\n{\n  if ( K1 == 0)\n    return(1);\n  else\n    return( f( N- K1, K1, 0));\n}\n\n\nlong long f2335 (int W,int H, int K)\n{ long long sum,product;\n  int x;\n\n  sum = 0LL;\n  for(x=0;x<=K;x++)\n    {\n    product = (combi(W+H+2*K,W+x*2)*f1(W+2*x,x)) % 1000000007LL;\n    sum += (product*f1(H+(K-x)*2,K-x)) % 1000000007LL;\n    sum %= 1000000007LL;\n    // printf(\"%lld\\n\",sum);\n    }\n  return(sum);\n\t\t}\n\nmain()\n{\n  init_hash();\n  init_hash2();\n  scanf(\"%d %d %d\",&W,&H,&K);\n  printf(\"%lld\\n\",f2335(W,H,K));\n  //printf(\"%d %d\\n\",hashcnt,hash2cnt);\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint mbk(long long a,int n,int m){return n?(mbk((a*a)%m,n/2,m)*(n%2?a:1))%m:1;}\nint inv(int a,int m){return mbk((long long)a,m-2,m);}\nlong long d[100010]={1,1};\nlong long e[100010]={};\nint M=1e9+7;\nint aCb(int a,int b,int m){\n  long long s=1,i;\n  if(b<0)return 0;\n  if(b>a-b)b=a-b;\n  return (((d[a]*e[b])%M)*e[a-b])%M;\n  for(i=0;i<b;i++)s=(((s*(a-i))%m)*inv(i+1,m))%m;  \n  return (int)s;\n}\nint main(){\n  int h,w,k,a,i;\n  long long s,b;\n  for(i=2;i<100000;i++)d[i]=(d[i-1]*i)%M;\n  for(i=0;i<100000;i++)e[i]=inv(d[i],M);\n  scanf(\"%d %d %d\",&h,&w,&k);\n  for(i=0;i<=k;i++){\n    a=k-i;\n    b=aCb(h+w+k+k,h+i+i,M);\n    b=(b*(aCb(h+i+i,i,M)-aCb(h+i+i,i-1,M)+M)%M)%M;\n    b=(b*(aCb(w+a+a,a,M)-aCb(w+a+a,a-1,M)+M)%M)%M;\n    s=(s+b)%M;\n  }\n  printf(\"%lld\\n\",s);\n  return 0;\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\n\t\tfact = new long[n + m + 2 * k + 1];\n\t\tfact[0] = 1;\n\t\tfact[1] = 1;\n\t\tfor (int i = 1; i <= n + m + 2 * k; i++) {\n\t\t\tfact[i] = (i % MOD * fact[i - 1]) % MOD;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tlong a = 1, b = 1;\n\t\t\tif (i >= 1)\n\t\t\t\ta = nCk(n + 2 * i, i) % MOD - nCk(n + 2 * i - 2, i - 1) % MOD;\n\t\t\tif (k >= i + 1)\n\t\t\t\tb = (nCk(m + 2 * (k - i), k - i) % MOD - nCk(m + 2 * (k - i) - 2, k - i - 1)) % MOD;\n\t\t\ta %= MOD;\n\t\t\tb %= MOD;\n\t\t\tans += nCk(n + m + 2 * k, n + 2 * i) % MOD * a % MOD * b % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\n\t\twhile (ans < 0)\n\t\t\t\n\t\t\tans += MOD;\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic long[] fact;\n\tstatic long[] inv_fact;\n\n\t// 1~n?????°?????????k????????????????????°\n\tstatic long nCk(int n, int k) {\n\t\tif (n < k)\n\t\t\treturn 0;\n\t\telse {\n\t\t\treturn fact[n] % MOD * inv(fact[n - k], MOD) % MOD * inv(fact[k], MOD) % MOD;\n\t\t}\n\t}\n\n\tstatic long inv(long a, long mod) {\n\t\ta = a % mod;\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\n\t\twhile (b > 1) {\n\t\t\tlong c = b / a;\n\t\t\tb = b % a;\n\t\t\tq = q - p * c;\n\t\t\tlong d = b;\n\t\t\tb = a;\n\t\t\ta = d;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d;\n\t\t}\n\t\twhile (q < 0)\n\t\t\tq += mod;\n\t\treturn q % MOD;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tstatic long MOD = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\n\t\tfact = new long[n + m + 2 * k + 1];\n\t\tfact[0] = 1;\n\t\tfact[1] = 1;\n\t\tfor (int i = 1; i <= n + m + 2 * k; i++) {\n\t\t\tfact[i] = (i % MOD * fact[i - 1]) % MOD;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tlong a = 1, b = 1;\n\t\t\tint j = k - i;\n\t\t\tif (i >= 1)\n\t\t\t\ta = (nCk(n + 2 * i, i) + MOD - nCk(n + 2 * i, i - 1)) % MOD;\n\t\t\tif (j >= 1)\n\t\t\t\tb = (nCk(m + 2 * j, j) + MOD - nCk(m + 2 * j, j - 1)) % MOD;\n\t\t\tans += nCk(n + m + 2 * k, n + 2 * i) % MOD * a % MOD * b % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\n\t\twhile (ans < 0)\n\t\t\tans += MOD;\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic long[] fact;\n\tstatic long[] inv_fact;\n\n\t// 1~n?????°?????????k????????????????????°\n\tstatic long nCk(int n, int k) {\n\t\tif (n < k)\n\t\t\treturn 0;\n\t\telse {\n\t\t\treturn fact[n] % MOD * inv(fact[n - k], MOD) % MOD * inv(fact[k], MOD) % MOD;\n\t\t}\n\t}\n\n\tstatic long inv(long a, long mod) {\n\t\ta = a % mod;\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\n\t\twhile (b > 1) {\n\t\t\tlong c = b / a;\n\t\t\tb = b % a;\n\t\t\tq = q - p * c;\n\t\t\tlong d = b;\n\t\t\tb = a;\n\t\t\ta = d;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d;\n\t\t}\n\t\twhile (q < 0)\n\t\t\tq += mod;\n\t\treturn q % MOD;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    // static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        mymath.setfacts(Math.Max(n, m) + k * 2 + 1);\n        for (int i = 0; i <= k; i++)\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic long n;//nCkにおけるnの最大値\nstatic long p = 1000000007;\nstatic long[] factorials;//i!(mod p)を先にメモ\nstatic long[] factorialRs;//i!^-1(mod p), pは素数\n\n\tstatic void Main()\n\t{\n    string[] input = Console.ReadLine().Split(' ');\n    long nn = long.Parse(input[0]);\n    long m = long.Parse(input[1]);\n    long k = long.Parse(input[2]);\n    n = nn+m+2*k;\n  \n    FactorialReady();\n    //ここからCombを使える\n\n    long answer = 0;\n    long answerMemo = 0;\n    for(int i = 0; i <= k; i++)\n    {\n      answerMemo = 1;\n      answerMemo *= CatalanNumber(i,m+i,p);\n      answerMemo %= p;\n      answerMemo *= CatalanNumber(k-i,nn+k-i,p);\n      answerMemo %= p;\n      answerMemo *= leftRightMove(m+2*i,2*(k-i)+nn,p);\n      answerMemo %= p;\n\n      answer += answerMemo;\n      answer %= p;\n    }\n\n    Console.WriteLine(answer);\n    \n\t}\n\n  static long leftRightMove(long l, long r, long mod)\n  {//左にl回、右にr回移動する方法の個数を返す。(mod p, pは素数)\n    long answer = factorials[l+r];\n    answer %= mod;\n    answer *= factorialRs[l];\n    answer %= mod;\n    answer *= factorialRs[r];\n    answer %= mod;\n    return answer;\n  }\n\n  static long CatalanNumber(long l, long r, long mod)\n  {//カタラン数(mod p, pは素数)を返す。すなわち、左にl回、右にr回移動するが、位置が1度も負にはならない方法の個数。\n    if(l > r) return 0; \n  \n    long answer = leftRightMove(l,r,mod);\n    if(l == 0) return answer;\n\n    long answerSub = leftRightMove(l-1,r+1,mod);\n\n    answer -= answerSub;\n    answer %= mod;\n    if(answer < 0) answer += mod;\n    return answer;\n  }\n\n  static void FactorialReady()\n  {\n    factorials = new long[n+1];\n    factorialRs = new long[n+1];\n    \n    factorials[0] = 1;\n    factorialRs[n] = DivideModFactorial(n,p);\n    for(long i = 1; i <= n; i++)\n    {\n      factorials[i] = (factorials[i-1]*i)%p;//i!(mod p)\n      factorialRs[n-i] = (factorialRs[n+1-i]*(n+1-i))%p;//逆元も先にメモ\n    }\n  }\n\n  static long MathPow(long x, long a)//戻り値はx^a\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x;\n  \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n      }\n    memo *= memo;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideModReverse(long x, long p)//戻り値はx^-1(mod p), pは素数\n  {\n    long answer = DivideMod(x, p-2, p);\n    return answer;\n  }\n\n  static long ModFactorial(long x, long p)//戻り値はx!(mod p)\n  {\n    long answer = 1;\n    for(int i = 2; i <= x; i++)\n    {\n      answer *= i;\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long DivideModFactorial(long x, long p)//戻り値はx!^-1(mod p), pは素数\n  {\n    long answer = 1;\n    for(long i = x; i >= 2; i--)\n    {\n      answer *= DivideModReverse(i, p);\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long Comb(long a, long b, long p)//戻り値は組み合わせC(a,b)のmod p\n  {\n    if(a-b < 0) return 0;//引数a-bが負なら0を返す\n    long answer = 1;\n    answer *= factorials[a];\n    answer %= p;\n    answer *= factorialRs[a-b];\n    answer %= p;\n    answer *= factorialRs[b];\n    answer %= p;\n    return answer;\n  }\n  \n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    // static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        mymath.setfacts(Math.Max(n, m) + k * 2 + 1);\n        for (int i = 0; i <= k; i++)\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        invs = new long[n + 1];\n        facts[0] = invs[0] = 1;\n        for (int i = 0; i < n; i++) {\n            facts[i + 1] = facts[i] * (i + 1) % Mod;\n            invs[i + 1] = inv(facts[i + 1]);\n        }\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts.Length > n)\n            return facts[n] * invs[r] * invs[n - r];\n\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    // static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        mymath.setfacts(Math.Max(n, m) + k * 2 + 1);\n        for (int i = 0; i <= k; i++)\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        invs = new long[n + 1];\n        facts[0] = invs[0] = 1;\n        for (int i = 0; i < n; i++) {\n            facts[i + 1] = facts[i] * (i + 1) % Mod;\n            invs[i + 1] = inv(facts[i + 1]);\n        }\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts.Length > n)\n            return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        for (int i = 0; i <= k; i++)\n        {\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    // static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static long[] getnextcomb(long[] a) {\n        var ret = new long[a.Length + 1];\n        ret[0] = ret[a.Length] = 1;\n        for (int i = 1; i < a.Length; i++) ret[i] = (a[i - 1] + a[i]) % Mod;\n        return ret;\n    }\n    public static long[] getprevcomb(long[] a) {\n        var ret = new long[a.Length - 1];\n        ret[0] = 1;\n        for (int i = 1; i < a.Length - 1; i++) ret[i] = (a[i + 1] - ret[i - 1] + Mod) % Mod;\n        return ret;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        for (int i = 0; i <= k; i++)\n        {\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static long[] getnextcomb(long[] a) {\n        var ret = new long[a.Length + 1];\n        ret[0] = ret[a.Length] = 1;\n        for (int i = 1; i < a.Length; i++) ret[i] = (a[i - 1] + a[i]) % Mod;\n        return ret;\n    }\n    public static long[] getprevcomb(long[] a) {\n        var ret = new long[a.Length - 1];\n        ret[0] = 1;\n        for (int i = 1; i < a.Length - 1; i++) ret[i] = (a[i + 1] - ret[i - 1] + Mod) % Mod;\n        return ret;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const double eps = 1e-11;\n    // static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        int n, m, k;\n        sc.Multi(out n, out m, out k);\n        long ans = 0;\n        var cb = mymath.getcomb(n + m + k * 2);\n        for (int i = 0; i <= k; i++)\n        {\n            ans = (ans + (mymath.comb(n + i * 2, i) - mymath.comb(n + i * 2, i - 1)) * (mymath.comb(m + (k - i) * 2, k - i) - mymath.comb(m + (k - i) * 2, k - i - 1)) % M * cb[n + i * 2] % M + M) % M;\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    static T Max<T>(params T[] a) { return a.Max(); }\n    static T Min<T>(params T[] a) { return a.Min(); }\n    static void DBG(string a) { Console.WriteLine(a); }\n    // static void DBG<T>(IEnumerable<T> a) { DBG(string.Join(\" \", a)); }\n    // static void DBG(params object[] a) { DBG(string.Join(\" \", a)); }\n    static void Prt(string a) { sw.WriteLine(a); }\n    // static void Prt<T>(IEnumerable<T> a) { Prt(string.Join(\" \", a)); }\n    // static void Prt(params object[] a) { Prt(string.Join(\" \", a)); }\n\n    // for AOJ\n    static string Join<T>(string sep, IEnumerable<T> a) { return string.Join(sep, a.Select(x => x.ToString()).ToArray()); }\n    static void DBG<T>(IEnumerable<T> a) { DBG(Join(\" \", a)); }\n    static void DBG(params object[] a) { DBG(Join(\" \", a)); }\n    static void Prt<T>(IEnumerable<T> a) { Prt(Join(\" \", a)); }\n    static void Prt(params object[] a) { Prt(Join(\" \", a)); }\n}\nstatic class ex\n{\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a)\n    {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) { return Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile(); }\n    public static Func<T, T> Lambda(Unary op) { return Expression.Lambda<Func<T, T>>(op(x), x).Compile(); }\n}\n\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public double Double { get { return double.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    bool eq<T, U>() { return typeof(T).Equals(typeof(U)); }\n    T ct<T, U>(U a) { return (T)Convert.ChangeType(a, typeof(T)); }\n    T cv<T>(string s) { return eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                             : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                             : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                             : eq<T, char>()   ? ct<T, char>(s[0])\n                                               : ct<T, string>(s); }\n    public void Multi<T>(out T a) { a = cv<T>(Str); }\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n    public void Multi<T, U, V, W, X, Y, Z>(out T a, out U b, out V c, out W d, out X e, out Y f, out Z g)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]);  g = cv<Z>(ar[6]);}\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) { return pow(a, Mod - 2); }\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) { return a / gcd(a, b) * b; }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static long[] getnextcomb(long[] a) {\n        var ret = new long[a.Length + 1];\n        ret[0] = ret[a.Length] = 1;\n        for (int i = 1; i < a.Length; i++) ret[i] = (a[i - 1] + a[i]) % Mod;\n        return ret;\n    }\n    public static long[] getprevcomb(long[] a) {\n        var ret = new long[a.Length - 1];\n        ret[0] = 1;\n        for (int i = 1; i < a.Length - 1; i++) ret[i] = (a[i + 1] - ret[i - 1] + Mod) % Mod;\n        return ret;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var k = sc.Integer();\n            var table = new ModTable(n + m + 2 * k + 50);\n            ModInteger ans = 0;\n            for (int x = 0; x <= k; x++)\n            {\n                ModInteger add = 1;\n                {\n                    var i = x;\n                    var a = table.Combination(n + 2 * i, i) - table.Combination(n + 2 * i, i - 1);\n                    add *= a;\n\n                }\n                {\n                    var i = k - x;\n                    var a = table.Combination(m + 2 * i, i) - table.Combination(m + 2 * i, i - 1);\n                    add *= a;\n\n                }\n                {\n                    add *= table.Combination(n + m + 2 * k, n + 2 * x);\n                }\n                ans += add;\n\n            }\n            IO.Printer.Out.WriteLine(ans);\n\n\n\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger(n); }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n#region Inverse\npublic partial struct ModInteger\n{\n    static public ModInteger Inverse(ModInteger v)\n    {\n        long p, q;\n        ExGCD(v.num, Mod, out p, out q);\n        return new ModInteger(p % Mod + Mod);\n    }\n    static public long ExGCD(long a, long b, out long x, out long y)\n    {\n        var u = new long[] { a, 1, 0 };\n        var v = new long[] { b, 0, 1 };\n        while (v[0] != 0)\n        {\n            var t = u[0] / v[0];\n            for (int i = 0; i < 3; i++)\n            {\n                var tmp = u[i] - t * v[i];\n                u[i] = v[i];\n                v[i] = tmp;\n            }\n        }\n        x = u[1];\n        y = u[2];\n        if (u[0] > 0)\n            return u[0];\n        for (int i = 0; i < 3; i++)\n            u[i] = -u[i];\n        return u[0];\n\n    }\n}\n#endregion\n#region ModTable\npublic class ModTable\n{\n    public ModInteger[] perm, inv;\n    public ModTable(int n)\n    {\n        perm = new ModInteger[n + 1];\n        inv = new ModInteger[n + 1];\n        perm[0] = 1;\n        for (int i = 1; i <= n; i++)\n            perm[i] = perm[i - 1] * i;\n        inv[n] = ModInteger.Inverse(perm[n]);\n        for (int i = n - 1; i >= 0; i--)\n            inv[i] = inv[i + 1] * (i + 1);\n        inv[0] = inv[1];\n    }\n    public ModInteger Inverse(int k) { return inv[k]; }\n    public ModInteger Permutation(int n, int k)\n    {\n        if (n < 0 || n >= perm.Length)\n            return 0;\n        if (k < 0 || k >= n)\n            return 0;\n        return perm[n] * inv[n - k];\n    }\n    public ModInteger Combination(int n, int r)\n    {\n        if (n < 0 || n >= perm.Length || r < 0 || r > n) return 0;\n        return perm[n] * inv[n - r] * inv[r];\n    }\n    public ModInteger RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return Combination(n + k - 1, k);\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "MOD = 1_000_000_007\n\n$fact = [1]\n(1..220000).each do |i|\n  $fact << $fact[-1] * i % MOD\nend\n\ndef exp(n, k)\n  x = 1\n  while k > 0\n    x = x * n % MOD if k & 1 == 1\n    n = n * n % MOD\n    k >>= 1\n  end\n  x\nend\n\n$inv = (0..220000).map {|i| exp($fact[i], MOD - 2) }\n\ndef comb(n, k)\n  ($fact[n] * $inv[k] % MOD) * $inv[n-k] % MOD\nend\n\nn, m, k = gets.split.map(&:to_i)\n\nanswer = 0\n(0..k).each do |ke|\n  east  = ke == 0 ? 1 : (comb(n + ke * 2, ke) - comb(n + ke * 2, ke - 1)) % MOD\n  kn = k - ke\n  north = kn == 0 ? 1 : (comb(m + kn * 2, kn) - comb(m + kn * 2, kn - 1)) % MOD\n  answer = (answer + east * north * comb(n + m + k * 2, n + ke * 2)) % MOD\nend\np answer\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\ncms = 10**6\ncm = [0] * cms\n\ndef comb_init():\n    cm[0] = 1\n    for i in range(1, cms):\n        cm[i] = cm[i-1] * i % mod\n\ndef comb(a, b):\n    return (cm[a] * inv(cm[a-b]) % mod) * inv(cm[b]) % mod\n\n\ndef main():\n    rr = []\n\n    def f(n,m,k):\n        comb_init()\n        r = 0\n        for i in range(k+1):\n            j = k - i\n            mt = comb(n+m+k*2, n+i*2)\n            lk = rk = 1\n            if i > 0:\n                lk = (comb(n+i*2, i) - comb(n+i*2, i-1)) % mod\n            if j > 0:\n                rk = (comb(m+j*2, j) - comb(m+j*2, j-1)) % mod\n            r += mt * lk * rk % mod\n            r %= mod\n\n        return r\n\n    while 1:\n        n,m,k = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m,k))\n        break\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    MOD = 10**9 + 7\n    N, M, K = map(int, readline().split())\n    MOD = 10**9 + 7\n\n    L = N+M+2*K\n\n    fact = [1]*(L+1)\n    rfact = [1]*(L+1)\n    r = 1\n    for i in range(1, L+1):\n        fact[i] = r = r * i % MOD\n    rfact[L] = r = pow(fact[L], MOD-2, MOD)\n    for i in range(L, 0, -1):\n        rfact[i-1] = r = r * i % MOD\n\n    def C(n, k):\n        return fact[n] * rfact[n-k] * rfact[k] % MOD\n    def F(n, k):\n        return (fact[n+k] * (n-k+1) % MOD) * (rfact[k] * rfact[n+1] % MOD) % MOD\n    ans = 0\n    for a in range(K+1):\n        b = K-a\n        ans += C(N+2*a+M+2*b, N+2*a) * F(N+a, a) * F(M+b, b) % MOD\n    ans %= MOD\n    write(\"%d\\n\" % ans)\nsolve()\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::i32::{MAX};\nuse std::cmp::{Ordering, min, max };\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut, SubAssign, Range};\nuse std::collections::{BTreeMap, VecDeque, BinaryHeap, BTreeSet, HashMap};\nuse std::fmt::{Display, Formatter, Error};\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_lines{\n    ($count: expr; $delimiter: expr; $ty: ty) => {{\n        let line_count = $count;\n        let mut vec: Vec<Vec<$ty>> = Vec::with_capacity(line_count);\n        for _ in 0 .. line_count {\n            vec.push(read_line!($delimiter; $ty));\n        }\n        vec\n    }};\n    ($count: expr; $ty: ty) => {{\n        let line_count = $count;\n        let mut vec: Vec<$ty> = Vec::with_capacity(line_count);\n        for _ in 0 .. line_count {\n            vec.push(read_value!());\n        }\n        vec\n    }}\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nfn main(){\n    const MOD: i64 = 1000000007i64;\n    let_all!(n: usize, m: usize, k: usize);\n    let mut factorial = vec![1i64; n + m + k * 2+ 1];\n    let mut inv = vec![1i64; n + m + k * 2 + 1];\n    let mut inv_factorial = vec![1i64; n + m + k * 2 + 1];\n    for i in 2.. factorial.len() {\n        factorial[i] = i as i64 * factorial[i - 1] as i64 % MOD;\n        inv[i] = (MOD - MOD / i as i64) * inv[(MOD % i as i64) as usize] % MOD;\n        inv_factorial[i] = inv[i] * inv_factorial[i - 1] % MOD;\n    }\n    let factorial = factorial; let inv_factorial = inv_factorial;\n    let mut result = 0i64;\n    //show(&inv_factorial);\n    for i in 0 .. k + 1 {\n        let j = k - i;\n        let for_vertical = if i == 0 {1i64} else {(factorial[n + i * 2] * inv_factorial[i] % MOD * inv_factorial[n + i] % MOD - factorial[n + i * 2] * inv_factorial[i - 1] % MOD * inv_factorial[n + i + 1] % MOD) % MOD};\n        let for_horizontal = if j == 0 {1i64} else {(factorial[m + j * 2] * inv_factorial[j] % MOD * inv_factorial[m + j] % MOD - factorial[m + j * 2] * inv_factorial[j - 1] % MOD * inv_factorial[m + j + 1] % MOD) % MOD};\n        result += for_vertical * for_horizontal % MOD * factorial[n + m + k * 2] % MOD * inv_factorial[n + i * 2] % MOD * inv_factorial[m + j * 2] % MOD;\n        result %= MOD;\n    }\n    println!(\"{}\", (result + MOD) % MOD);\n}\n"
  }
]