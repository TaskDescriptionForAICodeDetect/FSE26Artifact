[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 100005\n#define MOD 1000000007\n\nchar S[MAX_LEN];\nint N, M;\nint operations[MAX_LEN][2];\n\nvoid sortSubstring(int l, int r) {\n    int len = r - l + 1;\n    char* substring = malloc(len * sizeof(char));\n    strncpy(substring, S + l, len);\n    \n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            if (substring[i] > substring[j]) {\n                char temp = substring[i];\n                substring[i] = substring[j];\n                substring[j] = temp;\n            }\n        }\n    }\n    \n    strncpy(S + l, substring, len);\n    free(substring);\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%s\", S);\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &operations[i][0], &operations[i][1]);\n        operations[i][0]--;\n        operations[i][1]--;\n    }\n    \n    for (int i = 0; i < M; i++) {\n        sortSubstring(operations[i][0], operations[i][1]);\n    }\n    \n    printf(\"%s\\n\", S);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int l, r;\n} Operation;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    char S[N + 1];\n    scanf(\"%s\", S);\n    Operation ops[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &ops[i].l, &ops[i].r);\n        ops[i].l--; // Convert to 0-based index\n        ops[i].r--;\n    }\n\n    // Process operations to find the effective intervals\n    int intervals[M][2];\n    int intervalCount = 0;\n    for (int i = 0; i < M; i++) {\n        if (i == 0) {\n            intervals[intervalCount][0] = ops[i].l;\n            intervals[intervalCount][1] = ops[i].r;\n            intervalCount++;\n        } else {\n            if (ops[i].l <= intervals[intervalCount - 1][1]) {\n                intervals[intervalCount - 1][1] = ops[i].r > intervals[intervalCount - 1][1] ? ops[i].r : intervals[intervalCount - 1][1];\n            } else {\n                intervals[intervalCount][0] = ops[i].l;\n                intervals[intervalCount][1] = ops[i].r;\n                intervalCount++;\n            }\n        }\n    }\n\n    // Merge the intervals\n    int mergedIntervals[M][2];\n    int mergedCount = 0;\n    if (intervalCount > 0) {\n        mergedIntervals[mergedCount][0] = intervals[0][0];\n        mergedIntervals[mergedCount][1] = intervals[0][1];\n        mergedCount++;\n        for (int i = 1; i < intervalCount; i++) {\n            if (intervals[i][0] <= mergedIntervals[mergedCount - 1][1]) {\n                mergedIntervals[mergedCount - 1][1] = intervals[i][1] > mergedIntervals[mergedCount - 1][1] ? intervals[i][1] : mergedIntervals[mergedCount - 1][1];\n            } else {\n                mergedIntervals[mergedCount][0] = intervals[i][0];\n                mergedIntervals[mergedCount][1] = intervals[i][1];\n                mergedCount++;\n            }\n        }\n    }\n\n    // Calculate the number of 1s in the merged intervals\n    int totalOnes = 0;\n    for (int i = 0; i < mergedCount; i++) {\n        for (int j = mergedIntervals[i][0]; j <= mergedIntervals[i][1]; j++) {\n            if (S[j] == '1') totalOnes++;\n        }\n    }\n\n    // Calculate the number of distinct strings\n    int result = 1;\n    int n = mergedCount > 0 ? (mergedIntervals[mergedCount - 1][1] - mergedIntervals[0][0] + 1) : 0;\n    int k = totalOnes;\n    if (n == 0 || k == 0 || k == n) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    // Precompute factorial, inverse factorial modulo MOD\n    int max_n = N;\n    long long factorial[max_n + 1];\n    long long invFact[max_n + 1];\n    factorial[0] = 1;\n    for (int i = 1; i <= max_n; i++) {\n        factorial[i] = (factorial[i - 1] * i) % MOD;\n    }\n    invFact[max_n] = 1;\n    long long base = factorial[max_n];\n    long long power = MOD - 2;\n    while (power > 0) {\n        if (power % 2 == 1) {\n            invFact[max_n] = (invFact[max_n] * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        power /= 2;\n    }\n    for (int i = max_n - 1; i >= 0; i--) {\n        invFact[i] = (invFact[i + 1] * (i + 1)) % MOD;\n    }\n\n    result = (factorial[n] * invFact[k]) % MOD;\n    result = (result * invFact[n - k]) % MOD;\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<pair<int, int>> ops(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> ops[i].first >> ops[i].second;\n        --ops[i].first;\n        --ops[i].second;\n    }\n\n    vector<int> parent(N);\n    iota(parent.begin(), parent.end(), 0);\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[y] = x;\n    };\n\n    int last_l = 0, last_r = -1;\n    for (auto &op : ops) {\n        int l = op.first, r = op.second;\n        if (l <= last_r) {\n            l = min(l, last_l);\n            r = max(r, last_r);\n        }\n        for (int i = l; i <= r; ++i) {\n            unite(l, i);\n        }\n        last_l = l;\n        last_r = r;\n    }\n\n    unordered_map<int, pair<int, int>> cnt;\n    for (int i = 0; i < N; ++i) {\n        int root = find(i);\n        if (S[i] == '0') cnt[root].first++;\n        else cnt[root].second++;\n    }\n\n    vector<int> fact(N + 1), inv_fact(N + 1);\n    fact[0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        fact[i] = 1LL * fact[i - 1] * i % MOD;\n    }\n    inv_fact[N] = 1;\n    for (int i = N - 1; i >= 0; --i) {\n        inv_fact[i] = 1LL * inv_fact[i + 1] * (i + 1) % MOD;\n    }\n\n    auto comb = [&](int n, int k) {\n        if (k < 0 || k > n) return 0LL;\n        return 1LL * fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;\n    };\n\n    long long res = 1;\n    for (auto &p : cnt) {\n        int a = p.second.first;\n        int b = p.second.second;\n        res = res * comb(a + b, a) % MOD;\n    }\n\n    cout << res << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        String S = scanner.next();\n        int[] l = new int[M];\n        int[] r = new int[M];\n        for (int i = 0; i < M; i++) {\n            l[i] = scanner.nextInt() - 1;\n            r[i] = scanner.nextInt() - 1;\n        }\n\n        int[] parent = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n\n        for (int i = 0; i < M; i++) {\n            int currentL = l[i];\n            int currentR = r[i];\n            if (i > 0 && l[i - 1] <= currentL && currentR <= r[i - 1]) {\n                continue;\n            }\n            int start = currentL;\n            if (i > 0) {\n                start = Math.max(start, r[i - 1] + 1);\n            }\n            for (int j = start; j <= currentR; j++) {\n                union(parent, currentL, j);\n            }\n        }\n\n        int[] count0 = new int[N];\n        int[] count1 = new int[N];\n        for (int i = 0; i < N; i++) {\n            int root = find(parent, i);\n            if (S.charAt(i) == '0') {\n                count0[root]++;\n            } else {\n                count1[root]++;\n            }\n        }\n\n        long result = 1;\n        for (int i = 0; i < N; i++) {\n            if (parent[i] == i) {\n                int total = count0[i] + count1[i];\n                long ways = 0;\n                for (int k = 0; k <= Math.min(count0[i], count1[i]); k++) {\n                    ways = (ways + comb(total, count0[i], k)) % MOD;\n                }\n                result = (result * ways) % MOD;\n            }\n        }\n\n        System.out.println(result);\n    }\n\n    static int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int[] parent, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n\n    static long comb(int n, int a, int k) {\n        long[][] dp = new long[a + 1][a + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= a; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (j == 0 || j == i) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\n                }\n            }\n        }\n        return dp[a][k];\n    }\n}",
    "timestamp": "2025-08-05 23:29:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int countDistinctStrings(String S, int[][] operations) {\n        int N = S.length();\n        Set<String> distinctStrings = new HashSet<>();\n        distinctStrings.add(S);\n        \n        int lastRight = 0;\n        for (int[] op : operations) {\n            int l = op[0] - 1;\n            int r = op[1] - 1;\n            \n            if (l < lastRight) continue;\n            \n            char[] chars = S.toCharArray();\n            char[] subarray = Arrays.copyOfRange(chars, l, r + 1);\n            Arrays.sort(subarray);\n            \n            do {\n                System.arraycopy(subarray, 0, chars, l, r - l + 1);\n                distinctStrings.add(new String(chars));\n            } while (nextPermutation(subarray));\n            \n            S = new String(chars);\n            lastRight = r;\n        }\n        \n        return distinctStrings.size() % 1000000007;\n    }\n    \n    private static boolean nextPermutation(char[] arr) {\n        int i = arr.length - 2;\n        while (i >= 0 && arr[i] >= arr[i + 1]) {\n            i--;\n        }\n        \n        if (i < 0) return false;\n        \n        int j = arr.length - 1;\n        while (j > i && arr[j] <= arr[i]) {\n            j--;\n        }\n        \n        swap(arr, i, j);\n        reverse(arr, i + 1, arr.length - 1);\n        return true;\n    }\n    \n    private static void swap(char[] arr, int i, int j) {\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    private static void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            swap(arr, start++, end--);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:29:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberOfDistinctValues(string s, vector<vector<int>>& ops) {\n        int n = s.length();\n        set<string> distinct;\n        \n        // Pre-process sorted substrings\n        vector<vector<string>> sorted_subarrays(n, vector<string>(n));\n        for (int i = 0; i < n; i++) {\n            string curr = s.substr(i);\n            for (int j = i; j < n; j++) {\n                sorted_subarrays[i][j - i] = curr.substr(0, j - i + 1);\n                sort(sorted_subarrays[i][j - i].begin(), sorted_subarrays[i][j - i].end());\n            }\n        }\n        \n        // Sort original string initially\n        distinct.insert(s);\n        \n        // Process each operation\n        int last_r = 0;\n        for (auto& op : ops) {\n            int l = op[0] - 1, r = op[1] - 1;\n            \n            // Only process if operation range is non-decreasing\n            if (l >= last_r) {\n                string curr = s;\n                string substring = curr.substr(l, r - l + 1);\n                sort(substring.begin(), substring.end());\n                curr.replace(l, r - l + 1, substring);\n                distinct.insert(curr);\n                s = curr;\n                last_r = r;\n            }\n        }\n        \n        return distinct.size() % 1000000007;\n    }\n};",
    "timestamp": "2025-08-05 23:29:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def distinct_values(S, operations):\n    MOD = 1000000007\n    n = len(S)\n    \n    prefix_zeros = [0] * (n + 1)\n    prefix_ones = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_zeros[i + 1] = prefix_zeros[i]\n        prefix_ones[i + 1] = prefix_ones[i]\n        if S[i] == '0':\n            prefix_zeros[i + 1] += 1\n        else:\n            prefix_ones[i + 1] += 1\n    \n    result_values = 1\n    \n    for l, r in operations:\n        zeros_in_range = prefix_zeros[r] - prefix_zeros[l - 1]\n        ones_in_range = prefix_ones[r] - prefix_ones[l - 1]\n        distinct_in_current_range = pow(2, zeros_in_range + ones_in_range, MOD)\n        result_values = (result_values * distinct_in_current_range) % MOD\n    \n    return result_values\n\n# Example of usage\nS = \"1001\"\noperations = [(1, 3), (2, 4)]\nprint(distinct_values(S, operations))",
    "timestamp": "2025-08-13 15:28:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DistinctBinaryStrings {\n    private static final int MOD = 1000000007;\n\n    public static int countDistinctValues(String S, int M, int[] l, int[] r) {\n        int n = S.length();\n        boolean[] visited = new boolean[n];\n        \n        // Mark the positions covered by the operations\n        for (int i = 0; i < M; i++) {\n            for (int j = l[i]; j <= r[i]; j++) {\n                visited[j - 1] = true;\n            }\n        }\n\n        // Count contiguous segments that can be independently permuted\n        int count = 0;\n        boolean inSegment = false;\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) {\n                if (!inSegment) {\n                    count++;\n                    inSegment = true;\n                }\n            } else {\n                inSegment = false;\n            }\n        }\n\n        // Return the number of distinct permutations modulo MOD\n        return (int) Math.pow(2, count) % MOD;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read input\n        String S = scanner.next();\n        int M = scanner.nextInt();\n        int[] l = new int[M];\n        int[] r = new int[M];\n        \n        for (int i = 0; i < M; i++) {\n            l[i] = scanner.nextInt();\n            r[i] = scanner.nextInt();\n        }\n        \n        // Calculate and print the result\n        int result = countDistinctValues(S, M, l, r);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:28:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint factorial(int n, int mod) {\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result = (result * i) % mod;\n    }\n    return (int)result;\n}\n\nint count_distinct_values(char* S, int* L, int* R, int N, int M) {\n    int distinct_count = 0;\n    int factor = factorial(N, MOD);\n    \n    for (int i = 0; i < M; ++i) {\n        int l = L[i] - 1;\n        int r = R[i] - 1;\n        \n        int count0 = 0, count1 = 0;\n        \n        for (int j = l; j <= r; ++j) {\n            if (S[j] == '0') count0++;\n            else count1++;\n        }\n        \n        long long perm_count = factorial(count0 + count1, MOD);\n        long long inv_count0 = factorial(count0, MOD);\n        long long inv_count1 = factorial(count1, MOD);\n        \n        perm_count = perm_count * inv_count0 % MOD;\n        perm_count = perm_count * inv_count1 % MOD;\n        \n        distinct_count = (distinct_count + perm_count) % MOD;\n    }\n    \n    return distinct_count;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    char S[N + 1];\n    scanf(\"%s\", S);\n    \n    int* L = (int*)malloc(M * sizeof(int));\n    int* R = (int*)malloc(M * sizeof(int));\n    \n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &L[i], &R[i]);\n    }\n    \n    int result = count_distinct_values(S, L, R, N, M);\n    printf(\"%d\\n\", result);\n\n    free(L);\n    free(R);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:28:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nconst int MOD = 1000000007;\n\nusing namespace std;\n\n// Function to calculate factorial modulo MOD\nlong long factorial(int n) {\n    long long res = 1;\n    for (int i = 2; i <= n; ++i) {\n        res = (res * i) % MOD;\n    }\n    return res;\n}\n\n// Function to calculate how many distinct permutations can be formed in a binary substring\nlong long distinctPermutations(int zeros, int ones) {\n    long long total = zeros + ones;\n    return (factorial(total) * modInverse(factorial(zeros), MOD) % MOD) * modInverse(factorial(ones), MOD) % MOD;\n}\n\n// Function to calculate modular inverse using Fermat's Little Theorem\nlong long modInverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<int> l(M), r(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> l[i] >> r[i];\n    }\n\n    long long result = 1;\n\n    for (int i = 0; i < M; ++i) {\n        int zeroCount = 0, oneCount = 0;\n        for (int j = l[i] - 1; j < r[i]; ++j) {\n            if (S[j] == '0') ++zeroCount;\n            else ++oneCount;\n        }\n        result = (result * distinctPermutations(zeroCount, oneCount)) % MOD;\n    }\n\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:28:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def countDistinctStrings(self, S: str, M: int) -> int:\n        MOD = 10**9 + 7\n        N = len(S)\n        \n        # Dynamic programming to track distinct strings\n        distinct_strings = set([S])\n        last_right = 0\n        \n        for i in range(M):\n            l, r = map(int, input().split())\n            l -= 1  # convert to 0-based indexing\n            r -= 1\n            \n            # Check if operation is valid (non-decreasing sequence)\n            if l < last_right:\n                continue\n            last_right = r\n            \n            # Generate new strings by sorting substring\n            new_distinct_strings = set()\n            for s in distinct_strings:\n                # Convert to list for manipulation\n                chars = list(s)\n                \n                # Extract and sort substring\n                substring = chars[l:r+1]\n                substring.sort()\n                \n                # Reconstruct string\n                chars[l:r+1] = substring\n                new_s = ''.join(chars)\n                new_distinct_strings.add(new_s)\n            \n            # Update distinct strings\n            distinct_strings.update(new_distinct_strings)\n        \n        return len(distinct_strings) % MOD",
    "timestamp": "2025-08-13 15:28:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    N, M = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n    parent = [i for i in range(N + 2)]  # 1-based to N\n    \n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_v] = root_u\n    \n    l_prev = 0\n    r_prev = 0\n    for _ in range(M):\n        l, r = map(int, sys.stdin.readline().split())\n        if l <= r_prev:\n            l = min(l, l_prev)\n            r = max(r, r_prev)\n        # Merge the intervals\n        # The key is to union all positions from l to r with l\n        # But to optimize, we can union in a way similar to path compression\n        current = l\n        while current <= r:\n            if find(current) != find(l):\n                union(l, current)\n                current += 1\n            else:\n                # Jump to the next unprocessed position\n                next_pos = find(current) + 1\n                if next_pos > r:\n                    break\n                union(l, next_pos)\n                current = next_pos + 1\n        l_prev, r_prev = l, r\n    \n    # Now count the number of connected components\n    roots = set()\n    for i in range(1, N+1):\n        roots.add(find(i))\n    k = len(roots)\n    # The answer is 2^k mod MOD\n    ans = pow(2, k, MOD)\n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 15:28:45"
  }
]