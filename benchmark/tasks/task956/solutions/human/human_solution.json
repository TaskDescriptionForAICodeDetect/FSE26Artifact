[
  {
    "language": "Crystal",
    "code": "MOD = 1000000007\nn, m = read_line.split.map(&.to_i)\ns = read_line.chars\nright = Array.new(n) { |i| i }\nm.times do\n  l, r = read_line.split.map(&.to_i)\n  right[l - 1] = {right[l - 1], r - 1}.max\nend\ndp = Array.new(n + 1) { Array.new(n + 1, 0) }\ndp[0][0] = 1\nprev = -1\nc0 = 0\nc1 = 0\nn.times do |i|\n  (prev + 1).upto(right[i]) do |j|\n    if s[j] == '0'\n      c0 += 1\n    else\n      c1 += 1\n    end\n  end\n  prev = {prev, right[i]}.max\n  0.upto(i) do |j|\n    dp[i + 1][j] += dp[i][j]\n    dp[i + 1][j] -= MOD if dp[i + 1][j] >= MOD\n    dp[i + 1][j + 1] += dp[i][j]\n    dp[i + 1][j + 1] -= MOD if dp[i + 1][j + 1] >= MOD\n  end\n  0.upto(i - c1) do |j|\n    dp[i + 1][j] = 0\n  end\n  (c0 + 1).upto(n) do |j|\n    dp[i + 1][j] = 0\n  end\nend\nputs dp[n].map { |v| v.to_i64 }.sum % MOD\n"
  },
  {
    "language": "Crystal",
    "code": "MOD = 1000000007i64\nn, m = read_line.split.map(&.to_i)\ns = [0] + read_line.chars.map { |c| c.to_i }\nright = Array.new(n + 1) { |i| i }\nm.times do\n  l, r = read_line.split.map(&.to_i)\n  right[l] = {right[l], r}.max\nend\nmax0 = Array.new(n + 1, 0)\nmax1 = Array.new(n + 1, 0)\nc0 = 0\nc1 = 0\n1.upto(n) do |i|\n  right[i] = {right[i], right[i - 1]}.max\n  (right[i - 1] + 1).upto(right[i]) do |r|\n    c0 += 1 - s[r]\n    c1 += s[r]\n  end\n  max0[i] = max0[i - 1]\n  if c0 > 0\n    max0[i] += 1\n    c0 -= 1\n  end\n  max1[i] = max1[i - 1]\n  if c1 > 0\n    max1[i] += 1\n    c1 -= 1\n  end\nend\ndp = Array.new(n + 1) { Array.new(n + 1, 0i64) }\ndp[0][0] = 1\nn.times do |i|\n  (i + 1).times do |j|\n    dp[i + 1][j] += dp[i][j]\n    dp[i + 1][j] %= MOD\n    dp[i + 1][j + 1] += dp[i][j]\n    dp[i + 1][j + 1] %= MOD\n  end\n  0.upto(i - max1[i + 1]) do |j|\n    dp[i + 1][j] = 0\n  end\n  (max0[i + 1] + 1).upto(i + 1) do |j|\n    dp[i + 1][j] = 0\n  end\nend\nputs dp[-1].sum % MOD\n"
  },
  {
    "language": "Fortran",
    "code": "program shuffling\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, m, i, j, k, l, r, x(0:3001) = 0, c(0:3001) = 0\n  character(3001) :: s\n  integer(8) :: dp(0:3001,0:3001) = 0_8\n  read(*,*) n, m\n  if (n <= 11) stop\n  read(*,*) s\n  s(n+1:n+1) = \"0\"\n  do i = 1, m\n    read(*,*) l, r\n    x(l) = max(x(l),r)\n  end do\n  do i = 1, n+1\n    x(i) = max(x(i-1),x(i),i)\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  dp(1,c(x(1))) = 1_8\n  do i = 1, n\n    k = c(x(i+1))-c(x(i))\n    dp(i+1,k) = mod(dp(i+1,k)+dp(i,0),md)\n    do j = 1, n\n      dp(i+1,k+j-1) = mod(dp(i+1,k+j-1)+dp(i,j),md)\n      if (x(i)-i >= j) dp(i+1,k+j) = mod(dp(i+1,k+j)+dp(i,j),md)\n    end do\n  end do\n  write(*,'(i0)') dp(n+1,0)\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "program shuffling\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, m, i, j, k, l, r, x(0:3001) = 0, c(0:3001) = 0\n  character(3001) :: s\n  integer(8) :: dp(0:3001,0:3001) = 0_8\n  read(*,*) n, m\n  read(*,*) s\n  s(n+1:n+1) = \"0\"\n  do i = 1, m\n    read(*,*) l, r\n    x(l) = max(x(l),r)\n  end do\n  do i = 1, n+1\n    x(i) = max(x(i-1),x(i),i)\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  dp(1,c(x(1))) = 1_8\n  do i = 1, n\n    k = c(x(i+1))-c(x(i))\n    dp(i+1,k) = mod(dp(i+1,k)+dp(i,0),md)\n    do j = 1, n\n      dp(i+1,k+j-1) = mod(dp(i+1,k+j-1)+dp(i,j),md)\n      if (x(i)-i >= j) dp(i+1,k+j) = mod(dp(i+1,k+j)+dp(i,j),md)\n    end do\n  end do\n  write(*,'(i0)') dp(n+1,0)\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "module modulo_util\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = 1_8\n    if (n == 0 .and. k == 0) return\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(mod(y,md)+md,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n  end\nend module modulo_util\nprogram shuffling\n  use modulo_util\n  implicit none\n  integer :: n, m, u = 0, ll, rr, i, j\n  integer, dimension(0:3000) :: l = 0, r = 0, c = 0\n  character(3000) :: s\n  integer(8) :: ans = 1_8\n  read(*,*) n, m\n  call init(n)\n  read(*,*) s\n  do i = 1, n\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  do i = 1, m\n    read(*,*) ll, rr\n    if (rr <= r(u)) cycle\n    u = u+1\n    l(u) = ll\n    r(u) = rr\n  end do\n  m = u\n  i = 1\n  do while (i <= m)\n    j = i\n    do while (j < m .and. l(j+1) <= r(j))\n      j = j+1\n    end do\n    ans = mod(ans*solve(l(i:j),r(i:j),1,0),md)\n    i = j+1\n  end do\n  write(*,'(i0)') ans\ncontains\n  recursive function solve(l,r,i,d) result(ret)\n    implicit none\n    integer, intent(in) :: l(:), r(:), i, d\n    integer :: j, x\n    integer(8) :: ret\n    if (i == 1) then\n      x = c(r(i))-c(l(i)-1)\n    else\n      x = d+c(r(i))-c(r(i-1))\n    end if\n    if (i == size(l)) then\n      ret = comb(r(i)-l(i)+1,x)\n      return\n    end if\n    ret = 0_8\n    do j = max(0,l(i+1)-r(i)+1-x), min(x,l(i+1)-r(i)+1)\n      ret = ret+mod(solve(l,r,i+1,j)*comb(l(i+1)-l(i),x-j),md)\n    end do\n    ret = mod(ret,md)\n  end\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "program shuffling\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, m, i, j, k, l, r, x(0:3001) = 0, c(0:3001) = 0\n  character(3001) :: s\n  integer(8) :: dp(0:3001,0:3001) = 0_8\n  read(*,*) n, m\n  read(*,*) s\n  s(n+1:n+1) = \"0\"\n  do i = 1, m\n    read(*,*) l, r\n    x(l) = max(x(l),r)\n  end do\n  do i = 1, n+1\n    x(i) = max(x(i-1),x(i),i)\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  dp(1,c(x(1))) = 1_8\n  do i = 1, n\n    k = c(x(i+1))-c(x(i))\n    dp(i+1,k) = mod(dp(i+1,k)+dp(i,0),md)\n    do j = 1, n-k\n      dp(i+1,k+j-1) = mod(dp(i+1,k+j-1)+dp(i,j),md)\n      if (x(i)-i >= j) dp(i+1,k+j) = mod(dp(i+1,k+j)+dp(i,j),md)\n    end do\n  end do\n  write(*,'(i0)') dp(n+1,0)\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "program shuffling\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, m, i, j, k, l, r, x(0:3001) = 0, c(0:3001) = 0\n  character(3001) :: s\n  integer(8) :: dp(0:3001,0:3001) = 0_8\n  read(*,*) n, m\n  if (n <= 10) stop\n  read(*,*) s\n  s(n+1:n+1) = \"0\"\n  do i = 1, m\n    read(*,*) l, r\n    x(l) = max(x(l),r)\n  end do\n  do i = 1, n+1\n    x(i) = max(x(i-1),x(i),i)\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  dp(1,c(x(1))) = 1_8\n  do i = 1, n\n    k = c(x(i+1))-c(x(i))\n    dp(i+1,k) = mod(dp(i+1,k)+dp(i,0),md)\n    do j = 1, n-k\n      dp(i+1,k+j-1) = mod(dp(i+1,k+j-1)+dp(i,j),md)\n      if (x(i)-i >= j) dp(i+1,k+j) = mod(dp(i+1,k+j)+dp(i,j),md)\n    end do\n  end do\n  write(*,'(i0)') dp(n+1,0)\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "module modulo_util\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = 1_8\n    if (n == 0 .and. k == 0) return\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(mod(y,md)+md,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n  end\nend module modulo_util\nprogram shuffling\n  use modulo_util\n  implicit none\n  integer :: n, m, u = 0, ll, rr, i, j\n  integer, dimension(0:3000) :: l = 0, r = 0, c = 0\n  character(3000) :: s\n  integer(8) :: ans = 1_8\n  read(*,*) n, m\n  call init(n)\n  read(*,*) s\n  do i = 1, n\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  do i = 1, m\n    read(*,*) ll, rr\n    if (rr <= r(u)) cycle\n    u = u+1\n    l(u) = ll\n    r(u) = rr\n  end do\n  i = 1\n  do while (i <= u)\n    j = i\n    do while (j < u .and. l(j+1) <= r(j))\n      j = j+1\n    end do\n    ans = mod(ans*solve(l(i:j),r(i:j),1,0),md)\n    i = j+1\n  end do\n  write(*,'(i0)') ans\ncontains\n  recursive function solve(l,r,i,d) result(ret)\n    implicit none\n    integer, intent(in) :: l(:), r(:), i, d\n    integer :: j, x\n    integer(8) :: ret\n    if (i == 1) then\n      x = c(r(i))-c(l(i)-1)\n    else\n      x = d+c(r(i))-c(r(i-1))\n    end if\n    if (i == size(l)) then\n      ret = comb(r(i)-l(i)+1,x)\n      return\n    end if\n    ret = 0_8\n    do j = max(0,x-(r(i+1)-l(i)+1)), min(x,r(i)-l(i+1)+1)\n      ret = ret+mod(solve(l,r,i+1,j)*comb(l(i+1)-l(i),x-j),md)\n    end do\n    ret = mod(ret,md)\n  end\nend program shuffling"
  },
  {
    "language": "Fortran",
    "code": "module modulo_util\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = 1_8\n    if (n == 0 .and. k == 0) return\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(mod(y,md)+md,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n  end\nend module modulo_util\nprogram shuffling\n  use modulo_util\n  implicit none\n  integer :: n, m, u = 0, ll, rr, i, j\n  integer, dimension(0:3000) :: l = 0, r = 0, c = 0\n  character(3000) :: s\n  integer(8) :: ans = 1_8\n  read(*,*) n, m\n  call init(n)\n  read(*,*) s\n  do i = 1, n\n    c(i) = c(i-1)+ichar(s(i:i))-48\n  end do\n  do i = 1, m\n    read(*,*) ll, rr\n    if (rr <= r(u)) cycle\n    u = u+1\n    l(u) = ll\n    r(u) = rr\n  end do\n  i = 1\n  do while (i <= u)\n    j = i\n    do while (j < u .and. l(j+1) <= r(j))\n      j = j+1\n    end do\n    ans = mod(ans*solve(l(i:j),r(i:j),1,0),md)\n    i = j+1\n  end do\n  write(*,'(i0)') ans+1_8\ncontains\n  recursive function solve(l,r,i,d) result(ret)\n    implicit none\n    integer, intent(in) :: l(:), r(:), i, d\n    integer :: j, x\n    integer(8) :: ret\n    if (i == 1) then\n      x = c(r(i))-c(l(i)-1)\n    else\n      x = d+c(r(i))-c(r(i-1))\n    end if\n    if (i == size(l)) then\n      ret = comb(r(i)-l(i)+1,x)\n      return\n    end if\n    ret = 0_8\n    do j = max(0,x-(r(i+1)-l(i)+1)), min(x,r(i)-l(i+1)+1)\n      ret = ret+mod(solve(l,r,i+1,j)*comb(l(i+1)-l(i),x-j),md)\n    end do\n    ret = mod(ret,md)\n  end\nend program shuffling"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=3010;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nchar str[N];\npair<int,int>p[N*2];\n#define l first\n#define r second\ninline bool cmp (const pair<int,int> &a,const pair<int,int> &b) { return a.l==b.l?a.r>b.r:a.l<b.l; }\nint f[N][N],sum[N];\nconst int mod=1e9+7;\ninline void inc(int &x,int y) { (x+=y)>=mod?x-=mod:0; }\nint main()\n{\n\tint n=gi(),m=gi(),i,j,t,d;\n\tscanf(\"%s\",str+1);\n\tfor (i=1;i<=n+1;i++) sum[i]=sum[i-1]+(str[i]=='1');\n\tfor (i=1;i<=n;i++) p[i].l=p[i].r=i;\n\tfor (i=n+1,m+=n;i<=m;i++) p[i].l=gi(),p[i].r=gi();\n\tsort(p+1,p+1+m,cmp);\n\tfor (i=1,t=m,m=0;i<=t;i++) if (p[i].r>p[m].r) p[++m]=p[i];\n\tp[m+1]=make_pair(n+1,n+1);\n\tf[1][sum[p[1].r]-sum[p[1].l-1]]=1;\n\tfor (i=t=1;i<=n;i++) {\n\t\tif (p[t+1].l<=i) t++;\n\t\tfor (j=0;j<=n;j++)\n\t\t\tif (f[i][j]) {\n\t\t\t\td=p[t+1].l==i+1?sum[p[t+1].r]-sum[p[t].r]:0;\n\t\t\t\tif (j) inc(f[i+1][j-1+d],f[i][j]);\n\t\t\t\tif (j!=p[t].r-i+1) inc(f[i+1][j+d],f[i][j]);\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=3007,P=1000000007;\n\nchar s[N];\nint n,m,t[N],f[2][N],r[N];\n\nint main()\n{\n\tin,n,m,s+1;\n\tfo1(i,n)t[i]=t[i-1]+s[i]-48;\n\tfo1(i,m)\n\t{\n\t\tint a,b;\n\t\tin,a,b;\n\t\trepr(r[a],b);\n\t}\n\tf[0][0]=1;\n\tint u=0,r=0;\n\tfo1(i,n)\n\t{\n\t\trepr(r,max(::r[i],i));\n\t\tfo(j,0,t[r])if(f[u][j])\n\t\t{\n\t\t\t//out,i,' ',j,' ',t[r]-j,' ',r-i,'\\n';\n\t\t\tif(t[r]-j<=r-i)(f[u^1][j]+=f[u][j])%=P;\n\t\t\tif(t[r]-j)(f[u^1][j+1]+=f[u][j])%=P;\n\t\t\tf[u][j]=0;\n\t\t}\n\t\tu^=1;\n\t}\n\tout,f[u][t[n]],'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll mo=1000000007;\nll dp[3030][3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\t\n\tint CR=0,CL=0;\n\tint B[2]={};\n\tdp[0][0]=1;\n\twhile(M--) {\n\t\tint L,R;\n\t\tcin>>L>>R;\n\t\tL--,R--;\n\t\twhile(CL<L) {\n\t\t\tif(CL==CR) B[S[CR++]=='1']++;\n\t\t\tFOR(i,3001) if(dp[CL][i]) {\n\t\t\t\tif(i<B[0]) (dp[CL+1][i+1]+=dp[CL][i])%=mo;\n\t\t\t\tif(CL-i<B[1]) (dp[CL+1][i]+=dp[CL][i])%=mo;\n\t\t\t}\n\t\t\tCL++;\n\t\t}\n\t\twhile(CR<=R) B[S[CR++]=='1']++;\n\t}\n\twhile(CL<N) {\n\t\tif(CL==CR) B[S[CR++]=='1']++;\n\t\tFOR(i,3001) if(dp[CL][i]) {\n\t\t\tif(i<B[0]) (dp[CL+1][i+1]+=dp[CL][i])%=mo;\n\t\t\tif(CL-i<B[1]) (dp[CL+1][i]+=dp[CL][i])%=mo;\n\t\t}\n\t\tCL++;\n\t}\n\t\n\tcout<<dp[CL][B[0]]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    string s; cin >> s;\n    int a[n];\n    rep(i,n) a[i] = s[i] - '0';\n    int l[m], r[m];\n    rep(i,m){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--;\n    } \n\n    int cnt = 0;\n    rep(i,n) cnt += a[i];\n    if(cnt == 0 || cnt == n){\n        cout << 1 << endl;\n        return 0;\n    }\n\n    int right[m][n];\n    rep(i,m)rep(j,n)right[i][j] = 0;\n    rep(i,m){\n        int now = r[i] + 1;\n        drep(j,n){\n            if(a[j] == 0) continue;\n            if(j == n-1){\n                right[i][j] = j;\n            }else if(i==0){\n                if(r[i] < j || j < l[i]){\n                    right[i][j] = j;\n                }else{\n                    right[i][j] = now - 1;\n                }\n            }else if(r[i] < right[i-1][j] || right[i-1][j] < l[i]){\n                right[i][j] = right[i-1][j];\n            }else{\n                right[i][j] = max(right[i-1][j], now-1);\n            }\n            if(a[j] == 1){\n                now = min(now, right[i][j]);\n            }\n        }\n        /*\n        rep(j,n) cout << right[i][j] << ' ';\n        cout << endl;\n        */\n    }\n\n    int left[m][n];\n    rep(i,m)rep(j,n)left[i][j] = n-1;\n    rep(i,m){\n        int now = l[i] - 1;\n        rep(j,n){\n            if(a[j] == 0) continue;\n            if(j == 0){\n                left[i][j] = j;\n            }else if(i==0){\n                if(r[i] < j || j < l[i]){\n                    left[i][j] = j;\n                }else{\n                    left[i][j] = now + 1;\n                }\n            }else if(r[i] < left[i-1][j] || left[i-1][j] < l[i]){\n                left[i][j] = left[i-1][j];\n            }else{\n                left[i][j] = min(left[i-1][j], now+1);\n            }\n            if(a[j] == 1){\n                now = max(now, left[i][j]);\n            }\n        }\n    }\n\n    /*\n    rep(i,n) cout << right[m-1][i] << ' ';\n    cout << endl;\n    */\n\n    const ll MOD = 1000000007;\n    ll dp[n][n];\n    rep(i,n)rep(j,n)dp[i][j] = 0;\n\n    cnt = 0;\n    rep(i,n){\n        if(a[i] == 0){\n            if(cnt == 0) continue;\n            rep(j,n) dp[i][j] = dp[i-1][j];\n            continue;\n        }\n        cnt++;\n        if(cnt == 1){\n            srep(j,left[m-1][i],right[m-1][i]+1){\n                dp[i][j] = 1;\n            }\n        }else{\n            ll sum = 0;\n            rep(j,n){\n                if(left[m-1][i]<=j&&j<=right[m-1][i]){\n                    dp[i][j] = sum;\n                }\n                sum += dp[i-1][j];\n                sum %= MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(i,n){\n        ans += dp[n-1][i];\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long c[3005][3005];\nvoid pre_C(){\n\tfor(int i=0;i<=3000;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t\t}\n\t}\n}\nlong long C(int n,int m)\n{\n\treturn c[n][m];\n}\nint main()\n{\n\tpre_C();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tint cnt=0;\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d\",&p[i].l,&p[i].r);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j)%mod)%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <array>\n#include <functional>\n#include <utility>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <map>\n#include <cstdio>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n\n\n\ntemplate<unsigned int Z>\nstruct ZpZ\n{\n    static const unsigned int P = Z;\n    using U64 = unsigned long long int;\n    U64 value;\n    ZpZ(long long int n) {if(std::abs(n) >= P)n %= P; if(n < 0)n += P; value = n;}\n    ZpZ():value(0){}\n    ZpZ& operator+=(ZpZ p){if((value += p.value) >= P)value -= P; return *this;}\n    ZpZ& operator-=(ZpZ p){if(value >= p.value)value -= p.value; else value += P - p.value; return *this;}\n    ZpZ& operator*=(ZpZ p){value = value * p.value % P; return *this;}\n    ZpZ& operator/=(ZpZ p){value = value * p.inverse().value % P; return *this;}\n    bool operator==(ZpZ p){return value == p.value;}\n    bool operator!=(ZpZ p){return value != p.value;}\n\n#define DEF(op) ZpZ operator op(ZpZ r)const{return ZpZ(value) op##= r;}\nDEF(+)DEF(-)DEF(*)DEF(/)\n#undef DEF\n\n    explicit operator long long int()const{return value;}\n    explicit operator int()const{return value;}\n    ZpZ operator-(){return P - value;}\n    ZpZ inverse()\n    {\n        int a = value, b = P, u = 1, v = 0;\n        while(b) \n        {\n            int t = a / b;\n            std::swap(a -= t * b, b); \n            std::swap(u -= t * v, v);\n        }\n        if(u < 0) u += P;\n        return u;\n    }\n    ZpZ pow(U64 e)\n    {\n        U64 ret = 1, base = value;\n        while(e)\n        {\n            if((e & 1) && ((ret *= base) >> 32))\n                ret %= P;\n            if((base *= base) >> 32)\n                base %= P;\n            e >>= 1;\n        }\n        return ret;\n    }\n\n};\n\ntemplate<unsigned int P>\nvoid WT(ZpZ<P> arg) {WT((int)arg);}\n\n\n\n\n\ntemplate<typename T>\nstruct Mapper\n{\n    int operator[](const T& v) { int& ret = table[v]; if(!ret) rtable[ret = table.size()] = v; return ret - 1; }\n    template<typename... Args> int operator()(Args... args) { return (*this)[T(args...)]; }\n    T rev(int idx){return rtable[idx + 1];}\n    std::map<T, int> table;\n    std::map<int, T> rtable;\n};\n\ntemplate<typename T, int S>\nstruct ReferenceArray\n{\n    struct It {typename std::array<T*, S>::iterator it; T& operator*(){return **it;} void operator++(){it++;} bool operator!=(const It& other){return it != other.it;} };\n    int size()const{return _ptr.size();}\n    It begin()const{return {_ptr.begin()};}\n    It end()const{return {_ptr.end()};}\n    T& operator[](int idx)const{return *_ptr[idx];}\n    mutable std::array<T*, S> _ptr;\n};\ntemplate<typename T, typename... Args> \nReferenceArray<T, sizeof...(Args) + 1> MAKEV(T& arg1, Args&... args) {return {&arg1, &args...};}\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nconst int MOD = 1000000007;\nusing ZZ = ZpZ<MOD>;\nZZ min(ZZ a, ZZ b){return std::min(a.value, b.value);}\nZZ max(ZZ a, ZZ b){return std::max(a.value, b.value);}\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nchar S[3456];\npair<int, int> qs[3456];\n\nint pre[3456];\nZZ dp[3009][3009];\n\nint one(int l, int r)\n{\n    return pre[r] - pre[l - 1];\n}\n\nint main()\n{\n    int N, M;\n    RD(N, M);\n    RD(S + 1);\n\n    S[N + 1] = '0';\n\n    for(int i: RG(1, N + 2))\n        pre[i] = pre[i - 1] + (S[i] == '1');\n\n\n    int total = 0;\n    qs[total++] = {0, 0};\n    for(int i: RG(M))\n    {\n        int l, r;\n        RD(l, r);\n\n        if(qs[total - 1].second >= r)\n            continue;\n\n        while(qs[total - 1].first == l)\n            total--;\n\n        while(qs[total - 1].second + 1 < l)\n        {\n            qs[total] = {qs[total - 1].second + 1, qs[total - 1].second + 1};\n            total++;\n        }\n        qs[total++] = {l, r};\n    }\n    while(qs[total - 1].second < N + 1)\n    {\n        qs[total] = {qs[total - 1].second + 1, qs[total - 1].second + 1};\n        total++;\n    }\n\n    dp[1][one(qs[1].first, qs[1].second)] = 1;\n\n    for(int i = 1, k = 1; i <= N; i++)\n    {\n        while(i >= qs[k + 1].first)\n            k++;\n        int l = qs[k].second - i + 1;//qs[k].first + 1;\n        for(int o = 0; o <= l; o++)\n        {\n\n            int z = l - o;\n\n            if(i + 1 < qs[k + 1].first)\n            {\n                if(z)\n                    dp[i + 1][o] += dp[i][o];\n                if(o)\n                    dp[i + 1][o - 1] += dp[i][o];\n            }\n            else\n            {\n                if(z)\n                    dp[i + 1][o + one(qs[k].second + 1, qs[k + 1].second)] += dp[i][o];\n                if(o)\n                    dp[i + 1][o - 1 + one(qs[k].second + 1, qs[k + 1].second)] += dp[i][o];\n            }\n        }\n    }\n\n\n\n    WTL(dp[N + 1][0]);\n\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n#define uint unsigned long long\n#define ll long long\n#define db double\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define X first\n#define Y second\n#define pcc pair<char, char>\n#define vi vector<int>\n#define vl vector<ll>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define ept 1e-9\n\nusing namespace std;\ninline int read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\nconst int mod = 1e9 + 7;\nconst int N = 3010;\nint n, m;\nint One[N], dp[N][N], rht[N];\nchar str[N];\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str);\n\trep(i, 0, n - 1)\n\t{\n\t\tOne[i] = (i ? One[i - 1] : 0) + str[i] - '0';\n\t\trht[i] = i;\n\t}\n\trep(i, 1, m)\n\t{\n\t\tint l = read(), r = read();\n\t\tl --;\n\t\tr --;\n\t\trep(j, l, r)\n\t\t\trht[j] = max(rht[j], r);\n\t}\n\tdp[0][0] = 1;\n\trep(i, 0, n - 1)\n\t\trep(now, 0, i)\n\t\t{\n\t\t\tint r = rht[i];\n\t\t\tint rest = One[r] - now;\n\t\t\tif(rest < 0) continue;\n\t\t\tif(rest > 0) (dp[i + 1][now + 1] += dp[i][now]) %= mod;\n\t\t\tif(r - i + 1 != rest) (dp[i + 1][now] += dp[i][now]) %= mod;\n\t\t}\n\tprintf(\"%d\\n\", dp[n][One[n - 1]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l[N], r[N], tr[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\t//freopen(\"f.in\", \"r\", stdin);\n\t//freopen(\"f.out\", \"w\", stdout);\n\t\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) {\n\t\tint ll, rr;\n\t\tscanf(\"%d%d\", &ll, &rr);\n\t\ttr[ll] = max(tr[ll], rr);\n\t}\n\tint m0 = 0;\n\tRep(i, n) if (tr[i]){\n\t\tbool flag = true;\n\t\tRep(j, i - 1) if (tr[i] <= tr[j]) flag = false;\n\t\tif (flag) l[++ m0] = i, r[m0] = tr[i];\n\t}\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, r[i] - l[i] + 1) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j] * c[r[i] - l[i] + 1][j]);\n\t\telse {\n\t\t\tRep0(j, r[i] - l[i] + 1) if (f[i][j]){\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, r[m0] - l[m0] + 1) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n10 2\n1011010000\n1 2\n3 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod>\nstruct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x (y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    Mod_Int &operator += (const Mod_Int &p){\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p){\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p){\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p){\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int &operator ++ () {return *this += Mod_Int(1);}\n\n    Mod_Int operator ++ (int){\n        Mod_Int tmp = *this;\n        ++*this;\n        return tmp;\n    }\n\n    Mod_Int &operator -- () {return *this -= Mod_Int(1);}\n\n    Mod_Int operator -- (int){\n        Mod_Int tmp = *this;\n        --*this;\n        return tmp;\n    }\n\n    Mod_Int operator - () const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow(ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse() const{\n        return pow(mod-2);\n    }\n\n    friend ostream &operator << (ostream &os, const Mod_Int &p){\n        return os << p.x;\n    }\n\n    friend istream &operator >> (istream &is, Mod_Int &p){\n        ll a;\n        is >> a;\n        p = Mod_Int<mod>(a);\n        return is;\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1], ifac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*i;\n    }\n    ifac[MAX_N] = fac[MAX_N].inverse();\n    rep3(i, MAX_N, 1){\n        ifac[i-1] = ifac[i]*i;\n    }\n}\n\nmint comb(int n, int k){\n    return fac[n]*ifac[n-k]*ifac[k];\n}\n\nmint perm(int n, int k){\n    return fac[n]*ifac[n-k];\n}\n\nint main(){\n    int N, M;\n    string S;\n    cin >> N >> M >> S;\n    int cnt[N+1];\n    cnt[0] = 0;\n    rep(i, N) cnt[i+1] = cnt[i]+(S[i] == '0');\n    int R[N];\n    fill(R, R+N, -1);\n    rep(i, M){\n        int l, r; cin >> l >> r; l--;\n        chmax(R[l], r);\n    }\n    vector<int> l, r;\n    l.pb(0), r.pb(0);\n    int now = 0;\n    rep(i, N){\n        if(chmax(now, R[i])) l.pb(i), r.pb(R[i]);\n    }\n    l.pb(N), r.pb(N);\n    \n    mint dp[N+1][N+1];\n    fill(dp[0], dp[N+1], 0);\n    dp[0][0] = 1;\n    rep(i, sz(l)-1){\n        rep2(j, l[i], min(r[i], l[i+1])-1){\n            rep(k, N+1){\n                if(dp[j][k] == 0) continue;\n                if(k+1 <= cnt[r[i]]) dp[j+1][k+1] += dp[j][k];\n                if(j-k+1 <= r[i]-cnt[r[i]]) dp[j+1][k] += dp[j][k];\n            }\n        }\n        if(r[i] < l[i+1]){\n            dp[l[i+1]][cnt[l[i+1]]] = dp[r[i]][cnt[r[i]]];\n        }\n    }\n    cout << dp[N][cnt[N]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,i,j,l[3005],r[3005],sum,top,f[3005][3005],g[3005][3005];\nchar s[3005],c1[3005],c2[3005];\nint main(){\n\t//freopen(\"camp.in\",\"r\",stdin);\n\t//freopen(\"camp.out\",\"w\",stdout);\n\tn=read();m=read();\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;i++){\n\t\tl[i]=read();r[i]=read();\n\t\tif(r[i]<=r[i-1]){\n\t\t\tl[i]=0;\n\t\t\tr[i]=0;\n\t\t\tm--;\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tc1[i]=s[i];\n\t\tc2[i]=s[i];\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tsum=0;\n\t\tfor(j=l[i];j<=r[i];j++)\n\t\t\tif(c1[j]=='1')\n\t\t\t\tsum++;\n\t\tfor(j=l[i];j<=l[i]+sum-1;j++)\n\t\t\tc1[j]='1';\n\t\tfor(j=l[i]+sum;j<=r[i];j++)\n\t\t\tc1[j]='0';\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tsum=0;\n\t\tfor(j=l[i];j<=r[i];j++)\n\t\t\tif(c2[j]=='0')\n\t\t\t\tsum++;\n\t\tfor(j=l[i];j<=l[i]+sum-1;j++)\n\t\t\tc2[j]='0';\n\t\tfor(j=l[i]+sum;j<=r[i];j++)\n\t\t\tc2[j]='1';\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(c1[i]=='1'){\n\t\t\ttop++;\n\t\t\tl[top]=i;\n\t\t}\n\ttop=0;\n\tfor(i=1;i<=n;i++)\n\t\tif(c2[i]=='1'){\n\t\t\ttop++;\n\t\t\tr[top]=i;\n\t\t}\n\tfor(i=0;i<=r[top];i++)\n\t\tg[0][i]=1;\n\tfor(i=1;i<=top;i++){\n\t\tfor(j=l[i];j<=r[i];j++)\n\t\t\tf[i][j]=g[i-1][j-1];\n\t\tfor(j=l[i];j<=r[top];j++)\n\t\t\tg[i][j]=(g[i][j-1]+f[i][j])%mo;\n\t}\n\tpus(g[top][r[top]],2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[4000][4000];\nint b[4000];\nint sum[4000];\n\nint main(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvector<P>v;\n\trep(i,m){\n\t\tint l,r;scanf(\"%d%d\",&l,&r);l--;r--;\n\t\tif(v.empty())v.push_back(P(l,r));\n\t\telse if(v.back().first==l)v.back().second=max(v.back().second,r);\n\t\telse if(v.back().second<r)v.push_back(P(l,r));\n\t}\n\tfor(auto p:v)b[p.first]=p.second;\n\tfor(int i=1;i<n;i++)b[i]=max(b[i],b[i-1]);\n\tint cnt=0;\n\trep(i,n){\n\t\tif(s[i]=='1')cnt++;\n\t\tsum[i]=cnt;\n\t}\n\tdp[0][cnt]=1;\n\trep(i,n)rep(j,cnt+1){\n\t\tif(dp[i][j]==0)continue;\n\t\tint a=j-(sum[n-1]-sum[b[i]]);\n\t\tif(a)(dp[i+1][j-1]+=dp[i][j])%=MOD;\n\t\tif(b[i]-i+1-a)(dp[i+1][j]+=dp[i][j])%=MOD;\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define INF 0x3f3f3f3f\nusing namespace std;\n\ntemplate<class T> inline\nvoid read(T& x) {\n\tint f = 1; x = 0;\n\tchar ch = getchar();\n\twhile (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}\n\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\n/*============ Header Template ============*/\n\nconst int N = 3000 + 5;\nconst int mo = 1000000007;\n\nint n, m, num;\nchar str[N];\nint f[N][N], vis[N][N], s[N];\nint L[N], R[N], W[N];\nint C[N][N];\n\nint solve(int x, int k) {\n\tif (vis[x][k]) return f[x][k];\n\tif (k < 0 || k > W[x]) {printf(\"fuck %d %d\\n\", x, k);}\n\tvis[x][k] = 1;\n\tint ans = 0, ALL = s[R[x]] - s[L[x] + W[x] - 1] + k;\n\tif (x == num) return f[x][k] = C[R[x] - L[x] + 1][ALL];\n\tint LS = max(0, ALL + W[x + 1] - (R[x] - L[x] + 1));\n\tint RS = min(W[x + 1], ALL);\n\tfor (int i = LS; i <= RS; i++) {\n\t\tans = (ans + 1LL * solve(x + 1, i) * C[R[x] - L[x] + 1 - W[x + 1]][ALL - i] % mo) % mo;\n\t}\n\treturn f[x][k] = ans;\n}\n\nint fish(int a, int b) {\n\tint ls = max(L[a], L[b]), rs = min(R[a], R[b]);\n\treturn max(0, rs - ls + 1);\n}\n\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", str + 1); n = strlen(str + 1);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + (str[i] == '1');\n\tfor (int i = 0; i <= n; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mo;\n\t}\n\tint mx = 0; num = 0;\n\tfor (int i = 1, ls, rs; i <= m; i++) {\n\t\tread(ls), read(rs);\n\t\tif (rs <= mx) continue;\n\t\tnum++; L[num] = ls; R[num] = rs; mx = rs; W[num] = fish(num - 1, num);\n\t}\n\tint ans = solve(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3100\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, r[N], sum[N], f[N][N];\nchar s[N];\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n + 1; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1'), r[i] = i;\n\n    for (int i = 1, l, x; i <= m; ++i) {\n        scanf(\"%d%d\", &l, &x);\n        r[l] = max(r[l], x);\n    }\n\n    for (int i = 1; i <= n + 1; ++i)\n        r[i] = max(r[i], r[i - 1]);\n\n    f[0][0] = 1;\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j <= n; ++j) {\n            if (!f[i][j]) continue;\n            int r1 = r[i], r2 = r[i + 1];\n            if (j) inc(f[i + 1][sum[r2] - sum[r1] + j - 1], f[i][j]);\n            if (r[i] - (i - 1) - j) inc(f[i + 1][sum[r2] - sum[r1] + j], f[i][j]);\n        }\n\n    cout << f[n + 1][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n//#include \"IntMod.h\"\ntypedef IntMod<1000000007> MInt;\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) {\n\t//if (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn MInt(n).Fact() / (MInt(r).Fact() * MInt(n - r).Fact());\n}\n\nint main() {\n\t/* さすがに無理か？ */\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e3+10;\nconst int mod=1e9+7;\nchar s[maxn];\nint n,m,f[maxn][maxn],R[maxn],sum[maxn][2];\nvoid check(int &a,int b) \n{\n\ta=a+b>=mod?a+b-mod:a+b;\n}\nint main() \n{\n\tcin>>n>>m;\n\tcin>>s+1;\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tR[i]=i;\n\t\tsum[i][0]=sum[i-1][0];\n\t\tsum[i][1]=sum[i-1][1];\n\t\tsum[i][s[i]-'0']++;\n\t}\n\tfor(int i=1;i<=m;i++) \n\t{\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tR[l]=max(R[l],r);\n\t}\n\tfor(int i=2;i<=n;i++) \n\t{\n\t\tR[i]=max(R[i],R[i-1]);\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<=i;j++) \n\t\t{\n\t\t\tif(!f[i][j]) continue;\n\t\t\tif(j<sum[R[i+1]][0]) \n\t\t\t{\n\t\t\t\tcheck(f[i+1][j+1],f[i][j]);\n\t\t\t}\n\t\t\tif(i-j<sum[R[i+1]][1]) \n\t\t\t{\n\t\t\t\tcheck(f[i+1][j],f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<f[n][sum[n][0]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    rep(j, lm[i]+1) tmp[lm[i]+1] += dp[j];\n    rep2(j, lm[i]+1, rm[i]+1) tmp[j+1] = tmp[j] + dp[j];\n    swap(dp, tmp);\n    // dump(dp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint solve(string s, vector<int> l, vector<int> r) {\n\tint N = s.length(), M = l.size();\n\tint R = l[0], zero = 0, one = 0;\n\tint j = 0;\n\tvector<int> dp(N + 1);\n\tdp[0] = 1;\n\tfor (int i = l[0]; i < r[M - 1]; i++) {\n\t\tif (j < M && i == l[j]) {\n\t\t\tfor (int i = R; i < r[j]; i++) {\n\t\t\t\tif (s[i] == '0') zero++;\n\t\t\t\telse one++;\n\t\t\t}\n\t\t\tR = r[j];\n\t\t\tj++;\n\t\t}\n\t\tvector<int> _dp(N + 1);\n\t\tfor (int x = 0; x <= N; x++) {\n\t\t\tint k0 = i - l[0] - x, k1 = x;\n\t\t\tif (k0 < 0 || k1 < 0) continue;\n\t\t\tif (k0 < zero) _dp[x] = (_dp[x] + dp[x]) % MOD;\n\t\t\tif (k1 < one) _dp[x + 1] = (_dp[x + 1] + dp[x]) % MOD;\n\t\t}\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= N; x++)\n\t\tans = (ans + dp[x]) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tvector<int> l, r;\n\tint ma = 0;\n\twhile (M--) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--;\n\t\tif (y <= ma) continue;\n\t\tma = y;\n\t\tif (l.size() && l.back() == x)\n\t\t\tl.pop_back(), r.pop_back();\n\t\tl.pb(x); r.pb(y);\n\t}\n\tM = l.size();\n\tvector<int> v;\n\tv.pb(0);\n\tfor (int j = 0; j + 1 < M; j++)\n\t\tif (r[j] <= l[j + 1])\n\t\t\tv.pb(j + 1);\n\tv.pb(M);\n\tint ans = 1;\n\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\tvector<int> _l, _r;\n\t\tfor (int j = v[k]; j < v[k + 1]; j++)\n\t\t\t_l.pb(l[j]), _r.pb(r[j]);\n\t\tans = (ll)ans * solve(s, _l, _r) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vi;\n\nconst int MOD = (int)1e9 + 7;\nint N, M;\nstring S;\nvi sum1, lr;\nvector<vi> dp;\n\nint main(void) {\n\tint l, r;\n\n\tcin >> N >> M >> S;\n\n\tsum1.resize(N + 1, 0);\n\tlr.resize(N + 1, 0);\n\n\tfor (int i = 1; i <= N; ++i) {\n\t\tsum1[i] = (S[i - 1] == '1') ? sum1[i - 1] + 1 : sum1[i - 1];\n\t\tlr[i] = i;\n\t}\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> l >> r;\n\t\tfor (int j = l; j <= r; ++j) {\n\t\t\tif (r > lr[j])\n\t\t\t\tlr[j] = r;\n\t\t}\n\t}\n\n\tvi v(N + 1, 0);\n\tdp.resize(N + 1, v);\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tl = i - (lr[i] - sum1[lr[i]]);\n\t\tif (l < 0)\n\t\t\tl = 0;\n\t\tr = sum1[lr[i]];\n\t\tfor (int j = l; j <= r; ++j) {\n\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n\t\t}\n\t}\n\n\tint ans = dp[N][sum1[N]];\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-7)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tint x;\n                                        \tint y,z,w;\n                                        \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\nunsigned int randxor()\n{\n    static unsigned int x=123456789,y=362436069,z=521288629,w=88675123;\n    unsigned int t;\n    t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nstring s;\nint n,m;\nvector<pa> memo;\nint rui[3010]={0};\n\nint one(int l,int r){\n\treturn rui[r]-rui[l-1];\n}\nint zero(int l,int r){\n\treturn r-l+1-one(l,r);\n}\nint dp[3010][3010]={0};\nint doko[3010]={0};\n  signed main(){\n  \t              cin.tie(0);\n    \t\tios::sync_with_stdio(false);\ncin>>n>>m;\n  \tcin>>s;\n  \ts=\"0\"+s;\n  \t\n  \tfor(int i=1;i<=n;i++)rui[i]=rui[i-1]+(s[i]-'0'?1:0);\n  \t\n  \tfor(int i=0;i<m;i++){\n  \t\tint y,yy;\n  \t\tcin>>y>>yy;\n  \t\tif(i==0){\n  \t\t\t\tmemo.pb({y,yy});\n  \t\t\tcontinue;\n  \t\t}\n  \t\tif(memo.back().second>=yy) continue;\n  \t\tif(memo.back().first==y){\n  \t\t\tmemo.pop_back();\n  \t\t}\n  \t\t\tmemo.pb({y,yy});\n  \t}\n  \t\n  \tint hani[3010];\n  \tfor(int i=0;i<3010;i++)hani[i]=-1;\n  \tfor(auto v:memo){\n  \t\tassert(hani[v.first]==-1);\n  \t\thani[v.first]=v.second;\n  \t}\n  \tif(hani[1]==-1){\n  \tdoko[0]=1;\n  \tdp[1][0]=1;\n  \t}\n  \telse{\n  \t\tdoko[0]=hani[1];\n  \t\tdp[1][one(1,hani[1])]=1;\n  \t}\n  \t\n // \tfor(int i=1;i<=n;i++)cout<<i<<\" \"<<hani[i]<<endl;\n  \tfor(int i=1;i<=n;i++){\n  \t//\tfor(int j=0;j<=n;j++)cout<<i<<\" \"<<doko[i-1]<<\"  \"<<j<<\"  \"<<dp[i][j]<<endl;\n  \t//\tcout<<endl;\n  \t\tif(hani[i]==-1 && doko[i-1]==i){\n  \t\t\tdoko[i]=i+1;\n  \t\t\tfor(int j=0;j<=n;j++)if(dp[i][j]){\n  \t\t//\t\tcout<<i<<\" \"<<j<<endl;\n  \t\t\t\tif(s[i+1]=='1'){\n  \t\t\t\t\tdp[i+1][1]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][1]%=inf;\n  \t\t\t\t}\n  \t\t\t\tif(s[i+1]=='0'){\n  \t\t\t\t\tdp[i+1][0]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][0]%=inf;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\telse if(hani[i]==-1){\n  \t\t\tdoko[i]=doko[i-1];\n  \t\t\tfor(int j=0;j<=n;j++)if(dp[i][j]){\n  \t\t\t\tint s1=j;\n  \t\t\t\tint s0=doko[i-1]-i+1-s1;\n  \n  //\t\t\t\tcout<<\"s1 s0 \"<<s1<<\" \"<<s0<<\" \"<<doko[i-1]<<\" \"<<hani[i]<<endl;\n  \t\t\t\tif(s1){\n  \t\t\t\t\tdp[i+1][s1-1]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][s1-1]%=inf;\n  \t\t\t\t}\n  \t\t\t\tif(s0){\n  \t\t\t\t\tdp[i+1][s1]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][s1]%=inf;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\telse{\n  \t\t\tdoko[i]=hani[i];\n  \t\t//\tcout<<\"doko \"<<i<<\" \"<<hani[i]<<endl;\n  \t\t\tfor(int j=0;j<=n;j++)if(dp[i][j]){\n  \t\t\t\tint s1=j;\n  \t\t\t\tint s0=doko[i-1]-i+1-s1;\n  \t\t\t\tint a1=one(doko[i-1]+1,hani[i]);\n  \t\t\t\tint a0=zero(doko[i-1]+1,hani[i]);\n  \t\t\t\ts1+=a1;\n  \t\t\t\ts0+=a0;\n  \t\t//\t\tcout<<\"s1 s0 \"<<a1<<\" \"<<a0<<\" \"<<doko[i-1]+1<<\" \"<<hani[i]<<endl;\n  \t\t\t\tif(s1){\n  \t\t\t\t\tdp[i+1][s1-1]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][s1-1]%=inf;\n  \t\t\t\t}\n  \t\t\t\tif(s0){\n  \t\t\t\t\tdp[i+1][s1]+=dp[i][j];\n  \t\t\t\t\tdp[i+1][s1]%=inf;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  \tint ans=0;\n  \tfor(int i=0;i<=n;i++){\n  \tans+=dp[n][i];\n  \t\tans%=inf;\n  \t}\n  \tcout<<ans<<endl;\n  \treturn 0;\n                }\n                \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nstruct Range {\n  int l, r;\n  Range(int l, int r) : l(l), r(r) {}\n};\n\ntemplate<class T> inline bool UpdateMin(T& a, T b) {\n  if (a > b) { a = b; return 1; } return 0;\n}\n\ntemplate<class T> inline bool UpdateMax(T& a, T b) {\n  if (a < b) { a = b; return 1; } return 0;\n}\n\ntemplate<typename T>\nvector<vector<T>> Make2DVector(int d1, int d2, T default_value) {\n  return vector<vector<T>>(d1, vector<T>(d2, default_value));\n}\n\nconstexpr int64 P = 1000000007;\n\nstruct FiniteField {\n private:\n  int64 x;\n  static inline int64 Normalize(int64 x) {\n    if (0 <= x && x < P) return x; x %= P; if (x < 0) x += P; return x;\n  }\n public:\n  FiniteField(int64 x) : x(Normalize(x)) {}\n  FiniteField() : x(0) {}\n  int64 Value() const { return x; }\n  inline FiniteField operator+(FiniteField o) const {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) const {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) const {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) const {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nostream& operator<<(ostream& s, const FiniteField& v) { s << v.Value(); return s; }\n\ntuple<vector<FiniteField>, vector<FiniteField>> MakeFactorialTables(int n) {\n  vector<FiniteField> factorials(n + 1);\n  vector<FiniteField> inverse_factorials(n + 1);\n  factorials[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    factorials[i] = factorials[i - 1] * i;\n  }\n  inverse_factorials[n] = FiniteField(1) / factorials[n];\n  for (int i = n; i >= 1; i--) {\n    inverse_factorials[i - 1] = inverse_factorials[i] * i;\n  }\n  return make_tuple(factorials, inverse_factorials);\n}\n\n// Vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size();\n  s << \"[\";\n\tfor (int i = 0; i < len; i++) {\n    if (i > 0) s << \", \";\n\t\ts << v[i];\n  }\n  s << \"]\";\n  return s;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n\n  vector<Range> ranges;\n  int r_max = -1;\n  for (int i = 0; i < m; i++) {\n    int l, r;\n    cin >> l >> r;\n    l--;\n    if (r < r_max) continue;\n    UpdateMax(r_max, r);\n    ranges.push_back(Range(l, r));\n  }\n\n  ranges.push_back(Range(n, n));\n\n  m = ranges.size();\n\n  vector<FiniteField> fs, ifs;\n  tie(fs, ifs) = MakeFactorialTables(n + 1);\n  auto c_fn = [&](int a, int b) -> FiniteField {\n    if (a < b) return 0;\n    return fs[a] * ifs[b] * ifs[a - b];\n  };\n\n  auto dp = Make2DVector(m, n + 1, FiniteField(0));\n\n  int c0 = 0;\n  for (int i = ranges[0].l; i < ranges[0].r; i++) {\n    if (s[i] == '1') c0++;\n  }\n  dp[0][c0] = 1;\n\n  for (int k = 1; k < m; k++) {\n    if (DEBUG) cout << k << \" \" << ranges[k].l << \" \" << ranges[k].r << endl;\n    if (ranges[k].l < ranges[k - 1].r) {\n      if (DEBUG) cout << \"A\" << endl;\n      int c = 0;\n      for (int i = ranges[k - 1].r; i < ranges[k].r; i++) {\n        if (s[i] == '1') c++;\n      }\n\n      int d = ranges[k].l - ranges[k - 1].l;\n\n      for (int l = 0; l <= n; l++) {\n        if (dp[k - 1][l].Value() == 0) continue;\n\n        for (int x = 0; x <= d; x++) {\n          int nl = ranges[k - 1].r - ranges[k - 1].l - l;\n          if (x > l) continue;\n          if (d - x > nl) continue;\n          // if (l + c - x > ranges[k].r - ranges[k].l) continue;\n          dp[k][l + c - x] += c_fn(d, x) * dp[k - 1][l];\n        }\n      }\n    } else {\n      if (DEBUG) cout << \"B\" << endl;\n      int c = 0;\n      for (int i = ranges[k].l; i < ranges[k].r; i++) {\n        if (s[i] == '1') c++;\n      }\n\n      int d = ranges[k - 1].r - ranges[k - 1].l;\n\n      for (int l = 0; l <= n; l++) {\n        if (dp[k - 1][l].Value() == 0) continue;\n        dp[k][c] += c_fn(d, l) * dp[k - 1][l];\n      }\n    }\n  }\n\n  if (DEBUG) {\n    for (int i = 0; i < m; i++) {\n      cout << \"dp[\" << i << \"]: \" << dp[i] << endl;\n    }\n  }\n\n  FiniteField ans = 0;\n  for (int i = 0; i <= n; i++) {\n    ans += dp[m - 1][i];\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\nclass Modulo\n{\npublic:\n    Modulo(const ll n, const ll mod = MOD) : size{n + 1}, mod{mod}, fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)  // mod should be prime\n    {\n        for (ll i = 2; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % mod;\n            inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod;\n            inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod;\n        }\n    }\n    ll factorial(const ll n) const\n    {\n        assert(n < size);\n        return fact[n];\n    }\n    ll inverse(const ll n) const\n    {\n        assert(n < size);\n        return inv[n];\n    }\n    ll inverseFactorial(const ll n) const\n    {\n        assert(n < size);\n        return inv_fact[n];\n    }\n    ll permutation(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (fact[n] * inv_fact[n - k]) % mod;\n    }\n    ll combination(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod;\n    }\n    ll homogenious(const ll n, const ll k) const { return (n == 0 and k == 0 ? 1 : combination(n + k - 1, k)); }\n\nprivate:\n    const ll size;\n    const ll mod;\n    vector<ll> fact;\n    vector<ll> inv;\n    vector<ll> inv_fact;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<vector<ll>> tmp(3001);\n    for (ll i = 0; i < M; i++) {\n        ll l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (tmp[l].size() > 0) {\n            if (tmp[l][0] < r) {\n                tmp[l][0] = r;\n            }\n        } else {\n            tmp[l].push_back(r);\n        }\n    }\n    using P = pair<ll, ll>;\n    vector<P> R;\n    ll r = 0;\n    for (ll i = 0; i <= 3000; i++) {\n        if (tmp[i].size() > 0 and tmp[i][0] > r) {\n            R.push_back({i, tmp[i][0]});\n            r = tmp[i][0];\n        }\n    }\n    const ll size = R.size();\n    vector<P> llersect(size);\n    llersect[0] = {-1, -1};\n    for (ll i = 1; i < size; i++) {\n        llersect[i] = {R[i].first, R[i - 1].second};\n    }\n    llersect.push_back({N, N});\n    vector<ll> one(size + 1, 0);\n    vector<ll> one_orig(size, 0);\n    for (ll i = 0; i < size; i++) {\n        if (i == 0) {\n            one[i] = 0;\n        } else {\n            for (ll j = llersect[i].first; j <= llersect[i].second; j++) {\n                one[i] += (S[j] == '1' ? 1 : 0);\n            }\n        }\n        for (ll j = R[i].first; j <= R[i].second; j++) {\n            one_orig[i] += (S[j] == '1' ? 1 : 0);\n        }\n    }\n    Modulo mod(N + 1);\n    vector<ll> dp(N + 1, 0);  // i番目の区間\n    dp[0] = 1;\n    for (ll i = 0; i < size; i++) {\n        vector<ll> tmp(N + 1, 0);\n        for (ll j = 0; j <= llersect[i].second - llersect[i].first + 1; j++) {\n            if (dp[j] > 0) {\n                const ll tot = one_orig[i] - one[i] + j;\n                const ll next = llersect[i + 1].second - llersect[i + 1].first + 1;\n                const ll rest = R[i].second - R[i].first + 1 - next;\n                for (ll k = max(0LL, tot - rest); k <= min(tot, next); k++) {\n                    (tmp[k] += mod.combination(rest, tot - k) * dp[j] % MOD) %= MOD;\n                }\n            }\n        }\n        dp = tmp;\n    }\n    ll ans = 0;\n    for (ll i = 0; i <= N; i++) {\n        (ans += dp[i]) %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < int(n); ++i)\n#define REPE(i, a, b) for (int i = (a); i <= int(b); ++i)\nusing LL = long long;\n\nint n, m;\nchar s[3010];\nint sum[3010];\n\nint dp[3010][3010];\nint a[3010];\n\nconst int mod = 1000000007;\nint f(int l, int r, int c) {\n  if (l > r && c) return 0;\n  if (l > n) return c == 0;\n  if (a[l] >= r) {\n    c += sum[a[l]] - sum[r];\n    r = a[l];\n  }\n  int &ret = dp[l][c];\n  if (ret >= 0) return ret;\n  ret = 0;\n  if (r - l + 1 - c > 0) ret += f(l + 1, r, c);\n  if (c > 0) ret += f(l + 1, r, c - 1);\n  if (ret >= mod) ret -= mod;\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d%s\", &n, &m, s + 1);\n  for (int i = 1; i <= n; ++i)\n    sum[i] = sum[i - 1] + (s[i] == '1');\n  for (int i = 1; i <= n; ++i)\n    a[i] = i;\n  for (int i = 0; i < m; ++i) {\n    int l, r;\n    scanf(\"%d%d\", &l, &r);\n    a[l] = max(a[l], r);\n  }\n  memset(dp, -1, sizeof dp);\n  printf(\"%d\\n\", f(1, 0, 0));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll l[5000], r[5000];\nll cnk[3001][3001];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //freopen(\"input.in\", \"r\", stdin);\n    //freopen(\"output.out\", \"w\", stdout);\n    cin >> n >> m >> s;\n    for (int i = 0; i < m; i++)\n    {\n        cin >> l[i] >> r[i];\n        if (i > 0 && l[i - 1] <= l[i] && r[i] <= r[i - 1])\n        {\n            i--;\n            m--;\n        }\n    }\n    cnk[0][0] = 1;\n    for (int i = 1; i <= 3000; i++)\n    {\n        cnk[i][0] = 1;\n        cnk[i][i] = 1;\n    }\n    for (int i = 1; i <= 3000; i++)\n    {\n        for (int j = 1; j < i; j++)\n        {\n            cnk[i][j] = cnk[i - 1][j] + cnk[i - 1][j - 1];\n            if (cnk[i][j] >= MOD)\n                cnk[i][j] -= MOD;\n        }\n    }\n    ll k = 0;\n    for (int i = l[0]; i <= r[0]; i++)\n    {\n        k += s[i] - '0';\n    }\n    cout << cnk[r[0] - l[0] + 1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],inv[3002];\nlld d[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= inv[n-r]; tmp %= Mod;\n\ttmp *= inv[r]; tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = inv[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][sum[x[1]-1]] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tint cnt1,cnt2;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t}else{\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt1 = min(cnt1,x[i+1]-x[i]);\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\t//if (l[i]<=r[i-1])\n\t\t//{\n\t\t\tfor (int k=max(0,l[i]-min(l[i+1],r[i]+1)+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(min(l[i+1],r[i]+1)-l[i],j-k))%mo;\n\t\t//}\n\t\t//else f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    REP(i, M){\n        if(r[i] <= rmax) continue;\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        int t = n1[rmax + 1];\n        if(l1 <= rmax){\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            REP(k, t + 1){\n                dp[i + 1][n1[l1]] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][n1[l1]] %= mod;\n            }\n        }\n    }\n    //debug(dp);\n    cout << dp[M][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 3000 + 100;\nconst int MOD = 1000000000 + 7;\n\nint n, m;\nchar s[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN], rig[MAXN];\n\nvoid add(int &x, int y)\n{\n\tx = (x + y) % MOD;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> m;\n\tcin >> (s + 1);\n\tfor(int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + (s[i] == '1');\n\tfor(int i = 1; i <= n; i++)\n\t\trig[i] = i;\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\trig[l] = max(rig[l], r);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\trig[i] = max(rig[i], rig[i - 1]);\n\n\t// for(int i = 1; i <= n; i++)\n\t// \tcerr << i << ' ' << rig[i] << endl;\n\n\tf[0][0] = 1;\n\tfor(int i = 0; i <= n - 1; i++)\n\t\tfor(int j = 0; j <= rig[i] - i + 1; j++)\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tint a = j + sum[rig[i + 1]] - sum[rig[i]];\n\t\t\t\tint b = rig[i + 1] - (i + 1) + 1 - a;\n\t\t\t\tif(a >= 1)\n\t\t\t\t\tadd(f[i + 1][a - 1], f[i][j]);\n\t\t\t\tif(b >= 1)\n\t\t\t\t\tadd(f[i + 1][a], f[i][j]);\n\t\t\t}\n\tint ans = f[n][0];\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate<int MOD>\nclass ModInt{\npublic:\n    ModInt():value(0){}\n    ModInt(long long val):value((int)(val<0?MOD+val%MOD:val%MOD)){ }\n\n    ModInt& operator+=(ModInt that){\n        value = value+that.value;\n        if(value>=MOD)value-=MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that){\n        value -= that.value;\n        if(value<0)value+=MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that){\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that){\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const{\n        return ModInt(*this)+=that;\n    }\n    ModInt operator-(ModInt that) const{\n        return ModInt(*this)-=that;\n    }\n    ModInt operator*(ModInt that) const{\n        return ModInt(*this)*=that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const{\n        if(value == 0)return 0;\n        ModInt n = *this, res = 1;\n        while(k){\n            if(k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const{ return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<1000000007> mint;\nostream& operator<<(ostream& os, const mint& x){\n    os << x.toi();\n    return os;\n}\n\nmint dp[3002][3002];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vi L, R;\n    rep(i, M) {\n        int l, r;\n        cin >> l >> r;\n        if(sz(L) && r <= R.back())continue;\n        while(sz(L) && L.back() == l && R.back() <= r) {\n            L.pop_back();\n            R.pop_back();\n        }\n        L.push_back(l);\n        R.push_back(r);\n    }\n\n    vector<mint> F(N + 1);\n    F[0] = 1;\n    for(int i = 1; i <= N; ++i) {\n        F[i] = F[i - 1] * i;\n    }\n\n    auto cnt=[&](int l, int r) {\n        int res = 0;\n        for(int i = l; i < r; ++i)if(S[i] == '1')++res;\n        return res;\n    };\n\n    M = sz(L);\n    \n    rep(i, M)--L[i];\n    dp[0][0] = 1;\n    int preCon = 0;\n    rep(i, M) {\n        int ones = 0;\n        if(i == 0 || R[i - 1] < L[i]) {\n            ones = cnt(L[i], R[i]);\n        } else {\n            ones = cnt(R[i - 1], R[i]);\n        }\n\n        int con = 0;\n        if(i < M - 1 && L[i + 1] < R[i]) {\n            con = R[i] - L[i + 1];\n        }\n        int len = R[i] - L[i];\n        rep(j, preCon+1) if(dp[i][j].toi()){\n            int curOnes = ones + j;\n            // 次のセグメントと接続\n            if(con) {\n                int ub = min(con, curOnes), lb = max(ub - (len - curOnes), 0);\n                for(int nj = lb; nj <= ub; ++nj) {\n                    int notCon = len - con;\n                    int notNj = curOnes - nj;\n                    dp[i + 1][nj] += dp[i][j] * (F[notCon]/(F[notNj]*F[notCon-notNj]));\n                }\n            } else {\n                // 接続しない\n                dp[i + 1][0] += dp[i][j] * F[len] /(F[curOnes]*F[len-curOnes]);\n            }\n        }\n        preCon = con;\n    }\n\n    mint ans = 0;\n    for(int i = 0; i <= N; ++i)ans += dp[M][i];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst int maxn = 3030;\n\n\n\nint n, m;\nstring s;\nint a[maxn];\nint b[maxn];\nll dp[maxn][maxn];//# ways to fill first i elems, holding j 1's\n\n\n\nvoid add(ll& x, ll y) {\n    x %= mod;\n    y %= mod;\n    x += y;\n    x %= mod;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>m;\n    cin>>s;\n    for (int i=0; i<n; i++) {\n\ta[i]=(s[i]-'0');\n\tb[i]=i+1;\n    }\n\n    for (int i=0; i<m; i++) {\n\tint l,r; cin>>l>>r;\n\t--l; --r;\n\tb[l]=max(b[l],r+1);\n    }\n\n    for (int i=1; i<n; i++) {\n\tb[i]=max(b[i],b[i-1]);\n    }\n\n    dp[0][0]=1;\n    for (int i=0, j=0; i<n; i++) {\n\tint ones = 0;\n\twhile (j<b[i]) ones+=a[j++];\n\n\tfor (int x=0; x<=n; x++) {\n\t    if (dp[i][x] == 0) continue;\n\t    int cur=x+ones;\n\n\t    //put 1 at ith index\n\t    if (cur>0) {\n\t\tadd(dp[i+1][cur-1], dp[i][x]);\n\t    }\n\n\t    // put 0 at ith index\n\t    if (j-i != cur) {\n\t\tadd(dp[i+1][cur], dp[i][x]);\n\t    }\n\t}\n    }\n\n    ll ans = dp[n][0];\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    cout<<ans<<endl;\n  \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst ll mod = 1000000007LL ;\n\nint n , m ;\nchar s[ 3005 ] ;\nii q[ 3005 ] ;\nvector< ii > v ;\nint pre[ 3005 ] ;\nll C[ 3005 ][ 3005 ] ;\n\nvoid init() {\n  scanf( \"%d%d%s\" , &n , &m , s + 1 ) ;\n  pre[ 0 ] = 0 ;\n  for ( int i = 1 ; i <= m ; i ++ ) {\n    scanf( \"%d%d\" , &q[ i ].first , &q[ i ].second ) ;\n    if ( v.size() == 0 ) v.push_back( q[ i ] ) ;\n    else {\n      q[ i ].second = max( v.back().second , q[ i ].second ) ;\n      if ( v.back().first < q[ i ].first ) v.push_back( q[ i ] ) ;\n      else v.back().second = max( v.back().second , q[ i ].second ) ;\n    }\n  }\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    if ( s[ i ] == '1' ) pre[ i ] = pre[ i - 1 ] + 1 ;\n    else pre[ i ] = pre[ i - 1 ] ;\n  }\n}\n\nll dp[ 3005 ][ 3005 ] ;\n\nvoid process() {\n  dp[ v[ 0 ].first ][ pre[ v[ 0 ].first - 1 ] ] = 1 ;\n  for ( int i = 0 ; i + 1 < (int)v.size() ; i ++ ) {\n    ii nw = v[ i ] ;\n    ii nxt = v[ i + 1 ] ;\n    int lb = nw.first , rb = nw.second ;\n    int nlb = nxt.first ;\n    int emp = nlb - lb ;\n    for ( int j = 0 ; j < lb ; j ++ ) if ( dp[ lb ][ j ] ) {\n      int ones = pre[ rb ] - j ;\n      int zeros = ( rb - lb + 1 ) - ones ;\n      int lbnd = max( j , emp - zeros + j ) ;\n      int bnd = min( pre[ rb ] , j + emp ) ;\n      for ( int one = lbnd ; one <= bnd ; one ++ ) {\n        dp[ nlb ][ one ] = ( dp[ nlb ][ one ] + dp[ lb ][ j ] * C[ emp ][ one - j ] ) % mod ;\n      }\n    }\n  }\n  ll ans = 0 ;\n  ii nw = v.back() ;\n  for ( int j = 0 ; j < nw.first ; j ++ ) if ( dp[ nw.first ][ j ] ) {\n    int one = pre[ nw.second ] - j ;\n    if ( one <= nw.second - nw.first + 1 ) {\n      ans = ( ans + dp[ nw.first ][ j ] * C[ nw.second - nw.first + 1 ][ one ] ) % mod ;\n    }\n  }\n  printf( \"%lld\\n\" , ans ) ;\n}\n\nint main() {\n  for ( int i = 0 ; i <= 3000 ; i ++ )\n    C[ i ][ 0 ] = C[ i ][ i ] = 1 ;\n  for ( int i = 1 ; i <= 3000 ; i ++ ) {\n    for ( int j = 1 ; j < i ; j ++ ) {\n      C[ i ][ j ] = ( C[ i - 1 ][ j ] + C[ i - 1 ][ j - 1 ] ) % mod ;\n    }\n  }\n/*\n#ifdef ONLINE_JUDGE\nfreopen(\"input.txt\",\"r\",stdin);\nfreopen(\"output.txt\",\"w\",stdout);\n#endif\n  int Cases;\n  scanf( \"%d\" , &Cases ) ;\n  for ( int cases = 1 ; cases <= Cases ; cases ++ ) {\n*/\n    init() ;\n    process() ;\n/*\n  }\n*/\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nchar s[3111];\nint n,m,p0[3111],p1[3111],l[3111],r[3111],c0,c1,tl[3111],tr[3111];\nint dp[3111][3111];\nint main()\n{\n\tget2(n,m);scanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(s[i]=='0')p0[++c0]=i;\n\t\telse p1[++c1]=i;\n\t}\n\tfor(int i=1;i<=m;i++)get2(l[i],r[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint mn=i,mx=i;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(l[j]<=mn&&mn<=r[j])mn=l[j];\n\t\t\tif(l[j]<=mx&&mx<=r[j])mx=r[j];\n\t\t}\n\t\ttl[i]=mn;tr[i]=mx;\n\t}\n\tdp[1][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<i&&j<=c0;j++)\n\t\t{\n\t\t\tint k=i-1-j;\n\t\t\tif(j<c0&&tl[p0[j+1]]<=i&&i<=tr[p0[j+1]])\n\t\t\t{\n\t\t\t\tdp[i+1][j+1]+=dp[i][j];\n\t\t\t\tif(dp[i+1][j+1]>=mod)dp[i+1][j+1]-=mod;\n\t\t\t}\n\t\t\tif(k<c1&&tl[p1[k+1]]<=i&&i<=tr[p1[k+1]])\n\t\t\t{\n\t\t\t\tdp[i+1][j]+=dp[i][j];\n\t\t\t\tif(dp[i+1][j]>=mod)dp[i+1][j]-=mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintendl(dp[n+1][c0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n// Segment Tree : 時間計算量 O(n log n), 空間計算量 O(n)\n// require  : なし\n// verified : \n//\n// T はモノイド（単位元を持ち，結合則が成り立つ）であることが要求される\ntemplate <class T, class U = size_t>\nstruct SegTree {\n\t// !!! 実装時 t(lhs, rhs) の引数の順番に注意(意図せず可換則が要求されてしまう) !!!\n\ttypedef typename T::V V;\n\texplicit SegTree(U _n = 0, const T &t = T()) : n(1), t(t) {\n\t\twhile (n < _n) n *= 2;\n\t\tv.assign(n * 2 - 1, t.identity());\n\t\tif (n >= 2) {\n\t\t\tfor (U i = n - 2;; --i) {\n\t\t\t\tv[i] = t(v[i * 2 + 1], v[i * 2 + 2]);\n\t\t\t\tif (i == 0) break; // Uが符号無し整数の可能性がある為こう実装している\n\t\t\t}\n\t\t}\n\t}\n\tV operator[](U i) const { return v[n - 1 + i]; }\n\tvoid set(U i, const V & x) {\n\t\ti += n - 1;\n\t\tv[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tv[i] = t(v[i * 2 + 1], v[i * 2 + 2]);\n\t\t}\n\t}\n\t// [a,b)の範囲についてのクエリを返す\n\tV get(U a, U b) const { return q(a, b, 0, 0, n); }\nprivate:\n\t// t : traits のインスタンス\n\t// v : 完全二分木の配列表現\n\t// n : 完全二分木の葉の数\n\tT t;\n\tvector<V> v;\n\tU n;\n\n\t// [a,b)の範囲についてのクエリを返す\n\t// k     : 現在見ている接点の番号\n\t// [l,r) : kに対応した範囲 \n\tV q(U a, U b, U k, U l, U r) const {\n\t\tif (r <= a || b <= l) return t.identity(); // 範囲外\n\t\tif (a <= l && r <= b) return v[k];         // [l,r) ⊂ [a,b)\n\t\t//[l,r)の一部が[a,b)に含まれる\n\t\tU c = (l + r) / 2;\n\t\treturn t(\n\t\t\tq(a, b, k * 2 + 1, l, c),\n\t\t\tq(a, b, k * 2 + 2, c, r)\n\t\t);\n\t}\n};\n\ntemplate <class T>\nstruct SumTrait {\n\ttypedef T V;\n\tV identity() const { return 0; }\n\tV operator()(const V &a, const V &b) const { return a + b; }\n};\n\n\ntemplate<int64_t mod> struct GF {\n\ttypedef int64_t T;\n\tT v;\n\tGF() = default;\n\tGF(T v) : v((v % mod + mod) % mod) {}\n\tGF & operator+=(GF x) { v = (v + x.v) % mod; return *this; }\n\tGF & operator*=(GF x) { v = (v * x.v) % mod; return *this; }\n\tGF & operator-=(GF x) { v = (v - x.v + mod) % mod; return *this; }\n\tGF & operator/=(GF x) { return (*this) *= x.inverse(); }\n\tGF operator+(GF rhs) const { GF lhs = *this; return lhs += rhs; }\n\tGF operator*(GF rhs) const { GF lhs = *this; return lhs *= rhs; }\n\tGF operator-(GF rhs) const { GF lhs = *this; return lhs -= rhs; }\n\tGF operator/(GF rhs) const { GF lhs = *this; return lhs /= rhs; }\n\tGF inverse() const { // http://topcoder.g.hatena.ne.jp/iwiwi/20130105/1357363348\n\t\tT a = v, b = mod, x = 1, y = 0;\n\t\twhile (b) {\n\t\t\tT t = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(x -= t * y, y);\n\t\t}\n\t\treturn x;\n\t}\n\tGF pow(T n) const {\n\t\tGF r; r.v = 1;\n\t\tfor (T x = v; n > 0; n >>= 1) {\n\t\t\tif (n & 1) (r.v *= x) %= mod;\n\t\t\t(x *= x) %= mod;\n\t\t}\n\t\treturn r;\n\t}\n\ttypedef size_t U;\n\tstatic GF fact(U n) {\n\t\tstatic vector<GF> data;\n\t\tU m = data.size();\n\t\tif (m <= n) {\n\t\t\tdata.resize(n + 1);\n\t\t\tif (m == 0) { data[0].v = 1; m++; }\n\t\t\tfor (U i = m; i < n + 1; ++i) data[i] = data[i - 1] * i;\n\t\t}\n\t\treturn data[n];\n\t}\n\tstatic GF nCr(U n, U r) { return fact(n) / fact(r) / fact(n - r); }\n\tstatic GF nPr(U n, U r) { return fact(n) / fact(r); }\n};\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tll n, m; cin >> n >> m;\n\tstring S;\n\tvl L, R;\n\t{ // 関係ない部分の除去\n\t\tstring s; cin >> s;\n\t\tvl l(m), r(m); \n\t\tREP(i, m) {\n\t\t\tcin >> l[i] >> r[i];\n\t\t\tl[i]--; r[i]--;\n\t\t}\n\n\t\tvl imos(n + 1, 0);\n\t\tREP(i, m) {\n\t\t\timos[l[i]]++;\n\t\t\timos[r[i] + 1]--;\n\t\t}\n\t\tFOR(i, 1, n + 1) imos[i] += imos[i - 1];\n\n\t\tSegTree<SumTrait<ll>> st(n);\n\t\tREP(i, n) if (imos[i] > 0) {\n\t\t\tst.set(i, 1);\n\t\t\tS.push_back(s[i]);\n\t\t}\n\t\tll mar = 0;\n\t\tREP(i, m) if (mar < st.get(0, r[i] + 1)) {\n\t\t\tif (i > 0 && L.back() == st.get(0, l[i] + 1) - 1) {\n\t\t\t\tR.back() = mar = st.get(0, r[i] + 1);\n\t\t\t} else {\n\t\t\t\tL.push_back(st.get(0, l[i] + 1) - 1);\n\t\t\t\tR.push_back(mar = st.get(0, r[i] + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tconst ll N = S.size(), M = R.size();\n\tSegTree<SumTrait<ll>> zero(N), one(N);\n\tREP(i, N) (S[i] == '0' ? zero : one).set(i, 1);\n\t\n\tll maxzero = zero.get(0, N + 1);\n\tvvl dp(M + 1, vl(maxzero + 1, -1));\n\tdp[0][0] = 1;\n\tREP(i, M) REP(j, maxzero + 1) if(dp[i][j] != -1){\n\t\tll k = L[i] - j; // 使った1の数\n\t\tll range = (i == M - 1 ? R[i] : L[i + 1]) - L[i];\n\t\tll zeroma = zero.get(0, R[i]) - j;\n\t\tll onema = one.get(0, R[i]) - k;\n\t\tFOR(l, max(0ll, range - onema), min(range, zeroma) + 1) {\n\t\t\tif (l + j > maxzero) continue;\n\t\t\tauto x = GF<mod>::nCr(range, l) * dp[i][j];\n\t\t\tif (dp[i + 1][l + j] == -1) dp[i + 1][l + j] = x.v;\n\t\t\telse dp[i + 1][l + j] = (GF<mod>(dp[i + 1][l + j]) + x).v;\n\t\t}\n\t}\n\t\n\tcout << dp[M][maxzero] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long to; long long len;\n\tbool operator<(const edge& rhs) const {\n\t\treturn len > rhs.len;\n\t}\n};\n\nll const MAX = 3e3 + 5;\nll dp[MAX][MAX] = {};\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y - MOD) + MOD;\n}\n\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\nll l[MAX], r[MAX];\nll sum0[MAX] = {}, sum1[MAX] = {};\n\nint main() {\n\tll n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tREP(i, 1, m) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tll cur_0 = 0, cur_1 = 0;\n\tll header = 0;\n\tll cur_i = 1;\n\tdp[0][0] = 1;\n\tREP(i, 1, n) {\n\t\tsum0[i] = sum0[i - 1] + (s[i - 1] == '0');\n\t\tsum1[i] = sum1[i - 1] + (s[i - 1] == '1');\n\t}\n\tl[m + 1] = n + 1; r[m + 1] = n + 1;\n\tREP(i, 1, m + 1) {\n\t\twhile (cur_i < l[i]) {\n\t\t\theader = max(header, cur_i);\n\t\t\tll t1 = max(ll(0), cur_i - sum0[header]);\n\t\t\tll t2 = min(cur_i, sum1[header]);\n\t\t\tREP(j, t1,t2) {\n\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j]);\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_i++;\n\t\t}\t\n\t\theader = max(header, r[i]);\n\n\t}\n\tcout << dp[n][sum1[n]] << endl;\n\t/*\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  string s;\n  cin >> n >> m >> s;\n\n  vector<int> MR(n);\n  REP(i,n) MR[i] = i+1;\n  REP(i,m){\n    int l,r;\n    cin >> l >> r;\n    FOR(j,l-1,r) MR[j] = max(MR[j],r);\n  }\n\n  vector<int> cnt0(n+1,0);\n  REP(i,n) cnt0[i+1] = cnt0[i] + (s[i]=='0');\n\n  mat dp(n+1,vec(n+1,0));\n  dp[0][0] = 1;\n  REP(i,n){\n    int zero = cnt0[MR[i]];\n    //cout << zero SP MR[i] SP cnt0[MR[i]] << endl;\n    REP(j,n+1){\n      if(j < zero) dp[i+1][j+1] += dp[i][j];\n      if(i-j < MR[i]-zero) dp[i+1][j] += dp[i][j];\n    }\n    //REP(j,n+1) cout << dp[i+1][j].value() << \" \";\n    //cout << endl << endl;\n  }\n\n  mint ans = 0;\n  REP(i,n+1) ans += dp[n][i];\n\n  cout << ans.value() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=3005,P=1e9+7;\n\nint fac[N],ifac[N];\nint fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\nint C(int n,int m){if(n<m)return 0;return (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;}\n\nint n,m,f[N],L,R,sum[N];\nchar str[N];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+(str[i]&1);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[n]=fpow(fac[n],P-2);\n\tfor(int i=n;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tf[0]=1;\n\tfor(int i=1,l,r;i<=m;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(r<=R)continue;\n\t\tif(R<l){\n\t\t\tint t=0;\n\t\t\tfor(int i=0;i<=n;i++)if(f[i])t=(t+(ll)C(R-L+1,i)*f[i])%P,f[i]=0;\n\t\t\tL=l,R=r,f[sum[R]-sum[L-1]]=t;\n\t\t}else{\n\t\t\twhile(L<l){\n\t\t\t\tfor(int i=1;i<=n;i++)if(f[i])(f[i-1]+=f[i])%=P;\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tfor(int i=R-L+2;i<=n;i++)f[i]=0;\n\t\t\tint t=sum[r]-sum[R];\n\t\t\tfor(int i=n,x;i>=0;i--)if(f[i])x=f[i],f[i]=0,f[i+t]=x;\n\t\t\tR=r;\n\t\t}\n\t}\n\tint t=0;\n\tfor(int i=0;i<=n;i++)if(f[i])t=(t+(ll)f[i]*C(R-L+1,i))%P;\n\tprintf(\"%d\\n\",t);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 3010;\nll dp[N][N];\n\n\nconst int DEBUG = 0;\n\n\nint main(void){\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  VI que(n, 0);\n  REP(i, 0, m) {\n    int l, r;\n    cin >> l >> r;\n    l--, r--;\n    que[l] = max(que[l], r);\n  }\n  REP(i, 0, n - 1) {\n    que[i + 1] = max(que[i + 1], que[i]);\n  }\n  VI zs(n + 1), os(n + 1);\n  REP(i, 0, n) {\n    zs[i + 1] = zs[i] + (s[i] == '0');\n    os[i + 1] = os[i] + (s[i] == '1');\n  }\n  dp[0][0] = 1;\n  REP(i, 1, n + 1) {\n    int end = que[i - 1];\n    int zero = zs[end + 1];\n    int one = os[end + 1];\n    if (DEBUG) {\n      cerr << \"[\" << i << \"]:\" << zero << \" \" << one << endl;\n    }\n    REP(j, 0, i + 1) {\n      ll &ret = dp[i][j];\n      // adds zero\n      if (j <= zero && j >= 1) {\n\tret += dp[i - 1][j - 1];\n\tret %= mod;\n      }\n      // adds one\n      if (i - j <= one && j <= i - 1) {\n\tret += dp[i - 1][j];\n\tret %= mod;\n      }\n    }\n    if (DEBUG) {\n      cerr << \"dp[\" << i << \"]:\";\n      REP(j, 0, i + 1) { cerr << \" \" << dp[i][j]; }\n      cerr << endl;\n    }\n  }\n  ll tot = 0;\n  REP(i, 0, n) {\n    tot = (tot + dp[n][i]) % mod;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst int maxn = 3030;\n\n\n\nint n, m;\nstring s;\nint a[maxn];\nint b[maxn];\nll dp[maxn][maxn];//# ways to fill first i elems, holding j 1's\n\n\n\nvoid add(ll& x, ll y) {\n    x %= mod;\n    y %= mod;\n    x += y;\n    x %= mod;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>m;\n    cin>>s;\n    for (int i=0; i<n; i++) {\n\ta[i]=(s[i]-'0');\n\tb[i]=i+1;\n    }\n\n    for (int i=0; i<m; i++) {\n\tint l,r; cin>>l>>r;\n\t--l; --r;\n\tb[l]=max(b[l],r+1);\n    }\n\n    for (int i=1; i<n; i++) {\n\tb[i]=max(b[i],b[i-1]);\n    }\n\n    dp[0][0]=1;\n    for (int i=0, j=0; i<n; i++) {\n\tint ones = 0;\n\twhile (j<b[i]) ones+=a[j++];\n\n\tfor (int x=0; x<=n; x++) {\n\t    if (dp[i][x] == 0) continue;\n\t    int cur=x+ones;\n\n\t    //put 1 at ith index\n\t    if (cur>0) {\n\t\tadd(dp[i+1][cur-1], dp[i][x]);\n\t    }\n\n\t    // put 0 at ith index\n\t    if (cur < j-i) {\n\t\tadd(dp[i+1][cur], dp[i][x]);\n\t    }\n\t}\n    }\n\n    ll ans = dp[n][0];\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    cout<<ans<<endl;\n  \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<int, int> P;\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nll dp[3001][3001];\nint cnt[3000];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tcnt[i + 1] = S[i] - '0' + cnt[i];\n\t}\n\tvector<P> v;\n\tv.emplace_back(0, 0);\n\tint prev_r = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (prev_r < r) {\n\t\t\tv.emplace_back(l, r);\n\t\t\tprev_r = r;\n\t\t}\n\t}\n\tv.emplace_back(N + 1, N + 1);\n\tcomb_init(N);\n\tdp[0][0] = 1;\n\tfor (int i = 0; i + 2 < v.size(); i++) {\n\t\tint len = max(v[i].second - v[i + 1].first + 1, 0);\n\t\tint nxt_len = max(v[i + 1].second - v[i + 2].first + 1, 0);\n\t\tint rest = (v[i + 1].second - v[i + 1].first + 1) - nxt_len;\n\t\tfor (int j = 0; j <= len; j++) {\n\t\t\tint one = j + cnt[v[i + 1].second] - cnt[v[i].second];\n\t\t\tfor (int k = 0; k <= min(one, rest); k++) {\n\t\t\t\tif (one - k > nxt_len) continue;\n\t\t\t\t(dp[i + 1][one - k] += dp[i][j] * comb(rest, k)) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[v.size() - 2][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\n\tassert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\n#define MP make_pair\n#define ls (o << 1)\n#define rs (o << 1 | 1)\n#define mid ((L + R) >> 1)\n#define eps (1e-5)\nusing namespace std;\ntypedef long long LL;\nconst LL mod = 1e9 + 7;\nint n, m;\ntypedef pair<int, int> PII;\nLL c[3050][3050];\nint l[3050], r[3050], pre[3050];\nchar s[3050];\nLL dp[3050][3050];\nint have(int l, int r) { return pre[r] - pre[l - 1]; }\nint have(int mark) { return pre[r[mark]] - pre[l[mark] - 1]; }\nvoid add(LL &o, LL p) { o = (o + p) % mod; }\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j) {\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n        }\n    }\n    scanf(\"%s\", s + 1);\n    for (int i = 1; s[i]; ++i) {\n        pre[i] = pre[i - 1] + s[i] - '0';\n    }\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]);\n        if (i && r[i] <= r[i - 1]) {\n            m--;\n            i--;\n        }\n    }\n    l[m] = n + 1;\n    pre[n + 1] = pre[n];\n    r[m] = n + 1;\n    dp[0][have(0)] = 1;\n    for (int i = 0; i < m; ++i) {\n        //        for(int j = 0;j <= n; ++j){\n        //            if(dp[i][j])printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n        //        }\n        if (r[i] < l[i + 1]) {\n            // cout <<have(i + 1) <<endl;\n            for (int j = 0; j <= n; ++j) {\n                add(dp[i + 1][have(i + 1)],\n                    dp[i][j] * c[r[i] - l[i] + 1][j] % mod);\n            }\n            continue;\n        }\n        int L = r[i] - l[i + 1] + 1;\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= L; ++k) {\n                if (j < k)\n                    break;\n                int qian = l[i + 1] - l[i];\n                if (qian < j - k)\n                    continue;\n                add(dp[i + 1][have(r[i] + 1, r[i + 1]) + k],\n                    dp[i][j] * c[qian][j - k] % mod);\n            }\n        }\n    }\n    printf(\"%lld\\n\", dp[m][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int mod=1000000007;\nint N,M,R[3010],sum[3010],f[3010][3010];\nchar S[3010];\nint main(){\n\tscanf(\"%d%d%s\",&N,&M,S);\n\tfor(int i=0;i<N;i++)R[i]=i+1;\n\tfor(int i=0;i<M;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(r>R[l-1])R[l-1]=r;\n\t}\n\tfor(int i=0;i<N;i++)if(R[i]>R[i+1])R[i+1]=R[i];\n\tfor(int i=0;i<N;i++)sum[i+1]=sum[i]+S[i]-'0';\n\tf[0][0]=1;\n\tfor(int i=0;i<N;i++)for(int j=0;j<=sum[N];j++)if(f[i][j]){\n\t\tif(sum[R[i]]-j<R[i]-i)(f[i+1][j]+=f[i][j])%=mod;\n\t\tif(sum[R[i]]-j>0)(f[i+1][j+1]+=f[i][j])%=mod;\n\t}\n\tprintf(\"%d\\n\",f[N][sum[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint main() {\n  int N, M, R[3000];\n  memset(R, -1, sizeof(R));\n\n  string S;\n\n  cin >> N >> M;\n  cin >> S;\n  for(int i = 0; i < M; i++) {\n    int l, r;\n    cin >> l >> r;\n    --l, --r;\n    R[l] = max(R[l], r);\n  }\n  for(int i = 0; i < N; i++) {\n    if(i > 0) R[i] = max(R[i], R[i - 1]);\n    R[i] = max(R[i], i);\n  }\n\n  vector< int > sum(N + 1);\n  int one = 0;\n  for(int i = 0; i < N; i++) {\n    one += S[i] == '1';\n    sum[i] = one;\n  }\n\n  vector< int > dp(3001);\n  dp[0] = 1;\n  for(int i = 0; i < N; i++) {\n    vector< int > dp2(3001);\n    for(int j = 0; j < dp.size(); j++) {\n      int rest = sum[R[i]] - j;\n      if(dp[j] == 0) continue;\n      if(rest > 0) (dp2[j + 1] += dp[j]) %= mod;\n      if(R[i] - i + 1 != rest) (dp2[j] += dp[j]) %= mod;\n    }\n    dp.swap(dp2);\n  }\n  cout << dp[sum[N - 1]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tptmp.erase(std::unique(ptmp.begin(), ptmp.end()), ptmp.end());\n\tvector<int> lefs;\n\tfor(int i=0;i<ptmp.size();i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second){\n\t\tif( i == ptmp.size()-1 || ptmp[i].first != ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tdp[i][ct[i]] += dp[i-1][ct[i-1]];\n\t\t\tdp[i][ct[i]]%=inf;\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=3010,p=1e9+7;\nint inc(int x,int y){x+=y;return x>=p?x-p:x;}\nint mul(int x,int y){return (ll)x*y%p;}\nint n,m,top,l[N],r[N],cnt[N];\nchar s[N];\nint dp[N][N],C[N][N];//dp[i][j]表示填完了前l[i+1]-1个，手里剩下j个1的方案数\nint calc(){\n\tfor (int i=0;i<=top;i++)\n\tfor (int j=0;j<=n;j++)\n\t\tdp[i][j]=0;\n\tdp[0][0]=1;l[0]=l[1];r[0]=l[1]-1;\n\tfor (int i=0;i<top;i++){\n\t\tint len=l[i+1]-l[i],one=cnt[r[i+1]]-cnt[r[i]];\n\t\tfor (int j=0;j<=n;j++){\n\t\t\tint v=dp[i][j],zero=r[i]-l[i]+1-j;\n\t\t\tfor (int k=max(0,len-zero);k<=j&&k<=len;k++)//考虑一下填多少个1\n\t\t\t\tdp[i+1][j-k+one]=inc(dp[i+1][j-k+one],mul(v,C[len][k]));\n\t\t}\n\t}\n\tl[0]=r[0]=0;\n\tint ans=0;\n\tfor (int j=0;j<=n;j++) ans=inc(ans,mul(dp[top][j],C[r[top]-l[top]+1][j]));\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor (int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) C[i][j]=inc(C[i-1][j-1],C[i-1][j]);\n\t}\n\tfor (int i=1;i<=n;i++) cnt[i]=cnt[i-1]+s[i]-'0';\n\tint ans=1;\n\tfor (int i=1;i<=m;i++){\n\t\tint L,R;\n\t\tscanf(\"%d%d\",&L,&R);\n\t\tif (top&&L>r[top]) ans=mul(ans,calc()),top=0;\n\t\tif (R>r[top]) top++,l[top]=L,r[top]=R;\n\t}\n\tans=mul(ans,calc());\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(0,x-y+a[y]) ,r=min(prer+x-v[i].fi+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(0,x-y+a[y]) ,r=min(prer+y-x+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- ModInt Library {{{ ///\n#include <ostream>\ntemplate < ll mod = (ll) 1e9 + 7 >\nstruct ModInt {\n  // math {{{\n  static inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll d;\n    return b == 0 ? (x = 1, y = 0, a) : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline ll modinv(ll a) {\n    ll x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0) x += mod;\n    return x;\n  }\n  static inline ll modpow(ll a, ll b) {\n    if(b < 0) b = -b, a = modinv(a);\n    ll r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  ll val;\n  constexpr ModInt() : val(0) {}\n  constexpr ModInt(ll t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModInt(ll t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // ModInt <arithmetic-operator>[=] ModInt {{{\n  ModInt operator+(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModInt operator-(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModInt operator*(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModInt operator/(ModInt const &rhs) const {\n    ModInt tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModInt &operator+=(ModInt const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModInt &operator-=(ModInt const &rhs) { return *this += -rhs; }\n  ModInt &operator*=(ModInt const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModInt &operator/=(ModInt const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModInt operator++(int) {\n    ModInt tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModInt operator--(int) {\n    ModInt tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModInt &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModInt &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModInt operator-() const { return ModInt(val == 0 ? 0 : mod - val, 0); }\n  // ModInt <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModInt operator+(T const &rhs) const {\n      return ModInt(val + rhs % mod);\n    }\n  template < typename T >\n    ModInt operator-(T const &rhs) const {\n      return ModInt(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModInt operator*(T const &rhs) const {\n      return ModInt(val * (rhs % mod));\n    }\n  template < typename T >\n    ModInt operator/(T const &rhs) const {\n      return ModInt(val * modinv(rhs));\n    }\n  template < typename T >\n    ModInt &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModInt &operator/=(T const &rhs) {\n      val = val * modinv(rhs, mod) % mod;\n      return *this;\n    }\n  // }}}\n  ModInt inv() const { return ModInt(modinv(val), 0); }\n  ModInt operator~() const { return inv(); }\n  friend ostream &operator<<(ostream &os, ModInt const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // T <arithmetic-operator> ModInt {{{\n  friend constexpr ModInt operator+(ll a, ModInt const &mv) {\n    return ModInt(a % mod + mv.val);\n  }\n  friend constexpr ModInt operator-(ll a, ModInt const &mv) {\n    return ModInt(a % mod - mv.val);\n  }\n  friend constexpr ModInt operator*(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModInt operator/(ll a, ModInt const &mv) {\n    return ModInt((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModInt operator^(ll x) const { return pow(*this, x); }\n  ModInt &operator^=(ll x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModInt pow(ModInt x, ll y) { return ModInt(modpow(x.val, y), 0); }\n  // }}}\n};\n/// }}}--- ///\n\nusing mint = ModInt<>;\n\n\nconst int N = 3001;\n\nint rms[N];\n\nint n, m;\nstring s;\nconstexpr int mod = 1e9 + 7;\n\nmint dp[N][N];\nint cnt[N];\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n\n  for(int i = 0; i < n; i++) rms[i] = i;\n  \n  for(int i = 0; i < n; i++) {\n    cnt[i] = s[i] == '1';\n    if(i) cnt[i] += cnt[i-1];\n  }\n\n  for(int i = 0; i < m; i++) {\n    int l, r;\n    cin >> l >> r;\n    l--; r--;\n    rms[l] = max(rms[l], r);\n  }\n\n  for(int i = 1; i < n; i++) rms[i] = max(rms[i], rms[i-1]);\n\n  dp[0][0] = 1;\n\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j <= i; j++) {\n      if(dp[i][j].val == 0) continue;\n      int ones = cnt[rms[i]];\n      int zeros = rms[i] + 1 - ones;\n      ones -= j;\n      zeros -= i - j;\n      if(ones >= 0 && zeros >= 0) {\n        if(ones >= 1) {\n          dp[i+1][j+1] += dp[i][j];\n        }\n        if(zeros >= 1) {\n          dp[i+1][j] += dp[i][j];\n        }\n      }\n    }\n  }\n\n  cout << dp[n][cnt[n-1]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ninline int Min(const int a,const int b){return a<b?a:b;}\ninline int Max(const int a,const int b){return a>b?a:b;}\n\nint n,m,Sum[3005],r[3005],f[3005][3005];\nchar s[3005];\nconst int p=1000000007;\n\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1);\n    for(int i=1;i<=n+1;++i)Sum[i]=Sum[i-1]+(s[i]&1),r[i]=i;\n    for(int i=1,L,R;i<=m;++i)scanf(\"%d%d\",&L,&R),r[L]=Max(r[L],R);\n    for(int i=1;i<=n;++i)r[i]=Max(r[i],r[i-1]);\n    for(int i=f[1][Sum[r[1]]]=1;i<=n;++i)\n        for(int j=0;j<=n;++j)\n            if(f[i][j])\n            {\n                int L=r[i]+1,R=r[i+1];\n                int c1=j,c0=r[i]-i+1-j,Nc=Sum[R]-Sum[L-1];\n                if(c0)(f[i+1][j+Nc]+=f[i][j])%=p;\n                if(c1)(f[i+1][j+Nc-1]+=f[i][j])%=p;\n            }\n    printf(\"%d\\n\",f[n+1][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n///12:36\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 3005;\ntypedef long long ll;\n\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\nint inm(int x, int y) { return (ll)x*y%Mod; }\n\nint n, m, X, Y, ones, cate, i, j, k, kmin, kmax, nr, ans, rest;\nint x[Nmax], y[Nmax], nr1[Nmax], dp[Nmax][Nmax], comb[Nmax][Nmax];\nchar a[Nmax];\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n //   freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> m;\n    cin >> (a+1);\n    for(i=1; i<=n; ++i) nr1[i] = nr1[i-1] + (a[i] == '1');\n\n    for(i=1; i<=m; ++i)\n    {\n        cin >> X >> Y;\n        if(Y > y[nr]) x[++nr] = X, y[nr] = Y;\n    }\n\n    for(i=0; i<=n; ++i)\n    {\n        comb[i][0] = 1;\n        for(j=1; j<=i; ++j)\n        {\n            comb[i][j] = comb[i-1][j];\n            add_to(comb[i][j], comb[i-1][j-1]);\n        }\n    }\n\n    ans = 1;\n\n    for(i=1; i<=nr; ++i)\n    if(i>1 && i<nr && x[i] <= y[i-1] && x[i+1] <= y[i])\n    {\n        ones = nr1[y[i]] - nr1[y[i-1]];\n        cate = x[i+1] - x[i];\n        rest = y[i] - x[i+1] + 1;\n\n        for(j=0; j + ones <= rest + cate; ++j)\n        {\n            kmin = max(0, j+ones-rest);\n            kmax = min(j+ones, cate);\n\n            for(k=kmin; k<=kmax; ++k)\n                add_to(dp[i+1][j+ones-k], inm(dp[i][j], comb[cate][k]));\n        }\n    }\n    else if(i<nr && x[i+1] <= y[i])\n    {\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        cate = x[i+1] - x[i];\n        rest = y[i] - x[i+1] + 1;\n\n        kmin = max(0, ones-rest);\n        kmax = min(ones, cate);\n        for(k=kmin; k<=kmax; ++k)\n            add_to(dp[i+1][ones-k], inm(ans, comb[cate][k]));\n    }\n    else if(i>1 && x[i] <= y[i-1])\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[y[i-1]];\n\n        ans = 0;\n        for(j=0; ones + j <= cate; ++j)\n            add_to(ans, inm(dp[i][j], comb[cate][ones + j]));\n    }\n    else\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        ans = inm(ans, comb[cate][ones]);\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n///12:36\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 3005;\ntypedef long long ll;\n\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\nint inm(int x, int y) { return (ll)x*y%Mod; }\n\nint n, m, X, Y, ones, cate, i, j, k, kmin, kmax, nr, ans, rest;\nint x[Nmax], y[Nmax], nr1[Nmax], dp[Nmax][Nmax], comb[Nmax][Nmax];\nchar a[Nmax];\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n //   freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> m;\n    cin >> (a+1);\n    for(i=1; i<=n; ++i) nr1[i] = nr1[i-1] + (a[i] == '1');\n\n    for(i=1; i<=m; ++i)\n    {\n        cin >> X >> Y;\n        if(Y > y[nr]) x[++nr] = X, y[nr] = Y;\n    }\n\n    for(i=0; i<=n; ++i)\n    {\n        comb[i][0] = 1;\n        for(j=1; j<=i; ++j)\n        {\n            comb[i][j] = comb[i-1][j];\n            add_to(comb[i][j], comb[i-1][j-1]);\n        }\n    }\n\n    ans = 1;\n\n    for(i=1; i<=nr; ++i)\n    if(i>1 && i<nr && x[i] <= y[i-1] && x[i+1] <= y[i])\n    {\n        ones = nr1[y[i]] - nr1[y[i-1]];\n        cate = x[i+1] - x[i];\n        rest = y[i] - x[i+1] + 1;\n\n        for(j=0; j + ones <= n; ++j)\n        {\n            kmin = max(0, j+ones-rest);\n            kmax = min(j+ones, cate);\n\n            for(k=kmin; k<=kmax; ++k)\n                add_to(dp[i+1][j+ones-k], inm(dp[i][j], comb[cate][k]));\n        }\n    }\n    else if(i<nr && x[i+1] <= y[i])\n    {\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        cate = x[i+1] - x[i];\n        rest = y[i] - x[i+1] + 1;\n\n        kmin = max(0, ones-rest);\n        kmax = min(ones, cate);\n        for(k=kmin; k<=kmax; ++k)\n            add_to(dp[i+1][ones-k], inm(ans, comb[cate][k]));\n    }\n    else if(i>1 && x[i] <= y[i-1])\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[y[i-1]];\n        int sum = 0;\n        for(j=0; ones + j <= cate; ++j)\n            add_to(sum, inm(dp[i][j], comb[cate][ones + j]));\n        ans = inm(ans, sum);\n    }\n    else\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        ans = inm(ans, comb[cate][ones]);\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef long long ll;\n\nint N,M,m;\nll sum[300030] = {0};\nll que[300030][2] = {0};\nll F[300030] = {0},R[300003] = {0};\nll dp[3030][3030];\nvector<int> QL,QR;\n\nll con(ll a,ll b)\n{\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nll P(ll n,ll s)\n{//printf(\"  %lld %lld\\n\",n,s);\n    if(dp[n][s] != -1)return dp[n][s];\n    ll res = 0;\n    ll l,r;\n    if(n == QR.size() - 1)\n    {\n        l = QL[n];r = QR[n];\n        res = con(r - l + 1,sum[r] - s);\n        return res;\n    }\n    l = QL[n],r = min(QR[n],QL[n + 1] - 1);\n    ll mem = sum[QR[n]] - s;\n    ll p = 0;\n    if(QR[n] < QL[n + 1])p = sum[QL[n + 1]] - sum[QR[n]];\n\n    //printf(\" %lld %lld %lld %lld\\n\",l,r,mem,(r - l + 1) - (QR[n] - l + 1 - mem));\n    for(int i = max((ll)0,(r - l + 1) - (QR[n] - l + 1 - mem)); i <= mem; i++)\n    {\n        res += P(n + 1,s + i + p) * con(r - l + 1,i);\n        res %= mod;\n    }\n    return dp[n][s] = res;\n}\n\nll power(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = power(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < 3030; i++)for(int j = 0; j < 3030; j++)dp[i][j] = -1;\n    F[0] = 1;\n    for(int i = 1; i <= 3030; i++)F[i] = F[i - 1] * i;\n    for(int i = 0; i <= 3030; i++)R[i] = power(F[i],mod - 2);\n    for(int i = 1; i <= N; i++)\n    {\n        char c;\n        scanf(\" %c\",&c);\n        sum[i] = sum[i - 1] + (c == '1');\n    }\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%d%d\",&que[i][0],&que[i][1]);\n        if(i != 0)que[i][1] = max(que[i][1],que[i - 1][1]);\n    }\n    for(int i = 0; i < M; i++)\n    {\n        if(i == 0)\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n        if(QL[QL.size() - 1] == que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QR[QR.size() - 1] = que[i][1];\n        }\n        else if(QL[QL.size() - 1] < que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n    }\n    /*\n    for(int i = 0; i < QR.size(); i++)\n    {\n        printf(\" %d %d\\n\",QL[i] ,QR[i]);\n    }\n    */\n    printf(\"%lld\\n\",P(0,sum[QL[0] - 1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll M = 1000000007;\nchar str[3010];\nint n, m, c = 1, sum[3010], s[3010], e[3010];\nll dp[3010][3010], cm[3010][3010], chk[3010][3010];\n\nint get(int s, int e){ return sum[e] - sum[s - 1]; }\n\nll f(int x, int y){\n\tif(x > m) return 1;\n\tif(y < 0 || e[x] - s[x] + 1 < y) return 0;\n\tif(chk[x][y]) return dp[x][y];\n\tif(e[x] < s[x + 1]){\n\t\tdp[x][y] = cm[e[x] - s[x] + 1][y] * f(x + 1, get(s[x + 1], e[x + 1])) % M;\n\t}\n\telse{\n\t\tfor(int i = max(0, y - (e[x] - s[x + 1] + 1)); i <= min(s[x + 1] - s[x], y); i++){\n\t\t\tdp[x][y] = (dp[x][y] + cm[s[x + 1] - s[x]][i] *\n\t\t\t\t\t\tf(x + 1, y - i + get(e[x] + 1, e[x + 1]))) % M;\n\t\t}\n\t}\n\tchk[x][y] = 1;\n\treturn dp[x][y];\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, str + 1);\n\tfor(int i = 1; i <= n; i++) sum[i] = sum[i - 1] + (str[i] == '1');\n\tfor(int x, y, l = 0; m--; ){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(y <= l) continue;\n\t\tl = y;\n\t\tif(s[c - 1] == x) e[c - 1] = y;\n\t\telse{\n\t\t\ts[c] = x; e[c] = y;\n\t\t\tc++;\n\t\t}\n\t}\n\tm = c - 1;\n\ts[m + 1] = n + 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tcm[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++) cm[i][j] = (cm[i - 1][j - 1] + cm[i - 1][j]) % M;\n\t}\n\tprintf(\"%lld\\n\", f(1, get(s[1], e[1])));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read(); r[i]=max(r[i-1],r[i]);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tl[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<(f[m][0]+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k>0){\n        if(k%2==1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k/=2;\n    }\n    return ans;\n}\nll inv(ll a){\n  return powmod(a, MOD-2);\n}\nint main()\n{\n\tint n, m;\n  cin>>n>>m;\n  string s;\n  cin>>s;\n  int ct[3001];\n  ct[0]=0;\n  for(int i=1; i<=n; i++){\n    ct[i]=ct[i-1];\n    if(s[i-1]=='1') ct[i]++;\n  }\n  vector<P> v[3001];\n  int t=0;\n  for(int i=0; i<m; i++){\n    int l0, r0;\n    cin>>l0>>r0;\n    if(v[t].empty() || (v[t].back()).second<r0){\n      if(!v[t].empty() && (v[t].back()).second<l0) t++;\n      v[t].push_back(P(l0, r0));\n    }\n  }\n  ll f[3001], invf[3001];\n  f[0]=1;\n  for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n  invf[n]=inv(f[n]);\n  for(ll i=n-1; i>=0; i--){\n    invf[i]=invf[i+1]*(i+1)%MOD;\n  }\n  ll ans=1;\n  for(int k=0; k<=t; k++){\n    if(v[k].size()==1){\n      int l0=v[k][0].first, r0=v[k][0].second;\n      ans=ans*f[r0-l0+1]%MOD*invf[ct[r0]-ct[l0-1]]%MOD*invf[r0-l0+1-ct[r0]+ct[l0-1]]%MOD;\n      continue;\n    }\n    ll dp[2][3001]={};\n    int l0=v[k][0].first, r0=v[k][0].second, l1=v[k][1].first;\n    for(int i=max(0, ct[r0]-ct[l0-1]-l1+l0); i<=min(ct[r0]-ct[l0-1], r0-l1+1); i++){\n      int c0=ct[r0]-ct[l0-1]-i, d0=l1-l0;\n      dp[0][i]=f[d0]*invf[c0]%MOD*invf[d0-c0]%MOD;\n    }\n    for(int i=1; i<=v[k].size()-2; i++){\n      int l0=v[k][i].first, r0=v[k][i].second, l1=v[k][i+1].first, rp=v[k][i-1].second;\n      int c0=ct[r0]-ct[rp];\n      for(int j=0; j<=n; j++){\n        dp[i%2][j]=0;\n        if(j>r0-l1+1) continue;\n        for(int p=max(0, j-c0); p<=min(n, j-c0+l1-l0); p++){\n          dp[i%2][j]+=(dp[(i+1)%2][p]*f[l1-l0]%MOD*invf[c0+p-j]%MOD*invf[l1-l0-c0-p+j]%MOD);\n          dp[i%2][j]%=MOD;\n        }\n      }\n    }\n    int par=v[k].size()%2;\n    r0=(v[k].back()).second, l0=(v[k].back()).first;\n    int rp=v[k][v[k].size()-2].second;\n    int c=ct[r0]-ct[rp];\n    ll ans1=0;\n    for(int i=0; i<=r0-l0+1-c; i++){\n      ans1+=(dp[par][i]*f[r0-l0+1]%MOD*invf[i+c]%MOD*invf[r0-l0+1-i-c]%MOD);\n      ans1%=MOD;\n    }\n    ans=ans*ans1%MOD;\n  }\n  cout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 3100\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint f[N][N],rt[N],sum[N],n,m;\nchar ch[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint main()\n{\n\tn=read(),m=read(); scanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)\tsum[i]=sum[i-1]+ch[i]-'0',rt[i]=i;\n\trt[n+1]=n+1,sum[n+1]=sum[n];\n\tfor(int i=1;i<=m;i++){int pos=read(); rt[pos]=max(read(),rt[pos]);}\n\tfor(int i=1;i<=n;i++)\trt[i]=max(rt[i-1],rt[i]); f[1][sum[rt[1]]]=1;\n\tfor(int i=1;i<=n;i++)\tfor(int j=0;j<n;j++)\tif(f[i][j])\n\t{\n\t\tint l=rt[i]+1,r=rt[i+1],o=j,z=rt[i]+1-i-j;\n\t\tif(z)\tupd(f[i+1][j+sum[r]-sum[l-1]],f[i][j]);\n\t\tif(o)\tupd(f[i+1][j+sum[r]-sum[l-1]-1],f[i][j]);\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nconst int mod = 1e9 + 7;\nint N, K;\nint r[3005], mxr[3005];\nint sum[3005][2];\nchar s[3005];\nint dp[3005][3005];\n\nint count0(int st, int dr)\n{\n    return (sum[dr][0] - sum[st - 1][0]);\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d%d\\n\", &N, &K);\n\n    for(int i = 1; i <= N; i++)\n        r[i] = i;\n\n    scanf(\"%s\", s + 1);\n\n    for(int i = 1; i <= N; i++)\n    {\n        sum[i][0] = sum[i - 1][0];\n        sum[i][1] = sum[i - 1][1];\n        sum[i][ s[i] - '0' ]++;\n    }\n\n    for(int i = 1; i <= K; i++)\n    {\n        int st, dr;\n        scanf(\"%d%d\", &st, &dr);\n        r[st] = max(r[st], dr);\n    }\n\n    for(int i = 1; i <= N; i++)\n        mxr[i] = max(mxr[i - 1], r[i]);\n    mxr[N + 1] = mxr[N];\n\n    /// DP[i][j] = fixam primele i - 1 si avem j zero pentru [ i, mxr[i] ]\n\n    dp[1][ sum[ r[1] ][0] ] = 1;\n    for(int i = 1; i <= N; i++)\n        for(int j = 0; j <= N; j++)\n            if(dp[i][j])\n            {\n                int cnt0 = j;\n                int cnt1 = mxr[i] - i + 1 - cnt0;\n\n                int cntNext0 = count0(mxr[i] + 1, mxr[i + 1]);\n\n                if(cnt1)\n                    dp[i + 1][cntNext0 + cnt0] = (dp[i + 1][cntNext0 + cnt0] + dp[i][j]) % mod;\n                if(cnt0)\n                    dp[i + 1][cntNext0 + cnt0 - 1] = (dp[i + 1][cntNext0 + cnt0 - 1] + dp[i][j]) % mod;\n            }\n\n    printf(\"%d\\n\", dp[N + 1][0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]]||tot==0)q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<f[m][0]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define X first\n#define Y second\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair <int, int > ii;\nusing ll = long long;\nconst int MAX=3005,inf=0x3f3f3f3f,mod=1e9+7;\nint a[MAX],b[MAX];\nll f[MAX][MAX];\nint n,m;\nchar s[MAX];\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"bao.inp\",\"r\",stdin);\n    //freopen(\"ESCAPE.out\",\"w\",stdout);\n    int T;\n    cin>>n>>m;\n    cin>>s+1;\n    for(int i=1;i<=n;i++) {\n            b[i]=i;\n        a[i]=a[i-1]+s[i]-'0';\n    }\n\n\n    for(int i=1,x,y;i<=m;i++){\n        cin>>x>>y;\n        b[x]=max(b[x],y);\n    }\n    f[0][0]=1;\n    for(int i=1,now;i<=n;i++){\n        b[i]=max(b[i],b[i-1]);\n        if(a[b[i]]-0 < b[i]-i+1 )  f[i][0]=f[i-1][0];\n        for(int j=1;j<=i;j++){\n            if(a[b[i]]-j < b[i]-i+1 ) f[i][j]=f[i-1][j];\n            if(a[b[i]]-j >= 0 ) f[i][j]+=f[i-1][j-1];\n            if(f[i][j]>=mod) f[i][j]-=mod;\n            //cout<<i<<' '<<j<<' '<<f[i][j]<<'\\n';\n        }\n    }\n    ll ans=0;\n    for(int i=0;i<=n;i++){\n        ans+=f[n][i];if(ans>=mod) ans-=mod;\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]])q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j+t<=jb&&j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<f[m][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l[N], r[N], tr[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\t//freopen(\"f.in\", \"r\", stdin);\n\t//freopen(\"f.out\", \"w\", stdout);\n\t\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) {\n\t\tint ll, rr;\n\t\tscanf(\"%d%d\", &ll, &rr);\n\t\ttr[ll] = max(tr[ll], rr);\n\t}\n\tint m0 = 0;\n\tRep(i, n) if (tr[i]){\n\t\tbool flag = true;\n\t\tRep(j, i - 1) if (tr[i] <= tr[j]) flag = false;\n\t\tif (flag) l[++ m0] = i, r[m0] = tr[i];\n\t}\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, r[i] - l[i] + 1) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j] * c[r[i] - l[i] + 1][j]);\n\t\telse {\n\t\t\tRep0(j, r[i] - l[i] + 1) if (f[i][j]){\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, r[m0] - l[m0] + 1) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n10 2\n1011010000\n1 2\n3 7\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr int MOD = 1000000007;\n\nint dp[ 1 << 12 ][ 1 << 13 ];\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tint N, M;\n\tcin >> N >> M;\n\n\tstring S;\n\tcin >> S;\n\n\tVI L( M ), R( M );\n\tREP( i, M )\n\t{\n\t\tcin >> L[i] >> R[i];\n\t\t--L[i];\n\t}\n\t// [ l, r )\n\n\tVI ones, csum( 1, 0 );\n\ttransform( ALL( S ), BI( ones ), bind( minus< char >(),  _1, '0' ) );\n\tpartial_sum( ALL( ones ), BI( csum ) );\n\n\tVI lengths( N, 1 );\n\tREP( i, M )\n\t{\n\t\tchmax( lengths[ L[i] ], R[i] - L[i] );\n\t}\n\n\tVI undecided( N ), additional_ones( N );\n\t{\n\t\tint c = 0;\n\t\tREP( i, N )\n\t\t{\n\t\t\tif ( c < lengths[i] )\n\t\t\t{\n\t\t\t\tadditional_ones[i] = csum[ i + lengths[i] ] - csum[ i + c ];\n\t\t\t\tc += lengths[i] - c;\n\t\t\t}\n\t\t\tundecided[i] = c;\n\t\t\t--c;\n\t\t\tchmax( c, 0 );\n\t\t}\n\t}\n\n\tDUMP( lengths );\n\tDUMP( undecided );\n\tDUMP( additional_ones );\n\n\tdp[0][0] = 1;\n\t// dp[ position ][ undecided ones ] := pattern\n\n\tREP( i, N )\n\t{\n\t\tREP( j, N + 1 )\n\t\t{\n\t\t\tconst int dj = additional_ones[i];\n\n\t\t\tif ( j + dj )\n\t\t\t{\n\t\t\t\t( dp[ i + 1 ][ j + dj - 1 ] += dp[i][j] ) %= MOD;\n\t\t\t}\n\t\t\tif ( j + dj < undecided[i] )\n\t\t\t{\n\t\t\t\t( dp[ i + 1 ][ j + dj ] += dp[i][j] ) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[N][0] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 3010\nint n, m, l, r, t;\nll dp[2][N];\nstring s;\n\nll inv[N], fact[N], ifact[N];\n \nvoid init_fact(ll n = N){\n    inv[1] = 1;\n    for(int i = 2; i < n; i++) inv[i] = inv[mod%i] * (mod - mod/i) % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfact[i] = (fact[i-1]*i)%mod;\n\t\tifact[i]=(ifact[i-1]*inv[i])%mod;\n\t}\n}\n\nll comb(ll a, ll b){\n\treturn fact[a+b]*ifact[a]%mod*ifact[b]%mod;\n}\n\nll comb_nk(ll n, ll k){\n\treturn comb(n-k, k);\n}\n\nint main(){\n\tcin>>n>>m>>s;\n\tinit_fact();\n\tdp[0][0] = 1;\n\trep(i, m){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tif(b<=r) continue;\n\t\tmset(dp[!t], 0);\n\t\tint d = min(r, a)-l, e = r-l-d;\n\t\tl = a;\n\t\tint c = 0;\n\t\tr = max(r, a);\n\t\twhile(r<b) c += s[r++]-'0';\n\t\tfor(int j = 0; j <= d; j++){\n\t\t\tfor(int k = j; k-j <= e; k++){\n\t\t\t\t(dp[!t][k-j+c]+=dp[t][k]*comb_nk(d, j))%=mod;\n\t\t\t}\n\t\t}\n\t\tt = !t;\n\t}\n\tll res = 0;\n\trep(i, r-l+1) (res+=dp[t][i]*comb_nk(r-l, i))%=mod;\n\t//rep(i, r-l+1) cerr<<dp[t][i]<<\" \"<<comb_nk(r-l, i)<<endl;\n\tcout<<res<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n\nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n\nusing namespace std;\nconst int N=3010,mod=1e9+7;\nchar s[N];\nint n,m,ans,l[N],r[N],c[N][N],f[N][N],a[N];\n\nint main()\n{\n    n=get(),m=get();\n    rep(i,0,n)\n    {\n        c[i][0]=1;\n        rep(j,1,i)\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n    }\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        rep(j,0,s)\n            rep(k,max(0,w-j),mx)\n                f[i][k]=(f[i][k]+1ll*f[i-1][j+k-w]*c[s][j])%mod;\n    }\n    rep(i,0,n)\n        ans=(ans+f[m][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  auto dp=vec(n+1,n+1,modint(0));\n  vector<ll>g(n);\n  iota(ALL(g),0LL);\n  rep(i,0,m){\n    ll l,r;cin>>l>>r;l--;r--;\n    chmax(g[l],r);\n  }\n  ll mx=-1;\n  dp[0][0]=1;\n  rep(i,0,n){\n    if(mx<g[i]){\n      ll cnt=0;\n      rep(j,mx+1,g[i]+1)if(s[j]=='1')cnt++;\n      if(cnt>=1){\n        rrep(j,0,n+1){\n          if(j+cnt>n)continue;\n          dp[i][j+cnt]=dp[i][j];\n          dp[i][j]=0;\n        }\n      }\n      mx=g[i];\n    }\n    rep(j,0,n+1){\n      if(j>=1)dp[i+1][j-1]+=dp[i][j];\n      if(mx-i>=j)dp[i+1][j]+=dp[i][j];\n    }\n  }\n  //debug(dp,n+1,n+1);\n  cout<<dp[n][0]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3010;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=0;\n    for (int i=0;i<=n;i++) ans=(ans+f[tot-1][i])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=3e5+100;\nconst int MOD=1000000007;\nconst int inf=0x3f3f3f3f;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n,m;\nchar s[twx];\nint l[twx],r[twx];\nint ans=0;\nint one[twx];\nint asd[twx][twx];\nint To[twx];\nll add(ll x,ll y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\nll sub(ll x,ll y)\n{\n    return x-y<0?x-y+MOD:x-y;\n}\nll mul(ll x,ll y)\n{\n    return 1LL*x*y%MOD;\n}\nvoid init()\n{\n\tn=read();\n    m=read();\n    scanf(\"%s\",s+1);\n    f1(1,n,i)\n    {\n        if(s[i]=='1')\n        {\n            one[i]=one[i-1]+1;\n        }\n        else\n        {\n            one[i]=one[i-1];\n        }\n        To[i]=i;\n    }\n    one[n+1]=one[n];\n    f1(1,m,i)\n    {\n        l[i]=read();\n        r[i]=read();\n        To[l[i]]=max(To[l[i]],r[i]);\n    }\n    f1(2,n+1,i)\n    {\n        To[i]=max(To[i],To[i-1]);\n    }\n}\nvoid work()\n{\n    asd[1][one[To[1]]]=1;\n    f1(1,n,i)\n    {\n        f1(0,n,j)\n        {\n            if(asd[i][j])\n            {\n                int Left=To[i]+1;\n                int Right=To[i+1];\n                int tmp=one[Right]-one[Left-1];\n                int a=j;\n                int b=To[i]-i+1-a;\n                if(a)\n                {\n                    asd[i+1][j+tmp-1]=add(asd[i+1][j+tmp-1],asd[i][j]);\n                }\n                if(b)\n                {\n                    asd[i+1][j+tmp]=add(asd[i+1][j+tmp],asd[i][j]);\n                }\n            }\n        }\n    }\n}\nvoid print()\n{\n\tprintf(\"%d\\n\",asd[n+1][0]);\n}\nint main()\n{\n    init();\n    work();\n    print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define poly vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\ninline ll read(){\n\tll x=0;char ch=getchar();bool d=1;\n\tfor(;!isdigit(ch);ch=getchar()) if(ch=='-') d=0;\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn d?x:-x;\n}\ninline void write(ll x){\n\tif(x<0) x=-x,putchar('-');\n\tif(x>=10) write(x/10);\n\tputchar('0'+x%10);\n}\ninline void writeln(ll x){write(x);puts(\"\");}\ninline void writep(ll x){write(x);putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=3005,mo=1e9+7;\npii a[N];\nint L[N],R[N],f[N][N],g[N],b[N],c[N][N];\nchar s[N];\nint main(){\n\t// freopen(\"ssw.in\",\"r\",stdin);freopen(\"ssw.out\",\"w\",stdout);\n\tint len=read(),m=read(),n=0;\n\tscanf(\"%s\",s+1);\n\tFor(i,1,len) b[i]=b[i-1]+(s[i]=='1');\n\tc[0][0]=1;\n\tFor(i,1,len){\n\t\tc[i][0]=1;\n\t\tFor(j,1,i) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mo;\n\t}\n\tFor(i,1,m) a[i].fi=read(),a[i].se=read();\n\tsort(a+1,a+m+1);int mx=0;\n\tFor(i,1,m){\n\t\tif(i<m&&a[i].fi==a[i+1].fi&&a[i].se<a[i+1].se) continue;\n\t\tif(i&&a[i].se<=mx) continue;\n\t\tL[++n]=a[i].fi;R[n]=a[i].se;\n\t\tmx=max(mx,a[i].se);\n\t}\n\tL[n+1]=len+1;f[0][0]=1;\n\tint ans=1;\n\tFor(i,1,n){\n\t\tmemset(g,0,sizeof(g));\n\t\tif(L[i]>R[i-1]) g[b[R[i]]-b[L[i]-1]]=1;\n\t\telse{\n\t\t\tint x=b[R[i]]-b[R[i-1]];\n\t\t\tFor(j,0,R[i-1]-L[i]+1) g[j+x]=(g[j+x]+f[i-1][j])%mo;\n\t\t}\n\t\tif(R[i]>=L[i+1]){\n\t\t\tFor(j,0,R[i]-L[i+1]+1){\n\t\t\t\tFor(k,0,L[i+1]-L[i]+1){\n\t\t\t\t\tint ksg=L[i+1]-L[i];\n\t\t\t\t\tint sana=(ll)g[j+k]*c[ksg][k]%mo;\n\t\t\t\t\tf[i][j]=(f[i][j]+sana)%mo;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint ssw=0,l=R[i]-L[i]+1;\n\t\t\tFor(j,0,R[i]-L[i]+1) ssw=(ssw+(ll)c[l][j]*g[j])%mo;\n\t\t\tans=(ll)ans*ssw%mo;\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007,N=3010;\nint n,m,a[N],b[N],f[N][N];\nchar s[N];\ninline void reduce(int&x){x+=x>>31&mod;}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m>>(s+1);\n\tfor(int i=1;i<=n;++i)a[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint x,y;cin>>x>>y;\n\t\ta[x]=max(a[x],y);\n\t}\n\tfor(int i=1;i<=n;++i)a[i]=max(a[i-1],a[i]);\n\tfor(int i=1;i<=n;++i)b[i]=b[i-1]+(s[i]&1);\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<i;++j)if(f[i-1][j]){\n\t\t\tint u=b[a[i]]-j,v=a[i]-i+1-u;\n\t\t\tif(v>0&&u>=0)reduce(f[i][j]+=f[i-1][j]-mod);\n\t\t\tif(u>0&&v>=0)reduce(f[i][j+1]+=f[i-1][j]-mod);\n\t\t}\n\t}\n\tcout<<f[n][b[n]]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 3005,mo = int(1e9) + 7;\n\nstring s;\nint a[maxn],m,far[maxn],f[maxn][maxn],co[maxn],n,ans;\n\nint dfs(int l,int r,int c)\n{\n\tif (l == n + 1) return 1;\n\tif (r < far[l]) c += co[far[l]] - co[r],r = far[l];\n\tif (~f[l][c]) return f[l][c];\n\tint ans = 0;\n\tif (c) ans = (ans + dfs(l + 1,r,c - 1)) % mo;\n\tif (r - l + 1 - c) ans = (ans + dfs(l + 1,r,c)) % mo;\n\treturn f[l][c] = ans;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s;\n\tfor(int i = 1;i <= n;i ++) a[i] = s[i - 1] - '0',co[i] = co[i - 1] + a[i];\n\tfor(int i = 1,l,r;i <= m;i ++) cin >> l >> r,far[l] = max(far[l],r);\n\tfor(int i = 1;i <= n;i ++) far[i] = max(far[i],far[i - 1]),far[i] = max(far[i],i);\n\tmemset(f,255,sizeof f);\n\tcout << dfs(1,0,0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tconst int mod = 1e9 + 7;\n\tint n, m; cin >> n >> m;\n\tvector<vector<int>> C(n + 1, vector<int>(n + 1, 0));\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= i; j++) {\n\t\tif (j == 0 || j == i) C[i][j] = 1;\n\t\telse C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n\t}\n\tstring s; cin >> s;\n\tvector<int> cnt(n, 0);\n\tfor (int i = 0; i < n; i++) cnt[i] = (i == 0 ? 0 : cnt[i - 1]) + (s[i] == '1');\n\tvector<pair<int, int>> q(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> q[i].first >> q[i].second;\n\t\tq[i].first--; q[i].second--;\n\t}\n\tsort(q.begin(), q.end(), [&](const pair<int, int>& l, const pair<int, int>& r) {\n\t\tif (l.first == r.first) return l.second > r.second;\n\t\treturn l.first < r.first;\n\t});\n\tfor (int i = 1; i < m; ) {\n\t\tif (q[i].second <= q[i - 1].second) {\n\t\t\tm--;\n\t\t\tfor (int j = i; j < m; j++) q[j] = q[j + 1];\n\t\t} else i++;\n\t}\n\tq.resize(m + 1);\n\tfor (int i = m; i > 0; i--) q[i] = q[i - 1];\n\tvector<vector<int>> f(m + 1, vector<int>(n + 1, 0));\n\tauto getcount = [&](int l, int r) {\n\t\tif (l == 0) return cnt[r];\n\t\treturn cnt[r] - cnt[l - 1];\n\t};\n\tvector<int> pw2(n + 1, 1);\n\tfor (int i = 1; i <= n; i++) pw2[i] = pw2[i - 1] * 2 % mod;\n\tvector<int> seg(m + 1, 0);\n\tvector<int> tot(m + 1, 0);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (i != m && q[i].second >= q[i + 1].first) seg[i] = q[i + 1].first - q[i].first;\n\t\telse seg[i] = q[i].second - q[i].first + 1;\n\t\tif (i != 1 && q[i].first <= q[i - 1].second) tot[i] = tot[i - 1] + getcount(q[i - 1].second + 1, q[i].second);\n\t\telse tot[i] = getcount(q[i].first, q[i].second);\n\t}\n\tlong long ans = 1;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint t = tot[i];\n\t\tint jmn = t - (q[i].second - q[i].first + 1 - seg[i]);\n\t\tfor (int j = max(0, jmn); j <= t; j++) {\n\t\t\tfor (int k = 0; k <= seg[i] && k <= j; k++) {\n\t\t\t\tf[i][j] = ((long long)f[i][j] + (long long)f[i - 1][j - k] * C[seg[i]][k]) % mod;\n\t\t\t}\n\t\t}\n\t\tif (i == m || q[i].second < q[i + 1].first) {\n\t\t\tans = ans * f[i][t] % mod;\n\t\t\tfor (int j = 0; j <= n; j++) f[i][j] = 0;\n\t\t\tf[i][0] = 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=3010;\nconst int mod=1000000007;\nint n,m;\nint mn[maxn],mx[maxn];\nchar s[maxn],ansl[maxn],ansr[maxn];\nint f[maxn][maxn];\nint main() {\n\tn=read();m=read();\n\tscanf(\"%s\",s+1);\n\trep(i,1,n) ansl[i]=ansr[i]=s[i];\n\trep(i,1,m) {\n\t\tint l=read(),r=read();\n\t\tsort(ansl+l,ansl+r+1);\n\t\tsort(ansr+l,ansr+r+1);\n\t\treverse(ansr+l,ansr+r+1);\n\t}\n\trep(i,1,n) {\n\t\tmn[i]=mn[i-1];mx[i]=mx[i-1];\n\t\tif(ansl[i]=='1') mn[i]++;\n\t\tif(ansr[i]=='1') mx[i]++;\n\t}\n\tf[0][0]=1;\n\tint res=0;\n\trep(i,0,n) rep(j,mn[i],mx[i]) {\n\t\tint& ans=f[i][j];\n\t\tif(i==n) (res+=ans)%=mod;\n\t\telse (f[i+1][j]+=ans)%=mod,(f[i+1][j+1]+=ans)%=mod;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nstruct LR{\n\tll l, r;\n};\nvoid solve()\n{\n\tll n, m;  cin >> n >> m;\n\tstring s;  cin >> s;\n\tvector<LR> lr_ = cinv2<LR>(m);\n\teach(e, lr_){\n\t\te.l--; e.r--;\n\t}\n\tsort(ALL(lr_), [](LR&a, LR&b){\n\t\tif (a.l==b.l) return a.r>b.r;\n\t\treturn a.l<b.l;\n\t});\n\n\tdeque<LR> lr;\n\teach(e, lr_){\n\t\tif (lr.empty() or lr.back().r < e.r){\n\t\t\tlr.push_back(e);\n\t\t}\n\t}\n\n\tvvmll dp(n+1, vmll(n+1));\n\tauto Dp = [&](ll i, ll j)->mll&{\n\t\tstatic mll dmy=0;\n\t\tif (j>n or j<0)return dmy;\n\t\treturn dp[i+1][j];\n\t};\n\tDp(-1, 0)=1;\n\n\tll en=-1;\n\t\n\trep(i, -1, n-2){\n\t\tll ii=i+1;\n\t\tll adj=0;\n\t\tif (!lr.empty() and lr.front().l==ii){\n\t\t\tll pre_en=en;\n\t\t\ten=lr.front().r;\n\t\t\t//pre_en+1～enの間の1の数\n\t\t\tadj=count(s.begin()+(pre_en+1), s.begin()+en+1, '1');\n\t\t\tlr.pop_front();\n\t\t}\n\t\tif (en<ii)en=ii;\n\n\t\trep(j, 0, n){\n\t\t\tif (j+adj<=en-ii){\n\t\t\t\tDp(ii, j+adj)+=Dp(i, j);\n\t\t\t}\n\t\t\tif (j+adj-1<=en-ii){\n\t\t\t\tDp(ii, j+adj-1)+=Dp(i, j);\n\t\t\t}\n\t\t}\n\n\t\tif (en==ii){\n\t\t\trep(j, 1, n) Dp(ii, j)=0;\n\t\t}\n\t}\n\tmll ans=Dp(n-1, 0);\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    if(v[i].second < v[i+1].first){\n        return dp[i][s] = (pt[v[i].second-v[i].first+1][tmp]*saiki(i+1,0))%mod;\n    }else{\n        for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n            ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n        }\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    // for(int i=0;i<v.size();i++){\n    //     cout << v[i].first << \" \" <<v[i].second << endl;\n    // }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        if(v[i].first>v[i-1].second){\n            for(int j=v[i].first;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }else{\n            for(int j=v[i-1].second+1;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }\n        nm[i] = tmp;\n        //cout << i << \" \" <<  nm[i] << endl;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    //cout << tmp << endl;\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    if(v[0].second <v[1].first){\n        //cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        ans = (pt[v[0].second-v[0].first+1][tmp]*saiki(1,0))%mod;\n    }else{\n        for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n            ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  string s;\n  cin>>s;\n  vector<int> ls(m),rs(m);\n  for(int i=0;i<m;i++) cin>>ls[i]>>rs[i],ls[i]--;\n\n  vector<int> mv(n);\n  iota(mv.begin(),mv.end(),1);\n  for(int i=0;i<m;i++)\n    chmax(mv[ls[i]],rs[i]);\n\n  for(int i=1;i<n;i++)\n    chmax(mv[i],mv[i-1]);\n\n  vector<int> os(n+1,0),zs(n+1,0);\n  for(int i=0;i<n;i++){\n    os[i+1]=os[i]+(s[i]=='1');\n    zs[i+1]=zs[i]+(s[i]=='0');\n  }\n\n  using M = Mint<int>;\n  vector<M> dp(n+1,0);\n  dp[0]=M(1);\n  for(int p=0;p<n;p++){\n    vector<M> nx(n+1,0);\n    for(int i=0;i<=p;i++){\n      // put one\n      if(i+1<=os[mv[p]])\n        nx[i+1]+=dp[i];\n      // put zero\n      if((p-i)+1<=zs[mv[p]])\n        nx[i]+=dp[i];\n    }\n    swap(dp,nx);\n  }\n\n  M ans{0};\n  for(auto v:dp) ans+=v;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=3e5+100;\nconst int MOD=1000000007;\nconst int inf=0x3f3f3f3f;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n,m;\nchar s[twx];\nint l[twx],r[twx];\nint ans=0;\nint one[twx];\nint asd[twx][twx];\nint To[twx];\nll add(ll x,ll y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\nll sub(ll x,ll y)\n{\n    return x-y<0?x-y+MOD:x-y;\n}\nll mul(ll x,ll y)\n{\n    return 1LL*x*y%MOD;\n}\nvoid init()\n{\n\tn=read();\n    m=read();\n    scanf(\"%s\",s+1);\n    f1(1,n,i)\n    {\n        if(s[i]=='1')\n        {\n            one[i]=one[i-1]+1;\n        }\n        else\n        {\n            one[i]=one[i-1];\n        }\n        To[i]=i;\n    }\n    one[n+1]=one[n];\n    f1(1,m,i)\n    {\n        l[i]=read();\n        r[i]=read();\n        To[l[i]]=max(To[l[i]],r[i]);\n    }\n    f1(2,n+1,i)\n    {\n        To[i]=max(To[i],To[i-1]);\n    }\n}\nvoid work()\n{\n    asd[1][one[To[1]]]=1;\n    f1(1,n,i)\n    {\n        f1(0,n,j)\n        {\n            if(asd[i][j])\n            {\n                int Left=To[i]+1;\n                int Right=To[i+1];\n                int tmp=one[Right]-one[Left-1];\n                int a=j;\n                int b=To[i]-i+1-a;\n                if(a)\n                {\n                    asd[i+1][j+tmp-1]=add(asd[i+1][j+tmp-1],asd[i][j]);\n                }\n                if(b)\n                {\n                    asd[i+1][j+tmp]=add(asd[i+1][j+tmp],asd[i][j]);\n                }\n            }\n        }\n    }\n}\nvoid print()\n{\n\tprintf(\"%d\\n\",asd[n+1][0]);\n}\nint main()\n{\n    init();\n    work();\n    print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,q; string s;\nvector<P>vec;\nll dp[3005][3005],C[3005][3005];\nint main(){\n    C[0][0]=1;\n    for(int i=1;i<3005;i++)for(int j=0;j<=i;j++){\n        if(j==0||j==i)C[i][j]=1LL;\n        else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    }\n\tcin>>n>>q>>s;\n\trep(i,q){\n\t\tint a,b;cin>>a>>b;\n\t\tif(vec.empty() || vec[vec.size()-1].sc<b){\n\t\t\tif(!vec.empty() && vec[vec.size()-1].fi == a){\n\t\t\t\tvec.pop_back();\n\t\t\t}\n\t\t\tvec.pb(mp(--a,--b));//cout<<vec[vec.size()-1].fi<<vec[vec.size()-1].sc<<endl;\n\t\t}\n\t}\n\tdp[0][0] =1LL;\n\tint sum = 0,nxt2 = 0;\n\tint S=0,T=0;\n\trep(i,vec.size()){\n\t\tint nxt = (i==vec.size()-1?vec[i].sc+1:min(vec[i].sc+1,vec[i+1].fi));\n\t\t//[vec[i].fi,nxt) wo kettei\n\t\tint S2 = 0,T2 = 0;\n\t\tfor(int ii=max(nxt2,vec[i].fi);ii<vec[i].sc+1;ii++){\n\t\t\tif(s[ii]=='0')S++;else T++;\n\t\t}\n\t\tfor(int ii=0;ii<=sum;ii++){\n\t\t\tif(dp[ii][sum-ii]==0LL)continue;\n\t\t\tint zan = S-ii,zan2 = T-(sum-ii);\n\t\t\tfor(int x=0;x<=nxt-vec[i].fi;x++){\n\t\t\t\tif(x>zan||(nxt-vec[i].fi-x)>zan2) continue;\n\t\t\t\tdp[ii+x][sum-ii+(nxt-vec[i].fi-x)] += dp[ii][sum-ii]*C[nxt-vec[i].fi][x]%mod;\n\t\t\t\tif(dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]>=mod) dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]-=mod;\n\t\t\t}\n\t\t}\n\t\tsum += nxt-vec[i].fi; nxt2 = vec[i].sc+1;\n\t}\n\tcout<<dp[S][T]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Task        \"test\"\n#define pb          emplace_back\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define ll          long long\n//#define int         int64_t\n\nusing namespace std;\n\ntypedef pair<ll, ll> pii;\nconst int N = (int)3e3 + 2;\nconst int mod = (int)1e9 + 7;\n\nint n, m, l, r, sum, f[N][N], cnt[N], jump[N];\nstring s;\n\nvoid add(int& x, int y) {if((x += y) >= mod) x -= mod;}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> n >> m >> s; s = ' ' + s;\n    for(int i = 1; i <= m; ++i) {\n        cin >> l >> r;\n        jump[l] = max(jump[l], r);\n    }\n    for(int i = 1; i <= n + 1; ++i) {\n        jump[i] = max({jump[i], jump[i - 1], i});\n        cnt[i] = cnt[i - 1] + (s[i] == '1');\n    }\n    f[1][cnt[jump[1]]] = 1;\n    for(int i = 1; i <= n + 1; ++i) {\n        l = jump[i], r = jump[i + 1];\n        sum = cnt[r] - cnt[l];\n        for(int j = 0; j <= cnt[n]; ++j) {\n            if(f[i][j] == 0) continue;\n            if(j) add(f[i + 1][j - 1 + sum], f[i][j]);\n            if(jump[i] - i + 1 - j > 0) add(f[i + 1][j + sum], f[i][j]);\n        }\n    }\n    cout << f[n + 1][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/* -------------------------------- Template -------------------------------- */\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// template<typename T> constexpr T inf = [](){ assert(false); };\n// template<> constexpr int inf<int> = 1e9;\n// template<> constexpr ll inf<ll> = 1e18;\n// template<> constexpr ld inf<ld> = 1e30;\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename()  const { return \"YES\"; }\n  string_type do_falsename() const { return \"NO\"; }\n};\n\nvoid solve();\n\nint main() {\n  std::locale loc(std::locale(), new yes_no);\n  std::cout << std::boolalpha << std::setprecision(12) << std::fixed;\n  std::cout.imbue(loc);\n  solve();\n  return 0;\n}\n\nusing namespace std;\n\n/* -------------------------------- Library -------------------------------- */\n\ntemplate<int M, bool IsPrime = false>\nclass Modulo {\n  using ll = long long;\n  int n;\n  static enable_if_t<IsPrime, ll> inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n  }\npublic:\n  Modulo () : n(0) {;}\n  Modulo (int m) : n(m) {\n    if (n >= M) n %= M;\n    else if (n < 0) n = (n % M + M) % M;\n  }\n  Modulo (ll m) {\n    if (m >= M) m %= M;\n    else if (m < 0) m = (m % M + M) % M;\n    n = m;\n  }\n  explicit operator int() const { return n; }\n  explicit operator ll() const { return n; }\n  bool operator==(const Modulo &a) const { return n == a.n; }\n  Modulo operator+=(const Modulo &a) { n += a.n; if (n >= M) n -= M; return *this; }\n  Modulo operator-=(const Modulo &a) { n -= a.n; if (n < 0) n += M; return *this; }\n  Modulo operator*=(const Modulo &a) { n = (ll(n) * a.n) % M; return *this; }\n  Modulo operator+(const Modulo &a) const { Modulo res = *this; return res += a; }\n  Modulo operator-(const Modulo &a) const { Modulo res = *this; return res -= a; }\n  Modulo operator*(const Modulo &a) const { Modulo res = *this; return res *= a; }\n  Modulo operator^(int n) const {\n    if (n == 0) return Modulo(1);\n    const Modulo a = *this;\n    Modulo res = (a * a) ^ (n / 2);\n    return n % 2 ? res * a : res;\n  }\n  enable_if_t<IsPrime, Modulo> operator/(const Modulo &a) const {\n    return *this * inv(ll(a), M);\n  }\n};\n\ntemplate<int M> Modulo<M, true> fact(int n, bool sw = true) {\n  static vector<Modulo<M, true>> v1 = {1}, v2 = {1};\n  if (n >= (int)v1.size()) {\n    const int from = v1.size(), to = n + 1024;\n    v1.reserve(to);\n    v2.reserve(to);\n    for (int i = from; i < to; ++i) {\n      v1.push_back(v1.back() * Modulo<M, true>(i));\n      v2.push_back(v2.back() / Modulo<M, true>(i));\n    }\n  }\n  return sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Modulo<M, true> comb(int a, int b) {\n  if (b < 0 || b > a) return fact<M>(0);\n  return fact<M>(a, true) * fact<M>(b, false) * fact<M>(a-b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Modulo<mod, true>;\n\n/* ---------------------------------- Main ---------------------------------- */\n\nint l[4000], r[4000];\nint le[4000], ri[4000];\nint le2[4000], ri2[4000];\n\nMod dp[3010][3010];\n\nvoid solve() {\n  int N, M;\n  string s;\n  cin >> N >> M;\n  cin >> s;\n  REP(i,M) { cin >> l[i] >> r[i]; --l[i]; }\n  int P = 0, Q = 0;\n  REP(i,N) {\n    if (s[i] == '1') {\n      le[P] = i;\n      ri[P] = i + 1;\n      ++P;\n    }\n    else {\n      le2[Q] = i;\n      ri2[Q] = i + 1;\n      ++Q;\n    }\n  }\n  // cout << P << endl;\n  // REP(i,P) cout << le[i] << \" \" << ri[i] << endl;\n  REP(i,P) REP(j,M) {\n    if (l[j] < ri[i] && le[i] < r[j]) {\n      chmin(le[i], l[j]);\n      chmax(ri[i], r[j]);\n    }\n  }\n  REP(i,Q) REP(j,M) {\n    if (l[j] < ri2[i] && le2[i] < r[j]) {\n      chmin(le2[i], l[j]);\n      chmax(ri2[i], r[j]);\n    }\n  }\n  // cout << P << endl;\n  // REP(i,P) cout << le[i] << \" \" << ri[i] << endl;\n  // cout << Q << endl;\n  // REP(i,Q) cout << le2[i] << \" \" << ri2[i] << endl;\n  dp[0][0] = 1;\n  REP(i,N) REP(j,P+1) {\n    int k = i - j;\n    if (k < 0) continue;\n    if (k > Q) continue;\n    if (j < P && le[j] <= i && i < ri[j])\n      dp[i+1][j+1] += dp[i][j];\n    if (k < Q && le2[k] <= i && i < ri2[k])\n      dp[i+1][j] += dp[i][j];\n    // if (j == 0) cout << endl;\n    // cout << int(dp[i][j]) << \" \";\n    // cout << i << \" \" << j << \" \" << k << \" \" << int(dp[i][j]) << endl;\n  }\n  // cout << endl;\n  cout << int(dp[N][P]) << endl;\n  return;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(0,x-y+a[y]) ,r=min(prer+x-y+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define pb push\n#define mp make_pair\n#define X first\n#define Y second\n#define Mad(a,b) a=(a+b)%mod;\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\nqueue<P> Q;\n#define N 3010\nll n,m,d[N],c[N];string s;\nint main(){\n    cin>>n>>m>>s;\n    Q.pb(mp(0,0));\n    while(m--){\n\tll a,b;cin>>a>>b;\n\tif(Q.back().Y<b)Q.pb(mp(a,b));\n    }\n    lol(i,N)d[i]=0;d[0]=1;\n    for(ll i=0,rnd=0,bef=0;i<=n;i++){\n\tll cnt=0;\n\twhile(!Q.empty()){\n\t    if(not(Q.front().X<=i))break;\n\t    rnd=Q.front().Y;\n\t    for(ll j=max(i-1,bef);j<rnd;j++)cnt+=s[j]-'0';\n\t    bef=rnd;Q.pop();\n\t}\n\t//lol(j,10)cout<<d[j]<<\" \";cout<<endl;\n\tlol(j,N)c[j]=0;\n\tlol(j,N-cnt)c[j+cnt]=d[j];\n\tlol(j,N)d[j]=c[j];\n\t//lol(j,10)cout<<d[j]<<\" \";cout<<endl;\n\t//cout<<\"#####\"<<endl;\n\tlol(j,N)c[j]=0;\n\tll lim=max(0LL,rnd-i);\n\tfor(ll j=0;j<=lim;j++)Mad(c[j],d[j]+d[j+1]);\n\tlol(j,N)d[j]=c[j];\n    }\n    cout<<d[0]<<endl;\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring s;\nint n,m;\nint a[3003];\nint l[3003],r[3003];\nvector<P> ps[2];\nll dp[2][3003];\n\nint main(){\n  cin>>n>>m>>s;\n  rep(i,n)a[i]=s[i]-'0';\n  rep(i,n){\n    l[i]=i;\n    r[i]=i+1;\n  }\n  rep(i,m){\n    int L,R;\n    cin>>L>>R;\n    L--; \n    rep(j,n){\n      if(L<r[j]&&r[j]<R)r[j]=R;\n      if(L<l[j]&&l[j]<R)l[j]=L;\n    }\n  }\n  rep(i,n){\n    ps[a[i]].push_back(P(l[i],r[i]));\n  }\n  ps[0].push_back(P(INF,INF+1));\n  ps[1].push_back(P(INF,INF+1));\n  sort(all(ps[0])); sort(all(ps[1]));\n\n  m=ps[0].size();\n  int crt=0,nxt=1;\n  dp[crt][0]=1;\n  rep(i,n){\n    memset(dp[nxt],0,sizeof(dp[nxt]));\n    rep(j,m){\n      int k=i-j;\n      if(k<0||k>=ps[1].size())continue;\n      int l0=ps[0][j].fi,r0=ps[0][j].se;\n      int l1=ps[1][k].fi,r1=ps[1][k].se;\n      if(r0<=i||r1<=i)continue;\n      if(l0<=i){\n        (dp[nxt][j+1]+=dp[crt][j])%=mod;\n      }\n      if(l1<=i){\n        (dp[nxt][j]+=dp[crt][j])%=mod;\n      }\n    }\n    swap(crt,nxt);\n  }\n  cout<<dp[crt][m-1]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin() , (x).end()\n#define rall(x) (x).rbegin() , (x).rend()\n#define len(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\nconst int N = 3001;\nint dp[N][N];\nint sum(int x , int y){\n    x += y; if(x >= MOD)x-=MOD;\n    return x;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0) , cin.tie(0) , cout.tie(0);\n    int n , m;cin >> n >> m;\n    string s;cin >> s;\n    vector < int > r(n);\n    iota(all(r) , 0);\n    for(int i = 0 ; i < m; ++i){\n        int l , _r;cin >> l >> _r;\n        --l , --_r;\n        r[l] = max(r[l] , _r);\n    }\n    dp[0][0] = 1;\n    int all = 0 , j = 0;\n    for(int i = 0; i < n; ++i){\n        while(j <= r[i])\n            all += s[j] - '0' , j++;\n        for(int was = 0 ;was <= i; ++was){\n            /// put 1\n            if(was + 1 <= all)\n                dp[i + 1][was + 1] = sum(dp[i+1][was+1],dp[i][was]);\n            /// put 0\n            if((j - all) - (i - was))\n                dp[i + 1][was] = sum(dp[i+1][was] , dp[i][was]);\n        }\n    }\n    int answer = 0;\n    for(int i = 0; i <= n; ++i)\n        answer = sum(answer , dp[n][i]);\n    cout << answer;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef long long ll;\n\nint N,M,m;\nll sum[300030] = {0};\nll que[300030][2] = {0};\nll F[300030] = {0},R[300003] = {0};\nll dp[3030][3030];\nvector<int> QL,QR;\n\nll con(ll a,ll b)\n{\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nll P(ll n,ll s)\n{//printf(\"  %lld %lld\\n\",n,s);\n    if(dp[n][s] != -1)return dp[n][s];\n    ll res = 0;\n    ll l,r;\n    if(n == QR.size() - 1)\n    {\n        l = QL[n];r = QR[n];\n        res = con(r - l + 1,sum[r] - s);\n        return res;\n    }\n    l = QL[n],r = min(QR[n],QL[n + 1] - 1);\n    ll mem = sum[QR[n]] - s;\n    ll p = 0;\n    if(QR[n] < QL[n + 1])p = sum[QL[n + 1] - 1] - sum[QR[n] + 1];\n\n    //printf(\" %lld %lld %lld %lld\\n\",l,r,mem,(r - l + 1) - (QR[n] - l + 1 - mem));\n    for(int i = max((ll)0,(r - l + 1) - (QR[n] - l + 1 - mem)); i <= mem; i++)\n    {\n        res += P(n + 1,s + i + p) * con(r - l + 1,i);\n        res %= mod;\n    }\n    return dp[n][s] = res;\n}\n\nll power(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = power(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < 3030; i++)for(int j = 0; j < 3030; j++)dp[i][j] = -1;\n    F[0] = 1;\n    for(int i = 1; i <= 3030; i++)F[i] = F[i - 1] * i;\n    for(int i = 0; i <= 3030; i++)R[i] = power(F[i],mod - 2);\n    for(int i = 1; i <= N; i++)\n    {\n        char c;\n        scanf(\" %c\",&c);\n        sum[i] = sum[i - 1] + (c == '1');\n    }\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%lld%lld\",&que[i][0],&que[i][1]);\n        if(i != 0)que[i][1] = max(que[i][1],que[i - 1][1]);\n    }\n    for(int i = 0; i < M; i++)\n    {\n        if(i == 0)\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n        if(QL[QL.size() - 1] == que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QR[QR.size() - 1] = que[i][1];\n        }\n        else if(QL[QL.size() - 1] < que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n    }\n    /*\n    for(int i = 0; i < QR.size(); i++)\n    {\n        printf(\" %d %d\\n\",QL[i] ,QR[i]);\n    }\n    */\n    printf(\"%lld\\n\",P(0,sum[QL[0] - 1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst ll mod = 1000000007LL ;\n\nint n , m ;\nchar s[ 3005 ] ;\nii q[ 3005 ] ;\nvector< ii > v ;\nint pre[ 3005 ] ;\nll C[ 3005 ][ 3005 ] ;\n\nvoid init() {\n  scanf( \"%d%d%s\" , &n , &m , s + 1 ) ;\n  pre[ 0 ] = 0 ;\n  for ( int i = 1 ; i <= m ; i ++ ) {\n    scanf( \"%d%d\" , &q[ i ].first , &q[ i ].second ) ;\n    if ( v.size() == 0 ) v.push_back( q[ i ] ) ;\n    else {\n      q[ i ].second = max( v.back().second , q[ i ].second ) ;\n      if ( v.back().first < q[ i ].first ) v.push_back( q[ i ] ) ;\n      else v.back().second = max( v.back().second , q[ i ].second ) ;\n    }\n  }\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    if ( s[ i ] == '1' ) pre[ i ] = pre[ i - 1 ] + 1 ;\n    else pre[ i ] = pre[ i - 1 ] ;\n  }\n}\n\nll dp[ 3005 ][ 3005 ] ;\n\nvoid process() {\n  dp[ v[ 0 ].first ][ pre[ v[ 0 ].first - 1 ] ] = 1 ;\n  for ( int i = 0 ; i + 1 < (int)v.size() ; i ++ ) {\n    ii nw = v[ i ] ;\n    ii nxt = v[ i + 1 ] ;\n    int lb = nw.first , rb = nw.second ;\n    int nlb = nxt.first ;\n    int emp = nlb - lb ;\n    for ( int j = 0 ; j <= lb ; j ++ ) if ( dp[ lb ][ j ] ) {\n      int bnd = min( pre[ rb ] , j + emp ) ;\n      for ( int one = j ; one <= bnd ; one ++ ) {\n        dp[ nlb ][ one ] = ( dp[ nlb ][ one ] + dp[ lb ][ j ] * C[ emp ][ one - j ] ) % mod ;\n      }\n    }\n  }\n  ll ans = 0 ;\n  ii nw = v.back() ;\n  for ( int j = 0 ; j <= nw.first ; j ++ ) if ( dp[ nw.first ][ j ] ) {\n    int one = pre[ nw.second ] - j ;\n    if ( one <= nw.second - nw.first ) {\n      ans = ( ans + dp[ nw.first ][ j ] * C[ nw.second - nw.first + 1 ][ one ] ) % mod ;\n    }\n  }\n  printf( \"%lld\\n\" , ans ) ;\n}\n\nint main() {\n  for ( int i = 0 ; i <= 3000 ; i ++ )\n    C[ i ][ 0 ] = C[ i ][ i ] = 1 ;\n  for ( int i = 1 ; i <= 3000 ; i ++ ) {\n    for ( int j = 1 ; j < i ; j ++ ) {\n      C[ i ][ j ] = ( C[ i - 1 ][ j ] + C[ i - 1 ][ j - 1 ] ) % mod ;\n    }\n  }\n/*\n#ifdef ONLINE_JUDGE\nfreopen(\"input.txt\",\"r\",stdin);\nfreopen(\"output.txt\",\"w\",stdout);\n#endif\n  int Cases;\n  scanf( \"%d\" , &Cases ) ;\n  for ( int cases = 1 ; cases <= Cases ; cases ++ ) {\n*/\n    init() ;\n    process() ;\n/*\n  }\n*/\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n\tint N, M;\n\tstatic long long dp[3001][3001];\n\twhile(cin >> N >> M){\n\t\tstring S; cin >> S;\n\t\tvector<int> upperNum(N, 0);\n\t\tvector<int> right(N, 0);\n\t\tfor(int i=0;i<N;i++) right[i] = i;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint l, r; cin >> l >> r;\n\t\t\t--l; --r;\n\t\t\tright[l] = max(right[l], r);\n\t\t}\n\t\tfor(int i=1;i<N;i++) right[i] = max(right[i], right[i-1]);\n\t\tupperNum[0] = (S[0] == '1');\n\t\tfor(int i=1;i<N;i++){\n\t\t\tupperNum[i] = upperNum[i-1] + (S[i] == '1');\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1;\n\t\tint lower = 0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(lower + right[i] - i + 1 == upperNum[right[i]]) ++lower;\n\t\t\tint upper = upperNum[right[i]];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tif(lower <= j+k && j+k <= upper) dp[i+1][j+k] = (dp[i][j]+dp[i+1][j+k])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[N][upperNum[N-1]] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nstatic const int MAXN = 3002;\nstatic const int MAXM = 3003;\nstatic const int MODULUS = 1e9 + 7;\n#define _  %  MODULUS\n#define __ %= MODULUS\n\nint n, m;\nchar s[MAXN];\nint l[MAXM], r[MAXM];\nint yonder[MAXM];\n\nint f[MAXN][MAXN] = {{ 0 }};\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m); getchar();\n    for (int i = 0; i < n; ++i) s[i] = getchar() - '0';\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d%d\", &l[i], &r[i]); --l[i], --r[i];\n        if (i > 0 && r[i] <= r[i - 1]) --m, --i;\n        else if (i > 0 && l[i] == l[i - 1] && r[i] >= r[i - 1]) --m, --i, r[i] = r[i + 1];\n    }\n\n    std::fill(yonder, yonder + n, -2);\n    for (int j = 0; j < l[0]; ++j) yonder[j] = j;\n    for (int j = l[m - 1]; j < n; ++j) yonder[j] = std::max(j, r[m - 1]);\n    for (int i = 1; i < m; ++i) {\n        for (int j = l[i - 1]; j < l[i]; ++j) yonder[j] = std::max(j, r[i - 1]);\n    }\n\n    int ones = 0;\n    for (int i = 0; i <= yonder[0]; ++i) ones += s[i];\n    f[0][ones] = 1;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j <= yonder[i - 1] - i + 1; ++j) {\n            f[i][j] = f[i - 1][j];\n            if (j < MAXN - 1) (f[i][j] += f[i - 1][j + 1])__;\n        }\n        if (yonder[i] != yonder[i - 1]) {\n            int ones = 0;\n            for (int j = yonder[i - 1] + 1; j <= yonder[i]; ++j) ones += s[j];\n            for (int j = MAXN - 1; j >= ones; --j) f[i][j] = f[i][j - ones];\n            for (int j = ones - 1; j >= 0; --j) f[i][j] = 0;\n        }\n    }\n\n    printf(\"%d\\n\", (f[n - 1][0] + f[n - 1][1])_);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i],ls[i]--;\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint pl=-1,pr=-1;\n\t\t\trep(i,m) if(pr<rs[i]){\n\t\t\t\tif(pl<ls[i])\n\t\t\t\t\tts.emplace_back(ls[i],rs[i]);\n\t\t\t\telse\n\t\t\t\t\tts.back()=mt(ls[i],rs[i]);\n\t\t\t\ttie(pl,pr)=ts.back();\n\t\t\t}\n\t\t\tint first=get<0>(ts[0]),last=get<1>(ts.back());\n\t\t\ts=s.substr(first,last-first);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=first,rs[i]-=first;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['0'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m)\n\t\t\trepi(i,ls[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M = 1e9+7;\ninline ll mul(ll a, ll b) {return (a*b)%M;}\nconst int MN = 3030;\nll dp[MN][MN];\nll pr[MN];\nll lf[MN],rt[MN];\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll cf[MN][MN];\nll ch(ll n, ll k) {\n\tif(k > n || k < 0) return 0;\n\tif(k == 0 || k == n) return 1;\n\tif(cf[n][k] != -1) return cf[n][k];\n\treturn cf[n][k] = (ch(n-1,k-1)+ch(n-1,k))%M;\n}\nll ct;\nll ds(ll id, ll x, ll rb) {\n\trb = max(rb,lf[id]);\n\tx += pr[rt[id]]-pr[rb];\n\tif(id == ct-1) {\n\t\treturn ch(rt[id]-lf[id],x);\n\t}\n\tif(dp[id][x] != -1) {\n\t\treturn dp[id][x];\n\t}\n\tll tot = 0;\n\tll nt = max(rt[id]-lf[id+1],0LL);\n\tfor(int i=0;i<=min(nt,x);i++) {\n\t\ttot += mul(ch(min(rt[id],lf[id+1])-lf[id],x-i),ds(id+1,i,rt[id]));\n\t}\n\ttot %= M;\n\t//cout << \"dp \" << id << \" \" << x << \" = \" << tot << '\\n';\n\treturn dp[id][x] = tot;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tmemset(cf,-1,sizeof(cf));\n\tmemset(dp,-1,sizeof(dp));\n\tint n,m;\n\tstring s;\n\tcin >> n >> m;\n\tcin >> s;\n\tll ub = -1,id = 0;\n\tpr[0] = 0;\n\tfor(int i=0;i<n;i++) {\n\t\tpr[i+1] = pr[i] + (s[i]-'0');\n\t}\n\tfor(int i=0;i<m;i++) {\n\t\tll a,b;\n\t\tcin >> a >> b;a--;b--;\n\t\tif(b <= ub) continue;\n\t\tub = b;\n\t\tlf[id] = a;\n\t\trt[id++] = b+1;\n\t}\n\tct = id;\n\tcout << ds(0,0,0) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < n; ++i)\n\nchar s[3001];\nint n, m, mx[3001], mn[3001], md = 1e9 + 7, x[3001], an[3001][3001];\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tf(i, 0, n)mx[i + 1] = mn[i + 1] = x[i + 1] = x[i] + (s[i] == '1');\n\tint L = 0;\n\twhile (m--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif (r <= L)continue;\n\t\tint a = mn[l - 1], b = mx[l - 1];\n\t\tint z = x[r] - b;\n\t\tf(i, l, r + 1) {\n\t\t\tif (z >= i - l + 1)mx[i] = 1 + mx[i - 1];\n\t\t\telse mx[i] = mx[i - 1];\n\t\t}\n\t\tz = r - l + 1 - (x[r] - a);\n\t\tf(i, l, r + 1) {\n\t\t\tif (z >= i - l + 1)mn[i] = mn[i - 1];\n\t\t\telse mn[i] = mn[i - 1] + 1;\n\t\t}\n\t\tL = r;\n\t}\n\tan[0][0] = 1;\n\tf(i, 0, n) {\n\t\tint a = mn[i], b = mx[i];\n\t\tf(j, a, b + 1) {\n\t\t\tif (j >= mn[i + 1] && j <= mx[i + 1]) {\n\t\t\t\tan[i + 1][j] += an[i][j];\n\t\t\t\tif (an[i + 1][j] >= md)an[i + 1][j] -= md;\n\t\t\t}\n\t\t\tif (j + 1 >= mn[j + 1] && j + 1 <= mx[i + 1]) {\n\t\t\t\tan[i + 1][j + 1] += an[i][j];\n\t\t\t\tif (an[i + 1][j + 1] >= md)an[i + 1][j + 1] -= md;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", an[n][x[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\n\nstruct BIT{\n  ll M=1;\n  vector<ll> dat;\n  BIT(ll N){\n    while(N>M) M*=2;\n    dat.resize(M*2-1, 0);\n  }\n  void update(ll x, ll k){\n    for(int i=k+1;i<=M;i+=(i&(-i))){\n      dat[i] += x;\n    }\n  }\n  ll sum(ll r){\n    ll ret = 0;\n    for(int k=r;k>0;k-=(k&(-k))) ret += dat[k];\n    return ret;\n  }\n\n  ll query(ll l, ll r){\n    return sum(r) - sum(l);\n  }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, m;std::cin >> n >> m;\n  vvl dp = VV(n+1, n+1, 0, ll);\n  string s;std::cin >> s;\n  BIT b(n+1);\n  for(int i=0;i<n;i++) b.update((s[i]=='1'), i);\n  ll cnt = b.query(0, n);\n  dp[0][0] = 1;\n\n  vvl d;\n  ll r = -1;\n  for(int i=0;i<m;i++){\n    ll x, y;std::cin >> x >> y;\n    x--, y--;\n    if(r>=y) continue;\n    r = y;\n    if(d.size()!=0&&d[d.size()-1][0]==x){\n      d[d.size()][1] = r;\n    }else{\n      d.push_back(vll{x, y});\n    }\n  }\n  m = d.size();\n\n  for(int i=0;i<n;i++){\n    auto itr = upper_bound(all(d), vll{i, -1});\n    ll r;\n\n    if(itr==d.begin()) r = i-1;\n    else {\n      r = (*--itr)[1];\n      if(r < i) r = i-1;\n    }\n    ll sa = r - i + 1;\n    itr = upper_bound(all(d), vll{i, 100000});\n\n    ll ad = 0;\n    if(itr!=d.begin()){\n      itr--;\n      if((*itr)[0]==i){\n        ad = b.query(r+1, (*itr)[1]+1);\n        sa = (*itr)[1] - i + 1;\n      }\n    }\n    //if(i==3) std::cout << sa << ad << '\\n';\n\n    if(sa==0){\n      dp[i+1] = dp[i];\n    }else{\n      //元々のr\n      for(int j=0;j<=cnt;j++){\n        ll one = j + ad;\n        if(sa < one) continue;\n        ll zero = sa - one;\n        if(one) dp[i+1][one-1] = (dp[i+1][one-1] + dp[i][j])%P;\n        if(zero) dp[i+1][one] = (dp[i+1][one] + dp[i][j])%P;\n      }\n    }\n  }\n  //std::cout << dp[4][2] << \" \" << dp[4][3] << \" \" << dp[4][4] << '\\n';\n  std::cout << dp[n][0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint const MOD=1000000007;\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n,n_operation;std::cin>>n>>n_operation;\n\n\tstd::vector<int> acm;acm.reserve(n+1);acm.resize(n); // suffix sum accumulation\n\tfor(int& x:acm){\n\t\tchar c;std::cin>>c;\n\t\tx=c-'0';\n\t}\n\tfor(int i=n-1;i--;)\n\t\tacm[i]+=acm[i+1];\n\tacm.push_back(0);\n\n\tauto const sum=[&](int l,int r){return acm[l]-acm[r];};\n\n\n\tstd::vector<std::pair<int,int>> ops;ops.reserve(n_operation+1);\n\tfor(int _=n_operation;_--;){\n\t\tint l,r;std::cin>>l>>r;--l;\n\t\tif(!ops.empty()){\n\t\t\tif(ops.back().first==l){\n\t\t\t\tops.back().second=std::max(ops.back().second,r);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(ops.back().second>=r)\n\t\t\t\tcontinue;\n\t\t}\n\t\tops.push_back({l,r});\n\t}\n\n\tops.push_back({n,n});\n\n\tn_operation=-1;\n\n\tauto const l=[&](int x){return ops[x].first;};\n\tauto const r=[&](int x){return ops[x].second;};\n\n\tstd::vector<std::vector<int>> dp(ops.size());\n\t// dp[i][n] = number of states of the sequence [0,l(i)] after i steps with sum n\n\n\tdp[0].resize(n+1);\n\tdp[0][sum(0,l(0))]=1;\n\n\n\tstd::vector<std::vector<int>> binom(n+1);\n\tbinom[0].assign(1,1);\n\tfor(unsigned i=1;i<binom.size();++i){\n\t\tbinom[i].resize(i+1);\n\t\tstd::copy(begin(binom[i-1]),end(binom[i-1]),begin(binom[i]));\n\t\tstd::transform(begin(binom[i-1]),end(binom[i-1]),++begin(binom[i]),++begin(binom[i]),[](int a,int b){\n\t\t\t\ta+=b;\n\t\t\t\tif(a>=MOD)a-=MOD;\n\t\t\t\treturn a;\n\t\t\t\t});\n\t}\n\n\n\tfor(int i=1;i<(int)ops.size();++i){\n\t\tdp[i].resize(n+1);\n\t\tfor(int x=0;x<=n;++x){\n\t\t\t// x = sum [0,l(i)] after i steps\n\n\t\t\tint ans=0;\n\t\t\tfor(int y=0;y<=x;++y){\n\t\t\t\t// y = sum [0,l(i-1)] after >= i-1 steps\n\t\t\t\t// then perform permutation of l(i-1) .. r(i-1) (after i-1 steps there are\n\t\t\t\t// sum(0,r(i-1))-y   ones in the range and  y  ones before)\n\t\t\t\t// such that there are x ones before l(i) <-> x-y ones int  l(i-1) .. l(i)\n\n\t\t\t\tint const cntrange=sum(0,r(i-1))-y; // range l..r (i-1)\n\n\t\t\t\tint mid=l(i);\n\t\t\t\tint midcnt=x-y; // desired cnt int l(i-1) .. mid\n\t\t\t\tif(mid>r(i-1)){\n\t\t\t\t\tmidcnt-=sum(r(i-1),mid);\n\t\t\t\t\tmid=r(i-1);\n\t\t\t\t}\n\n\t\t\t\t// need to count number of seq [l(i-1) .. mid] with midcnt ones\n\t\t\t\tif(0<=midcnt&&midcnt<=cntrange&& midcnt<=mid-l(i-1) && cntrange-midcnt<=r(i-1)-mid)\n\t\t\t\t\tans=(ans+(int64_t)dp[i-1][y]*binom[mid-l(i-1)][midcnt])%MOD;\n\t\t\t}\n\t\t\tdp[i][x]=ans;\n\t\t}\n\t}\n\n\tstd::cout<<dp[ops.size()-1][sum(0,n)]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nll dp[3030][3030];\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    vector<int> cnt0(n),cnt1(n);\n    rep(i,n)cnt0[i]=s[i]=='0';\n    rep(i,n-1)cnt0[i+1]+=cnt0[i];\n    rep(i,n)cnt1[i]=s[i]=='1';\n    rep(i,n-1)cnt1[i+1]+=cnt1[i];\n    dp[0][0]=1;\n    int c = 0;\n    vector<int> l(n);\n    rep(i,n)l[i]=i;\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        l[x]=max(l[x],y);\n    }\n    rep(i,n-1)l[i+1]=max(l[i+1],l[i]);\n    rep(i,n)rep(j,n+1){\n        dp[i][j]%=mod;\n        if(j+1<=cnt0[l[i]])dp[i+1][j+1]+=dp[i][j];\n        if(i+1-j<=cnt1[l[i]])dp[i+1][j]+=dp[i][j];\n    }\n    cout<<dp[n][cnt0[n-1]]%mod;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst ll oo = 1e18;\nconst int MOD = 1000000007;\nconst int N = 500002;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define cpx complex<double>\n\nint n , m , mx[3010], dp[3010][3010], pre[3010];\nstring s;\n\nint calc(int l , int r , int ones){\n\tif(ones < 0)return 0;\n\tif(l == n)return (ones == 0?1:0);\n\tif(l > r && ones != 0)return 0;\n\tif(r >= l && ones > (r-l+1))return 0;\n\tif(mx[l]>r){\n\t\tones += pre[mx[l]]-(r==-1?0:pre[r]);\n\t\tr = mx[l];\n\t}\n\tint &ret = dp[l][ones];\n\tif(ret != -1)return ret;\n\treturn ret = (1ll*calc(l+1,r,ones)+calc(l+1,r,ones-1))%MOD;\n}\nint main() {\n\tmemset(dp,-1,sizeof dp);\n\tcin >> n >> m >> s;\n\tfor (int i = 0 ; i < n ; ++i) {\n\t\tpre[i] = s[i] - '0';\n\t\tmx[i] = i;\n\t\tif (i)pre[i] += pre[i - 1];\n\t}\n\tfor (int l , r , i = 0 ; i < m ; ++i) {\n\t\tcin >> l >> r;\n\t\tl--,r--;\n\t\tmx[l] = max(mx[l], r);\n\t}\n\tprintf(\"%d\\n\", calc(0,-1,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\n\tassert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = min(y[i] - rightmost, y[i] - x[i] + 1);\n\t\tfix[i] = min(x[i+1] - x[i], y[i] - x[i] + 1);\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tidx = max(idx, x[i]);\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\nusing i64 = long long;\nusing pii = pair<int, int>;\n\nconst int N = 3005;\nconst i64 MOD = 1000000007;\n\nint v[N], st[N], dr[N];\ni64 dp[N][N];\n\nvector<pii> ivs;\nstring str;\nint n, m, one;\n\nint main() {\n#ifdef HOME\n\tfreopen(\"arc65d.in\", \"r\", stdin);\n\tfreopen(\"arc65d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\n\tcin >> n >> m;\n\tcin >> str;\n\tivs.resize(m);\n\tfor (auto &i: ivs)\n\t\tcin >> i.x >> i.y;\n\n\tfor (int i = 0; i < n; ++i) if (str[i] == '1')\n\t\tv[i + 1] = ++one;\n\n\tfor (int i = 0; i < m; ++i)\n\t\tstable_partition(v + ivs[i].x, v + ivs[i].y + 1, [&](int x) { return x; });\n\tfor (int i = 1; i <= n; ++i) if (v[i])\n\t\tst[v[i]] = i;\n\n\tmemset(v, 0x00, sizeof v);\n\tone = 0;\n\n\tfor (int i = 0; i < n; ++i) if (str[i] == '1')\n\t\tv[i + 1] = ++one;\n\n\tfor (int i = 0; i < m; ++i)\n\t\tstable_partition(v + ivs[i].x, v + ivs[i].y + 1, [&](int x) { return !x; });\n\tfor (int i = 1; i <= n; ++i) if (v[i])\n\t\tdr[v[i]] = i;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tdp[i][0] = 1;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= one; ++j) {\n\t\t\tdp[i][j]+= dp[i - 1][j];\n\n\t\t\tif (st[j] <= i && i <= dr[j]) \n\t\t\t\tdp[i][j]+= dp[i - 1][j - 1];\n\n\t\t\tif (dp[i][j] >= MOD)\n\t\t\t\tdp[i][j]-= MOD; }\n\n\tcout << dp[n][one] % MOD << endl;\n\n\treturn 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3005, MOD = 1e9 + 7;\n\nint n, m, r[N], rightend[N], cnt1[N], f[N][N];\nstring s;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n >> m >> s;\n  int curl, curr;\n  cin >> curl >> curr;\n  for (int i = 2, nxl, nxr; i <= m; ++i) {\n    cin >> nxl >> nxr;\n    if (curl == nxl) curr = max(curr, nxr);\n    else if (curr < nxr) {\n      r[curl] = curr;\n      curl = nxl; curr = nxr;\n    }\n  }\n  r[curl] = curr;\n  for (int i = 1; i <= n; ++i) {\n    cnt1[i] = cnt1[i - 1] + (s[i - 1] == '1');\n    rightend[i] = max(rightend[i - 1], r[i - 1]);\n    r[i] = max({r[i], i, rightend[i]});\n  }\n  f[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (f[i][j] == 0) continue;\n      int one = j + ((rightend[i] < r[i]) ? (cnt1[r[i]] - cnt1[rightend[i]]) : 0);\n      if (one) (f[i + 1][one - 1] += f[i][j]) %= MOD;\n      if (r[i] - i + 1 > one) (f[i + 1][one] += f[i][j]) %= MOD;\n    }\n  }\n  cout << f[n + 1][0];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\t//cout << \"start: \" << x << \" \" << ones << \" \" << maxr[x] - x + 1 << \"\\n\";\n\tif (x == n + 1) return 1ll;\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\tif (ones > maxr[x] - x + 1) return 0;\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << x << \" \" << ones << \" \" << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t\n\t//for (int i =1;i<=n;i++) {\n\t\t//cout << i << \" \" << maxr[i] << \"\\n\";\n\t//}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(1,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3000+10,mo=1000000007;\nint f[maxn][maxn],right[maxn],sum[maxn];\nint i,j,k,l,r,t,n,m,ans,one,zero;\nchar get(){\n    char ch=getchar();\n    while (ch!='0'&&ch!='1') ch=getchar();\n    return ch;\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    fo(i,1,n) sum[i]=get()-'0';\n    fo(i,1,n+1) sum[i]+=sum[i-1];\n    fo(i,1,n+1) right[i]=i;\n    fo(i,1,m){\n        scanf(\"%d%d\",&j,&k);\n        right[j]=max(right[j],k);\n    }\n    fo(i,1,n) right[i]=max(right[i],right[i-1]);\n    f[1][sum[right[1]]]=1;\n    fo(i,1,n)\n        fo(j,0,n)\n            if (f[i][j]){\n                l=right[i]+1;r=right[i+1];\n                one=j;zero=right[i]-i+1-j;\n                if (zero) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n                if (one) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n            }\n    ans=f[n+1][0];\n    (ans+=mo)%=mo;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 3010\n#define MOD 1000000007\n#define rep(i, x, y) for(int i = (x) ; i <= (y); i ++) \ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t} return x * f;\n}\nchar s[M]; int sum[M];\nint r[M];\nint f[M][M];\nint main() {\n\tint n = read(), m = read();\n\tscanf(\"%s\", s + 1);\n\trep(i, 1, n) sum[i] = sum[i - 1] + (s[i] == '1');\n\trep(i, 1, n) r[i] = i;\n\trep(i, 1, m) {\n\t\tint x = read(), y = read();\n\t\tr[x] = max(r[x], y);\n\t} rep(i, 1, n) r[i] = max(r[i - 1], r[i]);\n\tf[0][0] = 1;\n\trep(i, 1, n) {\n\t\trep(j, 0, sum[r[i - 1]]) if(f[i - 1][j]) {\n\t\t\tif(sum[r[i]] > j) (f[i][j + 1] += f[i - 1][j]) %= MOD;\n\t\t\tif(sum[r[i]] - j < r[i] - i + 1) (f[i][j] += f[i - 1][j]) %= MOD;\n\t\t}\n\t} cout << f[n][sum[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005;\nconst int md = 1e9 + 7;\n\nint n, m;\nstring s;\nint r[N], cnt[N], mx[N];\nint f[N][N];\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m >> s; s = ' ' + s;\n\tfor (int i = 1; i <= n; ++i) cnt[i] = cnt[i-1] + (s[i] == '1');\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint L, R; cin >> L >> R; r[L] = max(r[L], R);\n\t}\n\tfor (int i = 1; i <= n; ++i) mx[i] = max(mx[i-1], r[i]), mx[i] = max(mx[i], i);\n\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) if (f[i-1][j]) {\n\t\t\tint nj = j + max(0, cnt[mx[i]] - cnt[mx[i-1]]);\n\t\t\tint w = mx[i] - i + 1;\n\t\t\tif (w - nj > 0) f[i][nj] = (f[i][nj] + f[i-1][j]) % md;\n\t\t\tif (nj > 0) f[i][nj - 1] = (f[i][nj - 1] + f[i-1][j]) % md;\n\t\t}\n\t}\n\n\tcout << f[n][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\nconstexpr int MOD = 1e9 + 7;\nmint<MOD> solve(int n, int m, string const & s, vector<pair<int, int> > ops) {\n    // remove included queries\n    ops.erase(unique(ALL(ops), [&](auto a, auto b) {\n        assert (a.first <= a.second);\n        return a.second >= b.second;\n    }), ops.end());\n    m = ops.size();\n\n    // cumulative sums of '1'\n    vector<int> cnt(n + 1);\n    REP (i, n) cnt[i + 1] += cnt[i] + (s[i] - '0');\n\n    vector<mint<MOD> > cur(n + 1), prv;\n    cur[0] = 1;\n    REP (j, m) {\n        int l, r; tie(l, r) = ops[j];\n        cur.swap(prv);\n        cur.assign(n + 1, 0);\n\n        // previous\n        int prev_r = (j == 0 ? 0 : ops[j - 1].second);\n        if (prev_r < l) {\n            prev_r = l;\n            REP3 (a, 1, n + 1) assert (prv[a].value == 0);\n        }\n\n        // next\n        int next_l = (j == m - 1 ? n : ops[j + 1].first);\n        if (r < next_l) next_l = r;\n\n        // fix [l, next_l)\n        int a0 = cnt[r] - cnt[prev_r];\n        int b0 = (r - prev_r) - a0;\n        REP (a1, prev_r - l + 1) if (prv[a1].value) {\n            int b1 = (prev_r - l) - a1;\n            REP (a, next_l - l + 1) {\n                int b = (next_l - l) - a;\n                if (a <= a0 + a1 and b <= b0 + b1) {\n                    cur[a0 + a1 - a] += prv[a1] * choose<MOD>(a + b, a);\n                }\n            }\n        }\n    }\n\n    REP3 (a, 1, n + 1) assert (cur[a].value == 0);\n    return cur[0];\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int> > ops(m);\n    REP (j, m) {\n        int l, r; cin >> l >> r;\n        -- l;\n        ops[j] = { l, r };\n    }\n    cout << solve(n, m, s, ops).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\t//cout << \"start: \" << x << \" \" << ones << \" \" << maxr[x] - x + 1 << \"\\n\";\n\tif (x == n + 1) return 1ll;\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\tif (ones > maxr[x] - x + 1) return 0;\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//~ cout << x << \" \" << ones << \" \" << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\t//~ FAST\n\tcin >> n >> m;\n\tcin >> S;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t\n\t//for (int i =1;i<=n;i++) {\n\t\t//cout << i << \" \" << maxr[i] << \"\\n\";\n\t//}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(1,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll ncr[3001][3001];\nconst int MOD = 1e9 + 7;\n\nll choose(int n, int r)\n{\n\tif(r==0) return 1;\n\tif(n<r) return 0;\n\tif(ncr[n][r]!=-1) return ncr[n][r];\n\tncr[n][r]=(choose(n-1,r-1)+choose(n-1,r))%MOD;\n\treturn ncr[n][r];\n}\n\nll dp[3001][3001];\nll modinv[3001];\nll fact[3001];\n\nll modpow(ll a, ll b)\n{\n\tll r = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=(r*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a,MOD-2);\n}\n\nint pre[3001];\nint countone(int l, int r)\n{\n\tif(l==0) return pre[r];\n\treturn pre[r]-pre[l-1];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(ncr,-1,sizeof(ncr));\n\tfor(int i = 1; i <= 3000; i++) modinv[i] = inv(i);\n\tfact[0]=1;\n\tfor(int i = 1; i <= 3000; i++) fact[i]=(fact[i-1]*i)%MOD;\n\tint n, m; cin>>n>>m;\n\tstring s; cin >> s;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i]=='1') pre[i]=1;\n\t\tif(i>0) pre[i]+=pre[i-1];\n\t}\n\tvector<ii> vec;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint l, r; cin>>l>>r;\n\t\tl--; r--;\n\t\tvec.pb(mp(l,r));\n\t}\t\n\tvector<ii> move;\n\tsort(vec.begin(),vec.end());\n\tint cur = -1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(vec[i].se>cur)\n\t\t{\n\t\t\tmove.pb(vec[i]);\n\t\t\tcur=vec[i].se;\n\t\t}\n\t}\n\tmove.pb(mp(n,n));\n\tm = move.size();\n\t//dp[0][countone(move[0].fi,move[0].se)] = choose(move[0].se-move[0].fi+1, countone(move[0].fi,move[0].se));\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tint l = move[0].fi;\n\t\tint mid = min(move[1].fi-1, move[0].se);\n\t\tint r = move[0].se;\n\t\tint cnt = countone(l,r);\n\t\t//i is [mid+1,r]\n\t\tif(i>cnt) break;\n\t\tif(i>r-mid) break;\n\t\tdp[0][i] = choose(mid-l+1,cnt-i);\n\t\t//cerr<<0<<' '<<i<<' '<<dp[0][i]<<'\\n';\n\t}\n\tfor(int i = 1; i < m - 1; i++)\n\t{\n\t\tint l = move[i].fi;\n\t\tint mid = min(move[i+1].fi-1, move[i].se);\n\t\tint r = move[i].se;\n\t\tint cnt = countone(l,r);\n\t\tif(move[i].fi>move[i-1].se)\n\t\t{\n\t\t\tll an = 0;\n\t\t\tfor(int j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\tan=(an+dp[i-1][j])%MOD;\n\t\t\t}\n\t\t\tfor(int j = 0; j <= r-mid; j++)\n\t\t\t{\n\t\t\t\tif(j>cnt) break;\n\t\t\t\tdp[i][j] = (an*choose(mid-l+1,cnt-j))%MOD;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt = countone(move[i-1].se+1,r);\n\t\t\t//this is the number of ones in the later part\n\t\t\t//Naive way\n\t\t\tfor(int x = 0; x <= r-mid; x++)\n\t\t\t{\n\t\t\t\tfor(int j = n; j >= max(0,x - cnt); j--)\n\t\t\t\t{\n\t\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int j = n; j >= max(0,r-mid - cnt); j--)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t}\n\t\t\tfor(int x = r-mid; x >= 0; x--)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j <= n; j++)\n\t\t{\n\t\t\tcerr<<i<<' '<<j<<' '<<dp[i][j]<<'\\n';\n\t\t}\n\t\t*/\n\t}\n\tll ans = dp[m-2][0];\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\nconst int MOD = 1000000007;\n\nint n, m;\nchar s[MAXN + 1];\npair<int, int> r[MAXM];\nint lim[MAXN];\n\nint dp[MAXN][MAXN + 1]; // #ways to get to [i..lim[i]] with j zeroes\nint cnt[MAXN + 1];\n\n\nvoid run() {\n\tscanf(\"%d%d%s\", &n, &m, s); REP(i, m) scanf(\"%d%d\", &r[i].first, &r[i].second), --r[i].first, --r[i].second;\n\tint mm = 0;\n\tREP(i,m) {\n\t\tif (mm != 0 && r[i].first == r[mm - 1].first&&r[i].second > r[mm - 1].second) { r[mm - 1].second = r[i].second; continue; }\n\t\tif (mm != 0 && r[i].second <= r[mm - 1].second) continue;\n\t\tr[mm++] = r[i];\n\t}\n\tm = mm;\n\tREP(i, n) lim[i] = i; REP(i, m) lim[r[i].first] = r[i].second; FOR(i, 1, n) if (lim[i - 1] > lim[i]) lim[i] = lim[i - 1];\n\t//REP(i, n) printf(\"%d \", lim[i]); puts(\"\");\n\tcnt[0] = 0; REP(i, n) cnt[i + 1] = cnt[i] + (s[i] == '0' ? 1 : 0);\n\n\tmemset(dp, 0, sizeof(dp)); dp[0][cnt[lim[0] + 1]] = 1;\n\tFOR(i, 1, n) {\n\t\tint inc = cnt[lim[i] + 1] - cnt[lim[i - 1] + 1];\n\t\tFORE(j, inc, lim[i] - i + 1) {\n\t\t\tdp[i][j] += dp[i - 1][j - inc + 1];\n\t\t\tif (j - inc != lim[i - 1] - (i - 1) + 1) dp[i][j] += dp[i - 1][j - inc];\n\t\t\tif (dp[i][j] >= MOD) dp[i][j] -= MOD;\n\t\t}\n\t}\n\t//REP(i, n) REPE(j, n) if (dp[i][j] > 0) printf(\"ways %d..%d with %d = %d\\n\", i, lim[i], j, dp[i][j]);\n\tint ret = dp[n - 1][0] + dp[n - 1][1]; if (ret >= MOD) ret -= MOD; printf(\"%d\\n\", ret);\n\n\t\n}\n\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\nll dp[3010][3010];\n\nint main(int argc, char const* argv[])\n{\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n  vector<int> l(m), r(m); rep(i, m)cin >> l[i] >> r[i], l[i]--, r[i]--;\n  int nex = 0;\n  int R = -1;\n  dp[0][0] = 1;\n  rep(i, n){\n    R = max(R, i - 1);\n    int rmax = R;\n    while(nex < m && l[nex] == i){\n      rmax = max(rmax, r[nex]);\n      nex++;\n    }\n    int k = 0;\n    for(int j = R + 1; j <= rmax; j++)if(s[j] == '1')k++;\n    R = rmax;\n    rep(j, n + 1){\n      if(j + k == 0){\n        (dp[i+1][j] += dp[i][j]) %= mod;\n      }else{\n        if(R - i + 1 > j + k && j + k <= n)(dp[i+1][j+k] += dp[i][j]) %= mod;\n        if(j + k > 0 && j + k - 1 <= n)(dp[i+1][j+k-1] += dp[i][j]) %= mod;\n      }\n    }\n  }\n  /*rep(i, n){\n    rep(j, n + 1){\n      cerr << i << \" \" << j << \" \" << dp[i+1][j] << endl;\n    }\n  }*/\n  cout << dp[n][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define NMAX 3005\n#define MMAX 3005\n#define mod 1000000007\n#define PIE 3.14159265358979\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N,M;\nstring S;\nint l_[MMAX],r_[MMAX];\nvector<int> sum;\n\nLL mpow(LL a,LL n){\n    LL ans = 1;\n    while(n>0){\n        if(n&1){ans=(ans*a)%mod;}\n        a=(a*a)%mod;\n        n>>=1;\n    }\n    return ans;\n}\n\nLL fact[NMAX+1];\nLL factinv[NMAX+1];\n\nLL comb(LL a,LL b){\n    LL ret = (fact[a]*factinv[b])%mod;\n    ret = (ret*factinv[a-b])%mod;\n    return ret;\n}\n\nLL dfs_[MMAX][NMAX];\n\nvoid init(){\n    fact[0]=1;\n    rep(i,NMAX){\n        fact[i+1]=fact[i]*(i+1);\n        fact[i+1]%=mod;\n    }\n    rep(i,NMAX+1){\n        factinv[i]=mpow(fact[i],mod-2);\n    }\n    rep(i,M+1){\n        rep(j,N+1){\n            dfs_[i][j]=-1;\n        }\n    }\n}\n\nLL dfs(int step,int czero_){\n    int czero=czero_;\n    if(dfs_[step][czero]>=0)return dfs_[step][czero];\n    if(step==M){\n        if(M>2){dfs_[M][czero]=comb(l_[M-1]-r_[M-2]+1,czero);}else{dfs_[M][czero]=1;}\n        return dfs_[M][czero];\n    }\n    int rp=0,ln=N+1;\n    int l=l_[step];\n    int r=r_[step];\n    if(step>0){\n        rp=r_[step-1];\n    }\n    if(step<M-1){\n        ln=l_[step+1];\n    }\n    if(r>=rp){czero+=sum[r]-sum[max(l,rp)];}\n    if(ln>=r){\n        dfs_[step][czero_]=(comb(r-l,czero)*dfs(step+1,0))%mod;\n        return dfs_[step][czero_];\n    }\n    LL ans = 0;\n    int nczeromax=min(r-ln,czero);\n    for(int nczero = max(0,czero-(ln-l));nczero<=nczeromax;nczero++){\n        ans += comb(ln-l,czero-nczero)*dfs(step+1,nczero);\n        ans %= mod;\n    }\n    dfs_[step][czero_]=ans;\n    return ans;\n}\n\nint main(){\n    cin>>N>>M;\n    cin>>S;\n    sum.push_back(0);\n    rep(i,N){\n        sum.push_back(sum[i]+('1'-S[i]));\n    }\n    init();\n    int now = 0;\n    int M_=M;\n    rep(i,M_){\n        cin>>l_[now]>>r_[now];\n        l_[now]--;\n        if(i==0){now++;}\n        else if(l_[now]==l_[now-1]){\n            M--;\n            r_[now-1]=max(r_[now],r_[now-1]);\n        }else if(r_[now]<=r_[now-1]){\n            M--;\n        }else{now++;}\n    }\n    \n    cout<<dfs(0,0)<<endl;\n//    rep(i,M+1){\n//        rep(j,N+1){\n//            printf(\"%4lld\",dfs_[i][j]);\n//        }\n//        cout<<endl;\n//    }\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    if(v[i].second < v[i+1].first){\n        return dp[i][s] = (pt[v[i].second-v[i].first+1][tmp]*saiki(i+1,0))%mod;\n    }else{\n        for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n            ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n        }\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    // for(int i=0;i<v.size();i++){\n    //     cout << v[i].first << \" \" <<v[i].second << endl;\n    // }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        for(int j=v[i-1].second+1;j<=min(v[i].second,v[i-1].second);j++){\n            if(s[j-1]=='1'){\n                tmp++;\n            }\n        }\n        nm[i] = tmp;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    if(v[0].second <v[1].first){\n        ans = (pt[v[0].second-v[0].first][tmp]*saiki(1,0))%mod;\n    }else{\n        for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n            ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 3011\n#define mod 1000000007\n\nint n, m, i, j, l, r, maxi;\nchar s[maxN];\nint sum[maxN];\nvector< pair<int, int> > ord, aux;\n\nll comb[maxN][maxN];\nll ans;\nll dp[maxN][maxN];\n\n\nvoid pre() {\n    int i, j;\n\n    for (i = 0; i <= n; i++) {\n        comb[i][0] = 1;\n        for (j = 1; j <= i; j++) {\n            comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];\n            if (comb[i][j] >= mod) comb[i][j] -= mod;\n        }\n    }\n}\n\nll sumi(ll x, ll y) {\n    return sum[y] - sum[x - 1];\n}\n\nll solve(int bg, int en) {\n    int i, j, k, l, r, new_l, new_r, intr_dim, dim;\n    int nr0, nr1, posl, posr, to;\n\n    aux.clear();\n    for (i = bg; i < en; i++)\n        aux.pb(ord[i]);\n\n    for (i = 0; i <= aux.size(); i++)\n        memset(dp[i], 0, sizeof(dp[i]));\n\n    dp[0][sumi(aux[0].first, aux[0].second)] = 1;\n    for (i = 0; i + 1 < aux.size(); i++) {\n        l = aux[i].first;\n        r = aux[i].second;\n        dim = r - l + 1;\n\n        new_l = aux[i + 1].first;\n        new_r = aux[i + 1].second;\n        intr_dim = new_l - l;\n\n        for (j = 0; j <= dim; j++) {\n            if (dp[i][j] == 0) continue;\n\n            nr1 = j;\n            nr0 = dim - nr1;\n\n            posl = max(0, intr_dim - nr0);\n            posr = min(intr_dim, nr1);\n\n            for (k = posl; k <= posr; k++) {\n                to = j - k + sumi(r + 1, new_r);\n                dp[i + 1][to] += (dp[i][j] * comb[intr_dim][k]) % mod;\n                if (dp[i + 1][to] >= mod) dp[i + 1][to] -= mod;\n            }\n        }\n    }\n\n    l = aux.back().first;\n    r = aux.back().second;\n    dim = r - l + 1;\n\n    ll ans = 0;\n    for (i = 0; i <= dim; i++)\n        ans += ( dp[aux.size() - 1][i] * comb[dim][i] ) % mod;\n\n    return ans % mod;\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d\\n%s\", &n, &m, s + 1);\n    for (i = 1; i <= m; i++) {\n        scanf(\"%d%d\", &l, &r);\n        ord.pb(mp(l, r));\n    }\n\n    sort(ord.begin(), ord.end(), [](const pair<int, int>& a, const pair<int, int>& b)->bool const {\n        return mp(a.first, -a.second) < mp(b.first, -b.second);\n    });\n\n    aux = ord;\n    ord.clear();\n\n    maxi = 0;\n    for (auto e : aux)\n        if (e.second > maxi)\n            maxi = e.second, ord.pb(e);\n\n    pre();\n    for (i = 1; i <= n; i++) sum[i] = sum[i - 1] + s[i] - '0';\n    ans = 1;\n\n    for (i = 0; i < ord.size(); i = j) {\n        for (j = i + 1; j < ord.size(); j++)\n            if (ord[j - 1].second < ord[j].first)\n                break;\n\n        ans = (ans * solve(i, j)) % mod;\n    }\n\n    printf(\"%lld\", ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ull mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow_mod(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nvl fact(3005);\n\nll Fact(ll n){\n\tif(fact[n]) return fact[n];\n\tif(!n) return fact[n]=1;\n\treturn fact[n]=Fact(n-1)*n%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow_mod(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(Fact(n),Fact(n-k)*Fact(k)%mod);\n}\n\nint n,m;\nstring s;\n\nint ff(int l,int r){\n\tint t=0;\n\tfor(int i=l;i<r;i++) t+=s[i]-'0';\n\treturn t;\n}\n\nll f(vp a){\n\tint l=a[0].first,r=a[0].second,t=ff(l,r);\n\tvl dp(n+1);\n\tdp[t]++;\n\tfor(int i=1;i<a.size();i++){\n\t\tint L=a[i].first,R=a[i].second;\n\t\tt=ff(r,R);\n\t\tvl DP(n+1);\n\t\tfor(int j=0;j<=r-l;j++) for(int k=max(0,L-r+j);k<=min(j,L-l);k++){\n\t\t\t(DP[j-k+t]+=nCk(L-l,k)*dp[j])%=mod;\n\t\t}\n\t\tl=L,r=R;dp=DP;\n\t}\n\tll res=0;\n\tfor(int i=0;i<=r-l;i++) (res+=dp[i]*nCk(r-l,i))%=mod;\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m>>s;\n\tvp a;\n\tll res=1;\n\tfor(int i=0;i<m;i++){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tif(a.empty()) a.push_back({l-1,r});\n\t\telse{\n\t\t\tint t=a.back().second;\n\t\t\tif(t<l){\n\t\t\t\t(res*=f(a))%=mod;\n\t\t\t\ta.clear();\n\t\t\t}\n\t\t\tif(t<r) a.push_back({l-1,r});\n\t\t}\n\t}\n\tif(a.size()) (res*=f(a))%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\tif (x == n) return 1ll;\n\t//cout << \"start: \" << x << \" \" << ones << \"\\n\";\n\t\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tdp[x][ones] %= mod;\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(firstl,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cstring>\n#define N 3005\nusing namespace std;\nconst int mod=1e9+7;\nint n,m;\nchar t[N];\nint s[N],val[N],dp[2][N];\nint main(){\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,t+1);\n\tfor(int i=1;i<=n;i++) s[i]=t[i]-'0'+s[i-1];\n\tint cnt=0;\n\tfor(int i=1,ml,mr;i<=m;i++)\n\t\tscanf(\"%d%d\",&ml,&mr),val[ml]=max(val[ml],mr);\n\tfor(int i=1;i<=n;i++) val[i]=max(max(i,val[i]),val[i-1]); \n\tint now=0;\n\tdp[now][0]=1;\n\tfor(int i=1;i<=n;i++,now^=1){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=max(0,s[val[i]]-(val[i]-i));j<=s[val[i]];j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+ (j==0?0:dp[now][j-1]) )%mod;\n\t}\n\tcout<<dp[now][s[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\t\n\tif (maxr[x] - x + 1 < ones) return 0ll;\n\tif (x == n) return 1ll;\n\t//cout << \"start: \" << x << \" \" << ones << \"\\n\";\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tdp[x][ones] %= mod;\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(firstl,0) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\nusing i64 = long long;\nusing pii = pair<int, int>;\n\nconst int N = 3005;\nconst i64 MOD = 1000000007;\n\nint v[N], st[N], dr[N];\ni64 dp[N][N];\n\nvector<pii> ivs;\nstring str;\nint n, m, one;\n\nint main() {\n#ifdef HOME\n\tfreopen(\"arc65d.in\", \"r\", stdin);\n\tfreopen(\"arc65d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\n\tcin >> n >> m;\n\tcin >> str;\n\tivs.resize(m);\n\tfor (auto &i: ivs)\n\t\tcin >> i.x >> i.y;\n\n\tfor (int i = 0; i < n; ++i) if (str[i] == '1')\n\t\tv[i + 1] = ++one;\n\n\tfor (int i = 0; i < m; ++i)\n\t\tstable_partition(v + ivs[i].x, v + ivs[i].y + 1, [&](int x) { return x; });\n\tfor (int i = 1; i <= n; ++i) if (v[i])\n\t\tst[v[i]] = i;\n\n\tmemset(v, 0x00, sizeof v);\n\tone = 0;\n\n\tfor (int i = 0; i < n; ++i) if (str[i] == '1')\n\t\tv[i + 1] = ++one;\n\n\tfor (int i = 0; i < m; ++i)\n\t\tstable_partition(v + ivs[i].x, v + ivs[i].y + 1, [&](int x) { return !x; });\n\tfor (int i = 1; i <= n; ++i) if (v[i])\n\t\tdr[v[i]] = i;\n\n\tfor (int i = 0; i <= n; ++i)\n\t\tdp[i][0] = 1;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= one; ++j) {\n\t\t\tdp[i][j]+= dp[i - 1][j];\n\n\t\t\tif (st[j] <= i && i <= dr[j]) \n\t\t\t\tdp[i][j]+= dp[i - 1][j - 1];\n\n\t\t\tif (dp[i][j] >= MOD)\n\t\t\t\tdp[i][j]-= MOD; }\n\n\tcout << dp[n][one] % MOD << endl;\n\n\treturn 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint N, M;\nstring S;\nstatic ll dp[3002][3002];\n\nconst ll MODP = 1000000007;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\nint main(void){\n\tcin >> N >> M;\n\tcin >> S;\n\tint l[M], r[M], c[M];\n\tint sum[N+1]={0};\n\tfor(int i=1;i<=N;i++){\n\t\tsum[i] = sum[i-1] + ((S[i-1]=='1') ? 1 : 0);\n\t}\n\tvpii a;\n\tint maxi = 0;\n\tfor(int i=0;i<=M;i++){\n\t\tif (i<M){\n\t\t\tcin >> l[i] >> r[i];\n\t\t}\n\t\tif (i==M || (i>0 && l[i]>l[i-1])){\n\t\t\ta.pb(mp(l[i-1], maxi));\n\t\t\tmaxi = 0;\n\t\t}\n\t\tif (i<M){\n\t\t\tmaxi = max(maxi, r[i]);\n\t\t}\n\t}\n\tvpii b;\n\tmaxi = -1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif (maxi < a[i].second){\n\t\t\tb.pb(a[i]);\n\t\t\tmaxi = a[i].second;\n\t\t}\n\t}\n\tfor(int i=0;i<b.size();i++){\n\t\tc[i] = sum[b[i].second] - sum[b[i].first-1];\n\t\tb[i].first--;\n\t\t//cout << b[i].first << \" \" << b[i].second << \" \" << c[i] << endl;\n\t}\n\t\n\tdp[0][c[0]] = 1;\n\tfor(int i=0;i+1<b.size();i++){\n\t\tfor(int j=0;j<=b[i].second-b[i].first;j++){\n\t\t\tfor(int k=0;k<=b[i+1].second-b[i+1].first;k++){\n\t\t\t\tint d = sum[b[i+1].second] - sum[b[i].second];\n\t\t\t\tint c1 = j - k + d;\n\t\t\t\tint c2 = k - d;\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << d << endl;\n\t\t\t\tif (d<0 || c1<0 || c2<0 || c2>b[i].second-b[i+1].first) continue;\n\t\t\t\tdp[i+1][k] += (dp[i][j] * comb(b[i+1].first - b[i].first, c1)) % MODP;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<b.size();i++){\n\t\tcout << \"i = \" << i << endl;\n\t\tfor(int j=0;j<3002;j++){\n\t\t\tif (dp[i][j]!=0){\n\t\t\t\tcout << \"dp[i][\" << j << \"] = \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tll ans = 0;\n\tfor(int i=0;i<3002;i++){\n\t\tans = (ans + dp[b.size()-1][i] * comb(b[b.size()-1].second - b[b.size()-1].first, i)) % MODP;\n\t}\n\tcout << ans << endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%MOD+MOD)%MOD){}\n    mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n    mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n    mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n    friend ostream& operator<<(ostream& os, const mint& mi)  \n\t{  \n\t    os << mi.x;  \n\t    return os;  \n\t}  \n};\n\nmint dp[3010][3010];\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tcin>>v[i].F>>v[i].S;\n\t\tv[i].F--;\n\t\tv[i].S--;\n\t}\n\tvector<pii> w;\n\trep(i,n){\n\t\tpii t=v[i];\n\t\treep(j,i+1,n){\n\t\t\tif(t.F<v[j].F && t.S<v[j].S){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti=j;\n\t\t\tmaxs(t.S,v[j].S);\n\t\t}\n\t\tw.PB(t);\n\t}\n\tint l = 0;\n\tint r = 0;\n\tw.PB(pll(n, n));\n\tdp[0][0].x=1;\n\trep(i,w.size()-1){\n\t\tint ll = l;\n\t\twhile(ll<w[i].F) ll++;\n\t\trep(i,3010){\n\t\t\tdp[ll][i]=dp[l][i];\n\t\t}\n\t\tl=ll;\n\t\tint c = 0;\n\t\tmaxs(r, l);\n\t\twhile(r<=w[i].S){\n\t\t\tc += s[r]=='1';\n\t\t\tr++;\n\t\t}\n\t\tfor(int j=n;j>=0;j--){\n\t\t\tdp[l][j+c]=dp[l][j];\n\t\t}\n\t\trep(j,c){\n\t\t\tdp[l][j].x=0;\n\t\t}\n\t\twhile(l<w[i+1].F && l<=w[i].S){\n\t\t\trep(j,n){\n\t\t\t\tif(j) dp[l+1][j-1] += dp[l][j];\n\t\t\t\tif(w[i].S-l+1-j>0){\n\t\t\t\t\tdp[l+1][j] += dp[l][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t}\n\tmint ans;\n\trep(i,3010){\n\t\tans += dp[l][i];\n\t}\n\tcout<<ans.x<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 1 << 20;\n\nint n, m, f[N], g[N], r[N], L[N], R[N], tot[N], dp[1 << 12][1 << 12], ones[N], A[N], B[N], C[N];\nchar a[N];\npair<int, int> p[N];\n\ninline int calc_ones(int st, int en) {\n\tif (st == 0) return ones[en];\n\treturn ones[en] - ones[st - 1];\n}\n\ninline int nCm(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn (long long)f[n] * g[m] % mod * g[n - m] % mod;\n}\n\nnamespace FFT {\n\tconst int M = 1<<18;\n\n\tusing DB = long double;\n\tusing LL = long long;\n\n\tstruct CP {\n\t\tDB x, y;\n\t\tCP(DB x=0, DB y=0) : x(x), y(y) {}\n\t\tCP operator+(const CP &rhs) const {\n\t\t\treturn CP(x+rhs.x, y+rhs.y);\n\t\t}\n\t\tvoid operator+=(const CP &rhs) {\n\t\t\tx += rhs.x, y += rhs.y;\n\t\t}\n\t\tCP operator-(const CP &rhs) const {\n\t\t\treturn CP(x-rhs.x, y-rhs.y);\n\t\t}\n\t\tCP operator*(const CP &rhs) const {\n\t\t\treturn CP(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);\n\t\t}\n\t\tCP operator!() const {\n\t\t\treturn (CP) {\n\t\t\t\tx, -y\n\t\t\t};\n\t\t}\n\t\tvoid operator*=(const CP &rhs) {\n\t\t\tDB tx = x*rhs.x-y*rhs.y, ty = x*rhs.y+y*rhs.x;\n\t\t\tx = tx, y = ty;\n\t\t}\n\t} f[M], g[M], h[M], p_w[M+1];\n\n\tint bit_inv[M];\n\n\tvoid init() {\n\t\tDB alpha = acos(-1)/M*2;\n\t\tfor (int i = 0; i <= M; i++) p_w[i] = CP(cos(alpha*i), sin(alpha*i));\n\t\tfor (int i = 0, j = 1; j < M; j++) {\n\t\t\tfor (int k = M >> 1; (i ^= k) < k; k >>= 1);\n\t\t\tbit_inv[j] = i;\n\t\t}\n\t}\n\n\tvoid FFT(CP *A, int N, int D = 1) {\n\t\tfor (int j = 1, i, d = __builtin_ctz(M/N); j < N-1; j++) if ((i = (bit_inv[j] >> d)) < j) swap(A[i], A[j]);\n\t\tfor (int n = 1, m = M/2*D; n < N; m /= 2, n <<= 1) {\n\t\t\tfor (int i = 0; i < N; i += n<<1) {\n\t\t\t\tCP *w = (D == 1 ? p_w : p_w + M), *a = A+i, *b = A+i+n;\n\t\t\t\tfor (int j = 0; j < n; j++, a++, b++, w += m) {\n\t\t\t\t\tCP x = *w **b;\n\t\t\t\t\t*b = *a - x;\n\t\t\t\t\t*a += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D != 1) for (int i = 0; i < N; i++) A[i].x /= N, A[i].y /= N;\n\t}\n\n\tvoid conv(int *A, int *B, int *C, int N, int MOD) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t}\n\t\t\tmemcpy(C, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) g[i] = CP(B[i]>>15, B[i]&32767);\n\t\tFFT(g, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=((f[i]+!f[j])*(!g[j]-g[i])+(!f[j]-f[i])*(g[i]+!g[j]))*CP(0,0.25);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (LL(h[i].x+0.5)%MOD<<15)%MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=(!f[j]-f[i])*(!g[j]-g[i])*CP(-0.25, 0)+CP(0, 0.25)*(f[i]+!f[j])*(g[i]+!g[j]);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (C[i] + LL(h[i].x+0.5)+((LL(h[i].y+0.5)%MOD)<<30)) % MOD;\n\t}\n\n\tvoid conv(int *A, int *B, int N, int P) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * A[j]) % P;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * A[j]) % P;\n\t\t\t}\n\t\t\tmemcpy(B, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=((!(f[j]*f[j]))-f[i]*f[i])*CP(0,0.5);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (LL(g[i].x+0.5)%P<<15)%P;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=(!f[j]-f[i])*(!f[j]-f[i])*CP(-0.25,0)+CP(0,0.25)*(f[i]+!f[j])*(f[i]+!f[j]);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (B[i] + LL(g[i].x+0.5)+((LL(g[i].y+0.5)%P)<<30)) % P;\n\t}\n};\n\nint solve(int st, int en) {\n\tfor (int i = st; i <= en; i++) {\n\t\tint common = 0;\n\t\tif (i < en) common = p[i].second - p[i + 1].first + 1;\n\t\tR[i] = min(p[i].second - p[st].first + 1 - common, calc_ones(p[st].first, p[i].second));\n\t\tL[i] = max(0, R[i] - common);\n\t\ttot[i] = p[i].second - p[i].first + 1 - common;\n\t}\n\tfor (int i = st; i <= en; i++) {\n\t\tif (i == st) {\n\t\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = nCm(tot[i], j);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= R[i]; k++) A[k] = dp[i - 1][k];\n\t\tfor (int k = 0; k <= R[i]; k++) B[k] = nCm(tot[i], k);\n\t\tint len = 1 << (32 - __builtin_clz(R[i] * 2 - 1));\n\t\tfor (int k = R[i] + 1; k < len; k++) A[k] = B[k] = 0;\n\t\tFFT::conv(A, B, C, len, mod);\n\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = C[j];\n//\t\t{\n//\t\t\tfor (int k = L[i - 1]; k <= R[i - 1]; k++) {\n//\t\t\t\tdp[i][j] = (dp[i][j] + (long long)dp[i - 1][k] * nCm(tot[i], j - k)) % mod;\n//\t\t\t}\n//\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = L[en]; i <= R[en]; i++) ret = (ret + dp[en][i]) % mod;\n\treturn ret;\n}\n\nint main() {\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tFFT::init();\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tf[0] = r[0] = r[1] = g[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) f[i] = (long long)f[i - 1] * i % mod;\n\t\tif (i > 1) r[i] = (long long)(mod - mod / i) * r[mod % i] % mod;\n\t\tif (i) g[i] = (long long)g[i - 1] * r[i] % mod;\n\t}\n//\tint ans = 0;\n//\tfor (int a = 2; a <= 3; a++) {\n//\t\tfor (int b = 4 - a; b <= 5 - a; b++) {\n//\t\t\tint c = 7 - a - b;\n//\t\t\tans += nCm(3, a) * nCm(2, b) * nCm(4, c);\n//\t\t}\n//\t}\n//\tcout << ans << endl;\n\tcin >> n >> m >> a;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) ones[i] = ones[i - 1];\n\t\tif (a[i] == '1') ones[i]++;\n\t}\n\tvector<pair<int, int>> vec;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> p[i].first >> p[i].second;\n\t\tp[i].first--;\n\t\tp[i].second--;\n\t\tif (i && p[i].second <= p[i - 1].second) continue;\n\t\tvec.push_back(p[i]);\n\t}\n\tm = vec.size();\n\tfor (int i = 0; i < m; i++) p[i] = vec[i];\n\tcout << solve(0, m - 1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <limits>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\n// range_query\nenum RQ_type {\n    MAX_MAX, // 更新クエリ: i:[l, r]に対して、x[i] = max(x[i], o). 求値クエリ: i:[l, r]に対して max(x[l],...,x[r]).\n    MIN_MIN, // 更新クエリ: i:[l, r]に対して、x[i] = min(x[i], o). 求値クエリ: i:[l, r]に対して min(x[l],...,x[r]).\n    ADD_MAX, // 更新クエリ: i:[l, r]に対して、x[i] += o.           求値クエリ: i:[l, r]に対して max(x[l],...,x[r]).\n    ADD_MIN, // 更新クエリ: i:[l, r]に対して、x[i] += o.           求値クエリ: i:[l, r]に対して min(x[l],...,x[r]).\n    SUB_MAX, // 更新クエリ: i:[l, r]に対して、x[i] = o.            求値クエリ: i:[l, r]に対して max(x[l],...,x[r]).\n    SUB_MIN, // 更新クエリ: i:[l, r]に対して、x[i] = o.            求値クエリ: i:[l, r]に対して min(x[l],...,x[r]).\n    ADD_SUM, // 更新クエリ: i:[l, r]に対して、x[i] += o.           求値クエリ: i:[l, r]に対して sum(x[l],...,x[r]).\n    MANUAL, // 手動で任意のものを与える場合。\n};\n\ntemplate <RQ_type rqt>\nclass RQ {\n    public:\n\n    int n;\n    std::vector<int128_t> data, lazy;\n    RQ() {}\n    RQ(const int size) {\n        // 要素数を2のべき乗にする。\n        // kの子をk*2+1,k*2+2とするやり方は、0-index配列に準拠している。1-indexの配列に適用することも考えて、\n        // x[0]...x[size]が問題なく確保出来るよう、nはsize+1以上の2冪にする。\n        n = 1;\n        while (n < size + 1) {\n            n *= 2;\n        }\n        data.resize(n*2, id_val());\n        lazy.resize(n*2, id_op());\n    }\n\n    // 全てを初期値に戻す。セグメント木を何度も利用する場合に用いる。\n    void reset() {\n        for (int i = 0; i < data.size(); i++) {\n            data[i] = id_val(); lazy[i] = id_op();\n        }\n    }\n\n    // 求値クエリに寄与しない値。\n    // op1(v, id_val()) = op1(id_val(), v) = v となるもの。\n    int128_t id_val() {\n        switch(rqt) {\n            case MAX_MAX:\n            case ADD_MAX:\n            case SUB_MAX:\n                return std::numeric_limits<int64_t>::min();\n                // データをint128_tとしているのは、modの取り忘れ等でオーバーフローしないためであり、最大値最小値などは64bitに収まる想定。\n                // std::numeric_limits<int128_t>は出力が未定義で適切に存在するのか不明なので使わない。\n                // 最小値として別の値(0など)を用いるべきケースでは、適切に初期化クエリを行うこと。\n                // 加算クエリなら update(1, N, -rq.id_val())、それ以外なら update(1, N, 0)とすれば、[1,N]を0にできる。\n            case MIN_MIN:\n            case ADD_MIN:\n            case SUB_MIN:\n                return std::numeric_limits<int64_t>::max();\n            case ADD_SUM:\n                return 0;\n            case MANUAL:\n                assert(false);\n                return 0;\n        }\n    }\n\n    // 更新操作の単位元。何も更新しない操作。\n    // op2(v, id_op()) = v, op3(o, id_op()) = op3(id_op(), o) = o となるもの。\n    int128_t id_op() {\n        switch(rqt) {\n            case MAX_MAX:\n            case SUB_MIN:\n            case SUB_MAX:\n                return std::numeric_limits<int64_t>::min();\n                // 更新操作が代入の場合、正しくは単位元のフラグが必要だが、int64_tの最小値をフラグ代わりに利用する。\n                // 実際に数列の値をint64_tの最小値にすることは論理的にできなくなることに注意。\n            case MIN_MIN:\n                return std::numeric_limits<int64_t>::max();\n            case ADD_MAX:\n            case ADD_MIN:\n            case ADD_SUM:\n                return 0;\n            case MANUAL:\n                assert(false);\n                return 0;\n        }\n    }\n\n    // 求値クエリにおいて、2つの値を1つの値に結合する演算。\n    int128_t op1(int128_t v1, int128_t v2) {\n        switch(rqt) {\n            case MAX_MAX:\n            case ADD_MAX:\n            case SUB_MAX:\n                return std::max(v1, v2);\n            case MIN_MIN:\n            case ADD_MIN:\n            case SUB_MIN:\n                return std::min(v1, v2);\n            case ADD_SUM:\n                return v1 + v2;\n            case MANUAL:\n                assert(false);\n                return 0;\n        }\n    }\n\n    // 更新操作。以下の2つの条件のうち、どちらかが成り立つ必要がある。\n    // 条件1: 2つの値を結合してから更新操作した値と、2つの値に更新操作してから結合した値が等しい。すなわち\n    // op2(op1(v1, v2), o) = op1(op2(v1, o), op2(v2, o))\n    // 条件2: 2つの値を結合してから、2倍の更新操作をした値と、2つの値に更新操作してから結合した値が等しい。すなわち\n    // op2(op1(v1, v2), o*2) = op1(op2(v1, o), op2(v2, o))\n    // 条件2を満たす場合、各ノードでの更新は、対応する区間長さを係数とする操作を行う。\n    int128_t op2(int128_t v, int128_t o, const int l, const int r) {\n        switch(rqt) {\n            case MAX_MAX:\n                return std::max(v, o);\n            case MIN_MIN:\n                return std::min(v, o);\n            case ADD_MAX:\n            case ADD_MIN:\n                return v + o;\n            case SUB_MAX:\n            case SUB_MIN:\n                return o == id_op() ? v : o;\n            case ADD_SUM:\n                return v + o * (r - l);\n            case MANUAL:\n                assert(false);\n                return 0;\n        }\n    }\n\n    // 更新操作のマージ\n    // 2つの更新操作を2度行った結果と、2つの更新操作を1つにまとめた更新操作を1度行った結果が等しくなる必要がある。すなわち\n    // op2(op2(v, o1), o2) = op2(v, op3(o1, o2)) \n    int128_t op3(int128_t o1, int128_t o2) {\n        switch(rqt) {\n            case MAX_MAX:\n                return std::max(o1, o2);\n            case MIN_MIN:\n                return std::min(o1, o2);\n            case ADD_MAX:\n            case ADD_MIN:\n            case ADD_SUM:\n                return o1 + o2;\n            case SUB_MAX:\n            case SUB_MIN:\n                return o2 == id_op() ? o1 : o2;\n            case MANUAL:\n                assert(false);\n                return 0;\n        }\n    }\n\n    void push(const int k, const int l, const int r) { // node に対して、lazyの操作を行い、子のノードに伝播する。lazy[k]は単位元に戻す。\n        if (lazy[k] == id_op()) { return; }\n        if (k < n - 1) {\n            lazy[k*2 + 1] = op3(lazy[k*2 + 1], lazy[k]);\n            lazy[k*2 + 2] = op3(lazy[k*2 + 2], lazy[k]);\n        }\n        data[k] = op2(data[k], lazy[k], l, r);\n        lazy[k] = id_op();\n    }\n\n    // データ配列の区間[a,b)の連結値を求める。\n    // k:探索しているセグメント木の節点のセグメント木配列番号\n    // [l, r):kに対応する区間\n    int128_t query_child(const int a, const int b, const int k, const int l, const int r) {\n        if (r <= a || b <= l) { return id_val(); }\n        if (a <= l && r <= b) { return op2(data[k], lazy[k], l, r); }\n        push(k, l, r);\n\n        int128_t vl = query_child(a, b, k*2 + 1, l, (l+r)/2);\n        int128_t vr = query_child(a, b, k*2 + 2, (l+r)/2, r);\n        return op1(vl, vr);\n    }\n\n    // データ配列の区間[a,b]の連結値を求める。query_childと異なり閉区間\n    int128_t query(const int a, const int b) {\n        return query_child(a, b+1, 0, 0, n);\n    }\n\n    // [a, b)の区間に、oで表される演算を行う。\n    // k:探索しているセグメント木の節点のセグメント木配列番号\n    // [l, r):kに対応する区間\n    void update_child(const int a, const int b, const int k, const int l, const int r, int128_t o) {\n        if (r <= a || b <= l) { return; }\n        if (a <= l && r <= b) { \n            lazy[k] = op3(lazy[k], o);\n            return;\n        }\n        push(k, l, r);\n        const int mid = (l + r) / 2;\n        update_child(a, b, k*2 + 1, l, mid, o);\n        update_child(a, b, k*2 + 2, mid, r, o);\n        data[k] = op1(op2(data[k*2 + 1], lazy[k*2 + 1], l, mid), op2(data[k*2 + 2], lazy[k*2 + 2], mid, r));\n    } \n\n    // データ配列の区間[a,b]に、oで表される演算を行う。update_childと異なり閉区間\n    void update(const int a, const int b, int128_t o) {\n        update_child(a, b+1, 0, 0, n, o);\n    }\n\n    // データ配列の要素1つに、oで表される演算を行う。\n    void update_spot(const int a, int128_t o) {\n        update_child(a, a+1, 0, 0, n, o);\n    }\n};\n\nconst int MAX_N = 3050;\nint S[MAX_N]; \nint N, M;\nint l[MAX_N], r[MAX_N];\nint ac[MAX_N];\nconst int MOD = 1e9 + 7;\n\nRQ<MAX_MAX> rq = RQ<MAX_MAX>(MAX_N);\nint128_t dp[MAX_N][MAX_N] = {};\n\n\nint main(int argc, char **argv) {\n    std::cin >> N >> M;\n\n    for (int i = 1; i <= N; i++) {\n        char tmp;\n        std::cin >> tmp;\n        S[i] = (tmp == '1') ? 1 : 0;\n    }\n\n    for (int i = 1; i <= M; i++) {\n        std::cin >> l[i] >> r[i];\n    }\n\n    for (int i = 1; i <= N; i++) {\n        rq.update_spot(i, i);\n    }\n\n    ac[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        ac[i] = ac[i-1] + S[i];\n        //std::cout << i << \" \" << ac[i] << std::endl;\n    }\n\n    for (int i = 1; i <= M; i++) {\n        rq.update(l[i], r[i], r[i]);\n    }\n\n    \n    dp[0][0] = 1;\n\n    for (int i = 1; i <= N; i++) {\n        int right = rq.query(i, i);\n        for (int j = ac[right] - (right - i); j <= ac[right]; j++) {\n            dp[i][j] = dp[i-1][j];\n            if (0 < j) {\n                dp[i][j] += dp[i-1][j-1];\n            }\n            dp[i][j] %= MOD;\n        }\n    }\n\n    std::cout << dp[N][ac[N]] << std::endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\t//cout << \"start: \" << x << \" \" << ones << \" \" << maxr[x] - x + 1 << \"\\n\";\n\tif (x == n + 1) return 1ll;\n\tif (ones > maxr[x] - x + 1) return 0;\n\t\n\t\n\t\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tdp[x][ones] %= mod;\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << x << \" \" << ones << \" \" << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t\n\t//for (int i =1;i<=n;i++) {\n\t\t//cout << i << \" \" << maxr[i] << \"\\n\";\n\t//}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(1,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 3e3 + 5;\n\nll dp[MAXN][MAXN];\n\nint cnt[MAXN];\nint nxt[MAXN];\n\nchar c[MAXN];\n\nvoid solve(){\n\tint n, m;\n\tscanf(\"%d%d%s\", &n, &m, &c[1]);\n\tREPN(i, 1, n){\n\t\tnxt[i] = i;\n\t\tcnt[i] = cnt[i - 1] + (c[i] == '1');\n\t}\n\tREP(i, 0, m){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tnxt[l] = max(nxt[l], r);\n\t}\n\tREPN(i, 2, n){\n\t\tnxt[i] = max(nxt[i], nxt[i - 1]);\n\t}\n\t\n\tdp[0][0] = 1;\n\tREP(i, 0, n){\n\t\tREPN(j, 0, i){\n\t\t\tif (j < cnt[nxt[i + 1]]){\n\t\t\t\tdp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t\tif (i - j < nxt[i + 1] - cnt[nxt[i + 1]]){\n\t\t\t\tdp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[n][cnt[n]]);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 3000\n#define MOD 1000000007\nchar S[MN+5];\nint s[MN+5],l[MN+5],r[MN+5],f[MN+5][MN+5];\ninline void rw(int&a,int b){if((a+=b)>=MOD)a-=MOD;}\nint main()\n{\n\tint n,m,i,j,k;\n\tn=read();m=read();\n\tscanf(\"%s\",S+1);\n\tfor(i=1;i<=n;++i)s[i]=s[i-1]+(S[i]=='1');\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tl[i]=read();r[i]=read();\n\t\tif(l[i]==l[i-1])r[i-1]=max(r[i-1],r[i]);\n\t\tif(r[i]<=r[i-1]){--i;--m;continue;}\n\t}\n\tl[i]=r[i]=n+2;f[0][0]=1;\n\tfor(i=j=0;i<=n;++i)\n\t{\n\t\tif(i==l[j+1])++j;\n\t\tfor(k=0;k<=n;++k)if(f[i][k])\n\t\t{\n\t\t\tif(i+1<l[j+1])\n\t\t\t{\n\t\t\t\tif(i>r[j]||k<=r[j]-i)rw(f[i+1][k],f[i][k]);\n\t\t\t\tif(k)rw(f[i+1][k-1],f[i][k]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(i>r[j])rw(f[i+1][k+s[r[j+1]]-s[i]],f[i][k]);\n\t\t\t\telse if(k<=r[j]-i)rw(f[i+1][k+s[r[j+1]]-s[r[j]]],f[i][k]);\n\t\t\t\tif(k)rw(f[i+1][k-1+s[r[j+1]]-s[r[j]]],f[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 3010\n#define MO 1000000007\nint f[MAXN][MAXN],dp[MAXN][MAXN],n,m,a[MAXN];\nstruct node\n{\n\tint l,r;\n}p[MAXN];\nbool cmp(node a,node b)\n{\n\treturn a.l<b.l||(a.l==b.l&&a.r<b.r);\n}\nvoid Pre()\n{\n\tf[0][0]=1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+f[i-1][j-1])%MO;\n\t}\n}\nchar s[MAXN];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<n;i++)\n\t\ta[i+1]=a[i]+s[i]-'0';\n\tPre();\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tsort(p+1,p+1+m,cmp);\n\tint mx=0,tmp=m;\n\tfor(int i=1;i<=m;i++)\n\t\tif(p[i].l==p[i+1].l||p[i].r<=mx)\n\t\t\tp[i].l=n+1,tmp--;\n\t\telse mx=max(p[i].r,mx);\n\tsort(p+1,p+1+m,cmp);\n\tm=tmp;\n\tdp[p[1].l-1][a[p[1].l-1]]=1;\n\tp[m+1].l=n+1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=p[i].l,r=p[i].r,x=p[i+1].l;\n\t\tfor(int j=0;j<l;j++)\n\t\t{\n\t\t\tif(!dp[l-1][j]) continue;\n\t\t\tint s=a[r]-j,st=max(0,s-(r-x+1)),ed=min(s,x-l);\n\t\t\tif(x>r)\n\t\t\t{\n\t\t\t\tdp[x-1][a[x-1]]+=1LL*dp[l-1][j]*f[r-l+1][s]%MO;\n\t\t\t\tdp[x-1][a[x-1]]%=MO;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=st;k<=ed;k++)\n\t\t\t{\n\t\t\t\tdp[x-1][j+k]+=1LL*dp[l-1][j]*f[x-l][k]%MO;\n\t\t\t\tdp[x-1][j+k]%=MO;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][a[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define maxn 3005\n#define mod 1000000007\nusing namespace std;\nint n,m,ri[maxn],cnt[maxn],dp[maxn][maxn];\nchar s[maxn];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n+1;i++) ri[i]=i;\n\tfor(int i=1;i<=n;i++) cnt[i]=cnt[i-1]+s[i]-'0';\n\tcnt[n+1]=cnt[n];\n\twhile(m--)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tri[l]=max(ri[l],r);\n\t}\n\tfor(int i=1;i<=n;i++) ri[i]=max(ri[i],ri[i-1]);\n\tdp[1][cnt[ri[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(dp[i][j])\n\t\t\t{\n\t\t\t\tint l=ri[i]+1,r=ri[i+1];\n\t\t\t\tif(j) dp[i+1][j+cnt[r]-cnt[l-1]-1]=(dp[i+1][j+cnt[r]-cnt[l-1]-1]+dp[i][j])%mod;\n\t\t\t\tif(ri[i]-i+1-j) dp[i+1][j+cnt[r]-cnt[l-1]]=(dp[i+1][j+cnt[r]-cnt[l-1]]+dp[i][j])%mod;\n\t\t\t}\n\tprintf(\"%d\\n\",(dp[n+1][0]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n\n#define eps 1e-11\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 337\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 500031;\n\nint n, m;\nstring st;\nint l[N], r[N];\nint s1[N], s2[N];\n\nint dp[3050][3050];\n\nstring solve(string st, int flag)\n{\n\tfor (int i = 1; i <=m; i++)\n\t{\n\t\tint a, b;\n\t\ta = l[i] - 1;\n\t\tb = r[i];\n\t\tsort(st.begin() + a, st.begin() + b);\n\t\tif (flag)\n\t\t\treverse(st.begin() + a, st.begin() + b);\n\t}\n\treturn st;\n}\n\nint main(){\n\t//freopen(\"tree.in\",\"r\",stdin);\n\t//freopen(\"tree.out\",\"w\",stdout);\n\t//\tfreopen(\"F:/input.txt\", \"r\", stdin);\n\t//\tfreopen(\"F:/output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> m;\n\tcin >> st;\n\t\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> l[i] >> r[i];\n\t}\n\n\tstring st1 = solve(st,0);\n\tstring st2 = solve(st,1);\n\t\n\tfor (int i = 0; i < st1.size(); i++)\n\t{\n\t\ts1[i + 1] = s1[i] + st1[i] - 48;\n\t\ts2[i + 1] = s2[i] + st2[i] - 48;\n\t}\n\n\t//cout << st1 << \" \" << st2 << endl;\n\t\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tfor (int j = 0; j <= i; j++)\n\t\t{\n\t\t\tfor (int ad = 0; ad <= 1; ad++)\n\t\t\t{\n\t\t\t\tif (j + ad<s1[i + 1] || j + ad>s2[i + 1])\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i + 1][j + ad] += dp[i][j];\n\t\t\t\tdp[i + 1][j + ad] %= bs;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i <= st.size(); i++)\n\t{\n\t\tans = ans + dp[st.size()][i];\n\t\tans %= bs;\n\t}\n\tcout << ans << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=next;\n            prel=prer=l;\n            continue;\n        }\n        int l = max(0,x-y+a[y]) , r=a[y];\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 3000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nint n, m, a[N], dp[N][N], DP[N], mark[N], ps[N], nCr[N][N], PS[N];\nstruct SEG{\n\tint l, r;\n};\nvector<SEG> seg1, seg;\nvector<int> koj[N];\n\nvoid calc(){\n\tnCr[0][0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\tnCr[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++){\n\t\t\tnCr[i][j] = nCr[i - 1][j - 1] + nCr[i - 1][j];\n\t\t\tnCr[i][j] %= MOD;\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcalc();\n\tcin >> n >> m;\n\t//cout << nCr[6][3] << '\\n';\n\tstring s;\n\tcin >> s;\n\tfor (int i = 1; i <= n; i++){\n\t\t//char c;\n\t\t//cin >> c;\n\t\t\n\t\tif (s[i - 1] == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tPS[i] = PS[i - 1];\n\t\tPS[i] += a[i];\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tSEG a;\n\t\tcin >> a.l >> a.r;\n\t\tseg1.pb(a);\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (seg1[i - 1].l <= seg1[j - 1].l && seg1[j - 1].r <= seg1[i - 1].r) mark[j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tif (!mark[i]) seg.pb(seg1[i - 1]);\n\t}\n\tfor (auto u:seg){\n\t\tkoj[u.l].pb(u.r);\n\t\t//cout << u.l << ' ' << u.r << '\\n';\n\t\tps[u.l]++;\n\t\tps[u.r + 1] --;\n\t}\n\tfor (int i = 1; i <= n; i++) ps[i] += ps[i - 1];\n\tDP[n + 1] = 1;\n\tint last = n + 1;\n\tfor (int i = n; i >= 1; i--){\n\t\tif (ps[i] == 0) DP[i] = DP[i + 1];\n\t\telse if(koj[i].size() == 0) DP[i] = DP[i + 1];\n\t\telse{\n\t\t\tif (last <= koj[i][0]){\n\t\t\t\tfor (int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tfor (int k = max(0ll, j - (koj[i][0] - last + 1)); k <= min(j, last - i); k++){\n\t\t\t\t\t\tdp[i][j] += (dp[last][j - k + PS[koj[last][0]] - PS[koj[i][0]]] * 1ll * nCr[last - i][k]) % MOD;\n\t\t\t\t\t\tdp[i][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tdp[i][j] = nCr[koj[i][0] - i + 1][j] * 1ll * DP[koj[i][0] + 1] % MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDP[i] = dp[i][PS[koj[i][0]] - PS[i - 1]];\n\t\t\tlast = i;\n\t\t}\n\t\t//cout << i << ' ' << DP[i] << '\\n';\n\t}\n\tcout << DP[1];\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <memory.h>\nusing namespace std;\n\nint n,m,s[3001],pf[3001];\nint comb[3001][3001];\nvector<pair<int,int>> v;\nconst int mod=1e9+7;\n\nint range1(int s,int e){ return pf[e]-pf[s-1]; }\nint range0(int s,int e){ return e-s+1-range1(s,e); }\n\nint dp[3001][3001];\n\nint f(int now,int befleft1,int befleft0)\n{\n\tif(now==v.size()) return 1;\n\n\tif(~dp[now][befleft1]) return dp[now][befleft1];\n\n\tint now1, now0;\n\tif(now==0 || v[now-1].second < v[now].first)\n\t{\n\t\tnow1=range1(v[now].first, v[now].second);\n\t\tnow0=range0(v[now].first, v[now].second);\n\t}\n\telse\n\t{\n\t\tnow1=befleft1+range1(v[now-1].second+1, v[now].second);\n\t\tnow0=befleft0+range0(v[now-1].second+1, v[now].second);\n\t}\n\n\tlong long ans=0;\n\tif(now==v.size()-1 || v[now].second < v[now+1].first)\n\t{\n\t\tint should = v[now].second - v[now].first + 1;\n\t\tans+=comb[should][now1]*1ll*f(now+1,0,0);\n\t\tans%=mod;\n\t}\n\telse\n\t{\n        int should = v[now+1].first - v[now].first;\n        for(int i=max(0,should-now0); i<=min(should,now1); i++)\n        {\n\t\t\tans+=comb[should][i]*1ll*f(now+1, now1-i, now0-(should-i));\n\t\t\tans%=mod;\n        }\n\t}\n\treturn dp[now][befleft1]=ans;\n}\n\nint main()\n{\n\tmemset(dp,-1,sizeof(dp));\n    scanf(\"%d %d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n\t\tscanf(\"%1d\",&s[i]);\n\t\tpf[i]=pf[i-1]+s[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j==0 || j==i) comb[i][j]=1;\n\t\t\telse comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%mod;\n\t\t}\n    for(int i=1,l,r;i<=m;i++)\n    {\n\t\tscanf(\"%d %d\",&l,&r);\n\t\tif(v.empty()) v.push_back(make_pair(l,r));\n\t\telse if(v.back().second >= r) continue;\n\t\telse if(v.back().first == l) v.back().second = r;\n\t\telse v.push_back(make_pair(l,r));\n\t}\n\tprintf(\"%d\\n\",f(0,0,0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <string>\n#define SIZE 3005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nint L[SIZE],R[SIZE];\nchar str[SIZE];\nll dp[SIZE];\nll nxt[SIZE];\nint sz;\n\nvoid make()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll C(int a,int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",&str);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint l,r;\n\t\tscanf(\"%d %d\",&l,&r);l--,r--;\n\t\tif(sz>0&&L[sz-1]==l) R[sz-1]=max(R[sz-1],r);\n\t\telse if(sz==0||R[sz-1]<r)\n\t\t{\n\t\t\tL[sz]=l;\n\t\t\tR[sz]=r;\n\t\t\tsz++;\n\t\t}\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tdp[0]=1;\n\tint c=0;\n\tfor(int i=0;i<sz;i++)\n\t{\n\t\t//printf(\"* %d %d\\n\",L[i],R[i]);\n\t\tint one=0;\n\t\tint f=L[i];\n\t\tif(i>0) f=max(f,R[i-1]+1);\n\t\tfor(int j=f;j<=R[i];j++) if(str[j]=='1') one++;\n\t\t\n\t\t//printf(\"%d %d\\n\",one,c);\n\t\tif(one>0)\n\t\t{\n\t\t\tfor(int j=c;j>=0;j--)\n\t\t\t{\n\t\t\t\tdp[j+one]=dp[j];\n\t\t\t\tdp[j]=0;\n\t\t\t}\n\t\t}\n\t\t//今 1 が何個あるかが分かった\n\t\tint wt=0;\n\t\tif(i+1<sz) wt=max(wt,R[i]-L[i+1]+1);\n\t\t//wt 個残したい\n\t\tint len=R[i]-L[i]+1;\n\t\tfor(int j=0;j<len-wt;j++)\n\t\t{\n\t\t\tfor(int k=0;k+1<SIZE;k++)\n\t\t\t{\n\t\t\t\tdp[k]+=dp[k+1];\n\t\t\t\tif(dp[k]>=MOD) dp[k]-=MOD;\n\t\t\t}\n\t\t\tdp[len-j]=0;\n\t\t}\n\t\t//for(int j=0;j<10;j++) printf(\"%d \",dp[j]);puts(\"\");\n\t\tc=wt;\n\t}\n\tprintf(\"%d\\n\",dp[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\nconst int MAX_N = 3005, MOD = 1000000007;\ntypedef long long i64;\ni64 f[2][MAX_N], C[MAX_N][MAX_N];\nint L[MAX_N], R[MAX_N];\nchar s[MAX_N];\n\nint main() {\n  int N, M;\n  \n  scanf(\"%d%d\", &N, &M);\n  scanf(\"%s\", s + 1);\n\n  assert(strlen(s + 1) == N);\n  \n  for (int i = 1; i <= M; ++i) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n    assert(L[i] >= L[i - 1]);\n    assert(L[i] < R[i]);\n    assert(R[i] <= N);\n    if (R[i] <= R[i - 1]) i--, M--;\n  }\n  \n  for (int i = 0; i <= N; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n  }\n  \n  int o = 0, p;\n  R[0] = L[1] - 1, f[0][0] = 1, L[M + 1] = N + 1;\n  \n  for (int i = 1; i <= M; ++i) {\n    p = o, o ^= 1;\n    memset(f[o], 0, sizeof f[o]);\n    int num = 0;\n    for (int j = R[i - 1] + 1; j <= R[i]; ++j)\n      if (s[j] == '1') num++;\n    \n    int temp1 = R[i - 1] - L[i] + 1, temp2 = max(R[i] - L[i + 1] + 1, 0);\n    \n    for (int k1 = 0; k1 <= temp1; ++k1) {\n      int num1 = num + k1, num0 = R[i] - L[i] + 1 - num1;\n      for (int k2 = 0; k2 <= temp2; ++k2) {\n\tint rest1 = num1 - k2, rest0 = num0 - temp2 + k2;\n\tif (rest1 < 0 || rest0 < 0) continue;\n\tf[o][k2] = (f[o][k2] + C[rest1 + rest0][rest1] * f[p][k1] % MOD) % MOD;\n      }\n    }\n    if (R[i] < L[i + 1] - 1) R[i] = L[i + 1] - 1;\n  }\n\n  printf(\"%lld\\n\", (f[o][0] + MOD) % MOD);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\n#define x first\n#define y second\n#define MOD 1000000007\n#define NMAX 3005\n\nint n, m, d[NMAX][NMAX], ones;\nchar s[NMAX];\npair<int,int> interval[NMAX];\n\nstruct segTree{\n    int sum, lazy;\n};\n\nsegTree aintL[10 * NMAX], aintR[10 * NMAX];\n\nvoid updateNode(segTree aint[], int n, int left, int right, int val){\n    aint[n].sum= (right - left + 1) * val;\n    aint[n].lazy = val;    \n}\n\nvoid update(segTree aint[], int n, int left, int right, int a, int b, int val){\n    if(a <= left  && right <= b){\n        updateNode(aint, n, left, right, val);\n        return ;\n    }\n    int mid = (left + right) / 2;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        update(aint, 2 * n, left, mid, a, b, val);\n    if(b > mid)\n        update(aint, 2 * n + 1, mid + 1, right, a, b, val);\n    aint[n].sum = aint[2 * n].sum + aint[2 * n + 1].sum;\n}\n\nint queryCount(segTree aint[], int n, int left, int right, int a, int b){\n    if(a <= left && right <= b){\n        return aint[n].sum;\n    }\n    int mid = (left + right) / 2, ans1 = 0, ans2 = 0;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        ans1 = queryCount(aint, 2 * n, left, mid, a, b);\n    if(b > mid)\n        ans2 = queryCount(aint, 2 * n + 1, mid + 1, right, a, b);\n    return ans1 + ans2;\n}\n\nint main (){\n    pair<int,int> seg;\n    \n    scanf(\"%d%d\\n\",&n,&m);\n    scanf(\"%s\",s + 1);\n    for(int i = 1; i <= n; i++){\n        update(aintL, 1, 1, n, i, i, s[i] - '0');\n        update(aintR, 1, 1, n, i, i, s[i] - '0');\n    }\n    for(int i = 1; i <= m; i++){\n        scanf(\"%d%d\",&seg.x,&seg.y);\n        int cnt = queryCount(aintL, 1, 1, n, seg.x, seg.y);\n        update(aintL, 1, 1, n, seg.x, seg.x + cnt - 1, 1);\n        update(aintL, 1, 1, n, seg.x + cnt, seg.y, 0);\n        \n        cnt = queryCount(aintR, 1, 1, n, seg.x, seg.y);\n        update(aintR, 1, 1, n, seg.x, seg.y - cnt, 0);\n        update(aintR, 1, 1, n, seg.y - cnt + 1, seg.y, 1);\n    }\n    \n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintL, 1, 1, n, i, i)){\n            interval[++ones].x = i;\n        }\n    }\n    ones = 0;\n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintR, 1, 1, n, i, i)){\n            interval[++ones].y = i;\n        }\n    }\n    \n    d[0][0] = 1;\n    for(int i = 1; i <= n; i++)\n        for(int j = 0; j <= ones; j++){\n            d[i][j] = d[i - 1][j];\n            if(j && interval[j].x <= i && i <= interval[j].y)\n                d[i][j] += d[i - 1][j - 1];\n            if(d[i][j] >= MOD)\n                d[i][j] -= MOD;\n        }\n    printf(\"%d\\n\", d[n][ones]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tptmp.erase(std::unique(ptmp.begin(), ptmp.end()), ptmp.end());\n\tvector<int> lefs;\n\tfor(int i=0;i<ptmp.size();i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second){\n\t\tif( i == ptmp.size()-1 || ptmp[i].first != ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tdp[i][j+s[i-1]-'0'] += dp[i-1][j];\n\t\t\t\tdp[i][j+s[i-1]-'0'] %= inf;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAXN=3000;\nconst int MOD=1e9+7;\nvoid A(int& a,int b){a+=b;if(a>=MOD)a-=MOD;}\nint n,m,r[MAXN+10],f[MAXN+10][MAXN+10],sm[MAXN+10];\nchar s[MAXN+10];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=1;i<=n;++i)sm[i]=sm[i-1]+s[i]-'0',r[i]=i;\n\tfor(int i=1,a,b;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tr[a]=max(r[a],b);\n\t}\n\tfor(int i=1;i<=n;++i)r[i]=max(r[i],r[i-1]);\n\tf[1][sm[r[1]]]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tif(!f[i][j])continue;\n\t\t\tint k=sm[r[i+1]]-sm[r[i]];\n\t\t\tif(j<r[i]-i+1&&j+k<=r[i+1]-i)A(f[i+1][j+k],f[i][j]);\n\t\t\tif(j>0&&j+k-1<=r[i+1]-i)A(f[i+1][j+k-1],f[i][j]);\n\t\t}\n\t}\n\tint ans=f[n][0];A(ans,f[n][1]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 3010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%1d\", a + i);\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j){\n            if(j > R){\n                R = j;\n                ad = a[i];\n            }\n            else ad = 0;\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad = sum[r] - sum[R];\n            R = r;\n        }\n        else ad = 0;\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j){\n        if(j > R){\n            R = j;\n            ad = a[i];\n        }\n        else ad = 0;\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3010\n#define MOD 1000000007\n#define int ull\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\nbool vis[maxn][maxn];\npi A[maxn];\nint fac[10001];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint mult(int a,int b){ //logb\n\tint res = 0;\n\ta %= MOD;\n\twhile (b){\n\t\tif (b&1) res = (res + a) % MOD;\n\t\t\n\t\ta = (2*a) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = mult(res,x);  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn mult(a,qexp(b,MOD-2));\n}\n\nint choose(ll n,ll k){\n\tif (n < k) return 0;\n\treturn modinv(modinv(fac[n],fac[k]),fac[n-k]);\n}\n\ninline int qry(pi i){\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\n\n\n\n\nint dpf(int i,int j){\n\tif (vis[i][j]) return dp[i][j];\n\tvis[i][j] = 1;\n\t\n\tif (i == M) return dp[i][j] = 1;\n\tif (i == M-1){\n\t\treturn dp[i][j] = choose(sz(A[i]),j);\n\t}\n\t\n\tdp[i][j] = 0;\n\t\n\tFOR(k,0,N){\n\t\tif (k > sz(inter(A[i],A[i+1]))) break;\n\t\tif (k > j) break;\n\t\t\n\t\tdp[i][j] += mult(dpf(i+1,qry(A[i+1]) - qry(inter(A[i],A[i+1])) + k),choose(sz(A[i]) - sz(inter(A[i],A[i+1])),j - k));\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n\t\t\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,10000){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\t\t\t\n\tcout<<dpf(0,qry(A[0]));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 3030;\nconst int MAXM = 3030;\nconst int MOD = 1000000007;\ninline int add(int x, int y) { return (x + y) % MOD; }\n\nchar S[MAXN];\nint cnt[MAXN];\nint dp[MAXN][MAXN];\nint l[MAXM], r[MAXM];\n\nint main() {\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int i = 0; i < M; i++)\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\tcnt[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tcnt[i] = cnt[i - 1] + S[i] - '0';\n\tdp[l[0] - 1][cnt[l[0] - 1]] = 1;\n\tint ans = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tint tl = l[i], tr = r[i];\n\t\twhile(i + 1 < M && (l[i + 1] == tl || r[i + 1] <= tr)) {\n\t\t\ti++;\n\t\t\ttr = max(tr, r[i]);\n\t\t}\n\t\tfor(int j = tl; (i == M - 1 || j < l[i + 1]) && j <= tr; j++) {\n\t\t\tfor(int k = 0; k <= N; k++) {\n\t\t\t\tif(cnt[tr] >= k && tr - cnt[tr] >= j - k) {\n\t\t\t\t\tif(k == 0)\n\t\t\t\t\t\tdp[j][k] = dp[j - 1][k];\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[j][k] = add(dp[j - 1][k - 1], dp[j - 1][k]);\n\t\t\t\t}\n\t\t\t\t/*if(cnt[tr] )\n\t\t\t\t\tdp[j][k] += dp[j - 1][k];*/\n\t\t\t\tdebug(\"dp[%d][%d] = %d\\n\", j, k, dp[j][k]);\n\t\t\t}\n\t\t}\n\t\tif(i == M - 1) {\n\t\t\tans = dp[tr][cnt[tr]];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3005\n#define Mod 1000000007ll\n#define Val(x) (((long long)x) % Mod)\nusing namespace std;\nstruct op {\n\tint l,r;\n};\nint sum[maxn],C[maxn][maxn];\nint dp[maxn][maxn];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<op> ops;\n\tfor(int i=0,l,r;i<m;i++) {\n\t\tcin >> l >> r;\n\t\tif(!ops.empty() && ops.back().r >= r)\tcontinue;\n\t\tif(!ops.empty() && ops.back().l == l)\tops.pop_back();\n\t\tops.emplace_back(op{l,r});\n\t}\n\t\t\n\treverse(s.begin(),s.end());\n\ts += \"0\";\n\treverse(s.begin(),s.end());\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i] = sum[i-1] + s[i] - '0';\n\t\t\n\tC[1][0] = C[1][1] = 1;\n\tfor(int i=2;i<=n;i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j=1;j<i;j++)\n\t\t\tC[i][j] = Val(C[i-1][j] + C[i-1][j-1]);\n\t}\n\t\n\tm = (int)ops.size();\n\tdp[ops.front().l-1][sum[ops.front().l-1]] = 1;\n\tfor(int i=0;i<m-1;i++) {\n\t\tint l = ops[i].l , r = ops[i].r;\n\t\tint nxt_l = ops[i+1].l;\n\t\tif(r <= nxt_l - 1) {\n\t\t\tfor(int j=0;j<=l-1;j++) {\n\t\t\t\tif(dp[l-1][j] == 0)\t\tcontinue;\n\t\t\t\tint rem = sum[r] - j;\n\t\t\t\tdp[nxt_l-1][sum[nxt_l-1]] = Val(dp[l-1][j] * C[r-l+1][rem] + dp[nxt_l-1][sum[nxt_l-1]]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=0;j<=l-1;j++) {\n\t\t\t\tif(dp[l-1][j] == 0)\t\tcontinue;\n\t\t\t\tint rem = sum[r] - j;\n\t\t\t\tint len = nxt_l-1 - l + 1, num = min(len,rem);\n\t\t\t\tfor(int k=0;k<=num;k++)\n\t\t\t\t\tif(rem - k <= r - nxt_l + 1)\t// won't remain too many '1' in [nxt_l,r]\n\t\t\t\t\t\tdp[nxt_l-1][j+k] = Val(dp[l-1][j] * C[len][k] + dp[nxt_l-1][j+k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++)\n\t\tif(dp[ops.back().l-1][i] != 0)\n\t\t\tans = Val(dp[ops.back().l-1][i] * C[ops.back().r-ops.back().l+1][sum[ops.back().r]-i] + ans);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid read(int &x) {\n\tchar ch; bool ok;\n\tfor(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n\tfor(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=3010,mod=1e9+7;\nchar ch[maxn];\nint n,m,f[maxn][maxn],tot,sum[maxn],las[maxn];\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint main()\n{\n\tread(n),read(m);scanf(\"%s\",ch+1);\n\tfor(rg int i=1;i<=n+1;i++){\n\t\tsum[i]=sum[i-1],las[i]=i;\n\t\tif(ch[i]=='1')tot++,sum[i]++;\n\t}\n\tfor(rg int i=1,x,y;i<=m;i++)read(x),read(y),las[x]=max(las[x],y);\n\tfor(rg int i=1;i<=n+1;i++)las[i]=max(las[i],las[i-1]);\n\tf[1][sum[las[1]]]=1;\n\tfor(rg int i=1;i<=n;i++){\n\t\tfor(rg int j=0;j<=tot;j++){\n\t\t\tint a=las[i],b=las[i+1];\n\t\t\tif(j)f[i+1][j+sum[b]-sum[a]-1]=add(f[i+1][j+sum[b]-sum[a]-1],f[i][j]);\n\t\t\tif(las[i]+1-i-j)f[i+1][j+sum[b]-sum[a]]=(f[i+1][j+sum[b]-sum[a]],f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 3000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,s[MN+5],f[MN+5],g[MN+5],l[MN+5],r[MN+5],p[MN+5],inv[MN+5];\nchar st[MN+5];\nvoid Move(int s)\n{\n\tfor(int i=n;i>=s;--i) f[i]=f[i-s];\n\tfor(int i=0;i<s;++i) f[i]=0;\n}\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;} \nint main()\n{\n\tn=read();m=read();scanf(\"%s\",st+1);p[0]=p[1]=inv[0]=inv[1]=f[0]=1;\n\tfor(int i=1;i<=n;++i) s[i]=s[i-1]+(st[i]=='1');\n\tfor(int i=2;i<=n;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=n;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;n=0;\n\tfor(int i=1;i<=m;++i) l[i]=read(),n=max(n,r[i]=read());l[m+1]=n+1;\n\tfor(int i=1,mr=l[1]-1;i<=m;++i)\n\t{\n\t\tif(r[i]>mr) Move(s[r[i]]-s[mr]),mr=r[i];\n\t\tif(l[i+1]>l[i])\n\t\t{\n\t\t\tint len=min(l[i+1]-1,mr)-l[i]+1;\n\t\t\tfor(int j=0;j<=n;++j) if(f[j])\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=j&&k<=len;++k) if(mr-l[i]+1-j>=len-k)\n\t\t\t\t\tg[j-k]=(g[j-k]+1LL*f[j]*C(len,k))%mod;\t\n\t\t\t}\n\t\t\tfor(int j=0;j<=n;++j) f[j]=g[j],g[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3010\n#define MOD 1000000007\n#define int ll\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\n\npi A[maxn];\nint fac[maxn];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = (res*x) % MOD;  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn (a * qexp(b,MOD-2)) % MOD;\n}\n\nint choose(int n,int k){\n\tif (n < k) return 0;\n\treturn modinv(fac[n],(fac[k] * fac[n-k]) % MOD);\n}\n\ninline int qry(pi i){\n\tint a = i.f, b = i.s;\n\tif (a == 0) return ss[b];\n\treturn ss[b] - ss[a-1];\n}\n\n\nint dpf(int i,int j){\n\tif (dp[i][j] != -1) return dp[i][j];\n\t\n\tif (i == M) return 1;\n\t\n\tdp[i][j] = 0;\n\t\n\tif (i == M-1){\n\t\tif (i == 0){\n\t\t\tdp[i][j] = choose(sz(A[i]),qry(A[i]));\n\t\t\treturn dp[i][j];\n\t\t}\n\t\tdp[i][j] = choose(sz(A[i]),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\treturn dp[i][j];\n\t}\n\t\n\tint mxsize;\n\tint sm;\n\tif (i > 0){\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\tsm = qry(pi(A[i-1].s + 1,A[i].s)) + j;\n\t}else{\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(A[i]));\n\t\tsm = qry(A[i]);\n\t}\n\t\n\tFOR(k,0,mxsize){\n\t\tdp[i][j] += (dpf(i+1,k) * choose(sz(A[i]) - sz(inter(A[i],A[i+1])),sm - k)) % MOD;\n\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,N){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\tmem(dp,-1);\n\t\t\t\n\tcout<<dpf(0,0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long lli;\nlli n,m;\nstring s;\nvector<lli> rightend;\nvector<vector<lli> > dp;\nvector<lli> sum;\nint main(){\n    cin >> n >> m;\n    cin >> s;\n    rightend = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) rightend[i] = i;\n    for(lli i = 0;i < m;i++){\n        lli l,r;\n        cin >> l >> r;\n        rightend[l] = max(rightend[l],r);\n    }\n    sum = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) sum[i] = s[i-1] - '0';\n    for(lli i = 0;i < n;i++) sum[i+1] += sum[i];\n    for(lli i = 0;i < n;i++) rightend[i+1] = max(rightend[i+1],rightend[i]);\n    dp = vector<vector<lli> > (n+2,vector<lli>(n+2));\n    dp[0][0] = 1;\n    for(lli i = 0;i < n;i++){\n        lli b,e;\n        b = max(0ll,i - (rightend[i] - sum[rightend[i]]));\n        e = min(i,sum[rightend[i]]);\n        for(lli j = b;j <= e;j++){\n            dp[i+1][j] += dp[i][j];\n            dp[i+1][j+1] += dp[i][j];\n        }\n    }\n    cout << dp[n][sum[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n \nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n \nusing namespace std;\nconst int N=3010,mod=1e9+7;\nchar s[N];\nint n,m,ans,c[N][N],l[N],r[N],lb[N],rb[N],f[N][N],a[N];\n \nint main()\n{\n    n=get(),m=get();\n    rep(i,0,n)\n    {\n        c[i][0]=1;\n        rep(j,1,i)\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n    }\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        lb[i]=max(0,lb[i-1]+w-s),rb[i]=min(mx,rb[i-1]+w);\n        rep(j,lb[i],rb[i])\n            rep(k,max(j-w,lb[i-1]),min(s+j-w,rb[i-1]))\n                f[i][j]=(f[i][j]+1ll*f[i-1][k]*c[s][k+w-j])%mod;\n    }\n    rep(i,lb[m],rb[m])\n        ans=(ans+f[m][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nlong long int dp[3001][3002];\nint sum[3001];\nchar s[3001];\nint r[3001];\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>s[i];\n\t\tsum[i]=s[i]-'0';\n\t\tsum[i]+=sum[i-1];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tr[i]=i;\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tcin>>x>>y;\n\t\tr[x]=max(r[x],y);\n\t}\n\tdp[0][0]=1;\n\tint now=0;\n\tfor(int i=0;i<n;i++){\n\t\tint tnow=max(now,r[i+1]);\n\t\tfor(int j=0;j<=3000;j++){\n\t\t\tint ones,zeros;\n\t\t\tif(r[i+1]>now)\n\t\t\t\tones=j+sum[tnow]-sum[now];\n\t\t\telse\n\t\t\t\tones=j;\n\t\t\tzeros=tnow-ones-i;\n\t\t\tif(ones)\n\t\t\t\tdp[i+1][ones-1]=(dp[i+1][ones-1]+dp[i][j])%mod;\n\t\t\tif(zeros)\n\t\t\t\tdp[i+1][ones]=(dp[i+1][ones]+dp[i][j])%mod;\n\t\t}\n\t\tnow=tnow;\t\n\t}\n\tcout<<dp[n][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nusing std::max;\nconst int mod=1000000007;\nint n,m,s[3010],right[3010];\nint x,y,f[3010][3010];\nchar S[3010];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s\",S+1);\n\tfor(int i=1;i<=n;i++)\n\t\ts[i]=S[i]-'0';\n\tfor(int i=1;i<=n+1;i++)\n\t\ts[i]+=s[i-1];\n\tfor(int i=1;i<=n+1;i++)\n\t\tright[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tright[x]=max(right[x],y);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tright[i]=max(right[i],right[i-1]);\n\tf[1][s[right[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(f[i][j]){\n\t\t\t\tint l=right[i]+1,r=right[i+1];\n\t\t\t\tint bo1=j,bo2=right[i]-i+1-j;\n\t\t\t\tif(bo2)(f[i+1][j+s[r]-s[l-1]]+=f[i][j])%=mod;\n\t\t\t\tif(bo1)(f[i+1][j-1+s[r]-s[l-1]]+=f[i][j])%=mod;\n\t\t\t}\n\tprintf(\"%lld\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tvector<int> lefs;\n\tfor(int i=0;i<m;i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second){\n\t\tif( i == m-1 || ptmp[i].first != ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tdp[i][j+s[i-1]-'0'] += dp[i-1][j];\n\t\t\t\tdp[i][j+s[i-1]-'0'] %= inf;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nconst int MOD = int(1e9) + 7;\n\nint n, m;\nchar buf[3005];\nint a[3005], le[3005], ri[3005];\nint from[3005], to[3005];\nint lsum[3005], rsum[3005];\nint d[3005], nd[3005];\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", buf);\n    forn(i, n) {\n        a[i] = buf[i] - '0';\n    }\n    forn(i, m) {\n        scanf(\"%d%d\", from + i, to + i);\n        --from[i];\n        --to[i];\n    }\n    forn(i, n) {\n        le[i] = a[i];\n    }\n    forn(i, m) {\n        int z = 0, o = 0;\n        for (int j = from[i]; j <= to[i]; ++j) {\n            if (le[j] == 0) ++z;\n            else ++o;\n        }\n        for (int j = from[i]; j <= to[i]; ++j) {\n            if (z) {\n                --z;\n                le[j] = 0;\n            } else {\n                le[j] = 1;\n            }\n        }\n    }\n\n    forn(i, n) {\n        ri[i] = a[i];\n    }\n    forn(i, m) {\n        int z = 0, o = 0;\n        for (int j = from[i]; j <= to[i]; ++j) {\n            if (ri[j] == 0) ++z;\n            else ++o;\n        }\n        for (int j = from[i]; j <= to[i]; ++j) {\n            if (o) {\n                --o;\n                ri[j] = 1;\n            } else {\n                ri[j] = 0;\n            }\n        }\n    }\n\n    lsum[0] = rsum[0] = 0;\n    forn(i, n) {\n        lsum[i + 1] = lsum[i] + le[i];\n        rsum[i + 1] = rsum[i] + ri[i];\n    }\n    memset(d, 0, sizeof d);\n    d[0] = 1;\n    forn(i, n) {\n        memset(nd, 0, sizeof nd);\n        for (int j = lsum[i]; j <= rsum[i]; ++j) {\n            add(nd[j], d[j]);\n            add(nd[j + 1], d[j]);\n        }\n        for (int j = lsum[i + 1] - 1; j >= max(0, lsum[i + 1] - 5); --j) {\n            nd[j] = 0;\n        }\n        for (int j = rsum[i + 1] + 1; j <= min(n, rsum[i + 1] + 5); ++j) {\n            nd[j] = 0;\n        }\n        memcpy(d, nd, sizeof d);\n    }\n    int ans = 0;\n    forn(i, n + 1) {\n        add(ans, d[i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\tif (l[i]<=r[i-1])\n\t\t{\n\t\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(l[i+1]-l[i],j-k))%mo;\n\t\t}\n\t\telse f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1000*1000*1000+7;\nint N, M;\nchar S[3010];\nvector<pii> seg;\nint st[3010], ed[3010];\nint prec[3010], psum[3010];\nint in[3010];\n\nint cc[3010][3010];\nint dp(int idx, int cnt) {\n\tif(idx == N) return cnt == psum[N - 1];\n\tint &ret = cc[idx][cnt];\n\tif(ret != -1) return ret;\n\n\tint cur = psum[prec[idx]] - cnt;\n\tif(idx && prec[idx - 1] - idx + 1 < psum[prec[idx - 1]] - cnt) return ret = 0;\n\tif(!in[idx]) return ret = dp(idx + 1, cnt + (S[idx] - '0'));\n\n\tret = 0;\n\tif(cur) ret += dp(idx + 1, cnt + 1), ret %= mod;\n\tret += dp(idx + 1, cnt), ret %= mod;\n\treturn ret;\n}\n\nint main() {\n\tscanf(\"%d %d\", &N, &M);\n\tscanf(\"\\n\");\n\tfor(int i = 0; i < N; i++) {\n\t\tscanf(\"%c\", &S[i]);\n\t}\n\tfor(int i = 0; i < M; i++) {\n\t\tint l, r; scanf(\"%d %d\", &l, &r);\n\t\tl--; r--;\n\t\tif(seg.size() == 0 || seg.back().first < l) {\n\t\t\tif(seg.size() == 0 || seg.back().second < r) seg.push_back(pii(l, r));\n\t\t}\n\t\telse if(seg.back().second < r) seg.back().second = r;\n\t}\n\tmemset(st, -1, sizeof(st));\n\tmemset(ed, -1, sizeof(ed));\n\tfor(int i = 0; i < seg.size(); i++) st[ seg[i].first ] = seg[i].second, ed[ seg[i].second + 1 ] = i;\n\tfor(int i = 0; i < N; i++) {\n\t\tif(i && prec[i - 1] >= i) in[i] = 1;\n\t\tprec[i] = i;\n\t\tif(i) prec[i] = max(prec[i], prec[i - 1]);\n\t\tif(st[i] != -1) prec[i] = st[i], in[i] = 1;\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tpsum[i] = S[i] - '0';\n\t\tif(i) psum[i] += psum[i - 1];\n\t}\n\tmemset(cc, -1, sizeof(cc));\n\tcout<<dp(0, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint solve(string s, vector<int> l, vector<int> r) {\n\tint N = s.length(), M = l.size();\n\tint R = l[0], zero = 0, one = 0;\n\tint j = 0;\n\tvector<int> dp(N + 1);\n\tdp[0] = 1;\n\tfor (int i = l[0]; i < r[M - 1]; i++) {\n\t\tif (j < M && i == l[j]) {\n\t\t\tfor (int i = R; i < r[j]; i++) {\n\t\t\t\tif (s[i] == '0') zero++;\n\t\t\t\telse one++;\n\t\t\t}\n\t\t\tR = r[j];\n\t\t\tj++;\n\t\t}\n\t\tvector<int> _dp(N + 1);\n\t\tfor (int x = 0; x <= N; x++) {\n\t\t\tint k0 = i - l[0] - x, k1 = x;\n\t\t\tif (k0 < 0 || k1 < 0) continue;\n\t\t\tif (k0 < zero) _dp[x] = (_dp[x] + dp[x]) % MOD;\n\t\t\tif (k1 < one) _dp[x + 1] = (_dp[x + 1] + dp[x]) % MOD;\n\t\t}\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= N; x++)\n\t\tans = (ans + dp[x]) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tvector<int> l, r;\n\tint ma = 0;\n\twhile (M--) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--;\n\t\tif (y <= ma) continue;\n\t\tma = y;\n\t\tl.pb(x); r.pb(y);\n\t}\n\tM = l.size();\n\tvector<int> v;\n\tv.pb(0);\n\tfor (int j = 0; j + 1 < M; j++)\n\t\tif (r[j] <= l[j + 1])\n\t\t\tv.pb(j + 1);\n\tv.pb(M);\n\tint ans = 1;\n\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\tvector<int> _l, _r;\n\t\tfor (int j = v[k]; j < v[k + 1]; j++)\n\t\t\t_l.pb(l[j]), _r.pb(r[j]);\n\t\tans = (ll)ans * solve(s, _l, _r) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e3 + 10;\ntemplate <class T>\ninline void _read(T &x)\n{\n\tx = 0;\n\tchar t = getchar();\n\twhile (!isdigit(t)) t = getchar();\n\twhile (isdigit(t))\n\t{\n\t\tx = x * 10 + t - '0';\n\t\tt = getchar();\n\t}\n}\nint n, m;\nchar ch[MAXN];\nint sum[MAXN], f[MAXN][MAXN], las[MAXN], tot;\nconst int mo = 1e9 + 7;\nint add(int x, int y)\n{\n\treturn x + y >= mo ? x + y - mo : x + y;\n}\nint main()\n{\n\t_read(n), _read(m);\n\tscanf(\"%s\", ch + 1);\n\tfor (int i = 1; i <= n + 1; ++i)\n\t{\n\t\tsum[i] = sum[i - 1], las[i] = i;\n\t\tif (ch[i] == '1') ++tot, ++sum[i];\n\t}\n\tfor (int i = 1, x, y; i <= m; ++i) _read(x), _read(y), las[x] = max(las[x], y);\n\tfor(int i = 1; i <= n + 1; ++i)las[i] = max(las[i], las[i - 1]);\n\tf[1][sum[las[1]]] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 0; j <= tot; ++j)\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tint a = las[i], b = las[i + 1];\n\t\t\t\tif(j)f[i + 1][j + sum[b] - sum[a] - 1] = add(f[i + 1][j + sum[b] - sum[a] - 1], f[i][j]);\n\t\t\t\tif(las[i] + 1 - i - j) f[i + 1][j + sum[b] - sum[a]] = (f[i + 1][j + sum[b] - sum[a]], f[i][j]);\n\t\t\t}\n\tprintf(\"%d\\n\", f[n + 1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\nclass Modulo\n{\npublic:\n    Modulo(const ll n, const ll mod = MOD) : size{n + 1}, mod{mod}, fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)  // mod should be prime\n    {\n        for (ll i = 2; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % mod;\n            inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod;\n            inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod;\n        }\n    }\n    ll factorial(const ll n) const\n    {\n        assert(n < size);\n        return fact[n];\n    }\n    ll inverse(const ll n) const\n    {\n        assert(n < size);\n        return inv[n];\n    }\n    ll inverseFactorial(const ll n) const\n    {\n        assert(n < size);\n        return inv_fact[n];\n    }\n    ll permutation(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (fact[n] * inv_fact[n - k]) % mod;\n    }\n    ll combination(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod;\n    }\n    ll homogenious(const ll n, const ll k) const { return (n == 0 and k == 0 ? 1 : combination(n + k - 1, k)); }\n\nprivate:\n    const ll size;\n    const ll mod;\n    vector<ll> fact;\n    vector<ll> inv;\n    vector<ll> inv_fact;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<vector<ll>> tmp(3001);\n    for (ll i = 0; i < M; i++) {\n        ll l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (tmp[l].size() > 0) {\n            if (tmp[l][0] < r) {\n                tmp[l][0] = r;\n            }\n        } else {\n            tmp[l].push_back(r);\n        }\n    }\n    using P = pair<ll, ll>;\n    vector<P> R;\n    ll r = 0;\n    for (ll i = 0; i <= 3000; i++) {\n        if (tmp[i].size() > 0 and tmp[i][0] > r) {\n            R.push_back({i, tmp[i][0]});\n            r = tmp[i][0];\n        }\n    }\n    const ll size = R.size();\n    vector<P> intersect(size);\n    intersect[0] = {-1, -1};\n    for (ll i = 1; i < size; i++) {\n        if (R[i].first > R[i - 1].second) {\n            intersect[i] = {R[i].first, R[i].first - 1};\n        } else {\n            intersect[i] = {R[i].first, R[i - 1].second};\n        }\n    }\n    intersect.push_back({N, N});\n    vector<ll> one(size + 1, 0);\n    vector<ll> one_orig(size, 0);\n    for (ll i = 0; i < size; i++) {\n        if (i == 0) {\n            one[i] = 0;\n        } else {\n            for (ll j = intersect[i].first; j <= intersect[i].second; j++) {\n                one[i] += (S[j] == '1' ? 1 : 0);\n            }\n        }\n        for (ll j = R[i].first; j <= R[i].second; j++) {\n            one_orig[i] += (S[j] == '1' ? 1 : 0);\n        }\n    }\n    Modulo mod(N + 1);\n    vector<ll> dp(N + 1, 0);  // i番目の区間\n    dp[0] = 1;\n    for (ll i = 0; i < size; i++) {\n        vector<ll> tmp(N + 1, 0);\n        for (ll j = 0; j <= intersect[i].second - intersect[i].first + 1; j++) {\n            if (dp[j] > 0) {\n                const ll tot = one_orig[i] - one[i] + j;\n                const ll next = intersect[i + 1].second - intersect[i + 1].first + 1;\n                const ll rest = R[i].second - R[i].first + 1 - next;\n                for (ll k = max(0LL, tot - rest); k <= min(tot, next); k++) {\n                    (tmp[k] += mod.combination(rest, tot - k) * dp[j] % MOD) %= MOD;\n                }\n            }\n        }\n        dp = tmp;\n    }\n    ll ans = 0;\n    for (ll i = 0; i <= N; i++) {\n        (ans += dp[i]) %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tq[m+1].l=n+1;q[m+1].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[1][sum[q[1].r]-sum[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i].r-q[i].l+1;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tfor(int j=0;j<=LEN;j++)\n\t\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;k++){\n\t\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\t\n\tq[m+1].l=n+1;q[m+1].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[1][sum[q[1].r]-sum[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i].r-q[i].l+1;//qujianchang\n\t\t\tint len=q[i].r-q[i+1].l+1;//jiaojichang\n\t\t\tint pre=q[i+1].l-q[i].l;//qianzhui\n\t\t\tfor(int j=0;j<=LEN;j++)\n\t\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;k++){\n\t\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(0,x-y+a[y]) ,r=min(prer+y-v[i].fi+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nint l[3005], r[3005];\nll ncr[3005][3005];\nll dp[3005][3005];\nchar buf[3005];\nint cu[3005];\nint n, m;\n\nll slv(int at, int ones)\n{\n\tif (at == m) return 1;\n\tif (dp[at][ones]) return dp[at][ones];\n\tif (r[at] >= l[at+1])\n\t{\n\t\tint lim = min(l[at+1]-l[at], ones);\n\t\tfor (int i = max(0, ones-r[at]+l[at+1]-1);i <= lim;i++)\n\t\t{\n\t\t\tdp[at][ones] += slv(at+1, ones-i+cu[r[at+1]]-cu[r[at]])*ncr[l[at+1]-l[at]][i];\n\t\t\tdp[at][ones] %= MOD;\n\t\t}\n\t} else\n\t{\n\t\tdp[at][ones] = ncr[r[at]-l[at]+1][ones] * slv(at+1, cu[r[at+1]]-cu[l[at+1]-1]);\n\t\tdp[at][ones] %= MOD;\n\t}\n\treturn dp[at][ones];\n}\n\nint main()\n{\n\tncr[0][0] = 1;\n\tfor (int i = 1;i < 3005;i++)\n\t{\n\t\tncr[i][0] = 1;\n\t\tfor (int j = 1;j <= i;j++) ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % MOD;\n\t}\n\tscanf(\"%d%d%s\", &n, &m, buf);\n\tfor (int i = 0;i < m;i++) scanf(\"%d%d\", l+i, r+i), --l[i], --r[i];\n\tfor (int i = 1;i < m;i++) r[i] = max(r[i], r[i-1]);\n\tfor (int i = 0;i < n;i++) cu[i] = buf[i]-'0';\n\tfor (int i = 1;i < n;i++) cu[i] += cu[i-1];\n\tl[m] = r[m] = n;\n\tprintf(\"%lld\\n\", slv(0, cu[r[0]]));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define MAXN 3006\n#define MOD 1000000007\nusing namespace std;\nint n,m,ll,rr,r[MAXN],d[MAXN][MAXN],sum[MAXN];\nchar s[MAXN];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tsum[i]=sum[i-1];\n\t\tif(i<=n) sum[i]+=s[i]-'0';\n\t\tr[i]=i;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&ll,&rr);\n\t\tr[ll]=max(r[ll],rr);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tr[i]=max(r[i],r[i-1]);\n\td[1][sum[r[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(!d[i][j]) continue;\n\t\t\tif(j) d[i+1][j-1+sum[r[i+1]]-sum[r[i]]]=(d[i+1][j-1+sum[r[i+1]]-sum[r[i]]]+d[i][j])%MOD;\n\t\t\tif(r[i]-(i-1)-j) d[i+1][j+sum[r[i+1]]-sum[r[i]]]=(d[i+1][j+sum[r[i+1]]-sum[r[i]]]+d[i][j])%MOD;\n\t\t}\n\tprintf(\"%d\",(d[n+1][0]+MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    REP(i, M){\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        int t = n1[rmax + 1];\n        if(l1 <= rmax){\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            REP(k, t + 1){\n                dp[i + 1][n1[l1]] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][n1[l1]] %= mod;\n            }\n        }\n    }\n    //debug(dp);\n    cout << dp[M][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 3010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,m;\n\nchar st[maxn];\n\nint r[maxn],mn[maxn],mx[maxn],dp[maxn][maxn],sm[maxn],sm2[maxn];\n\nvoid Work(){\n\tdp[0][0]=1;\n\tREP(i,0,n-1)\n\t\tREP(j,0,n)if(dp[i][j]&&j>=mn[i]&&j<=mx[i]){\n\t\t\t(dp[i+1][j]+=dp[i][j])%=mod;\n\t\t\t(dp[i+1][j+1]+=dp[i][j])%=mod;\n\t\t}\n\tiout(dp[n][mn[n]]);\n}\n\nvoid Init(){\n\tread(n,m);\n\tscanf(\"%s\",st+1);\n\tREP(i,1,n)r[i]=i;\n\tREP(i,1,m){\n\t\tint x,y;\n\t\tread(x,y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tREP(i,1,n)sm[i]=sm[i-1]+(st[i]=='1'),sm2[i]=sm2[i-1]+(st[i]=='0');\n\tint lst=0,now=0;\n\tREP(i,1,n){\n\t\tnow=now+max(sm[r[i]]-sm[lst],0);\n\t\tlst=max(lst,r[i]);\n\t\tif(now)mx[i]=1,now--;\n\t}\n\tREP(i,1,n)mx[i]+=mx[i-1];\n\tlst=0;now=0;\n\tREP(i,1,n){\n\t\tnow=now+max(sm2[r[i]]-sm2[lst],0);\n\t\tlst=max(lst,r[i]);\n\t\tif(now)now--;else mn[i]=1;\n\t}\n\tREP(i,1,n)mn[i]+=mn[i-1];\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,q; string s;\nvector<P>vec;\nll dp[3005][3005],C[3005][3005];\nint main(){\n    C[0][0]=1;\n    for(int i=1;i<3005;i++)for(int j=0;j<=i;j++){\n        if(j==0||j==i)C[i][j]=1LL;\n        else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    }\n\tcin>>n>>q>>s;\n\trep(i,q){\n\t\tint a,b;cin>>a>>b;\n\t\tif(vec.empty() || vec[vec.size()-1].sc<b){\n\t\t\tif(!vec.empty() && vec[vec.size()-1].fi == a){\n\t\t\t\tvec.pop_back();\n\t\t\t}\n\t\t\tvec.pb(mp(--a,--b));//cout<<vec[vec.size()-1].fi<<vec[vec.size()-1].sc<<endl;\n\t\t}\n\t}\n\tdp[0][0] =1LL;\n\tint sum = 0,nxt2 = 0;\n\tint S=0,T=0;\n\trep(i,vec.size()){\n\t\tint nxt = (i==vec.size()-1?vec[i].sc+1:min(vec[i].sc+1,vec[i+1].fi));\n\t\t//[vec[i].fi,nxt) wo kettei\n\t\tint S2 = 0,T2 = 0;\n\t\tfor(int ii=max(nxt2,vec[i].fi);ii<vec[i].sc+1;ii++){\n\t\t\tif(s[ii]=='0')S++;else T++;\n\t\t}\n\t\tfor(int ii=0;ii<=sum;ii++){\n\t\t\tif(dp[ii][sum-ii]==0LL)continue;\n\t\t\tint zan = S-ii,zan2 = T-(sum-ii); \n\t\t\tfor(int x=0;x<=nxt-vec[i].fi;x++){\n\t\t\t\tif(x>zan||(nxt-vec[i].fi-x)>zan2) continue;\n\t\t\t\tdp[ii+x][sum-ii+(nxt-vec[i].fi-x)] += dp[ii][sum-ii]*C[nxt-vec[i].fi][x]%mod;\n\t\t\t\twhile(dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]>=mod) dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]-=mod;\n\t\t\t}\n\t\t}\n\t\tsum += nxt-vec[i].fi; nxt2 = vec[i].sc+1;\n\t}\n\tll ret = 0;\n\trep(i,S+T+1) ret=(ret+dp[i][S+T-i])%mod; cout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)x.size()\n#define f first\n#define s second\n#define MAXN 3010\nll MOD = 1e9+7;\n\nll A[MAXN];\nll N,K,a,b;\nll E[MAXN];\nstring S;\nvpi V;\nll memo[MAXN][MAXN];\nll overlap[MAXN];\nll fact[MAXN];\nll invfact[MAXN];\n\nll exp(ll a, ll b){\n\tif (b==0)return 1;\n\tll c = exp(a,b/2);\n\tc = (c*c)%MOD;\n\tif (b%2)c=(c*a)%MOD;\n\treturn c;\n}\n\nll inv(ll x){\n\treturn exp(x, MOD-2);\n}\n\nll C(ll a, ll b){\n\treturn (fact[a] * invfact[a-b]) %MOD * invfact[b]%MOD;\n}\n\nint main(){\n\tcin>>N>>K>>S;\n\tfact[0] = 1;\n\tfor (int i=1;i<=N;++i)fact[i] = (fact[i-1]*i)%MOD;\n\tfor (int i=0;i<=N;++i)invfact[i] = inv(fact[i]);\n\n\tfor (int i=1;i<=N;++i){\n\t\tif (S[i-1] == '1')A[i] = 1;\n\t\tA[i] += A[i-1];\n\t}\n\tfor (int i=0;i<K;++i){\n\t\tcin>>a>>b;\n\t\tE[a] = max(E[a], b);\n\t}\n\tV.pb(-1,-1);\n\tfor (int i=1;i<=N;++i)if(E[i]){\n\t\tif (SZ(V) && V.back().s >= E[i])continue;\n\t\tV.pb(i,E[i]);\n\t}\n\tfor (int i=1;i<SZ(V)-1; ++i){\n\t\toverlap[i] = max(0LL,V[i].s - V[i+1].f + 1);\n\t}\n\n\t// for (int i=1;i<SZ(V);++i)cout<<overlap[i]<<' ';\n\t// cout<<'\\n';\n\n\tmemo[0][0] = 1;\n\tfor (int i=1;i<SZ(V);++i){\n\t\t// cout<<\"Hi\\n\";\n\t\tint s = V[i-1].s+1;\n\t\tint e = V[i].s;\n\t\t// cout<<\"R \"<<s<<' '<<e<<' '<<A[e]-A[s-1]<<'\\n';\n\t\tint l = V[i].s - V[i].f + 1;\n\t\tfor (int j=0;j<=overlap[i-1];++j){\n\t\t\tfor (int k=0;k<=overlap[i];++k){\n\t\t\t\tint ones = j + A[e] - A[s-1];\n\t\t\t\t// cout<<ones<<'\\n';\n\t\t\t\tint zeroes = l - ones;\n\t\t\t\tif (ones < k)continue;\n\t\t\t\tif (zeroes + k > l)continue;\n\t\t\t\tmemo[i][k] += (memo[i-1][j] * C(l-overlap[i], ones-k))%MOD;\n\t\t\t\tmemo[i][k]%=MOD;\n\t\t\t}\n\t\t}\n\t\t// for (int k=0;k<=overlap[i];++k)cout<<memo[i][k]<<' ';cout<<'\\n';\n\t}\n\tll ans =0;\n\tfor (int k=0;k<=overlap[SZ(V) - 1];++k)ans=(ans+memo[SZ(V)-1][k])%MOD;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#define Rep(i,a) for(int i = 0; i < (a); i++)\n#define rep(i,a,b) for(int i = (a); i <= (b); i++)//(a)!\n#define dep(i,a,b) for(int i = (a); i >= (b); i--)\n#define ab(a) ((a) > 0 ? (a) : -(a))\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long uLL;\nconst int N = 3010, mod = 1000000000 + 7;\nchar s[N], t[N];\nint f[N][N];\nint main() {\n\tint n, m; scanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s + 1); rep(i,1,n) t[i] = s[i];\n\trep(j,1,m) {\n\t\tint l, r; scanf(\"%d%d\",&l,&r);\n\t\tint c = 0; rep(i,l,r) if (s[i] == '0') c++;\n\t\trep(i,l,l+c-1) s[i] = '0'; rep(i,l + c,r) s[i] = '1';\n\t\tc = 0; rep(i,l,r) if (t[i] == '1') c++;\n\t\trep(i,l,l+c-1) t[i] = '1'; rep(i,l + c,r) t[i] = '0';\n\t}\n\tf[0][0] = 1; int cnt_s = 0, cnt_t = 0;\n\trep(i,1,n) {\n\t\tcnt_s += s[i] - '0', cnt_t += t[i] - '0';\n\t\trep(j,0,i) if (cnt_s <= j && j <= cnt_t) {\n\t\t\tf[i][j] = f[i - 1][j]; if (j) ( f[i][j] += f[i - 1][j - 1] ) %= mod;\n\t\t}\n\t}\n\tcout <<f[n][cnt_s] % mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vii dp;\n    vi dist;\n    Tree(vii edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,M; cin>>N>>M;\n    string S; cin>>S;\n    S='0'+S;\n    vector<pii> data(M);\n    {\n        rep(i,0,M){\n            cin>>data[i].first>>data[i].second;\n            data[i].second*=-1;\n        }\n        sort(ALL(data));\n        ll memo=0;\n        vector<pii> mem;\n        rep(i,0,M){\n            if(memo<-data[i].second){\n                data[i].second*=-1;\n                mem.pb(data[i]);\n                memo=data[i].second;\n            }\n        }\n        data=mem;\n        M=mem.size();\n    }\n    vii dp(M+1,vi(N+1));\n    data.pb(mp(inf,inf));\n    ll ans=1;\n    ll memo=data[0].first-1;\n    dp[0][0]++;\n    COMinit();\n    rep(i,0,M){\n        if(data[i+1].first>data[i].second){\n            dp[i+1][0]++;\n            ll sum=0,cnt=0;\n            REP(j,memo+1,data[i].second){\n                if(S[j]=='1') cnt++;\n            }\n            REP(j,0,N){\n                //if(dp[i][j]==0) break;\n                ll X=j+cnt;\n                sum+=dp[i][j]*COM(data[i].second-data[i].first+1,X)%MOD;\n                sum%=MOD;\n            }\n            ans*=sum;\n            ans%=MOD;\n            memo=data[i+1].first-1;\n            continue;\n        }\n        ll cnt=0;\n        REP(j,memo+1,data[i].second){\n            if(S[j]=='1') cnt++;\n        }\n        REP(j,0,N){\n            //if(dp[i][j]==0) break;\n            ll X=j+cnt;\n            REP(k,std::max(0ll,X-(data[i].second-data[i+1].first+1)),data[i+1].first-data[i].first){\n                if(X<k) break;\n                dp[i+1][X-k]+=dp[i][j]*COM(data[i+1].first-data[i].first,k)%MOD;\n                dp[i+1][X-k]%=MOD;\n            }\n        }\n        memo=data[i].second;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll ncr[3001][3001];\nconst int MOD = 1e9 + 7;\n\nll choose(int n, int r)\n{\n\tif(r==0) return 1;\n\tif(n<r) return 0;\n\tif(ncr[n][r]!=-1) return ncr[n][r];\n\tncr[n][r]=(choose(n-1,r-1)+choose(n-1,r))%MOD;\n\treturn ncr[n][r];\n}\n\nll dp[3001][3001];\nll modinv[3001];\nll fact[3001];\n\nll modpow(ll a, ll b)\n{\n\tll r = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=(r*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a,MOD-2);\n}\n\nint pre[3001];\nint countone(int l, int r)\n{\n\tif(l==0) return pre[r];\n\treturn pre[r]-pre[l-1];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(ncr,-1,sizeof(ncr));\n\tfor(int i = 1; i <= 3000; i++) modinv[i] = inv(i);\n\tfact[0]=1;\n\tfor(int i = 1; i <= 3000; i++) fact[i]=(fact[i-1]*i)%MOD;\n\tint n, m; cin>>n>>m;\n\tstring s; cin >> s;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i]=='1') pre[i]=1;\n\t\tif(i>0) pre[i]+=pre[i-1];\n\t}\n\tvector<ii> vec;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint l, r; cin>>l>>r;\n\t\tl--; r--;\n\t\tvec.pb(mp(l,r));\n\t}\t\n\tvector<ii> move;\n\tsort(vec.begin(),vec.end());\n\tint cur = -1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(vec[i].se>cur)\n\t\t{\n\t\t\tmove.pb(vec[i]);\n\t\t\tcur=vec[i].se;\n\t\t}\n\t}\n\tmove.pb(mp(n,n));\n\tm = move.size();\n\t//dp[0][countone(move[0].fi,move[0].se)] = choose(move[0].se-move[0].fi+1, countone(move[0].fi,move[0].se));\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tint l = move[0].fi;\n\t\tint mid = min(move[1].fi-1, move[0].se);\n\t\tint r = move[0].se;\n\t\tint cnt = countone(l,r);\n\t\t//i is [mid+1,r]\n\t\tif(i>cnt) break;\n\t\tif(i>r-mid) break;\n\t\tdp[0][i] = choose(mid-l+1,cnt-i);\n\t\t//cerr<<0<<' '<<i<<' '<<dp[0][i]<<'\\n';\n\t}\n\tfor(int i = 1; i < m - 1; i++)\n\t{\n\t\tint l = move[i].fi;\n\t\tint mid = min(move[i+1].fi-1, move[i].se);\n\t\tint r = move[i].se;\n\t\tint cnt = countone(l,r);\n\t\tif(move[i].fi>move[i-1].se)\n\t\t{\n\t\t\tll an = 0;\n\t\t\tfor(int j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\tan=(an+dp[i-1][j])%MOD;\n\t\t\t}\n\t\t\tfor(int j = 0; j <= r-mid; j++)\n\t\t\t{\n\t\t\t\tif(j>cnt) break;\n\t\t\t\tdp[i][j] = (an*choose(mid-l+1,cnt-j))%MOD;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt = countone(move[i-1].se+1,r);\n\t\t\t//this is the number of ones in the later part\n\t\t\t//Naive way\n\t\t\tfor(int x = 0; x <= r-mid; x++)\n\t\t\t{\n\t\t\t\tfor(int j = n; j >= max(0,x - cnt); j--)\n\t\t\t\t{\n\t\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int j = n; j >= max(0,r-mid - cnt); j--)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t}\n\t\t\tfor(int x = r-mid; x >= 0; x--)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j <= n; j++)\n\t\t{\n\t\t\tcerr<<i<<' '<<j<<' '<<dp[i][j]<<'\\n';\n\t\t}\n\t\t*/\n\t}\n\tll ans = dp[m-2][0];\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\n\nstring S;\nconst int mod=1000000007;\nint to[3333];\nint sum[3333];\n\nint dp[3333][3333];\n\nsigned main(){\n    cin>>N>>M;\n    cin>>S;\n    rep(i,N)sum[i+1]=sum[i]+(S[i]=='1');\n    rep(i,N)to[i+1]=i+1;\n    rep(i,M){\n        int l,r;\n        cin>>l>>r;\n        chmax(to[l],r);\n    }\n    for(int i=1;i<N;i++)chmax(to[i],to[i-1]);\n    dp[0][0]=1;\n    for(int i=0;i<N;i++){\n        for(int j=max(i-(to[i]-sum[to[i]]),0ll);j<=min(i,sum[to[i]]);j++){\n            if(to[i+1]-sum[to[i+1]]>=i-j+1)dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n            if(sum[to[i+1]]>=j+1)dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n        }\n    }\n    cout<<dp[N][sum[N]]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[4000][4000];\nint b[4000];\nint sum[4000];\n\nint main(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvector<P>v;\n\trep(i,m){\n\t\tint l,r;scanf(\"%d%d\",&l,&r);l--;r--;\n\t\tif(v.empty())v.push_back(P(l,r));\n\t\telse if(v.back().first==l)v.back().second=max(v.back().second,r);\n\t\telse if(v.back().second<r)v.push_back(P(l,r));\n\t}\n\tfor(auto p:v)b[p.first]=p.second;\n\tfor(int i=1;i<n;i++)b[i]=max({i,b[i],b[i-1]});\n\tint cnt=0;\n\trep(i,n){\n\t\tif(s[i]=='1')cnt++;\n\t\tsum[i]=cnt;\n\t}\n\tdp[0][cnt]=1;\n\trep(i,n)rep(j,cnt+1){\n\t\tif(dp[i][j]==0)continue;\n\t\tint a=j-(sum[n-1]-sum[b[i]]);\n\t\tif(a)(dp[i+1][j-1]+=dp[i][j])%=MOD;\n\t\tif(b[i]-i+1-a)(dp[i+1][j]+=dp[i][j])%=MOD;\n\t}\n\tcout<<dp[n][0]<<endl;\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define P 1000000007\nusing namespace std;\nint n,m,c,s[3003],L,R,l,r;\nlong long jc[3003];\nlong long pow(long long x,int y){\n\tlong long res=1;\n\tfor(;y;y>>=1,x=x*x%P)\n\t    if(y&1)res=res*x%P;\n\treturn res;\n}\nlong long C(int x,int y){\n\treturn jc[x]*pow(jc[y],P-2)%P*pow(jc[x-y],P-2)%P;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tjc[0]=1;\n\tfor(int i=1;i<=n;++i)jc[i]=jc[i-1]*i%P;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%1d\",&c);\n\t\ts[i]=s[i-1]+c;\n\t}\n\tlong long ans=1;\n\tscanf(\"%d%d\",&L,&R);\n\tfor(int i=2;i<=m;++i){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(l<=R)R=max(R,r);\n\t\telse{\n\t\t\tans=ans*C(R-L+1,s[R]-s[L-1])%P;\n\t\t\tL=l,R=r;\n\t\t}\n\t}\n\tans=ans*C(R-L+1,s[R]-s[L-1])%P;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3005;\nLL mod = 1e9 + 7;\n\nint n, m, r[N], pref[N];\nLL dp[N][N];\nchar s[N];\n\ninline void modadd(LL &x, LL y) {\n  x += y;\n  if (x >= mod) x -= mod;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  scanf(\"%s\", s + 1);\n  for (int i = 1; i <= n; i ++) {\n    r[i] = i;\n    pref[i] = pref[i - 1] + s[i] - '0';\n  }\n  for (int i = 1, x, y; i <= m; i ++) {\n    scanf(\"%d%d\", &x, &y);\n    r[x] = max(r[x], y);\n  }\n  int c = 0, R = 0, t;\n  dp[0][0] = 1;\n  for (int i = 1; i <= n; i ++) {\n    t = 0;\n    if (R < r[i]) {\n      c += (t = pref[r[i]] - pref[R]);\n      R = r[i];\n    }\n    if (i == R)\n      modadd(dp[i][0], dp[i - 1][0] + dp[i - 1][1]);\n    else {\n      for (int j = t - 1; j <= c && j <= R - i; j ++) {\n  \tif (j >= t) modadd(dp[i][j], dp[i - 1][j - t]);\n  \tif (j >= t - 1) modadd(dp[i][j], dp[i - 1][j - t + 1]);\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[n][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ull mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow_mod(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nvl fact(3005);\n\nll Fact(ll n){\n\tif(fact[n]) return fact[n];\n\tif(!n) return fact[n]=1;\n\treturn fact[n]=Fact(n-1)*n%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow_mod(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(Fact(n),Fact(n-k)*Fact(k)%mod);\n}\n\nint n,m;\nstring s;\n\nint ff(int l,int r){\n\tint t=0;\n\tfor(int i=l;i<r;i++) t+=s[i]-'0';\n\treturn t;\n}\n\nll f(vp a){\n\tint l=a[0].first,r=a[0].second,t=ff(l,r);\n\tvl dp(n+1);\n\tdp[t]++;\n\tfor(int i=1;i<a.size();i++){\n\t\tint L=a[i].first,R=a[i].second;\n\t\tt=ff(r,R);\n\t\tvl DP(n+1);\n\t\tfor(int j=0;j<=r-l;j++) for(int k=max(0,L-r+j);k<=min(j,L-l);k++){\n\t\t\t(DP[j-k+t]+=nCk(L-l,k)*dp[j])%=mod;\n\t\t}\n\t\tl=L,r=R;dp=DP;\n\t}\n\tll res=0;\n\tfor(int i=0;i<=r-l;i++) (res+=dp[i]*nCk(r-l,i))%=mod;\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m>>s;\n\tvp a;\n\tll res=1;\n\tfor(int i=0;i<m;i++){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tif(a.empty()) a.push_back({l-1,r});\n\t\telse{\n\t\t\tint t=a.back().second;\n\t\t\tif(t<l){\n\t\t\t\t(res*=f(a))%=mod;\n\t\t\t\ta.clear();\n\t\t\t}\n\t\t\telse if(t<r) a.push_back({l-1,r});\n\t\t}\n\t}\n\tcout<<res*f(a)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt((uint64_t)num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) \n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//ifstream cin (\"x.in\"); ofstream cout (\"x.out\");\n\nconst int nmax = 3000;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint s[nmax + 1];\nint d[nmax + 1][nmax + 1];\n\npair<int, int> w[nmax + 1];\nvector< pair<int, int> > unu;\n\nstring vs;\nint v[nmax + 1];\n\ninline bool cmpdr (int x) {\n    return x == 0;\n}\n\ninline bool cmpst (int x) {\n    return x > 0;\n}\n\nvoid precalc() {\n    unu.push_back(make_pair(0, 0));\n    for (int i = 0; i < n; ++ i) {\n        if (vs[ i ] == '1') {\n            v[i + 1] = unu.size();\n            unu.push_back(make_pair(0, 0));\n        }\n    }\n\n    for (int i = 1; i <= m; ++ i) {\n        stable_partition(v + w[ i ].first, v + w[ i ].second + 1, cmpdr);\n    }\n\n    for (int i = 1; i <= n; ++ i) {\n        if (v[ i ]) {\n            unu[ v[ i ] ].second = i;\n        }\n    }\n\n    int shp = 0;\n    for (int i = 0; i < n; ++ i) {\n        if (vs[ i ] == '1') {\n            v[i + 1] = ++ shp;\n        } else {\n            v[i + 1] = 0;\n        }\n    }\n\n    for (int i = 1; i <= m; ++ i) {\n        stable_partition(v + w[ i ].first, v + w[ i ].second + 1, cmpst);\n    }\n\n    for (int i = 1; i <= n; ++ i) {\n        if (v[ i ]) {\n            unu[ v[ i ] ].first = i;\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m >> vs;\n\n    for (int i = 1; i <= m; ++ i) {\n        int x, y;\n        cin >> x >> y;\n        w[ i ] = make_pair(x, y);\n    }\n\n    precalc();\n\n    d[ 0 ][ 0 ] = 1;\n    for (int i = 0; i <= n; ++ i) s[ i ] = 1;\n\n    for (int i = 1; i < (int)unu.size(); ++ i) {\n        for (int j = unu[ i ].first; j <= unu[ i ].second; ++ j) {\n            d[ i ][ j ] = s[j - 1];\n        }\n\n        s[ 0 ] = 0;\n        for (int j = 1; j <= n; ++ j) {\n            s[ j ] = s[j - 1] + d[ i ][ j ];\n            if (s[ j ] >= mod) {\n                s[ j ] -= mod;\n            }\n        }\n    }\n\n    cout << s[ n ] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005, P = 1e9 + 7;\nchar s[N];\nint n, m, d[N], f[N][N], num[N];\n\nint main () {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; ++i) d[i] = i, num[i] = num[i - 1] + (s[i] == '1');\n\tfor (int i = 1, l, r; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif (r > d[l]) d[l] = r;\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 0, r = 0; i < n; ++i) {\n\t\tif (d[i + 1] > r) r = d[i + 1];\n\t\tfor (int j = 0; j <= num[r]; ++j) {\n\t\t\tif (f[i][j] >= P) f[i][j] -= P;\n\t\t\tif (!f[i][j]) continue ;\n\t\t\tif (num[r] - j < r - i) f[i + 1][j] += f[i][j];\n\t\t\tif (num[r] - j > 0) f[i + 1][j + 1] += f[i][j];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][num[n]] % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nconst int N=3000+19;\nconst int p=1e9+7;\n\nint C[N][N];\nint A[N],S[N],F[N][N];\nint n,m,l,r,res;\nchar s[N];\n\nvoid Upd(int &x,int y){\n\tx=(x+y)%p;\n}\n\nint main(){\n\tFor(i,0,N){\n\t\tC[i][0]=1;\n\t\tFor(j,1,i+1) C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;\n\t}\n\tn=IN(),m=IN();\n\tscanf(\"%s\",s+1);\n\tFor(i,1,n+1) S[i]=S[i-1]+(s[i]=='1');\n\tFor(i,1,n+1) A[i]=i;\n\tFor(i,1,m+1){\n\t\tl=IN(),r=IN();\n\t\tA[l]=max(A[l],r);\n\t}\n\tFor(i,1,n+1) A[i]=max(A[i],A[i-1]);\n\tF[1][S[A[1]]]=1;\n\tFor(i,1,n){\n\t\tFor(j,0,n+1)\n\t\t\tif (F[i][j]){\n\t\t\t\tif (j<A[i]-i+1) Upd(F[i+1][j+S[A[i+1]]-S[A[i]]],F[i][j]);\n\t\t\t\tif (j>0) Upd(F[i+1][j-1+S[A[i+1]]-S[A[i]]],F[i][j]);\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",(F[n][0]+F[n][1])%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\nint n, m;\nchar S[3010];\nint s[3010];\npp q[3010];\n\nll dp[3010][3010];\nconst ll mod = 1000000007;\nll C[3010][3010];\n\nint main()\n{\n\tint m_;\n\tread(n, m_);\n\tscanf(\"%s\", S+1);\n\tfor(int i=1; i<=n; ++i){ s[i] = s[i-1] + (S[i]=='1'); }\n\t\n\tC[0][0] = 1;\n\tfor(int i=1; i<=3000; ++i){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j=1; j<i; ++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\t\n\tfor(;m_--;){\n\t\tint a, b; read(a, b);\n\t\tif(!m){ q[++m] = {a, b}; continue; }\n\t\tif(q[m].x == a){ q[m].y = max(q[m].y, b); continue; }\n\t\tif(b < q[m].y) continue;\n\t\tq[++m] = {a, b};\n\t}\n\t\n\tdp[0][0] = 1;\n\t\n\tfor(int i=1; i<=m; ++i){\n\t\tint kbef = 0;\n\t\tif(1 < i) kbef = max(0, q[i-1].y-q[i].x+1);\n\t\tint b = s[q[i].y]-s[q[i].x+kbef-1];\n\t\tint knxt = 0;\n\t\tif(i < m) knxt = max(0, q[i].y-q[i+1].x+1);\n\t\t\n\t\tint l = q[i].y-q[i].x+1;\n\t\tfor(int j=0; j<=kbef; ++j){\n\t\t\tint budget = j+b;\n\t\t\tfor(int k=0; k<=knxt; ++k){\n\t\t\t\tif(k > budget || (budget-k)>(l-knxt)) continue;\n\t\t\t\t(dp[i][k] += dp[i-1][j] * C[l-knxt][budget-k] % mod) %= mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tprintf(\"dp of %d : kbef %d, knxt %d\\n\", i, kbef, knxt);\n\t\tfor(int j=0; j<=knxt; ++j){\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tprintf(\"dp[%d][%d] = %lld\\n\", i, j, dp[i][j]);\n\t\t}\n\t\t*/\n\t}\n\t\n\tprintf(\"%lld\\n\", dp[m][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate<int MOD>\nclass ModInt{\npublic:\n    ModInt():value(0){}\n    ModInt(long long val):value((int)(val<0?MOD+val%MOD:val%MOD)){ }\n\n    ModInt& operator+=(ModInt that){\n        value = value+that.value;\n        if(value>=MOD)value-=MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that){\n        value -= that.value;\n        if(value<0)value+=MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that){\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that){\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const{\n        return ModInt(*this)+=that;\n    }\n    ModInt operator-(ModInt that) const{\n        return ModInt(*this)-=that;\n    }\n    ModInt operator*(ModInt that) const{\n        return ModInt(*this)*=that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const{\n        if(value == 0)return 0;\n        ModInt n = *this, res = 1;\n        while(k){\n            if(k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const{ return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<1000000007> mint;\nostream& operator<<(ostream& os, const mint& x){\n    os << x.toi();\n    return os;\n}\n\nmint dp[3002][3002];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vi L, R;\n    rep(i, M) {\n        int l, r;\n        cin >> l >> r;\n        if(sz(L) && r <= R.back())continue;\n        while(sz(L) && L.back() == l && R.back() <= r) {\n            L.pop_back();\n            R.pop_back();\n        }\n        L.push_back(l);\n        R.push_back(r);\n    }\n\n    vector<mint> F(N + 1);\n    F[0] = 1;\n    for(int i = 1; i <= N; ++i) {\n        F[i] = F[i - 1] * i;\n    }\n\n    auto cnt=[&](int l, int r) {\n        int res = 0;\n        for(int i = l; i < r; ++i)if(S[i] == '1')++res;\n        return res;\n    };\n\n    M = sz(L);\n    \n    rep(i, M)--L[i];\n    dp[0][0] = 1;\n    int preCon = 0;\n    rep(i, M) {\n        int ones = 0;\n        if(i == 0 || R[i - 1] <= L[i]) {\n            ones = cnt(L[i], R[i]);\n        } else {\n            ones = cnt(R[i - 1], R[i]);\n        }\n\n        int con = 0;\n        if(i < M - 1 && L[i + 1] < R[i]) {\n            con = R[i] - L[i + 1];\n        }\n        int len = R[i] - L[i];\n        rep(j, preCon+1) if(dp[i][j].toi()){\n            int curOnes = ones + j;\n            // 次のセグメントと接続\n            if(con) {\n                int ub = min(con, curOnes), lb = max(ub - (len - curOnes), 0);\n                for(int nj = lb; nj <= ub; ++nj) {\n                    int notCon = len - con;\n                    int notNj = curOnes - nj;\n                    dp[i + 1][nj] += dp[i][j] * (F[notCon]/(F[notNj]*F[notCon-notNj]));\n                }\n            } else {\n                // 接続しない\n                dp[i + 1][0] += dp[i][j] * F[len] /(F[curOnes]*F[len-curOnes]);\n            }\n        }\n        preCon = con;\n    }\n\n    mint ans = 0;\n    for(int i = 0; i <= N; ++i)ans += dp[M][i];\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[a[v[0].fi-1]]=1;\n    int prel=a[v[0].fi-1],prer=a[v[0].fi-1];\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int mi=INT_MAX,ma=0;\n        rep2(j,prel,prer){\n            int l = max((int)j,x-y+a[y]);\n            int r = min((int)j+x-v[i].fi+1,a[y]);\n            chmin(mi,l);chmax(ma,r);\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=mi,prer=ma;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nll factorial(int i){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n  return k[i];\n}\n\nll nCr(ll n,ll r){\n  ll a = mod_pow( factorial(r) * factorial(n-r) % mod ,mod-2);\n  return factorial(n) * a % mod;\n}\n\nint n, m, sum[3005];\nstring s;\nvector<int> L, R;\n\nvoid init(){\n  for(int i=0;i<n;i++){\n    sum[i] = s[i] == '1';\n    if(i) sum[i] += sum[i-1];\n  }\n}\n\nint get(int l, int r){\n  int res = sum[r];\n  if( l != 0 ) res -= sum[l-1];\n  return res;\n}\n\nint memo[3005][3005], used[3005][3005];\n\nint dfs(int x, int cnt1, int cnt0){\n    \n  if( cnt0 + cnt1 ){\n    \n    int l = R[x-1] + 1, r = R[x];\n    \n    int c1 = get( l, r );\n    int c0 = r - l + 1 - c1;\n    \n    cnt1 += c1;\n    cnt0 += c0;\n    \n  }else{\n    \n    cnt1 = get( L[x], R[x] );\n    cnt0 = R[x] - L[x] + 1 - cnt1;\n    \n  }\n  \n  if( used[x][cnt1]++ ) return memo[x][cnt1];\n    \n  int l = L[x], r = R[x];\n  \n  if( x == (int)L.size() - 1 ){\n    return memo[x][cnt1] = nCr( r - l + 1, cnt0 );\n  }\n  \n  if( R[x] < L[x+1] ){\n    return memo[x][cnt1] = nCr( r - l + 1, cnt0 ) * dfs( x + 1, 0, 0 ) % mod;\n  }\n  \n  r = L[x+1] - 1;\n  \n  int res = 0;\n  \n  for(int i=0;i<=r-l+1;i++){\n    \n    int ncnt1 = cnt1 - i;\n    int ncnt0 = cnt0 - ( r - l + 1 - i );\n    \n    if( ncnt1 < 0 || ncnt0 < 0 ) continue;\n    \n    res += nCr( r - l + 1, i ) * dfs( x + 1, ncnt1, ncnt0 ) % mod;\n    res %= mod;\n  }\n  \n  return memo[x][cnt1] = res;\n}\n\nint main(){\n  \n  cin>>n>>m;\n  cin>>s;\n  \n  for(int i=0;i<m;i++){\n    \n    int l, r;\n    cin>>l>>r;\n    l--, r--;\n    \n    if(i){\n      int idx = L.size()-1;\n      if( L[idx] == l ) R[idx] = max( R[idx], r );\n      if( R[idx] < r ){\n\tL.push_back(l);\n\tR.push_back(r);\n      }\n    }else{\n      L.push_back(l);\n      R.push_back(r);\n    }\n    \n  }\n  \n  init();\n      \n  cout << dfs( 0, 0, 0 ) << endl;\n    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nconst int p=1000000007;\nint n,m,sum[3010],l[3010],r[3010],f[3010][3010],c[3010][3010];\nchar a[3010];\n\nint main()\n{\n    int t;\n    scanf(\"%d%d%s\",&n,&t,a+1);\n    repu(i,1,n)\n        sum[i]=sum[i-1]+(a[i]=='1');\n    while (t--)\n    {\n        scanf(\"%d%d\",&l[m+1],&r[m+1]);\n        m+=r[m+1]>r[m];\n    }\n    sum[l[m+1]=r[m+1]=n+1]=sum[n],f[0][0]=1;\n    repu(i,0,n)\n    {\n        c[i][0]=1;\n        repu(j,1,i)\n            c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n    }\n    repu(i,0,m)\n        repu(j,0,r[i]-l[i]+1)\n            if (f[i][j])\n            {\n                int cnt=sum[r[i+1]]-sum[max(l[i+1]-1,r[i])];\n                if (l[i+1]>r[i])\n                    f[i+1][cnt]=(f[i+1][cnt]+LL(f[i][j])*c[r[i]-l[i]+1][j])%p;\n                else\n                {\n                    int x=max(j-(l[i+1]-l[i]),0);\n                    int y=min(j,r[i]-l[i+1]+1);\n                    repu(k,x,y)\n                        f[i+1][cnt+k]=(f[i+1][cnt+k]+LL(f[i][j])*c[l[i+1]-l[i]][j-k])%p;\n                }\n            }\n    printf(\"%d\\n\",f[m+1][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N,M;\nint A[3001];\nint B[3001];\nstring S;\nint l[3001];\nint r[3001];\n\nvoid maxS(){\n\tREP(i,M){\n\t\tint c=0;\n\t\tfor(int j=l[i];j<=r[i];j++){\n\t\t\tif(A[j]==1){\n\t\t\t\tc++;\n\t\t\t\tA[j]=0;\n\t\t\t}\n\t\t}\n\t\tREP(j,c){\n\t\t\tA[r[i]-j]=1;\n\t\t}\n\t}\n}\n\nvoid minS(){\n\tREP(i,M){\n\t\tint c=0;\n\t\tfor(int j=l[i];j<=r[i];j++){\n\t\t\tif(B[j]==1){\n\t\t\t\tc++;\n\t\t\t\tB[j]=0;\n\t\t\t}\n\t\t}\n\t\tREP(j,c){\n\t\t\tB[l[i]+j]=1;\n\t\t}\n\t}\n}\n\nLL dp[3011];\nLL nxt[3011];\nLL MOD=1e9+7;\n\nint main(){\n\tcin>>N>>M>>S;\n\tREP(i,N){\n\t\tif(S[i]=='0'){\n\t\t\tA[i]=0;\n\t\t\tB[i]=0;\n\t\t}else{\n\t\t\tA[i]=1;\n\t\t\tB[i]=1;\n\t\t}\n\t}\n\tREP(i,M){\n\t\tcin>>l[i]>>r[i];\n\t\tl[i]--;\n\t\tr[i]--;\n\t}\n\tmaxS();\n\tminS();\n\tREP(i,N){\n\t\tif(i==0)continue;\n\t\tA[i]=A[i]+A[i-1];\n\t\tB[i]=B[i]+B[i-1];\n\t}\n\tREP(i,3002){\n\t\tdp[i]=0;\n\t}\n\t\n\t/*REP(i,N){\n\t\tcout<<A[i]<<\" \";\n\t}\n\tcout<<endl;\n\t\tREP(i,N){\n\t\tcout<<B[i]<<\" \";\n\t}\n\tcout<<endl;*/\n\tdp[0]=1;\n\tREP(k,N){\n\t\tREP(i,3002){\n\t\t\tnxt[i]=0;\n\t\t}\n\t\tREP(i,3001){\n\t\t\tif((i>=A[k])&&(i<=B[k])){\n\t\t\t\tnxt[i]+=dp[i];\n\t\t\t\tnxt[i]%=MOD;\n\t\t\t}\n\t\t\tif(((i+1)>=A[k])&&((i+1)<=B[k])){\n\t\t\t\tnxt[i+1]+=dp[i];\n\t\t\t\tnxt[i+1]%=MOD;\n\t\t\t}\n\t\t}\n\t\tREP(i,3002){\n\t\t\tdp[i]=nxt[i];\n\t\t}\n\t\t/*cout<<\"test\"<<endl;\n\t\tREP(i,5){\n\t\t\tcout<<dp[i]<<endl;\n\t\t}*/\n\t}\n\tLL ans=0;\n\tREP(i,3002){\n\t\tans+=dp[i];\n\t\tans%=MOD;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef long long ll;\n\nint N,M,m;\nll sum[300030] = {0};\nll que[300030][2] = {0};\nll F[300030] = {0},R[300003] = {0};\nll dp[3030][3030];\nvector<int> QL,QR;\n\nll con(ll a,ll b)\n{\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nll P(ll n,ll s)\n{//printf(\"  %lld %lld\\n\",n,s);\n    if(dp[n][s] != -1)return dp[n][s];\n    ll res = 0;\n    ll l,r;\n    if(n == QR.size() - 1)\n    {\n        l = QL[n];r = QR[n];\n        res = con(r - l + 1,sum[r] - s);\n        return res;\n    }\n    l = QL[n],r = min(QR[n],QL[n + 1] - 1);\n    ll mem = sum[QR[n]] - s;\n    ll p = 0;\n    if(QR[n] < QL[n + 1])p = sum[QL[n + 1] - 1] - sum[QR[n]];\n\n    //printf(\" %lld %lld %lld %lld\\n\",l,r,mem,(r - l + 1) - (QR[n] - l + 1 - mem));\n    for(int i = max((ll)0,(r - l + 1) - (QR[n] - l + 1 - mem)); i <= min(mem,r - l + 1); i++)\n    {\n        res += P(n + 1,s + i + p) * con(r - l + 1,i);\n        res %= mod;\n    }\n    return dp[n][s] = res;\n}\n\nll power(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = power(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < 3030; i++)for(int j = 0; j < 3030; j++)dp[i][j] = -1;\n    F[0] = 1;\n    for(int i = 1; i <= 3030; i++)F[i] = F[i - 1] * i % mod;\n    for(int i = 0; i <= 3030; i++)R[i] = power(F[i],mod - 2);\n    for(int i = 1; i <= N; i++)\n    {\n        char c;\n        scanf(\" %c\",&c);\n        sum[i] = sum[i - 1] + (c == '1');\n    }\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%lld%lld\",&que[i][0],&que[i][1]);\n        if(i != 0)que[i][1] = max(que[i][1],que[i - 1][1]);\n    }\n    for(int i = 0; i < M; i++)\n    {\n        if(i == 0)\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n        if(QL[QL.size() - 1] == que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QR[QR.size() - 1] = que[i][1];\n        }\n        else if(QL[QL.size() - 1] < que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n    }\n    /*\n    for(int i = 0; i < QR.size(); i++)\n    {\n        printf(\" %d %d\\n\",QL[i] ,QR[i]);\n    }\n    */\n    printf(\"%lld\\n\",P(0,sum[QL[0] - 1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=MOD-1)+=MOD-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\nvector<ll> fact,finv,inv;\nll comb(ll n,ll r){\n  if(n<r||r<0)return 0;\n  return fact[n]*finv[n-r]%MOD*finv[r]%MOD;\n}\nclass Doralion{\n  void Modinvs(vector<ll> &re,int n){\n    re.resize(n+1); re[1]=1;\n    for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i)%MOD;\n  }\n  void Facts(vector<ll> &re,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*(i+1)%MOD;\n  }\n  void Factinvs(vector<ll> &re,const vector<ll> &inv,int n){\n    re.resize(n+1); re[0]=1;\n    rep(i,n)re[i+1]=re[i]*inv[i+1]%MOD;\n  }\npublic:\n  Doralion(int n){\n    Modinvs(inv,n);\n    Facts(fact,n);\n    Factinvs(finv,inv,n);\n  }\n} doralion(21234);\n\n\nll dp[3123][3123];\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n,m;\n  cin>>n>>m;\n  string s;\n  cin>>s;\n  vector<pii> ps;\n  rep(i,m){\n    int x,y;\n    cin>>x>>y; --x;\n    if(ps.size() && ps.back().Y>y) continue;\n    if(ps.size() && ps.back().X==x) MX(ps.back().Y,y);\n    else ps.eb(x,y);\n  }\n  m=ps.size();\n  //cout<<ps;\n  vector<int> sum(n+1);\n  rep(i,n) sum[i+1]=sum[i]+(s[i]=='1');\n  //cout<<sum;\n  int prev=0;\n  dp[0][0]=1;\n  rep(i,m){\n    const int l=ps[i].X;\n    const int r=ps[i].Y;\n    if(prev<l){\n      rep(j,n) dp[l][j+sum[l]-sum[prev]]=dp[prev][j];\n    }\n    int nxt=r;\n    if(i+1<m) MN(nxt,ps[i+1].X);\n    rep(j,nxt-l+1){\n      const ll tmp=comb(nxt-l,j);\n      rep(k,n){\n\tif(k+j>sum[r]) break;\n\tif(nxt-(k+j)>r-sum[r]) continue;\n\t(dp[nxt][k+j]+=dp[l][k]*tmp%MOD)%=MOD;\n      }\n    }\n    prev=nxt;\n  }\n  //rep(i,n+1){rep(j,n+1)cout<<dp[i][j]<<\",\";cout<<endl;}\n  cout<<dp[prev][sum[prev]]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n, m, a, b, r[3030], c[2020], dp[2020][2020];\nstring s;\n\nsigned main() {\n\tcin >> n >> m >> s;\n\trep(i,n) c[i+1] = s[i]-'0' + (i ? c[i] : 0);\n\trep(i,3030) r[i] = i;\n\trep(i,m) {\n\t\tcin >> a >> b;\n\t\treps(j,a,b+1) chmax(r[j],b);\n\t}\n\tdp[0][0] = 1;\n\treps(i,1,n+1) rep(j,min(c[r[i]],i)+1) {\n\t\t// [0,r[i]] 0-count\n\t\tif (r[i]-c[r[i]]<i-j) continue;\n\t\t// 0\n\t\tdp[i][j] = dp[i-1][j];\n\t\t// 1\n\t\tif (j) (dp[i][j] += dp[i-1][j-1]) %= mod;\n\t}\n\tcout << dp[n][c[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 3010\n#define MOD 1000000007\n#define rep(i, x, y) for(int i = (x) ; i <= (y); i ++) \ninline int read() {\n\tchar ch = getchar(); int x = 0, f = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') f = -1;\n\t\tch = getchar();\n\t} while('0' <= ch && ch <= '9') {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t} return x * f;\n}\nchar s[M]; int sum[M];\nint r[M];\nint f[M][M];\nint main() {\n\tint n = read(), m = read();\n\tscanf(\"%s\", s + 1);\n\trep(i, 1, n) sum[i] = sum[i - 1] + (s[i] == '1');\n\trep(i, 1, n) r[i] = i;\n\trep(i, 1, m) {\n\t\tint x = read(), y = read();\n\t\tr[x] = max(r[x], y);\n\t} rep(i, 1, n) r[i] = max(r[i - 1], r[i]);\n\tf[0][0] = 1;\n\trep(i, 1, n) {\n\t\trep(j, 0, sum[r[i - 1]]) if(f[i - 1][j]) {\n\t\t\tif(sum[r[i]] > j) (f[i][j + 1] += f[i - 1][j]) %= MOD;\n\t\t\tif(sum[r[i]] - j < r[i] - i + 1) (f[i][j] += f[i - 1][j]) %= MOD;\n\t\t}\n\t} cout << f[n][sum[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 5e15;\nusing mint = math::Modint<mod>;\nconst std::size_t SIZE = 3010;\nmint dp_buf[2][SIZE];\nauto dp1 = dp_buf[0], dp2 = dp_buf[1];\n\nint main() {\n    ll n, m;\n    std::string s;\n    std::cin >> n >> m >> s;\n    vec<ll> rights(n, -inf);\n    for (ll i = 0; i < m; i++) {\n        ll l, r;\n        std::cin >> l >> r;\n        chmax(rights[l - 1], r);\n    }\n\n    {\n        ll maxr = -inf;\n        for (ll i = 0; i < n; i++) {\n            if (rights[i] <= maxr) rights[i] = -inf;\n            else maxr = rights[i];\n        }\n    }\n\n    std::queue<pll> ops;\n    for (ll i = 0; i < n; i++) if (rights[i] != -inf) ops.emplace(i, rights[i]);\n\n    vec<ll> sum(n + 1);\n    for (ll i = 0; i < n; i++) sum[i + 1] = sum[i] + (s[i] == '1');\n\n    auto calc_dp = [&](std::queue<pll> &ranges) {\n        ll minl, cr;\n        std::tie(minl, cr) = ranges.front();\n        ranges.pop();\n        std::fill(dp1, dp1 + SIZE, mint(0));\n        dp1[0] = 1;\n        for (ll i = minl;; i++) {\n            if (ranges.empty() && i == cr) break;\n            std::fill(dp2, dp2 + SIZE, mint(0));\n            if (ranges.size() && ranges.front().first == i) {\n                cr = ranges.front().second;\n                ranges.pop();\n            }\n            for (ll j = 0; j <= sum[cr] - sum[minl]; j++) {\n                if (j < sum[cr] - sum[minl]) dp2[j + 1] += dp1[j];\n                if (sum[cr] - sum[minl] <= j + (cr - i) - 1) dp2[j] += dp1[j];\n            }\n            std::copy(dp2, dp2 + SIZE, dp1);\n        }\n\n        return dp1[sum[cr] - sum[minl]];\n    };\n\n    mint ans = 1;\n    while (ops.size()) {\n        std::queue<pll> que;\n        auto move_ele = [&] {\n            que.push(ops.front());\n            ops.pop();\n        };\n\n        move_ele();\n        ll cr = que.front().second;\n        while (ops.size()) {\n            ll l, r;\n            std::tie(l, r) = ops.front();\n            if (cr <= l) break;\n            cr = r;\n            move_ele();\n        }\n\n        vec<pll> tmp;\n        auto cpy = que;\n        while (cpy.size()) { tmp.push_back(cpy.front()); cpy.pop(); }\n#endif\n        ans *= calc_dp(que);\n    }\n\n    std::cout << ans.value() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,to=b;i<to;++i)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\n\nint cc[3005][3005];\n\nint comb(int n, int k){\n\treturn cc[n][k];\n}\n\nchar s[4096];\nint n,m;\nvector<pair<int,int> > w;\nint sp[4096];\nmap<int,int> z;\nint dp[3005][3005];\n\nint f(int k, int q){\n\tif(dp[k][q]>=0)return dp[k][q];\n\tint r;\n\tif(k==w.size())r=1;\n\telse {\n\t\tint s=w[k].fst;\n\t\tint e=w[k].snd;\n\t\tint m0;\n\t\tif(k>0)m0=max(s,w[k-1].snd);\n\t\telse m0=s;\n\t\tint m1;\n\t\tif(k<w.size()-1)m1=min(e,w[k+1].fst);\n\t\telse m1=e;\n\t\tint n1=sp[e]-sp[m0]+q;\n\t\tint n0=e-s-n1;\n\t\tr=0;\n\t\tfore(j,0,min(e-m1,n1)+1){\n\t\t\tint jj=n1-j;\n\t\t\tr+=(1LL*comb(m1-s,jj)*f(k+1,j))%MOD;\n\t\t\tr%=MOD;\n\t\t}\n\t}\n\treturn dp[k][q]=r;\n}\n\n\nint main(){\n\tmemset(cc,0,sizeof(cc));\n\tfore(i,1,3005){\n\t\tcc[i][0]=cc[i][i]=1;\n\t\tfore(j,1,i){\n\t\t\tcc[i][j]=(cc[i-1][j-1]+cc[i-1][j])%MOD;\n\t\t}\n\t}\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tsp[0]=0;\n\tfore(i,1,n+1){\n\t\tsp[i]=sp[i-1]+s[i-1]-'0';\n\t}\n\tfore(i,0,m){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);x--;\n\t\tz[x]=max(z[x],y);\n\t}\n\tint k=-1;\n\tfor(map<int,int>::iterator it=z.begin();it!=z.end();++it){\n\t\tint x=it->fst,y=it->snd;\n\t\tif(y<=k)continue;\n\t\tk=max(k,y);\n\t\tw.pb(mp(x,y));\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",f(0,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3005,M=1e9+7;\nint n,m,x,y,f[N],a[N],r[N];\nchar s[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++)r[i]=i,a[i]=a[i-1]+(s[i]=='1');\n\twhile (m--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tf[0]=1;\n\tfor (int i=1,R=0;i<=n;i++){\n\t\tR=r[i]>R?r[i]:R;\n\t\tfor (int j=a[R]<i?a[R]:i;j;j--)\n\t\t\tif (j<a[R]-R+i)f[j]=0;\n\t\t\telse if (j)(f[j]+=f[j-1])%=M;\n\t}\n\tprintf(\"%d\\n\",f[a[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 3010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%1d\", a + i);\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j){\n            if(j > R){\n                R = j;\n                ad = a[i];\n            }\n            else ad = 0;\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad = sum[r] - sum[R];\n            R = r;\n        }\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j){\n        if(j > R){\n            R = j;\n            ad = a[i];\n        }\n        else ad = 0;\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\n\nstring S;\nint n, m;\n\nconst int MAXN = 4000;\n\nint l[MAXN], r[MAXN];\n\nint cnt[MAXN][2];\n\nvoid move(bool one) {\n\tstring T = S;\n\tFOR (i, m) {\n\t\tint cnt0 = 0, cnt1 = 0;\n\t\tffor (j, l[i], r[i] + 1)\n\t\t\tif (T[j] == '1')\n\t\t\t\tcnt1++;\n\t\t\telse\n\t\t\t\tcnt0++;\n\t\tif (one) {\n\t\t\tFOR (j, cnt0)\n\t\t\t\tT[l[i] + j] = '0';\n\t\t\tFOR (j, cnt1)\n\t\t\t\tT[l[i] + cnt0 + j] = '1';\n\t\t}\n\t\telse {\n\t\t\tFOR (j, cnt1)\n\t\t\t\tT[l[i] + j] = '1';\n\t\t\tFOR (j, cnt0)\n\t\t\t\tT[l[i] + cnt1 + j] = '0';\n\t\t}\n\t}\n\tchar ch = '0';\n\tif (one)\n\t\tch = '1';\n\tfor (int i = T.sz - 1; i > -1; i--)\n\t\tcnt[i][one] = cnt[i + 1][one] + (T[i] == ch);\n}\n\nint dp[4000][4000];\n\nconst int MOD = 1000000007;\n\nint memo(int idx, int ones) {\n\tif (idx < 0)\n\t\treturn 1;\n\tint &ret = dp[idx][ones];\n\tif (ret != -1)\n\t\treturn ret;\n\tret = 0;\n\tint zeros = S.sz - 1 - idx - ones;\n\tif (zeros < cnt[idx][0])\n\t\tret += memo(idx - 1, ones);\n\tif (ones < cnt[idx][1])\n\t\tret += memo(idx - 1, ones + 1);\n\tif (ret >= MOD)\n\t\tret -= MOD;\n\treturn ret;\n}\n\nint main() {\n\tcin >> n >> m;\n\tcin >> S;\n\tFOR (i, m) {\n\t\tcin >> l[i] >> r[i];\n\t\tl[i]--;\n\t\tr[i]--;\n\t}\n\tSET(cnt, 0);\n\tmove(true);\n\tmove(false);\n\tSET(dp, 255);\n\tcout << memo(S.sz - 1, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(va_0, va_1, va_2, name, ...) name\n#define rep_0(i, n) for(int i = 0; i < (n); ++i)\n#define rep_1(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModInt {\nprivate: using ll = int_fast64_t;\npublic: ll x;\n    constexpr ModInt(ll t = 0) noexcept : x((t %= mod) < 0 ? t + mod : t) {}\n    constexpr friend istream& operator >> (istream& s, ModInt& m) noexcept {\n        s >> m.x; m.x %= mod; if(m.x < 0)m.x += mod; return s;\n    }\n    constexpr friend ostream& operator << (ostream& s, ModInt m) noexcept {\n        return s << m.x;\n    }\n    constexpr ModInt operator + (const ModInt m) noexcept { return ModInt(*this) += m; }\n    constexpr ModInt& operator += (const ModInt m) noexcept {\n        if((x += m.x) >= mod)x -= mod; return *this;\n    }\n    constexpr ModInt operator - (const ModInt m) noexcept { return ModInt(*this) -= m; }\n    constexpr ModInt& operator -= (const ModInt m) noexcept {\n        if((x += mod - m.x) >= mod)x -= mod; return *this;\n    }\n    constexpr ModInt operator * (const ModInt m) noexcept { return ModInt(*this) *= m; }\n    constexpr ModInt& operator *= (const ModInt m) noexcept {\n        x = x * m.x % mod; return *this;\n    }\n    constexpr ModInt operator / (const ModInt m) noexcept { return ModInt(*this) /= m; }\n    constexpr ModInt& operator /= (const ModInt m) noexcept {\n        return *this *= m.inv();\n    }\n    constexpr ModInt inv() const noexcept {\n        return pow(mod - 2);\n    }\n    constexpr ModInt pow(ll p) const noexcept {\n        ModInt res(1), mult(*this);\n        for(; p; p >>= 1){ if(p & 1)res *= mult; mult *= mult; }\n        return res;\n    }\n};\n\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModFact {\nprivate:\n    using mint = ModInt<mod>;\n    vector<mint> fact, ifact;\npublic:\n    constexpr ModFact(int sz = 200000) noexcept : fact(sz + 1), ifact(sz + 1) {\n        fact[0] = mint(1);\n        for(int i = 1; i <= sz; ++i)fact[i] = fact[i - 1] * mint(i);\n        ifact[sz] = fact[sz].inv();\n        for(int i = sz; i > 0; --i)ifact[i - 1] = ifact[i] * mint(i);\n    }\n    constexpr mint operator [] (int id) const noexcept { return fact[id]; }\n    constexpr mint operator () (int n, int r) noexcept {\n        return fact[n] * ifact[n - r] * ifact[r];\n    }\n    constexpr mint nPr(int n, int r) noexcept {\n        return fact[n] * ifact[r];\n    }\n    constexpr mint inv(int id) const noexcept { return ifact[id]; }\n};\n\n// declarations\nusing mint = ModInt<>;\nusing mfact = ModFact<>;\n\nint N, M;\nint cnt[3001];\nint L[3001], R[3000];\nmint dp[3002][3001];\nmfact fact;\n\n// solve\nint main(){\n\n    int N, M;\n    cin >> N >> M;\n\n    rep(i, N){\n        char c; \n        cin >> c;\n        if(c == '1')cnt[i + 1]++;\n        cnt[i + 1] += cnt[i];\n    }\n\n    int size_q = 0, last_l = -1, last_r = 0;\n    rep(i, M){\n        int l, r;\n        cin >> l >> r;\n        l--;\n        if(last_l <= l && last_r >= r)continue;\n        L[size_q] = last_l = l;\n        R[size_q++] = last_r = r;\n    }\n\n    L[size_q] = N;\n    dp[L[0]][cnt[L[0]]] = mint(1);\n    rep(i, size_q){\n        int l = L[i], r = min(R[i], L[i + 1]);\n        rep(j, 0, N){\n            int usable = cnt[R[i]] - j;\n            if(usable < 0)break;\n            int mi = max(0, (r - l) - (R[i] - l - usable)), ma = min(r - l, usable);\n            rep(k, mi, ma){\n                dp[r][j + k] += dp[l][j] * fact(r - l, k);\n            }\n        }\n        int until_next = cnt[L[i + 1]] - cnt[r];\n        rep(j, 0, N){\n            if(j + until_next > N)break;\n            dp[L[i + 1]][j + until_next] = dp[r][j];\n        }\n    }\n\n    cout << dp[N][cnt[N]] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],tmp[maxm+8];\nint f[maxm+8][maxm+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) tmp[i]=tmp[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+tmp[r[i]]-tmp[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=l[i+1]-l[i]+j-tmp[r[i]]+tmp[max(l[i]-1,r[i-1])];k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+tmp[r[i]]-tmp[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nint l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return (x*x)%MOD;\n}\nint modpow(ll x,ll y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=(ret*(x-i)*inv(i+1))%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        int le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max(0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,l[SZ],r[SZ],qzh[SZ];\nchar s[SZ];\nll dp[3003][3003],MOD=1e9+7;\nll tmp[3003];\nint sum(int l,int r)\n{\n\tif(l<=r)\n\treturn qzh[r]-qzh[l-1];\n\treturn 0;\n}\nll fac[SZ],rfac[SZ];\nll qp(ll a,ll b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&1) ans=ans*a%MOD;\n        a=a*a%MOD; b>>=1;\n    }\n    return ans;\n}\nll C(int a,int b)\n{\n\tif(b>a) return 0;\n\treturn fac[a]*rfac[b]%MOD*rfac[a-b]%MOD;\n}\nint main()\n{\n\tfac[0]=rfac[0]=1;\n\tfor(int i=1;i<=200000;i++)\n\tfac[i]=fac[i-1]*i%MOD, rfac[i]=rfac[i-1]*qp(i,MOD-2)%MOD;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) qzh[i]=qzh[i-1]+s[i]-48;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t\tif(r[i]<r[i-1]) {--i; --m; continue;}\n\t}\n\tl[m+1]=n+1; r[m+1]=n+1;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) tmp[j]=0;\n\t\tint s=sum(max(r[i-1]+1,l[i]),r[i]);\n\t\tfor(int j=0;j<=n;j++) tmp[j+s]+=dp[i-1][j];\n\t\tint ol=max(r[i]-l[i+1]+1,0),p=r[i]-l[i]+1-ol;\n\t\tfor(int j=0;j<=ol;j++)\n\t\tfor(int k=j;k<=n&&k-j<=p;k++)\n\t\t\tdp[i][j]=(dp[i][j]+C(p,k-j)*tmp[k]%MOD)%MOD;\n\t}\n\tll ans=dp[m][0];\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nstruct Combination {\n  vector<long long> fac, finv, inv;\n  const int mod;\n\n  Combination(int MAX, int mod = MOD) : fac(MAX + 1), finv(MAX + 1), inv(MAX + 1), mod(mod) {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i=2; i<=MAX; ++i) {\n      fac[i] = fac[i-1] * i % mod;\n      inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n      finv[i] = finv[i-1] * inv[i] % mod;\n    }\n  }\n\n  long long P(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[n-r] % mod;\n  }\n\n  long long C(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * (finv[r] * finv[n-r] % mod) % mod;\n  }\n\n  long long H(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return C(n + r - 1, r);\n  }\n};\n\nstruct path {\n  int l, r;\n\n  path(int l, int r) : l(l), r(r) {}\n};\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n\n  vector<path> g;\n  rep(i,m) {\n    int l, r; cin >> l >> r; --l;\n    if (!g.empty() && l == g.back().l) {\n      chmax(g.back().r, r);\n    } else if (g.empty() || r > g.back().r) {\n      g.emplace_back(l, r);\n    }\n  }\n\n  m = g.size();\n  g.emplace_back(n, n);\n\n  vector<path> sum(m+1, {0, 0});\n  rep(j, g[0].l) {\n    sum[0].l += s[j] - '0';\n  }\n  rep(j, g[0].r) {\n    sum[0].r += s[j] - '0';\n  }\n\n  rep1eq(i,m) {\n    sum[i] = sum[i-1];\n    REP(j, g[i-1].l, g[i].l - 1) {\n      sum[i].l += s[j] - '0';\n    }\n    REP(j, g[i-1].r, g[i].r - 1) {\n      sum[i].r += s[j] - '0';\n    }\n  }\n  \n  Graph<int> dp(m+1, vi(n+1, 0));\n  dp[0][sum[0].l] = 1;\n\n  Combination comb(n);\n\n  rep(i,m) {\n    if (g[i].r <= g[i+1].l) {\n      repeq(j, g[i].l) if (dp[i][j] != 0) {\n        (dp[i+1][sum[i+1].l] += dp[i][j] * comb.C(g[i].r - g[i].l, sum[i].r - j) % MOD) %= MOD;\n      }\n      continue;\n    }\n\n    repeq(j,g[i].l) if (dp[i][j] != 0) {\n      int MIN = max((g[i+1].l - g[i].r) + (sum[i].r - j), 0);\n      int MAX = min(sum[i].r - j, g[i+1].l - g[i].l);\n\n      REP(k, MIN, MAX) {\n        (dp[i+1][j+k] += dp[i][j] * comb.C(g[i+1].l - g[i].l, k) % MOD) %= MOD;\n      }\n    }\n  }\n\n  int ans = accumulate(ALL(dp[m]), 0LL) % MOD;\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint solve(string s, vector<int> l, vector<int> r) {\n\tint N = s.length(), M = l.size();\n\tint R = l[0], zero = 0, one = 0;\n\tint j = 0;\n\tvector<int> dp(N + 1);\n\tdp[0] = 1;\n\tfor (int i = l[0]; i < r[M - 1]; i++) {\n\t\tif (j < M && i == l[j]) {\n\t\t\tfor (int i = R; i < r[j]; i++) {\n\t\t\t\tif (s[i] == '0') zero++;\n\t\t\t\tif (s[i] == '1') one++;\n\t\t\t}\n\t\t\tR = r[j];\n\t\t\tj++;\n\t\t}\n\t\tvector<int> _dp(N + 1);\n\t\tfor (int x = 0; x <= N; x++) {\n\t\t\tint k0 = i - l[0] - x, k1 = x;\n\t\t\tif (k0 < 0 || k1 < 0) continue;\n\t\t\tif (k0 < zero) _dp[x] = (_dp[x] + dp[x]) % MOD;\n\t\t\tif (k1 < one) _dp[x + 1] = (_dp[x + 1] + dp[x]) % MOD;\n\t\t}\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= N; x++)\n\t\tans = (ans + dp[x]) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tvector<int> l, r;\n\tint ma = 0;\n\twhile (M--) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--;\n\t\tif (y <= ma) continue;\n\t\tma = y;\n\t\tl.pb(x); r.pb(y);\n\t}\n\tM = l.size();\n\tvector<int> v;\n\tv.pb(0);\n\tfor (int j = 0; j + 1 < M; j++)\n\t\tif (r[j] <= l[j + 1])\n\t\t\tv.pb(j + 1);\n\tv.pb(M);\n\tint ans = 1;\n\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\tvector<int> _l, _r;\n\t\tfor (int j = v[k]; j < v[k + 1]; j++)\n\t\t\t_l.pb(l[j]), _r.pb(r[j]);\n\t\tans = (ll)ans * solve(s, _l, _r) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-10;\nconst ull mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow_mod(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nvl fact(3005);\n\nll Fact(ll n){\n\tif(fact[n]) return fact[n];\n\tif(!n) return fact[n]=1;\n\treturn fact[n]=Fact(n-1)*n%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow_mod(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(Fact(n),Fact(n-k)*Fact(k)%mod);\n}\n\nint n,m;\nstring s;\n\nint ff(int l,int r){\n\tint t=0;\n\tfor(int i=l;i<r;i++) t+=s[i]-'0';\n\treturn t;\n}\n\nll f(vp a){\n\tint l=a[0].first,r=a[0].second,t=ff(l,r);\n\tvl dp(n+1);\n\tdp[t]++;\n\tfor(int i=1;i<a.size();i++){\n\t\tint L=a[i].first,R=a[i].second;\n\t\tt=ff(r,R);\n\t\tvl DP(n+1);\n\t\tfor(int j=0;j<=r-l;j++) for(int k=max(0,L-r+j);k<=min(j,L-l);k++){\n\t\t\t(DP[j-k+t]+=nCk(L-l,k)*dp[j])%=mod;\n\t\t}\n\t\tl=L,r=R;dp=DP;\n\t}\n\tll res=0;\n\tfor(int i=0;i<=r-l;i++) (res+=dp[i]*nCk(r-l,i))%=mod;\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m>>s;\n\tvp a;\n\tll res=1;\n\tfor(int i=0;i<m;i++){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tif(a.empty()) a.push_back({l-1,r});\n\t\telse{\n\t\t\tint t=a.back().second;\n\t\t\tif(t<l){\n\t\t\t\t(res*=f(a))%=mod;\n\t\t\t\ta.clear();\n\t\t\t}\n\t\t\telse if(t<r) a.push_back({l-1,r});\n\t\t}\n\t}\n\tif(a.size()) (res*=f(a))%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=3005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(b<0) return 0;\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nll dp[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    int N,q;cin>>N>>q;\n    string S;cin>>S;\n    vector<pair<int,int>> Q;\n    while(q--){\n        int s,t;cin>>s>>t;\n        if(Q.size()==0) Q.push_back({s,t});\n        else if(Q.back().first==s) chmax(Q.back().second,t);\n        else if(Q.back().second<t) Q.push_back({s,t});\n    }\n    Q.push_back({N+1,N+2});\n    \n    vector<int> T(N+1);\n    int M=int(Q.size());\n    \n    for(int i=1;i<=N;i++){\n        if(S[i-1]=='1') T[i]=T[i-1]+1;\n        else T[i]=T[i-1];\n    }\n    \n    ll ans=1;\n    \n    int left=Q[0].first-1;\n    dp[0][T[left]]=1;\n    \n    for(int i=1;i<M;i++){\n        if(Q[i-1].second<Q[i].first){\n            ll sum=0;\n            for(int j=0;j<=T[Q[i-1].second];j++){\n                sum+=dp[i-1][j]*comb(Q[i-1].second-left,T[Q[i-1].second]-j);\n                sum%=mod;\n            }\n            ans*=sum;\n            ans%=mod;\n            left=Q[i].first-1;\n            dp[i][T[Q[i].first-1]]=1;\n        }else{\n            for(int j=0;j<=T[Q[i-1].second];j++){\n                for(int d=0;d<=Q[i].first-1-left;d++){\n                    if(j-d<0) continue;\n                    if(T[Q[i-1].second]-j>Q[i-1].second-(Q[i].first-1)) continue;\n                    \n                    dp[i][j]+=dp[i-1][j-d]*comb(Q[i].first-1-left,d);\n                    dp[i][j]%=mod;\n                }\n            }\n            left=Q[i].first-1;\n        }\n    }\n    \n    /*for(int i=1;i<=M;i++){\n        for(int j=0;j<=N;j++){\n            cout<<dp[i][j]<<\" \";\n        }\n        cout<<endl;\n    }*/\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<string.h>\n#include<vector>\n#include<set>\nusing namespace std;\nlong long mod=1000000007;\nchar in[3100];\nlong long dp[3100][3100];\nint r[3100];\nint sum[3100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",in);\n\tfor(int i=0;i<a;i++)r[i]=i;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tr[p]=max(r[p],q);\n\t}\n\tfor(int i=1;i<a;i++){\n\t\tr[i]=max(r[i],r[i-1]);\n\t}\n\tint cur=0;\n\tfor(int i=0;i<a;i++){\n\t\tcur+=in[i]-'0';\n\t\tsum[i]=cur;\n\t}\n\tdp[0][0]=1;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(!dp[i][j])continue;\n\t\t\tint t=sum[r[i]];\n\t\t\tif(j<=t&&t-j<=r[i]-i)dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod;\n\t\t\tif(j+1<=t&&t-j-1<=r[i]-i)dp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[a][sum[a-1]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],inv[3002];\nlld d[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= inv[n-r]; tmp %= Mod;\n\ttmp *= inv[r]; tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = inv[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][sum[x[1]-1]] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tif(d[i-1][j] == 0) continue;\n\t\t\tint cnt1,cnt2;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t}else{\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tif(cnt1 > cnt2) while(true);\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[r[i - 1]] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[r[i - 1]]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\nchar s[3005], t[3005];\nint dp[3005][3005];\nint main() {\n  int n, m, x, y;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", s + 1);\n  strcpy(t + 1, s + 1);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d %d\", &x, &y);\n    y++;\n    sort(s + x, s + y);\n    sort(t + x, t + y);\n    reverse(t + x, t + y);\n  }\n  dp[0][0] = 1;\n  int atleast = 0, atmost = 0;\n  for (int i = 1; i <= n; i++) {\n    atleast += s[i] == '1';\n    atmost += t[i] == '1';\n    for (int j = atleast; j <= atmost; j++) {\n      dp[i][j] = dp[i - 1][j] + (j > 0 ? dp[i - 1][j - 1] : 0);\n      if (dp[i][j] >= MOD) dp[i][j] -= MOD;\n    }\n  }\n  printf(\"%d\\n\", dp[n][atleast]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint le[3640],ri[3640],nz[3640],no[3640];\nint dp[3640][3640];\nint main()\n{\n\tint n,m,mo=1000000007,l,r;string s;\n\tcin>>n>>m;cin>>s;\n\tnz[0]=no[0]=0;\n\trep(i,n){\n\t\tno[i+1]=no[i]+(s[i]-'0');\n\t\tnz[i+1]=i+1-no[i+1];\n\t}\n\trep(i,n) le[i]=ri[i]=i;\n\trep(i,m){\n\t\tcin>>l>>r;l--;r--;\n\t\tREP(j,l,r+1) le[j]=min(le[j],le[l]),ri[j]=max(ri[j],ri[r]);\n\t}\n\t//rep(i,n+1) cout<<nz[i]<<' '<<no[i]<<endl;\n\t//rep(i,n) cout<<le[i]<<' '<<ri[i]<<endl;\n\t//rep(i,n) cout<<nz[ri[i]+1]<<' '<<no[ri[i]+1]<<endl;\n\tmemset(dp,0,sizeof(dp));dp[0][0]=1;\n\trep(i,n+1) rep(j,n+1){\n\t\tif(i+j>n) dp[i][j]=0;\n\t\tif(i+j>0 && i>nz[ri[i+j-1]+1]) dp[i][j]=0;\n\t\tif(i+j>0 && j>no[ri[i+j-1]+1]) dp[i][j]=0;\n\t\tif(dp[i][j]>=mo) dp[i][j]-=mo;\n\t\tdp[i+1][j]+=dp[i][j];dp[i][j+1]+=dp[i][j];\n\t}\n\tcout<<dp[nz[n]][no[n]]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<int, int> P;\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nll dp[3001][3001];\nint cnt[3000];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tcnt[i + 1] = S[i] - '0' + cnt[i];\n\t}\n\tvector<P> v;\n\tv.emplace_back(0, 0);\n\tint prev_r = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (prev_r < r) {\n\t\t\tv.emplace_back(l, r);\n\t\t\tprev_r = r;\n\t\t}\n\t}\n\tv.emplace_back(N + 1, N + 1);\n\tcomb_init(N);\n\tdp[0][0] = 1;\n\tfor (int i = 0; i + 2 < v.size(); i++) {\n\t\tint len = max(v[i].second - v[i + 1].first + 1, 0);\n\t\tint nxt_len = max(v[i + 1].second - v[i + 2].first + 1, 0);\n\t\tint rest = (v[i + 1].second - v[i + 1].first + 1) - nxt_len;\n\t\tfor (int j = 0; j <= len; j++) {\n\t\t\tint one = j + cnt[v[i + 1].second] - cnt[v[i].second];\n\t\t\tfor (int k = 0; k <= min(one, rest); k++) {\n\t\t\t\t(dp[i + 1][one - k] += dp[i][j] * comb(rest, k)) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[v.size() - 2][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i],ls[i]--;\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint pl=-1,pr=-1;\n\t\t\trep(i,m) if(pr<rs[i]){\n\t\t\t\tif(pl<ls[i])\n\t\t\t\t\tts.emplace_back(ls[i],rs[i]);\n\t\t\t\telse\n\t\t\t\t\tts.back()=mt(ls[i],rs[i]);\n\t\t\t\ttie(pl,pr)=ts.back();\n\t\t\t}\n\t\t\tint first=get<0>(ts[0]),last=get<1>(ts.back());\n\t\t\ts=s.substr(first,last-first);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=first,rs[i]-=first;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['1'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m){\n\t\t\trepi(i,ls[k],min(rs[k],ls[k+1]))\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(i+1-j<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(j+1<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\t\t\trepi(i,rs[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(s[i]=='0')\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t\telse\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\t\t}\n\n\t\tcout<<dp[n][ocount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N,M, R[3000], num[3000], dp[3001][3001];\nstring s;\n\nint main() {\n\tcin >> N >> M >> s;\n\tF0R(i,N) R[i] = i+1;\n\tR[N] = N;\n\t\n\tF0R(i,M) {\n\t    int l,r; cin >> l >> r; l--,r--;\n\t    R[l] = max(R[l],r+1);\n\t}\n\t\n\tF0R(i,N+1) {\n\t    int pre = 0;\n\t    if (i) pre = R[i-1];\n\t    \n\t    R[i] = max(pre,R[i]);\n\t    for (int j = pre; j < R[i]; ++j) if (s[j] == '1') num[i] ++;\n\t}\n\t\n\t//F0R(i,N+1) cout << i << \" \" << R[i] << \"\\n\";\n\tdp[N][0] = 1;\n\tF0Rd(L,N) F0R(j,R[L]-L+1) {\n\t    if (j <= R[L]-L-1) dp[L][j] += dp[L+1][j+num[L+1]]; // what should these indices be\n\t    if (j >= 1) dp[L][j] += dp[L+1][j+num[L+1]-1];\n\t    dp[L][j] %= MOD;\n\t    //cout << L << \" \" << j << \" \" << dp[L][j] << \"\\n\";\n\t}\n\tcout << dp[0][num[0]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\ntypedef pair<pll, pll> P;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nll mod_pow(ll x, ll n, ll mod) {\n\tif (n == 0) return 1;\n\tll res = mod_pow(x * x % mod, n / 2, mod);\n\tif (n & 1) res = res * x % mod;\n\treturn res;\n}\n\nvector<ll> fact, inv;\nvoid fact_inv(int n, ll mod) {\n\tfact.resize(n + 1);\n\tinv.resize(n + 1);\n\t\n\tfact[0] = 1;\n\tFOR(i, 1, n + 1) fact[i] = fact[i - 1] * i % mod;\n\tinv[n] = mod_pow(fact[n], mod - 2, mod);\n\tfor (int i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nll ncr(ll n, ll r, ll mod) {\n\tif (n < r || r < 0 || n < 0) return 0;\n\treturn fact[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nint N, M;\nstring S;\nint l[3000], r[3000];\nll dp[3001][3001]; // i:区間, j:前共通部分に含まれる0の数\n\nint main() {\n\tfact_inv(3000, MOD);\n\t\n\tcin >> N >> M;\n\tcin >> S;\n\tREP(i, M) scanf(\"%d %d\", l + i, r + i), l[i]--, r[i]--;\n\t\n\tvector<pii> q;\n\tq.push_back(pii(l[0], r[0]));\n\t\n\tFOR(i, 1, M) {\n\t\tpii &b = q.back();\n\t\tif (b.fi == l[i]) chmax(b.se, r[i]);\n\t\telse if (b.se < r[i]) q.push_back(pii(l[i], r[i]));\n\t}\n\tq.push_back(pii(N, N));\n\t\n\tdp[0][0] = 1;\n\tREP(i, q.size() - 1) {\n\t\tint lcc = max(q[i].se - q[i + 1].fi + 1, 0); // 後区間との共通の長さ\n\t\t\n\t\tint bcc = 0; // 前区間との共通の長さ\n\t\tif (i > 0) bcc = max(q[i - 1].se - q[i].fi + 1, 0);\n\t\t\n\t\tint bacnt = 0; // 前区間を除く区間に含まれる0の数\n\t\tFOR(j, q[i].fi + bcc, q[i].se + 1) if (S[j] == '0') bacnt++;\n\t\t\n\t\tint l = q[i].se - q[i].fi + 1; // 区間の長さ\n\t\t\n\t\tREP(j, bcc + 1) {\n\t\t\tif (dp[i][j] == 0) continue;;\n\t\t\t\n\t\t\tint cnt = bacnt + j; // 区間[l_i, r_i]の中に、cnt個の1が存在する。\n\t\t\t\n\t\t\tREP(k, lcc + 1) {\n\t\t\t\t(dp[i + 1][k] += dp[i][j] * ncr(l - lcc, cnt - k, MOD) % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[q.size() - 1][0] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n        ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        for(int j=v[i-1].second+1;j<=v[i].second;j++){\n            if(s[j-1]=='1'){\n                tmp++;\n            }\n        }\n        nm[i] = tmp;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n        ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=3200;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\npii a[maxn];\nll n,m;\nll ent[maxn][maxn];\nll dp[maxn][maxn];\nll par[maxn];\n\nvoid comperess(){\n\tfor(ll i=0;i<m;i++){\n\t\ta[i].S*=-1;\n\t}\n\tsort(a,a+m);\n\tfor(ll i=0;i<m;i++){\n\t\ta[i].S*=-1;\n\t}\n\n\tvector<pii> vec;\n\tfor(ll i=0;i<m;i++){\n\t\tif(vec.size()==0 || vec.back().S<a[i].S){\n\t\t\tvec.pb(a[i]);\n\t\t}\n\t}\n\tfor(ll i=0;i<vec.size();i++){\n\t\ta[i]=vec[i];\n\t}\n\tm=vec.size();\n}\nbool f(char c){\n\treturn c-'0';\n}\nll find_par(ll l,ll r){\n\tif(l==0){\n\t\treturn par[r];\n\t}\t\n\treturn par[r]-par[l-1];\n}\nll find_par(ll l){\n\treturn find_par(a[l].F,a[l].S);\n}\nll tol(ll l,ll r){\n\treturn r-l+1;\n}\nll tol(ll i){\n\treturn a[i].S-a[i].F+1;\n}\n\n\nint main(){\n\tent[0][0]=1;\n\tfor(ll i=1;i<maxn;i++){\n\t\tent[i][0]=1;\n\t\tent[i][i]=1;\n\t\tfor(ll j=1;j<i;j++){\n\t\t\tent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n\t\t}\n\t}\n\n\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tpar[0]=f(s[0]);\n\tfor(ll i=1;i<n;i++){\n\t\tpar[i]=(par[i-1]+f(s[i]));\n\t}\n\tfor(ll i=0;i<m;i++){\n\t\tcin>>a[i].F>>a[i].S;\n\t\ta[i].F--;\n\t\ta[i].S--;\n\t}\n\tcomperess();\n\tfor(ll i=0;i<m;i++){\n\t\t//cout<<a[i].F<<'@'<<a[i].S<<endl;\n\t}\n\tfor(ll i=0;i<=tol(m-1);i++){\n\t\tdp[m-1][i]=ent[tol(m-1)][i];\n\t}\n\tfor(ll i=m-2;i>=0;i--){\n\t\tif(a[i].S<a[i+1].F){\n\t\t\tfor(ll j=0;j<=tol(i);j++){\n\t\t\t\tdp[i][j]=(ent[tol(i)][j]*dp[i+1][find_par(i+1)])%mod;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(ll j=0;j<=tol(i);j++){\n\t\t\t\tll CTE=find_par(a[i].S+1,a[i+1].S);\n\t\t\t\tll TOL=tol(a[i].F,a[i+1].F-1);\n\t\t\t\tll Tol=tol(a[i+1].F,a[i].S);\n\t\t\t\tfor(ll k=max(0LL,j-Tol);k<=min(TOL,j);k++){\n\t\t\t\t\tdp[i][j]+=(ent[TOL][k]*dp[i+1][j-k+CTE])%mod;\n\t\t\t\t}\n\t\t\t\tdp[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][find_par(0)];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n\nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n\nusing namespace std;\nconst int N=3010,mod=1e9+7;\nchar s[N];\nint n,m,ans,c[N][N],f[N][N],a[N];\nstruct data\n{\n    int l,r;\n    bool operator<(const data &x) const\n    {\n        return l<x.l || (l==x.l && r>x.r);\n    }\n} b[N];\n\nint main()\n{\n    n=get(),m=get();\n    rep(i,0,n)\n    {\n        c[i][0]=1;\n        rep(j,1,i)\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n    }\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    rep(i,1,m)\n        b[i].l=get(),b[i].r=get();\n    sort(b+1,b+1+m);\n    int t=0;\n    rep(i,1,m)\n        if (b[i].r>b[t].r)\n            b[++t]=b[i];\n    m=t,b[m+1].l=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        int w=a[b[i].r]-a[max(b[i].l-1,b[i-1].r)];\n        int l=min(b[i].r,b[i+1].l-1)-b[i].l+1;\n        int mx=b[i].r-b[i].l+1-l;\n        rep(j,0,l)\n            rep(k,max(0,w-j),mx)\n                f[i][k]=(f[i][k]+1ll*f[i-1][j+k-w]*c[l][j])%mod;\n    }\n    rep(i,0,n)\n        ans=(ans+f[m][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint dp[4000][4000];\nint b[4000];\nint sum[4000];\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tvector<P>v;\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r); l--; r--;\n\t\tif (v.empty())v.push_back(P(l, r));\n\t\telse if (v.back().first == l)v.back().second = max(v.back().second, r);\n\t\telse if (v.back().second < r)v.push_back(P(l, r));\n\t}\n\tfor (auto p : v)b[p.first] = p.second;\n\tfor (int i = 1; i < n; i++)b[i] = max({ i,b[i],b[i - 1] });\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '1')cnt++;\n\t\tsum[i] = cnt;\n\t}\n\tdp[0][cnt] = 1;\n\tfor (int i = 0; i < n; i++)for (int j = 0; j < cnt + 1; j++) {\n\t\tif (dp[i][j] == 0)continue;\n\t\tint a = j - (sum[n - 1] - sum[b[i]]);\n\t\tif (a)(dp[i + 1][j - 1] += dp[i][j]) %= MOD;\n\t\tif (b[i] - i + 1 - a)(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t}\n\tcout << dp[n][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            cout<<x<<\"/\"<<y<<endl;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\nvector<l_l>convert(vector<l_l>v){\n    vector<l_l>r;\n    ll n=v.size();\n    rep(i,0,n-1){\n        if(i==n-1||v[i].fi!=v[i+1].fi)r.pb(v[i]);\n        else if(v[i]>v[i+1])swap(v[i],v[i+1]);\n    }\n    n=r.size();\n    vector<l_l>res;\n    ll mx=-inf;\n    rep(i,0,n-1){\n        if(chmax(mx,r[i].se)){\n            res.pb(r[i]);\n        }\n    }\n    return res;\n}\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 2000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\n\nint main(){fastio\n    calc();\n    ll n,m;cin>>n>>m;\n    string s;cin>>s;\n    vector<l_l>v(m);\n    rep(i,0,m-1){\n        cin>>v[i].fi>>v[i].se;\n        v[i].fi--;v[i].se--;\n    }\n    v=convert(v);\n   // for(auto x:v)cout<<x.fi<<\" \"<<x.se<<endl;cout<<\"***\"<<endl;\n    m=v.size();\n    ll cnt[n+1];\n    cnt[0]=0;\n    rep(i,0,n-1){\n        cnt[i+1]=cnt[i]+s[i]-'0';\n    }\n    ll dp[m+1][n+1];memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    rep(i,0,m-1){\n        ll ad=(i==0?cnt[v[i].se+1]-cnt[v[i].fi]:cnt[v[i].se+1]-cnt[v[i-1].se+1]);\n        ll sp=(i==m-1?v[i].se+1-v[i].fi:v[i+1].fi-v[i].fi);\n        rep(j,0,n){\n            if(dp[i][j]==0)continue;\n            rep(k,0,sp){\n                ll nxj=j+ad-k;\n                if(nxj<0||nxj>n)continue;\n                Add(dp[i+1][nxj],dp[i][j]*comb(sp,k));\n            }\n        }\n       // cout<<ad<<\" \"<<sp<<endl;\n        if(i==m-1)break;\n        ll mx=v[i].se-v[i+1].fi+1;\n        chmax(mx,0);\n        rep(j,mx+1,n)dp[i+1][j]=0;\n    }\n    /*\n    rep(i,0,m){\n        rep(j,0,n){\n            cout<<dp[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;\n    */\n    cout<<mod(dp[m][0])<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3005\nusing namespace std;\n\nint n,m,s[N],a[N],b[N],dp[N][N],cbn[N][N]; char ch[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) s[i]=s[i-1]+(ch[i]=='1');\n\tm++; a[1]=b[1]=1;\n\tfor (i=2; i<=m; i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif (a[i]==a[i-1]){\n\t\t\tb[i-1]=max(b[i-1],b[i]); i--; m--;\n\t\t}\n\t\tif (b[i]<=b[i-1]){ i--; m--; continue; }\n\t}\n\ta[m+1]=n+1;\n\tdp[0][0]=1;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++) cbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tfor (i=1; i<=m; i++){\n\t\tfor (j=max(a[i+1]-1-b[i]+s[b[i]],0); j<=s[b[i]]; j++)\n\t\t\tfor (k=0; k<=a[i+1]-a[i] && k<=j; k++) dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k]*cbn[a[i+1]-a[i]][k])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[m][s[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 2005\n\nconst LL mod=1000000007;\nLL ans,n,m,C[N][N],f[N],g[N],a[N];\nchar s[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nint main(){\n\tscanf(\"%lld%lld%s\",&n,&m,s+1);\n\tfor (LL i=0;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor (LL j=1;j<=i;++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tfor (LL i=1;i<=n;++i) a[i]=s[i]-'0';\n\tf[0]=1;\n\tans=1;\n\tLL l=1,r=0;\n\tfor (LL i=1;i<=m;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\tif (y<=r) continue;\n\t\tif (x>r){\n\t\t\tLL sum=0;\n\t\t\tfor (LL j=0;j<=r-l+1;++j){\n\t\t\t\tupd(sum,f[j]*C[r-l+1][j]);\n\t\t\t}\n\t\t\tans=ans*sum%mod;\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[0]=1;\n\t\t\tl=x; r=x-1;\n\t\t}\n\t\tLL tmp=0;\n\t\tfor (LL j=r+1;j<=y;++j){\n\t\t\ttmp+=a[j];\n\t\t}\n\t\tLL len=x-l;\n\t\tmemset(g,0,sizeof g);\n\t\tfor (LL j=0;j<=n;++j){\n\t\t\tfor (LL k=0;k<=len&&k<=j;++k){\n\t\t\t\tif (j-k<=r-l+1-len) upd(g[j-k+tmp],f[j]*C[len][k]);\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,g,sizeof f);\n\t\tl=x; r=y;\n\t}\n\tLL sum=0;\n\tfor (LL j=0;j<=r-l+1;++j){\n\t\tupd(sum,f[j]*C[r-l+1][j]);\n\t}\n\tans=ans*sum%mod;\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=3e3+5,Mod=1e9+7;\nint f[N][N],n,m,a[N],r[N];\nint Plus(int &x,int y){ return x=(x+y)%Mod; }\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n){\n\t\tchar c=getchar();\n\t\twhile(c!='0'&&c!='1') c=getchar();\n\t\ta[i]=c-'0';\n\t}\n\trep(i,1,n+1) a[i]=a[i]+a[i-1],r[i]=i;\n\trep(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tr[u]=max(v,r[u]);\n\t}\n\tf[1][a[r[1]]]=1;\n\trep(i,1,n) r[i]=max(r[i],r[i-1]);\n\trep(i,1,n) rep(j,0,a[n]) if(f[i][j]){\n\t\tint L=r[i]+1,R=r[i+1],x=L-i-j,y=j;//x->0 y->1\n\t\tif(x) Plus(f[i+1][j+a[R]-a[L-1]],f[i][j]);\n\t\tif(y) Plus(f[i+1][j-1+a[R]-a[L-1]],f[i][j]);\n\t}\n\tprintf(\"%d\",f[n+1][0]%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 3000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,s[MN+5],f[MN+5],g[MN+5],l[MN+5],r[MN+5],p[MN+5],inv[MN+5];\nchar st[MN+5];\nvoid Move(int s)\n{\n\tfor(int i=n;i>=s;--i) f[i]=f[i-s];\n\tfor(int i=0;i<s;++i) f[i]=0;\n}\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;} \nint main()\n{\n\tn=read();m=read();scanf(\"%s\",st+1);p[0]=p[1]=inv[0]=inv[1]=f[0]=1;\n\tfor(int i=1;i<=n;++i) s[i]=s[i-1]+(st[i]=='1');\n\tfor(int i=2;i<=n;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=n;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;n=0;\n\tfor(int i=1;i<=m;++i) l[i]=read(),n=max(n,r[i]=read());l[m+1]=n+1;\n\tfor(int i=1,mr=l[1]-1;i<=m;++i)\n\t{\n\t\tif(r[i]>mr) Move(s[r[i]]-s[mr]),mr=r[i];\n\t\tif(l[i+1]>l[i])\n\t\t{\n\t\t\tint len=min(l[i+1]-1,mr)-l[i]+1;\n\t\t\tfor(int j=0;j<=n;++j) if(f[j])\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=j&&k<=len;++k) if(mr-l[i]+1-j>=len-k)\n\t\t\t\t\tg[j-k]=(g[j-k]+1LL*f[j]*C(len,k))%mod;\t\n\t\t\t}\n\t\t\tfor(int j=0;j<=n;++j) f[j]=g[j],g[j]=0;\n\t\t\tmr=max(mr,l[i+1]-1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst Int MOD = 1000000007;\nconst Int MAX = 10000;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(Int n, Int k) {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nInt dp[3010][3010];\nint main() {\n    COMinit();\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> L, R;\n    L.push_back(-1), R.push_back(-1);\n    for (int i = 0; i < M; i++) {\n        int l, r; cin >> l >> r; l--;\n        if (L.back() == l) {\n            R.back() = max(R.back(), r);\n        } else if (R.back() < r) {\n            L.push_back(l), R.push_back(r);\n        }\n    }\n    L.push_back(N + 1), R.push_back(N + 1);\n    dp[0][0] = 1;\n    for (int i = 1; i <= L.size() - 2; i++) {\n        int add = 0;\n        for (int k = max(R[i - 1], L[i]); k < R[i]; k++) {\n            add += S[k] - '0';\n        }\n        int set = max(0, min(L[i + 1], R[i]) - L[i]);\n        for (int j = 0; j <= max(0, R[i - 1] - L[i]); j++) {\n            int cnt = j + add;\n            for (int k = max(0, cnt - set); k <= min(cnt, max(0, R[i] - L[i + 1])); k++) {\n                dp[i][k] += COM(set, cnt - k) * dp[i - 1][j];\n                dp[i][k] %= MOD;\n            }\n        }\n    }\n    cout << dp[L.size() - 2][0] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nll l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return (x*x)%MOD;\n}\nint modpow(ll x,int y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=(ret*(x-i)*inv(i+1))%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        ll le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max((ll)0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 3005, MOD = 1000000007;\ntypedef long long i64;\ni64 f[2][MAX_N];\nint L[MAX_N], R[MAX_N], C[MAX_N][MAX_N];\nchar s[MAX_N];\n\nint main() {\n  int N, M;\n  \n  scanf(\"%d%d\", &N, &M);\n  scanf(\"%s\", s + 1);\n  \n  for (int i = 1; i <= M; ++i) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n    if (R[i] <= R[i - 1]) i--, M--;\n  }\n  \n  for (int i = 0; i <= N; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n  }\n  \n  int o = 0, p;\n  R[0] = L[1] - 1, f[0][0] = 1, L[M + 1] = N + 1;\n  \n  for (int i = 1; i <= M; ++i) {\n    p = o, o ^= 1;\n    memset(f[o], 0, sizeof f[o]);\n    int num = 0;\n    for (int j = R[i - 1] + 1; j <= R[i]; ++j)\n      if (s[j] == '1') num++;\n    \n    int temp1 = R[i - 1] - L[i] + 1, temp2 = max(R[i] - L[i + 1] + 1, 0);\n    \n    for (int k1 = 0; k1 <= temp1; ++k1) {\n      int num1 = num + k1, num0 = R[i] - L[i] + 1 - num1;\n      for (int k2 = 0; k2 <= temp2; ++k2) {\n\tint rest1 = num1 - k2, rest0 = num0 - temp2 + k2;\n\tif (rest1 < 0 || rest0 < 0) continue;\n\tf[o][k2] = (f[o][k2] + C[rest1 + rest0][rest1] * f[p][k1] % MOD) % MOD;\n      }\n    }\n    if (R[i] < L[i + 1] - 1) R[i] = L[i + 1] - 1;\n  }\n\n  printf(\"%lld\\n\", f[o][0]);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int mod=1e9+7;\nint f[3005][3005],sum[3005],n,m,mx[3005];\nchar s[3005];\nint add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) sum[i]=sum[i-1]+(s[i]=='1');\n\tfor(int i=1,l,r;i<=m;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tfor(int p=l;p<=r;p++) mx[p]=max(mx[p],r);\n\t}\n\tf[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!mx[i]){\n\t\t\tfor(int p=0;p<=i;p++){\n\t\t\t\tif(s[i]=='1'&&p) f[i][p]=f[i-1][p-1];\n\t\t\t\tif(s[i]=='0') f[i][p]=f[i-1][p];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int p=0;p<=i;p++){\n\t\t\tif(p) f[i][p]=add(f[i-1][p],f[i-1][p-1]);\n\t\t\telse f[i][p]=f[i-1][p];\n\t\t\tif(sum[mx[i]]<p||(mx[i]-sum[mx[i]])<i-p) f[i][p]=0;\n\t\t}\n\t}\n\tprintf(\"%d\",f[n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\nconst long long MOD=1000000007;\nvoid op(set<string> &sSet,int l,int r)\n{\n\tl--;\n\tr--;\n\tint strLen=r-l+1;\n\tset<string> tmpSet;\n\tset<string>::iterator sit;\n\tfor (sit=sSet.begin();sit!=sSet.end();sit++){\n\t\tchar *S=(char*)(*sit).c_str();\n\t\tint n=0;\n\t\twhile (n<strLen){\n\t\t\tchar ch=*(S+l);\n\t\t\tmemcpy(S+l,S+l+1,strLen);\n\t\t\t*(S+r)=ch;\n\t\t\ttmpSet.insert(S);\n\t\t\tn++;\n\t\t}\n\t}\n\tsSet.insert(tmpSet.begin(),tmpSet.end());\n\ttmpSet.clear();\n\treturn;\n}\nint main(int argc, char* argv[])\n{\n\tint N,M;\n\tcin>>N>>M;\n\tstring S;\n\tcin>>S;\n\tset<string> sSet;\n\tsSet.insert(S);\n\tint i;\n\tint l,r;\n\tlong long aw=0;\n\tfor (i=0;i<M;i++){\n\t\tcin>>l>>r;\n\t\top(sSet,l,r);\n\t}\n\tcout<<sSet.size()%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst ll mod = 1000000007LL ;\n\nint n , m ;\nchar s[ 3005 ] ;\nii q[ 3005 ] ;\nvector< ii > v ;\nint pre[ 3005 ] ;\nll C[ 3005 ][ 3005 ] ;\n\nvoid init() {\n  scanf( \"%d%d%s\" , &n , &m , s + 1 ) ;\n  pre[ 0 ] = 0 ;\n  for ( int i = 1 ; i <= m ; i ++ ) {\n    scanf( \"%d%d\" , &q[ i ].first , &q[ i ].second ) ;\n    if ( v.size() == 0 ) v.push_back( q[ i ] ) ;\n    else {\n      q[ i ].second = max( v.back().second , q[ i ].second ) ;\n      if ( v.back().first < q[ i ].first ) v.push_back( q[ i ] ) ;\n      else v.back().second = max( v.back().second , q[ i ].second ) ;\n    }\n  }\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    if ( s[ i ] == '1' ) pre[ i ] = pre[ i - 1 ] + 1 ;\n    else pre[ i ] = pre[ i - 1 ] ;\n  }\n}\n\nll dp[ 3005 ][ 3005 ] ;\n\nvoid process() {\n  dp[ v[ 0 ].first ][ pre[ v[ 0 ].first - 1 ] ] = 1 ;\n  for ( int i = 0 ; i + 1 < (int)v.size() ; i ++ ) {\n    ii nw = v[ i ] ;\n    ii nxt = v[ i + 1 ] ;\n    int lb = nw.first , rb = nw.second ;\n    int nlb = nxt.first ;\n    int emp = min( nlb - 1 , rb ) - ( lb - 1 ) ;\n    for ( int j = 0 ; j < lb ; j ++ ) if ( dp[ lb ][ j ] ) {\n      int ones = pre[ rb ] - j ;\n      int zeros = ( rb - lb + 1 ) - ones ;\n      int lbnd = max( j , emp - zeros + j ) ;\n      int bnd = min( pre[ rb ] , j + emp ) ;\n      int offs = 0 ;\n      if ( rb < nlb ) offs = pre[ nlb - 1 ] - pre[ rb - 1 ] ;\n      for ( int one = lbnd ; one <= bnd ; one ++ ) {\n        dp[ nlb ][ one + offs ] = ( dp[ nlb ][ one + offs ] + dp[ lb ][ j ] * C[ emp ][ one - j ] ) % mod ;\n      }\n    }\n  }\n  ll ans = 0 ;\n  ii nw = v.back() ;\n  for ( int j = 0 ; j < nw.first ; j ++ ) if ( dp[ nw.first ][ j ] ) {\n    int one = pre[ nw.second ] - j ;\n    if ( one <= nw.second - nw.first + 1 ) {\n      ans = ( ans + dp[ nw.first ][ j ] * C[ nw.second - nw.first + 1 ][ one ] ) % mod ;\n    }\n  }\n  printf( \"%lld\\n\" , ans ) ;\n}\n\nint main() {\n  for ( int i = 0 ; i <= 3000 ; i ++ )\n    C[ i ][ 0 ] = C[ i ][ i ] = 1 ;\n  for ( int i = 1 ; i <= 3000 ; i ++ ) {\n    for ( int j = 1 ; j < i ; j ++ ) {\n      C[ i ][ j ] = ( C[ i - 1 ][ j ] + C[ i - 1 ][ j - 1 ] ) % mod ;\n    }\n  }\n/*\n#ifdef ONLINE_JUDGE\nfreopen(\"input.txt\",\"r\",stdin);\nfreopen(\"output.txt\",\"w\",stdout);\n#endif\n  int Cases;\n  scanf( \"%d\" , &Cases ) ;\n  for ( int cases = 1 ; cases <= Cases ; cases ++ ) {\n*/\n    init() ;\n    process() ;\n/*\n  }\n*/\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    int n, m;\n    string s;\n    cin >> n >> m >> s;\n\n    vector<int> minCnt(n+1), maxCnt(n+1);\n    for(int i=0; i<n; ++i){\n        if(s[i] == '1')\n            minCnt[i+1] = maxCnt[i+1] = 1;\n        minCnt[i+1] += minCnt[i];\n        maxCnt[i+1] += maxCnt[i];\n    }\n\n    for(int i=0; i<m; ++i){\n        int l, r;\n        cin >> l >> r;\n\n        int x = minCnt[l-1];\n        int y = minCnt[r];\n        for(int j=r; j>=l; --j)\n            minCnt[j] = max(x, y - (r - j));\n\n        x = maxCnt[l-1];\n        y = maxCnt[r];\n        for(int j=l; j<=r; ++j)\n            maxCnt[j] = min(y, x + (j - l + 1));\n    }\n\n    vector<int> dp(n+1, 0);\n    dp[0] = 1;\n    for(int i=1; i<=n; ++i){\n        vector<int> nextDp(n+1, 0);\n        for(int j=0; j<=n; ++j){\n            if(minCnt[i] <= j && j <= maxCnt[i]){\n                nextDp[j] += dp[j];\n                nextDp[j] %= MOD;\n            }\n            if(minCnt[i] <= j + 1 && j + 1 <= maxCnt[i]){\n                nextDp[j+1] += dp[j];\n                nextDp[j+1] %= MOD;\n            }\n        }\n        dp.swap(nextDp);\n    }\n\n    int ans = accumulate(dp.begin(), dp.end(), 0);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pair<int,int>,int>\n#define aa first\n#define bb second\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nconst int q=1000000007;\nint n,m,f[3010][3010],a[3010],b[3010],l[3010],r[3010];\nchar s[3010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d%d%s\",&n,&m,&s[0]+1);\n\tfor(i=1;i<=m;i++)\n\t  scanf(\"%d%d\",&l[i],&r[i]);\n\tfor(i=1,j=0,k=0;i<=n;i++)\n\t  {\n\t   a[i]=a[i-1];\n\t   b[i]=b[i-1];\n\t   for(;j<=m && i==l[j+1];j++)\n\t     for(;k+1<=r[j+1];k++)\n\t       if(s[k+1]=='0')\n\t         a[i]++;\n\t       else\n\t         b[i]++;\n\t   if(k<i)\n\t     {\n\t\t  k++;\n\t\t  if(s[i]=='0')\n\t\t    a[i]++;\n\t\t  else\n\t\t    b[i]++;\n\t\t }\n\t  }\n\tf[0][0]=1;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   f[i][0]=f[i-1][0];\n\t   for(j=1;j<=i;j++)\n\t     f[i][j]=(f[i-1][j-1]+f[i-1][j])%q;\n\t   for(j=a[i]+1;j<=i;j++)\n\t     f[i][j]=0;\n\t   for(j=0;j<i-b[i];j++)\n\t     f[i][j]=0;\n\t  }\n\tprintf(\"%d\\n\",f[n][a[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define er erase\n\ntypedef pair<int, int> ii;\ntypedef pair<ii, int> iii;\ntypedef pair<ii, ii> iiii;\n\nconst int oo = 1e18 + 7, mod = 1e9 + 7;\n\nconst int N = 3005;\n\nint n, m, r[N], dp[N][N], pref[N];\nstring s;\n\nsigned main(){\n\tios_base::sync_with_stdio(0);\n\tcin >> n >> m;\n\tcin >> s;\n    s = '*' + s;\n    for(int i = 1; i <= n; i++) pref[i] = (pref[i - 1] + (s[i] - '0'));\n\tfor(int i = 1; i <= m; i++){\n\t    int le, ri;\n\t    cin >> le >> ri;\n\t    r[le] = max(r[le], ri);\n\t}\n\tfor(int i = 2; i <= n; i++) if(i <= r[i - 1]) r[i] = max(r[i], r[i - 1]);\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t    for(int j = 0; j <= i; j++){\n\t        if(!r[i]){\n\t            if(j >= (s[i] - '0')) dp[i][j] = dp[i - 1][j - (s[i] - '0')];\n\t            continue;\n\t        }\n\t        else{\n\t            if(r[i] - pref[r[i]] < (i - j)) continue;\n\t            if(pref[r[i]] < j) continue;\n\t            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod;\n\t        }\n\t    }\n\t}\n\tcout << dp[n][pref[n]];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define M 3010\n#define MOD 1000000007\nchar s[M]; int sum[M];\nint r[M];\nint f[M][M];\nint main() {\n\tint n, m; scanf(\"%d %d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; i ++) sum[i] = sum[i - 1] + (s[i] == '1');\n\tfor (int i = 1; i <= n; i ++) r[i] = i;\n\tfor (int i = 1; i <= m; i ++) {\n\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\tr[x] = max(r[x], y);\n\t}\n\tfor (int i = 1; i <= n; i ++) r[i] = max(r[i - 1], r[i]);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 0; j <= sum[r[i - 1]]; j ++)\n\t\t\tif(f[i - 1][j]) {\n\t\t\t\tif(sum[r[i]] > j) (f[i][j + 1] += f[i - 1][j]) %= MOD;\n\t\t\t\tif(sum[r[i]] - j < r[i] - i + 1) (f[i][j] += f[i - 1][j]) %= MOD;\n\t\t\t}\n\t}\n\tcout << f[n][sum[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 301\n#define MOD 1000000007\n#define int ll\nint N,M;\nstring S;\n\nint A[maxn];\n\nint dp[maxn][maxn];\nint ss[maxn];\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\n\n\ninline int qry(pi i){\n\tif (i.f == 0) return ss[i.s];\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint dpf(int i,int j,int k){\n\t//cout<<i<<' '<<j<<' '<<k<<'\\n';\n\tif (k > sz(pi(i,j))) return 0;\n\tif (k < 0) return 0;\n\tif (A[i] > j){\n\t\tk += qry(pi(j + 1, A[i]));\n\t\tj = A[i];\n\t}\n\t\n\tif (dp[i][k] != -1) return dp[i][k];\n\t\n\t\n\t\n\t\n\t\n\tif (i == N) return 1;\n\t\n\t\n\t\n\n\n\tif (k > 0) return dp[i][k] = (dpf(i+1,j,k-1) + dpf(i+1,j,k)) % MOD;\n\telse return dp[i][k] = dpf(i+1,j,k);\n}\n\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\tFOR(i,0,N-1) A[i] = i;\n\t\n\tDEC(i,M-1,0){\n\t\tA[st.top().f - 1] = st.top().s - 1;\n\t\tst.pop();\n\t}\n\t\n\tif (S[0] == '1') ss[0] = 1;\n\telse ss[0] = 0;\n\t\n\tFOR(i,1,N-1){\n\t\tif (S[i] == '1') ss[i] = ss[i-1] + 1;\n\t\telse ss[i] = ss[i-1];\n\t}\n\tmem(dp,-1);\n\t\n\tcout<<dpf(0,A[0],qry(pi(0,A[0])));\n\t\n\t\n\t\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 301\n#define MOD 1000000007\n#define int ll\nint N,M;\nstring S;\n\nint A[maxn];\n\nint dp[maxn][maxn][maxn];\nint ss[maxn];\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\n\n\ninline int qry(pi i){\n\tif (i.f == 0) return ss[i.s];\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint dpf(int i,int j,int k){\n\t//cout<<i<<' '<<j<<' '<<k<<'\\n';\n\tif (dp[i][j][k] != -1) return dp[i][j][k];\n\tif (k > sz(pi(i,j))) return 0;\n\tif (i == N) return 1;\n\t\n\tif (k < 0) return 0;\n\t\n\tif (A[i] > j){\n\t\tk += qry(pi(j + 1, A[i]));\n\t\tj = A[i];\n\t}\n\t\n\n\n\tif (k > 0) return dp[i][j][k] = (dpf(i+1,j,k-1) + dpf(i+1,j,k)) % MOD;\n\telse return dp[i][j][k] = dpf(i+1,j,k);\n}\n\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\tFOR(i,0,N-1) A[i] = i;\n\t\n\tDEC(i,M-1,0){\n\t\tA[st.top().f - 1] = st.top().s - 1;\n\t\tst.pop();\n\t}\n\t\n\tif (S[0] == '1') ss[0] = 1;\n\telse ss[0] = 0;\n\t\n\tFOR(i,1,N-1){\n\t\tif (S[i] == '1') ss[i] = ss[i-1] + 1;\n\t\telse ss[i] = ss[i-1];\n\t}\n\tmem(dp,-1);\n\t\n\tcout<<dpf(0,A[0],qry(pi(0,A[0])));\n\t\n\t\n\t\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\nint dp[3002][3002], sum[3002];\nint R[3002];\nchar s[3002];\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", s+1);\n    for(int i=1;i<=n;i++){\n        if(s[i] == '1') sum[i]++;\n        sum[i] += sum[i-1];\n        R[i] = i;\n    }\n    for(int i=1;i<=m;i++){\n        int l, r;\n        scanf(\"%d%d\", &l, &r);\n        R[l] = max(R[l], r);\n    }\n    dp[1][0] = 1;\n    int last = 0;\n    for(int i=1;i<=n;i++){\n        int add = 0;\n        if(R[i] > last) add += sum[R[i]] - sum[last];\n        last = max(last, R[i]);\n        for(int j=0;j<=n;j++){\n            if(dp[i][j] == 0) continue;\n\n            int one = j + add;\n            int zero = last-i+1 - one;\n\n            if(one > 0){\n                dp[i+1][one-1] = (dp[i+1][one-1] + dp[i][j])%mod;\n            }\n            if(zero > 0){\n                dp[i+1][one] = (dp[i+1][one] + dp[i][j])%mod;\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int N=3e3+2;\nconst int mod=1e9+7;\nint sum[N],dp[N],max1[N],dp1[N];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,m,now=0;\n\tstring s;\n\tcin>>n>>m>>s;\n\ts=' '+s;\n\tfor(i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1];\n\t\tif(s[i]=='1'){\n\t\t\tsum[i]++;\n\t\t}\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tcin>>j>>k;\n\t\tmax1[j]=max(max1[j],k);\n\t}\n\tdp[0]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(max1[i]){\n\t\t\tnow=max(now,max1[i]);\n\t\t}\n\t\tnow=max(now,i);\n\t\tfor(j=0;j<=min(sum[now],i);j++){\n\t\t\tif(j){\n\t\t\t\tdp1[j]=dp[j-1];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp1[j]=0;\n\t\t\t}\n\t\t\tif(i-j<=now-sum[now]){\n\t\t\t\tdp1[j]+=dp[j];\n\t\t\t\tif(dp1[j]>=mod){\n\t\t\t\t\tdp1[j]-=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<=sum[now];j++){\n\t\t\tdp[j]=dp1[j];\n\t\t}\n\t}\n\tcout<<dp[sum[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  /*bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };*/\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[3331][3333];\nint l[3331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[3331];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v[2];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(int n,int m)\n{\n  if(n>a) return 1;\n  //if(m>u[l[n]].y-n+1) return 0;\n  if(o[n][m]>=0) return o[n][m];\n  if(l[n]==0) return f(n+1,m);\n  long long k=0;\n  if(l[n+1]==0)\n  {\n    k=f(n+1,m);\n  }\n  else if(l[n+1]!=l[n])\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m+j[u[l[n+1]].y]-j[u[l[n]].y]);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1+j[u[l[n+1]].y]-j[u[l[n]].y]))%mod;\n  }\n  else\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1))%mod;\n  }\n  return o[n][m]=k;\n}\n\nint main()\n{\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  scanf(\"%s\",r+1);\n  for(int t=1;t<=a;j[t]+=j[t-1],t++)\n  if(r[t]=='1') j[t]=1;\n  for(int t=1;t<=b;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    if(u[c].x==n) u[c].y=max(u[c].y,m);\n    else if(u[c].y<m)\n    {\n      c++;\n      u[c]={n,m};\n    }\n  }\n  u[0].x=1;\n  for(int t=1;t<=c;t++)\n  {\n    for(int i=u[t].x;i<=u[t].y;i++)\n      l[i]=t;\n  }\n  printf(\"%lld\",f(u[1].x,j[u[1].y]-j[u[1].x-1]));\n}\n//3\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n// }}}\n// pre-written code {{{\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n//#define PB push_back\n#define CLEAR(c,d) memset((c),(d),sizeof(c))\n#define TO_STRING(VariableName) # VariableName\n//#define DB(c) cout<<TO_STRING(c)<<\"=\"<<(c)<<endl\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug2(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define clr(a) memset((a),0,sizeof(a))\n#define nclr(a) memset((a),-1,sizeof(a))\n#define pb push_back\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntypedef pair<int,int> pii;\n//{{{ io\nstruct IO{ }io;//dummy\n#define endl \"\\n\"\nIO& operator>>(IO &io,int &n){scanf(\"%d\",&n);return io;}\nIO& operator>>(IO &io,unsigned int &n){scanf(\"%u\",&n);return io;}\nIO& operator>>(IO &io,long long &n){scanf(\"%lld\",&n);return io;}\nIO& operator>>(IO &io,unsigned long long &n){scanf(\"%llu\",&n);return io;}\nIO& operator>>(IO &io,double &n){scanf(\"%lf\",&n);return io;}\nIO& operator>>(IO &io,long double &n){scanf(\"%Lf\",&n);return io;}\nIO& operator>>(IO &io,char *c){scanf(\"%s\",c);return io;}\nIO& operator>>(IO &io,string &s){\n    char c;s.clear();\n    while(isspace(c=getc(stdin))){if(c==-1)return io;}\n    do{\n        s.push_back(c);\n    }while(!isspace(c=getc(stdin)));\n    if(c!=-1)ungetc(c,stdin);\n    return io;\n}\nIO& operator<<(IO &io,const int &n){printf(\"%d\",n);return io;}\nIO& operator<<(IO &io,const unsigned int &n){printf(\"%u\",n);return io;}\nIO& operator<<(IO &io,const long long &n){printf(\"%lld\",n);return io;}\nIO& operator<<(IO &io,const unsigned long long &n){printf(\"%llu\",n);return io;}\nIO& operator<<(IO &io,const double &n){printf(\"%lf\",n);return io;}\nIO& operator<<(IO &io,const long double &n){printf(\"%Lf\",n);return io;}\nIO& operator<<(IO &io,const char c[]){printf(\"%s\",c);return io;}\nIO& operator<<(IO &io,const string &s){\n    REP(i,s.size())putc(s[i],stdout);\n}\n//}}}\n// }}}\n\nconst int mod = 1000000007;\n\nint N,M;\nstring S;\nint zero_ct[3005], one_ct[3005];\nvector<pair<int,int> > p;\n\nint dp[3005][3005];\n\nint main(){\n\tcin>>N>>M;\n\tcin>>S;\n\tassert(N==S.size());\n\tint o=0,z=0;\n\tREP(i,N){\n\t\tzero_ct[i] = z;\n\t\tone_ct[i] = o;\n//\t\tcout<<one_ct[i]<<\" \";\n\t\tif(S[i]=='1')o++;\n\t\telse z++;\n\t}\n\tzero_ct[N] = z;\n\tone_ct[N] = o;\n//\tcout<<one_ct[N]<<endl;\n\n\tint right = 0;\n\tREP(i,M){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tl--;\n\t\tif(r<=right)continue;\n\t\tp.push_back(make_pair(l,r));\n\t\tright = r;\n\t\t//\t\tcout<<l<<\" \"<<r<<endl;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tREP(j,S.size()+1){\n\t\tdp[0][j] = (j==0)?1:0;\n\t}\n\tREP(i,N){\n\t\tint j=0;\n\t\tREP(k,S.size()+1){\n\t\t\twhile(1){\n\t\t\t\tint j2 = j+1;\n\t\t\t\tif(j2<p.size() and p[j2].first<=i)j=j2;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\t// decide dp[i+1][k]\n\t\t\tint num_zero = i-k;\n\t\t\tif(num_zero<0){\n//\t\t\t\tdp[i+1][k] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool zero = false, one = false;\n\t\t\tif(i<p[j].first or p[j].second<=i){\n\t\t\t\tif(S[i]=='0')zero = true;\n\t\t\t\telse one = true;\n\t\t\t}else{\n\t\t\t\tif(num_zero<zero_ct[p[j].second])zero = true;\n\t\t\t\tif(k<one_ct[p[j].second])one = true;\n\t\t\t}\n\t\t\tif(zero){\n//\t\t\t\tif(i==3)cout<<\"zero: \"<<i<<\" \"<<k<<\" \"<<dp[i][k]<<endl;\n\t\t\t\tdp[i+1][k] += dp[i][k];\n\t\t\t\tif(dp[i+1][k]>=mod)dp[i+1][k]-=mod;\n\t\t\t}\n\t\t\tif(one){\n//\t\t\t\tif(i==3)cout<<\"one: \"<<i<<\" \"<<k<<endl;\n\t\t\t\tdp[i+1][k+1] += dp[i][k];\n\t\t\t\tif(dp[i+1][k+1]>=mod)dp[i+1][k+1]-=mod;\n\t\t\t}\n//\t\t\tcout<<dp[i+1][k]<<\" \";\n\t\t}\n//\t\tcout<<endl;\n\t}\n\tcout<<dp[N][one_ct[N]]<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    ModInt operator-(const ModInt &r) const {return make(normS(v+MD-r.v));}\n    ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\nconst int MN = 3030;\nint co;\nint A[MN], B[MN];\n\nMint calc(int n, int b);\n//calc sm\nMint casm(int n, int b) {\n  static Mint dp[MN][MN];\n  static bool used[MN][MN];\n  if (b == MN-4) return 0;\n  if (used[n][b]) return dp[n][b];\n  used[n][b] = true;\n  Mint &ans = dp[n][b];\n  ans = calc(n, b) + casm(n, b+1);\n  return ans;\n}\n\nMint calc(int n, int b) {\n  static Mint dp[MN][MN];\n  static bool used[MN][MN];\n  if (n == co) return 1;\n  if (used[n][b]) return dp[n][b];\n  used[n][b] = true;\n  Mint &ans = dp[n][b]; ans = 0;\n/*  for (int i = max(A[n], b); i < B[n]; i++) {\n    ans += calc(n+1, i+1);\n  }*/\n  int l = max(A[n], b), r = B[n];\n  if (r <= l) return ans;\n  ans = casm(n+1, l+1) - casm(n+1, r+1);\n  return ans;\n}\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  string t = s;\n  for (int i = 0; i < m; i++) {\n    int l, r;\n    cin >> l >> r; l--;\n    sort(s.begin()+l, s.begin()+r);\n    sort(t.begin()+l, t.begin()+r, greater<char>());\n  }\n  co = 0;\n  for (int i = 0; i < n; i++) {\n    if (t[i] == '0')continue;\n    A[co++] = i;\n  }\n  co = 0;\n  for (int i = 0; i < n; i++) {\n    if (s[i] == '0') continue;\n    B[co++] = i+1;\n  }\n/*  cout << co << endl;\n  for (int i = 0; i < co; i++) {\n    cout << A[i] << \" \" << B[i] << endl;\n  }*/\n  cout << calc(0, 0).v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = (1e+9)+7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint mi[3000]; int ma[3000];\nll dp[3001][3002] = {};\nint main() {\n\tint n, m; string s; cin >> n >> m >> s;\n\tstring t1 = s; string t2 = s;\n\tint cnt = 0;\n\trep(i, m) {\n\t\tint l; int r;\n\t\tcin >> l >> r; l--; r--;\n\t\tint cnt1 = 0; int cnt2 = 0;\n\t\tRep1(j, l, r) {\n\t\t\tif (t1[j] == '1')cnt1++;\n\t\t\tif (t2[j] == '0')cnt2++;\n\t\t}\n\t\tRep1(j, l, r) {\n\t\t\tif (j < l + cnt1) {\n\t\t\t\tt1[j] = '1';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt1[j] = '0';\n\t\t\t}\n\t\t\tif (j < l + cnt2) {\n\t\t\t\tt2[j] = '0';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt2[j] = '1';\n\t\t\t}\n\t\t}\n\t}\n\tint cnt1 = 0; int cnt2 = 0;\n\trep(i, n) {\n\t\tif (s[i] == '1')cnt++;\n\t\tif (t1[i] == '1')cnt1++;\n\t\tif (t2[i] == '1')cnt2++;\n\t\tmi[i] = cnt2; ma[i] = cnt1;\n\t}\n\trep(i, n) {\n\t\tif (i == 0) {\n\t\t\tif (mi[i] == 0)dp[0][0] = 1;\n\t\t\tif (ma[i] == 1)dp[0][1] = 1;\n\t\t}\n\t\telse {\n\t\t\trep(j, 3001) {\n\t\t\t\tif (mi[i - 1] <= j && j <= ma[i - 1] && mi[i] <= j && j <= ma[i]) {\n\t\t\t\t\t(dp[i][j] += dp[i - 1][j]) %= MOD;\n\t\t\t\t}\n\t\t\t\tif (mi[i - 1] <= j - 1 && j - 1 <= ma[i - 1] && mi[i] <= j && j <= ma[i]) {\n\t\t\t\t\t(dp[i][j] += dp[i - 1][j - 1]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n-1][cnt] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=3010;\nconst int yql=1e9+7;\nusing namespace std;\nint a[N],dp[N][N],n,m,s[N];\nchar p[N];\ninline int read(){\n\tint f=1,x=0;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn f*x;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\"%s\",p+1);\n\tfor(int i=1;i<=n;i++){a[i]=i;s[i]=s[i-1];if(p[i]=='1')s[i]++;}\n\tfor(int i=1;i<=n;i++)printf(\"%d%c\",s[i],i==n?'\\n':' ');\n\tfor(int i=1;i<=m;i++){\n\t\tint l=read(),r=read();\n\t\tfor(int j=l;j<=r;j++)a[j]=max(a[j],r);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j>s[a[i]])continue;\n\t\t\tif(i-j>a[i]-s[a[i]])continue;\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%yql;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][s[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int mi=INT_MAX,ma=0;\n        rep2(j,prel,prer){\n            int l = max((int)j,x-y+a[y]);\n            int r = min((int)j+x-v[i].fi+1,a[y]);\n            chmin(mi,l);chmax(ma,r);\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=mi,prer=ma;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod = 1000000007;\n\nint main () {\n  \n  vector<long long> kai(3030);\n  vector<long long> gkai(3030);\n  long long bk = 1;\n  long long bkt;\n  long long bkmod;\n  for (int i=1; i<3030; i++) {\n    bk *= i;\n    bk %= mod;\n    kai[i] = bk;\n    bkmod = bk;\n    for (int i=0; i<9; i++) {\n      bkt = bkmod;\n      for (int j=0; j<9; j++) {\n        bkmod *= bkt;\n        bkmod %= mod;\n      }\n    }\n    for (int i=0; i<5; i++) {\n      bkmod *= bk;\n      bkmod %= mod;\n    }\n    gkai[i] = bkmod;\n  }\n  kai[0] = kai[1];\n  gkai[0] = gkai[1];\n  \n  int N,M;\n  string S;\n  cin >> N >> M >> S;\n  vector<long long> l(M+1,N+1),r(M+1,N+1);\n  for (int i=0; i<M; i++) {\n    cin >> l[i] >> r[i];\n    if (i >= 1) {\n      if (l[i] == l[i-1]) {\n        l[i-1] = -1;\n        r[i] = max(r[i],r[i-1]);\n      }\n    }\n  }\n  vector<int> n1(N+1,0);\n  for (int i=0; i<N; i++) {\n    if (S[i] == '1') {\n      n1[i+1] = n1[i] + 1;\n    }\n    else {\n      n1[i+1] = n1[i];\n    }\n  }\n  long long L=0;\n  long long R=0;\n  long long com;\n  vector<vector<long long>> dp(N+1,vector<long long>(N+1,0));\n  for (int i=0; i<M+1; i++) {\n    if (l[i] == -1) {\n      continue;\n    }\n    if(L == 0) {\n      dp[l[i]-1][n1[l[i]-1]] = 1;\n      L = l[i];\n      R = r[i];\n      continue;\n    }\n    if (R < l[i]) {\n      for (int j=n1[R]-(R-L+1); j<n1[R]+1; j++) {\n        if (j<0) continue;\n        com = kai[R-L+1] * gkai[n1[R]-j] % mod * gkai[(R-L+1)-(n1[R]-j)] % mod;\n        dp[l[i]-1][n1[l[i]-1]] += dp[L-1][j] * com % mod;\n      }\n      dp[l[i]-1][n1[l[i]-1]] %= mod;\n      L = l[i];\n      R = r[i];\n      continue;\n    }\n    for (int j=n1[R]-(R-l[i]+1); j<n1[R]+1; j++) {\n      for (int k=0; k<=l[i]-L; k++) {\n        if (j-k < 0) continue;\n        com = kai[l[i]-L] * gkai[k] % mod * gkai[l[i]-L-k] % mod;\n        dp[l[i]-1][j] += dp[L-1][j-k] * com % mod;\n      }\n      dp[l[i]-1][j] %= mod;\n    }\n    L = l[i];\n    R = max(r[i],R);\n  }\n  cout << dp[N][n1[N]] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\nll dp[3001][3001];\nstring str;\nint nex[3001];\nint cnt[3001];\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tcin >> str;\n\tfor(int i=0;i<n;i++){\n\t\tcnt[i+1]+=cnt[i];\n\t\tif(str[i]=='1')cnt[i+1]++;\n\t}\n\tmemset(nex,-1,sizeof(nex));\n\tfor(int i=0;i<m;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tl--;\n\t\tnex[l]=max(nex[l],r);\n\t}\n\tdp[0][0]=1;\n\tint r=-1;\n\tfor(int i=0;i<n;i++){\n\t\tr=max(nex[i],r);\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(r<=i){\n\t\t\t\tif(str[i]=='0'){\n\t\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%MOD;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(j<cnt[r]){\n\t\t\t\t\tdp[i+1][j+1]=(dp[i+1][j+1]+dp[i][j])%MOD;\n\t\t\t\t}\n\t\t\t\tif(i-j<r-cnt[r]){\n\t\t\t\t\tdp[i+1][j]=(dp[i+1][j]+dp[i][j])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][cnt[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nchar s[N+9];\nint n,nxt[N+9];\n\nvoid into(){\n  int m;\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1);\n  for (int i=1;i<=m;++i){\n\tint l,r;\n\tscanf(\"%d%d\",&l,&r);\n\tnxt[l]=max(nxt[l],r);\n  }\n}\n\nint a[N+9];\n\nvoid Get_a(){\n  for (int i=1;i<=n;++i) a[i]=s[i]-'0'+a[i-1];\n  a[n+1]=a[n];\n}\n\nvoid Get_nxt(){\n  for (int i=1;i<=n+1;++i){\n\tif (!nxt[i]) nxt[i]=i;\n\tnxt[i]=max(nxt[i],nxt[i-1]);\n  }\n}\n\nint dp[N+9][N+9];\n\nvoid Get_dp(){\n  dp[1][a[nxt[1]]]=1;\n  for (int i=1;i<=n;++i)\n\tfor (int j=0;j<=n;++j){\n\t  if (!dp[i][j]) continue;\n\t  int l=nxt[i],r=nxt[i+1],c0=nxt[i]-i+1-j,c1=j;\n\t  if (c1) sadd(dp[i+1][j+a[r]-a[l]-1],dp[i][j]);\n\t  if (c0) sadd(dp[i+1][j+a[r]-a[l]],dp[i][j]);\n\t}\n}\n\nvoid work(){\n  Get_a();\n  Get_nxt();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",dp[n+1][0]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define endl '\\n'\n#define f first\n#define s second\n\n#ifdef SEREZHKA\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T>\nvoid _dbg(const char* _s, T _h) { cerr << _s << \" = \" << _h << \"\\n\"; }\n\ntemplate<typename T, typename... Ts>\nvoid _dbg(const char*_s, T _h, Ts... _t) {\n    int _b = 0;\n    \n    while (((_b += *_s == '(') -= *_s == ')') != 0 || *_s != ',')\n        cerr << *_s++;\n    \n    cerr << \" = \" << _h << \",\";\n    _dbg(_s + 1, _t...);\n}\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7ll;\nconst ll LINF = INF * INF;\nconst int MAXN = static_cast<int>(3e3) + 17;\n\nint n, m;\nstring s;\nint R[MAXN];\nint S[MAXN];\nll binomial[MAXN][MAXN], dp[MAXN][MAXN];\n\nbool read() {\n    if (!(cin >> n >> m >> s))\n        return false;\n\n    forn (i, m) {\n        int l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n\n    return true;\n}\n\nll add(ll a, ll b) { return (a += b) >= INF ? a - INF : a; }\n\nll dfs(int i, int cnt, const vector< pair<int, int> >& v) {\n    if (i == sz(v) - 1)\n        return binomial[v[i].s - v[i].f + 1][cnt];\n\n    ll res = 0;\n    \n    for (int k = 0; k <= cnt; ++k)\n        if (k <= v[i + 1].f - v[i].f && cnt - k <= v[i].s - v[i + 1].f + 1)\n            res = add(res, dfs(i + 1, cnt - k + S[v[i + 1].s] - S[v[i].s], v) * binomial[v[i + 1].f - v[i].f][k] % INF);\n\n    return res;\n}\n\nvoid solve() {\n    forn (i, n)\n        S[i + 1] = s[i] - '0';\n\n    forn (i, n)\n        S[i + 1] += S[i];\n\n    binomial[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            binomial[i][j] = add(binomial[i - 1][j], j ? binomial[i - 1][j - 1] : 0ll);\n\n    ll ans = 1ll;\n\n    for (int l = 1; l <= n; ) {\n        if (R[l] == 0) {\n            ++l;\n            continue;\n        }\n\n        int l1 = l, mxr = l1;\n        vector< pair<int, int> > vec;\n\n        for (; l1 <= mxr; ++l1)\n            if (R[l1] > mxr) {\n                mxr = R[l1];\n                vec.pb(mp(l1, R[l1]));\n            }\n\n        ans = ans * dfs(0, S[vec[0].s] - S[vec[0].f - 1], vec);\n        l = l1;\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    \n    while (read())\n        solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        rep2(j,prel,prer){\n            int l = max((int)j,x-y+a[y]);\n            int r = min((int)j+x-v[i].fi+1,a[y]);\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3005, MOD = 1e9 + 7;\n\nint n, m, r[N], rightend[N], cnt1[N], f[N][N];\nstring s;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n  cin >> n >> m >> s;\n  int curl, curr;\n  cin >> curl >> curr;\n  for (int i = 2, nxl, nxr; i <= m; ++i) {\n    cin >> nxl >> nxr;\n    if (nxl == curl) curr = max(curr, nxr);\n    else if (nxr > curr) {\n      r[curl] = curr;\n      curl = nxl;\n      curr = nxr;\n    }\n  }\n  r[curl] = curr;\n  for (int i = 1; i <= n; ++i) {\n    cnt1[i] = cnt1[i - 1] + (s[i - 1] == '1');\n    rightend[i] = max(rightend[i - 1], r[i - 1]);\n    r[i] = max({rightend[i], r[i], i});\n  }\n  f[0][0] = 1;\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      if (f[i][j] == 0) continue;\n      int one = j + ((rightend[i] < r[i]) ? (cnt1[r[i]] - cnt1[rightend[i]]) : 0);\n      if (one) (f[i + 1][one - 1] += f[i][j]) %= MOD;\n      if (r[i] - i + 1 > one) (f[i + 1][one] += f[i][j]) %= MOD;\n    }\n  }\n  cout << f[n + 1][0];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i];\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint pl=0,pr=0;\n\t\t\trep(i,m) if(pl<ls[i]&&pr<rs[i]){\n\t\t\t\tts.emplace_back(ls[i]-1,rs[i]);\n\t\t\t\ttie(pl,pr)=mt(ls[i],rs[i]);\n\t\t\t}\n\t\t\tint l0=get<0>(ts[0]);\n\t\t\ts=s.substr(l0);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=l0,rs[i]-=l0;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['0'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m)\n\t\t\trepi(i,ls[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pii pair<int,int>\n#define pb push_back\n#define right ri\nconst int maxn = 3000 + 5;\nconst int mod = 1e9 + 7;\nll dp[maxn][maxn] , right[maxn] , sum[maxn] , d[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    int n, m; cin >> n >> m;\n    string a; cin >> a;\n    for (int i = 1 ; i <= n + 1; i++) right[i] = i , sum[i] = sum[i - 1] + (a[i - 1] == '1');\n    for (int i = 1 ; i <= m ; i++){\n        ll l , r; cin >> l >> r;\n        right[l] = max (right[l] , r);\n    }\n    for (int i = 1 ; i <= n ; i++) {\n        right[i] = max (right[i - 1] , right[i]);\n        d[i] = sum[right[i]] - sum[right[i - 1]];\n    }\n    dp[1][d[1]] = 1;\n    for (int i = 1 ; i <= n ; i++){\n        for (int j = 0 ; j <= n ; j++){\n            if (dp[i][j]){\n                int l = right[i] + 1 , r = right[i + 1];\n                if (j) (dp[i+1][j-1+sum[r]-sum[l-1]]+=dp[i][j])%=mod;\n                if (right[i] - i + 1 - j) (dp[i+1][j+sum[r]-sum[l-1]]+=dp[i][j])%=mod;\n            }\n         /*   if (dp[i][j]){\n                if (j) dp[i + 1][j + d[i + 1] - 1] = (dp[i + 1][j + d[i + 1]] + dp[i][j]) % mod;\n                if (right[i] - i + 1 - j) dp[i + 1][j + d[i + 1]] = (dp[i + 1][j + d[i + 1]] + dp[i][j]) % mod;\n            }*/\n        }\n    }\n    cout << dp[n + 1][0] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e3+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nchar s[N];\nint n,m,f[N][N],R[N],sum[N][2];\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint main() {\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1),n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) {\n\t\tR[i]=i;\n\t\tsum[i][0]=sum[i-1][0];\n\t\tsum[i][1]=sum[i-1][1];\n\t\t++sum[i][s[i]-'0'];\n\t}\n\tfor(int i=1,l,r;i<=m;i++) l=gi(),r=gi(),R[l]=max(R[l],r);\n\tfor(int i=2;i<=n;i++) R[i]=max(R[i],R[i-1]);\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<=i;j++) {\n\t\t\tif(!f[i][j]) continue;\n\t\t\tif(j<sum[R[i+1]][0]) inc(f[i+1][j+1],f[i][j]);\n\t\t\tif(i-j<sum[R[i+1]][1]) inc(f[i+1][j],f[i][j]);\n\t\t}\n\tcout<<f[n][sum[n][0]];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint const MOD=1000000007;\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n,n_operation;std::cin>>n>>n_operation;\n\n\tstd::vector<int> acm;acm.reserve(n+1);acm.resize(n); // suffix sum accumulation\n\tfor(int& x:acm){\n\t\tchar c;std::cin>>c;\n\t\tx=c-'0';\n\t}\n\tfor(int i=n-1;i--;)\n\t\tacm[i]+=acm[i+1];\n\tacm.push_back(0);\n\n\tauto const sum=[&](int l,int r){return acm[l]-acm[r];};\n\n\n\tstd::vector<std::pair<int,int>> ops;ops.reserve(n_operation+1);\n\tfor(int _=n_operation;_--;){\n\t\tint l,r;std::cin>>l>>r;--l;\n\t\tif(!ops.empty()){\n\t\t\tif(ops.back().first==l){\n\t\t\t\tops.back().second=std::max(ops.back().second,r);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(ops.back().second>=r)\n\t\t\t\tcontinue;\n\t\t}\n\t\tops.push_back({l,r});\n\t}\n\n\tops.push_back({n,n});\n\n\tn_operation=-1;\n\n\tauto const l=[&](int x){return ops[x].first;};\n\tauto const r=[&](int x){return ops[x].second;};\n\n\tstd::vector<std::vector<int>> dp(ops.size());\n\t// dp[i][n] = number of states of the sequence [0,l(i)] after i steps with sum n\n\n\tdp[0].resize(n+1);\n\tdp[0][sum(0,l(0))]=1;\n\n\n\tstd::vector<std::vector<int>> binom(n+1);\n\tbinom[0].assign(1,1);\n\tfor(unsigned i=1;i<binom.size();++i){\n\t\tbinom[i].resize(i+1);\n\t\tstd::copy(begin(binom[i-1]),end(binom[i-1]),begin(binom[i]));\n\t\tstd::transform(begin(binom[i-1]),end(binom[i-1]),++begin(binom[i]),++begin(binom[i]),[](int a,int b){\n\t\t\t\ta+=b;\n\t\t\t\tif(a>=MOD)a-=b;\n\t\t\t\treturn a;\n\t\t\t\t});\n\t}\n\n\n\tfor(int i=1;i<(int)ops.size();++i){\n\t\tdp[i].resize(n+1);\n\t\tfor(int x=0;x<=n;++x){\n\t\t\t// x = sum [0,l(i)] after i steps\n\n\t\t\tint ans=0;\n\t\t\tfor(int y=0;y<=x;++y){\n\t\t\t\t// y = sum [0,l(i-1)] after >= i-1 steps\n\t\t\t\t// then perform permutation of l(i-1) .. r(i-1) (after i-1 steps there are\n\t\t\t\t// sum(0,r(i-1))-y   ones in the range and  y  ones before)\n\t\t\t\t// such that there are x ones before l(i) <-> x-y ones int  l(i-1) .. l(i)\n\n\t\t\t\tint const cntrange=sum(0,r(i-1))-y; // range l..r (i-1)\n\n\t\t\t\tint mid=l(i);\n\t\t\t\tint midcnt=x-y; // desired cnt int l(i-1) .. mid\n\t\t\t\tif(mid>r(i-1)){\n\t\t\t\t\tmidcnt-=sum(r(i-1),mid);\n\t\t\t\t\tmid=r(i-1);\n\t\t\t\t}\n\n\t\t\t\t// need to count number of seq [l(i-1) .. mid] with midcnt ones\n\t\t\t\tif(midcnt<=cntrange&& midcnt<=mid-l(i-1) && cntrange-midcnt<=r(i-1)-mid)\n\t\t\t\t\tans=(ans+(int64_t)dp[i-1][y]*binom[mid-l(i-1)][midcnt])%MOD;\n\t\t\t}\n\t\t\tdp[i][x]=ans;\n\t\t}\n\t}\n\n\tstd::cout<<dp[ops.size()-1][sum(0,n)]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] += x;\n    while(k>0) k = (k-1)/2, dat[k] = dat[k*2+1] + dat[k*2+2];\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return A + B;\n  }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, m;std::cin >> n >> m;\n  vvl dp = VV(n+1, n+1, 0, ll);\n  string s;std::cin >> s;\n  segtree b(n+1, 0);\n  for(int i=0;i<n;i++) b.update((s[i]=='1'), i);\n  dp[0][0] = 1;\n  vvl d;\n  ll r = -1;\n\n  for(int i=0;i<m;i++){\n    ll x, y;std::cin >> x >> y;\n    x--, y--;\n    if(r >= y) continue;\n    r = y;\n    if(d.size()&&d[d.size()-1][0]==x){\n      d[d.size()-1][1] = r;\n    }else{\n      d.push_back(vll{x, y});\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    auto itr = upper_bound(all(d), vll{i, -1});\n    ll r;\n    if(itr==d.begin()) r = i-1;\n    else {\n      r = (*--itr)[1];\n      if(r < i) r = i-1;\n    }\n\n    ll sa = r - i + 1;\n    itr = upper_bound(all(d), vll{i, 100000});\n    ll ad = 0;\n    if(itr!=d.begin()){\n      itr--;\n      if((*itr)[0]==i){\n        ad = b.query(r+1, (*itr)[1]+1);\n        sa = (*itr)[1] - i + 1;\n      }\n    }\n    if(sa==0){\n      dp[i+1] = dp[i];\n    }else{\n      for(int j=0;j<=n;j++){\n        ll one = j + ad;\n        if(one>n || sa < one) continue;\n        ll zero = sa - one;\n        if(one) dp[i+1][one-1] = (dp[i+1][one-1] + dp[i][j])%P;\n        if(zero) dp[i+1][one] = (dp[i+1][one] + dp[i][j])%P;\n      }\n    }\n  }\n  std::cout << dp[n][0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint n, m, l[3009], r[3009], p[3009], dp[3009][3009], R, s[3009], t[3009], mod = 1000000007; bool used[3009]; string S;\nint main() {\n\tcin >> n >> m >> S; S = \"#\" + S;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (R >= r[i])continue;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (l[j] == l[i])used[j] = false;\n\t\t}\n\t\tR = r[i]; used[i] = true;\n\t}\n\tfor (int i = 0; i <= n; i++) { s[i] = -1; t[i] = 1e9; }\n\tint V = 1, W = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (used[i] == false)continue;\n\t\tif (W < l[i]) V = l[i];\n\t\tint cnt = 0, u = 0; for (int j = 1; j < V; j++)cnt += (S[j] - '0');\n\t\tfor (int j = V; j <= W; j++)u += (S[j] - '0');\n\t\ts[l[i] - 1] = cnt + max(0, (l[i] - V) - max(0, ((W - V + 1) - u)));\n\t\tt[l[i] - 1] = cnt + min(l[i] - V, u);\n\t\tW = r[i];\n\t}\n\tint X = 0; for (int i = 1; i <= n; i++)X += (S[i] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (!(s[i] <= j && j <= t[i])) { dp[i][j] = 0; continue; }\n\t\t\tdp[i + 1][j] += dp[i][j]; dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t}\n\t}\n\tcout << dp[n][X] % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nlong long max(long long x, long long y){return (x > y ? x : y);}\nlong long min(long long x, long long y){return (x < y ? x : y);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=3200;\nconst ll inf=1e9+800;\nconst ll mod=1e9+7;\n\npii a[maxn];\nll n,m;\nll ent[maxn][maxn];\nll dp[maxn][maxn];\nll par[maxn];\n\nvoid comperess(){\n\tfor(ll i=0;i<m;i++){\n\t\ta[i].S*=-1;\n\t}\n\tsort(a,a+m);\n\tfor(ll i=0;i<m;i++){\n\t\ta[i].S*=-1;\n\t}\n\tvector<pii> vec;\n\tfor(ll i=0;i<m;i++){\n\t\tif(i==0 || a[i-1].S<a[i].S){\n\t\t\tvec.pb(a[i]);\n\t\t}\n\t}\n\tfor(ll i=0;i<vec.size();i++){\n\t\ta[i]=vec[i];\n\t}\n\tm=vec.size();\n}\nbool f(char c){\n\treturn c-'0';\n}\nll find_par(ll l,ll r){\n\tif(l==0){\n\t\treturn par[r];\n\t}\t\n\treturn par[r]-par[l-1];\n}\nll find_par(ll l){\n\treturn find_par(a[l].F,a[l].S);\n}\nll tol(ll l,ll r){\n\treturn r-l+1;\n}\nll tol(ll i){\n\treturn a[i].S-a[i].F+1;\n}\n\n\nint main(){\n\tent[0][0]=1;\n\tfor(ll i=1;i<maxn;i++){\n\t\tent[i][0]=1;\n\t\tent[i][i]=1;\n\t\tfor(ll j=1;j<i;j++){\n\t\t\tent[i][j]=(ent[i-1][j]+ent[i-1][j-1])%mod;\n\t\t}\n\t}\n\n\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\t\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tpar[0]=f(s[0]);\n\tfor(ll i=1;i<n;i++){\n\t\tpar[i]=(par[i-1]+f(s[i]));\n\t}\n\tfor(ll i=0;i<m;i++){\n\t\tcin>>a[i].F>>a[i].S;\n\t\ta[i].F--;\n\t\ta[i].S--;\n\t}\n\tcomperess();\n\tfor(ll i=0;i<=tol(m-1);i++){\n\t\tdp[m-1][i]=ent[tol(m-1)][i];\n\t}\n\tfor(ll i=m-2;i>=0;i--){\n\t\tif(a[i].S<a[i+1].F){\n\t\t\tfor(ll j=0;j<=tol(i);j++){\n\t\t\t\tdp[i][j]=(ent[tol(i)][j]*dp[i+1][find_par(i+1)])%mod;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(ll j=0;j<=tol(i);j++){\n\t\t\t\tll CTE=find_par(a[i].S+1,a[i+1].S);\n\t\t\t\tll TOL=tol(a[i].F,a[i+1].F-1);\n\t\t\t\tll Tol=tol(a[i+1].F,a[i].S);\n\t\t\t\tfor(ll k=max(0LL,j-Tol);k<=min(TOL,j);k++){\n\t\t\t\t\tdp[i][j]+=(ent[TOL][k]*dp[i+1][j-k+CTE])%mod;\n\t\t\t\t}\n\t\t\t\tdp[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][find_par(a[0].F,a[0].S)];\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1'000'000'007, maxn = 10000;\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint pwr(long long a, long long b){\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nint fat[maxn], ifat[maxn];\nvoid init(){\n\tfat[0] = 1;\n\tfor(int i = 1; i < maxn; i++) fat[i] = mul(i, fat[i - 1]);\n\tifat[maxn - 1] = pwr(fat[maxn - 1], mod - 2);\n\tfor(int i = maxn - 2; i >= 0; i--) ifat[i] = mul(i + 1, ifat[i + 1]);\n\tfor(int i = 0; i < maxn; i++) assert(mul(fat[i], ifat[i]) == 1);\n}\nint ncr(int n, int r){\n\tif(n < r) return 0;\n\treturn mul(fat[n], mul(ifat[r], ifat[n - r]));\n}\nusing ii = pair<int,int>;\nusing ti = tuple<int,int,int>;\nint main(){\n\tinit();\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tvector<int> pref(n + 1, 0);\n\tfor(int i = 0; i < n; i++) pref[i + 1] = pref[i] + (s[i] == '1');\n\tvector<ii> I;\n\tauto contains = [](ii a, ii b){\n\t\treturn a.first <= b.first && b.second <= a.second;\n\t};\n\tauto count_ones = [&](int l, int r){\n\t\treturn pref[r + 1] - pref[l];\n\t};\n\tint ans = 1;\n\tauto propagate = [&](){\n\t\tint len = I.size();\n\t\tfor(int i = 0; i < len - 1; i++) assert(I[i].first <= I[i + 1].first && I[i].second <= I[i + 1].second);\n\t\tif(len == 1){\n\t\t\tans = mul(ans, ncr(I[0].second - I[0].first + 1, count_ones(I[0].first, I[0].second)));\n\t\t} else {\n\t\t\tvector<ii> ni, na;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tif(i != len - 1){\n\t\t\t\t\tni.push_back({I[i].first, I[i + 1].first - 1});\n\t\t\t\t} else {\n\t\t\t\t\tni.push_back(I[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> space, inc, let;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tspace.push_back(ni[i].second - ni[i].first + 1);\n\t\t\t\tif(i == 0){\n\t\t\t\t\tinc.push_back(count_ones(I[i].first, I[i].second));\n\t\t\t\t} else {\n\t\t\t\t\tinc.push_back(count_ones(I[i-1].second + 1, I[i].second));\n\t\t\t\t}\n\t\t\t\tif(i != len - 1){\n\t\t\t\t\tlet.push_back(I[i].second - I[i + 1].first + 1);\n\t\t\t\t} else {\n\t\t\t\t\tlet.push_back(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tot_ones = 0;\n\t\t\tfor(int v : inc) tot_ones += v;\n\t\t\tvector<int> f(tot_ones + 1, 0), nf(tot_ones + 1, 0);\n\t\t\tf[0] = 1;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfill(nf.begin(), nf.end(), 0);\n\t\t\t\tfor(int j = 0; j <= tot_ones; j++){\n\t\t\t\t\tif(f[j]){\n\t\t\t\t\t\tint mn = 0, mx = j + inc[i];\n\t\t\t\t\t\tmx = min(mx, space[i]);\n\t\t\t\t\t\tfor(int k = mn; k <= mx; k++){\n\t\t\t\t\t\t\tint pass = j + inc[i] - k;\n\t\t\t\t\t\t\tif(pass <= tot_ones && pass <= let[i]){\n\t\t\t\t\t\t\t\tnf[pass] += mul(f[j], ncr(space[i], k));\n\t\t\t\t\t\t\t\tif(nf[pass] >= mod) nf[pass] -= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = nf;\n\t\t\t}\n\t\t\tans = mul(ans, f[0]);\n\t\t}\n\t\tI.clear();\n\t};\n\tfor(int i = 0; i < m; i++){\n\t\tint l, r; cin >> l >> r; l--; r--;\n\t\tii e = {l, r};\n\t\tif(I.empty()) I.push_back(e);\n\t\telse if(I.back().second < l){\n\t\t\tpropagate();\n\t\t\tI.push_back(e);\n\t\t} else {\n\t\t\tif(contains(I.back(), e)) continue;\n\t\t\telse{\n\t\t\t\twhile(!I.empty() && contains(e, I.back())) I.pop_back();\n\t\t\t\tI.push_back(e);\n\t\t\t}\n\t\t}\n\t}\n\tpropagate();\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 1);\n    fi.resize(n + 1);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * mint(i);\n    }\n    fi[n] = mint(1) / f[n];\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * mint(i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r) {\n        return mint(0);\n    }\n    if (r == 0) {\n        return mint(1);\n    }\n    return f[n] * fi[n - r] * fi[r];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> co(n + 1);\n    for (int i = 0; i < n; i++) {\n        co[i + 1] = co[i] + (s[i] == '1');\n    }\n    int mr = 0;\n    vector<P> v;\n    vector<int> rs(n, -1);\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        --l;\n        --r;\n        chmax(rs[l], r);\n    }\n    for (int i = 0; i < n; i++) {\n        if (rs[i] != -1 && rs[i] > mr) {\n            mr = rs[i];\n            v.push_back(P(i, rs[i]));\n        }\n    }\n    v.push_back(P(n, n));\n    vector<vector<mint>> dp(m + 1, vector<mint>(n + 1));\n    dp[0][0] = 1;\n    comb(n + 10);\n    for (int i = 0; i + 1 < v.size(); i++) {\n        int l = v[i].first, r = v[i].second;\n        int a = r - l + 1, c = a;\n        chmin(c, v[i + 1].first - l);\n        for (int j = 0; j <= n; j++) {\n            if (dp[i][j].a == 0) {\n                continue;\n            }\n            int b = co[r + 1] - j;\n            for (int d = max(0, b - a + c); d <= min(b, c); d++) {\n                int to = j + d;\n                if (c == a) {\n                    to = co[v[i + 1].first];\n                }\n                dp[i + 1][to] += dp[i][j] * ncr(c, d);\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i <= n; i++) {\n        res += dp[v.size() - 1][i];\n    }\n    cout << res.a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?(c=getchar()):0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\nconst int N=3010,O=1000000007;\ninline int fpow(int x,int n){\n\tint a=1;\n\tfor(;n;n>>=1,x=(lint)x*x%O){\n\t\tif(n&1){\n\t\t\ta=(lint)a*x%O;\n\t\t}\n\t}\n\treturn a;\n}\ninline int inv(int x){\n\treturn fpow(x,O-2);\n}\nint f[N][N];\nint lpos[N],rpos[N],sum[N];\nchar s[N];\nint fac[N],invfac[N];\ninline void gmath(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac[i]=(lint)fac[i-1]*i%O;\n\t}\n\tinvfac[n]=inv(fac[n]);\n\tfor(int i=n;i>=1;i--){\n\t\tinvfac[i-1]=(lint)invfac[i]*i%O;\n\t}\n}\ninline int C(int n,int k){\n\tassert(n>=k);\n\treturn (lint)fac[n]*invfac[k]%O*invfac[n-k]%O;\n}\nint main(){\n\tint n=ni,tot=ni;\n\tscanf(\"%s\",s+1);\n\tsum[0]=lpos[0]=rpos[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1]+(s[i]=='1');\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tlpos[i]=ni,rpos[i]=ni;\n\t\tif(rpos[i]<=rpos[i-1]){\n\t\t\ti--,tot--;\n\t\t}else if(lpos[i]==lpos[i-1]){\n\t\t\trpos[i-1]=rpos[i];\n\t\t\ti--,tot--;\n\t\t}\n\t}\n\tlpos[tot+1]=n+1;\n\tmemset(f,0,sizeof(f));\n\tgmath(n);\n\tf[0][0]=1;\n\tint lo=0,hi=0;\n\tfor(int i=1;i<=tot;i++){\n\t\tint nxtl=min(lpos[i+1],rpos[i]+1);\n\t\tint one=sum[rpos[i]]-sum[max(lpos[i]-1,rpos[i-1])];\n\t\tint len1=nxtl-lpos[i],len2=rpos[i]-nxtl+1;\n\t\tint nlo=max(lo+one-len1,0),nhi=min(hi+one,len2);\n\t\tassert(nlo<=nhi);\n\t\tfor(int j=nlo;j<=nhi;j++){\n\t\t\tlint tmp=0;\n\t\t\tfor(int k=max(lo,j-one),tk=min(hi,len1+j-one);k<=tk;k++){\n\t\t\t\ttmp+=(lint)f[i-1][k]*C(len1,k+one-j)%O;\n\t\t\t}\n\t\t\tf[i][j]=tmp%O;\n\t\t}\n\t\tlo=nlo,hi=nhi;\n\t}\n\tprintf(\"%d\\n\",f[tot][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimization (\"unroll-loops, no-stack-protector\")\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 1e9 + 7;\nll dp[3005][3005]; \nll n, m; string s;\nll prefix[3005], r[3005];\nint main(){\n\tfastio;\n\tll n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\treverse(s.begin(), s.end()); s.pb('0'); reverse(s.begin(), s.end());\n\tfor (ll i = 1; i <= n; i++){\n\t\tr[i] = i; prefix[i] = prefix[i - 1] + (s[i] == '1');\n\t}\n\tfor (ll i = 0; i < m; i++){\n\t\tll u, v; cin >> u >> v; r[u] = max(r[u], v);\n\t}\n\tdp[0][0] = 1;\n\tfor (ll i = 1; i <= n; i++){\n\t\tr[i] = max(r[i], r[i - 1]);\n\t\tif (prefix[r[i]] < r[i] - i + 1) dp[i][0] = dp[i - 1][0];\n\t\tfor (ll j = 1; j <= i; j++){\n\t\t\tif (prefix[r[i]] - j < r[i] - i + 1) dp[i][j] = dp[i - 1][j];\n\t\t\tif (prefix[r[i]] - j >= 0) dp[i][j] += dp[i - 1][j - 1];\n\t\t\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\t}\n\t}\n\tcout << dp[n][prefix[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l[N], r[N], tr[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) {\n\t\tint ll, rr;\n\t\tscanf(\"%d%d\", &ll, &rr);\n\t\ttr[ll] = max(tr[ll], rr);\n\t}\n\tint m0 = 0;\n\tRep(i, n) if (tr[i]){\n\t\tbool flag = true;\n\t\tRep(j, i - 1) if (tr[i] <= tr[j]) flag = false;\n\t\tif (flag) l[++ m0] = i, r[m0] = tr[i];\n\t}\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, r[i] - l[i] + 1) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j]);\n\t\telse {\n\t\t\tRep0(j, r[i] - l[i] + 1) if (f[i][j]){\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, r[m0] - l[m0] + 1) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n11 8\n00101000110\n2 4\n2 3\n4 6\n4 7\n5 6\n6 9\n6 10\n10 11\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 3005;\nconst int mo = 1e+9+7;\n\nint n,m;\nint a[N],R[N];\nint pre[N],ps[N];\nint f[N][N];\n\nint add(int x,int y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tn=get();m=get();\n\tfo(i,1,n){\n\t\tchar ch;\n\t\twhile(ch=getchar(),ch<'0'||ch>'1');\n\t\ta[i]=ch-'0';\n\t}\n\tfo(i,1,m){\n\t\tint l=get(),r=get();\n\t\tR[l]=max(R[l],r);\n\t}\n\tfo(i,1,n){\n\t\tif (R[i]>pre[i-1])pre[i]=R[i];\n\t\telse R[i]=0,pre[i]=pre[i-1];\n\t}\n\tfo(i,1,n)ps[i]=ps[i-1]+a[i];\n\tf[0][0]=1;\n\tfo(i,0,n-1){\n\t\tif (!R[i+1]&&pre[i+1]<i+1)f[i+1][0]=f[i][0];\n\t\tif (!R[i+1]&&pre[i+1]>=i+1){\n\t\t\tint cnt=pre[i]-i;\n\t\t\tfo(j,0,n){\n\t\t\t\tif (j)f[i+1][j-1]=add(f[i+1][j-1],f[i][j]);\n\t\t\t\tif (cnt-j)f[i+1][j]=add(f[i+1][j],f[i][j]);\n\t\t\t}\n\t\t}\n\t\tif (R[i+1]){\n\t\t\tint cnt=R[i+1]-i,ad=ps[R[i+1]]-ps[max(i,pre[i])];\n\t\t\tfo(j,0,n){\n\t\t\t\tif (j+ad)f[i+1][j+ad-1]=add(f[i+1][j+ad-1],f[i][j]);\n\t\t\t\tif (cnt-(j+ad))f[i+1][j+ad]=add(f[i+1][j+ad],f[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_> left, const IntMod<Modulus_> right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus> left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus> left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus> left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus> left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus> left, const IntMod<Modulus> right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus> left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus> right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus> left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus> right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus> left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus> right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus> left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus> right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus> val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus> val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt((uint64_t)num); }\n#endif\n\n#endif\n\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) {\n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tdp[0][0] = 1;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if(i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if(j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<n;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <set>\n\nusing namespace std;\nconst long long MOD=1000000007;\nvoid op(set<string> &sSet,int l,int r)\n{\n\tl--;\n\tr--;\n\tint strLen=r-l+1;\n\tset<string> tmpSet;\n\tset<string>::iterator sit;\n\tfor (sit=sSet.begin();sit!=sSet.end();sit++){\n\t\tchar *S=(char*)(*sit).c_str();\n\t\tint n=0;\n\t\twhile (n<strLen){\n\t\t\tchar ch=*(S+l);\n\t\t\tmemcpy(S+l,S+l+1,strLen);\n\t\t\t*(S+r)=ch;\n\t\t\ttmpSet.insert(S);\n\t\t\tn++;\n\t\t}\n\t}\n\tsSet.insert(tmpSet.begin(),tmpSet.end());\n\ttmpSet.clear();\n\treturn;\n}\nint main(int argc, char* argv[])\n{\n\tint N,M;\n\tcin>>N>>M;\n\tstring S;\n\tcin>>S;\n\tset<string> sSet;\n\tsSet.insert(S);\n\tint i;\n\tint l,r;\n\tlong long aw=0;\n\tfor (i=0;i<M;i++){\n\t\tcin>>l>>r;\n\t\top(sSet,l,r);\n\t}\n\tcout<<sSet.size()%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\n#define x first\n#define y second\n#define MOD 1000000007\n#define NMAX 3005\n\nint n, m, d[NMAX][NMAX], ones;\nchar s[NMAX];\npair<int,int> interval[NMAX];\n\nstruct segTree{\n    int sum, lazy;\n};\n\nsegTree aintL[4 * NMAX], aintR[4 * NMAX];\n\nvoid updateNode(segTree aint[], int n, int left, int right, int val){\n    aint[n].sum= (right - left + 1) * val;\n    aint[n].lazy = val;    \n}\n\nvoid update(segTree aint[], int n, int left, int right, int a, int b, int val){\n    if(a <= left  && right <= b){\n        updateNode(aint, n, left, right, val);\n        return ;\n    }\n    int mid = (left + right) / 2;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        update(aint, 2 * n, left, mid, a, b, val);\n    if(b > mid)\n        update(aint, 2 * n + 1, mid + 1, right, a, b, val);\n    aint[n].sum = aint[2 * n].sum + aint[2 * n + 1].sum;\n}\n\nint queryCount(segTree aint[], int n, int left, int right, int a, int b){\n    if(a <= left && right <= b){\n        return aint[n].sum;\n    }\n    int mid = (left + right) / 2, ans1 = 0, ans2 = 0;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        ans1 = queryCount(aint, 2 * n, left, mid, a, b);\n    if(b > mid)\n        ans2 = queryCount(aint, 2 * n + 1, mid + 1, right, a, b);\n    return ans1 + ans2;\n}\n\nint main (){\n    pair<int,int> seg;\n    \n    scanf(\"%d%d\\n\",&n,&m);\n    scanf(\"%s\",s + 1);\n    for(int i = 1; i <= n; i++){\n        update(aintL, 1, 1, n, i, i, s[i] - '0');\n        update(aintR, 1, 1, n, i, i, s[i] - '0');\n    }\n    for(int i = 1; i <= m; i++){\n        scanf(\"%d%d\",&seg.x,&seg.y);\n        int cnt = queryCount(aintL, 1, 1, n, seg.x, seg.y);\n        update(aintL, 1, 1, n, seg.x, seg.x + cnt - 1, 1);\n        update(aintL, 1, 1, n, seg.x + cnt, seg.y, 0);\n        \n        cnt = queryCount(aintR, 1, 1, n, seg.x, seg.y);\n        update(aintR, 1, 1, n, seg.x, seg.y - cnt, 0);\n        update(aintR, 1, 1, n, seg.y - cnt + 1, seg.y, 1);\n    }\n    \n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintL, 1, 1, n, i, i)){\n            interval[++ones].x = i;\n        }\n    }\n    ones = 0;\n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintR, 1, 1, n, i, i)){\n            interval[++ones].y = i;\n        }\n    }\n    \n    d[0][0] = 1;\n    for(int i = 1; i <= n; i++)\n        for(int j = 0; j <= ones; j++){\n            d[i][j] = d[i - 1][j];\n            if(j && interval[j].x <= i && i <= interval[j].y)\n                d[i][j] += d[i - 1][j - 1];\n            if(d[i][j] >= MOD)\n                d[i][j] -= MOD;\n        }\n    printf(\"%d\\n\", d[n][ones]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint fact[1000001];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nint N, M;\nint L[3000], R[3000];\nint T[3001];\nstring S;\nint dp[3001][3001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=1000000; i++) {\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n\n  cin >> N >> M >> S;\n  rep(i, N) T[i+1] = T[i] + (S[i] == '1');\n  rep(i, M) {\n    cin >> L[i] >> R[i];\n    L[i]--, R[i]--;\n  }\n  vector<P> qs;\n  rep(i, M) {\n    bool f = true;\n    rep(j, M) {\n      if (i == j) continue;\n      // j contains i\n      if (L[j] <= L[i] && R[i] <= R[j]) {\n        f = false;\n        break;\n      }\n    }\n    if (!f) continue;\n    qs.pb(P(L[i], R[i]));\n  }\n  dp[0][0] = 1;\n  int s = 1;\n  rep(i, qs.size()) {\n    int l = qs[i]._1, r = qs[i]._2;\n    bool end = true;\n    int n = 0;\n    int nl = N;\n    if (i+1 < qs.size()) {\n      nl = qs[i+1]._1;\n      if (r >= nl) {\n        end = false;\n        n = r-nl+1;\n      }\n    }\n    int ll = l;\n    if (i > 0) ll = max(ll, qs[i-1]._2+1);\n    int ones = T[r+1] - T[ll];\n    if (end) {\n      int len = r-l+1;\n      long long e = 0;\n      rep(k, N+1) {\n        e += (1LL * dp[i][k] * nCr(len, ones+k)) % MOD;\n        e %= MOD;\n      }\n      s = (1LL*s*e) % MOD;\n      dp[i+1][0] = 1;\n    }\n    else {\n      int det = nl-l;\n      rep(k, (ll-l)+1) {\n        if (k > N) break;\n        if (dp[i][k] == 0) continue;\n        int r = ones+k;\n        rep(nk, n+1) {\n          if (r < nk) break;\n          // r-nk, nk\n          dp[i+1][nk] += (1LL * nCr(det, r-nk) * dp[i][k]) % MOD;\n          dp[i+1][nk] %= MOD;\n        }\n      }\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n \nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n \nusing namespace std;\nconst int N=1e5+10,mod=1e9+7;\nchar s[N];\nint n,m,ans,fac[N],ifac[N],l[N],r[N],lb[N],rb[N],f[2][N],a[N];\n\nint inv(int x)\n{\n    return x>1? 1ll*(mod-mod/x)*inv(mod%x)%mod:1;\n}\n\nint c(int n,int m)\n{\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n \nint main()\n{\n    n=get(),m=get();\n    fac[0]=1;\n    rep(i,1,n)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=inv(fac[n]);\n    repd(i,n,1)\n        ifac[i-1]=1ll*ifac[i]*i%mod;\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        static int *f=::f[0],*g=::f[1];\n        swap(f,g);\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        lb[i]=max(0,lb[i-1]+w-s),rb[i]=min(mx,rb[i-1]+w);\n        rep(j,lb[i],rb[i])\n            rep(k,max(j-w,lb[i-1]),min(s+j-w,rb[i-1]))\n                f[j]=(f[j]+1ll*g[k]*c(s,k+w-j))%mod;\n        memset(g+lb[i-1],0,sizeof(int)*(rb[i-1]-lb[i-1]+1));\n    }\n    rep(i,0,n)\n        ans=(ans+f[m&1][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tfor(int i=1;i<=m;++i)\n\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j)%mod)%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=3010,Mo=1000000007;\nint n,m;\nchar s[N];\nint f[N][N],w[N],r[N],id[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nint main() {\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++) w[i]=w[i-1]+s[i]-'0',r[i]=i;\n    for(int i=1;i<=m;i++) {\n\tint x=gi(),y=gi();\n\tfor(int j=x;j<=y;j++) r[j]=max(r[j],y);\n    }\n    f[0][0]=1;\n    for(int i=1;i<=n;i++)\n\tfor(int j=max(0,i-r[i]+w[r[i]]);j<=w[r[i]];j++)\n\t    f[i][j]=(f[i-1][j]+f[i-1][j-1])%Mo;\n    cout<<f[n][w[n]];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 1);\n    fi.resize(n + 1);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * mint(i);\n    }\n    fi[n] = mint(1) / f[n];\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * mint(i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r) {\n        return mint(0);\n    }\n    if (r == 0) {\n        return mint(1);\n    }\n    return f[n] * fi[n - r] * fi[r];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> co(n + 1);\n    for (int i = 0; i < n; i++) {\n        co[i + 1] = co[i] + (s[i] == '1');\n    }\n    int mr = 0;\n    vector<P> v;\n    vector<int> rs(n, -1);\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        --l;\n        --r;\n        chmax(rs[l], r);\n    }\n    for (int i = 0; i < n; i++) {\n        if (rs[i] != -1 && rs[i] > mr) {\n            mr = rs[i];\n            v.push_back(P(i, rs[i]));\n        }\n    }\n    v.push_back(P(n, n));\n    vector<vector<mint>> dp(m + 1, vector<mint>(n + 1));\n    dp[0][co[v[0].first]] = 1;\n    comb(n + 10);\n    for (int i = 0; i + 1 < v.size(); i++) {\n        int l = v[i].first, r = v[i].second;\n        int a = r - l + 1, c = a;\n        chmin(c, v[i + 1].first - l);\n        for (int j = 0; j <= n; j++) {\n            if (dp[i][j].a == 0) {\n                continue;\n            }\n            int b = co[r + 1] - j;\n            for (int d = max(0, b - a + c); d <= min(b, c); d++) {\n                int to = j + d;\n                if (c == a) {\n                    to = co[v[i + 1].first];\n                }\n                dp[i + 1][to] += dp[i][j] * ncr(c, d);\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i <= n; i++) {\n        res += dp[v.size() - 1][i];\n    }\n    cout << res.a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tban[i][j] = false;\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\tassert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\ttable.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m,ans;\nstring s;\nll ac[3001];\nll l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return x*x%MOD;\n}\nint modpow(ll x,int y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=(ret*(x-i)*inv(i+1))%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        ll le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max((ll)0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 3030;\nconst int MAXM = 3030;\nconst int MOD = 1000000007;\ninline int add(int x, int y) { return (x + y) % MOD; }\n\nchar S[MAXN];\nint cnt[MAXN];\nint dp[MAXN][MAXN];\nint l[MAXM], r[MAXM];\n\nint main() {\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int i = 0; i < M; i++)\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\tcnt[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tcnt[i] = cnt[i - 1] + S[i] - '0';\n\tdp[l[0] - 1][cnt[l[0] - 1]] = 1;\n\tint ans = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tint tl = l[i], tr = r[i];\n\t\twhile(i + 1 < M && (l[i + 1] == tl || r[i + 1] <= tr)) {\n\t\t\ti++;\n\t\t\ttr = max(tr, r[i]);\n\t\t}\n\t\tdebug(\"(%d, %d)\\n\", tl, tr);\n\t\tfor(int j = tl; (i == M - 1 || j < l[i + 1]) && j <= tr; j++) {\n\t\t\tfor(int k = 0; k <= N; k++) {\n\t\t\t\tif(cnt[tr] >= k && tr - cnt[tr] >= j - k) {\n\t\t\t\t\tif(k == 0)\n\t\t\t\t\t\tdp[j][k] = dp[j - 1][k];\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[j][k] = add(dp[j - 1][k - 1], dp[j - 1][k]);\n\t\t\t\t}\n\t\t\t\t/*if(cnt[tr] )\n\t\t\t\t\tdp[j][k] += dp[j - 1][k];*/\n\t\t\t\tdebug(\"dp[%d][%d] = %d\\n\", j, k, dp[j][k]);\n\t\t\t}\n\t\t}\n\t\tif(i == M - 1) {\n\t\t\tans = dp[tr][cnt[tr]];\n\t\t}\n\t\telse {\n\t\t\tfor(int j = tr + 1; j < l[i + 1]; j++)\n\t\t\t\tfor(int k = 0; k <= N; k++) {\n\t\t\t\t\tif(S[j] == '1') {\n\t\t\t\t\t\tif(k > 0)\n\t\t\t\t\t\t\tdp[j][k] = dp[j - 1][k - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[j][k] = dp[j - 1][k];\n\t\t\t\t\tdebug(\"dp[%d][%d] = %d\\n\", j, k, dp[j][k]);\n\t\t\t\t}\n\t\t\tdebug(\"!\\n\");\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for (int i = (a); i <= (b); ++i)\n#define REPD(i,a,b) for (int i = (a); i >= (b); --i)\n#define FORI(i,n) REP(i,1,n)\n#define FOR(i,n) REP(i,0,int(n)-1)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define vi vector<int>\n#define ll long long\n#define SZ(x) int((x).size())\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)\n#define fi first\n#define se second\n\nconst int N = 3030;\nconst int mod = 1000000007;\n\nint p[N];\n\nint zeros(int l, int r) {\n\treturn p[r] - p[l];\n}\n\nchar s[N];\nint l[N], r[N];\nint c[N][N];\nint dp[N][N];\n\nvoid test() {\n\tint n,m;\n\tscanf(\"%d %d %s\", &n, &m, s);\n\tFOR(i,m) {\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\t\tl[i]--;\n\t\tif (i>0 && r[i]<r[i-1]) {\n\t\t\tr[i] = r[i-1];\n\t\t}\n\t}\n\tl[m] = r[m] = n;\n\tFOR(i,n) p[i+1] = p[i] + (s[i]=='0');\n\tFOR(i,n+1) FOR(j,i+1) {\n\t\tif (i==0 || i==j) c[i][j] = 1;\n\t\telse {\n\t\t\tc[i][j] = c[i-1][j] + c[i-1][j-1];\n\t\t\tif (c[i][j] >= mod) c[i][j] -= mod;\n\t\t}\n\t}\n\tFOR(z,n+1) dp[m][z] = 1;\n\tfor (int i=m-1; i>=0; i--) {\n\t\tif (r[i] > l[i+1]) { // overlap\n\t\t\tint d = l[i+1] - l[i];\n\t\t\tFOR(z,n+1) {\n\t\t\t\tfor (int zz = 0; zz <= d; zz++) {\n\t\t\t\t\tif (zz>z) break;\n\t\t\t\t\tif (d-zz > r[i]-l[i]-z) continue;\n\t\t\t\t\tdp[i][z] += 1LL * c[d][zz] * dp[i+1][z-zz+zeros(r[i], r[i+1])] % mod;\n\t\t\t\t\tif (dp[i][z] >= mod) dp[i][z] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // no overlap\n\t\t\tFOR(z,n+1) {\n\t\t\t\tdp[i][z] = 1LL * c[r[i]-l[i]][z] * dp[i+1][zeros(l[i+1], r[i+1])] % mod;\n\t\t\t\tif (dp[i][z] >= mod) dp[i][z] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[0][zeros(l[0], r[0])]);\n}\n\nint main() {\n\tint ttn=1;\n\t//scanf(\"%d\", &ttn);\n\twhile (ttn--) test();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp>*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n//typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\n#define FOR(i, a, b) for (int i=a; i<b; i++)\n#define F0R(i, a) for (int i=0; i<a; i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\nconst int MOD = 1000000007;\ndouble PI = 4*atan(1);\n\nint N,M, R[3001], num[3001], dp[3001][3001];\nstring s;\n\nint main() {\n\tcin >> N >> M >> s;\n\tF0R(i,N) R[i] = i+1;\n\tR[N] = N;\n\t\n\tF0R(i,M) {\n\t    int l,r; cin >> l >> r; l--,r--;\n\t    R[l] = max(R[l],r+1);\n\t}\n\t\n\tF0R(i,N+1) {\n\t    int pre = 0;\n\t    if (i) pre = R[i-1];\n\t    \n\t    R[i] = max(pre,R[i]);\n\t    for (int j = pre; j < R[i]; ++j) if (s[j] == '1') num[i] ++;\n\t}\n\t\n\t//F0R(i,N+1) cout << i << \" \" << R[i] << \"\\n\";\n\tdp[N][0] = 1;\n\tF0Rd(L,N) F0R(j,R[L]-L+1) {\n\t    if (j <= R[L]-L-1) dp[L][j] += dp[L+1][j+num[L+1]]; // what should these indices be\n\t    if (j >= 1) dp[L][j] += dp[L+1][j+num[L+1]-1];\n\t    dp[L][j] %= MOD;\n\t    //cout << L << \" \" << j << \" \" << dp[L][j] << \"\\n\";\n\t}\n\tcout << dp[0][num[0]];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3005;\nconst int MOD=1000000007;\n\nint n,m,c[N][N],a[N],f[N][N];\nstruct data{int l,r;}op[N];\nchar str[N];\n\nbool cmp(data a,data b)\n{\n    return a.l<b.l||a.l==b.l&&a.r<b.r;\n}\n\nvoid mod(int &x)\n{\n    x-=x>=MOD?MOD:0;\n}\n\nvoid prepare()\n{\n    c[0][0]=1;\n    for (int i=1;i<=n;i++)\n    {\n        c[i][0]=1;\n        for (int j=1;j<=i;j++) mod(c[i][j]=c[i-1][j]+c[i-1][j-1]);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    prepare();\n    scanf(\"%s\",str+1);\n    for (int i=1;i<=n;i++) a[i]=a[i-1]+str[i]-'0';\n    for (int i=1;i<=m;i++) scanf(\"%d%d\",&op[i].l,&op[i].r);\n    sort(op+1,op+m+1,cmp);\n    int tmp=m,mx=0;\n    for (int i=1;i<=m;i++)\n        if (op[i].l==op[i+1].l||op[i].r<=mx) tmp--,op[i].l=n+1;\n        else mx=max(mx,op[i].r);\n    sort(op+1,op+m+1,cmp);\n    m=tmp;\n    f[op[1].l-1][a[op[1].l-1]]=1;\n    op[m+1].l=n+1;\n    for (int i=1;i<=m;i++)\n    {\n        int l=op[i].l,r=op[i].r,nx=op[i+1].l;\n        for (int j=0;j<l;j++)\n        {\n            if (!f[l-1][j]) continue;\n            int s=a[r]-j,p=max(0,s-(r-nx+1)),q=min(s,nx-l);\n            if (nx>r) {mod(f[nx-1][a[nx-1]]+=(LL)f[l-1][j]*c[r-l+1][s]%MOD);continue;}\n            if (p>q) continue;\n            for (int k=p;k<=q;k++) mod(f[nx-1][j+k]+=(LL)f[l-1][j]*c[nx-l][k]%MOD);\n        }\n    }\n    printf(\"%d\",f[n][a[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=3e3+5,mod=1e9+7;\nint n,m;\nint a[maxn],R[maxn],sum[maxn],f[maxn][maxn];\nchar str[maxn];\nvoid upd(int &x,int y){\n\tx=(x+y)%mod;\n}\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",str+1);\n\trep(i,1,n)a[i]=str[i]-'0',R[i]=i,sum[i]=sum[i-1]+a[i];\n\trep(i,1,m){\n\t\tint x,y;read(x);read(y);\n\t\tR[x]=max(R[x],y);\n\t}\n\trep(i,1,n)R[i]=max(R[i-1],R[i]);\n\tint pnt=0;\n\tf[0][0]=1;\n\trep2(i,0,n)rep(j,0,n)if(f[i][j]){\n\t\tif(R[i]-i<j)continue;\n\t\tint dlt=sum[R[i+1]]-sum[R[i]];\n\t\tif(j+dlt-1>=0)upd(f[i+1][j+dlt-1],f[i][j]);\n\t\tupd(f[i+1][j+dlt],f[i][j]);\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nint l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return x*x%MOD;\n}\nint modpow(ll x,ll y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=ret*(x-i)%MOD;\n        ret=ret*inv(i+1)%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        int le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max(0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nlong long dp[3010][3010];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    int rmax = -1; int curr = 0;\n    int rsum = 0;\n    dp[0][0] = 1;\n    auto f = [&](void) {\n        if (rmax < curr) {\n            int x = s[curr] == '1';\n            for (int i = 0; i <= n; i++) {\n                dp[curr+1][i+x] = dp[curr][i];\n            }\n            rmax++, curr++; rsum += x;\n        } else {\n            for (int i = 0; i <= n; i++) {\n                if (curr+1-(rmax+1-rsum) <= i+1 && i+1 <= rsum) {\n                    dp[curr+1][i+1] += dp[curr][i];\n                }\n                if (curr+1-(rmax+1-rsum) <= i && i <= rsum) {\n                    dp[curr+1][i] += dp[curr][i];\n                }\n                dp[curr+1][i] %= mod;\n            }\n            curr++;\n        }\n    };\n    auto g = [&](int r) {\n        while (rmax < r) {\n            rmax++;\n            rsum += s[rmax] == '1';\n        }\n    };\n    map<int, int> c;\n    for (int mi = 0; mi < m; mi++) {\n        int l, r; cin >> l >> r; l--; r--;\n        c[l] = max(c[l], r);\n    }\n    for (auto &iter: c) {\n        int l = iter.first;\n        int r = iter.second;\n        while (curr < l) f();\n        g(r);\n    }\n    while (curr < n) f();\n    g(n);\n    cout << dp[n][rsum] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 4010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\nchar s[MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s + 1);\n    for(i = 1; i <= n; ++i){\n        a[i] = s[i] - '0';\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j){\n            if(j > R){\n                R = j;\n                ad = a[j];\n            }\n            else ad = 0;\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad = sum[r] - sum[R];\n            R = r;\n        }\n        else ad = 0;\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j){\n        if(j > R){\n            R = j;\n            ad = a[j];\n        }\n        else ad = 0;\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 3005;\nconst int mo = 1e+9+7;\n\nint n,m;\nint a[N],R[N];\nint pre[N],ps[N];\nint f[N][N];\n\nint add(int x,int y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tn=get();m=get();\n\tfo(i,1,n){\n\t\tchar ch;\n\t\twhile(ch=getchar(),ch<'0'||ch>'1');\n\t\ta[i]=ch-'0';\n\t}\n\tfo(i,1,m){\n\t\tint l=get(),r=get();\n\t\tR[l]=max(R[l],r);\n\t}\n\tfo(i,1,n){\n\t\tif (R[i]>pre[i-1])pre[i]=R[i];\n\t\telse R[i]=0,pre[i]=pre[i-1];\n\t}\n\tfo(i,1,n)ps[i]=ps[i-1]+a[i];\n\tf[0][0]=1;\n\tfo(i,0,n-1){\n\t\tint cnt,ad;\n\t\tif (!R[i+1]&&pre[i+1]<i+1)cnt=1,ad=a[i+1];\n\t\tif (!R[i+1]&&pre[i+1]>=i+1)cnt=pre[i]-i,ad=0;\n\t\tif (R[i+1])cnt=R[i+1]-i,ad=ps[R[i+1]]-ps[max(i,pre[i])];\n\t\tfo(j,0,n){\n\t\t\tif (j+ad)f[i+1][j+ad-1]=add(f[i+1][j+ad-1],f[i][j]);\n\t\t\tif (cnt-(j+ad))f[i+1][j+ad]=add(f[i+1][j+ad],f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n\nconst int N = 3000 + 10, MOD = 1000000007;\n\nint n;\nchar s[N];\n\nint a[N], b[N];\n\nint main() {\n  int m;\n  scanf(\"%d%d %s\", &n, &m, s + 1);\n  for (int i = 1; i <= n; ++i) a[i] = b[i] = s[i] - '0';\n  while (m--) {\n    int l, r;\n    scanf(\"%d%d\", &l, &r);\n    std::sort(a + l, a + r + 1);\n    std::sort(b + l, b + r + 1, std::greater<int>());\n  }\n  for (int i = 1; i <= n; ++i) a[i] += a[i - 1], b[i] += b[i - 1];\n  static int f[N][N];\n  f[1][0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      int cur = f[i][j];\n      if (!cur) continue;\n      if (a[i] <= j && j <= b[i]) (f[i + 1][j] += cur) %= MOD;\n      if (a[i] <= j + 1 && j + 1 <= b[i]) (f[i + 1][j + 1] += cur) %= MOD;\n    }\n  }\n  printf(\"%d\\n\", f[n + 1][a[n]]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 3005\n\nconst LL mod=1000000007;\nLL ans,n,m,C[N][N],f[N],g[N],a[N];\nchar s[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nint main(){\n\tscanf(\"%lld%lld%s\",&n,&m,s+1);\n\tfor (LL i=0;i<=n;++i){\n\t\tC[i][0]=1;\n\t\tfor (LL j=1;j<=i;++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tfor (LL i=1;i<=n;++i) a[i]=s[i]-'0';\n\tf[0]=1;\n\tans=1;\n\tLL l=1,r=0;\n\tfor (LL i=1;i<=m;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\tif (y<=r) continue;\n\t\tif (x>r){\n\t\t\tLL sum=0;\n\t\t\tfor (LL j=0;j<=r-l+1;++j){\n\t\t\t\tupd(sum,f[j]*C[r-l+1][j]);\n\t\t\t}\n\t\t\tans=ans*sum%mod;\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[0]=1;\n\t\t\tl=x; r=x-1;\n\t\t}\n\t\tLL tmp=0;\n\t\tfor (LL j=r+1;j<=y;++j){\n\t\t\ttmp+=a[j];\n\t\t}\n\t\tLL len=x-l;\n\t\tmemset(g,0,sizeof g);\n\t\tfor (LL j=0;j<=n;++j){\n\t\t\tfor (LL k=0;k<=len&&k<=j;++k){\n\t\t\t\tif (j-k<=r-l+1-len) upd(g[j-k+tmp],f[j]*C[len][k]);\n\t\t\t}\n\t\t}\n\t\tmemcpy(f,g,sizeof f);\n\t\tl=x; r=y;\n\t}\n\tLL sum=0;\n\tfor (LL j=0;j<=r-l+1;++j){\n\t\tupd(sum,f[j]*C[r-l+1][j]);\n\t}\n\tans=ans*sum%mod;\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],inv[3002];\nlld d[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= inv[n-r]; tmp %= Mod;\n\ttmp *= inv[r]; tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = inv[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][sum[x[1]-1]] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tif(d[i-1][j] == 0) continue;\n\t\t\tint cnt1,cnt2,tmp = 0;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t\ttmp = sum[x[i+1]-1]-sum[maxr];\n\t\t\t}else{\n\t\t\t\tif(sum[maxr]-j > maxr-x[i]+1) while(true);\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k+tmp] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k+tmp] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#define ll long long\n#define plus 0\n#define minus 1\nusing namespace std;\nconst int N=1e5+10;\nstruct Dot{\n\tint x,y,id;\n\tDot(){}\n\tDot(int x1,int y1,int id1){x=x1; y=y1; id=id1;}\n\tfriend bool operator < (Dot a,Dot b){\n\t\tif (a.x!=b.x) return a.x<b.x;\n\t\tif (a.y!=b.y) return a.y<b.y;\n\t\treturn a.id<b.id;\n\t}\n}a[N];\nint vis[N],LL;\nmap<int,vector<int> >rec2[2];\nmap<int,set<Dot> >rec1[2];\nset<Dot>::iterator it,it2;\nqueue<Dot> q;\nll ans;\nint n,A,B,D;\nint Abs(int x){return x<0?-x:x;}\nvoid prework(){\n\twhile (!q.empty()) q.pop();\n\tmemset(vis,false,sizeof(vis));\n\tfor (int i=1;i<=n;++i){\n\t\tif (i==A)\n\t\t\tq.push(a[i]),vis[i]=true;\n\t\telse{\n\t\t\trec1[plus][a[i].x+a[i].y].insert(a[i]);\n\t\t\trec1[minus][a[i].x-a[i].y].insert(a[i]);\n\t\t}\n\t}\n}\nvoid get_point(set<Dot> &tmp,int which,ll val,int lx,int rx){\n\tDot ttmp;\n\tif (rec1[which].find(val)==rec1[which].end()) return;\n\tit=lower_bound(tmp.begin(),tmp.end(),Dot(lx,0,0));\n\tttmp=*it;\n\tfor (;ttmp.x<=rx&&it!=tmp.end();it=it2,ttmp=*it2){\n\t\tit2=it; ++it2;\n\t\tq.push(ttmp),vis[ttmp.id]=true;\n\t\tLL++;\n\t\trec1[plus][ttmp.x+ttmp.y].erase(ttmp);\n\t\trec1[minus][ttmp.x-ttmp.y].erase(ttmp);\n\t}\n}\nvoid bfs(){\n\tDot u,v;\n\twhile (!q.empty()){\n\t\tv=q.front(); q.pop();\n\t\tif (1LL*v.x+v.y+D<=2e9)\n\t\t\tget_point(rec1[plus][1LL*v.x+v.y+D],plus,1LL*v.x+v.y+D,v.x,v.x+D);\n\t\tget_point(rec1[plus][1LL*v.x+v.y-D],plus,1LL*v.x+v.y-D,v.x-D,v.x);\n\n\t\tget_point(rec1[minus][1LL*v.x-v.y+D],minus,1LL*v.x-v.y+D,v.x,v.x+D);\n\t\tget_point(rec1[minus][1LL*v.x-v.y-D],minus,1LL*v.x-v.y-D,v.x-D,v.x);\n\n\t\t//printf(\"%d\\n\",(int)q.size());\n\t}\n\t//printf(\"%d\\n\",debug);\n}\nint calc(int which,int val,int lx,int rx){\n\tif (rec2[which].find(val)==rec2[which].end()) return 0;\n\tstatic vector<int> tmp;\n\ttmp=rec2[which][val];\n\treturn lower_bound(tmp.begin(),tmp.end(),rx+1)-lower_bound(tmp.begin(),tmp.end(),lx);\n}\n\nvoid solve(){\n\tsort(a+1,a+1+n);\n\tans=0;\n\tDot v;\n\tfor (int i=1;i<=n;++i){\n\t\tv=a[i];\n\t\t//printf(\"%d %d %d\\n\",v.x,v.y,v.id);\n\t\tif (!vis[v.id]) continue;\n\t\tif (1LL*v.x+v.y+D<=2e9)\n\t\t\tans+=calc(plus,v.x+v.y+D,v.x,v.x+D);\n\t\tans+=calc(plus,v.x+v.y-D,v.x-D,v.x);\n\n\t\tans+=calc(minus,v.x-v.y+D,v.x+1,v.x+D-1);\n\t\tans+=calc(minus,v.x-v.y-D,v.x-D+1,v.x-1);\n\n\t\trec2[plus][v.x+v.y].push_back(v.x);\n\t\trec2[minus][v.x-v.y].push_back(v.x);\n\t\t//printf(\"%lld\\n\",ans);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y),a[i].id=i;\n\tD=Abs(a[A].x-a[B].x)+Abs(a[A].y-a[B].y);\n\tprework();\n\tbfs();\n\tsolve();\n//\tprintf(\"%d\",LL);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 3e3 + 3;\nconst int mod = 1e9 + 7;\nint n , m;\nchar str[N];\nint sum[N];\nint arr[N];\nint a , b;\nint dp[N][N];\nint solve(int l , int r , int cnt){\n    if(cnt > r - l + 1){\n        return 0;\n    }\n    if(l > n){\n        return 1;\n    }\n    if(arr[l] > r){\n        cnt += sum[arr[l]] - sum[r];\n        r = arr[l];\n    }\n    if(dp[l][cnt] != -1){\n        return dp[l][cnt];\n    }\n    int res = 0;\n    if(cnt){\n        res += solve(l + 1 , r , cnt - 1);\n    }\n    res += solve(l + 1 , r , cnt);\n    if(res >= mod){\n        res -= mod;\n    }\n    if(dp[l][cnt] != -1){\n        return dp[l][cnt];\n    }\n    return res;\n}\nint main(){\n    scanf(\"%d %d\" , &n , &m);\n    scanf(\"%s\" , str + 1);\n    sum[0] = 0;\n    for(int i = 1 ; i <= n ; ++i){\n        sum[i] = sum[i - 1] + str[i] - '0';\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        arr[i] = i;\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        scanf(\"%d %d\" , &a , &b);\n        arr[a] = max(arr[a] , b);\n    }\n    memset(dp , -1 , sizeof(dp));\n    printf(\"%d\\n\" , solve(1 , 0 , 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=3005,mod=1000000007;\ntypedef long long LL;\nchar S[N];\nint n,m,s[N],x[N],y[N],c[N][N],tot,l[N],r[N],maxn;\nLL f[N][N];\nstruct data{int x,y;} dat[N];\n\nint getint()\n{\n\tchar ch;\n\tint f=1;\n\twhile(!isdigit(ch=getchar())) if(ch=='-') f=-1;\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x*f;\n}\n\nbool cmp(data a,data b)\n{\n\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n}\n\nint main()\n{\n\t\n\tn=getint(),m=getint(),scanf(\"%s\",S+1);\n\trep(i,0,n) c[i][0]=c[i][i]=1;\n\trep(i,1,n) rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\trep(i,1,n) s[i]=s[i-1]+S[i]-48;\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\tsort(dat+1,dat+1+m,cmp);\n\trep(i,1,m) if(dat[i].y>maxn) ++tot,x[tot]=dat[i].x,y[tot]=dat[i].y,maxn=dat[i].y;\n\tf[0][0]=1,x[tot+1]=y[tot+1]=n+1;\n\trep(i,1,tot)\n\t{\n\t\tint w=min(y[i]-x[i]+1,x[i+1]-x[i]),a=s[y[i]]-s[max(x[i]-1,y[i-1])];\n\t\tl[i]=max(0,l[i-1]+a-w),r[i]=min(y[i]-x[i]+1,min(max(y[i]-x[i+1]+1,0),r[i-1]+a));\n\t\trep(j,l[i],r[i])\n\t\t\trep(k,max(l[i-1],-(a-j)),r[i-1])\n\t\t\t{\n\t\t\t\tif(k+a-j>w) break;\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][k]*c[w][k+a-j])%mod;\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[tot][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nvoid act(int& a, int b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n\n    string s; cin >> s;\n    vector<int> ones(n), zero(n);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') ones[i] = 1;\n        else zero[i] = 1;\n        if (i > 0) {\n            ones[i] += ones[i - 1];\n            zero[i] += zero[i - 1];\n        }\n    }\n\n    vector<int> best(n);\n    for (int i = 0; i < n; ++i)\n        best[i] = i;\n\n    for (int i = 0; i < m; ++i) {\n        int l, r; cin >> l >> r; --l; --r;\n        best[l] = max(best[l], r);\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        best[i + 1] = max(best[i + 1], best[i]);\n    }\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int at = i + j;\n            bool can_zero = zero[best[at]] > i;\n            bool can_ones = ones[best[at]] > j;\n            if (can_zero) act(dp[i + 1][j], dp[i][j]);\n            if (can_ones) act(dp[i][j + 1], dp[i][j]);\n        }\n    }\n    \n    int ans = 0;\n    for (int i = 0, j = n; i <= n; ++i, --j)\n        act(ans, dp[i][j]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nconst ll MOD=1e9+7;\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string buf;\n    cin>>buf;\n    vector<int> s(n);\n    for(int i=0;i<n;i++) s[i]=buf[i]-'0';\n    vector<pair<int,int>> lr(m);\n    for(int i=0;i<m;i++){\n        cin>>lr[i].first>>lr[i].second;\n        lr[i].first--;\n    }\n    sort(lr.begin(),lr.end(),[](pair<int,int> lhs,pair<int,int> rhs){\n        return lhs.first==rhs.first ? lhs.second>rhs.second : lhs.first<rhs.first;\n    });\n    vector<int> l;\n    vector<int> r;\n    int mr=0;\n    for(int i=0;i<m;i++){\n        if(mr<lr[i].second){\n            while(mr<lr[i].first){\n                l.push_back(mr);\n                r.push_back(mr+1);\n                mr++;\n            }\n            l.push_back(lr[i].first);\n            r.push_back(lr[i].second);\n            mr=r.back();\n        }\n    }\n    for(int i=r.back();i<n;i++){\n        l.push_back(i);\n        r.push_back(i+1);\n    }\n    m=l.size();\n\n    vector<int> sum(n);\n    partial_sum(s.begin(),s.end(),sum.begin()+1);\n    vector<vector<ll>> dp(n+1,vector<ll>(n+1,0));\n    dp[0][0]=1;\n    int rig=0;\n    int idx=0;\n    for(int i=0;i<n;i++){\n        int p=0;\n        if(idx<m && l[idx]==i){\n            p=sum[r[idx]]-sum[rig];\n            rig=r[idx];\n            idx++;\n        }\n        // cerr<<\"$\"<<i<<\" \"<<p<<\" \"<<rig<<endl;\n        for(int j=0;j<=n;j++){\n            // cerr<<\"#\"<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n            if(j+p-1>=0) (dp[i+1][j+p-1]+=dp[i][j])%=MOD;\n            if(rig-i>j+p) (dp[i+1][j+p]+=dp[i][j])%=MOD;\n        }\n    }\n    cout<<dp[n][0]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\n\ntemplate <long long mod>\nstruct modint {\n    long long x;\n\n    modint<mod>(): x(0LL) {}\n    modint<mod>(const long long _data) {\n        if (_data < 0) {\n            x = (_data % mod + mod) % mod;\n        } else if (_data >= mod) {\n            x = _data % mod;\n        } else {\n            x = _data;\n        }\n    }\n\n    bool operator==(const modint<mod>& op) const {\n        return x == op.x;\n    }\n\n    bool operator!=(const modint<mod>& op) const {\n        return !((*this) == op);\n    }\n\n    modint<mod> operator-() const {\n        if (x == 0) {\n            return modint(0);\n        }\n        return modint(mod - x);\n    }\n\n    modint<mod> operator+(const modint<mod>& op) const {\n        const long long newdata = x + op.x;\n        if (newdata >= mod) {\n            return modint<mod>(newdata - mod);\n        } else {\n            return modint<mod>(newdata);\n        }\n    }\n\n    modint<mod> operator-(const modint<mod>& op) const {\n        return *this + (-op);\n    }\n\n    modint<mod> operator*(const modint<mod>& op) const {\n        return modint<mod>(x * op.x % mod);\n    }\n\n    modint<mod> pow(const long long n) const {\n        if (n == 0) {\n            return modint<mod>(1);\n        }\n        modint<mod> sq = pow(n / 2);\n        if (n & 1) {\n            return (*this) * sq * sq;\n        } else {\n            return sq * sq;\n        }\n    }\n\n    modint<mod> inverse() const {\n        return pow(mod - 2);\n    }\n\n    modint<mod> operator/(const modint<mod>& op) const {\n        return (*this) * op.inverse();\n    }\n\n    friend modint<mod> operator/(const long long dividend, const modint<mod>& divisor) {\n        return modint<mod>(dividend) / divisor;\n    }\n\n    static modint<mod> factorial(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() * cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> combination(const long long n, const long long k) {\n        if (k < 0 || n < k) {\n            return modint<mod>(0);\n        }\n\n        if (n < 1e6) {\n            return factorial(n) / (factorial(k) * factorial(n - k));\n        }\n\n        modint<mod> ret(1);\n        for (int i = 1; i <= k; ++i) {\n            ret = ret * modint<mod>(n - i + 1) / modint<mod>(i);\n        }\n        return ret;\n    }\n};\n\ntypedef modint<1000000007> mint;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    li n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<li> ops(n);\n    for (int i = 0; i < m; ++i) {\n        li l, r;\n        cin >> l >> r;\n        l--; r--;\n        ops[l] = max(ops[l], r);\n    }\n\n    vector<li> accum(n + 1);\n    for (int i = 0; i < n; ++i) {\n        accum[i + 1] = accum[i] + (s[i] - '0');\n    }\n\n    vector<vector<mint>> dp(n + 1, vector<mint>(n + 1, 0));\n    dp[0][0] = 1;\n    li max_r = 0;\n    for (int i = 0; i < n; ++i) {\n        max_r = max(max_r, ops[i]);\n        max_r = max(max_r, (li) i);\n        const li ones = accum[max_r + 1];\n        const li zeros = max_r + 1 - ones;\n        for (int next_ones = 0; next_ones <= ones; ++next_ones) {\n            const li next_zeros = i + 1 - next_ones;\n            if (next_zeros < 0 || next_zeros > zeros) {\n                continue;\n            }\n            dp[i + 1][next_ones] = dp[i][next_ones];\n            if (next_ones > 0) {\n                dp[i + 1][next_ones] = dp[i + 1][next_ones] + dp[i][next_ones - 1];\n            }\n        }\n\n    }\n\n    cout << dp[n][accum[n]].x << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mdl=1000000007LL;\nin p2(in a){\n  return (1LL<<a);\n}\nin pw(in a, in b, in lm=62){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  in r=1;\n  for(in i=lm;i>=0;--i){\n    r=r*r%mdl;\n    if(b&p2(i))\n      r=r*a%mdl;\n  }\n  return r;\n}\nin inv(in a){\n  a%=mdl;\n  if(a<0)\n    a+=mdl;\n  assert(a!=0);\n  return pw(a,mdl-2,30);\n}\nVI fc,invfc;\nin ncr(in a, in b){\n  if(b==0 || b==a)\n    return 1;//even if a<0\n  if(b<0 || b>a)\n    return 0;\n  return fc[a]*invfc[b]%mdl*invfc[a-b]%mdl;\n}\nvoid inifc(){\n  const in mxfc=1001000;\n  fc.resize(mxfc);\n  invfc.resize(mxfc);\n  fc[0]=fc[1]=invfc[0]=invfc[1]=1;\n  for(in i=2;i<mxfc;++i){\n    fc[i]=fc[i-1]*i%mdl;\n    invfc[i]=invfc[mdl%i]*(mdl-mdl/i)%mdl;\n  }\n  for(in i=2;i<mxfc;++i){\n    invfc[i]*=invfc[i-1];\n    invfc[i]%=mdl;\n  }\n}\n\nstring s;\nVI l,r;\nVI wys[2];\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  inifc();\n  in n,m;\n  cin>>n>>m;\n  cin>>s;\n  in tl,tr;\n  in prr=-3;\n  forn(z,m){\n    cin>>tl>>tr;\n    --tl;\n    --tr;\n    if(tr<=prr)\n      continue;\n    prr=tr;\n    l.PB(tl);\n    r.PB(tr);\n  }\n  l.PB(n);\n  r.PB(n-1);\n  forn(z,2)\n    wys[z].resize(n+3);\n  in nw=0;\n  in sw=1;\n  wys[nw][0]=1;\n  in cl=0;\n  in cr=0;\n  in nus;\n  forv(z,l){\n    swap(nw,sw);\n    forn(i,n+1){\n      wys[sw][i]%=mdl;\n      wys[nw][i]=0;\n    }\n    if(cr<=l[z]){\n      nus=0;\n      for(in i=l[z];i<=r[z];++i){\n\tif(s[i]=='1')\n\t  ++nus;\n      }\n      forn(i,n+1){\n\twys[nw][nus]+=wys[sw][i]*ncr(cr-cl,i);\n\twys[nw][nus]%=mdl;\n      }\n      cl=l[z];\n      cr=r[z]+1;\n      continue;\n    }\n    in csz=cr-cl;\n    if(cl<l[z]){\n      forn(i,csz+1){\n\tif(i)\n\t  wys[nw][i-1]+=wys[sw][i];\n\tif(i!=csz)\n\t  wys[nw][i]+=wys[sw][i];\n      }\n      ++cl;\n      --z;\n      continue;\n    }\n    if(cr<=r[z]){\n      forn(i,csz+1){\n\twys[nw][i+(s[cr]=='1')]+=wys[sw][i];\n      }\n      ++cr;\n      --z;\n      continue;\n    }\n    forn(i,csz+1)\n      wys[nw][i]=wys[sw][i];\n  }\n  in sm=wys[nw][0];\n  sm%=mdl;\n  if(sm<0)\n    sm+=mdl;\n  cout<<sm<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pw(x) (1ll << (x))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,l,r) for(int i=(l);i<(r);++i)\n#define per(i,l,r) for(int i=(r)-1;i>=(l);--i)\n#define dd(x) cout << #x << \" = \" << x << \", \"\n#define de(x) cout << #x << \" = \" << x << endl\n\n//-----\nconst int N = 3e3 + 7, MOD = 1e9 + 7;\nint add(int a, int b) { if ((a += b) >= MOD) a -= MOD; return a; }\nint mul(int a, int b) { return ll(a) * b % MOD; }\nint n, m, sum[N], l[N], r[N], dp[N][N], C[N][N];\nint qry(int l, int r) { return sum[r] - sum[l - 1]; }\nstring s;\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\trep(i, 0, N) C[i][0] = 1;\n\trep(i, 1, N) rep(j, 1, i + 1) C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);\n\t//rep(i, 0, 10) rep(j,0 , i + 1) cout << C[i][j] << \" \\n\"[j == i];\n  cin >> n >> m >> s;\n  int _m = 1;\n  rep(i, 1, m + 1) {\n  \tcin >> l[_m] >> r[_m];\n  \t_m += r[_m] > r[_m - 1];\n\t}\n\tm = _m - 1;\n  rep(i, 1, n + 1) sum[i] = sum[i - 1] + (s[i - 1] == '1');\n  dp[1][qry(l[1], r[1])] = 1;\n\trep(i, 1, m) {\n\t\trep(j, 0, n + 1) if (dp[i][j]) {\n\t\t\tint &dij = dp[i][j];\n\t\t\trep(k, max(0, j - l[i + 1] + l[i]), max(0, min(r[i] - l[i + 1] + 1, j)) + 1) {\n\t\t\t\tint &d = dp[i + 1][k + qry(max(r[i] + 1, l[i + 1]), r[i + 1])]; \n\t\t\t\td = add(d, mul(dij, C[min(r[i] + 1, l[i + 1]) - l[i]][j - k]));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, 0, r[m] - l[m] + 2) ans = add(ans, mul(dp[m][i], C[r[m] - l[m] + 1][i]));\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\nconst int P=1e9+7,N=3007;\nchar s0[N];\nint n,m,rs[N],p=0,f[N],ans=1;\ninline int fix(int x){return x-=P,x+(x>>31&P);}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s0+1);\n\tfor(int i=1;i<=n;++i)rs[i]=i;\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(y>rs[x])rs[x]=y;\n\t}\n\tf[0]=1;\n\tfor(int i=1,mr=0;i<=n;++i){\n\t\tif(rs[i]>mr){\n\t\t\tint c1=0;\n\t\t\tfor(int j=mr+1;j<=rs[i];++j)c1+=s0[j]-'0';\n\t\t\tif(c1)for(int j=mr-i+1;j>=0;--j)f[j+c1]=f[j],f[j]=0;\n\t\t\tmr=rs[i];\n\t\t}\n\t\tfor(int j=0;j<=mr-i;++j)f[j]=fix(f[j]+f[j+1]);\n\t\tf[mr-i+1]=0;\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n// #define dump(x)  cerr << #x << \" = \" << (x) << endl\n\n// #ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << ' ' << H; debug_out(T...); }\n#define debug(...) cerr << 'L' << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << 'L' << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n// #else\n// #define debug(...) (void(0))\n// #define dump(x) (void(0))\n// #endif\n\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    int &l = lm[i];\n    int &r = rm[i];\n    rep(j, l+1) tmp[l+1] += dp[j];\n    rep2(j, l+1, r+1) tmp[j+1] = tmp[j] + dp[j];\n    swap(dp, tmp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3005;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3010\n#define mod 1000000007\nusing namespace std;\nint dp[maxn][maxn],n,m,l[maxn],r[maxn],tp,s[maxn],C[maxn][maxn];\nchar ss[maxn];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(int i=1;i<=n;++i)\n\t\ts[i]=s[i-1]+(ss[i]=='1');\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tif(l[i]==l[tp])r[tp]=max(r[tp],r[i]);\n\t\telse if(r[tp]<r[i])l[++tp]=l[i],r[tp]=r[i];\n\t}\n\tdp[1][s[r[1]]-s[l[1]-1]]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=*C[i]=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tfor(int i=2;i<=tp;++i){\n\t\tint k=s[r[i]]-s[max(l[i]-1,r[i-1])],A=min(r[i-1]+1,l[i])-l[i-1],len=r[i-1]-l[i-1]+1,len2=r[i]-l[i]+1;\n\t\tfor(int j=k;j<=len2&&j<=max(0,r[i-1]-l[i]+1)+k;++j)\n\t\t\tfor(int a=0;a<=A&&a+j-k<=len;++a)\n\t\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[i-1][a+j-k]*C[A][a])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=r[tp]-l[tp]+1;++i)\n\t\tans=(ans+1ll*dp[tp][i]*C[r[tp]-l[tp]+1][i])%mod;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-(r[i]-l[i+1]+1));j<=sum[r[i]];j++)\n\t{\n\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(l[i+1]-l[i],j-k))%mo;\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=3005,mod=1e9+7;;\nint f[maxn][maxn],C[maxn][maxn];\ninline void prprpr(){\n\trep(i,0,3000){\n\t\tC[i][0]=1;\n\t\trep(j,1,3000)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n}\ninline int powmod(int a,int b){\n\tint res=1;for(;b;b>>=1){\n\t\tif(b&1)res=1ll*res*a%mod;a=1ll*a*a%mod;\n\t}return res;\n}\nint n;char s[maxn];\nint sum[maxn];\nint lpos[maxn],rpos[maxn],tot;\nint main(){\n\t// judge();\n\tprprpr();\n\tread(n);read(tot);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n)sum[i]=sum[i-1]+(s[i]=='1');\n\trep(i,1,tot){\n\t\tread(lpos[i]),read(rpos[i]);\n\t\tif(rpos[i]<=rpos[i-1])\n\t\t\ti--,tot--;\n\t\telse if (lpos[i]==lpos[i-1]){\n\t\t\trpos[i-1]=rpos[i];\n\t\t\ti--;tot--;\n\t\t}\n\t}\n\tlpos[tot+1]=n+1;\n\tf[0][0]=1;int lq=0,rq=0;\n\trep(i,1,tot){\n\t\tint nl=min(lpos[i+1],rpos[i]+1);\n\t\tint num=sum[rpos[i]]-sum[max(lpos[i]-1,rpos[i-1])];\n\t\tint len1=nl-lpos[i],len2=rpos[i]-nl+1;\n\t\tint nlq=max(lq+num-len1,0),nrq=min(rq+num,len2);\n\t\trep(j,nlq,nrq){\n\t\t\tint tmp=0;\n\t\t\trep(k,max(lq,j-num),min(rq,len1+j-num)){\n\t\t\t\ttmp=(tmp+1ll*f[i-1][k]*C[len1][k+num-j])%mod;\n\t\t\t}\n\t\t\tf[i][j]=tmp;\n\t\t}lq=nlq;rq=nrq;\n\t}\n\tprintf(\"%d\\n\",f[tot][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define C(n,m) ((LL)fac[n]*ifac[m]%mo*ifac[(n)-(m)]%mo)\n\nconst int maxn=3010;\nconst int mo=1e9+7;\n\nint n,m,m0,l[maxn],r[maxn];\nint fac[6010],ifac[6010],dp[maxn][maxn];\nbool s[maxn];\n\nint power(int x,int k)\n{\n\tint res=1;\n\twhile (k)\n\t{\n\t\tif (k&1) res=(LL)res*x%mo;\n\t\tx=(LL)x*x%mo;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tchar c;\n\n\tfac[0]=1;\n\tfor (i=1;i<=6000;i++)\n\t\tfac[i]=(LL)fac[i-1]*i%mo;\n\tifac[6000]=power(fac[6000],mo-2);\n\tfor (i=6000;i>=1;i--)\n\t\tifac[i-1]=(LL)ifac[i]*i%mo;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tc=getchar();\n\t\twhile (c!='0'&&c!='1') c=getchar();\n\t\ts[i]=c=='1';\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tif (r[i]>r[m0])\n\t\t\tm0++,l[m0]=l[i],r[m0]=r[i];\n\t}\n\tm=m0;\n\tl[m+1]=r[m+1]=2333333;\n\n\tint p=1;\n\tdp[1][0]=1;\n\tfor (i=1;i<=m;i++)\n\t{\n//\t\tprintf(\"i=%d\\n\",i);\n\t\tint cnt=0;\n\t\tp=max(p,l[i]);\n\t\twhile (p<=r[i]) cnt+=s[p++];\n\t\tfor (j=0;j<=n;j++) if (dp[i][j])\n\t\t{\n\t\t\tint R=max(0,r[i]-l[i+1]+1);\n\t\t\tint L=r[i]-l[i]+1-R;\n\t\t\tfor (int k=max(0,cnt+j-L);k<=R&&k<=cnt+j;k++)\n\t\t\t\t(dp[i+1][k]+=(LL)dp[i][j]*C(L,cnt+j-k)%mo)%=mo;\n\t\t}\n//\t\tputs(\"\"); puts(\"\");\n\t}\n\tprintf(\"%d\\n\",dp[m+1][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > p;\n\tint cur = -1;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tif( i > 0 && p.back().first == xx ){\n\t\t\tif( p.back().second < yy ){\n\t\t\t\tp.pop_back();\n\t\t\t}\n\t\t}\n\t\tif( cur < yy ){\n\t\t\tp.pb(mp(xx,yy));\n\t\t\tcur = yy;\n\t\t}\n\t}\n\tvector<int> lefs;\n\tfor(int i=0;i<p.size();i++){ lefs.pb(p[i].first); }\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tdp[i][ct[i]] += dp[i-1][ct[i-1]];\n\t\t\tdp[i][ct[i]] %= inf;\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 3333\n#define mod 1000000007\n\nint n,m,a[N],r[N],f[N][N];\nchar s[N];\n\nvoid pls(int &x,int y){x=(x+y)%mod;}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();m=read();scanf(\" %s\",s+1);\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=a[i-1]+(s[i]=='1');\n\tfor (int i=1;i<=m;i++){\n\t\tint x=read(),y=read();\n\t\tr[x]=max(r[x],y);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tr[i]=max(max(r[i-1],r[i]),i);\n\tf[0][0]=1;\n\tfor (int i=0;i<n;i++)\n\t\tfor (int j=0;j<=n;j++){\n\t\t\tif (j+a[r[i+1]]-a[r[i]]) pls(f[i+1][j+a[r[i+1]]-a[r[i]]-1],f[i][j]);\n\t\t\tif (r[i+1]-i-j-a[r[i+1]]+a[r[i]]) pls(f[i+1][j+a[r[i+1]]-a[r[i]]],f[i][j]);\n\t\t}\n\tprintf(\"%d\\n\",(f[n][0]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define NMAX 3005\n#define MMAX 3005\n#define mod 1000000007\n#define PIE 3.14159265358979\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N,M;\nstring S;\nint l[MMAX],r[MMAX];\n\nLL mpow(LL a,LL n){\n    LL ans = 1;\n    while(n>0){\n        if(n&1){ans=(ans*a)%mod;}\n        a=(a*a)%mod;\n        n>>=1;\n    }\n    return ans;\n}\n\nLL fact[NMAX+1];\nLL factinv[NMAX+1];\n\nLL comb(LL a,LL b){\n    LL ret = (fact[a]*factinv[b])%mod;\n    ret = (ret*factinv[a-b])%mod;\n    return ret;\n}\n\nvoid init(){\n    fact[0]=1;\n    rep(i,NMAX){\n        fact[i+1]=fact[i]*(i+1);\n        fact[i+1]%=mod;\n    }\n    rep(i,NMAX+1){\n        factinv[i]=mpow(fact[i],mod-2);\n    }\n}\n\nLL dfs(int step,int czero){\n    if(step==M)return 1;\n    int rp=0,ln=N;\n    int l_=l[step];\n    int r_=r[step];\n    if(step>0){\n        rp=r[step-1];\n    }\n    if(step<M-1){\n        ln=l[step+1];\n    }\n    for(int i = max(l_,rp);i < r_;i++){\n        if(S[i]=='0')czero++;\n    }\n    if(ln>=r_){\n        return (comb(r-l,czero)*dfs(step+1,0))%mod;\n    }\n    LL ans = 0;\n    int nczeromax=min(r_-ln,czero);\n    for(int nczero = max(0,czero-(ln-l_));nczero<=nczeromax;nczero++){\n        ans += comb(ln-l_,czero-nczero)*dfs(step+1,nczero);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main(){\n    init();\n    cin>>N>>M;\n    cin>>S;\n    int now = 0;\n    int M_=M;\n    rep(i,M_){\n        cin>>l[now]>>r[now];\n        r[now]++;\n        if(i==0){now++;}\n        else if(l[now]==l[now-1]){\n            M--;\n            r[now-1]=max(r[now],r[now-1]);\n        }else{\n            now++;\n        }\n    }\n    cout<<dfs(0,0)<<endl;\n//    rep(i,M){\n//        cout<<l[i]<<\" \"<<r[i];\n//    }\n    init();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    dp[0][0] = 1;\n    queue<pair<int, int>> q;\n    rep (i, n) {\n        memo[0] = memo[1] = 0;\n        rep (j, n) {\n            if (R[j] < i) memo[s[j] == '1']++;\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] %= mod, dp[j+1][i-j] %= mod;\n        }\n    }\n    // rep (i, 4) {\n    //     rep (j, 3) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // rep (i, n) cout << cnt[0][i] << \" \"; cout << endl;\n    // rep (i, n) cout << cnt[1][i] << \" \"; cout << endl;\n    int ans = 0;\n    rep (i, n + 1) {\n        ans += dp[i][n-i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define Max 3005\n#define int long long\n#define Mod 1000000007\nusing namespace std;\nil int read()\n{\n\tchar c=getchar();\n\tint x=0,f=1;\n\twhile(c>'9'||c<'0')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nchar s[Max];\nint n,m,r[Max],l[Max],cnt;\nint f[Max][Max];\nsigned main()\n{\n\tn=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n+1;i++)\n\t{\n\t\tl[i]=l[i-1]+(s[i]=='1');\n\t\tr[i]=i;\n\t\tcnt+=(s[i]=='1');\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tr[x]=max(y,r[x]);\n\t}\n\tfor(int i=1;i<=n;i++) r[i]=max(r[i],r[i-1]);\n\tf[1][l[r[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\t{\n\t\t\tif(f[i][j])\n\t\t\t{\n\t\t\t\tint a=l[r[i]],b=l[r[i+1]];\n\t\t\t\tif(r[i]-i+1-j) (f[i+1][j+b-a]+=f[i][j])%=Mod;//,puts(\"qwq1\");\n\t\t\t\tif(j) (f[i+1][j+b-a-1]+=f[i][j])%=Mod;//,puts(\"qwq2\");\n\t\t\t\t//cout<<i<<' '<<j<<endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(f[n+1][0]+Mod)%Mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tconst int mod = 1e9 + 7;\n\tint n, m; cin >> n >> m;\n\tvector<vector<int>> C(n + 1, vector<int>(n + 1, 0));\n\tfor (int i = 0; i <= n; i++) for (int j = 0; j <= i; j++) {\n\t\tif (j == 0 || j == i) C[i][j] = 1;\n\t\telse C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n\t}\n\tstring s; cin >> s;\n\tvector<int> cnt(n, 0);\n\tfor (int i = 0; i < n; i++) cnt[i] = (i == 0 ? 0 : cnt[i - 1]) + (s[i] == '1');\n\tvector<pair<int, int>> q(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> q[i].first >> q[i].second;\n\t\tq[i].first--; q[i].second--;\n\t}\n\tsort(q.begin(), q.end(), [&](const pair<int, int>& l, const pair<int, int>& r) {\n\t\tif (l.first == r.first) return l.second > r.second;\n\t\treturn l.first < r.first;\n\t});\n\tfor (int i = 1; i < m; i++) {\n\t\tif (q[i].second <= q[i - 1].second) {\n\t\t\tm--;\n\t\t\tfor (int j = i; j < m; j++) q[j] = q[j + 1];\n\t\t}\n\t}\n\tq.resize(m + 1);\n\tfor (int i = m; i > 0; i--) q[i] = q[i - 1];\n\tvector<vector<int>> f(m + 1, vector<int>(n + 1, 0));\n\tauto getcount = [&](int l, int r) {\n\t\tif (l == 0) return cnt[r];\n\t\treturn cnt[r] - cnt[l - 1];\n\t};\n\tvector<int> pw2(n + 1, 1);\n\tfor (int i = 1; i <= n; i++) pw2[i] = pw2[i - 1] * 2 % mod;\n\tvector<int> seg(m + 1, 0);\n\tvector<int> tot(m + 1, 0);\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (i != m && q[i].second >= q[i + 1].first) seg[i] = q[i + 1].first - q[i].first;\n\t\telse seg[i] = q[i].second - q[i].first + 1;\n\t\tif (i != 1 && q[i].first <= q[i - 1].second) tot[i] = tot[i - 1] + getcount(q[i - 1].second + 1, q[i].second);\n\t\telse tot[i] = getcount(q[i].first, q[i].second);\n\t}\n\tlong long ans = 1;\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint t = tot[i];\n\t\tint jmn = t - (q[i].second - q[i].first + 1 - seg[i]);\n\t\tfor (int j = max(0, jmn); j <= t; j++) {\n\t\t\tfor (int k = 0; k <= seg[i] && k <= j; k++) {\n\t\t\t\tf[i][j] = (f[i][j] + (long long)f[i - 1][j - k] * C[seg[i]][k]) % mod;\n\t\t\t}\n\t\t}\n\t\tif (i == m || q[i].second < q[i + 1].first) {\n\t\t\tans = ans * f[i][t] % mod;\n\t\t\tfor (int j = 0; j <= t; j++) f[i][j] = 0;\n\t\t\tf[i][0] = 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) 0;\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n// using mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\n// require gcc >= 7.1.0\ntemplate < class ... Keys >\nclass fmt_t {\n    using storage_t = std::tuple< Keys ... >;\n    storage_t storage;\n    static constexpr std::size_t N = sizeof ... (Keys);\n\n    // is_exact_match_impl\n    template < std::size_t I, class Value >\n      auto is_exact_match_impl(long, Value) const\n        { return false; }\n\n    template < std::size_t I, class Value,\n      std::enable_if_t<\n        std::is_same< std::decay_t< Value > , char >::value\n        == std::is_same< std::tuple_element_t< I, storage_t >, char >::value,\n      std::nullptr_t > = nullptr,\n      class = decltype(std::declval< Value >() == std::get< I >(std::declval< storage_t >())) >\n      auto is_exact_match_impl(int, Value x) const\n        { return x == std::get< I >(storage); }\n\n    template < class Value, std::size_t ... Is >\n      auto find_exact_match_impl(Value x, std::integer_sequence< std::size_t, Is ... >) const {\n        auto ret = false;\n        (void)std::initializer_list< std::nullptr_t >\n          { (ret |= is_exact_match_impl< Is >(int{}, x), nullptr) ...  };\n        return ret;\n      }\n\n    template < class Value >\n      auto exists_exact_match(Value x) const\n      {  return find_exact_match_impl(x, std::make_index_sequence< N >()); }\n\n    // tuple_format_impl\n    template < class Tuple,  std::size_t ... Is >\n    std::string tuple_format_impl(const Tuple& tuple, std::integer_sequence< std::size_t, Is ... >) const {\n      std::string ret = \"(\";\n      (void)std::initializer_list< std::nullptr_t >\n        { (ret = ret + (Is == 0 ? \"\" : \",\") + format(std::get< Is >(tuple)), nullptr) ... };\n      return ret + \")\";\n    }\n\n    // usual_format\n    template < class Value >\n    std::string usual_format(long, Value x) const\n      { return std::to_string(x); }\n\n    template < class Value, std::enable_if_t< std::is_same< std::decay_t< Value >, char >::value, std::nullptr_t > = nullptr >\n    std::string usual_format(int, Value c) const\n      { return std::string{'\\''} + std::string{c} + std::string{'\\''}; }\n\n    std::string usual_format(int, char const* s) const\n      { return \"\\\"\" + std::string(s) + \"\\\"\"; }\n\n    std::string usual_format(int, std::string const s) const\n      { return \"\\\"\" + s + \"\\\"\"; }\n\n    template < class Container, class = typename Container::value_type >\n    std::string usual_format(int, Container const & v) const {\n      return \"{\" + std::accumulate(v.begin(), v .end(), std::string{},\n        [this](auto const& s, auto const x) { return s + (s.empty() ? \"\" : \",\") + this->format(x); })\n        + \"}\";\n    }\n\n    template < class Tuple, std::size_t N = std::tuple_size< Tuple >::value >\n    std::string usual_format(int, Tuple const& tuple) const\n      { return tuple_format_impl(tuple, std::make_index_sequence< N >()); }\n\n    // format\n    template < class Value > std::string format(Value&& x) const\n      { return exists_exact_match(x) ? std::string{'_'} : usual_format(int{}, x); }\n\n  public:\n    fmt_t()=default;\n    template < Keys ... > fmt_t(Keys&& ... keys ) : storage(keys ... ){}\n\n    template < class Value > std::string operator()(Value&& x) const\n      { return format(x); }\n};\ntemplate < class ... Keys > auto fmt(Keys&& ... keys)\n  { return fmt_t< Keys ... >(std::forward< Keys >(keys) ... ); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, m; std::cin >> n >> m;\n  std::string s; std::cin >> s;\n  std::vector< int > stretch(n+1);\n  std::iota(all(stretch), 0);\n  loop(m) {\n    int l, r; std::cin >> l >> r;\n    cmx(stretch.at(l), r);\n  }\n  rep(i,0,n) {\n    cmx(stretch.at(i+1), stretch.at(i));\n  }\n  // debug(stretch);\n  std::vector< mint > dp(n+1, 0);\n  dp.at(0) = 1;\n  int zero = 0, one = 0;\n  int len_ = 0;\n  rep(len, 1, n+1) {\n    while (len_ < stretch.at(len)) {\n      char c = s.at(len_);\n      len_++;\n      (c == '1' ? one : zero)++;\n    }\n    // debug(len_, zero, one);\n    int min = len - zero, max = one;\n    // debug(len, min, max);\n\n    for (int i = n; i > 0; i--) {\n      dp.at(i) += dp.at(i-1);\n    }\n    rep(i,0,n+1) {\n      if (i < min || max < i) dp.at(i) = 0;\n    }\n    // debug((dp));\n  }\n  assert(zero == std::count(all(s), '0'));\n  assert(one == std::count(all(s), '1'));\n  mint ans = dp.at(one);\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<int MOD>\nstruct ModInt {\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int getInt() const { return (int)x; }\n    template<class T> T get() const { return (T)x; }\n    inline int mod() const { return MOD; }\n    ModInt(int y=0) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % (unsigned long long)MOD; else x = y; }\n    ModInt &operator+=(const ModInt &y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &y) { if ((x += MOD - y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &y) { x = (unsigned long long)x * y.x % (unsigned long long)MOD; return *this; }\n    ModInt &operator/=(const ModInt &y) { x = (unsigned long long)x * y.inv().x % (unsigned long long)MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n};\nconst LL MOD = 1000000007;\ntypedef ModInt<MOD> Mint;\nMint operator+(Mint x, const Mint &y) { if ((x.x += y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator-(Mint x, const Mint &y) { if ((x.x += x.mod() - y.x) >= (unsigned)x.mod()) x.x -= x.mod(); return x; }\nMint operator*(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.x % (unsigned long long)x.mod(); return x; }\nMint operator/(Mint x, const Mint &y) { x.x = (unsigned long long)x.x * y.inv().x % (unsigned long long)x.mod(); return x; }\nbool operator<(const Mint &x, const Mint &y) { return x.x < y.x; }\nbool operator==(const Mint &x, const Mint &y) { return x.x == y.x; }\nbool operator!=(const Mint &x, const Mint &y) { return x.x != y.x; }\n\nint N, M;\nchar S[3111];\nint A[3111];\nint L[3111], R[3111];\nint hi[3111], lo[3111];\n\nMint dp[3111][3111];\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    scanf(\"%s\", S);\n    REP (i, M) scanf(\"%d%d\", L+i, R+i), L[i]--;\n\n    memset(A, 0, sizeof A);\n    REP (i, N) if (S[i] == '1') A[i] = 1;\n    REP (i, M) sort(A+L[i], A+R[i]);\n    int cnt = 0;\n    REP (i, N) if (A[i] == 1) hi[cnt++] = i+1;\n\n    memset(A, 0, sizeof A);\n    REP (i, N) if (S[i] == '1') A[i] = -1;\n    REP (i, M) sort(A+L[i], A+R[i]);\n    cnt = 0;\n    REP (i, N) if (A[i] == -1) lo[cnt++] = i;\n\n    dp[0][0] = 1;\n\n    REP (i, cnt) {\n\tREP (j, N) if (dp[i][j].x) {\n\t    for (int k=max(j, lo[i]); k<hi[i]; k++)\n\t\tdp[i+1][k+1] += dp[i][j];\n\t}\n    }\n\n    Mint ans = 0;\n    REP (j, N+1) ans += dp[cnt][j];\n    printf(\"%d\\n\", ans.getInt());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1]+s[i]-'0';\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tq[m+1].l=n+1;q[m+1].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[1][sum[q[2].r]-sum[q[2].l-1]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i+1].r-q[i].l+1;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=LEN;j++)\n\t\t\t\tfor(int k=0;k<=len;k++){\n\t\t\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\t\t\tif(pre>=j-k&&j>=k)dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=6005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]])q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j+t<=jb&&j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<f[m][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tfor (int i=1;i<=top;i++) \n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++) for (int j=r[i-1]+1;j<l[i];j++) sum[j]=0;\n\tfor (int i=1;i<=n;i++) sum[i]+=sum[i-1];\n\t\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\t//if (l[i]<=r[i-1])\n\t\t//{\n\t\t\tfor (int k=max(0,l[i]-min(l[i+1],r[i]+1)+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(min(l[i+1],r[i]+1)-l[i],j-k))%mo;\n\t\t//}\n\t\t//else f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 3000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nint n, m, a[N], dp[N][N], DP[N], mark[N], ps[N], nCr[N][N], PS[N];\nstruct SEG{\n\tint l, r;\n};\nvector<SEG> seg1, seg;\nvector<int> koj[N];\n\nvoid calc(){\n\tnCr[0][0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\tnCr[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++){\n\t\t\tnCr[i][j] = nCr[i - 1][j - 1] + nCr[i - 1][j];\n\t\t\tnCr[i][j] %= MOD;\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcalc();\n\tcin >> n >> m;\n\t//cout << nCr[6][3] << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tPS[i] = PS[i - 1];\n\t\tPS[i] += a[i];\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tSEG a;\n\t\tcin >> a.l >> a.r;\n\t\tseg1.pb(a);\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (seg1[i - 1].l <= seg1[j - 1].l && seg1[j - 1].r <= seg1[i - 1].r) mark[j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tif (!mark[i]) seg.pb(seg1[i - 1]);\n\t}\n\tfor (auto u:seg){\n\t\tkoj[u.l].pb(u.r);\n\t\t//cout << u.l << ' ' << u.r << '\\n';\n\t\tps[u.l]++;\n\t\tps[u.r + 1] --;\n\t}\n\tfor (int i = 1; i <= n; i++) ps[i] += ps[i - 1];\n\tDP[n + 1] = 1;\n\tint last = n + 1;\n\tfor (int i = n; i >= 1; i--){\n\t\tif (ps[i] == 0) DP[i] = DP[i + 1];\n\t\telse if(koj[i].size() == 0) DP[i] = DP[i + 1];\n\t\telse{\n\t\t\tif (last <= koj[i][0]){\n\t\t\t\tfor (int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tfor (int k = max(0ll, j - (koj[i][0] - last + 1)); k <= min(j, last - i); k++){\n\t\t\t\t\t\t//if (i == 4 && j == 3) cout << k << ' ' << dp[last][j - k + PS[koj[last][0]] - PS[koj[i][0]]] << ' ' <<  nCr[last - i][k] << '\\n';\n\t\t\t\t\t\tdp[i][j] %= MOD;;\n\t\t\t\t\t\tdp[i][j] += (dp[last][j - k + PS[koj[last][0]] - PS[koj[i][0]]] * 1ll * nCr[last - i][k]) % MOD;\n\t\t\t\t\t\tdp[i][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tdp[i][j] = nCr[koj[i][0] - i + 1][j] * 1ll * DP[koj[i][0] + 1] % MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDP[i] = dp[i][PS[koj[i][0]] - PS[i - 1]];\n\t\t\tlast = i;\n\t\t}\n\t\t//cout << i << ' ' << DP[i] << '\\n';\n\t}\n\tcout << DP[1];\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint n, m, sum[MAXN], rbd[MAXN];\nint dp[MAXN][MAXN];\n\ninline int Inc(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\n\nvoid init() {\n\tread(n); read(m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i=1;i<=n;++i) {\n\t\tsum[i] = sum[i-1] + s[i] - '0';\n\t\trbd[i] = i;\n\t}\n\tsum[n+1] = sum[n]; rbd[n+1] = n+1;\n\tfor (int i=1;i<=m;++i) {\n\t\tint l, r;\n\t\tread(l); read(r);\n\t\tcmax(rbd[l], r);\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tcmax(rbd[i], rbd[i-1]);\n\t}\n}\n\nvoid solvee() {\n\tdp[1][sum[rbd[1]]] = 1;\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=0;j<=n;++j) {\n\t\t\tint x = dp[i][j];\n\t\t\tif (!x) continue;\n\t\t\tint l = rbd[i], r = rbd[i+1];\n\t\t\tint cnt1 = j, cnt0 = rbd[i] - i + 1 - j;\n\t\t\tif (cnt0) Inc(dp[i+1][j+sum[r]-sum[l-1]], x);\n\t\t\tif (cnt1) Inc(dp[i+1][j-1+sum[r]-sum[l-1]], x);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n+1][0]);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid read(int &x) {\n    char ch; bool ok;\n    for(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n    for(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=3010,mod=1e9+7;\nchar ch[maxn];\nint n,m,f[maxn][maxn],tot,sum[maxn],las[maxn];\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint main()\n{\n    read(n),read(m);scanf(\"%s\",ch+1);\n    for(rg int i=1;i<=n+1;i++){\n        sum[i]=sum[i-1],las[i]=i;\n        if(ch[i]=='1')tot++,sum[i]++;\n    }\n    for(rg int i=1,x,y;i<=m;i++)read(x),read(y),las[x]=max(las[x],y);\n    for(rg int i=1;i<=n+1;i++)las[i]=max(las[i],las[i-1]);\n    f[1][sum[las[1]]]=1;\n    for(rg int i=1;i<=n;i++)\n        for(rg int j=0;j<=tot;j++)\n            if(f[i][j]){\n                int a=las[i],b=las[i+1];\n                if(j)f[i+1][j+sum[b]-sum[a]-1]=add(f[i+1][j+sum[b]-sum[a]-1],f[i][j]);\n                if(las[i]+1-i-j)f[i+1][j+sum[b]-sum[a]]=(f[i+1][j+sum[b]-sum[a]],f[i][j]);\n        }\n    printf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass F {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      string s; cin >> s;\n      vector<vector<mint>> dp(n+1, vector<mint>(n+1));\n      dp[0][0] = 1;\n\n      int q = 0;\n      vector<P> vec(m);\n      rep(i, m) {\n        cin >> vec[i].first >> vec[i].second;\n      }\n      int mr = 0;\n      int idx = 0;\n      int zero = 0;\n      int one = 0;\n\n      for(int i=1; i<=n; i++) {\n        while(q < m && vec[q].first <= i) {\n          chmax(mr, (int)vec[q].second);\n          q++;\n        }\n        chmax(mr, i);\n        while(idx < n && idx <= mr-1) {\n          if (s[idx] == '0') {\n            zero++;\n          } else {\n            one++;\n          }\n          idx++;\n        }\n\n        // j: count of one\n        for(int j=0; j<=n; j++) {\n          if (j+1 <= one) dp[i][j+1] += dp[i-1][j];\n          if (i-j <= zero) dp[i][j] += dp[i-1][j];\n        }\n      }\n\n      mint ret = 0;\n      for(int i=0; i<=n; i++) {\n        ret += dp[n][i];\n      }\n      cout << ret.x << endl;\n\n\n\n    }\n};\n\nsigned main() {\n  F solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for(register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for(register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) {return b < a ? a = b, 1 : 0;}\ntemplate<typename T> inline bool chkmax(T &a, T b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x(0), sgn(1); char ch(getchar());\n    for (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n    for (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n    return x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 3010, Mod = 1e9 + 7;\n\nint n, m, R[N], dp[N][N], sum[N];\n\nchar str[N];\n\ninline void Add(int &a, int b) {\n\tif ((a += b) >= Mod) a -= Mod;\n}\n\nint main() {\n\n\tFile();\n\n\tn = read(); m = read();\n\n\tscanf (\"%s\", str + 1);\n\tFor (i, 1, n + 1)\n\t\tsum[i] = sum[i - 1] + (i <= n ? str[i] ^ 48 : 0);\n\tFor (i, 1, m) {\n\t\tint l = read(), r = read(); chkmax(R[l], r);\n\t}\n\tFor (i, 1, n + 1)\n\t\tchkmax(R[i], max(i, R[i - 1]));\n\tdp[1][sum[R[1]]] = 1;\n\n\tFor (i, 1, n) For (j, 0, n) if (dp[i][j]) {\n\t\tint l = R[i] + 1, r = R[i + 1], one = j, zero = (R[i] - i + 1) - j;\n\t\tif (zero) Add(dp[i + 1][j + (sum[r] - sum[l - 1])], dp[i][j]);\n\t\tif (one) Add(dp[i + 1][j + (sum[r] - sum[l - 1]) - 1], dp[i][j]);\n\t}\n\tprintf (\"%d\\n\", dp[n + 1][0]);\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(s) s.begin(), s.end()\n#define pb push_back\n#define ii pair<int, int>\n#define x first\n#define y second\n#define bit(x, y) ((x >> y) & 1)\n\nconst int MOD = 1000000007;\n\nint dp[3005][3005];\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0); \n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    s = \" \" + s;\n    string t = s;\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        cin >> u >> v;\n        sort(s.begin() + u, s.begin() + v + 1);\n        sort(t.begin() + u, t.begin() + v + 1, [](char x, char y) {\n            return x > y;\n        });\n    }\n    vector<int> cntmx(n + 1);\n    vector<int> cntmn(n + 1);\n    for (int i = 1; i <= n; i++) {\n        cntmx[i] = cntmx[i - 1] + (s[i] == '0');\n        cntmn[i] = cntmn[i - 1] + (t[i] == '0');\n    }\n\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        if (cntmn[i] == 0) dp[i][0] = dp[i - 1][0];\n        for (int j = max(cntmn[i], 1); j <= cntmx[i]; j++) {\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i <= 3000; i++) {\n        ans = (ans + dp[n][i]) % MOD;\n    }\n\n    cout << ans;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\n\ntemplate <long long mod>\nstruct modint {\n    long long x;\n\n    modint<mod>(): x(0LL) {}\n    modint<mod>(const long long _data) {\n        if (_data < 0) {\n            x = (_data % mod + mod) % mod;\n        } else if (_data >= mod) {\n            x = _data % mod;\n        } else {\n            x = _data;\n        }\n    }\n\n    bool operator==(const modint<mod>& op) const {\n        return x == op.x;\n    }\n\n    bool operator!=(const modint<mod>& op) const {\n        return !((*this) == op);\n    }\n\n    modint<mod> operator-() const {\n        if (x == 0) {\n            return modint(0);\n        }\n        return modint(mod - x);\n    }\n\n    modint<mod> operator+(const modint<mod>& op) const {\n        const long long newdata = x + op.x;\n        if (newdata >= mod) {\n            return modint<mod>(newdata - mod);\n        } else {\n            return modint<mod>(newdata);\n        }\n    }\n\n    modint<mod> operator-(const modint<mod>& op) const {\n        return *this + (-op);\n    }\n\n    modint<mod> operator*(const modint<mod>& op) const {\n        return modint<mod>(x * op.x % mod);\n    }\n\n    modint<mod> pow(const long long n) const {\n        if (n == 0) {\n            return modint<mod>(1);\n        }\n        modint<mod> sq = pow(n / 2);\n        if (n & 1) {\n            return (*this) * sq * sq;\n        } else {\n            return sq * sq;\n        }\n    }\n\n    modint<mod> inverse() const {\n        return pow(mod - 2);\n    }\n\n    modint<mod> operator/(const modint<mod>& op) const {\n        return (*this) * op.inverse();\n    }\n\n    friend modint<mod> operator/(const long long dividend, const modint<mod>& divisor) {\n        return modint<mod>(dividend) / divisor;\n    }\n\n    static modint<mod> factorial(const long long n) {\n        static std::vector<modint<mod>> cache;\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() * cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> combination(const long long n, const long long k) {\n        if (k < 0 || n < k) {\n            return modint<mod>(0);\n        }\n\n        if (n < 1e6) {\n            return factorial(n) / (factorial(k) * factorial(n - k));\n        }\n\n        modint<mod> ret(1);\n        for (int i = 1; i <= k; ++i) {\n            ret = ret * modint<mod>(n - i + 1) / modint<mod>(i);\n        }\n        return ret;\n    }\n};\n\ntypedef modint<1000000007> mint;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    li n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<li> ops(n);\n    for (int i = 0; i < m; ++i) {\n        li l, r;\n        cin >> l >> r;\n        l--; r--;\n        ops[l] = max(ops[l], r);\n    }\n\n    vector<li> accum(n + 1);\n    for (int i = 0; i < n; ++i) {\n        accum[i + 1] = accum[i] + (s[i] - '0');\n    }\n\n    vector<vector<mint>> dp(n + 1, vector<mint>(n + 1, 0));\n    dp[0][0] = 1;\n    li max_r = 0;\n    for (int i = 0; i < n; ++i) {\n        max_r = max(max_r, ops[i]);\n        const li ones = accum[max_r + 1];\n        const li zeros = max_r + 1 - ones;\n        for (int next_ones = 0; next_ones <= ones; ++next_ones) {\n            const li next_zeros = i + 1 - next_ones;\n            if (next_zeros < 0 || next_zeros > zeros) {\n                continue;\n            }\n            dp[i + 1][next_ones] = dp[i][next_ones];\n            if (next_ones > 0) {\n                dp[i + 1][next_ones] = dp[i + 1][next_ones] + dp[i][next_ones - 1];\n            }\n        }\n\n    }\n\n    cout << dp[n][accum[n]].x << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nll dp[3003][3003];\nvector<vector<ll>> C;\nconst ll mod = 1000000007LL;\nint N,M;\nstring S;\nint bnum[3003];\n\nvector<P> ps;\n\nvector<vector<long long> > Comb(int n){\n  vector<vector<long long> > v(n+1,vector<long long>(n+1));\n  for(int i=0;i<=n;i++) v[i][i] = v[i][0] = 1LL;\n  for(int i=2;i<=n;i++)\n    for(int j=1;j<i;j++)\n      v[i][j] = v[i-1][j] + v[i-1][j-1];\n  return v;\n}\n\nvoid update( ll &a, ll b ){\n  a += b;\n  a %= mod;\n}\n\nll solve(){\n  dp[0][bnum[0]] = 1;\n  for(int i=0;i<M;i++){\n    int l = ps[i].first;\n    int r = ps[i].second;\n    if( i < M-1 ) r = min( r, ps[i+1].first-1 );\n    int nl = ps[i+1].first;\n    int nr = max( nl-1, ps[i].second );\n    for(int j=0;j<=bnum[i];j++){\n      if( !dp[i][j] ) continue;\n      for(int k = max(0,j - (r-l+1)); k <= min( j, nr-nl+1 ); k++ ){\n        update( dp[i+1][j+k], dp[i][j] * C[r-l+1][j-k] );\n      }\n    }\n  }\n  ll res = 0;\n  for(int i=0;i<=N;i++)\n    update( res, dp[M][i] );\n  return res;\n}\n\nint main(){\n  cin >> N >> M;\n  cin >> S;\n  for(int i=0;i<M;i++){\n    int a,b; cin >> a >> b; --a; --b;\n    ps.push_back( P(a,b) );\n  }\n\n  C = Comb( N );\n\n  for(int i=0;i<M-1;i++){\n    if( ps[i].first == ps[i+1].first ) {\n      ps[i] = max( ps[i], ps[i+1] );\n      for(int j=i+1;j<M-1;j++)\n        ps[j] = ps[j+1];\n      --M; --i;\n    }\n  }\n  for(int i=0;i<M;i++){\n    int pp = 0;\n    if( i ) pp = max( pp, ps[i-1].second );\n    for(int j=max( pp, ps[i].first );j<=ps[i].second;j++)\n      if( S[j] == '1' ) bnum[i]++;\n  }\n  cout << solve() << endl;  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> a(n, 0);\n  for(int i = 0; i < m; i++)\n  {\n    int li, ri;\n    cin >> li >> ri;\n    li--;\n    ri--;\n    a[li] = max(a[li], ri);\n  }\n  for(int i = 1; i < n; i++)\n  {\n    a[i] = max(max(a[i], a[i - 1]), i);\n  }\n  vector<int> pref(n);\n  pref[0] = s[0] - '0';\n  for(int i = 1; i < n; i++)\n  {\n    pref[i] = pref[i - 1] + s[i] - '0';\n  }\n  vector<vector<int>> dp(n + 1, vector<int> (n + 1, 0));\n  dp[n][0] = dp[n - 1][0] = dp[n - 1][1] = 1;\n  for(int i = n - 2; i >= 0; i--)\n  {\n    int offset = pref[a[i + 1]] - pref[a[i]], lim = min(n, a[i] - i + 1);\n    for(int j = 0; j <= lim; j++)\n    {\n      if(j == 0)\n      {\n        (dp[i][j] += dp[i + 1][j + offset]) %= MOD;\n      }\n      else if(j == lim)\n      {\n        (dp[i][j] += dp[i + 1][j - 1 + offset]) %= MOD;\n      }\n      else\n      {\n        (dp[i][j] += dp[i + 1][j + offset]) %= MOD;\n        (dp[i][j] += dp[i + 1][j - 1 + offset]) %= MOD;\n      }\n    }\n  }\n  cout << dp[0][pref[a[0]]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\n\tassert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = min(y[i] - rightmost, y[i] - x[i] + 1);\n\t\tfix[i] = min(x[i+1] - x[i], y[i] - x[i] + 1);\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    int pos = -1;\n    dp[0][0] = 1;\n    queue<pair<int, int>> q;\n    rep (i, n) {\n        while (L[++pos] <= i) q.push({pos, s[pos] == '1'});\n        while (R[q.front().first] < i) {\n            memo[q.front().second]++; q.pop();\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] %= mod, dp[j+1][i-j] %= mod;\n        }\n    }\n    // rep (i, 4) {\n    //     rep (j, 3) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // rep (i, n) cout << cnt[0][i] << \" \"; cout << endl;\n    // rep (i, n) cout << cnt[1][i] << \" \"; cout << endl;\n    int ans = 0;\n    rep (i, n + 1) {\n        ans += dp[i][n-i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l[N], r[N], tr[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) {\n\t\tint ll, rr;\n\t\tscanf(\"%d%d\", &ll, &rr);\n\t\ttr[ll] = max(tr[ll], rr);\n\t}\n\tint m0 = 0;\n\tRep(i, n) if (tr[i]){\n\t\tbool flag = true;\n\t\tRep(j, i - 1) if (tr[i] <= tr[j]) flag = false; \n\t\tif (flag) l[++ m0] = i, r[m0] = tr[i];\n\t}\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, r[i] - l[i] + 1) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j]);\n\t\telse {\n\t\t\tRep0(j, r[i] - l[i] + 1) if (f[i][j]){\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, n) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n11 8\n00101000110\n2 4\n2 3\n4 6\n4 7\n5 6\n6 9\n6 10\n10 11\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\n\tassert(zero + one > n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N = 3005, mod = 1e9+7;\n\nll n, m, o[N], b[N], dt[N][N];\nchar a[N];\n\nint main()\n{\n\tscanf(\"%lld%lld%s\",&n,&m,a+1);\n\tfor(ll i=1;i<=n;i++) {\n\t\to[i] = o[i-1] + (a[i] == '1');\n\t}\n\tiota(b, b+n+1, 0);\n\tfor(ll i=1;i<=m;i++) {\n\t\tll S, E;\n\t\tscanf(\"%lld%lld\",&S,&E);\n\t\tfor(ll i=S;i<=E;i++) b[i] = max(b[i], E);\n\t}\n\tdt[0][0] = 1;\n\tfor(ll i=1;i<=n;i++) for(ll j=0;j<=i;j++) {\n\t\tif(j > o[b[i]] || i-j > b[i]-o[b[i]]) continue;\n\t\tdt[i][j] = dt[i-1][j];\n\t\tif(j) dt[i][j] = (dt[i][j] + dt[i-1][j-1]) % mod;\n\t}\n\tprintf(\"%lld\\n\",dt[n][o[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst ll MOD = 1000000007;\nll comb[3010][3010];\nint N, M;\nstring s;\nvector<pii> vec;\nll dp[3010][3010];\nint len[3010];\nint num[3010];\nll ret = 1;\n\nint main() {\n\trep(i, 3010) {\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tcomb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n\t\t}\n\t}\n\n\tscanf(\"%d %d\", &N, &M);\n\tcin >> s;\n\trep(i, N) num[i+1] = num[i] + (s[i] == '0');\n\n\trep(i, M) {\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\t--l; --r;\n\t\tif (vec.size() == 0 || vec.back().se < r) {\n\t\t\tvec.eb(l, r);\n\t\t}\n\t}\n\n\trep(i, vec.size()) len[i] = vec[i].se - vec[i].fi + 1;\n\n\tfor (int i = 0; i < vec.size(); ) {\n\t\trep(j, 3010) dp[i][j] = 0;\n\n\t\tint j = i;\n\t\tint la = vec[i].se;\n\t\twhile (j < M && vec[j].fi <= la) {\n\t\t\tla = vec[j].se;\n\t\t\t++j;\n\t\t}\n\n\t\tif (j - i == 1) {\n\t\t\tint n0 = num[vec[i].se+1] - num[vec[i].fi];\n\t\t\tret = ret * comb[len[i]][n0] % MOD;\n\t\t} else {\n\t\t\tint n0 = num[vec[i].se+1] - num[vec[i].fi];\n\t\t\tint w = vec[i].se - vec[i+1].fi + 1;\n\t\t\t//cout << n0 << w << endl;\n\n\t\t\tfor (int k = 0; k <= min(w, n0); ++k) {\n\t\t\t\tdp[i][k] = comb[vec[i+1].fi-vec[i].fi][n0 - k];\n\t\t\t}\n\n\t\t\t//cout << i << \" \" << j << endl;\n\n\t\t\tfor (int k = i+1; k < j-1; ++k) {\n\t\t\t\tint a0 = num[vec[k].se + 1] - num[vec[k-1].se];\n\t\t\t\t//cout << a0 << endl;\n\n\t\t\t\trep(l, 3010) {\n\t\t\t\t\tif (dp[k-1][l] == 0) continue;\n\t\t\t\t\tint w = vec[k+1].fi - vec[k].fi;\n\t\t\t\t\tfor (int m = 0; m <= min(a0 + l, w); ++m) {\n\t\t\t\t\t\tdp[k][l+a0-m] = (dp[k][l+a0-m] + dp[k-1][l] * comb[w][m]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tll u = 0;\n\t\t\trep(l, 3010) {\n\t\t\t\tif (dp[j-2][l] == 0) continue;\n\t\t\t\tint a0 = num[vec[j-1].se + 1] - num[vec[j-2].se + 1]; \n\t\t\t\t//cout << a0 << endl;\n\t\t\t\tu = (u + dp[j-2][l] * comb[len[j-1]][a0 + l]);\n\t\t\t}\n\t\t\tret = ret * u % MOD;\n\t\t}\n\n\t\ti = j;\n\t}\n\n\tcout << ret << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 3010;\nconst int Mod = 1e9 + 7;\n\nvoid add(int &x, int y){\n\tx += y;\n\tif(x >= Mod) x -= Mod;\n}\n\nint dp[N][N];\nint n, m;\nint L[N], sum[N], R[N];\nchar S[N];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", S + 1);\n\tFor(i, 1, n) sum[i] = sum[i - 1] + (S[i] == '1');\n\tFor(i, 1, m) scanf(\"%d%d\", &L[i], &R[i]);\n\n\tdp[0][0] = 1;\n\tint p = 1, mx = 0;\n\tFor(i, 1, n){\n\t\tmx = max(mx, i);\n\t\twhile(p <= m && L[p] == i){\n\t\t\tmx = max(mx, R[p]);\n\t\t\t++p;\n\t\t}\n\n\t\tFor(j, 0, i - 1){\n\t\t\tint v = dp[i - 1][j];\n\t\t\tif(!v) continue;\n\t\t\tif(j + 1 <= sum[mx]) add(dp[i][j + 1], v);\n\t\t\tif(i - j <= mx - sum[mx]) add(dp[i][j], v);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxm+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nstring s;\nvector<pair<int, int> > vec;\nint r[3005];\nllint dp[3005][3005];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> s;\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tvec.push_back(make_pair(a, b));\n\t}\n\tfor(int i = 1; i < vec.size(); i++){\n\t\tif(vec[i].second <= vec[i-1].second){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(int i = 0; i < vec.size()-1; i++){\n\t\tif(vec[i].first == vec[i+1].first){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\tint cur = 1, prev = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tfor(int j = cur; j < vec[i].first; j++) r[j] = max(j, prev);\n\t\tr[vec[i].first] = vec[i].second;\n\t\tcur = vec[i].first+1;\n\t\tprev = vec[i].second;\n\t}\n\tfor(int j = cur; j <= N; j++) r[j] = prev;\n\tr[N+1] = N;\n\t\n\t//for(int i = 1; i <= N; i++) cout << r[i] << \" \"; cout << endl;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tint Y = 0;\n\t\tfor(int j = r[i]+1; j <= r[i+1]; j++) if(s[j-1] == '1') Y++;\n\t\tfor(int j = 0; j <= N; j++){\n\t\t\tif(j < r[i]-i+1){\n\t\t\t\tdp[i+1][j+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j+Y] %= mod;\n\t\t\t}\n\t\t\tif(j > 0){\n\t\t\t\tdp[i+1][j-1+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j-1+Y] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= 7; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tcout << dp[N+1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2016 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <cassert>\n#include <ctime>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstd::string procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return std::string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        if (ch == '-')\n            f = -1;\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 3e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, M;\nint ub[MAXN];\nint sum[MAXN];\n\nvoid input()\n{\n    read(N); read(M);\n    static char inp[MAXN];\n    scanf(\"%s\", inp + 1);\n    for (int i = 1; i <= N; ++i) {\n        sum[i] = sum[i - 1] + (inp[i] == '1');\n    }\n    for (int i = 1; i <= M; ++i) {\n        int l, r;\n        read(l); read(r);\n        chkmax(ub[l], r);\n    }\n    for (int i = 1; i <= N; ++i) {\n        chkmax(ub[i], std::max(i, ub[i - 1]));\n    }\n}\n\nvoid solve()\n{\n    static int dp[MAXN][MAXN];\n\n    dp[0][0] = 1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (!dp[i][j])\n                continue;\n            int s = sum[ub[i + 1]] - sum[ub[i]];\n            if (j <= ub[i] - i) (dp[i + 1][j + s] += dp[i][j]) %= MOD;\n            if (j - 1 <= ub[i] - i && j >= 1) (dp[i + 1][j - 1 + s] += dp[i][j]) %= MOD;\n        }\n    }\n    int ans = (dp[N][0] + dp[N][1]) % MOD;\n\n    write(ans); putchar('\\n');\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=3e3;\nconst long long Mod=1e9+7;\n#define int long long\nint n,m,f[Max+10][Max+10]={},c[Max+10][Max+10]={},b[Max+10]={},l[Max+10]={},r[Max+10]={};\nstruct kk{\n    int l,r,v;\n} e[Max+10]={};\nchar a[Max+10]={};\nmain(){\n // freopen(\"a.in\",\"r\",stdin);\n//  freopen(\"a.out\",\"w\",stdout);\n    scanf(\"%lld%lld\",&n,&m);\n    scanf(\"%s\",a+1);\n    for(int i=1;i<=n;i++)\n     b[i]=b[i-1]+(a[i]=='1');\n    c[0][0]=c[0][1]=c[1][1]=1;\n    for(int i=2;i<=Max;i++){\n        c[0][i]=c[i][i]=1;\n        for(int j=1;j<i;j++)\n         c[j][i]=(c[j-1][i-1]+c[j][i-1])%Mod;\n    }\n    int Max=0;\n    for(int i=1;i<=m;i++) {\n        scanf(\"%d%d\",&e[i].l,&e[i].r);\n    }\n    for(int i=1;i<=m;i++)\n     for(int j=1;j<=m;j++)\n      if(i!=j&&e[j].l>=e[i].l&&e[j].r<=e[i].r&&!e[i].v) e[j].v=1;\n    int s=0;\n    for(int i=1;i<=m;i++)\n     if(!e[i].v) ++s,l[s]=e[i].l,r[s]=e[i].r;\n    m=s;\n    f[0][0]=1;\n    for(int i=1;i<m;i++){\n        if(l[i+1]>r[i]){\n            for(int j=0;j<=n;j++)\n             f[i][0]+=f[i-1][j]*c[j+b[r[i]]-b[max(r[i-1],l[i]-1)]][r[i]-l[i]+1]%Mod,f[i][0]%=Mod;\n        }else{\n            for(int j=0;j<=r[i]-l[i+1]+1;j++)\n             for(int k=0;k<=n;k++)\n              if(k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j>=0){\n                f[i][j]+=f[i-1][k]*c[k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j][l[i+1]-l[i]]%Mod,f[i][j]%=Mod;\n              }\n        }\n    }    \n    int ans=0; \n     for(int i=0;i<=n;i++)\n      ans+=f[m-1][i]*c[i+b[r[m]]-b[max(r[m-1],l[m]-1)]][r[m]-l[m]+1]%Mod,ans%=Mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<set>\n#define SF scanf\n#define PF printf\n#define MAXN 3010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN][MAXN];\nint n,m;\nchar s[MAXN];\nint end[MAXN],pre[MAXN];\nint main(){\n\tSF(\"%d%d\",&n,&m);\n\tSF(\"%s\",s+1);\n\tfor(int i=1;i<=n+1;i++)\n\t\tpre[i]=pre[i-1]+(s[i]=='1');\n\tint las=1;\n\tint u,v;\n\tfor(int i=1;i<=n+1;i++)\n\t\tend[i]=max(end[i],i);\n\tfor(int i=1;i<=m;i++){\n\t\tSF(\"%d%d\",&u,&v);\t\n\t\tend[u]=max(end[u],v);\n\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tend[i]=max(end[i],end[i-1]);\n\tdp[1][pre[end[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(dp[i][j]){\n\t\t\t\tint l=end[i];\n\t\t\t\tint r=end[i+1];\n\t\t\t\tint one=j;\n\t\t\t\tint zero=end[i]-i+1-j;\n\t\t\t\tif(zero)\n\t\t\t\t\t(dp[i+1][j+pre[r]-pre[l]]+=dp[i][j])%=MOD;\n\t\t\t\tif(one)\n\t\t\t\t\t(dp[i+1][j-1+pre[r]-pre[l]]+=dp[i][j])%=MOD;\n\t\t\t}\n\tPF(\"%lld\",dp[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\n\nconst int N = 3000 + 7, mod = 1e9 + 7;\n\nint c[N], l[N], r[N], n, m, dp[N][N];\n\nstring str;\n\n\nint f(int idx, int one) {\n\tif(idx > n) {\n\t\treturn 1;\n\t}\n\tif(~dp[idx][one]) {\n\t\treturn dp[idx][one];\n\t}\n\tint res = 0;\n\tif(r[idx] - idx >= one) {\n\t\tif(l[idx + 1] != l[idx]) { \n\t\t\tres += f(idx + 1, one + c[r[idx + 1]] - c[r[idx]]); \n\t\t\tres %= mod;\n\t\t} else {\n\t\t\tres += f(idx + 1, one);\n\t\t\tres %= mod;\n\t\t}\n\t}\n\n\tif(one) {\n\t\tif(l[idx + 1] != l[idx]) {\n\t\t\tres += f(idx + 1, one - 1 + c[r[idx + 1]] - c[r[idx]]);\n\t\t\tres %= mod;\n\t\t} else {\n\t\t\tres += f(idx + 1, one - 1);\n\t\t\tres %= mod;\n\t\t}\n\t}\n\t\n\treturn dp[idx][one] = res;\n}\n\nint32_t main() {\n\tios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n >> m >> str;\n\tfor(int i = 1; i <= m; i++) {\n\t\tint lx, rx; cin >> lx >> rx;\n\t\tr[lx] = max(rx, r[lx]);\n\t}\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tr[i] = max(i, r[i]);\n\t\tl[i] = r[l[i - 1]] >= r[i] ? l[i - 1] : i;\n\t\tr[i] = r[l[i]];\n\t\tc[i] = c[i - 1] + (str[i - 1] == '1');\n\t}\n\n\tc[n + 1] = c[n];\n\n\tl[n + 1] = r[n + 1] = n + 1;\n\n\tmemset(dp, -1, sizeof dp);\n\tcout << f(1, c[r[1]]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M;\nstring S;\nvector<int> L, R, T, U;\nint memo[3010][3010];\nbool visited[3010][3010];\nlong long f(int p, int q) {\n\tif (p == N+1) return 1;\n\tif (visited[p][q]) return memo[p][q];\n\tvisited[p][q] = true;\n\tlong long rr = 0;\n\tint qq = T[U[p]] - T[U[p-1]] + q;\n\tint x = U[p]-p+1;\n\tif (qq < x) { // 0\n\t\trr += f(p+1, qq);\n\t}\n\tif (qq > 0) { // 1\n\t\trr += f(p+1, qq-1);\n\t}\n\treturn memo[p][q] = rr % mod;\n}\nint main() {\n\tcin >> N >> M >> S;\n\tL.resize(M);\n\tR.resize(M);\n\tfor (int i = 0; i < M; ++ i) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\tT.resize(N+1, -1);\n\tU.resize(N+1, 0);\n\tfor (int i = 0; i < N; ++ i) {\n\t\tU[i+1] = i+1;\n\t\tT[i+1] = T[i] + (S[i] == '1' ? 1 : 0);\n\t}\n\tfor (int i = 0; i < M; ++ i) {\n\t\tU[L[i]] = max(U[L[i]], R[i]);\n\t}\n\tfor (int i = 0; i < N; ++ i) {\n\t\tU[i+1] = max(U[i+1], U[i]);\n\t}\n\tcout << f(1, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nstring s;\nvector<pair<int, int> > vec;\nint r[3005];\nllint dp[3005][3005];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> s;\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tvec.push_back(make_pair(a, b));\n\t}\n\tfor(int i = 1; i < vec.size(); i++){\n\t\tif(vec[i].second <= vec[i-1].second){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(int i = 0; i < vec.size()-1; i++){\n\t\tif(vec[i].first == vec[i+1].first){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\tint cur = 1, prev = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tfor(int j = cur; j < vec[i].first; j++) r[j] = max(j, prev);\n\t\tr[vec[i].first] = vec[i].second;\n\t\tcur = vec[i].first+1;\n\t\tprev = vec[i].second;\n\t}\n\tfor(int j = cur; j <= N; j++) r[j] = max(j, prev);\n\t\n\t//for(int i = 1; i <= N; i++) cout << r[i] << \" \"; cout << endl;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tint Y = 0;\n\t\tfor(int j = r[i]+1; j <= r[i+1]; j++) if(s[j-1] == '1') Y++;\n\t\tfor(int j = 0; j <= N-Y; j++){\n\t\t\tif(j < r[i]-i+1){\n\t\t\t\tdp[i+1][j+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j+Y] %= mod;\n\t\t\t}\n\t\t\tif(j > 0){\n\t\t\t\tdp[i+1][j-1+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j-1+Y] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= 7; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tcout << dp[N+1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define endl '\\n'\n#define f first\n#define s second\n\n#ifdef SEREZHKA\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T>\nvoid _dbg(const char* _s, T _h) { cerr << _s << \" = \" << _h << \"\\n\"; }\n\ntemplate<typename T, typename... Ts>\nvoid _dbg(const char*_s, T _h, Ts... _t) {\n    int _b = 0;\n    \n    while (((_b += *_s == '(') -= *_s == ')') != 0 || *_s != ',')\n        cerr << *_s++;\n    \n    cerr << \" = \" << _h << \",\";\n    _dbg(_s + 1, _t...);\n}\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7ll;\nconst ll LINF = INF * INF;\nconst int MAXN = static_cast<int>(3e3) + 17;\n\nint n, m, u;\nstring s;\nint R[MAXN];\nint S[MAXN];\nll binomial[MAXN][MAXN], dp[MAXN][MAXN];\nint U[MAXN][MAXN];\n\nbool read() {\n    if (!(cin >> n >> m >> s))\n        return false;\n\n    forn (i, m) {\n        int l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n\n    return true;\n}\n\nll add(ll a, ll b) { return (a += b) >= INF ? a - INF : a; }\n\nll dfs(int i, int cnt, const vector< pair<int, int> >& v) {\n    if (i == sz(v) - 1)\n        return binomial[v[i].s - v[i].f + 1][cnt];\n\n    if (U[i][cnt] == u)\n        return dp[i][cnt];\n\n    U[i][cnt] = u;\n    dp[i][cnt] = 0;\n    ll& res = dp[i][cnt];\n    \n    for (int k = 0; k <= cnt; ++k)\n        if (k <= v[i + 1].f - v[i].f && cnt - k <= v[i].s - v[i + 1].f + 1)\n            res = add(res, dfs(i + 1, cnt - k + S[v[i + 1].s] - S[v[i].s], v) * binomial[v[i + 1].f - v[i].f][k] % INF);\n\n    return dp[i][cnt];\n}\n\nvoid solve() {\n    forn (i, n)\n        S[i + 1] = s[i] - '0';\n\n    forn (i, n)\n        S[i + 1] += S[i];\n\n    binomial[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            binomial[i][j] = add(binomial[i - 1][j], j ? binomial[i - 1][j - 1] : 0ll);\n\n    ll ans = 1ll;\n\n    for (int l = 1; l <= n; ) {\n        if (R[l] == 0) {\n            ++l;\n            continue;\n        }\n\n        int l1 = l, mxr = l1;\n        vector< pair<int, int> > vec;\n\n        for (; l1 <= mxr; ++l1)\n            if (R[l1] > mxr) {\n                mxr = R[l1];\n                vec.pb(mp(l1, R[l1]));\n            }\n\n        ++u;\n        ans = ans * dfs(0, S[vec[0].s] - S[vec[0].f - 1], vec) % INF;\n        l = l1;\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    \n    while (read())\n        solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 3009\nusing namespace std;\nstruct node{ \n\tint l, r;\n\tbool operator < (const node &rhs) const{ \n\t\treturn (l < rhs.l) && (l == rhs.l && r > rhs.r);\n\t}\n}a[maxn];\nint n, m, dp[maxn][maxn], C[maxn][maxn], sum[maxn];\nchar s[maxn];\nconst int MOD = 1e9 + 7;\n\nbool in(int L, int R, int x){\n\treturn L <= x && x <= R;\n}\nlong long solve(int L ,int R){\n\tif(L == R){\n\t\treturn C[R - L + 1][sum[R] - sum[L - 1]];\n\t}\n\n\tfor(int i = 0; i <= sum[a[L].r] - sum[a[L].l - 1]; i++){\n\t\tint part1 = a[L + 1].l - a[L].l;\n\t\tint part2 = a[L].r - a[L].l + 1 - part1;\n\t\tif(i > part2) \n\t\t\tbreak;\n\t\tdp[L][i] = C[part1][sum[a[L].r] - sum[a[L].l - 1] - i];\n\t}\n\n\n\tfor(int i = L + 1; i < R; i++){\n\t\tint part1 = a[i + 1].l - a[i].l;\n\t\tint part2 = a[i].r - a[i].l + 1 - part1;\n\t\tint one = sum[a[i].r] - sum[a[i - 1].r];\n\n\t\tfor(int j = 0; j <= part2; j++){\n\t\t\tfor(int k = max(0, j - one) ; k <= part1 + j - one; k++)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1LL * C[part1][k + one - j] * dp[i - 1][k]) % MOD;\n\t\t}\n\t}\n\n\tint last1 = a[R - 1].r - a[R].l + 1;\n\tint one = sum[a[R].r] - sum[a[R - 1].r];\n\n\tlong long ans = 0;\n\tfor(int k = 0; k <= last1; k++)\n\t\tans = (ans + 1LL * dp[R - 1][k] * C[a[R].r - a[R].l + 1][one + k]) % MOD;\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tscanf(\"%s\", s + 1);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + (s[i] == '1');\n\n\tfor(int i = 0; i <= n; i++){\n\t\tC[i][i] = C[i][0] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n\n\tfor(int i = 1; i <= m; i++){\n\t\tscanf(\"%d%d\", &a[i].l, &a[i].r);\n\t}\n\tsort(a + 1, a + 1 + m);\n\n\tint tot = 0, last = -1;\n\tfor(int i = 1; i <= m; i++){\n\t\tif(a[i].r <= last)\n\t\t\tcontinue;\n\t\t++tot;\n\t\ta[tot] = a[i];\n\t\tlast = a[i].r;\n\t}\n\n\tint cur = 1;\n\tlong long ans = 1;\n\twhile(cur <= tot){\n\t\tint L = cur;\n\t\twhile(cur + 1 <= tot && in(a[cur].l, a[cur].r, a[cur+1].l))\n\t\t\tcur++;\n\t\tint R = cur;\n\t\tans = ans * solve(L, R) % MOD;\n\t\tcur++;\n\t}\n\n\tcout<< ans << endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    int sum[2]; rep (i, 2) sum[i] = 0;\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        sum[s[i] == '1']++;\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    dp[0][0] = 1;\n    rep (i, n) {\n        memo[0] = memo[1] = 0;\n        rep (j, n) {\n            if (R[j] < i) memo[s[j] == '1']++;\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] -= mod * (dp[j][i-j+1] > mod), dp[j+1][i-j] -= mod * (dp[j][i-j+1] > mod);\n        }\n    }\n    cout << dp[sum[0]][sum[1]] << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define N 3050\ninline void upd(ll &x,ll y) {x=(x+y)%mod;}\nll f[N][N];\nint s[N],n,m,rp[N];\nchar w[N];\nint main() {\n\tscanf(\"%d%d%s\",&n,&m,w+1);\n\tint i,j;\n\tfor(i=1;i<=n;i++) s[i]=s[i-1]+w[i]-'0';\n\ts[n+1]=s[n];\n\tfor(i=1;i<=n+1;i++) rp[i]=i;\n\tfor(i=1;i<=m;i++) {\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\trp[l]=max(rp[l],r);\n\t}\n\tfor(i=1;i<=n;i++) rp[i]=max(rp[i],rp[i-1]);\n\tf[1][s[rp[1]]]=1;\n\tfor(i=1;i<=n;i++) {\n\t\tfor(j=0;j<=n;j++) if(f[i][j]) {\n\t\t\tint num=s[rp[i+1]]-s[rp[i]];\n\t\t\tif(j) upd(f[i+1][j-1+num],f[i][j]);\n\t\t\tif(j!=rp[i]-i+1) upd(f[i+1][j+num],f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[n+1][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n\n#define mod 1000000007\nusing namespace std;\n\nlong long dp[3010][3010],a[3010];\nint main(){\n\tstring s;\n\tpair<int,int> p[3010];\n\tint i,j,n,m,mx=0,l,r;\n\tcin >> n >> m >> s;\n\t//p[0] = make_pair(0,0);\n\tj = 0;\n\tfor(i=0;i<m;i++){\n\t\tcin >> l >> r;\n\t\tif(r > mx){\n\t\t\tmx = r;\n\t\t\tp[j] = make_pair(l,r);\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tmx = 0;\n\ta[0] = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tmx++;\n\t\t}\n\t\ta[i+1] = mx;\n\t}\n\t\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\t\n\tmx = 0;\n\tdp[0][0] = 1;\n\tfor(i=1;i<=n;i++){\n\t\tif(p[mx].first==i){\n\t\t\tmx++;\n\t\t}\n\t\tfor(j=0;j<i;j++){\n\t\t\tif(mx==0 || (i<p[mx].first && i>p[mx-1].second)){\n\t\t\t\tif(s[i-1]=='1'){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}else if(s[i-1]=='0'){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}\n\t\t\t}else{// mx>=1 && p[mx-1].first<=i<=p[mx-1].second\n\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\tif(a[p[mx-1].second]<j+1 || a[p[mx-1].second]-(p[mx-1].second-i)>j+1){\n\t\t\t\t\tdp[i][j+1] = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif(a[p[mx-1].second]<j || a[p[mx-1].second]-(p[mx-1].second-i)>j){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][a[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll mo=1000000007;\nll dp[3030][3030];\nint ma[3030];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\t\n\tint CR=0,CL=0;\n\tint B[2]={};\n\tdp[0][0]=1;\n\twhile(M--) {\n\t\tint L,R;\n\t\tcin>>L>>R;\n\t\tL--,R--;\n\t\twhile(CL<L) {\n\t\t\tif(CL==CR) {\n\t\t\t\tB[S[CR]=='1']++;\n\t\t\t\tCR++;\n\t\t\t}\n\t\t\tFOR(i,3001) if(dp[CL][i]) {\n\t\t\t\tint T[2]={i,CL+1-i};\n\t\t\t\tif(i<B[0]) (dp[CL+1][i+1]+=dp[CL][i])%=mo;\n\t\t\t\tif(CL-i<B[1]) (dp[CL+1][i]+=dp[CL][i])%=mo;\n\t\t\t}\n\t\t\tCL++;\n\t\t}\n\t\twhile(CR<=R) {\n\t\t\tB[S[CR]=='1']++;\n\t\t\tCR++;\n\t\t}\n\t}\n\twhile(CL<N) {\n\t\tif(CL==CR) {\n\t\t\tB[S[CR]=='1']++;\n\t\t\tCR++;\n\t\t}\n\t\tFOR(i,3001) if(dp[CL][i]) {\n\t\t\tint T[2]={i,CL+1-i};\n\t\t\tif(i<B[0]) (dp[CL+1][i+1]+=dp[CL][i])%=mo;\n\t\t\tif(CL-i<B[1]) (dp[CL+1][i]+=dp[CL][i])%=mo;\n\t\t}\n\t\tCL++;\n\t}\n\t\n\tcout<<dp[CL][B[0]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3005\n#define Mod 1000000007ll\n#define Val(x) (((long long)x) % Mod)\nusing namespace std;\nstruct op {\n\tint l,r;\n};\nint sum[maxn],C[maxn][maxn];\nint dp[maxn][maxn];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<op> ops;\n\tfor(int i=0,l,r;i<m;i++) {\n\t\tcin >> l >> r;\n\t\tif(!ops.empty() && ops.back().r >= r)\tcontinue;\n\t\tif(!ops.empty() && ops.back().l == l)\tops.pop_back();\n\t\tops.emplace_back(op{l,r});\n\t}\n\t\t\n\treverse(s.begin(),s.end());\n\ts += \"0\";\n\treverse(s.begin(),s.end());\n\tfor(int i=1;i<=n;i++)\n\t\tsum[i] = sum[i-1] + s[i] - '0';\n\t\t\n\tC[1][0] = C[1][1] = 1;\n\tfor(int i=2;i<=n;i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor(int j=1;j<i;j++)\n\t\t\tC[i][j] = Val(C[i-1][j] + C[i-1][j-1]);\n\t}\n\t\n\tm = (int)ops.size();\n\tdp[ops.front().l-1][sum[ops.front().l-1]] = 1;\n\tfor(int i=0;i<m-1;i++) {\n\t\tint l = ops[i].l , r = ops[i].r;\n\t\tint nxt_l = ops[i+1].l;\n\t\tfor(int j=0;j<=l-1;j++) {\n\t\t\tif(dp[l-1][j] == 0)\t\tcontinue;\n\t\t\tint rem = sum[r] - j;\n\t\t\tint len = nxt_l - l , num = min(len,rem);\n\t\t\tfor(int k=0;k<=num;k++)\n\t\t\t\tif(rem - k <= r - nxt_l + 1)\t// won't remain too many '1' in [nxt_l,r]\n\t\t\t\t\tdp[nxt_l-1][j+k] = Val(dp[l-1][j] * C[len][k] + dp[nxt_l-1][j+k]);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++)\n\t\tif(dp[ops.back().l-1][i] != 0)\n\t\t\tans = Val(dp[ops.back().l-1][i] * C[ops.back().r-ops.back().l+1][sum[ops.back().r]-i] + ans);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nmint dp[3030][3030];\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<int> cnt(n + 1, 0);\n    vector<int> right(n, 0);\n    rep(i, m) {\n        int l, r; cin >> l >> r;\n        -- l, -- r;\n        chmax(right[l], r);\n    }\n    int ma = 0;\n    rep(i, n) {\n        chmax(ma, i);\n        chmax(ma, right[i]);\n        right[i] = ma;\n    }\n    rep(i, n) {\n        cnt[i + 1] = cnt[i] + (s[i] == '1');\n    }\n    rep(i, 3030) {\n        rep(j, 3030) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = 1;\n    rep(i, n) {\n        rep(used, n) {\n            int r = right[i];\n            int rest = cnt[r + 1] - used;\n            if(rest < 0) continue;\n            if(rest > 0) {\n                dp[i + 1][used + 1] += dp[i][used];\n            }\n            if(r + 1 - cnt[r + 1] - (i - used) > 0) {\n                dp[i + 1][used] += dp[i][used];\n            }\n        }\n    }\n    cout << dp[n][cnt[n]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nconst LL MM=1e9+7;\nconst int L=3009;\nint sum[L];\nchar in[L];\nLL dp[L][L];\nint main() {\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tscanf(\"%s\",in+1);\n\tfor(int i=1;i<=N;i++){\n\t\tsum[i]=sum[i-1];\n\t\tif(in[i]=='1'){\n\t\t\tsum[i]++;\n\t\t}\n\t}\n\tint pl=1,mr=0;\n\tdp[0][0]=1;\n\tfor(int i=0;i<=M;i++){\n\t\tint l,r;\n\t\tif(i==M){\n\t\t\tl=N+1;\n\t\t\tr=N+1;\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d%d\",&l,&r);\n\t\t}\n\t\tif(pl==l){\n\t\t\tmr=max(mr,r);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=pl;j<l;j++){\n\t\t\tif(j<=mr){\n\t\t\t\tint c=min(j,mr-sum[mr]);\n\t\t\t\tint a=j-c;\n\t\t\t\tint b=min(j,sum[mr]);\n\t\t\t\tfor(int k=0;k<=N;k++){\n\t\t\t\t\tif(a<=k&&k<=b){\n\t\t\t\t\t\tif(k){\n\t\t\t\t\t\t\tdp[j][k]+=dp[j-1][k-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[j][k]+=dp[j-1][k];\n\t\t\t\t\t\tdp[j][k]%=MM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int k=0;k<=N;k++){\n\t\t\t\t\tif(sum[j]-sum[j-1]){\n\t\t\t\t\t\tif(k){\n\t\t\t\t\t\t\tdp[j][k]=dp[j-1][k-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[j][k]=dp[j-1][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmr=max(mr,r);\n\t\tpl=l;\n\t}\n\t/*\n\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<=N;j++){\n\t\t\tcerr << dp[i][j] << \" \";\n\t\t}\n\t\tcerr << endl;\n\t}\n\t*/\n\tprintf(\"%lld\\n\",dp[N][sum[N]]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n    using LD = long double;\n    #define double LD\n    #define long long long\n    #define LL long\n    #define int long\n    template<class T> using vec = vector<T>;\n    using VB = vec<bool>;   using WB = vec<VB>;\n    using VC = vec<char>;   using WC = vec<VC>;\n    using VI = vec<int>;    using WI = vec<VI>;\n    using VD = vec<double>; using WD = vec<VD>;\n    using VS = vec<string>; using WS = vec<VS>;\n    using PI = pair<int, int>;  using VPI = vec<PI>; using WPI = vec<VPI>;\n    using MI = map<int, int>;   using VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    settings();\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n    template<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n        Graph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n    };\n    using GraphI = Graph<int>;\n/** IO **/\n    template<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n    int INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n    template<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n        const int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n        if(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n        times(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n    }\n    template<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n    template<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n    template<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n    template<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n    #define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n    template<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n    template<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n    template<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n    template<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n    template<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n    template<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n    inline void RD() {}\n    template<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n    template<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n    #define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n    template<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n    template<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n    template<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n    #define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n    #define all(v) begin(v), end(v)\n    template<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n    template<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n    template<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n    template<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n    template<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n    template<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n    template<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n    template<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n        return 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n    #define first_itr_st_val_ge_ lower_bound\n    #define first_itr_st_val_gt_ upper_bound\n/** other **/\n    template<class T> inline signed SIZE(const T& t) { return t.size(); }\n    #define size SIZE\n    #define MP make_pair\n    #define MT make_tuple\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.q.uf> */\n    // VERIFIED: arc090b\n    // ref: https://github.com/monyone/teihen_library/blob/master/DataStructure/01_WeightedUnionFind.md\n    struct UnionFind {\n        int n;\n        VI parents, treeSizes, weightDiffs;\n        UnionFind(int n_) : n(n_), parents(n), treeSizes(n, 1), weightDiffs(n, 0) { times(n, i) parents[i] = i; }\n        int root(int i) {\n            if(parents[i] == i) return i;\n            int p = root(parents[i]);\n            weightDiffs[i] += weightDiffs[parents[i]];\n            return parents[i] = p;\n        }\n        int weight(int i) { root(i); return weightDiffs[i]; }\n        void merge(int i, int j, int w = 0) { // w > 0 if i < j\n            if(same(i, j)) return;\n            int x = w + weight(i) - weight(j);\n            i = root(i); j = root(j);\n            if(treeSizes[i] < treeSizes[j]) { swap(i, j); x = -x; }\n            parents[j] = i;\n            treeSizes[i] += treeSizes[j]; treeSizes[j] = -1;\n            weightDiffs[j] = x;\n        }\n        bool same(int i, int j) { return root(i) == root(j); }\n        int diff(int base, int i) { return same(base, i) ? weight(i) - weight(base) : -INF; }\n    };\n/* </sr.q.uf> */\n/************************************ main ************************************/\n\nvoid settings() {\n    // INPUT_GRAPH_index_sub = 0;       // uncomment if input index is 0-based\n    // INPUT_GRAPH_allow_empty = true;  // uncomment to allow empty graph\n    INPUT_GRAPH_cost = 1;            // uncomment if all input costs are 1\n}\n\nvoid solve() {\n// NMSM(-LR)\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;VI L0(M);VI R0(M);times(M,Ri_0){cin>>L0[Ri_0\n];--L0[Ri_0];cin>>R0[Ri_0];}\n/* </foxy.memo-area> */\n    VI L, R; L.reserve(N); R.reserve(N);\n    times(M, i) {\n        if(size(R) == 0 or R0[i] >= R[size(R)-1]) {\n            L.push_back(L0[i]);\n            R.push_back(R0[i]);\n        }\n    }\n    M = size(L); /*!!!!!*/\n\n    VI c(N), rj(N), mnc(N), mxc(N);\n    times(N, j) {\n        c[j] = (j ? c[j-1] : 0) + (S[j] == '1');\n    }\n\n    times(M, i) rj[L[i]] = R[i] - 1;\n    times(N, j) {\n        rj[j] = max(rj[j], j ? rj[j-1] : 0);\n        mxc[j] = c[rj[j]];\n    }\n\n    ddd(L);ddd(R);\n    {\n        L.push_back(N); R.push_back(N);\n        int r1 = 0, cnt = 0;\n        times(M, i) {\n            uptil(max(r1, L[i]), R[i], j) {\n                cnt += S[j] == '1';\n                S[j] = '0';\n            }\n            int kab = max(0ll, R[i] - L[i+1]);\n            int d = max(0ll, cnt - kab);\n            cnt -= d;\n            ddd(cnt, kab, d);\n            downto(R[i]-cnt-1, R[i]-cnt-d, j) S[j] = '1';\n            r1 = R[i];\n        }\n        times(N, j) {\n            mnc[j] = (j ? mnc[j-1] : 0) + (S[j] == '1');\n        }\n    }\n    ddd(c); ddd(rj); ddd(mxc); ddd(mnc);\n\n    VI dp, dq; dp.push_back(1);\n    times(N, i) {\n        dq.resize(mxc[i]+1);\n        fill(all(dq), 0);\n        upto(mnc[i], mxc[i], j) {\n            dq[j] = (dig(0, dp, j-1) + dig(0, dp, j)) % MOD;\n        }\n        swap(dp, dq);\n    }\n    cout << sum(dp, MOD) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l[N], r[N], tr[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) {\n\t\tint ll, rr;\n\t\tscanf(\"%d%d\", &ll, &rr);\n\t\ttr[ll] = max(tr[ll], rr);\n\t}\n\tint m0 = 0;\n\tRep(i, n) if (tr[i]){\n\t\tbool flag = true;\n\t\tRep(j, i - 1) if (tr[i] <= tr[j]) flag = false; \n\t\tif (flag) l[++ m0] = i, r[m0] = tr[i];\n\t}\n\t//printf(\"%d\\n\", m0);\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, n) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j]);\n\t\telse {\n\t\t\tRep0(j, n) if (f[i][j]){\n\t\t\t\t//printf(\"%d %d %lld\\n\", i, j, f[i][j]);\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, n) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n9 3\n110111110\n1 4\n4 6\n6 9\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\nll R[5000];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = i;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = max(R[i], R[i - 1]);\n    }\n    dp[1][summ(1, R[1])] = 1;\n    for (int p = 1; p <= n; p++)\n    {\n        if (p > 1 && R[p] > R[p - 1])\n        {\n            for (int j = n; j >= summ(R[p - 1] + 1, R[p]); j--)\n            {\n                dp[p][j] = dp[p][j - summ(R[p - 1] + 1, R[p])];\n                dp[p][j - summ(R[p - 1] + 1, R[p])] = 0;\n            }\n        }\n        for (int c = 0; c <= n; c++)\n        {\n            dp[p + 1][c] = (dp[p][c] + dp[p][c + 1]) % MOD;\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            ;//cout << dp[i][j] << \" \";\n        }\n        ;//cout << endl;\n    }\n    cout << (dp[n][0] + dp[n][1]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 3030;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nint n;\nint m;\nint a[N];\nint s[N];\nchar c[N];\nint d[N][N];\n\nvoid add(int &x, int y)\n{\n        x += y;\n        if(x >= mod){\n                x -= mod;\n        }\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> m;\n        for(int i = 1; i <= n; i++){\n                cin >> c[i];\n                a[i] = i;\n                s[i] = s[i - 1] + c[i] - '0';\n        }\n        for(int i = 1; i <= m; i++){\n                int x, y;\n                cin >> x >> y;\n                a[x] = max(a[x], y);\n        }\n        for(int i = 1; i <= n; i++){\n                a[i] = max(a[i], a[i - 1]);\n        }\n        d[n][0] = d[n][1] = 1;\n        for(int i = n - 1; i >= 1; i--){\n                int to_add = s[a[i + 1]] - s[a[i]];\n                int lim = min(n - to_add, a[i] - i + 1);\n                for(int j = 0; j <= lim; j++){\n                        if(j > 0){\n                                add(d[i][j], d[i + 1][j - 1 + to_add]);\n                        }\n                        if(j < a[i] - i + 1){\n                                add(d[i][j], d[i + 1][j + to_add]);\n                        }\n                }\n        }\n        cout << d[1][s[a[1]]] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops,Ofast\")\n#pragma GCC target(\"avx,sse,sse2,ssse3,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int maxn = 3030, mod = 1e9 + 7;\nint n, m, jump[maxn], nxt[2][maxn][maxn], dp[maxn][maxn][2];\nstring s;\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m >> s;\n\tfor(int i = 0; i < n; i++) jump[i] = i;\n\tfor(int l, r, i = 0; i < m; i++) {\n\t\tcin >> l >> r; --l, --r;\n\t\tjump[l] = max(jump[l], r);\n\t}\n\tfor(int i = 1; i < n; i++) jump[i] = max(jump[i], jump[i-1]);\n\tmemset(nxt, 0x3f, sizeof nxt);\n\tfor(int c = 0; c < 2; c++)\n\tfor(int i = n; i--;) {\n\t\tif(s[i] == char('0'+c)) nxt[c][i][0] = i;\n\t\telse nxt[c][i][0] = nxt[c][i+1][0];\n\t\tfor(int j = 1; j < n; j++) {\n\t\t\tnxt[c][i][j] = nxt[c][i+1][j-(s[i]==char('0'+c))];\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int p = 0; p < 2; p++) {\n\t\t\t\tint cur = s[i]-'0';\n\t\t\t\tint ni = i+1;\n\t\t\t\tint nj = j;\n\t\t\t\tif(cur == p && nj)\n\t\t\t\t\tnj--, cur ^= 1;\n\t\t\t\tadd(dp[ni][nj][p], dp[i][j][p]);\n\t\t\t\tif(nxt[cur^1][i][j] <= jump[i])\n\t\t\t\t\tadd(dp[ni][nj+1][cur^1], dp[i][j][p]);\n\t\t\t}\n\t\t}\n\t}\n\tadd(dp[n][0][0], dp[n][0][1]);\n\tcout << dp[n][0][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define inf 998244353\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tvector<int> lefs;\n\tfor(int i=0;i<m;i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second){\n\t\tif( i == m-1 || ptmp[i].first != ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tdp[i][j+s[i-1]-'0'] += dp[i-1][j];\n\t\t\t\tdp[i][j+s[i-1]-'0'] %= inf;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULL)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) \n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3005\nusing namespace std;\n\nint n,m,s[N],a[N],b[N],dp[N][N],cbn[N][N]; char ch[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) s[i]=s[i-1]+(ch[i]=='1');\n\tm++; a[1]=b[1]=1;\n\tfor (i=2; i<=m; i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif (a[i]==a[i-1]){\n\t\t\tb[i-1]=max(b[i-1],b[i]); i--; m--; continue;\n\t\t}\n\t\tif (b[i]<=b[i-1]){ i--; m--; continue; }\n\t}\n\ta[m+1]=n+1;\n\tdp[0][0]=1;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++) cbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tfor (i=1; i<=m; i++){\n\t\tfor (j=max(a[i+1]-1-b[i]+s[b[i]],0); j<=s[b[i]]; j++)\n\t\t\tfor (k=0; k<=a[i+1]-a[i] && k<=j; k++) dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k]*cbn[a[i+1]-a[i]][k])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[m][s[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint const MOD=1000000007;\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n,n_operation;std::cin>>n>>n_operation;\n\n\tstd::vector<int> acm;acm.reserve(n+1);acm.resize(n); // suffix sum accumulation\n\tfor(int& x:acm){\n\t\tchar c;std::cin>>c;\n\t\tx=c-'0';\n\t}\n\tfor(int i=n-1;i--;)\n\t\tacm[i]+=acm[i+1];\n\tacm.push_back(0);\n\n\tauto const sum=[&](int l,int r){return acm[l]-acm[r];};\n\n\n\tstd::vector<std::pair<int,int>> ops;ops.reserve(n_operation+1);\n\tfor(int _=n_operation;_--;){\n\t\tint l,r;std::cin>>l>>r;--l;\n\t\tif(!ops.empty()){\n\t\t\tif(ops.back().first==l){\n\t\t\t\tops.back().second=std::max(ops.back().second,r);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(ops.back().second>=r)\n\t\t\t\tcontinue;\n\t\t}\n\t\tops.push_back({l,r});\n\t}\n\n\tops.push_back({n,n});\n\n\tn_operation=-1;\n\n\tauto const l=[&](int x){return ops[x].first;};\n\tauto const r=[&](int x){return ops[x].second;};\n\n\tstd::vector<std::vector<int>> dp(ops.size());\n\t// dp[i][n] = number of states of the sequence [0,l(i)] after i steps with sum n\n\n\tdp[0].resize(n+1);\n\tdp[0][sum(0,l(0))]=1;\n\n\n\tstd::vector<std::vector<int>> binom(n+1);\n\tbinom[0].assign(1,1);\n\tfor(unsigned i=1;i<binom.size();++i){\n\t\tbinom[i].resize(i+1);\n\t\tstd::copy(begin(binom[i-1]),end(binom[i-1]),begin(binom[i]));\n\t\tstd::transform(begin(binom[i-1]),end(binom[i-1]),++begin(binom[i]),++begin(binom[i]),[](int a,int b){\n\t\t\t\ta+=b;\n\t\t\t\tif(a>=MOD)a-=MOD;\n\t\t\t\treturn a;\n\t\t\t\t});\n\t}\n\n\n\tfor(int i=1;i<(int)ops.size();++i){\n\t\tdp[i].resize(n+1);\n\n\t\tint const mid=std::min(r(i-1),l(i));\n\t\tint const tmp2=sum(0,r(i-1));\n\t\tint const tmp3=l(i)>r(i-1)?sum(r(i-1),l(i)):0;\n\t\tint const* const binom_tmp4=binom[mid-l(i-1)].data();\n\t\tint const* const dp_i_1=dp[i-1].data();\n\n\t\tfor(int x=0;x<=n;++x){\n\t\t\t// x = sum [0,l(i)] after i steps\n\n\t\t\tint ans=0;\n\t\t\tif((x-tmp3)<=tmp2&&tmp2-(x-tmp3)<=r(i-1)-mid){\n\t\t\t\tfor(int y_=std::max((x-tmp3)-mid+l(i-1),0)-x;y_<=-tmp3;++y_){\n\t\t\t\t\tans=(ans+(int64_t)dp_i_1[y_+x]*binom_tmp4[tmp3-y_])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][x]=ans;\n\t\t}\n\t}\n\n\tstd::cout<<dp[ops.size()-1][sum(0,n)]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=6005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]])q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max(0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j+t<=jb&&j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max(0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<f[m][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nconst int mo=1e9+7;\nint n,m,len,a[N],l[N],r[N],L[N],R[N],f[N],g[N],C[N][N],vis[N],ans;\nint main()\n{\n\tint i,j,k;\n\tscanf(\"%d %d\\n\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=a[i-1]+getchar()-'0';\n\tfor(i=0;i<=n;i++){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t  }\n\tf[0]=1;\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d %d\",&L[i],&R[i]);\n\tfor(i=1;i<=m;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t\tif(L[i]>=L[j]&&R[i]<=R[j]){\n\t\t\t\tif(L[i]!=L[j]||R[i]!=R[j]) vis[i]=1;\n\t\t\t\telse vis[i]=(j<i);\n\t\t\t\tbreak;\n\t\t\t  }\n\tfor(i=1;i<=m;i++)\n\t\tif(!vis[i])\n\t\t\t++len,l[len]=L[i],r[len]=R[i];\n\tl[0]=1,m=len;\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<=n;j++) g[j]=f[j],f[j]=0;\n\t\tfor(j=0;j<=r[i]-l[i]+1;j++)\n\t\t\tif(r[i]<l[i+1])\n\t\t\t\tf[a[r[i+1]]-a[l[i+1]-1]]=(f[a[r[i+1]]-a[l[i+1]-1]]+1LL*g[j]*C[r[i]-l[i]+1][j])%mo;\n\t\t\telse{\n\t\t\t\tfor(k=max(j-r[i]+l[i+1]-1,0);k<=j&&k<=l[i+1]-l[i];k++)\n\t\t\t\t\tf[j+a[r[i+1]]-a[r[i]]-k]=(f[j+a[r[i+1]]-a[r[i]]-k]+1LL*g[j]*C[l[i+1]-l[i]][k])%mo;\n\t\t\t  }\n\t  }\n\tfor(i=0;i<=r[m]-l[m]+1;i++)\n\t\tans=(ans+1LL*f[i]*C[r[m]-l[m]+1][i])%mo;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(l[i+1]-l[i],j-k))%mo;\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353; \n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e4;\nconstexpr ll MAX=3e6;\nconstexpr ll inf=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        if(A<0) return B;\n        if(B<0) return A;\n        return std::min(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Tree{\n    int N;\n    vii dp;\n    vi dist;\n    Tree(vii edge){\n        N=edge.size();\n        dp.resize(N);\n        dist.resize(N,-1);\n        for(int i=0;i<N;i++) dp[i].resize(30);\n        dist[0]=dp[0][0]=0;\n        std::queue<int> que;\n        que.push(0);\n        while(!que.empty()){\n            int now=que.front(); que.pop();\n            for(int i=0;i<edge[now].size();i++){\n                int next=edge[now][i];\n                if(dist[next]==-1){\n                    dist[next]=dist[now]+1;\n                    que.push(next);\n                    dp[next][0]=now;\n                }\n            }\n        }\n        for(int i=1;i<30;i++){\n            for(int j=0;j<N;j++) dp[j][i]=dp[dp[j][i-1]][i-1];\n        }\n    }\n    int LCA(int X,int Y){\n        if(dist[X]<dist[Y]) std::swap(X,Y);\n        {\n            int Z=dist[X]-dist[Y];\n            for(int i=0;i<30;i++){\n                if(Z&(1<<i)){\n                    X=dp[X][i];\n                }\n            }\n        }\n        if(X==Y) return X;\n        for(int i=29;i>=0;i--){\n            if(dp[X][i]!=dp[Y][i]){\n                X=dp[X][i];\n                Y=dp[Y][i];\n            }\n        }\n        return dp[X][0];\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,ll a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> memo;\n    rep(i,0,A.size()) memo[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:memo) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=memo[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,M; cin>>N>>M;\n    string S; cin>>S;\n    S='0'+S;\n    vector<pii> data(M);\n    {\n        rep(i,0,M){\n            cin>>data[i].first>>data[i].second;\n            data[i].second*=-1;\n        }\n        sort(ALL(data));\n        ll memo=0;\n        vector<pii> mem;\n        rep(i,0,M){\n            if(memo<-data[i].second){\n                data[i].second*=-1;\n                mem.pb(data[i]);\n                memo=data[i].second;\n            }\n        }\n        data=mem;\n        M=mem.size();\n    }\n    vii dp(M+1,vi(N+1));\n    data.pb(mp(inf,inf));\n    ll ans=1;\n    ll memo=data[0].first-1;\n    dp[0][0]++;\n    COMinit();\n    rep(i,0,M){\n        if(data[i+1].first>data[i].second){\n            dp[i+1][0]++;\n            ll sum=0,cnt=0;\n            REP(j,memo+1,data[i].second){\n                if(S[j]=='1') cnt++;\n            }\n            REP(j,0,N){\n                if(dp[i][j]==0) break;\n                ll X=j+cnt;\n                sum+=dp[i][j]*COM(data[i].second-data[i].first+1,X)%MOD;\n                sum%=MOD;\n            }\n            ans*=sum;\n            ans%=MOD;\n            memo=data[i+1].first-1;\n            continue;\n        }\n        ll cnt=0;\n        REP(j,memo+1,data[i].second){\n            if(S[j]=='1') cnt++;\n        }\n        REP(j,0,N){\n            if(dp[i][j]==0) break;\n            ll X=j+cnt;\n            REP(k,std::max(0ll,X-(data[i].second-data[i+1].first+1)),data[i+1].first-data[i].first){\n                if(X<k) break;\n                dp[i+1][X-k]+=dp[i][j]*COM(data[i+1].first-data[i].first,k)%MOD;\n                dp[i+1][X-k]%=MOD;\n            }\n        }\n        memo=data[i].second;\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],tmp[maxn+8];\nint f[maxm+8][maxm+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) tmp[i]=tmp[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+tmp[r[i]]-tmp[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=l[i+1]-l[i]+j-tmp[r[i]]+tmp[max(l[i]-1,r[i-1])];k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+tmp[r[i]]-tmp[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N,M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> sum(N+1,0);\n    for (int i=0;i<N;++i) sum[i+1]=sum[i]+(S[i]-'0');\n    vector<vector<mint>> dp(M+1,vector<mint>(N+1,0));\n    dp[0][0]=1;\n    mint ans=0;\n    int prel=-1,prer=-1;\n    for (int i=0;i<M;++i){\n        int l,r; cin >> l >> r; --l,--r;\n        if (r<=prer){\n            for (int j=0;j<=N;++j) dp[i+1][j]+=dp[i][j];\n        } else {\n            int nxt=(prer<l?0:l-prel),add=sum[r+1]-sum[prer+1],rest=max(0,prer-l+1);\n            for (int j=0;j<=N;++j){\n                if (dp[i][j]==0) continue;\n                for (int k=0;k<=min(j,nxt);++k){\n                    if (j-k<=rest) dp[i+1][j+add-k]+=dp[i][j]*COM(nxt,k);\n                }\n            }\n            prel=l,prer=max(prer,r);\n        }\n        if (i==M-1) for (int j=0;j<=N;++j){\n            ans+=dp[i+1][j]*COM(r-l+1,j);\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1];\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 3010;\nint N, M;\nchar S[MAXN];\nint pref[MAXN];\n\nint to[MAXN];\nll dp[MAXN][MAXN];\n\nconst ll MOD = 1e9 + 7;\n\nint main() {\n\tscanf(\"%d %d\", &N, &M);\n\tscanf(\"%s\", S);\n\tfor (int i = 0; i < N; i++) {\n\t\tpref[i+1] = pref[i] + S[i] - '0';\n\t}\n\n\tfor (int i = 0; i <= N; i++) {\n\t\tto[i] = i;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tto[l] = max(r, to[l]);\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tto[i] = max(to[i], to[i-1]);\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tint add = pref[to[i+1]] - pref[to[i]];\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tint newj = j + add;\n\t\t\tif (newj > 0) {\n\t\t\t\tdp[i+1][newj-1] = (dp[i+1][newj-1] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t\tif (to[i+1] - i - newj > 0) {\n\t\t\t\tdp[i+1][newj] = (dp[i+1][newj] + dp[i][j]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", dp[N][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \n#define pb push_back\n#define fr first\n#define sc second\n\nconst ll Mod = 1000000007;\n\nint main(){\n\tstatic int N,M;\n\tstatic string S;\n\tstatic int l[3002],r[3002];\n\tscanf(\"%d%d\",&N,&M);\n\tcin >> S;\n\tfor(int i = 1 ; i <= M ; i ++){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t}\n\t\n\tstatic int cnt[3002] = {};\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tcnt[i] = cnt[i-1] + S[i-1]-'0';\n\t}\n\tstatic int R[3002] = {};\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tR[i] = i;\n\t}\n\tfor(int i = 1 ; i <= M ; i ++){\n\t\tfor(int j = l[i] ; j <= r[i] ; j ++){\n\t\t\tR[j] = max( R[j] , r[i] );\n\t\t}\n\t}\n\t\n\tstatic ll dp[3002][3002] = {};\n\tdp[0][0] = 1;\n\tfor(int i = 1 ; i <= N ; i ++){\n\t\tif(cnt[R[i]]-R[i]+i <= 0)dp[i][0] = dp[i-1][0];\n\t\tfor(int j = max(cnt[R[i]]-R[i]+i,1) ; j <= cnt[R[i]] ; j ++){\n\t\t\tdp[i][j] = dp[i-1][j]+dp[i-1][j-1];\n\t\t\tif(dp[i][j] >= Mod)dp[i][j] -= Mod;\n\t\t}\n\t}\n\tcout << dp[N][cnt[N]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define sd(n) scanf(\"%d\",&n)\n#define sl(n) scanf(\"%lld\",&n)\n#define pd(n) printf(\"%d\",n)\n#define pl(n) printf(\"%lld\",n)\n#define sf(n) scanf(\"%f\",&n)\n#define pf(n) printf(\"%.12f\",n)\n#define psp printf(\" \")\n#define endc printf(\"\\n\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int maxn = 3002;\nconst ll md = 1e9 + 7;\n\npii Z[maxn];\nll C[maxn][maxn];\nll dp[maxn][maxn];\nint pref[maxn];\n\nint main() {\n\tIOS; string s;\n\n\tfor (int i = 0; i < maxn; i++) {\n\t\tfor (int j = 0; j < maxn; j++) {\n\t\t\tif (i == 0) { C[i][j] = (j==0); continue; }\n\t\t\tif (j == 0) { C[i][j] = 1; continue; }\n\t\t\tC[i][j] = (C[i-1][j] + C[i-1][j-1])%md;\n\t\t}\n\t}\n\n\tint n,m; cin>>n>>m>>s; s = \" \" + s; int idx = 0; pref[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpref[i] = pref[i-1]; pref[i] += (s[i] == '1');\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint l,r;\n\t\tcin>>l>>r; pii z = mp(l,r);\n\t\tif (idx == 0) { idx++; Z[idx] = z; continue; }\n\t\tif (Z[idx].first == l) {\n\t\t\tif (Z[idx].second < r) Z[idx] = z;\n\t\t\telse continue;\n\t\t} else {\n\t\t\tif (Z[idx].second >= r) continue;\n\t\t\telse { idx++; Z[idx] = z; }\n\t\t}\n\t}\n\tm = idx; Z[m+1] = mp(n+7,n+7); Z[0] = mp(-1,-1);\n\tfor (int k = m; k >= 1; k--) {\n\t\tint lft = Z[k].first, rgt = Z[k].second;\n\t\tint p = max(Z[k-1].second, lft-1); \n\t\tint tc = pref[rgt] - pref[p];\n\t\tfor (int l = 0; l <= (p-lft+1); l++) {\n\t\t\tdp[k][l] = 0;\n\t\t\tint t = tc + l;\n\t\t\tint d = max(rgt - Z[k+1].first + 1, 0);\n\t\t\tint my = rgt - lft + 1 - d;\n\t\t\tif (d == 0) { dp[k][l] = C[my][t]; continue; } // arrange yours\n\t\t\tfor (int g = max(t-my,0); g <= min(d,t); g++) { // can give atleast 0 and t-my atmost overlap and t\n\t\t\t\tll cur = C[my][t-g] * dp[k+1][g];\n\t\t\t\tdp[k][l] = (cur + dp[k][l])%md;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][0]<<endl;\t\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\nint dp[3005][3005] = {};\n//i番目まで見た時の1がj個あるような状態\nint main() {\n    int N, M;\n    int cnt[3005] = {};\n    int A[3005];\n    \n    string S;\n    \n    cin >> N >> M >> S;\n    for (int i = 0; i < N; i++) {\n        cnt[i + 1] = S[i] == '1';\n        cnt[i + 1] += cnt[i];\n    }\n\n    for (int i = 0; i <= N; i++) A[i] = i; \n    for (int i = 0; i < M; i++) {\n        int l, r;\n        cin >> l >> r;\n        A[l] = max(A[l], r);\n    }\n    \n    for (int i = 1; i <= N; i++) A[i] = max(A[i], A[i - 1]);\n\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= N; j++) {\n            if (dp[i][j] == 0) continue;\n            if (cnt[A[i + 1]] >= j + 1) (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n            if (A[i + 1] - cnt[A[i + 1]] >= i - j + 1) (dp[i + 1][j] += dp[i][j]) %= mod;\n        }\n    }\n    cout << dp[N][cnt[N]] << endl;\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3003;\ntypedef long long ll;\nconst ll MOD = 1000000007ll;\nll p1[N],p2[N],comb[N][N];\nint l[N],r[N];\nchar S[N];\n\nint main(){\n    int n,m;\n    scanf(\"%d%d%s\",&n,&m,S);\n    for(int i = 0; i<m; i++){\n        scanf(\"%d%d\",&l[i],&r[i]);\n        l[i]--,r[i]--;\n        if(i&&l[i]==l[i-1]){\n            r[i-1] = max(r[i],r[i-1]);\n            i--;\n            m--;\n        }else if(i&&r[i]<=r[i-1]){\n            i--;\n            m--;\n        }\n    }\n    for(int i = 0; i<N; i++){\n        comb[i][0] = comb[i][i] = 1;\n        for(int j = 1; j<i; j++)\n            comb[i][j] = (comb[i-1][j-1]+comb[i-1][j])%MOD;\n    }\n    p1[0] = 1;\n    int rem = 0;\n    for(int i = 0; i<m; i++){\n        int nxt = 0;\n        if(i<m-1&&l[i+1]<=r[i])\n            nxt = r[i]-l[i+1]+1;\n        int L = l[i];\n        if(i&&r[i-1]>=l[i])\n            L = r[i-1]+1;\n        int R = r[i];\n        int cnt = 0;\n        for(int j = L; j<=R; j++)\n            cnt += (S[j]=='1');\n        for(int j = 0; j<=nxt; j++)\n            p2[j] = 0;\n        int sz = r[i]-l[i]+1;\n        for(int j = 0; j<=rem; j++){\n            int avail = cnt+j;\n            for(int k = 0; k<=nxt; k++){\n                int sel = avail-k;\n                if(sz-nxt-sel>=0&&sel>=0)\n                    p2[k] = (p2[k]+(p1[j]*comb[sz-nxt][sel])%MOD)%MOD;\n            }\n        }\n        for(int k = 0; k<=nxt; k++) p1[k] = p2[k];\n        rem = nxt;\n    }\n    printf(\"%lld\\n\",p1[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod=1e9+7,N=1e3+10;\n\nint n,m,dp[N][N],summ[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;++i) summ[i]=summ[i-1]+(s[i]=='0'); \n}\n\nvoid Solve() {\n\tint nowr=0,l,r,cnt=0;\n\tscanf(\"%d%d\",&l,&r); ++cnt;\n\tdp[0][0]=1;\n\tfor (int i=0;i<n;++i) {\n\t\tint sum=0; \n\t\twhile (i+1==l && cnt<=m) {\n\t\t\tif (r>nowr) sum+=summ[r]-summ[nowr],nowr=r;\n\t\t\tif (cnt<m) { scanf(\"%d%d\",&l,&r); ++cnt; }\n\t\t\telse break; \n\t\t}\n\t\tif (nowr>i){\n\t\t\tfor (int j=0;j<=nowr-i;++j) {\n\t\t\t\tif (j+sum) dp[i+1][j+sum-1]=(dp[i+1][j+sum-1]+dp[i][j])%Mod;\n\t\t\t\tif (nowr-i-j-sum) dp[i+1][j+sum]=(dp[i+1][j+sum]+dp[i][j])%Mod; \n\t\t\t}\n\t\t}else dp[i+1][0]=dp[i][0],nowr=i+1;\n\t}\n\tprintf(\"%d\\n\",dp[n][0]);\n} \n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define pb push\n#define mp make_pair\n#define X first\n#define Y second\n#define Mad(a,b) a=(a+b)%mod;\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\nqueue<P> Q;\n#define N 3010\nll n,m,d[2][N];string s;\nint main(){\n    cin>>n>>m>>s;\n    Q.pb(mp(0,0));\n    while(m--){\n\tll a,b;cin>>a>>b;\n\tif(Q.back().Y<b)Q.pb(mp(a,b));\n    }\n    lol(i,N)lol(j,2)d[j][i]=0;d[0][0]=1;\n    for(ll i=0,rnd=0,bef=0;i<=n;i++){\n\tll cnt=0;\n\twhile(!Q.empty()){\n\t    if(not(Q.front().X<=i))break;\n\t    for(ll j=bef;j<rnd;j++)cnt+=s[j]-'0';\n\t    bef=rnd;Q.pop();rnd=Q.front().Y;\n\t}\n\tlol(j,N)d[1^i&1][j]=0;\n\tll lim=max(0LL,bef-i);\n\tfor(ll j=cnt;j<=lim;j++)Mad(d[1^i&1][j],d[i&1][j-cnt]);\n\tfor(ll j=cnt-1;j<=lim;j++)Mad(d[1^i&1][j],d[i&1][j-cnt+1]);\n    }\n    cout<<d[1^n&1][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 3000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,s[MN+5],f[MN+5],g[MN+5],l[MN+5],r[MN+5],p[MN+5],inv[MN+5];\nchar st[MN+5];\nvoid Move(int s)\n{\n\tfor(int i=n;i>=s;--i) f[i]=f[i-s];\n\tfor(int i=0;i<s;++i) f[i]=0;\n}\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;} \nint main()\n{\n\tn=read();m=read();scanf(\"%s\",st+1);p[0]=p[1]=inv[0]=inv[1]=f[0]=1;\n\tfor(int i=1;i<=n;++i) s[i]=s[i-1]+(st[i]=='1');\n\tfor(int i=2;i<=n;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=n;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;n=0;\n\tfor(int i=1;i<=m;++i) l[i]=read(),n=max(n,r[i]=read());l[m+1]=n+1;\n\tfor(int i=1,mr=l[1]-1;i<=m;++i)\n\t{\n\t\tif(r[i]>mr) Move(s[r[i]]-s[mr]),mr=r[i];\n\t\tif(l[i+1]>l[i])\n\t\t{\n\t\t\tfor(int j=0;j<=n;++j) if(f[j])\n\t\t\t{\n\t\t\t\tfor(int k=0;k<=j&&k<=l[i+1]-l[i];++k) if(mr-l[i]+1-j>=l[i+1]-l[i]-k)\n\t\t\t\t\tg[j-k]=(g[j-k]+1LL*f[j]*C(l[i+1]-l[i],k))%mod;\t\n\t\t\t}\n\t\t\tfor(int j=0;j<=n;++j) f[j]=g[j],g[j]=0;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nconst int MAXN = (int) 3e3;\n\nnamespace MATH\n{\n\tconst int n = MAXN;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = inv(fac[n]);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n\n\tinline int C(int N, int M) { return N < 0 || M < 0 || N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n}\nusing MATH::C;\n\nint n, m;\n\ninline char safe_getchar()\n{\n\tregister char ch(getchar());\n\twhile(!isdigit(ch)) ch = getchar();\n\treturn ch;\n}\n\nint a[MAXN + 5], R[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = safe_getchar() - '0';\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint l = read<int>(), r = read<int>();\n\t\tchkmax(R[l], r);\n\t}\n}\n\nstruct seg\n{\n\tint l, r;\n\n\tseg() { }\n\tseg(int _l, int _r): l(_l), r(_r) { }\n};\n\ninline void solve()\n{\n\tstatic seg s[MAXN + 5];\n\tint M = 0;\n\n\tfor(int lst = 0, i = 1; i <= n; ++i) if(R[i] >= i && chkmax(lst, R[i])) s[++M] = seg(i, R[i]);\n\ts[M + 1] = seg(s[M].r + 1, s[M].r);\n\n\tstatic int c[MAXN + 5], l[MAXN + 5], t[MAXN + 5], f[MAXN + 5][MAXN + 5];\n\n\tfor(int i = 1; i <= M; ++i)\n\t{\n\t\tc[i] = max(0, s[i - 1].r - s[i].l + 1);\n\t\tl[i] = min(s[i + 1].l, s[i].r + 1) - s[i].l;\n\t\tfor(int j = max(s[i - 1].r + 1, s[i].l); j <= s[i].r; ++j) t[i] += a[j] == 0;\n\t}\n\n\tf[0][0] = 1;\n\tfor(int i = 1; i <= M; ++i)\n\t\tfor(int j = 0; j <= n; ++j)\n\t\t{\n\t\t\tf[i][j] = 0;\n\t\t\tfor(int k = 0; k <= l[i]; ++k) if(j - t[i] + k >= 0 && j - t[i] + k <= c[i]) (f[i][j] += (LL) f[i - 1][j - t[i] + k] * C(l[i], k) % MOD) %= MOD;\n\t\t}\n\tprintf(\"%d\\n\", f[M][0]);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = (int)3e3 + 5, mod = (int)1e9 + 7;\nint n, m, rMost[N], dp[N][N], rPref[N], n0Pref[N];\nstring s;\n\nint add(int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n//    freopen(\"test.INP\", \"r\", stdin);\n\n    cin >> n >> m >> s;\n    while (m --) {\n        int l, r; cin >> l >> r;\n        rMost[l] = max(rMost[l], r);\n    }\n\n    s = ' ' + s;\n    for (int i = 1; i <= n; ++i) {\n        rMost[i] = max(rMost[i], i);\n        rPref[i] = max(rPref[i - 1], rMost[i]);\n        n0Pref[i] = n0Pref[i - 1] + (s[i] == '0');\n    }\n\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        for (int n0 = 0; n0 <= i; ++n0) if (dp[i][n0]) {\n            int n1 = i - n0, rem0 = n0Pref[ rPref[i + 1] ] - n0, rem1 = rPref[i + 1] - n0Pref[ rPref[i + 1] ] - n1;\n            if (rem0) dp[i + 1][n0 + 1] = add(dp[i + 1][n0 + 1], dp[i][n0]);\n            if (rem1) dp[i + 1][n0] = add(dp[i + 1][n0], dp[i][n0]);\n        }\n    }\n\n    int ans = 0;\n    for (int n0 = 0; n0 <= n; ++n0) ans = add(ans, dp[n][n0]);\n    cout << ans;\n\n    return 0;\n}\n/*\n110111\n\n011111\n101111\n110111\n111011\n\n011111\n101111\n110111\n111011\n111101\n111110\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nconst int mod=1e9+7;\nint n,m;\nint s[N],val[N],dp[2][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tchar t[2];gets(t);\n\tfor(int i=1;i<=n;i++) s[i]=getchar()-'0'+s[i-1];\n\tint cnt=0;\n\tfor(int i=1,ml,mr;i<=m;i++)\n\t\tscanf(\"%d%d\",&ml,&mr),val[ml]=max(val[ml],mr);\n\tfor(int i=1;i<=n;i++) val[i]=max(max(i,val[i]),val[i-1]); \n\tint now=0;\n\tdp[now][0]=1;\n\tfor(int i=1;i<=n;i++,now^=1){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=s[val[i]]-(val[i]-i);j<=s[val[i]];j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+ (j==0?0:dp[now][j-1]) )%mod;\n\t}\n\tcout<<dp[now][s[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long mod=1000000007ll;\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nint main()\n{\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  char s[3010];\n  scanf(\"%s\",s);\n  int R[3010];\n  for(int i=0;i<n;i++){\n    R[i]=i;\n  }\n  for(int i=0;i<m;i++){\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    l--;\n    r--;\n    R[l]=max(R[l],r);\n  }\n  int S[3010];\n  S[0]=0;\n  for(int i=0;i<n;i++){\n    S[i+1]=S[i]+(s[i]=='1'?1:0);\n  }\n  long long dp[2][3010]={0};\n  bool b=0;\n  dp[b][0]=1ll;\n  int r=0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=n;j++){\n      dp[!b][j]=0ll;\n    }\n    int nr=max(R[i]+1,r);\n    int p=S[nr]-S[r];\n    r=nr;\n    //printf(\"%d %d %d\\n\",i,r,p);\n    for(int j=0;j<=n;j++){\n      if(dp[b][j]==0){\n\tcontinue;\n      }\n      if(r-i-(j+p)>0){\n\tad(dp[!b][j+p],dp[b][j]);\n      }\n      if(j+p>0){\n\tad(dp[!b][j+p-1],dp[b][j]);\n      }\n    }\n    b=!b;\n  }\n  printf(\"%lld\\n\",dp[b][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3000+10,mo=1000000007;\nint f[maxn][maxn],right[maxn],sum[maxn];\nint i,j,k,l,r,t,n,m,ans,one,zero;\nchar get(){\n    char ch=getchar();\n    while (ch!='0'&&ch!='1') ch=getchar();\n    return ch;\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    fo(i,1,n) sum[i]=get()-'0';\n    fo(i,1,n+1) sum[i]+=sum[i-1];\n    fo(i,1,n+1) right[i]=i;\n    fo(i,1,m){\n        scanf(\"%d%d\",&j,&k);\n        right[j]=max(right[j],k);\n    }\n    fo(i,1,n) right[i]=max(right[i],right[i-1]);\n    f[1][sum[right[1]]]=1;\n    fo(i,1,n)\n        fo(j,0,n)\n            if (f[i][j]){\n                l=right[i]+1;r=right[i+1];\n                one=j;zero=right[i]-i+1-j;\n                if (zero) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n                if (one) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n            }\n    ans=f[n+1][0];\n    (ans+=mo)%=mo;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3005;\nconst int MOD=1000000007;\n\nint n,m,c[N][N],a[N],f[N][N];\nstruct data{int l,r;}op[N];\nchar str[N];\n\nbool cmp(data a,data b)\n{\n\treturn a.l<b.l||a.l==b.l&&a.r<b.r;\n}\n\nvoid mod(int &x)\n{\n\tx-=x>=MOD?MOD:0;\n}\n\nvoid prepare()\n{\n\tc[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tc[i][0]=1;\n\t\tfor (int j=1;j<=i;j++) mod(c[i][j]=c[i-1][j]+c[i-1][j-1]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tprepare();\n\tscanf(\"%s\",str+1);\n\tfor (int i=1;i<=n;i++) a[i]=a[i-1]+str[i]-'0';\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&op[i].l,&op[i].r);\n\tsort(op+1,op+m+1,cmp);\n\tint tmp=m,mx=0;\n\tfor (int i=1;i<=m;i++)\n\t\tif (op[i].l==op[i+1].l||op[i].r<=mx) tmp--,op[i].l=n+1;\n\t\telse mx=max(mx,op[i].r);\n\tsort(op+1,op+m+1,cmp);\n\tm=tmp;\n\tf[op[1].l-1][a[op[1].l-1]]=1;\n\top[m+1].l=n+1;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint l=op[i].l,r=op[i].r,nx=op[i+1].l;\n\t\tfor (int j=0;j<l;j++)\n\t\t{\n\t\t\tif (!f[l-1][j]) continue;\n\t\t\tint s=a[r]-j,p=max(0,s-(r-nx+1)),q=min(s,nx-l);\n\t\t\tif (nx>r) {mod(f[nx-1][a[nx-1]]+=(LL)f[l-1][j]*c[r-l+1][s]%MOD);continue;}\n\t\t\tif (p>q) continue;\n\t\t\tfor (int k=p;k<=q;k++) mod(f[nx-1][j+k]+=(LL)f[l-1][j]*c[nx-l][k]%MOD);\n\t\t}\n\t}\n\tprintf(\"%d\",f[n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 3010,mod = 1e9 + 7;\nint n,m,sum[maxn],R[maxn],f[maxn][maxn];\nchar s[maxn];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s + 1);\n    for (int i = 1; i <= n; i++)\n    {\n        sum[i] = sum[i - 1] + s[i] - '0';\n        R[i] = i;\n    }\n    R[n + 1] = n + 1;\n    sum[n + 1] = sum[n];\n    for (int i = 1; i <= m; i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        R[x] = max(R[x],y);\n    }\n    for (int i = 2; i <= n + 1; i++)\n        R[i] = max(R[i],R[i - 1]);\n    f[1][sum[R[1]]] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= n; j++)\n        {\n            if (!f[i][j])\n                continue;\n            int k = sum[R[i + 1]] - sum[R[i]];\n            if (j)\n                (f[i + 1][j - 1 + k] += f[i][j]) %= mod;\n            if (i + j <= R[i])\n                (f[i + 1][j + k] += f[i][j]) %= mod;\n        }\n    printf(\"%d\\n\",f[n + 1][0]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    if(v[i].second < v[i+1].first){\n        return dp[i][s] = (pt[v[i].second-v[i].first+1][tmp]*saiki(i+1,0))%mod;\n    }else{\n        for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n            ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n        }\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    // for(int i=0;i<v.size();i++){\n    //     cout << v[i].first << \" \" <<v[i].second << endl;\n    // }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        for(int j=v[i-1].second+1;j<=v[i].second;j++){\n            if(s[j-1]=='1'){\n                tmp++;\n            }\n        }\n        nm[i] = tmp;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    if(v[0].second <v[1].first){\n        ans = (pt[v[0].second-v[0].first][tmp]*saiki(1,0))%mod;\n    }else{\n        for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n            ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define fin \"\\n\"\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntemplate <typename T>\ninline void chmin(T &l,T r){l=min(l,r);}\n\ntemplate <typename T>\ninline void chmax(T &l,T r){l=max(l,r);}\n\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\n\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nconst LL MOD=1e9+7;\nint main(){\n    int N,M;\n    cin>>N>>M;\n    string s;\n    cin>>s;\n    vector<P> sum(N);\n    sum[0].X=(s[0]=='0');\n    sum[0].Y=1-sum[0].X;\n    FOR(i,1,N)sum[i].X=(s[i]=='0')+sum[i-1].X;\n    FOR(i,1,N)sum[i].Y=(s[i]=='1')+sum[i-1].Y;\n    vector<int> ub(N);\n    iota(ub.begin(),ub.end(),0);\n    REP(i,M){\n        int l,r;cin>>l>>r;l--;r--;\n        chmax(ub[l],r);\n    }\n    FOR(i,1,N)chmax(ub[i],ub[i-1]);\n    //REP(i,N)cout<<sum[i].X<<sum[i].Y<<\" \";cout<<endl;\n    vector<LL> dp(N+1,0);\n    dp[0]=1;\n    REP(i,N){\n        vector<LL> nxt(N+1,0);\n        REP(j,N+1)if(dp[j]){\n            const int x=sum[ub[i]].X-j;\n            const int y=sum[ub[i]].Y-(i-j);\n            if(x)(nxt[j+1]+=dp[j])%=MOD;\n            if(y)(nxt[j]+=dp[j])%=MOD;\n        }\n        swap(dp,nxt);\n    }\n    cout<<dp[sum.back().X]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if(i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if(j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n#define pe pair<int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX_N = 3010;\nconst long long MOD = 1000000007;\n\nvector<pe> ops;\n\nclass cmp {\npublic:\n  inline bool operator()(const pe &a, const pe &b) {\n    if(a.se == b.se) {\n      return a.fi > b.fi;\n    }\n    return a.se > b.se;\n  }\n};\n\nint le[MAX_N];\nint ri[MAX_N];\n\nlong long d[MAX_N][MAX_N];\n\nstring s;\nstring copie;\n\nint main()\n{\n  int n, m;\n  cin >> n >> m >> s;\n\n  for(int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    ops.push_back(mp(a, b));\n  }\n\n  sort(ops.begin(), ops.end());\n\n  s = \" \" + s;\n  copie = s;\n\n  for(auto it : ops) {\n    int cnt0 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt0 += (s[i] == '0');\n    }\n\n    for(int i = it.fi; i < it.fi + cnt0; i++) {\n      s[i] = '0';\n    }\n    for(int i = it.fi + cnt0; i <= it.se; i++) {\n      s[i] = '1';\n    }\n  }\n  int cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      ri[++cnt] = i;\n    }\n  }\n\n\n  s = copie;\n  cnt = 0;\n\n  for(auto it : ops) {\n    int cnt1 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt1 += (s[i] == '1');\n    }\n\n    for(int i = it.fi; i < it.fi + cnt1; i++) {\n      s[i] = '1';\n    }\n    for(int i = it.fi + cnt1; i <= it.se; i++) {\n      s[i] = '0';\n    }\n  }\n\n  cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      le[++cnt] = i;\n    }\n  }\n\n  d[0][0] = 1;\n  for(int i = 1; i <= n; i++) {\n    d[i][0] = d[i - 1][0];\n    for(int j = 1; j <= min(cnt, i); j++) {\n      if(i >= le[j] && i <= ri[j]) {\n        d[i][j] += d[i - 1][j - 1];\n      }\n      d[i][j] = (d[i][j] + d[i - 1][j]) % MOD;\n    }\n  }\n\n  cout << d[n][cnt] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n, m;\nstring s;\n\nint cnt[3005];\nint mx[3005], mn[3005];\nint dp[3005][3005];\nsigned main()\n{\n\tcin>>n>>m>>s;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcnt[i]=cnt[i-1]+(s[i-1]=='1');\n\t\tmx[i]=cnt[i], mn[i]=cnt[i];\n\t}\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint l, r;\n\t\tcin>>l>>r;\n\n\t\tint lol=mn[r]-mn[l-1], lel=mx[r]-mx[l-1];\n\n\t\tfor(int j=l; j<=r; j++)\n\t\t{\n\t\t\tmn[j]=min(mn[j], mn[l-1]+max(0, lol-(r-j)));\n\t\t\tmx[j]=max(mx[j], mx[l-1]+min(j-l+1, lel));\n\t\t}\n\t}\n\t// for(int i=1; i<=n; i++)\n\t// {\n\t// \tcout<<mx[i]<<\" \"<<mn[i]<<endl;\n\t// }\n\tdp[0][0]=1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=mn[i]; j<=mx[i]; j++)\n\t\t{\n\t\t\tif(j>0)\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t\tdp[i][j]%=1000000007;\n\t\t}\n\t}\n\tcout<<dp[n][cnt[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],inv[3002];\nlld d[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= inv[n-r]; tmp %= Mod;\n\ttmp *= inv[r]; tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = inv[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][sum[x[1]-1]] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tint cnt1,cnt2;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t}else{\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=3000+10;\nconst int mod=1e9+7;\nvoid add(int& x,int y) { x+=y; if (x>=mod) x-=mod; }\n\nint n,m; char str[N];\nstruct node { int l,r; } p[N];\nbool operator <(node a,node b) { return a.l<b.l||(a.l==b.l&&a.r>b.r); }\nint C[N][N],sum[N],dp[N][N];\n\nint main() {\n\tn=read(),m=read(); scanf(\"%s\",str+1);\n\tfor (int i=1;i<=m;++i) p[i].l=read(),p[i].r=read();\n\tsort(p+1,p+m+1); int top=0;\n\tfor (int i=1,x=0;i<=m;++i)\n\t\tif (p[i].r>x) p[++top]=p[i],x=p[i].r;\n\tm=top,p[m+1].l=n+1;\n\tfor (int i=1;i<=n;++i) sum[i]=sum[i-1]+str[i]-'0';\n\tdp[p[1].l-1][sum[p[1].l-1]]=1;\n\tfor (int i=C[0][0]=1;i<=n;++i)\n\t\tfor (int j=C[i][0]=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tfor (int i=1;i<=m;++i) {\n\t\tint l=p[i].l,r=p[i].r,nxt=p[i+1].l;\n\t\tfor (int j=0;j<l;++j) {\n\t\t\tif (!dp[l-1][j]) continue;\n\t\t\tint s=sum[r]-j;\n\t\t\tif (nxt>r) \n\t\t\t\tadd(dp[nxt-1][sum[nxt-1]],1ll*dp[l-1][j]*C[r-l+1][s]%mod);\n\t\t\telse {\n\t\t\t\tint x=max(0,s-(r-nxt+1)),y=min(s,nxt-l);\n\t\t\t\tfor (int k=x;k<=y;++k)\n\t\t\t\t\tadd(dp[nxt-1][j+k],1ll*dp[l-1][j]*C[nxt-l][k]%mod);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long to; long long len;\n\tbool operator<(const edge& rhs) const {\n\t\treturn len > rhs.len;\n\t}\n};\n\nll const MAX = 3e3 + 5;\nll dp[MAX][MAX] = {};\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y + MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\nll l[MAX], r[MAX];\nll sum0[MAX] = {}, sum1[MAX] = {};\n\nint main() {\n\tll n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tREP(i, 1, m) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tll cur_0 = 0, cur_1 = 0;\n\tll header = 0;\n\tll cur_i = 1;\n\tdp[0][0] = 1;\n\tREP(i, 1, n) {\n\t\tsum0[i] = sum0[i - 1] + (s[i - 1] == '0');\n\t\tsum1[i] = sum1[i - 1] + (s[i - 1] == '1');\n\t}\n\tl[m + 1] = n + 1; r[m + 1] = n + 1;\n\tREP(i, 1, m + 1) {\n\t\twhile (cur_i < l[i]) {\n\t\t\theader = max(header, cur_i);\n\t\t\tll t1 = max(ll(0), cur_i - sum0[header]);\n\t\t\tll t2 = min(cur_i, sum1[header]);\n\t\t\tREP(j, t1,t2) {\n\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j]);\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_i++;\n\t\t}\t\n\t\theader = max(header, r[i]);\n\n\t}\n\tcout << dp[n][sum1[n]] << endl;\n\t/*\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\nconst int MAX_N = 3005, MOD = 1000000007;\ntypedef long long i64;\ni64 f[2][MAX_N], C[MAX_N][MAX_N];\nint L[MAX_N], R[MAX_N];\nchar s[MAX_N];\n\nint main() {\n  int N, M;\n  \n  scanf(\"%d%d\", &N, &M);\n  scanf(\"%s\", s + 1);\n\n  assert(strlen(s + 1) == N);\n  \n  for (int i = 1; i <= M; ++i) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n    assert(L[i] >= L[i - 1]);\n    assert(L[i] < R[i]);\n    assert(R[i] <= N);\n    if (R[i] <= R[i - 1]) i--, M--;\n    else if (L[i] == L[i - 1] && R[i - 1] <= R[i]) {\n      R[i - 1] = R[i];\n      i--, M--;\n    }\n  }\n  \n  for (int i = 0; i <= N; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n  }\n  \n  int o = 0, p;\n  R[0] = L[1] - 1, f[0][0] = 1, L[M + 1] = N + 1;\n  \n  for (int i = 1; i <= M; ++i) {\n    p = o, o ^= 1;\n    memset(f[o], 0, sizeof f[o]);\n    int num = 0;\n    for (int j = R[i - 1] + 1; j <= R[i]; ++j)\n      if (s[j] == '1') num++;\n    \n    int temp1 = R[i - 1] - L[i] + 1, temp2 = max(R[i] - L[i + 1] + 1, 0);\n    \n    for (int k1 = 0; k1 <= temp1; ++k1) {\n      int num1 = num + k1, num0 = R[i] - L[i] + 1 - num1;\n      if (!f[p][k1]) continue;\n      for (int k2 = max(0, temp2 - num0); k2 <= min(temp2, num1); ++k2) {\n\tint rest1 = num1 - k2, rest0 = num0 - temp2 + k2;\n\tif (rest1 < 0 || rest0 < 0) continue;\n\tf[o][k2] = (f[o][k2] + C[rest1 + rest0][rest1] * f[p][k1] % MOD) % MOD;\n      }\n    }\n    if (R[i] < L[i + 1] - 1) R[i] = L[i + 1] - 1;\n  }\n\n  printf(\"%lld\\n\", (f[o][0] + MOD) % MOD);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N = 3005;\nconst int mod = 1e9 + 7;\nusing namespace std;\n\nint n, m, a[N], dp[N][N], cnt[N], Max;\nstring s;\n\nvoid add(int&a, int b){\n    a += b; if (a >= mod) a -= mod;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m >> s; s = '.' + s;\n    for (int i = 1; i <= n; i++) cnt[i] = cnt[i-1] + (s[i] == '0');\n    while (m--){\n        int l, r; cin >> l >> r;\n        if (r > Max){\n            a[l] = r;\n            Max = r;\n        }\n    }\n    Max = 0;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        Max = max(Max, a[i]);\n        for (int j = 0; j <= i; j++){\n            if (Max < i) {\n                if (j - (s[i] == '0') >= 0) dp[i][j] = dp[i-1][j - (s[i] == '0')];\n            }\n            else{\n                if (j <= cnt[Max]) add(dp[i][j], dp[i-1][j-1]);\n                if (i-j <= Max - cnt[Max]) add(dp[i][j], dp[i-1][j]);\n            }\n        }\n    }\n    cout << dp[n][cnt[n]];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\nconst int inf = 1000000001;\nconst ll INF = 2e18;\nconst ll MOD = 1000000007;\nconst ll mod = 1000000009;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nll MAXM = 3010;\nvl fact(MAXM);\nvl rfact(MAXM);\n\nll mod_pow(ll x, ll p, ll M) {\n\tll a = 1;\n\twhile (p) {\n\t\tif (p % 2)\n\t\t\ta = a*x%M;\n\t\tx = x*x%M;\n\t\tp /= 2;\n\t}\n\treturn a;\n}\n\nll mod_inverse(ll a, ll m) {\n\treturn mod_pow(a, m - 2, m);\n}\n\nll nCr(ll n, ll r) {\n\tll ret = fact[n];\n\tret = (ret*mod_inverse(fact[r], MOD)) % MOD;\n\tret = (ret*mod_inverse(fact[n - r], MOD)) % MOD;\n\treturn ret;\n}\n\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfact[0] = 1; rfact[0] = 1;\n\trep1(i, n) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\trfact[i] = mod_inverse(fact[i], MOD);\n\t}\n\tstring s;\n\tcin >> s;\n\tvi sum1(n + 1);\n\trep(i, n) {\n\t\tif (s[i] == '1') {\n\t\t\tsum1[i + 1] = sum1[i] + 1;\n\t\t}\n\t\telse {\n\t\t\tsum1[i + 1] = sum1[i];\n\t\t}\n\t}\n\tvi l, r;\n\trep(i, m) {\n\t\tint l0, r0;\n\t\tcin >> l0 >> r0;\n\t\tl0--;\n\t\tif (l.empty()) {\n\t\t\tl.push_back(l0);\n\t\t\tr.push_back(r0);\n\t\t}\n\t\telse {\n\t\t\tif (r.back() < r0) {\n\t\t\t\tif (l.back() == l0) {\n\t\t\t\t\tl.pop_back();\n\t\t\t\t\tr.pop_back();\n\t\t\t\t}\n\t\t\t\tl.push_back(l0);\n\t\t\t\tr.push_back(r0);\n\t\t\t}\n\t\t}\n\t}\n\tm = l.size();\n\tl.push_back(inf); r.push_back(inf);\n\t//DEBUG_VEC(sum1);\n\t//DEBUG_VEC(l); DEBUG_VEC(r);\n\tvll dp(m + 1, vl(n + 5));\n\tdp[0][sum1[l[0]]] = 1;\n\tint mi = sum1[l[0]], ma = sum1[l[0]];\n\trep(i, m) {\n\t\t//DEBUG(i);\n\t\t//DEBUG(mi); DEBUG(ma);\n\t\tif (r[i] <= l[i + 1]) {\n\t\t\tfor (int j = mi; j <= ma; j++) {\n\t\t\t\tif (i != m - 1) {\n\t\t\t\t\tdp[i + 1][sum1[l[i + 1]]] += dp[i][j] * nCr(r[i] - l[i], sum1[r[i]] - j) % MOD;\n\t\t\t\t\tdp[i + 1][sum1[l[i + 1]]] %= MOD;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][n + 4] += dp[i][j] * nCr(r[i] - l[i], sum1[r[i]] - j) % MOD;\n\t\t\t\t\tdp[i + 1][n + 4] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i != m - 1) {\n\t\t\t\tmi = ma = sum1[l[i + 1]];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint mi0 = inf, ma0 = -1;\n\t\t\tfor (int j = mi; j <= ma; j++) {\n\t\t\t\tint nokori = sum1[r[i]] - j;\n\t\t\t\t//DEBUG(nokori);\n\t\t\t\tfor (int k = max(0, nokori - (r[i] - l[i + 1])); k <= min(nokori, l[i + 1] - l[i]); k++) {\n\t\t\t\t\tdp[i + 1][j + k] += dp[i][j] * nCr(l[i + 1] - l[i], k) % MOD;\n\t\t\t\t\tdp[i + 1][j + k] %= MOD;\n\t\t\t\t\tmi0 = min(mi0, j + k); ma0 = max(ma0, j + k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmi = mi0; ma = ma0;\n\t\t}\n\t\t//DEBUG(mi); DEBUG(ma);\n\t}\n\tcout << dp[m][n + 4] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n, m;\n\nconst int maxn = 3005;\nchar s[maxn];\n\nconst int mod = 1e9 + 7;\nint cnt[maxn];\nint dp[maxn][maxn];\nint c[maxn][maxn];\n\nvoid init(){\n    c[0][0] = 1;\n    for(int i = 1;i < maxn;i++){\n        c[i][0] = c[i][i] = 1;\n        for(int j = 1;j < i;j++){\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n        }\n    }\n}\n\ntypedef pair<int, int> pii;\n\npii p[maxn];\n\nbool cmp(pii a, pii b){\n    if(a.first != b.first)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nint main(){\n    init();\n    cin >> n >> m;\n    scanf(\"%s\", s + 1);\n    cnt[0] = 0;\n    for(int i = 1;i <= n;i++){\n        cnt[i] = cnt[i - 1] + (s[i] == '0');\n    }\n    for(int i = 1;i <= m;i++){\n        scanf(\"%d%d\", &p[i].first, &p[i].second);\n    }\n    p[m + 1] = make_pair(n + 1, n + 1);\n    sort(p + 1, p + m + 2, cmp);\n    int tot = 0;\n    dp[0][cnt[p[1].first - 1]] = 1;  \n    for(int i = 1, j = 1;i <= m;i = j + 1, j = i){\n        while(p[j + 1].second <= p[i].second){\n            j++;\n        }\n        int nxt = j + 1;\n        int l = p[i].first, r = p[i].second;\n        tot++;\n        if(p[nxt].first <= r){\n            int len = p[nxt].first - l;\n            for(int j = 0;j <= cnt[n];j++){\n                if(dp[tot - 1][j] == 0)\n                    continue;\n                int R = min(cnt[r] - j, len);\n                int L = max(0, cnt[r] - j - (r - p[nxt].first + 1));\n                for(int k = L;k <= R;k++){\n                    add(dp[tot][k + j], 1LL * dp[tot - 1][j] * c[len][k] % mod);\n                }\n            }\n        }else{\n            int len = r - l + 1;\n            for(int j = 0;j <= cnt[n];j++){\n                if(dp[tot - 1][j] == 0)\n                    continue;\n                int num = cnt[r] - j;\n                add(dp[tot][cnt[p[nxt].first - 1]], 1LL * dp[tot - 1][j] * c[len][num] % mod);\n            }\n        }\n    }\n    int ans = dp[tot][cnt[n]];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t*/\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3005, mod = 1e9 + 7;\nint N, M, Right[maxn], s[maxn];\nlong long dp[maxn][maxn];\nchar str[maxn];\ninline int S(int L, int R){return (s[R] - s[L - 1]);}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", str + 1);\n\tfor(int i = 1; i <= N + 1; ++i) s[i] = s[i - 1] + (str[i] == '1');\n\tfor(int i = 1; i <= N + 1; ++i) Right[i] = i;\n\tfor(int L, R, i = 1; i <= M; ++i){\n\t\tscanf(\"%d%d\", &L, &R);\n\t\tRight[L] = max(Right[L], R);\n\t}\n\tfor(int i = 1; i <= N; ++i) Right[i] = max(Right[i], Right[i - 1]);\n\tdp[1][s[Right[1]]] = 1;\n\tfor(int i = 1; i <= N; ++i)\n\t\tfor(int j = 0; j <= N; ++j)\n\t\t\tif(dp[i][j]){\n\t\t\t\tint lin = S(Right[i] + 1, Right[i + 1]);\n\t\t\t\tint one = j, zero = Right[i] - (i - 1) - j;\n\t\t\t\tif(one) dp[i + 1][j - 1 + lin] = (dp[i + 1][j - 1 + lin] + dp[i][j]) % mod;  \n\t\t\t\tif(zero) dp[i + 1][j + lin] = (dp[i + 1][j + lin] + dp[i][j]) % mod;\n\t\t\t}\n\tcout << dp[N + 1][0];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint can_go[4000];\nint cnt_one[4000];\nint cnt_zero[4000];\nint dp[4000][4000];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < s.length(); ++i) {\n\t\tcan_go[i] = i;\n\t\tif (i != 0) {\n\t\t\tcnt_one[i] = cnt_one[i - 1];\n\t\t\tcnt_zero[i] = cnt_zero[i - 1];\n\t\t}\n\t\tif (s[i] == '1') {\n\t\t\tcnt_one[i]++;\n\t\t}\n\t\telse {\n\t\t\tcnt_zero[i]++;\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tfor (int i = a; i <= b; ++i) {\n\t\t\tcan_go[i] = max(can_go[i], b);\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint limit_one = cnt_one[can_go[i]];\n\t\tint limit_zero = cnt_zero[can_go[i]];\n\t\tfor (int q = 0; q <= limit_one; ++q) {\n\t\t\tif (dp[i][q] == 0) continue;\n\t\t\tint remaining_one = limit_one - q;\n\t\t\tint now_zero = i - q;\n\t\t\tint remaining_zero = limit_zero - now_zero;\n\t\t\tif (remaining_zero > 0) {\n\t\t\t\tdp[i + 1][q] += dp[i][q];\n\t\t\t\tdp[i + 1][q] %= MAX_MOD;\n\t\t\t}\n\t\t\tif (remaining_one > 0) {\n\t\t\t\tdp[i + 1][q + 1] += dp[i][q];\n\t\t\t\tdp[i + 1][q + 1] %= MAX_MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][cnt_one[n-1]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\nlli n,m;\nstring s;\nvector<lli> sum;\nvector<lli> rightend;\nvector<vector<lli> > dp;\nint main(){\n    cin >> n >> m;\n    cin >> s;\n    sum = vector<lli> (n+1);\n    rightend = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++){\n        rightend[i] = i;\n    }\n    for(lli i = 0;i < n;i++){\n        sum[i+1] = sum[i] + (s[i] - '0');\n    }\n    for(lli i = 0;i < m;i++){\n        lli l,r;\n        cin >> l >> r;\n        for(lli j = l,j <= r;j++) rightend[j] = max(rightend[j],r);\n    }\n    dp = vector<vector<lli> > (n+1,vector<lli> (n+1));\n    dp[0][0] = 1;\n    for(lli i = 0;i < n;i++){\n        lli b,e;\n        b = max(0ll,i - (rightend[i] - sum[rightend[i]]));\n        e = min(i,sum[rightend[i]]);\n        for(lli j = b;j <= e;j++){\n            dp[i+1][j] += dp[i][j];dp[i+1][j] %= 1000000007;\n            dp[i+1][j+1] += dp[i][j];dp[i+1][j] %= 1000000007;\n        }\n    }\n    cout < dp[n][sum[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\nconst long long MOD=1000000007;\nlong long op(string &S,int l,int r)\n{\n\tl--;\n\tr--;\n\tset<string> sSet;\n\tsSet.insert(S);\n\tint n=0;\n\twhile (n<r-l+1){\n\t\tchar ch=S[l];\n\t\tfor (int i=l;i<=r;i++){\n\t\t\tS[i]=S[i+1];\n\t\t}\n\t\tS[r]=ch;\n\t\tsSet.insert(S);\n\t\tn++;\n\t}\n\treturn sSet.size();\n}\nint main(int argc, char* argv[])\n{\n\tint N,M;\n\tcin>>N>>M;\n\tstring S;\n\tcin>>S;\n\tint i;\n\tint l,r;\n\tlong long aw=0;\n\tfor (i=0;i<M;i++){\n\t\tcin>>l>>r;\n\t\taw+=op(S,l,r);\n\t}\n\tcout<<aw<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nlong long n,m,i,j,dp[3005][3005],l[3005],r[3005],mod=1000000007,cnt[3005],x,y;\nstring st;\nint main()\n{\n\tcin>>n>>m>>st;\n\tst=\" \"+st;\n\tfor (i=1;i<=n;i++) \n\t{\n\t\tcnt[i]=cnt[i-1]+st[i]-'0';\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tl[i]=i;\n\t\tr[i]=i;\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tr[x]=max(r[x],y);\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tr[i]=max(r[i],r[i-1]);\n\t}\n\tdp[0][0]=1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=0;j<=r[i];j++)\n\t\t{\n\t\t\tif (j>cnt[r[i]]) break;\n\t\t\tif (j>=cnt[r[i]]-r[i]+i)\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j]+dp[i-1][j-1];\n\t\t\t\tdp[i][j]%+mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][cnt[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  /*bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };*/\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[3331][3333];\nint l[3331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[3331];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v[2];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(int n,int m)\n{\n  if(n>a) return 1;\n  //if(m>u[l[n]].y-n+1) return 0;\n  if(o[n][m]>=0) return o[n][m];\n  if(l[n]==0)\n  {\n   if(l[n+1]==0) return f(n+1,m);\n  else\n  {\n    //printf(\"##%d %d\\n\",n,m);\n   return f(n+1,m+j[u[l[n+1]].y]-j[n]);\n  }\n  }\n  long long k=0;\n  /*if(l[n+1]==0)\n  {\n    k=f(n+1,m);\n  }\n  else*/ if(l[n+1]!=l[n]&&l[n+1])\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m+j[u[l[n+1]].y]-j[u[l[n]].y]);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1+j[u[l[n+1]].y]-j[u[l[n]].y]))%mod;\n  }\n  else\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1))%mod;\n  }\n  return o[n][m]=k;\n}\n\nint main()\n{\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  scanf(\"%s\",r+1);\n  for(int t=1;t<=a;j[t]+=j[t-1],t++)\n  if(r[t]=='1') j[t]=1;\n  for(int t=1;t<=b;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    if(u[c].x==n) u[c].y=max(u[c].y,m);\n    else if(u[c].y<m)\n    {\n      c++;\n      u[c]={n,m};\n    }\n  }\n  for(int t=1;t<=c;t++)\n  {\n    for(int i=u[t].x;i<=u[t].y;i++)\n      l[i]=t;\n  }\n  printf(\"%lld\",f(u[1].x,j[u[1].y]-j[u[1].x-1]));\n}\n//3\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 34;\nint n, m;\nint mx[N], mn[N];\nint dp[N][N];\nstring s;\nsigned main()\n{\n\tint cnt = 0;\n\tcin >> n >> m;\n\tcin >> s;\n\ts = \"a\" + s;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcnt += (s[i] == '1');\n\t\tmn[i] = cnt,\n\t\tmx[i] = cnt;\n\t}\n\t// cout << cnt << ' ';\n\t// cout << mx[4] << ' ';\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint tmp1 = mn[r] - mn[l - 1],\n\t\t\ttmp2 = mx[r] - mx[l - 1];\n\t\t// cout << tmp1 << ' ' << tmp2 << '\\n';\n\t\tfor(int j = l; j <= r; j++)\n\t\t{\n\t\t\tmn[j] = min(mn[j], mn[l - 1] + max(0LL, tmp1 - r + j));\n\t\t\tmx[j] = max(mx[j], mx[l - 1] + min(j - l + 1, tmp2));\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = mn[i]; j <= mx[i]; j++)\n\t\t{\n\t\t\tif(j > 0)\n\t\t\t \tdp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];\n\t\t\t else\n\t\t\t \tdp[i][j] = dp[i - 1][j];\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t\t\n\t}\n\tcout << dp[n][cnt];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n    for(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n    for(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\n\nint num[3005];\nint dp[3005][3005];\nstring sa;\npriority_queue<P,vector<P>,greater<P> > q1;\n\nint main(){\n    int n,m;\n    int i,j,k;\n    int a,b,c;\n    cin>>n>>m;\n    cin>>sa;\n    for(i=0;i<n;i++){\n        if(sa[i]=='1')num[i]++;\n        if(i!=0)num[i]+=num[i-1];\n    }\n    for(i=0;i<m;i++){\n        cin>>a>>b;\n        a--,b--;\n        q1.push(make_pair(a,b));\n    }\n    int en=0;\n    dp[0][0]=1;\n    for(i=0;i<n;i++){\n        en=max(en,i);\n        while(!q1.empty() && q1.top().first==i){\n            en=max(en,q1.top().second),q1.pop();\n        }\n        for(j=max(i-(en-num[en]+1),0);j<=num[en];j++){\n            if(dp[i][j]>=MAX)dp[i][j]%=MAX;\n            if(j<num[en])dp[i+1][j+1]+=dp[i][j];\n            if(j!=i-(en-num[en]+1))dp[i+1][j]+=dp[i][j];\n        }\n    }\n    cout<<dp[n][num[n-1]]%MAX<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1e9 + 7;\n\nll dp[3005][3005], comb[3005][3005];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\n\tvector<int> l, r;\n\tint rmax = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint tl, tr;\n\t\tcin >> tl >> tr;\n\t\ttl--;\n\t\trmax = max(rmax, tr);\n\t\tl.push_back(tl);\n\t\tr.push_back(rmax);\n\t}\n\n\tvector<int> sum(n + 1, 0);\n\tfor (int i = 0; i < n; i++) sum[i + 1] = sum[i] + s[i] - '0';\n\n\tfor (int i = 0; i <= n; i++) comb[i][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcomb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD;\n\t\t}\n\t}\n\t\n\tdp[0][sum[l[0]]] = 1;\n\tl.push_back(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i > 0 && l[i] == l[i - 1] && r[i] < r[i - 1]) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= sum[r[i]]; j++) {\n\t\t\tif (dp[i][j] == 0) continue;\n\t\t\tint rest = sum[r[i]] - j;\n\t\t\tint plus = max(sum[l[i + 1]] - sum[r[i]], 0);\n\t\t\tint L = min(r[i], l[i + 1]) - l[i];\n\t\t\tfor (int k = max(L - (r[i] - l[i] - rest), 0); k <= min(L, rest); k++) {\n\t\t\t\t(dp[i + 1][j + k + plus] += dp[i][j] * comb[L][k] % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[m][sum[n]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 3010;\nconst int MOD = 1e9 + 7;\nint n, m;\nint li[N], ri[N];\nint C[N][N], f[N][N];\nstring st;\nvoid ADD(int &t, int d) {t += d; if (t >= MOD) t -= MOD;}\nint main()\n{\n    cin >> n >> m;\n    cin >> st;\n    for (int i = 0; i <= n; ++ i)\n    {\n        C[i][0] = C[i][i] = 1;\n        for (int j = 1; j < i; ++ j)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n    }\n    for (int i = 1; i <= m; ++ i)\n    {\n        cin >> li[i] >> ri[i];\n        if (ri[i] < ri[i - 1]) i --, m --;\n    }\n    li[m + 1] = ri[m + 1] = n + 1;\n    f[0][0] = 1;\n    for (int i = 1; i <= m; ++ i)\n    {\n        int c = 0;\n        for (int j = max(ri[i - 1] + 1, li[i]); j <= ri[i]; ++ j)\n            if (st[j - 1] == '1') c ++;\n        for (int j = 0; j <= max(ri[i - 1] - li[i] + 1, 0); ++ j)\n            for (int k = 0; k <= min(j + c, min(li[i + 1] - 1, ri[i]) - li[i] + 1); ++ k)\n                if (j + c - k <= max(ri[i] - li[i + 1] + 1, 0))\n                    ADD(f[i][j + c - k], 1ll * f[i - 1][j] * C[min(li[i + 1] - 1, ri[i]) - li[i] + 1][k] % MOD);\n    }\n    cout << f[m][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nint getint()\n{\n    char ch=getchar();\n    int f=1,x=0;\n    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return f*x;\n}\n\nconst int N=3030;\nconst int MOD=1000000007;\n\nint n,m;\nchar s[N];\nint sum[N];\nint l[N],r[N];\nlong long c[N][N],f[N][N];\n\nvoid init()\n{\n    n=getint(),m=getint();\n    scanf(\"%s\",s+1);\n    for(int i=1; i<=n; i++) sum[i]=sum[i-1]+s[i]-'0';\n    int tot=0;\n    for(int i=1; i<=m; i++){\n        int ll=getint(),rr=getint();\n        if(ll==l[tot]){\n            r[tot]=max(r[tot],rr);\n        }else if(rr<=r[tot]){\n        }else{\n            tot++;\n            l[tot]=ll;\n            r[tot]=rr;\n        }\n    }\n    m=tot;\n    for(int i=0; i<=n; i++){\n        c[i][0]=1;\n        for(int j=1; j<=i; j++){\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;\n        }\n    }\n    l[m+1]=n+1;\n    r[m+1]=n+1;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    init();\n    f[0][0]=1;\n    for(int i=1; i<=m; i++){\n        int nxt=r[i]>=l[i+1]?r[i]-l[i+1]+1:0;\n        int pre=r[i-1]>=l[i]?r[i-1]-l[i]+1:0;\n        for(int k=0; k<=pre; k++){\n            if(f[i-1][k]==0) continue;\n            int lb=max(nxt-(r[i]-l[i]+1-(sum[r[i]]-sum[l[i]-1])-(pre-(sum[l[i]+pre-1]-sum[l[i]-1]))+pre-k),0);\n            int rb=min(sum[r[i]]-sum[l[i]-1]-(sum[l[i]+pre-1]-sum[l[i]-1])+k,nxt);\n            for(int j=lb; j<=rb; j++){\n                f[i][j]=(f[i][j]+f[i-1][k]*c[r[i]-l[i]+1-nxt][sum[r[i]]-sum[l[i]-1]-(sum[l[i]+pre-1]-sum[l[i]-1])+k-j])%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",f[m][0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nstring s;\n\nint cnt[3005];\nint mx[3005], mn[3005];\nint dp[3005][3005];\nsigned main()\n{\n\tcin>>n>>m>>s;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcnt[i]=cnt[i-1]+(s[i-1]=='1');\n\t\tmx[i]=cnt[i], mn[i]=cnt[i];\n\t}\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint l, r;\n\t\tcin>>l>>r;\n\n\t\tint lol=mn[r]-mn[l-1], lel=mx[r]-mx[l-1];\n\n\t\tfor(int j=l; j<=r; j++)\n\t\t{\n\t\t\tmn[j]=min(mn[j], mn[l-1]+max(0, lol-(r-j)));\n\t\t\tmx[j]=max(mx[j], mx[l-1]+min(j-l+1, lel));\n\t\t}\n\t}\n\t// for(int i=1; i<=n; i++)\n\t// {\n\t// \tcout<<mx[i]<<\" \"<<mn[i]<<endl;\n\t// }\n\tdp[0][0]=1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=mn[i]; j<=mx[i]; j++)\n\t\t{\n\t\t\tif(j>0)\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][cnt[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#undef LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nconst int N = 3003;\nmint dp[N][N];\n\nvoid solve() {\n    int n,m;\n    cin >> n >> m;\n    string s; cin >> s;\n    vector<int> sum(n+2);\n    sum[0] = 0;\n    for (int i = 0; i < n; i++) {\n        sum[i+1] = sum[i] + (s[i]-'0');\n    }\n    sum[n+1] = sum[n];\n    vector<int> R(n+2);\n    iota(R.begin(), R.end(), 0);\n    for (int _ = 0; _ < m; _++) {\n        int l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n+1; i++) {\n        R[i] = max(R[i], R[i-1]);\n    }\ndbg(sum, R);\n    dp[0][sum[R[1]]] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            int one = j, zero = R[i] - (i-1) - j;\n            int l = R[i], r = R[i+1];\n            int new_one = sum[r]-sum[l];\n            if (one > 0) dp[i][one-1 + new_one] += dp[i-1][j];\n            if (zero > 0) dp[i][one  + new_one] += dp[i-1][j];\n        }\n    }\n    cout << dp[n][0];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2016 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <cassert>\n#include <ctime>\n#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\ntypedef long long LL;\ntypedef std::pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstd::string procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return std::string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        if (ch == '-')\n            f = -1;\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 3e3 + 5;\nconst int MOD = 1e9 + 7;\n\nint N, M;\nint ub[MAXN];\nint sum[MAXN];\n\nvoid input()\n{\n    read(N); read(M);\n    static char inp[MAXN];\n    scanf(\"%s\", inp + 1);\n    for (int i = 1; i <= N; ++i) {\n        sum[i] = sum[i - 1] + (inp[i] == '1');\n    }\n    for (int i = 1; i <= M; ++i) {\n        int l, r;\n        read(l); read(r);\n        chkmax(ub[l], r);\n    }\n    for (int i = 1; i <= N; ++i) {\n        chkmax(ub[i], std::max(i, ub[i - 1]));\n    }\n}\n\nvoid solve()\n{\n    static int dp[MAXN][MAXN];\n\n    dp[0][0] = 1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            if (!dp[i][j])\n                continue;\n            int s = sum[ub[i + 1]] - sum[ub[i]];\n            if (j <= ub[i] - i) (dp[i + 1][j + s] += dp[i][j]) %= MOD;\n            if (j - 1 <= ub[i] - i && j >= 1) (dp[i + 1][j - 1 + s] += dp[i][j]) %= MOD;\n        }\n    }\n    int ans = (dp[N][0] + dp[N][1]) % MOD;\n\n    write(ans); putchar('\\n');\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\nnamespace mystd {\n\tint stoi(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tint res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\tlong long stoll(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tlong long res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\ttemplate<class T>\n\tstd::string to_string(T d) {\n\t\tstd::stringstream ss;\n\t\tss << d;\n\t\tstd::string res;\n\t\tss >> res;\n\t\treturn res;\n\t}\n}\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\n\nint dp[6003][3003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVAR(std::string, s);\n\tVEC_ROW(int, m, l, r);\n\tREP(i, m) --l[i];\n\n\tstd::stack<PAIR> st;\n\tREP(i, m) {\n\t\tif (!st.empty()){\n\t\t\tif (r[i] <= st.top().second) continue;\n\t\t\tif (st.top().first == l[i] && st.top().second <= r[i]) {\n\t\t\t\tst.pop();\n\t\t\t\t--i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tst.push(PAIR(l[i], r[i]));\n\t}\n\n\tstd::vector<std::vector<PAIR>> lr;\n\tint pre = -1;\n\t{\n\t\tstd::vector<PAIR> pv;\n\t\twhile (!st.empty()) {\n\t\t\tPAIR p = st.top(); st.pop();\n\t\t\tpv.emplace_back(p);\n\t\t}\n\t\tstd::reverse(ALL(pv));\n\n\t\tfor (const auto& p : pv) {\n\t\t\tif (pre < p.first) {\n\t\t\t\tlr.emplace_back();\n\t\t\t}\n\t\t\tlr.back().emplace_back(p);\n\t\t\tpre = p.second;\n\t\t}\n\t}\n\n\tint ans = 1;\n\tint pos = 0;\n\tfor (auto& v : lr) {\n\t\tdp[pos][0] = 1;\n\n\t\tint L = v.front().first, R = v.front().first;\n\t\tint t = v.back().second;\n\t\tint sz = 0;\n\t\tint preR = INFINT;\n\t\tv.emplace_back(t, t);\n\t\tfor (const auto& p : v) {\n\t\t\tint add = 0, del = 0;\n\t\t\twhile (R < p.second) {\n\t\t\t\tadd += s[R] == '1';\n\t\t\t\t++R;\n\t\t\t}\n\t\t\twhile (L < p.first) {\n\t\t\t\t++del;\n\t\t\t\t++L;\n\t\t\t}\n\n\t\t\tREP(i, del + 1) FOR(j, i, sz + 1) {\n\t\t\t\tif (dp[pos][j] == 0) continue;\n\t\t\t\tif (j - i > preR - p.first) continue;\n\t\t\t\t(dp[pos + 1][j - i + add] += Combination(del, i) * dp[pos][j]) %= MOD;\n\t\t\t}\n\t\t\tsz = p.second - p.first;\n\t\t\tpreR = p.second;\n\t\t\t++pos;\n\t\t}\n\t\t(ans *= dp[pos][0]) %= MOD;\n\t\t++pos;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}\n/*\n|-------|\n   |--------|\n---      ----\ndel       add\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 3005,mo = int(1e9) + 7;\n\nstring s;\nint a[maxn],m,far[maxn],f[maxn][maxn],co[maxn],n,ans;\n\nint dfs(int l,int r,int c)\n{\n\tif (l == n + 1) return 1;\n\tif (r < far[l]) c += co[far[l]] - co[r],r = far[l];\n\tif (~f[l][c]) return f[l][c];\n\tint ans = 0;\n\tif (c) ans = (ans + dfs(l + 1,r,c - 1)) % mo;\n\tif (r - l + 1 - c) ans = (ans + dfs(l + 1,r,c)) % mo;\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s;\n\tfor(int i = 1;i <= n;i ++) a[i] = s[i - 1] - '0',co[i] = co[i - 1] + a[i];\n\tfor(int i = 1,l,r;i <= m;i ++) cin >> l >> r,far[l] = max(far[l],r);\n\tfor(int i = 1;i <= n;i ++) far[i] = max(far[i],far[i - 1]),far[i] = max(far[i],i);\n\tmemset(f,255,sizeof f);\n\tcout << dfs(1,0,0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <functional>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass combination{\nprivate:\n    vector<mint> fact,finv;\npublic:\n    combination(int N){\n        fact = finv = vector<mint>(N+1);\n        fact[0] = fact[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(ll i=2;i<=N;i++){\n            fact[i] = fact[i-1]*i;\n            finv[i] = fact[i].inv();\n        }\n    }\n    mint f(int i){\n        return fact[i];\n    }\n    mint comb(int n,int k){\n        if(n<k) return 0;\n        if(n<0 || k<0) return 0;\n        return fact[n]*finv[k]*finv[n-k];\n    }\n    mint hcomb(int n,int k){\n        if(n==0 && k==0) return 1;\n        return comb(n+k-1,k);\n    }\n};\n\nint main(){\n    int N,M;\n    string S;\n    cin >> N >> M >> S;\n    vector<int> L(M+1),R(M+1);\n    vector<int> mi(N+1,N+1),ma(N+1,0);\n    for(int i=1;i<=M;i++){\n        cin >> L[i] >> R[i];\n        for(int j=L[i];j<=R[i];j++){\n            mi[j] = min(mi[j],i);\n            ma[j] = max(ma[j],i);\n        }\n    }\n    vector<int> get1(N+2,0),getc(N+2,0),remove(N+2,0);\n    for(int i=1;i<=N;i++){\n        get1[mi[i]] += (S[i-1]=='1');\n        getc[mi[i]]++;\n        remove[ma[i]]++;\n    }\n    vector<mint> dp(N+1,0);\n    combination c(N);\n    dp[0] = 1;\n    int now = 0;\n    for(int i=1;i<=M;i++){\n //       cerr << i << \" \" << getc[i] << \" \" << remove[i] << endl;\n        for(int j=now;j>=0;j--) dp[j+get1[i]] = dp[j];\n        for(int j=get1[i]-1;j>=0;j--) dp[j] = 0;\n        now += getc[i];\n        if(!remove[i]) continue;\n        vector<mint> ndp(N+1,0);\n        for(int j=0;j<=now;j++){\n            for(int k=0;k<=min(j,remove[i]);k++){\n                if(0<=j-k && j-k<=now-remove[i]) ndp[j-k] += dp[j]*c.comb(remove[i],k);\n            }\n        }\n        now -= remove[i];\n        swap(dp,ndp);\n//        for(int j=0;j<=N;j++) cerr << dp[j].x << (j!=N? \" \":\"\\n\");\n    }\n    cout << dp[0].x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n\nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])];k++)\n\t\t\t{\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=0;\n    for (int i=0;i<=n;i++) ans=(ans+f[tot-1][i])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tq[m+1].l=n+1;q[m+1].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[1][sum[q[2].r]-sum[q[2].l-1]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i+1].r-q[i].l+1;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;k++){\n\t\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 3010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%1d\", a + i);\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        if(R < l){\n            for(; j < l; ++j){\n                if(j > R){\n                    R = j;\n                    ad = a[i];\n                }\n                else ad = 0;\n                for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                    if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                    if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n\n                }\n            }\n        }\n        if(r > R){\n            ad = sum[r] - sum[R];\n            R = r;\n        }\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j){\n        if(j > R){\n            R = j;\n            ad = a[i];\n        }\n        else ad = 0;\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxm+8],fact[maxm+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 6005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint s0[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    make();\n    vp vec(m+1);\n    rep(i,m){\n        cin >> vec[i].fi >> vec[i].se;\n        --vec[i].fi,--vec[i].se;\n    }\n    rep(i,n){\n        if(s[i] == '0'){\n            s0[i+1] = s0[i] + 1;\n        }else{\n            s0[i+1] = s0[i];\n        }\n    }\n    int nw,l = 1,r = 0;\n    vp data;\n    vec[m] = P(n-1,n);\n    rep(i,m+1){\n        // show(i);\n        // show(nw);\n        // svecp(data);\n        if(vec[i].se <= r){\n            continue;\n        }\n        if(r <= vec[i].fi){\n            ll val = 0;\n            if(r > 0){\n                rep(j,len(data)){\n                    ll zero = data[j].fi;\n                    ll al = r-l+1;\n                    val = add(val,mul(data[j].se,comb(al,zero)));\n                }\n            }else{\n                val = 1;\n            }\n            nw = i,l = vec[nw].fi,r = vec[nw].se;\n            vp hoge;\n            hoge.pb(P(s0[r+1]-s0[l],val));\n            data = hoge;\n            continue;\n        }\n        //重なり\n        int lm = r-vec[i].fi+1;\n        //右の覆われていない部分の0の個数\n        int sm = s0[vec[i].se+1] - s0[r+1];\n        vector<int> nx(s0[vec[i].se+1] - s0[vec[i].fi+1]+2,0);\n        rep(j,len(data)){\n            int cnt = data[j].fi;\n            int leng = vec[i].fi - l;\n            int mn = max(cnt-leng,0);\n            int mx = min(cnt,lm);\n            srep(k,mn,mx+1){\n                nx[sm+k] = add(nx[sm+k],mul(comb(leng,cnt-k),data[j].se));\n            }\n        }\n        vp hoge;\n        rep(j,len(nx)){\n            if(nx[j]){\n                hoge.pb(P(j,nx[j]));\n            }\n        }\n        data = hoge;\n        nw = i,l = vec[nw].fi,r = vec[nw].se;\n    }\n    cout << data[0].se << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1]+s[i]-'0';\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(i&&q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tq[m].l=n+1;q[m].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[0][sum[q[1].r]-sum[q[1].l-1]]=1;\n\tfor(int i=0;i<m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j],dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i+1].r-q[i].l+1;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=LEN;j++)\n\t\t\t\tfor(int k=0;k<=len;k++){\n\t\t\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\t\t\tif(pre>=j-k&&j>=k)dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k],dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 5e3 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int MOD = 1e9 + 7;\nconst int TM = 3;\nconst int BASE = 257;\n\nint n, a[xn], part[xn], m, dp[xn][xn], res;\nstring s;\n\nint main(){\n    InTheNameOfGod;\n    \n\tcin >> n >> m >> s;\n\tfor (int i = 1; i <= n; ++ i) a[i] = i;\n\twhile (m --){\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\ta[l] = max(a[l], r);\n\t}\n\tfor (int i = 1; i <= n; ++ i) part[i] = part[i - 1] + (s[i - 1] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tres = max(res, a[i]);\n\t\tfor (int j = max(0, i - res + part[res]); j <= part[res]; ++ j){\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j) dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n\t\t}\n\t}\n\tcout << dp[n][part[n]] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// think twice code once\n// Start:2016-12-12 11:02:48\n// End  :\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, x, y) for(int i = (x), _ = (y); i <= _; ++ i)\n#define per(i, x, y) for(int i = (x), _ = (y); i >= _; -- i)\n#define dprintf(...) fprintf(stderr, __VA_ARGS__)\n#define disp(x) cout << #x << \" = \" << x << \"; \"\n\ntypedef long long LL;\n\ntemplate <class T> bool chkmin(T& a, T b) { return a > b ? a = b, true : false; }\ntemplate <class T> bool chkmax(T& a, T b) { return a < b ? a = b, true : false; }\n\ntemplate <class T> void read(T& a) {\n\tchar c = getchar(); T f = 1; a = 0;\n\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\tfor(; isdigit(c); c = getchar()) a = a * 10 + c - '0';\n\ta *= f;\n}\n\ntemplate <class T> void write(T a) {\n\tstatic int stk[60]; \n\tint tp = 0;\n\tif(a < 0) putchar('-'), a = -a;\n\tdo {\n\t\tstk[++ tp] = a % 10;\n\t\ta /= 10;\n\t}while(a);\n\t\n\twhile(tp) putchar(stk[tp--] + '0');\n}\n\nconst int maxN = 3005, mo = 1e9 + 7;\n\nint dp[maxN][maxN];\nint N, M;\nint a[maxN], b[maxN];\nchar s[maxN];\n\nvoid move1(int l, int r) {\n\tint tot1 = 0;\n\trep(i, l, r) tot1 += a[i];\n\trep(i, l, l + tot1 - 1) a[i] = 1;\n\trep(i, l + tot1, r) a[i] = 0;\n}\n\nvoid move2(int l, int r) {\n\tint tot0 = 0;\n\trep(i, l, r) tot0 += b[i] == 0;\n\trep(i, l, l + tot0 - 1) b[i] = 0;\n\trep(i, l + tot0, r) b[i] = 1;\n}\n\nint main() {\n#ifdef Leeson\n\tfreopen(\"tmp.in\", \"r\", stdin);\n\tfreopen(\"tmp.out\", \"w\", stdout);\n#endif\n\n\tread(N); read(M);\n\tscanf(\"%s\", s + 1);\n\trep(i, 1, N) a[i] = b[i] = s[i] - '0';\n\trep(i, 1, M) {\n\t\tint x, y;\n\t\tread(x); read(y);\n\t\tmove1(x, y);\n\t\tmove2(x, y);\n\t}\n\n//\trep(i, 1, N) printf(\"%d\", a[i]); puts(\"\");\n//\trep(i, 1, N) printf(\"%d\", b[i]); puts(\"\");\n\n\trep(i, 1, N) a[i] += a[i - 1], b[i] += b[i - 1];\n\n\tdp[0][0] = 1;\n\trep(i, 1, N) rep(j, b[i], a[i]) {\n\t\tdp[i][j] = dp[i - 1][j];\n\t\tif(j) dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mo;\n\t}\n\tcout << dp[N][a[N]] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 3e3 + 7, MOD = 1e9 + 7;\nint n, m, total, corder[N], prev[N], dp[N][N];\nchar now;\n\ninline int max(int a, int b){return a > b?a:b;}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor (register int i = 1;i <= n;i ++){\n\t\twhile (now = getchar(), now != '1' && now != '0')continue;\n\t\tprev[i] = prev[i - 1], corder[i] = i;\n\t\tif (now == '1')total ++, prev[i] ++;\n\t}\n\tprev[n + 1] = prev[n], corder[n + 1] = n + 1;\n\tfor (register int i = 1, x, y;i <= m;i ++){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tcorder[x] = max(corder[x], y);\n\t}\n\tfor (register int i = 1;i <= n + 1;i ++)corder[i] = max(corder[i], corder[i - 1]);\n\tdp[1][prev[corder[1]]] = 1;\n\tfor (register int i = 1;i <= n;i ++)\n\t\tfor (register int j = 0;j <= total;j ++)\n\t\t\tif (dp[i][j]){\n\t\t\t\tif (j)dp[i + 1][j + prev[corder[i + 1]] - prev[corder[i]] - 1] = (dp[i + 1][j + prev[corder[i + 1]] - prev[corder[i]] - 1] + dp[i][j])%MOD;\n\t\t\t\tif (corder[i] + 1 - i - j)dp[i + 1][j + prev[corder[i + 1]] - prev[corder[i]]] = (dp[i + 1][j + prev[corder[i + 1]] - prev[corder[i]]] + dp[i][j])%MOD;\n\t\t\t}\n\treturn !printf(\"%d\", dp[n + 1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=3000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nchar s[N+9];\nint n,nxt[N+9];\n\nvoid into(){\n  int m;\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1);\n  for (int i=1;i<=m;++i){\n\tint l,r;\n\tscanf(\"%d%d\",&l,&r);\n\tnxt[l]=max(nxt[l],r);\n  }\n}\n\nint a[N+9];\n\nvoid Get_a(){\n  for (int i=1;i<=n;++i) a[i]=s[i]-'0'+a[i-1];\n  a[n+1]=a[n];\n}\n\nvoid Get_nxt(){\n  for (int i=1;i<=n+1;++i){\n\tif (!nxt[i]) nxt[i]=i;\n\tnxt[i]=max(nxt[i],nxt[i-1]);\n  }\n}\n\nint dp[N+9][N+9];\n\nvoid Get_dp(){\n  dp[1][a[nxt[1]]]=1;\n  for (int i=1;i<=n;++i)\n\tfor (int j=0;j<=n;++j){\n\t  if (!dp[i][j]) continue;\n\t  int l=nxt[i],r=nxt[i+1],c0=nxt[i]-i+1-j,c1=j;\n\t  if (c1) sadd(dp[i+1][j+a[r]-a[l]-1],dp[i][j]);\n\t  if (c0) sadd(dp[i+1][j+a[r]-a[l]],dp[i][j]);\n\t}\n}\n\nvoid work(){\n  Get_a();\n  Get_nxt();\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",dp[n+1][0]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3010\n#define MOD 1000000007\n#define int ull\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\nbool vis[maxn][maxn];\npi A[maxn];\nint fac[maxn];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = (res*x) % MOD;  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn (a * qexp(b,MOD-2)) % MOD;\n}\n\nint choose(ll n,ll k){\n\tif (n < k) return 0;\n\treturn modinv(modinv(fac[n],fac[k]),fac[n-k]);\n}\n\ninline int qry(pi i){\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint mult(int a,int b){ //logb\n\tint res = 0;\n\ta %= MOD;\n\twhile (b){\n\t\tif (b&1) res = (res + a) % MOD;\n\t\t\n\t\ta = (2*a) % MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\n\n\nint dpf(int i,int j){\n\tif (vis[i][j]) return dp[i][j];\n\tvis[i][j] = 1;\n\t\n\tif (i == M) return dp[i][j] = 1;\n\tif (i == M-1){\n\t\treturn dp[i][j] = choose(sz(A[i]),j);\n\t}\n\t\n\tdp[i][j] = 0;\n\t\n\tFOR(k,0,N){\n\t\tif (k > sz(inter(A[i],A[i+1]))) break;\n\t\tif (k > j) break;\n\t\t\n\t\tdp[i][j] += mult(dpf(i+1,qry(A[i+1]) - qry(inter(A[i],A[i+1])) + k),choose(sz(A[i]) - sz(inter(A[i],A[i+1])),j - k));\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n\t\t\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,N){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\t\t\t\n\tcout<<dpf(0,qry(A[0]));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[4000][4000];\nint b[4000];\nint sum[4000];\n\nint main(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvector<P>v;\n\trep(i,m){\n\t\tint l,r;scanf(\"%d%d\",&l,&r);l--;r--;\n\t\tif(v.empty())v.push_back(P(l,r));\n\t\telse if(v.back().first==l)v.back().second=max(v.back().second,r);\n\t\telse if(v.back().second<r)v.push_back(P(l,r));\n\t}\n\tfor(auto p:v)b[p.first]=p.second;\n\tfor(int i=1;i<n;i++)b[i]=max({i,b[i],b[i-1]});\n\tint cnt=0;\n\trep(i,n){\n\t\tif(s[i]=='1')cnt++;\n\t\tsum[i]=cnt;\n\t}\n\tdp[0][cnt]=1;\n\trep(i,n)rep(j,cnt+1){\n\t\tif(dp[i][j]==0)continue;\n\t\tint a=j-(sum[n-1]-sum[b[i]]);\n\t\tif(a)(dp[i+1][j-1]+=dp[i][j])%=MOD;\n\t\tif(b[i]-i+1-a)(dp[i+1][j]+=dp[i][j])%=MOD;\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define allof(a)        a.begin(),a.end()\n#define fi              first\n#define se              second\n#define pb              push_back\n#define F(i,a,b)        for(int i=a;i<=b;i++)\n#define D(i,a,b)        for(int i=a;i>=b;i--)\n#define inf             0x3f3f3f3f3f3f3f3f\n#define mn              3001\n#define task            \"holiday\"\nusing namespace std;\nconst int mod=          1e9+7;\ntypedef pair<int,int>   ii;\ntypedef pair<int,ii>    ip;\n\ntemplate<typename _t>\nbool ckmax(_t& target,_t value)\n    {return value>target ? target=value,1 : 0;}\n\ntemplate<typename _t>\nbool ckmin(_t& target,_t value)\n    {return value<target ? target=value,1 : 0;}\n\nint n,m;\nint a[mn];\nint t[mn];\nint r[mn];\nint dp[mn][mn];\n\nint32_t main()\n{\n    ios::sync_with_stdio(0);\n    #ifdef _TPR_\n        freopen(\"t.inp\",\"r\",stdin);\n        freopen(\"t.out\",\"w\",stdout);\n    #endif\n    cin>>n>>m;\n    string s;cin>>s;\n    F(i,1,n)a[i]=s[i-1]-'0';\n    F(i,1,n)t[i]=t[i-1]+a[i];\n    F(i,1,m)\n    {\n        int u,v;cin>>u>>v;\n        ckmax(r[u],v);\n    }\n    dp[0][0]=1;\n    F(i,1,n)\n    {\n        ckmax(r[i],max(i,r[i-1]));\n        if(t[r[i]]<r[i]-i+1)dp[i][0]=dp[i-1][0];\n        F(j,1,i)\n        {\n            if(t[r[i]]-j<r[i]-i+1)dp[i][j]+=dp[i-1][j];\n            if(t[r[i]]-j>=0)dp[i][j]+=dp[i-1][j-1];\n            dp[i][j]%=mod;\n        }\n    }\n    int res=0;\n    F(j,0,n)res=(res+dp[n][j])%mod;\n    cout<<res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN (3010)\n#define mod (1000000007)\n\nint n, m;\nint sumOne[MAXN], dp[MAXN][MAXN], right[MAXN];  //dp[i][j] means [0, i) has j ones\nchar str[MAXN];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", str);\n\tfor(int i = 0; i < n; ++ i){\n\t\tsumOne[i] = (i ? sumOne[i - 1] : 0) + str[i] - '0';\n\t\tright[i] = i;\n\t}\n\tfor(int i = 1; i <= m; ++ i){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\t-- l; -- r;\n\t\tfor(int j = l; j <= r; ++ j){\n\t\t\tright[j] = std::max(right[j], r);\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\tfor(int i = 0; i < n; ++ i){\n\t\tfor(int usedOne = 0; usedOne < i + 1; ++ usedOne){\n\t\t\tint r = right[i];\n\t\t\tint restOne = sumOne[r] - usedOne;\n\t\t\tif(restOne < 0) continue;\n\t\t\t\n\t\t\tif(restOne > 0){   //fill str[i] with '1'\n\t\t\t\t(dp[i + 1][usedOne + 1] += dp[i][usedOne]) %= mod;\n\t\t\t}\n\t\t\t\n\t\t\tif(r - i + 1 != restOne){  //fill str[i] with '0'\n\t\t\t    (dp[i + 1][usedOne] += dp[i][usedOne]) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][sumOne[n - 1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        sz = r[i] - l[i + 1] + 1;\n        if (l[i + 1] <= r[i]) {\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k)\n                    inc(f[i][j], 1ll * f[i - 1][k] * c[l[i + 1] - l[i]][k + sum[r[i]] - sum[r[i - 1]] - j] % Mod);\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * c[r[i] - l[i] + 1][k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]] % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\nconst int mod= 1e9 + 7;\n\nint r[3005];\nint n, l;\nchar str[3005];\nint ps[3005];\nint sum(int s, int e){\n\treturn ps[e] - ps[s-1];\n}\n\nint dp[3005][3005];\n\nlint f(int x, int y){\n\tif(y < 0 || y > r[x] - x + 1) return 0;\n\tif(x == n+1) return y == 0;\n\tif(~dp[x][y]) return dp[x][y];\n\tint ret = 0;\n\tif(y < r[x] - x + 1) ret += f(x+1, y + sum(r[x]+1, r[x+1]));\n\tif(y) ret += f(x+1, y-1 + sum(r[x]+1, r[x+1]));\n\treturn dp[x][y] = ret % mod;\n}\n\nint main(){\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> n >> l >> (str + 1);\n\tfor(int i=1; i<=n; i++) r[i] = i, ps[i] = (str[i] == '1');\n\tfor(int i=0; i<l; i++){\n\t\tint s, e;\n\t\tcin >> s >> e;\n\t\tr[s] = max(r[s], e);\n\t}\n\tr[n+1] = n;\n\tfor(int i=2; i<=n; i++){\n\t\tr[i] = max(r[i], r[i-1]);\n\t\tps[i] += ps[i-1];\n\t}\n\tcout << f(1, sum(1, r[1])) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int Mod=1e9+7,N=3e3+10;\n\nint n,m,dp[N][N],summ[N];\nchar s[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;++i) summ[i]=summ[i-1]+(s[i]=='0'); \n}\n\nvoid Solve() {\n\tint nowr=0,l,r,cnt=0;\n\tscanf(\"%d%d\",&l,&r); ++cnt;\n\tdp[0][0]=1;\n\tfor (int i=0;i<n;++i) {\n\t\tint sum=0; \n\t\twhile (i+1==l && cnt<=m) {\n\t\t\tif (r>nowr) sum+=summ[r]-summ[nowr],nowr=r;\n\t\t\tif (cnt<m) { scanf(\"%d%d\",&l,&r); ++cnt; }\n\t\t\telse break; \n\t\t}\n\t\tif (nowr>i){\n\t\t\tfor (int j=0;j<=nowr-i;++j) {\n\t\t\t\tif (j+sum) dp[i+1][j+sum-1]=(dp[i+1][j+sum-1]+dp[i][j])%Mod;\n\t\t\t\tif (nowr-i-j-sum) dp[i+1][j+sum]=(dp[i+1][j+sum]+dp[i][j])%Mod; \n\t\t\t}\n\t\t}else dp[i+1][0]=dp[i][0],nowr=i+1;\n\t}\n\tprintf(\"%d\\n\",dp[n][0]);\n} \n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=3005,mod=1000000007;\ntypedef long long LL;\nchar S[N];\nint n,m,s[N],x[N],y[N],c[N][N],tot,l[N],r[N],maxn;\nLL f[N][N];\nstruct data{int x,y;} dat[N];\n\nint getint()\n{\n\tchar ch;\n\tint f=1;\n\twhile(!isdigit(ch=getchar())) if(ch=='-') f=-1;\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x*f;\n}\n\nbool cmp(data a,data b)\n{\n\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n}\n\nint main()\n{\n\tn=getint(),m=getint(),scanf(\"%s\",S+1);\n\trep(i,0,n) c[i][0]=c[i][i]=1;\n\trep(i,1,n) rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\trep(i,1,n) s[i]=s[i-1]+S[i]-48;\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\tsort(dat+1,dat+1+m,cmp);\n\trep(i,1,m) if(dat[i].y>maxn) ++tot,x[tot]=dat[i].x,y[tot]=dat[i].y,maxn=dat[i].y;\n\tf[0][0]=1,x[tot+1]=y[tot+1]=n+1;\n\trep(i,1,tot)\n\t{\n\t\tint w=min(y[i]-x[i]+1,x[i+1]-x[i]),a=s[y[i]]-s[max(x[i]-1,y[i-1])];\n\t\tl[i]=max(0,l[i-1]+a-w),r[i]=min(max(y[i]-x[i+1]+1,0),r[i-1]+a);\n\t\trep(j,l[i],r[i])\n\t\t\trep(k,l[i-1],r[i-1])\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][k]*c[w][k+a-j])%mod;\n\t}\n\tprintf(\"%lld\\n\",f[tot][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    if(v[i].second < v[i+1].first){\n        return dp[i][s] = (pt[v[i].second-v[i].first+1][tmp]*saiki(i+1,0))%mod;\n    }else{\n        for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n            ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n        }\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    // for(int i=0;i<v.size();i++){\n    //     cout << v[i].first << \" \" <<v[i].second << endl;\n    // }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        if(v[i].first>v[i].second){\n            for(int j=v[i].first;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }else{\n            for(int j=v[i-1].second+1;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }\n        nm[i] = tmp;\n        //cout << i << \" \" <<  nm[i] << endl;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    if(v[0].second <v[1].first){\n        ans = (pt[v[0].second-v[0].first+1][tmp]*saiki(1,0))%mod;\n    }else{\n        for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n            ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\ntypedef long long ll;\nconst ll mod = 1e9+7;\nconst int maxn = 3030;\n\n\n\nint n, m;\nstring s;\nint a[maxn];\nint b[maxn];\nll dp[maxn][maxn];//# ways to fill first i elems, holding j 1's\n\n\n\nvoid add(ll& x, ll y) {\n    x %= mod;\n    y %= mod;\n    x += y;\n    x %= mod;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>m;\n    cin>>s;\n    for (int i=0; i<n; i++) {\n\ta[i]=(s[i]-'0');\n\tb[i]=i+1;\n    }\n\n    for (int i=0; i<m; i++) {\n\tint l,r; cin>>l>>r;\n\t--l; --r;\n\tb[l]=max(b[l],r+1);\n    }\n\n    for (int i=1; i<n; i++) {\n\tb[i]=max(b[i],b[i-1]);\n    }\n\n    dp[0][0]=1;\n    for (int i=0, j=0; i<n; i++) {\n\tint ones = 0;\n\twhile (j<b[i]) ones+=a[j++];\n\n\tfor (int x=0; x<=n; x++) {\n\t    if (dp[i][x] == 0) continue;\n\t    int cur=x+ones;\n\n\t    //put 1 at ith index\n\t    if (cur!=0) {\n\t\tadd(dp[i+1][cur-1], dp[i][x]);\n\t    }\n\n\t    // put 0 at ith index\n\t    if (j-i != cur) {\n\t\tadd(dp[i+1][cur], dp[i][x]);\n\t    }\n\t}\n    }\n\n    ll ans = dp[n][0];\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    cout<<ans<<endl;\n  \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 34;\nint n, m;\nint mx[N], mn[N];\nint dp[N][N];\nstring s;\nsigned main()\n{\n\tint cnt = 0;\n\tcin >> n >> m;\n\tcin >> s;\n\ts = \"a\" + s;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcnt += ( s[i] - '0' );\n\t\tmn[i] = cnt,\n\t\tmx[i] = cnt;\n\t}\n\t// cout << cnt << ' ';\n\t// cout << mx[4] << ' ';\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint tmp1 = mn[r] - mn[l - 1],\n\t\t\ttmp2 = mx[r] - mx[l - 1];\n\t\t// cout << tmp1 << ' ' << tmp2 << '\\n';\n\t\tfor(int j = l; j <= r; j++)\n\t\t{\n\t\t\tmn[j] = min(mn[j], mn[l - 1] + max(0LL, tmp1 - r + j));\n\t\t\tmx[j] = max(mx[j], mx[l - 1] + min(j - l + 1, tmp2));\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = mn[i]; j <= mx[i]; j++)\n\t\t{\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif(j > 0)\n\t\t\t \tdp[i][j] += dp[i - 1][j - 1];\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t\t\n\t}\n\tcout << dp[n][cnt];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cstring>\n#define N 3005\nusing namespace std;\nconst int mod=1e9+7;\nint n,m;\nint s[N],val[N],dp[2][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tgetchar();\n\tfor(int i=1;i<=n;i++) s[i]=getchar()-'0'+s[i-1];\n\tint cnt=0;\n\tfor(int i=1,ml,mr;i<=m;i++)\n\t\tscanf(\"%d%d\",&ml,&mr),val[ml]=max(val[ml],mr);\n\tfor(int i=1;i<=n;i++) val[i]=max(max(i,val[i]),val[i-1]); \n\tint now=0;\n\tdp[now][0]=1;\n\tfor(int i=1;i<=n;i++,now^=1){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=s[val[i]]-(val[i]-i);j<=s[val[i]];j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+ (j==0?0:dp[now][j-1]) )%mod;\n\t}\n\tcout<<dp[now][s[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr int MOD = 1000000007;\n\nclass mint {\n  int n;\npublic:\n  mint(int n_ = 0) : n(n_) {}\n  explicit operator int() { return n; }\n  friend mint operator-(mint a) { return -a.n + MOD * (a.n != 0); }\n  friend mint operator+(mint a, mint b) { int x = a.n + b.n; return x - (x >= MOD) * MOD; }\n  friend mint operator-(mint a, mint b) { int x = a.n - b.n; return x + (x < 0) * MOD; }\n  friend mint operator*(mint a, mint b) { return (long long)a.n * b.n % MOD; }\n  friend mint &operator+=(mint &a, mint b) { return a = a + b; }\n  friend mint &operator-=(mint &a, mint b) { return a = a - b; }\n  friend mint &operator*=(mint &a, mint b) { return a = a * b; }\n  friend bool operator==(mint a, mint b) { return a.n == b.n; }\n  friend bool operator!=(mint a, mint b) { return a.n != b.n; }\n  friend istream &operator>>(istream &i, mint &a) { return i >> a.n; }\n  friend ostream &operator<<(ostream &o, mint a) { return o << a.n; }\n};\nmint operator \"\" _m(unsigned long long n) { return n; }\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int N, M; cin >> N >> M;\n  string S; cin >> S;\n  vector<pair<int, int>> I(M); rep(i, M) {\n    cin >> I[i].first >> I[i].second, I[i].first--;\n  }\n  sort(I.begin(), I.end());\n  vector<pair<int, int>> J;\n  for (auto i : I) {\n    if (J.empty() || (J.back().second < i.second)) {\n      J.push_back(i);\n    }\n  }\n  vector<int> sum(N+1);\n  rep(i, N) sum[i+1] = sum[i] + (S[i] == '1');\n  vector<mint> dp0(N+1), dp1(N+1);\n  dp0[0] = 1;\n  J.insert(J.begin(), make_pair(-1, -1));\n  J.emplace_back(N, N);\n  for (int i=1; i+1<J.size(); i++) {\n    int l = J[i].first;\n    int r = min(J[i].second, J[i+1].first);\n    int c = sum[J[i].second] - sum[max(J[i].first, J[i-1].second)];\n    int d = max(0, J[i-1].second - J[i].first);\n    for (int j=d+1; j<=N; j++) dp0[j]=0;\n    fill(dp1.begin(), dp1.end(), 0);\n    for (int j=0; j+c<=N; j++) {\n      dp1[j + c] += dp0[j];\n    }\n    swap(dp0, dp1);\n    for (int j=l; j<r; j++) {\n      fill(dp1.begin(), dp1.end(), 0);\n      for (int k=0; k<=N; k++) {\n        if (k>0) dp1[k-1] += dp0[k];\n        dp1[k] += dp0[k];\n      }\n      swap(dp0, dp1);\n    }\n  }\n  cout << dp0[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\nclass Modulo\n{\npublic:\n    Modulo(const ll n, const ll mod = MOD) : size{n + 1}, mod{mod}, fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)  // mod should be prime\n    {\n        for (ll i = 2; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % mod;\n            inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod;\n            inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod;\n        }\n    }\n    ll factorial(const ll n) const\n    {\n        assert(n < size);\n        return fact[n];\n    }\n    ll inverse(const ll n) const\n    {\n        assert(n < size);\n        return inv[n];\n    }\n    ll inverseFactorial(const ll n) const\n    {\n        assert(n < size);\n        return inv_fact[n];\n    }\n    ll permutation(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (fact[n] * inv_fact[n - k]) % mod;\n    }\n    ll combination(const ll n, const ll k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod;\n    }\n    ll homogenious(const ll n, const ll k) const { return (n == 0 and k == 0 ? 1 : combination(n + k - 1, k)); }\n\nprivate:\n    const ll size;\n    const ll mod;\n    vector<ll> fact;\n    vector<ll> inv;\n    vector<ll> inv_fact;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<vector<ll>> tmp(3001);\n    for (ll i = 0; i < M; i++) {\n        ll l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (tmp[l].size() > 0) {\n            if (tmp[l][0] < r) {\n                tmp[l][0] = r;\n            }\n        } else {\n            tmp[l].push_back(r);\n        }\n    }\n    using P = pair<ll, ll>;\n    vector<P> R;\n    ll r = 0;\n    for (ll i = 0; i <= 3000; i++) {\n        if (tmp[i].size() > 0 and tmp[i][0] > r) {\n            R.push_back({i, tmp[i][0]});\n            r = tmp[i][0];\n        }\n    }\n    const ll size = R.size();\n    vector<P> intersect(size);\n    intersect[0] = {-1, -1};\n    for (ll i = 1; i < size; i++) {\n        if (R[i].first > R[i - 1].second) {\n            intersect[i] = {R[i].first, R[i].first - 1};\n        } else {\n            intersect[i] = {R[i].first, R[i - 1].second};\n        }\n    }\n    intersect.push_back({N, N});\n    vector<ll> one(size + 1, 0);\n    vector<ll> one_orig(size, 0);\n    for (ll i = 0; i < size; i++) {\n        if (i == 0) {\n            one[i] = 0;\n        } else {\n            for (ll j = intersect[i].first; j <= intersect[i].second; j++) {\n                one[i] += (S[j] == '1' ? 1 : 0);\n            }\n        }\n        for (ll j = R[i].first; j <= R[i].second; j++) {\n            one_orig[i] += (S[j] == '1' ? 1 : 0);\n        }\n    }\n    Modulo mod(N + 1);\n    vector<ll> dp(N + 1, 0);  // i番目の区間\n    dp[0] = 1;\n    for (ll i = 0; i < size; i++) {\n        vector<ll> tmp(N + 1, 0);\n        for (ll j = 0; j <= intersect[i].second - intersect[i].first + 1; j++) {\n            if (dp[j] > 0) {\n                const ll tot = one_orig[i] - one[i] + j;\n                const ll next = intersect[i + 1].second - intersect[i + 1].first + 1;\n                const ll rest = R[i].second - R[i].first + 1 - next;\n                for (ll k = max(0LL, tot - rest); k <= min(tot, next); k++) {\n                    (tmp[k] += mod.combination(rest, tot - k) * dp[j] % MOD) %= MOD;\n                }\n            }\n        }\n        dp = tmp;\n    }\n    ll ans = 0;\n    for (ll i = 0; i <= N; i++) {\n        (ans += dp[i]) %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) \n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nstring s;\nll dp[3010][3010];\nint tar[3010];\n\nconst ll mod=1000000007LL;\nconst int limit=3000;\nll C[limit+1][limit+1];\n\n\n\nint main(void){\n\n\trep(i,limit+1){\n\t\trep(j,i+1){\n\t\t\tif(j==0 or j==i)\n\t\t\t\tC[i][j]=1LL;\n\t\t\telse\n\t\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t\t}\n\t}\n\n\n\tint n,m;\n\tcin >> n >> m >> s;\n\trep(i,n) tar[i]=i+1;\n\ttar[n]=n;\n\t\n\trep(i,m){\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tchmax(tar[l],r);\n\t}\n\n\trep(i,1,n+1) chmax(tar[i],tar[i-1]);\n\t\n\t//rep(i,n+1) cout << tar[i] << endl;\n\n\tint one=0;\n\trep(i,tar[0]) one+=(s[i]=='1');\n\tdp[0][one]=1LL;\n\t\n\trep(i,n){\n\t\tint add=0;\n\t\trep(j,tar[i],tar[i+1]) add+=(s[j]=='1');\n\t\t//cout << \"Len : \" << tar[i]-i << endl;\n\t\trep(c,tar[i]-i+1){\n\t\t\tif(c>0) dp[i+1][c-1+add]+=dp[i][c];\n\t\t\tif(c<tar[i]-i) dp[i+1][c+add]+=dp[i][c];\n\t\t}\n\t}\n\n\t//rep(i,2) cout << dp[n-1][i] << endl;\n\tcout << dp[n][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    rep(j, lm[i]+1) tmp[lm[i]+1] += dp[j];\n    rep2(j, lm[i]+1, rm[i]+1) tmp[j+1] = tmp[j] + dp[j];\n    swap(dp, tmp);\n    dump(dp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(s) s.begin(), s.end()\n#define pb push_back\n#define ii pair<int, int>\n#define x first\n#define y second\n#define bit(x, y) ((x >> y) & 1)\n#define bug(x) cerr<<#x<<\" = \"<<x<<'\\n'\n\nusing namespace std;\nusing ll = long long;\n\nconst int mod = 1000000007;\n\nint n, m, ans = 0;\nint dp[3005][3005];\nint cntmn[3005], cntmx[3005];\nstring s;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \" \" + s;\n//    bug(s);\n    string t = s;\n    for (int l, r, i = 1; i <= m; i++) {\n        cin >> l >> r;\n        sort(s.begin() + l, s.begin() + r + 1);\n        sort(t.begin() + l, t.begin() + r + 1, greater<char>());\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        cntmn[i] = cntmn[i - 1] + (t[i] == '0');\n        cntmx[i] = cntmx[i - 1] + (s[i] == '0');\n        if (cntmn[i] == 0) dp[i][0] = dp[i - 1][0];\n        for (int j = max(cntmn[i], 1); j <= cntmx[i]; j++) {\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        ans = (ans + dp[n][i]) % mod;\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define X   first\n#define Y   second\n\nconst int   N   = 3e3 + 1;\nconst int   mod = 1e9 + 7;\n\nint add(int &a,int b)   {\n    a += b;\n    if(a >= mod)a -= mod;\n    return  a;\n}\n\nstring s;\nint n, q;\nint r[N];\nint c[N];\n\nint f[N][N];\n\nint cal(int L,int C)    {\n    if (C < 0)\n        return  0;\n    if (C > r[L - 1] - L + 1)\n        return  0;\n    if (L == n)\n        return  1;\n    C += c[r[L]] - c[r[L - 1]];\n    if (f[L][C] < 0)\n        f[L][C] = 0,\n        add(f[L][C],cal(L + 1,C)),\n        add(f[L][C],cal(L + 1,C - 1));\n    return  f[L][C];\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> q;\n    cin >> s;\n\n    s = \"#\" + s;\n\n    iota(r + 1,r + 1 + n,1);\n\n    for(int i = 1 ; i <= q ; ++i)   {\n        int L;  cin >> L;\n        int R;  cin >> R;\n        r[L] = max(r[L],R);\n    }\n\n    for(int i = 1 ; i <= n ; ++i)\n        r[i] = max(r[i],r[i - 1]),\n        c[i] = c[i - 1] + s[i] - '0';\n\n    memset(f,-1,sizeof f);\n\n    cout << cal(1,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\n#define fo(i,a,b) for(int i=(a);i<=(b);++i)\n#define fd(i,a,b) for(int i=(a);i>=(b);--i)\n#define rep(i,a,b)  for(int i=(a);i<(b);++i)\n#define fi  first\n#define se  second\n#define LL  unsigned long long\n#define uint unsigned int\n#define pb  push_back\n#define eb  emplace_back\n#define bit(s,i) ((s >> i) & 1)\n#define off(s,i) (s & (~ (1 << i)))\n#define ii pair <int , int>\n#define iii1 pair <ii , int>\n#define iii2 pair <int , ii>\n#define TASK \"F-SHUFFLING\"\nusing   namespace   std;\nconst long long inf = 0x3f3f3f3f3f3f3f3f;\nconst int oo = 0x3f;\nconst int base = 1e9 + 7;\nint n , m , a[3010] , up[3010] , f[3010][3010];\nstring s;\n///--------------------------\nvoid readf() {\n    cin >> n >> m >> s;\n    s = \" \" + s;\n    for (int i = 1 ; i <= n ; ++i)\n    a[i] = a[i-1] + (s[i] == '1');\n}\n///--------------------------\nvoid solve() {\n    for (int i = 1 ; i <= m ; ++i) {\n        int u , v;\n        cin >> u >> v;\n        up[u] = max(up[u],v);\n    }\n    f[0][0] = 1;\n    for (int i = 1 ; i <= n ; ++i) {\n        up[i] = max({up[i] , up[i-1] , i});\n        if (a[up[i]] < up[i] - i + 1) f[i][0] = f[i-1][0];\n        for (int j = 1 ; j <= i ; ++j) {\n            if (a[up[i]] - j < up[i] - i + 1) f[i][j] = (f[i][j] + f[i-1][j]) % base;\n            if (a[up[i]] - j >= 0) f[i][j] = (f[i][j] + f[i-1][j-1]) % base;\n        }\n    }\n    cout << (f[n][a[n]] % base + base) % base;\n}\n///--------------------------\nint main() {\n   #ifdef BDP0509\n       freopen(TASK\".inp\", \"r\", stdin);\n       freopen(TASK\".out\", \"w\", stdout);\n   #endif // ONLINE_JUDGE\n   ios::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   readf();\n   solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    int ans;\n    REP(i, M){\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        int t = n1[rmax + 1];\n        if(l1 <= rmax){\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            REP(k, t + 1){\n                dp[i + 1][t] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][t] %= mod;\n            }\n        }\n        if(i == M - 1) ans = dp[M][t];\n    }\n    //debug(dp);\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i],ls[i]--;\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint pl=-1,pr=-1;\n\t\t\trep(i,m) if(pr<rs[i]){\n\t\t\t\tif(pl<ls[i])\n\t\t\t\t\tts.emplace_back(ls[i],rs[i]);\n\t\t\t\telse\n\t\t\t\t\tts.back()=mt(ls[i],rs[i]);\n\t\t\t\ttie(pl,pr)=ts.back();\n\t\t\t}\n\t\t\tint l0=get<0>(ts[0]);\n\t\t\ts=s.substr(l0);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=l0,rs[i]-=l0;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['0'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m)\n\t\t\trepi(i,ls[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nchar s[5000];\nint c[5000];\nll dp[3005][3005],nck[3005][3005];\nint u[N];\nll solve(vector<pii> z){\n  REP(i,z.size()+1) REP(j,3005) dp[i][j]=0;\n  dp[0][c[z[0].Y]-c[z[0].X-1]]=1;\n  ll ans=0;\n  REP(i,z.size()) REP(j,3005) if(dp[i][j]){\n    if(i+1==z.size()){\n      ans+=nck[z[i].Y-z[i].X+1][j]*dp[i][j]%mod;\n    }else{\n      int ex=c[z[i+1].Y]-c[z[i].Y],zo=z[i].Y-z[i].X+1-j;\n      REP(k,min(j,z[i+1].X-z[i].X)+1) if(z[i+1].X-z[i].X-k<=zo){\n        dp[i+1][ex+j-k]+=nck[z[i+1].X-z[i].X][k]*dp[i][j]%mod;\n        dp[i+1][ex+j-k]%=mod;\n      }\n    }\n  }\n  return ans%mod;\n}\nint main(){\n  nck[0][0]=1;\n  REPP(i,1,3005){\n    nck[i][0]=1;\n    REPP(j,1,i+1) nck[i][j]=(nck[i-1][j]+nck[i-1][j-1])%mod;\n  }\n  int n,m; scanf(\"%d%d%s\",&n,&m,s);\n  vector<pii> a,nw;\n  ll ans=1;\n  REP(i,n) c[i+1]=c[i]+(s[i]=='1');\n  REP(i,m){\n    pii x;\n    scanf(\"%d%d\",&x.X,&x.Y);\n    a.pb(x);\n  }\n  sort(all(a));\n  a.resize(unique(all(a))-a.begin());\n  m=a.size();\n  REP(i,m) REP(j,m) if(i!=j){\n    if(a[i].X<=a[j].X&&a[j].Y<=a[i].Y) u[j]=1;\n  }\n  REP(i,m) if(!u[i]) nw.pb(a[i]);\n  a=nw;\n  int tl=0;\n  while(tl<a.size()){\n    vector<pii> cur; cur.pb(a[tl++]);\n    while(tl<a.size()&&a[tl].X<=cur.back().Y) cur.pb(a[tl++]);\n    ans=ans*solve(cur)%mod;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0LL) {\n        value = x % mod;\n        if (value < 0LL) value += mod;\n    }\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0LL) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        long long a = 0LL, b = 1, c = other.value, m = mod;\n        while (c != 0LL) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0LL) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular operator-() { return modular(-value); }\n    modular operator+(modular rhs) { return modular(*this) += rhs; }\n    modular operator-(modular rhs) { return modular(*this) -= rhs; }\n    modular operator*(modular rhs) { return modular(*this) *= rhs; }\n    modular operator/(modular rhs) { return modular(*this) /= rhs; }\n    bool operator==(modular rhs) { return value == rhs.value; }\n    bool operator!=(modular rhs) { return value != rhs.value; }\n    bool operator<(modular rhs) { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0LL) x.value += mod;\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0LL) x.value += mod;\n    return stream;\n};\nconst long long mod = (long long)1e9 + 7;\nusing mint = modular<mod>;\n\ninline mint pw(mint a, long long n) {\n    mint res = 1;\n    while (n > 0LL) {\n        if (n & 1LL) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\nvector<mint> fact, finv;\ninline void cinit(int n) {\n    fact.resize(n, mint(1));\n    finv.resize(n, mint(1));\n    for (int i = 2; i < n; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    finv[n - 1] /= fact[n - 1];\n    for (int i = n - 2; i >= 2; i--) {\n        finv[i] = finv[i + 1] * (i + 1);\n    }\n}\ninline mint C(int n, int k) {\n    if (n < k || k < 0 || n < 0) {\n        return mint(0LL);\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cinit(10000);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> l, r;\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        if (l.empty() || (l.back() < x && r.back() < y)) {\n            l.emplace_back(x);\n            r.emplace_back(y);\n        } else if (r.back() < y) {\n            r.back() = y;\n        }\n    }\n    m = l.size();\n    vector<mint> dp(1, 1);\n    for (int i = 0; i < m; i++) {\n        vector<int> c(2);\n        for (int j = max(l[i], (i != 0 ? r[i - 1] + 1 : 0)); j <= r[i]; j++) {\n            c[s[j] - '0']++;\n        }\n        int d = 0;\n        if (i != m - 1 && l[i + 1] <= r[i]) {\n            d = r[i] - l[i + 1] + 1;\n        }\n        vector<mint> ndp(d + 1);\n        c[1] += dp.size() - 1;\n        for (int j = 0; j < dp.size(); j++) {\n            for (int k = 0; k <= d; k++) {\n                ndp[k] += C(c[0] + c[1] - d, c[0] - k) * dp[j];\n            }\n            c[0]++;\n            c[1]--;\n        }\n        swap(dp, ndp);\n    }\n    cout << dp[0] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define NMAX 3005\n#define MMAX 3005\n#define mod 1000000007\n#define PIE 3.14159265358979\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N,M;\nstring S;\nint l_[MMAX],r_[MMAX];\n\nLL mpow(LL a,LL n){\n    LL ans = 1;\n    while(n>0){\n        if(n&1){ans=(ans*a)%mod;}\n        a=(a*a)%mod;\n        n>>=1;\n    }\n    return ans;\n}\n\nLL fact[NMAX+1];\nLL factinv[NMAX+1];\n\nLL comb(LL a,LL b){\n    LL ret = (fact[a]*factinv[b])%mod;\n    ret = (ret*factinv[a-b])%mod;\n    return ret;\n}\n\nLL dfs_[MMAX][NMAX];\n\nvoid init(){\n    fact[0]=1;\n    rep(i,NMAX){\n        fact[i+1]=fact[i]*(i+1);\n        fact[i+1]%=mod;\n    }\n    rep(i,NMAX+1){\n        factinv[i]=mpow(fact[i],mod-2);\n    }\n    rep(i,M+1){\n        rep(j,N+1){\n            dfs_[i][j]=-1;\n        }\n    }\n}\n\nLL dfs(int step,int czero_){\n    int czero=czero_;\n    if(dfs_[step][czero]>=0)return dfs_[step][czero];\n    if(step==M){\n        if(M>2){dfs_[M][czero]=comb(l_[M-1]-r_[M-2]+1,czero);}else{dfs_[M][czero]=1;}\n        return dfs_[M][czero];\n    }\n    int rp=0,ln=N+1;\n    int l=l_[step];\n    int r=r_[step];\n    if(step>0){\n        rp=r_[step-1];\n    }\n    if(step<M-1){\n        ln=l_[step+1];\n    }\n    for(int i = max(l,rp);i < r;i++){\n        if(S[i]=='0')czero++;\n    }\n    if(ln>=r){\n        dfs_[step][czero_]=(comb(r-l,czero)*dfs(step+1,0))%mod;\n        return dfs_[step][czero_];\n    }\n    LL ans = 0;\n    int nczeromax=min(r-ln,czero);\n    for(int nczero = max(0,czero-(ln-l));nczero<=nczeromax;nczero++){\n        ans += comb(ln-l,czero-nczero)*dfs(step+1,nczero);\n        ans %= mod;\n    }\n    dfs_[step][czero_]=ans;\n    return ans;\n}\n\nint main(){\n    cin>>N>>M;\n    cin>>S;\n    init();\n    int now = 0;\n    int M_=M;\n    rep(i,M_){\n        cin>>l_[now]>>r_[now];\n        l_[now]--;\n        if(i==0){now++;}\n        else if(l_[now]==l_[now-1]){\n            M--;\n            r_[now-1]=max(r_[now],r_[now-1]);\n        }else if(r_[now]<=r_[now-1]){\n            M--;\n        }else{now++;}\n    }\n    \n    cout<<dfs(0,0)<<endl;\n//    rep(i,M+1){\n//        rep(j,N+1){\n//            printf(\"%4lld\",dfs_[i][j]);\n//        }\n//        cout<<endl;\n//    }\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tban[i][j] = false;\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\t//assert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\tm = table.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = max(table[i].second, rightmost);\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\t//assert(problemid == 0);\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> ii;\ntypedef pair<ll,ll> pll;\n\nconst int mod=1000000000+7;\n\nint addm(int& a,int b) {return (a+=b)<mod?a:a-=mod;}\n\ntemplate<class T,class U> bool smin(T& a,U b) {return a>b?(a=b,1):0;}\ntemplate<class T,class U> bool smax(T& a,U b) {return a<b?(a=b,1):0;}\n\nint N,M;\nint l[3001],r[3001];\nint dp[3001][3001];\nstring s;\nint ct;\n\nint ncr[3001][3001];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tfor (int i=0;i<=3000;i++) for (int j=0;j<=3000;j++) {\n\t\tif (i==0) ncr[i][j]=i==j;\n\t\telse if (i==j) ncr[i][j]=1;\n\t\telse if (j>i) ncr[i][j]=0;\n\t\telse if (j==0) ncr[i][j]=1;\n\t\telse ncr[i][j]=(ncr[i-1][j-1]+ncr[i-1][j])%mod;\n\t}\n\n\tint Mend=0;\n\tcin >> N >> M >> s;\n\tfor (int i=0;i<M;i++) {\n\t\tcin >> l[ct] >> r[ct];l[ct]--;\n\t\tif (ct==0 || r[ct]>r[ct-1]) ct++;\n\t}\n\n\tl[ct]=r[ct]=N;\n\tdp[0][0]=1;\n\n\tfor (int i=0;i<ct;i++) {\n\t\tint ext=0;\n\t\tfor (int j=max(l[i],Mend);j<r[i];j++) if (s[j]=='1') ext++;\n\n\t\tint toc=min(r[i],l[i+1])-l[i];\n\t\tfor (int j=0;j<=N;j++) {\n\t\t\tif (dp[i][j]==0) continue;\n\t\t\tfor (int k=max(0,ext+j-(r[i]-l[i]-toc));k<=min(toc,ext+j);k++) {\n\t\t\t\tdp[i+1][ext+j-k]=(dp[i+1][ext+j-k]+(ll)ncr[toc][k]*dp[i][j])%mod;\n\t\t\t}\n\t\t}\n\n\t\tsmax(Mend,r[i]);\n\t}\n\n\tcout << dp[ct][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define NMAX 3005\n#define MMAX 3005\n#define mod 1000000007\n#define PIE 3.14159265358979\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N,M;\nstring S;\nint l_[MMAX],r_[MMAX];\nvector<int> sum;\n\nLL mpow(LL a,LL n){\n    LL ans = 1;\n    while(n>0){\n        if(n&1){ans=(ans*a)%mod;}\n        a=(a*a)%mod;\n        n>>=1;\n    }\n    return ans;\n}\n\nLL fact[NMAX+1];\nLL factinv[NMAX+1];\n\nLL comb(LL a,LL b){\n    LL ret = (fact[a]*factinv[b])%mod;\n    ret = (ret*factinv[a-b])%mod;\n    return ret;\n}\n\nLL dfs_[MMAX][NMAX];\n\nvoid init(){\n    fact[0]=1;\n    rep(i,NMAX){\n        fact[i+1]=fact[i]*(i+1);\n        fact[i+1]%=mod;\n    }\n    rep(i,NMAX+1){\n        factinv[i]=mpow(fact[i],mod-2);\n    }\n    rep(i,M+1){\n        rep(j,N+1){\n            dfs_[i][j]=-1;\n        }\n    }\n}\n\nLL dfs(int step,int czero_){\n    int czero=czero_;\n    if(dfs_[step][czero_]>=0)return dfs_[step][czero_];\n    if(step==M){\n        dfs_[M][czero_]=1;\n        return dfs_[M][czero_];\n    }\n    int rp=0,ln=N+1;\n    int l=l_[step];\n    int r=r_[step];\n    if(step>0){\n        rp=r_[step-1];\n    }\n    if(step<M-1){\n        ln=l_[step+1];\n    }\n    czero+=sum[r]-sum[max(l,rp)];\n    if(ln>=r){\n        dfs_[step][czero_]=(comb(r-l,czero)*dfs(step+1,0))%mod;\n        return dfs_[step][czero_];\n    }\n    LL ans = 0;\n    int nczeromax=min(r-ln,czero);\n    for(int nczero = max(0,czero-(ln-l));nczero<=nczeromax;nczero++){\n        ans += comb(ln-l,czero-nczero)*dfs(step+1,nczero);\n        ans %= mod;\n    }\n    dfs_[step][czero_]=ans;\n    return ans;\n}\n\nint main(){\n    cin>>N>>M;\n    cin>>S;\n    sum.push_back(0);\n    rep(i,N){\n        sum.push_back(sum[i]+('1'-S[i]));\n    }\n    init();\n    int now = 0;\n    int M_=M;\n    rep(i,M_){\n        cin>>l_[now]>>r_[now];\n        l_[now]--;\n        if(i==0){now++;}\n        else if(l_[now]==l_[now-1]){\n            M--;\n            r_[now-1]=max(r_[now],r_[now-1]);\n        }else if(r_[now]<=r_[now-1]){\n            M--;\n        }else{now++;}\n    }\n    cout<<dfs(0,0)<<endl;\n//    rep(i,M+1){\n//        rep(j,N+1){\n//            printf(\"%4lld\",dfs_[i][j]);\n//        }\n//        cout<<endl;\n//    }\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\t/*for(int i=1;i<=m;++i)\n\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;*/\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j))%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid read(T &x)\n{\n\tx = 0; int f = 1; char c = getchar();\n\twhile (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }\n\twhile (isdigit(c)) { x = x * 10 + c - 48; c = getchar(); }\n\tx *= f;\n}\n\ntemplate<typename T> inline int chkmax(T &x, T y) { return x < y ? x = y, 1 : 0; }\n\nconst int MAXN = 3e3 + 9, Mod = 1e9 + 7;\n\ninline int add(int a, int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline void updateA(int &a, int b) { a = add(a, b); }\n\nint n, m, s[MAXN];\nstd::unordered_map<int, int> to;\n\nint f[MAXN][MAXN]; // 1 - i - 1 已经确定，还有 j 个可选的 1 的方案数\n\ninline int Calc(int L, int R) { return s[R] - s[L - 1]; }\n\nint main()\n{\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tchar str = getchar();\n\t\ts[i] = s[i - 1] + str - 48;\n\t\tto[i] = i;\n\t}\n\ts[n + 1] = s[n];\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint l, r;\n\t\tread(l), read(r);\n\t\tchkmax(to[l], r);\n\t}\n\tfor (int i = 2; i <= n + 1; ++i)\n\t\tchkmax(to[i], to[i - 1]);\n\n\tf[1][s[to[1]]] = 1;\n\n\tfor (int i = 1; i <= n; ++i) \n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tif (f[i][j]) // 很有效的一个剪枝\n\t\t\t{\n\t\t\t\tint l = to[i] + 1, r = to[i + 1];\n\t\t\t\tint a = j, b = to[i] - i + 1 - a; // 1 的个数，0 的个数\n\t\t\t\tif (a) updateA(f[i + 1][j + Calc(l, r) - 1], f[i][j]);\n\t\t\t\tif (b) updateA(f[i + 1][j + Calc(l, r)], f[i][j]);\n\t\t\t}\n\n\tprintf(\"%d\\n\", f[n + 1][0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\nint v[5000];\nint st[5000], dr[5000];\nint init[5000];\nint a[5000], b[5000];\nint dp[5000][5000];\n\nvoid perm(int st, int dr, bool inv = 0)\n{\n    vector <int> nr;\n    for (int i(st); i <= dr; i++)\n        if (v[i])\n            nr.push_back(v[i]), v[i] = 0;\n    for (int i(inv ? dr - nr.size() + 1 : st), j(0); j < nr.size(); i++, j++)\n        v[i] = nr[j];\n}\n\nint main()\n{\n    int n, m, id = 1;\n    cin >> n >> m;\n\n    for (int i(1); i <= n; i++) {\n        char c;\n        cin >> c;\n        if (c == '1')\n            init[i] = id++;\n    }\n\n    for (int i(1); i <= m; i++)\n        cin >> a[i] >> b[i];\n\n    for (int i(1); i <= n; i++)\n        v[i] = init[i];\n\n    for (int i(1); i <= m; i++)\n        perm(a[i], b[i]);\n\n    for (int i(1); i <= n; i++)\n        if (v[i])\n            st[v[i]] = i; /// am calculat st[i]\n\n    for (int i(1); i <= n; i++)\n        v[i] = init[i];\n\n    for (int i(1); i <= m; i++)\n        perm(a[i], b[i], 1);\n\n    for (int i(1); i <= n; i++)\n        if (v[i])\n            dr[v[i]] = i; /// am calculat dr[i]\n\n    dp[0][0] = 1;\n\n    for (int i(1); i <= n; i++) {\n        for (int j(0); j < id; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j > 0 && st[j] <= i && dr[j] >= i)\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;\n        }\n    }\n\n    cout << dp[n][id - 1];\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 1e9 + 7;\nconst int MX = 4000;\nll inv[MX], f[MX], invf[MX];\nvoid calc(){\n\tinv[0] = inv[1] = f[0] = f[1] = invf[0] = invf[1] = 1;\n\tfor (int i = 2; i < MX; i++){\n\t\tinv[i] = mod - mod / i * inv[mod % i] % mod;\n\t\tf[i] = f[i - 1] * i % mod;\n\t\tinvf[i] = invf[i - 1] * inv[i] % mod;\n\t}\n}\ninline ll C(ll n, ll k){\n\treturn f[n] * invf[k] % mod * invf[n - k] % mod;\n}\n\nint sum[MX];\nll dp[2][3001];\n\nll solve(vector<pi> v){\n\t{\n\t\tint last = v.back().second, first = v[0].first;\n\t\tv.insert(v.begin(), pi(first, first));\n\t\tv.emplace_back(last, last);\n\t}\n\t\n\t//dbg(v);\n\t\n\tint n = v.size(), cur = 0, next = 1;\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0] = 1;\n\t\n\tfor(int i = 1; i + 1 < v.size(); i++){\n\t\tmemset(dp[next], 0, sizeof(dp[next]));\n\t\t\n\t\tfor(int j = 0; j <= v[i].second - v[i + 1].first; j++){\n\t\t\tint x = sum[v[i].second] - sum[v[i - 1].second];\n\t\t\t\n\t\t\tint l = max(0, j - x);\n\t\t\tint r = min(v[i - 1].second - v[i].first, j - x + v[i + 1].first - v[i].first);\n\t\t\t\n\t\t\tfor(int k = l; k <= r; k++){\n\t\t\t\tll s = C(v[i + 1].first - v[i].first, x + k - j);\n\t\t\t\tdp[next][j] += s * dp[cur][k] % mod;\n\t\t\t}\n\t\t}\n\t\trep(j, 3001) dp[next][j] %= mod;\n\t\tswap(cur, next);\n\t}\n\treturn dp[cur][0];\n}\n\nint main(){\n\tcalc();\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, m;\n\tstring s; cin >> n >> m >> s;\n\trep(i, n) sum[i + 1] = sum[i] + (s[i] == '1');\n\t\n\tvector<vector<pi>> vs;\n\tvector<pi> v;\n\trep(i, m){\n\t\tint a, b; cin >> a >> b; a--;\n\t\tif(v.size() && v.back().second >= b) continue;\n\t\tif(v.size() && v.back().second <= a){\n\t\t\tvs.pb(v);\n\t\t\tv = vector<pi>();\n\t\t}\n\t\tv.emplace_back(a, b);\n\t}\n\tvs.pb(v);\n\t\n\tll ans = 1;\n\tfor(const auto &i : vs) ans = ans * solve(i) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=3000+10;\nconst int mod=1e9+7;\nvoid add(int& x,int y) { x+=y; if (x>=mod) x-=mod; }\n\nint n,m; char str[N];\nstruct node { int l,r; } p[N];\nbool operator <(node a,node b) { return a.l<b.l||(a.l==b.l&&a.r>b.r); }\nint C[N][N],sum[N],dp[N][N];\n\nint main() {\n\tn=read(),m=read(); scanf(\"%s\",str+1);\n\tfor (int i=1;i<=m;++i) p[i].l=read(),p[i].r=read();\n\tsort(p+1,p+m+1); int top=0;\n\tfor (int i=1,x=0;i<=m;++i)\n\t\tif (p[i].r>x) p[++top]=p[i],x=p[i].r;\n\tm=top,p[m+1].l=n+1;\n\tfor (int i=1;i<=n;++i) sum[i]=sum[i-1]+str[i]-'0';\n\tdp[p[1].l-1][sum[p[1].l-1]]=1;\n\tfor (int i=C[0][0]=1;i<=n;++i)\n\t\tfor (int j=C[i][0]=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tfor (int i=1;i<=m;++i) {\n\t\tint l=p[i].l,r=p[i].r,nxt=p[i+1].l;\n\t\tfor (int j=0;j<l;++j) {\n//\t\t\tif (!dp[l-1][j]) continue;\n\t\t\tint s=sum[r]-j;\n\t\t\tif (nxt>r) \n\t\t\t\tadd(dp[nxt-1][sum[nxt-1]],1ll*dp[l-1][j]*C[r-l+1][s]%mod);\n\t\t\telse {\n\t\t\t\tint x=max(0,s-(r-nxt+1)),y=min(s,nxt-l);\n\t\t\t\tfor (int k=x;k<=y;++k)\n\t\t\t\t\tadd(dp[nxt-1][j+k],1ll*dp[l-1][j]*C[nxt-l][k]%mod);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nifstream cin (\"x.in\"); ofstream cout (\"x.out\");\n\nconst int nmax = 3000;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint s[nmax + 1];\nint d[nmax + 1][nmax + 1];\n\npair<int, int> w[nmax + 1];\nvector< pair<int, int> > unu;\n\nstring vs;\nint v[nmax + 1];\n\ninline bool cmpdr (int x) {\n    return x == 0;\n}\n\ninline bool cmpst (int x) {\n    return x > 0;\n}\n\nvoid precalc() {\n    unu.push_back(make_pair(0, 0));\n    for (int i = 0; i < n; ++ i) {\n        if (vs[ i ] == '1') {\n            v[i + 1] = unu.size();\n            unu.push_back(make_pair(0, 0));\n        }\n    }\n\n    for (int i = 1; i <= m; ++ i) {\n        stable_partition(v + w[ i ].first, v + w[ i ].second + 1, cmpdr);\n    }\n\n    for (int i = 1; i <= n; ++ i) {\n        if (v[ i ]) {\n            unu[ v[ i ] ].second = i;\n        }\n    }\n\n    int shp = 0;\n    for (int i = 0; i < n; ++ i) {\n        if (vs[ i ] == '1') {\n            v[i + 1] = ++ shp;\n        } else {\n            v[i + 1] = 0;\n        }\n    }\n\n    for (int i = 1; i <= m; ++ i) {\n        stable_partition(v + w[ i ].first, v + w[ i ].second + 1, cmpst);\n    }\n\n    for (int i = 1; i <= n; ++ i) {\n        if (v[ i ]) {\n            unu[ v[ i ] ].first = i;\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m >> vs;\n\n    for (int i = 1; i <= m; ++ i) {\n        int x, y;\n        cin >> x >> y;\n        w[ i ] = make_pair(x, y);\n    }\n\n    precalc();\n\n    d[ 0 ][ 0 ] = 1;\n    for (int i = 0; i <= n; ++ i) s[ i ] = 1;\n\n    for (int i = 1; i < (int)unu.size(); ++ i) {\n        for (int j = unu[ i ].first; j <= unu[ i ].second; ++ j) {\n            d[ i ][ j ] = s[j - 1];\n        }\n\n        s[ 0 ] = 0;\n        for (int j = 1; j <= n; ++ j) {\n            s[ j ] = s[j - 1] + d[ i ][ j ];\n            if (s[ j ] >= mod) {\n                s[ j ] -= mod;\n            }\n        }\n    }\n\n    cout << s[ n ] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<int> cnts(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        cnts[i] = cnts[i - 1];\n        char c;\n        std::cin >> c;\n        if (c == '1') ++cnts[i];\n    }\n\n    std::vector<int> to(n + 1);\n    std::iota(to.begin(), to.end(), 0);\n    while (m--) {\n        int l, r;\n        std::cin >> l >> r;\n        to[l] = std::max(to[l], r);\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        to[i] = std::max(to[i], to[i - 1]);\n    }\n\n    std::vector<mint> dp(n + 1, 0);\n    dp[0] = 1;\n    // 1を何個使ったか\n    auto ndp = dp;\n\n    for (int i = 1; i <= n; ++i) {\n        std::fill(ndp.begin(), ndp.end(), 0);\n\n        for (int one = 0; one < i; ++one) {\n            if (cnts[to[i]] - one) {\n                ndp[one + 1] += dp[one];\n            }\n            if ((to[i] - cnts[to[i]]) - ((i - 1) - one)) {\n                ndp[one] += dp[one];\n            }\n        }\n        std::swap(dp, ndp);\n    }\n\n    std::cout << dp[cnts[n]] << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long lli;\nlli n,m;\nstring s;\nvector<lli> rightend;\nvector<vector<lli> > dp;\nvector<lli> sum;\nint main(){\n    cin >> n >> m;\n    cin >> s;\n    rightend = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) rightend[i] = i;\n    for(lli i = 0;i < m;i++){\n        lli l,r;\n        cin >> l >> r;\n        rightend[l] = max(rightend[l],r);\n    }\n    sum = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) sum[i] = s[i-1] - '0';\n    for(lli i = 0;i < n;i++) sum[i+1] += sum[i];\n    for(lli i = 0;i < n;i++) rightend[i+1] = max(rightend[i+1],rightend[i]);\n    dp = vector<vector<lli> > (n+2,vector<lli>(n+2));\n    dp[0][0] = 1;\n    for(lli i = 0;i < n;i++){\n        lli b,e;\n        b = max(0ll,i - (rightend[i] - sum[rightend[i]]));\n        e = min(i,sum[rightend[i]]);\n        for(lli j = b;j <= e;j++){\n            dp[i+1][j] += dp[i][j];dp[i+1][j] %= 1000000007;\n            dp[i+1][j+1] += dp[i][j];dp[i+1][j] %= 1000000007;\n        }\n    }\n    cout << dp[n][sum[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n \ntypedef long long ll;\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y)\n{\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y)\n{\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y)\n{\n\treturn ((ll)x * y) % MOD;\n}\n \nconst int N = 3030;\nint n;\nchar s[N];\nint a[N];\nint b[N];\nint dp[N][N];\nint C[N][N];\n \nvoid read()\n{\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\" %s \", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)(s[i] - '0');\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = i + 1;\n\twhile(m--)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tb[l] = max(b[l], r);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = max(b[i], b[i - 1]);\n}\n \nint main()\n{\n\tread();\n \n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n\t\n\tdp[0][0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint willAdd = 0;\n\t\twhile(cur < b[i])\n\t\t{\n\t\t\twillAdd += a[cur];\n\t\t\tcur++;\n\t\t}\n\t\tfor (int x = 0; x <= n; x++)\n\t\t{\n\t\t\tif (dp[i][x] == 0) continue;\n\t\t\tint y = x + willAdd;\n\t\t\tif (y != 0)\n\t\t\t\tdp[i + 1][y - 1] = add(dp[i + 1][y - 1], dp[i][x]);\n\t\t\tif (y != cur - i)\n\t\t\t\tdp[i + 1][y] = add(dp[i + 1][y], dp[i][x]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][0]);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tint cnt=0;\n\t/*for(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;*/\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&q[i].l,&q[i].r);\n\t\tif(q[i].r<=q[i-1].r)m--,i--;\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j)%mod)%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005, P = 1e9 + 7;\nchar s[N];\nint n, m, d[N], f[N][N], num[N];\n\nint main () {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; ++i) d[i] = i, num[i] = num[i - 1] + (s[i] == '1');\n\tfor (int i = 1, l, r; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tif (r > d[l]) d[l] = r;\n\t}\n\tf[0][0] = 1;\n\tfor (int i = 0, r = 0; i < n; ++i) {\n\t\tif (d[i + 1] > r) r = d[i + 1];\n\t\tfor (int j = 0; j <= num[r]; ++j) {\n\t\t\tif (f[i][j] >= P) f[i][j] -= P;\n\t\t\tif (!f[i][j]) continue ;\n\t\t\tif (num[r] - j < r - i) f[i + 1][j] += f[i][j];\n\t\t\tif (num[r] - j > 0) f[i + 1][j + 1] += f[i][j];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][num[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 7;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nchar s[MAXN];\nint n, m, sum[MAXN], rbd[MAXN];\nint dp[MAXN][MAXN];\n\ninline void Inc(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\n\nvoid init() {\n\tread(n); read(m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i=1;i<=n;++i) {\n\t\tsum[i] = sum[i-1] + s[i] - '0';\n\t\trbd[i] = i;\n\t}\n\tsum[n+1] = sum[n]; rbd[n+1] = n+1;\n\tfor (int i=1;i<=m;++i) {\n\t\tint l, r;\n\t\tread(l); read(r);\n\t\tcmax(rbd[l], r);\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tcmax(rbd[i], rbd[i-1]);\n\t}\n}\n\nvoid solve() {\n\tdp[1][sum[rbd[1]]] = 1;\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=0;j<=n;++j) {\n\t\t\tint x = dp[i][j];\n\t\t\tif (!x) continue;\n\t\t\tint l = rbd[i] + 1, r = rbd[i+1];\n\t\t\tint cnt1 = j, cnt0 = rbd[i] - i + 1 - j;\n\t\t\tif (cnt0) Inc(dp[i+1][j+sum[r]-sum[l-1]], x);\n\t\t\tif (cnt1) Inc(dp[i+1][j-1+sum[r]-sum[l-1]], x);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n+1][0]);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define sd(n) scanf(\"%d\",&n)\n#define sl(n) scanf(\"%lld\",&n)\n#define pd(n) printf(\"%d\",n)\n#define pl(n) printf(\"%lld\",n)\n#define sf(n) scanf(\"%f\",&n)\n#define pf(n) printf(\"%.12f\",n)\n#define psp printf(\" \")\n#define endc printf(\"\\n\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int maxn = 3002;\nconst int md = 1e9 + 7;\n\npii Z[maxn];\nint C[maxn][maxn];\nint dp[maxn][maxn];\nint pref[maxn];\n\nint main() {\n\tIOS; string s;\n\n\tfor (int i = 0; i < maxn; i++) {\n\t\tfor (int j = 0; j < maxn; j++) {\n\t\t\tif (i == 0) { C[i][j] = (j==0); continue; }\n\t\t\tif (j == 0) { C[i][j] = 1; continue; }\n\t\t\tC[i][j] = (C[i-1][j] + C[i-1][j-1])%md;\n\t\t}\n\t}\n\n\tint n,m; cin>>n>>m>>s; s = \" \" + s; int idx = 0; pref[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpref[i] = pref[i-1]; pref[i] += (s[i] == '1');\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint l,r;\n\t\tcin>>l>>r; pii z = mp(l,r);\n\t\tif (idx == 0) { idx++; Z[idx] = z; continue; }\n\t\tif (Z[idx].first == l) {\n\t\t\tif (Z[idx].second < r) Z[idx] = z;\n\t\t\telse continue;\n\t\t} else {\n\t\t\tif (Z[idx].second >= r) continue;\n\t\t\telse { idx++; Z[idx] = z; }\n\t\t}\n\t}\n\tm = idx; Z[m+1] = mp(n+7,n+7); Z[0] = mp(-1,-1);\n\tfor (int k = m; k >= 1; k--) {\n\t\tint lft = Z[k].first, rgt = Z[k].second;\n\t\tint p = max(Z[k-1].second, lft-1); \n\t\tint tc = pref[rgt] - pref[p];\n\t\tfor (int l = 0; l <= (p-lft+1); l++) {\n\t\t\tdp[k][l] = 0;\n\t\t\tint t = tc + l;\n\t\t\tint d = max(rgt - Z[k+1].first + 1, 0);\n\t\t\tint my = rgt - lft + 1 - d;\n\t\t\tif (d == 0) { dp[k][l] = C[my][t]; continue; } // arrange yours\n\t\t\tfor (int g = max(t-my,0); g <= min(d,t); g++) { // can give atleast 0 and t-my atmost overlap and t\n\t\t\t\tll cur = (ll)(C[my][t-g]) * dp[k+1][g];\n\t\t\t\tcur %= md;\n\t\t\t\tdp[k][l] = (cur + dp[k][l])%md;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][0]<<endl;\t\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long I64;\n\nusing namespace std;\n\nconst I64 NMAX = 3000;\nconst I64 MOD  = 1000000007;\n\nI64 v[NMAX+2], cop[NMAX+2], st[NMAX+2], dr[NMAX+2], x[NMAX+2], y[NMAX+2];\nI64 dp[NMAX+2][NMAX+2];\nI64 N, M, unu;\nstring s;\n\nint main()\n{\n    cin >> N >> M;\n    cin >> s;\n    for( I64 i = 1;  i <= N;  ++i )\n        cop[i] = v[i] = (s[i-1] == '1');\n    for( I64 i = 1;  i <= M;  ++i ) {\n        cin >> x[i] >> y[i];\n\n        I64 cnt = 0;\n        for( I64 j = x[i];  j <= y[i];  ++j ) {\n            cnt += v[j];\n        }\n        for( I64 j = y[i];  j >= x[i];  --j, --cnt ) {\n            if (cnt > 0)\n                v[j] = 1;\n            else\n                v[j] = 0;\n        }\n    }\n    I64 r_ind = 0;\n    for( I64 i = 1;  i <= N;  ++i ) {\n        if (v[i])\n            dr[++r_ind] = i;\n        v[i] = cop[i];\n        unu += v[i];\n    }\n    for( I64 i = 1;  i <= M;  ++i ) {\n        I64 cnt = 0;\n        for( I64 j = x[i];  j <= y[i];  ++j )\n            cnt += v[j];\n        for( I64 j = x[i];  j <= y[i];  ++j, --cnt ) {\n            if (cnt > 0)\n                v[j] = 1;\n            else\n                v[j] = 0;\n        }\n    }\n    r_ind = 0;\n    for( I64 i = 1;  i <= N;  ++i )\n        if (v[i])\n            st[++r_ind] = i;\n    dp[0][0] = 1;\n    st[0] = 1;\n    dr[0] = N;\n    for( I64 i = 0;  i <= unu;  ++i ) {\n        for( I64 j = 1;  j <= N;  ++j ) {\n            dp[i][j] = dp[i][j-1];\n            if (i > 0 && st[i] <= j && j <= dr[i])\n                dp[i][j] += dp[i-1][j-1];\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << dp[unu][ dr[unu] ] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\nvoid chmax(int& l, int r) {\n\tl = max(l, r);\n}\n\nconst int MOD = ten(9) + 7;\n\nconst int N = ten(5);\nll inverse[N];\nvoid init_inverse() {\n\t/*\n\tM%i = M - (M/i) * i\n\t(M%i)*i^-1 = M*i^-1 - M/i (mod M)\n\t(M%i)*i^-1 = M-M/i(mod M)\n\ti^-1 = (M-M/i) * (M%i)^-1\n\t*/\n\tinverse[1] = 1;\n\tfor (int i = 2; i < N; i++) inverse[i] = (MOD - MOD / i) * inverse[MOD%i] % MOD;\n}\n\nll fact[N], infact[N];\nvoid init_fast_fact() {\n\tinit_inverse();\n\tfact[0] = fact[1] = 1;\n\tfor (int i = 2; i < N; i++) fact[i] = fact[i - 1] * i % MOD;\n\tinfact[0] = infact[1] = 1;\n\tfor (int i = 2; i < N; i++) infact[i] = infact[i - 1] * inverse[i] % MOD;\n}\n\nll fast_nCk(int n, int k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (k > n) return 0;\n\tll ret = fact[n] * infact[k] % MOD * infact[n - k] % MOD;\n\treturn ret;\n}\n\n\nll solve(string& s, vector<Pii>& vp) {\n\tinit_fast_fact();\n\n\tstatic int ones[3001];\n\tFOR(i, sz(s)) ones[i + 1] = ones[i] + (s[i] == '1');\n\n\tvector<ll> pv(sz(s) + 1), nt(sz(s) + 1);\n\tpv[0] = 1;\n\n\tFOR(i, sz(vp)) {\n\t\tnt.assign(sz(pv), 0);\n\t\tint ul;\n\t\tif (i == 0) ul = vp[i].first;\n\t\telse ul = max(vp[i].first, vp[i - 1].second);\n\n\t\tint ur;\n\t\tif (i < sz(vp) - 1) ur = min(vp[i].second, vp[i + 1].first);\n\t\telse ur = vp[i].second;\n\n\t\tconst int must_one_count = ones[vp[i].second] - ones[ul];\n\n\t\tconst int arr = ur - vp[i].first;\n\t\tFOR(one_from_left, ul - vp[i].first + 1) {\n\t\t\tconst int can_use = must_one_count + one_from_left;\n\t\t\tFOR(one_use, arr + 1) {\n\t\t\t\tif (one_use > can_use) break;\n\t\t\t\tll cnt = fast_nCk(arr, one_use) * pv[one_from_left] % MOD;\n\t\t\t\tconst int left_one = can_use - one_use;\n\t\t\t\tnt[left_one] += cnt;\n\t\t\t\tif (nt[left_one] >= MOD) nt[left_one] -= MOD;\n\t\t\t}\n\t\t}\n\n\t\tswap(pv, nt);\n\t}\n\n\treturn pv[0];\n}\n\nint main() {\n\tint x, n; reader(x, n);\n\tstring s; reader(s);\n\t\n\tmap<int, int> mp;\n\tFOR(i, n) {\n\t\tint l, r; reader(l, r);\n\t\tl--;\n\t\tchmax(mp[l], r);\n\t}\n\tvector<Pii> vp(mp.begin(), mp.end());\n\tvector<Pii> vp2;\n\tint pr = -1;\n\tFOR(i, sz(vp)) {\n\t\tif (vp[i].second > pr) {\n\t\t\tvp2.push_back(vp[i]);\n\t\t\tpr = vp2.back().second;\n\t\t}\n\t}\n\n\tll ans =solve(s, vp2);\n\t\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,m,dp[3002][3002],mx[N],s[N];\nchar ch[N];\ninline int ksm(int d,int tk){int ret=1;while(tk){if(tk&1)ret=1ll*ret*d%p;d=1ll*d*d%p;tk>>=1;}return ret;}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",ch+1);\n    for(int i=1;i<=n;i++)s[i]=s[i-1]+ch[i]-'0',mx[i]=i;s[n+1]=s[n];\n    for(int i=1;i<=m;i++)\n    {\n    \tint l,r;scanf(\"%d%d\",&l,&r);\n    \tmx[l]=max(mx[l],r);\n\t}\n\tfor(int i=1;i<=n;i++)mx[i]=max(mx[i],mx[i-1]);mx[n+1]=mx[n];\n\tdp[0][s[mx[1]]]=1;\n\tfor(int i=0;i<n;i++)for(int j=0;j<=n;j++)\n\t{\n\t\tif(j)(dp[i+1][j+s[mx[i+2]]-s[mx[i+1]]-1]+=dp[i][j])%=p;\n\t\tif(mx[i+1]-i-j>0)(dp[i+1][j+s[mx[i+2]]-s[mx[i+1]]]+=dp[i][j])%=p;\n\t}\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n\nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n\nusing namespace std;\nconst int N=3010,mod=1e9+7;\nchar s[N];\nint n,m,ans,c[N][N],f[N][N],a[N];\nstruct data\n{\n    int l,r;\n    bool operator<(const data &x) const\n    {\n        return l<x.l && (l==x.l && r>x.r);\n    }\n} b[N];\n\nint main()\n{\n    n=get(),m=get();\n    rep(i,0,n)\n    {\n        c[i][0]=1;\n        rep(j,1,i)\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n    }\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    rep(i,1,m)\n        b[i].l=get(),b[i].r=get();\n    sort(b+1,b+1+m);\n    int t=0;\n    rep(i,1,m)\n        if (b[i].r>b[i-1].r)\n            b[++t]=b[i];\n    m=t,b[m+1].l=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        int w=a[b[i].r]-a[max(b[i].l-1,b[i-1].r)];\n        int l=min(b[i].r,b[i+1].l-1)-b[i].l+1;\n        int mx=b[i].r-b[i].l+1-l;\n        rep(j,0,l)\n            rep(k,max(0,w-j),mx)\n                f[i][k]=(f[i][k]+1ll*f[i-1][j+k-w]*c[l][j])%mod;\n    }\n    rep(i,0,n)\n        ans=(ans+f[m][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n///12:36\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7, Nmax = 3005;\ntypedef long long ll;\n\nvoid add_to(int &x, int y) { x+=y; if(x>=Mod) x-=Mod; }\nint inm(int x, int y) { return (ll)x*y%Mod; }\n\nint n, m, X, Y, ones, cate, i, j, k, kmin, kmax, nr, ans, rest;\nint x[Nmax], y[Nmax], nr1[Nmax], dp[Nmax][Nmax], comb[Nmax][Nmax];\nchar a[Nmax];\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n //   freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> n >> m;\n    cin >> (a+1);\n    for(i=1; i<=n; ++i) nr1[i] = nr1[i-1] + (a[i] == '1');\n\n    for(i=1; i<=m; ++i)\n    {\n        cin >> X >> Y;\n        if(Y > y[nr]) x[++nr] = X, y[nr] = Y;\n    }\n\n    for(i=0; i<=n; ++i)\n    {\n        comb[i][0] = 1;\n        for(j=1; j<=i; ++j)\n        {\n            comb[i][j] = comb[i-1][j];\n            add_to(comb[i][j], comb[i-1][j-1]);\n        }\n    }\n\n    ans = 1;\n\n    for(i=1; i<=nr; ++i)\n    if(i>1 && i<nr && x[i] <= y[i-1] && x[i+1] <= y[i])\n        for(j=0; j<=n; ++j)\n            {\n                ones = nr1[y[i]] - nr1[y[i-1]];\n                cate = x[i+1] - x[i];\n                rest = y[i] - x[i+1] + 1;\n\n                kmin = max(0, j+ones-rest);\n                kmax = min(j+ones, cate);\n                for(k=kmin; k<=kmax; ++k)\n                    add_to(dp[i+1][j+ones-k], inm(dp[i][j], comb[cate][k]));\n            }\n    else if(i<nr && x[i+1] <= y[i])\n    {\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        cate = x[i+1] - x[i];\n        rest = y[i] - x[i+1] + 1;\n\n        kmin = max(0, ones-rest);\n        kmax = min(ones, cate);\n        for(k=kmin; k<=kmax; ++k)\n            add_to(dp[i+1][ones-k], inm(ans, comb[cate][k]));\n    }\n    else if(i>1 && x[i] <= y[i-1])\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[y[i-1]];\n        int sum = 0;\n        for(j=0; j<=n; ++j)\n            add_to(sum, inm(dp[i][j], comb[cate][ones + j]));\n        ans = inm(ans, sum);\n    }\n    else\n    {\n        cate = y[i] - x[i] + 1;\n        ones = nr1[y[i]] - nr1[x[i]-1];\n        ans = inm(ans, comb[cate][ones]);\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2e+3+3;\nconst int K = 1e+4+3;\nconst int L = 1e+6+5;\n\nbool f[N][K];\nint n,k;\nchar s[L],ans[K];\nint st[N],len[N],m;\nbool bz[K],qbz[K];\nint nxt[L];\nint tr[K];\n\nint main(){\n\tn=get();k=get();\n\tm=0;\n\tfo(i,1,n){\n\t\tscanf(\"%s\",s+m+1);\n\t\tlen[i]=strlen(s+m+1);\n\t\tst[i]=m+1;\n\t\tm+=len[i];\n\t}\n\tf[n+1][0]=1;\n\tfd(i,n,1){\n\t\tfo(j,0,k){\n\t\t\tf[i][j]=f[i+1][j];\n\t\t\tif (j>=len[i])f[i][j]|=f[i+1][j-len[i]];\n\t\t}\n\t}\n\tfo(i,1,k)ans[i]='z'+1;\n\tbz[0]=1;\n\tfo(i,1,n){\n\t\tint w=0,p=0;\n\t\tfo(j,2,len[i]){\n\t\t\tnxt[j]=0;\n\t\t\tif (w+p-1>=j)nxt[j]=min(nxt[j-w+1],w+p-j);\n\t\t\twhile(j+nxt[j]<=len[i]&&s[st[i]+j+nxt[j]-1]==s[st[i]+nxt[j]])nxt[j]++;\n\t\t\tif (j+nxt[j]>w+p)w=j,p=nxt[j];\n\t\t}\n\t\tw=0,p=0;\n\t\tfo(j,1,k){\n\t\t\ttr[j]=0;\n\t\t\tif (w+p-1>=j)tr[j]=min(nxt[j-w+1],w+p-j);\n\t\t\twhile(j+tr[j]<=k&&tr[j]<len[i]&&ans[j+tr[j]]==s[st[i]+tr[j]])tr[j]++;\n\t\t\tif (j+tr[j]>w+p)w=j,p=tr[j];\n\t\t}\n\t\tfo(j,0,k){qbz[j]=bz[j];bz[j]=0;}\n\t\tfo(j,0,k)\n\t\tif (qbz[j]){\n\t\t\tbz[j]=1;\n\t\t\tbool pd=0;\n\t\t\tif (j+len[i]<=k&&f[i+1][k-j-len[i]]){\n\t\t\t\tif (tr[j+1]==len[i])bz[j+len[i]]=1;\n\t\t\t\telse{\n\t\t\t\t\tif (s[st[i]+tr[j+1]]<ans[j+tr[j+1]+1]){\n\t\t\t\t\t\tbz[j+len[i]]=1;\n\t\t\t\t\t\tfo(x,j+1,j+len[i])ans[x]=s[st[i]+x-j-1];\n\t\t\t\t\t\tfo(x,j+len[i]+1,k)ans[x]='z'+1;\n\t\t\t\t\t\tpd=1;\n\t\t\t\t\t\tfo(x,j+1,j+tr[j+1])bz[x]=qbz[x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pd)break;\n\t\t}\n\t}\n\tfo(i,1,k)putchar(ans[i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int mod = 1000000007;\nint N, M, lp, rp, sum[3009], r[3009], dp[3009][3009]; string s;\nint main() {\n\tcin >> N >> M >> s;\n\tfor (int i = 0; i < N; i++) sum[i + 1] = sum[i] + s[i] - 48;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> lp >> rp;\n\t\tr[lp] = max(r[lp], rp);\n\t}\n\tfor (int i = 1; i <= N; i++) r[i] = max({ r[i], r[i - 1], i });\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tint pl = max(sum[r[i]] - r[i] + i, 0), pr = min(sum[r[i]], i);\n\t\tfor (int j = pl; j <= pr; j++) {\n\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\tif (j != 0) {\n\t\t\t\tdp[i][j] += dp[i - 1][j - 1];\n\t\t\t\tif (dp[i][j] >= mod) dp[i][j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tret += dp[N][i];\n\t\tif (ret >= mod) ret -= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int MX = 3005,  MOD = 1e9+7;\nint n, m, l[MX], r[MX], ac[MX], rmax, c;\nchar s[MX];\nll dp[MX] = {1};\nint main(){\n\tscanf(\"%d%d\\n%s\", &n, &m, s);\n\trep(i,n) ac[i+1] = ac[i] + s[i] -'0';\n\trep(i,m) scanf(\"%d%d\", l+i, r+i);\n\trep(i,n){\n\t\tfor(; c < n && l[c] == i+1; c++) rmax = max(rmax, r[c]);\n\t\tif(rmax == i) rmax++;\n\t\tfor(int j=ac[rmax]-1; j >= max(0,ac[rmax]-rmax+i); j--) (dp[j+1] += dp[j]) %= MOD;\n\t\trep(j,ac[rmax]-rmax+i+1) dp[j] = 0;\n\t}\n\tprintf(\"%lld\\n\", dp[ac[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define sd(n) scanf(\"%d\",&n)\n#define sl(n) scanf(\"%lld\",&n)\n#define pd(n) printf(\"%d\",n)\n#define pl(n) printf(\"%lld\",n)\n#define sf(n) scanf(\"%f\",&n)\n#define pf(n) printf(\"%.12f\",n)\n#define psp printf(\" \")\n#define endc printf(\"\\n\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int maxn = 3010;\nconst ll md = 1e9 + 7;\n\npii Z[maxn];\nll C[maxn][maxn];\nll dp[maxn][maxn];\nint pref[maxn];\n\nint main() {\n\tIOS; string s;\n\n\tfor (int i = 0; i < maxn; i++) {\n\t\tfor (int j = 0; j < maxn; j++) {\n\t\t\tif (i == 0) { C[i][j] = (j==0); continue; }\n\t\t\tif (j == 0) { C[i][j] = 1; continue; }\n\t\t\tC[i][j] = (C[i-1][j] + C[i-1][j-1])%md;\n\t\t}\n\t}\n\n\tint n,m; cin>>n>>m>>s; s = \" \" + s; int idx = 0; pref[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpref[i] = pref[i-1]; pref[i] += (s[i] == '1');\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint l,r;\n\t\tcin>>l>>r; pii z = mp(l,r);  \n\t\tif (idx == 0) { idx++; Z[idx] = z; continue; }\n\t\tif (Z[idx].first == l) {\n\t\t\tif (Z[idx].second < r) Z[idx] = z;\n\t\t\telse continue;\n\t\t} else {\n\t\t\tif (Z[idx].second >= r) continue;\n\t\t\telse { idx++; Z[idx] = z; }\n\t\t}\n\t}\n\tm = idx; Z[m+1] = mp(n+7,n+7); Z[0] = mp(-7,-7); dp[m+1][0] = 1;\n\tfor (int k = m; k >= 1; k--) {\n\t\tint lft = Z[k].first, rgt = Z[k].second;\n\t\tint p = max(Z[k-1].second, lft-1); \n\t\tint tc = pref[rgt] - pref[p];\n\t\tfor (int l = 0; l <= (p-lft+1); l++) {\n\t\t\tdp[k][l] = 0;\n\t\t\tint t = tc + l;\n\t\t\tint d = max(rgt - Z[k+1].first + 1, 0);\n\t\t\tint my = rgt - lft + 1 - d;\n\t\t\tif (d == 0) { dp[k][l] = (C[my][t] * dp[k+1][0])%md; continue; } // arrange yours\n\t\t\tfor (int g = max(t-my,0); g <= min(d,t); g++) { // can give atleast 0 and t-my atmost overlap and t\n\t\t\t\tll cur = C[my][t-g] * dp[k+1][g];\n\t\t\t\tdp[k][l] = (cur + dp[k][l])%md;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][0]<<endl;\t\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n//region Template\n#include \"ext/pb_ds/assoc_container.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n\nconst int MOD = 1000000007;\n\nusing namespace std;\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset;\n\n#define finish(x) cout << x; exit(0);\n#define fastIO cin.tie(0); cin.sync_with_stdio(false);\n\nvoid setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\n//const string USCAO_TAG = \"mountains\";\nvoid usaco(const string& USACO_TAG) { setIn(USACO_TAG + \".in\"); setOut(USACO_TAG + \".out\"); }\n/*\ntemplate<typename... Args>\nvoid print(Args... args) {\n\t#ifdef LOCAL\n\t((std::cout << args << \" \"), ...);\n\tcout << endl;\n\t#endif\n}\n */\n//endregion\n\n/* Notes:\n * Farah </3\n */\n\nconst int MAXN = 3e3 + 6;\nstring s;\nint r[MAXN];\nint p[MAXN];\nint n, m;\n\nll dp[MAXN][MAXN];\n\nint ones(int l, int r){\n\treturn p[r] - p[l - 1];\n}\n\nll solve(int l, int c){\n\tif(l == n && c <= 1){\n\t\treturn dp[l][c] = 1;\n\t}\n\telse if(l == n) return 0;\n\n\tif(dp[l][c] != 0) return dp[l][c];\n\n\tint nc = c + ones(r[l] + 1, r[l + 1]);\n\tint len = r[l] - l + 1;\n\tif(len > c) {\n\t\tdp[l][c] += solve(l + 1, nc);\n\t}\n\tif(c > 0) dp[l][c] += solve(l + 1, nc - 1);\n\n\treturn dp[l][c] % MOD;\n}\n\nint main() {\n\t#ifdef LOCAL\n\tsetIn(\"in.txt\");\n\tsetOut(\"out.txt\");\n\t#endif\n\n\tcin >> n >> m;\n\n\tcin >> s;\n\ts = \"#\" + s;\n\n\tp[1] = (s[1] == '1');\n\tfor(int i = 2; i <= n; i++){\n\t\tp[i] = p[i - 1] + (s[i] == '1');\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tr[i] = i;\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tint l, x;\n\t\tcin >> l >> x;\n\n\t\tr[l] = max(r[l], x);\n\t}\n\n\tfor(int i = 2; i <= n; i++){\n\t\tr[i] = max(r[i], r[i - 1]);\n\t}\n\n\tmemset(dp, 0, sizeof dp);\n\tcout << solve(1, ones(1, r[1]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3000+10,mo=1000000007;\nint f[maxn][maxn],right[maxn],sum[maxn];\nint i,j,k,l,r,t,n,m,ans,one,zero;\nchar get(){\n\tchar ch=getchar();\n\twhile (ch!='0'&&ch!='1') ch=getchar();\n\treturn ch;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) sum[i]=get()-'0';\n\tfo(i,1,n+1) sum[i]+=sum[i-1];\n\tfo(i,1,n+1) right[i]=i;\n\tfo(i,1,m){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tright[j]=max(right[j],k);\n\t}\n\tfo(i,1,n) right[i]=max(right[i],right[i-1]);\n\tf[1][sum[right[1]]]=1;\n\tfo(i,1,n)\n\t\tfo(j,0,n)\n\t\t\tif (f[i][j]){\n\t\t\t\tl=right[i]+1;r=right[i+1];\n\t\t\t\tone=j;zero=right[i]-i+1-j;\n\t\t\t\tif (zero) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n\t\t\t\tif (one) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n\t\t\t}\n\tans=f[n+1][0];\n\t(ans+=mo)%=mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[2005],fx[2005],inv[2005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=2000;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=2000;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=2000;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][2005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tfor(int i=1;i<=m;++i)\n\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j))%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=3005,mod=1000000007;\ntypedef long long LL;\nchar S[N];\nint n,m,s[N],x[N],y[N],c[N][N],tot,l[N],r[N],maxn;\nLL f[N][N];\nstruct data{int x,y;} dat[N];\n\nint getint()\n{\n\tchar ch;\n\tint f=1;\n\twhile(!isdigit(ch=getchar())) if(ch=='-') f=-1;\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x*f;\n}\n\nbool cmp(data a,data b)\n{\n\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n}\n\nint main()\n{\n\tn=getint(),m=getint(),scanf(\"%s\",S+1);\n\trep(i,0,n) c[i][0]=c[i][i]=1;\n\trep(i,1,n) rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\trep(i,1,n) s[i]=s[i-1]+S[i]-48;\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\tsort(dat+1,dat+1+m,cmp);\n\trep(i,1,m) if(dat[i].y>maxn) ++tot,x[tot]=dat[i].x,y[tot]=dat[i].y,maxn=dat[i].y;\n\tf[0][0]=1,x[tot+1]=y[tot+1]=n+1;\n\trep(i,1,tot)\n\t{\n\t\tint w=min(y[i]-x[i]+1,x[i+1]-x[i]),a=s[y[i]]-s[max(x[i]-1,y[i-1])];\n\t\tl[i]=max(0,l[i-1]+a-w),r[i]=min(y[i]-x[i+1]+1,r[i-1]+a);\n\t\trep(j,l[i],r[i])\n\t\t\trep(k,l[i-1],r[i-1])\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][k]*c[w][k+a-j])%mod;\n\t}\n\tprintf(\"%lld\\n\",f[tot][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mu=1000000007;\nint n,m,l,r,right[3005],sum[3005],f[3005][3005];\nchar s[3005];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) right[i]=i;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++) sum[i]=sum[i-1]+s[i]-'0';\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tright[l]=std::max(right[l],r);\n\t}\n\tfor (int i=1;i<=n;i++) right[i]=std::max(right[i],right[i-1]);\n\tf[0][0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tint t=sum[right[i]]-sum[right[i-1]];\n\t\tfor (int j=0;j<=right[i];j++){\n\t\t\tif (!f[i-1][j]) continue;\n\t\t\tif (j+t>0) f[i][j+t-1]=(f[i][j+t-1]+f[i-1][j])%mu;\n\t\t\tif (right[i]-i+1>j+t) f[i][j+t]=(f[i][j+t]+f[i-1][j])%mu; \n\t\t}\n\t\t//if (i==right[i]) for (int j=1;j<=n;j++) f[i][j]=0;\n\t}\n\tprintf(\"%d\\n\",f[n][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else {\n            if(v.empty()){\n                rep2(i,1,l-1)v.eb(i,i);\n            }\n            int L=v.back().se;\n            rep2(i,L+1,l-1)v.eb(i,i);\n            v.eb(l,r);\n        }\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        int l = max(prel,x-y+a[y]) ,r=min(prer+x-v[i].fi+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<60;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\nconst int SZE = 1e6+1;\n\nint r[3009];//1 indexed\nchar s[3009];\nint rs[3009];//1 indexed\nLL mm[3009][3009];\n\nint n,m;\n\nLL dp(int p,int v){\n\tif(p==n)return (v==0);\n\tif(v>r[p]-p)return 0;\n\tif(mm[p][v]!=-1)return mm[p][v];\n\tint dv=0;\n\tif(r[p+1]>r[p])dv=rs[r[p+1]]-rs[r[p]];\n\tmm[p][v]=dp(p+1,v+dv);\n\tif(v+dv)mm[p][v]=(mm[p][v]+dp(p+1,v+dv-1))%MOD;\n\treturn mm[p][v];\n}\n\nint main(){\n\tRII(n,m);\n\tRS(s);\n\tREPP(i,1,n+1){\n\t\trs[i]=rs[i-1]+(s[i-1]=='1');\n\t}\n\tREP(i,m){\n\t\tDRII(a,b);\n\t\tr[a]=max(r[a],b);\n\t}\n\tREPP(i,1,n+1){\n\t\tr[i]=max(max(i,r[i]),r[i-1]);\n\t}\n\tMS1(mm);\n\tprintf(\"%lld\\n\",dp(0,0));\n\t/*REP(i,n+1){\n\t\tREP(j,n){\n\t\t\tprintf(\"%lld \",dp(i,j));\n\t\t}puts(\"\");\n\t}*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N (3009)\n#define MOD (1000000007)\nusing namespace std;\n\nint n,m,x,y,R[N],sum[N],f[N][N];\nchar s[N];\n\nint main()\n{\n\tcin>>n>>m>>s+1; s[n+1]='0';\n\tfor (int i=1; i<=n+1; ++i)\n\t\tR[i]=i, sum[i]=sum[i-1]+s[i]-'0';\n\tfor (int i=1; i<=m; ++i)\n\t\tcin>>x>>y, R[x]=max(R[x],y);\n\tfor (int i=2; i<=n+1; ++i)\n\t\tR[i]=max(R[i],R[i-1]);\n\tf[1][sum[R[1]]]=1;\n\tfor (int i=1; i<=n; ++i)\n\t\tfor (int j=0; j<=n; ++j)\n\t\t{\n\t\t\tint k=sum[R[i+1]]-sum[R[i]];\n\t\t\tif (j) (f[i+1][j+k-1]+=f[i][j])%=MOD;\n\t\t\tif (R[i]-i>=j) (f[i+1][j+k]+=f[i][j])%=MOD;\n\t\t}\n\tcout<<f[n+1][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<uint> divisor(uint x){ vector<uint> ans; for(uint i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline int __lg(int __n){ return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nstruct PartialSum{\n    vector<ll> data;\n    template<class T> PartialSum(const T& v): data(v.size() + 1){\n        for(ll i = 0; i < v.size(); i++) data[i + 1] = data[i] + v[i];\n    }\n    ll get(ll l, ll r) const {\n        return data[r] - data[l];\n    }\n    ll operator[](ll at) const { return data[at]; }\n};\nconstexpr uint mod = MOD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(n,m);\n    STR(s);\n    VEC(pll,a,m);\n    each(i,a)i.first--;\n    each(i,s)i-='0';\n    PartialSum acc(s);\n    ll l=0,r=0;\n    Modint ans=1;\n    vec(Modint,dp,n+1);\n    dp[0]=1;\n    each(p,a){\n        if(r<p.first){\n            Modint sum=sum(dp);\n            each(i,dp)i=0;\n            dp[acc.get(0,p.first)]=sum;\n            ll d=p.first-r;\n            r=p.first;\n            l+=d;\n        }\n        rep(p.first-l)rrep(n)dp[i+1]+=dp[i];\n        ll one=acc.get(0,r),zero=r-one;\n        rep(i,one+1,n+1)dp[i]=0;\n        rep(p.first-zero)dp[i]=0;\n        l=p.first;\n        chmax(r,p.second);\n    }\n    rep(r-l)rrep(n)dp[i+1]+=dp[i];\n    out(dp[acc[r]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<int> sh(n, -1);\n    for (int i = 0; i < m; ++i) {\n        int l, r; cin >> l >> r;\n        l--, r--;\n        sh[l] = max(sh[l], r);\n    }\n    for (int i = 0; i < n; ++i) {\n        if (sh[i] == -1) continue;\n        for (int j = i + 1; j < n; ++j) {\n            if (sh[j] <= sh[i]) sh[j] = -1;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (sh[i] == -1) continue;\n        for (int j = i + 1; j <= sh[i]; ++j) {\n            if (sh[j] != -1) break;\n            sh[j] = sh[i];\n        }\n    }\n    vector<int> pref(n);\n    for (int i = 0; i < n; ++i) {\n        pref[i] = (s[i] == '0');\n        if (i > 0) pref[i] += pref[i - 1];\n    }\n    constexpr int kMod = 1'000'000'000 + 7;\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < n; ++i) {\n        if (sh[i] == -1) {\n            if (s[i] == '0') {\n                for (int j = n; j > 0; --j) dp[j] = dp[j - 1];\n                dp[0] = 0;\n            }\n        } else {\n            vector<int> nxt(n + 1, 0);\n            for (int j = 0; j <= n; ++j) {\n                if (dp[j] == 0) continue;\n                int cnt = pref[sh[i]] - j;\n                assert(cnt >= 0);\n                if (cnt > 0) (nxt[j + 1] += dp[j]) %= kMod;\n                if (sh[i] - i + 1 - cnt > 0) (nxt[j] += dp[j]) %= kMod;\n            }\n            dp = nxt;\n        }\n    }\n    cout << dp[pref[n - 1]] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint N, M;\nstring S;\nstatic ll dp[3002][3002];\n\nconst ll MODP = 1000000007;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\nint main(void){\n\tcin >> N >> M;\n\tcin >> S;\n\tint l[M], r[M], c[M];\n\tint sum[N+1]={0};\n\tfor(int i=1;i<=N;i++){\n\t\tsum[i] = sum[i-1] + ((S[i-1]=='1') ? 1 : 0);\n\t}\n\tvpii a;\n\tint maxi = 0;\n\tfor(int i=0;i<=M;i++){\n\t\tif (i<M){\n\t\t\tcin >> l[i] >> r[i];\n\t\t}\n\t\tif (i==M || (i>0 && l[i]>l[i-1])){\n\t\t\ta.pb(mp(l[i-1], maxi));\n\t\t\tmaxi = 0;\n\t\t}\n\t\tif (i<M){\n\t\t\tmaxi = max(maxi, r[i]);\n\t\t}\n\t}\n\tvpii b;\n\tmaxi = -1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif (maxi < a[i].second){\n\t\t\tb.pb(a[i]);\n\t\t\tmaxi = a[i].second;\n\t\t}\n\t}\n\tfor(int i=0;i<b.size();i++){\n\t\tc[i] = sum[b[i].second] - sum[b[i].first-1];\n\t\tb[i].first--;\n\t\tcout << b[i].first << \" \" << b[i].second << \" \" << c[i] << endl;\n\t}\n\t\n\tdp[0][c[0]] = 1;\n\tfor(int i=0;i+1<b.size();i++){\n\t\tfor(int j=0;j<=b[i].second-b[i].first;j++){\n\t\t\tfor(int k=0;k<=b[i+1].second-b[i+1].first;k++){\n\t\t\t\tint d = sum[b[i+1].second] - sum[b[i].second];\n\t\t\t\tint c1 = j - k + d;\n\t\t\t\tint c2 = k - d;\n\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << d << endl;\n\t\t\t\tif (d<0 || c1<0 || c2<0 || c2>b[i].second-b[i+1].first) continue;\n\t\t\t\tdp[i+1][k] += (dp[i][j] * comb(b[i+1].first - b[i].first, c1)) % MODP;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<b.size();i++){\n\t\tcout << \"i = \" << i << endl;\n\t\tfor(int j=0;j<3002;j++){\n\t\t\tif (dp[i][j]!=0){\n\t\t\t\tcout << \"dp[i][\" << j << \"] = \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tll ans = 0;\n\tfor(int i=0;i<3002;i++){\n\t\tans = (ans + dp[b.size()-1][i] * comb(b[b.size()-1].second - b[b.size()-1].first, i)) % MODP;\n\t}\n\tcout << ans << endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int mo=1000000007;\nint f[3005],r[3005],a[3005];\nchar s[3005];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\\n%s\",&n,&m,s+1);\n\tfor (int i=1;i<=n;i++) r[i]=i,a[i]=a[i-1]+s[i]-'0';\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\\n\",&x,&y);\n\t\tif (y>r[x]) r[x]=y;\n\t}\n\tf[0]=1;\n\tfor (int i=1,R=0;i<=n;i++){\n\t\tR=r[i]>R?r[i]:R;\n\t\tfor (int j=a[R]<i?a[R]:i;j>=0;j--)\n\t\t\tif (j<a[R]-R+i) f[j]=0;\n\t\t\t\telse if (j) (f[j]+=f[j-1])%=mo;\n\t}\n\tprintf(\"%d\\n\",f[a[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n    const int MAX =200002;\nconst int MOD =1000000007;\n\n     signed main(){\nint n,m;\ncin>>n>>m;\nstring s;\ncin>>s;\nint x[n+1];\nfor(int i=0;i<=n;i++)x[i]=i;\nint l,r;\nfor(int i=0;i<m;i++){\n    cin>>l>>r;\n    x[l]=max(x[l],r);\n}\nfor(int i=0;i<n;i++)x[i+1]=max(x[i],x[i+1]);\nmap<pair<int,int>,int> mp1,mp2;\nmp1[{0,0}]=1;\n\nfor(int i=0;i<n;i++){\n    int t0=0,t1=0;\n    for(int j=x[i];j<x[i+1];j++){\n        if(s[j]=='0')t0++;\n        else t1++;\n    }\n    for(auto&& j:mp1){\n        pair<int,int>p={j.first.first+t0,j.first.second+t1};\n        if(p.first!=0)mp2[{p.first-1,p.second}]=(mp2[{p.first-1,p.second}]+j.second)%MOD;\n        if(p.second!=0)mp2[{p.first,p.second-1}]=(mp2[{p.first,p.second-1}]+j.second)%MOD;\n    }\n    swap(mp1,mp2);\n    mp2.clear();\n   \n}\n  \ncout<<mp1[{0,0}]<<endl;\n\n     }\n\n\n \n\n\n \n\n\n\n\n\n\n    \n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef long long ll;\n\nint N,M,m;\nll sum[300030] = {0};\nll que[300030][2] = {0};\nll F[300030] = {0},R[300003] = {0};\nll dp[3030][3030];\nvector<int> QL,QR;\n\nll con(ll a,ll b)\n{\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nll P(ll n,ll s)\n{//printf(\"  %lld %lld\\n\",n,s);\n    if(dp[n][s] != -1)return dp[n][s];\n    ll res = 0;\n    ll l,r;\n    if(n == QR.size() - 1)\n    {\n        l = QL[n];r = QR[n];\n        res = con(r - l + 1,sum[r] - s);\n        return res;\n    }\n    l = QL[n],r = min(QR[n],QL[n + 1] - 1);\n    ll mem = sum[QR[n]] - s;\n    ll p = 0;\n    if(QR[n] < QL[n + 1])p = sum[QL[n + 1] - 1] - sum[QR[n] + 1];\n\n    //printf(\" %lld %lld %lld %lld\\n\",l,r,mem,(r - l + 1) - (QR[n] - l + 1 - mem));\n    for(int i = max((ll)0,(r - l + 1) - (QR[n] - l + 1 - mem)); i <= min(mem,r - l + 1); i++)\n    {\n        res += P(n + 1,s + i + p) * con(r - l + 1,i);\n        res %= mod;\n    }\n    return dp[n][s] = res;\n}\n\nll power(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = power(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < 3030; i++)for(int j = 0; j < 3030; j++)dp[i][j] = -1;\n    F[0] = 1;\n    for(int i = 1; i <= 3030; i++)F[i] = F[i - 1] * i;\n    for(int i = 0; i <= 3030; i++)R[i] = power(F[i],mod - 2);\n    for(int i = 1; i <= N; i++)\n    {\n        char c;\n        scanf(\" %c\",&c);\n        sum[i] = sum[i - 1] + (c == '1');\n    }\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%lld%lld\",&que[i][0],&que[i][1]);\n        if(i != 0)que[i][1] = max(que[i][1],que[i - 1][1]);\n    }\n    for(int i = 0; i < M; i++)\n    {\n        if(i == 0)\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n        if(QL[QL.size() - 1] == que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QR[QR.size() - 1] = que[i][1];\n        }\n        else if(QL[QL.size() - 1] < que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n    }\n    /*\n    for(int i = 0; i < QR.size(); i++)\n    {\n        printf(\" %d %d\\n\",QL[i] ,QR[i]);\n    }\n    */\n    printf(\"%lld\\n\",P(0,sum[QL[0] - 1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3005\nusing namespace std;\n\nint n,m,s[N],a[N],b[N],dp[N][N],cbn[N][N]; char ch[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) s[i]=s[i-1]+(ch[i]=='1');\n\tm++; a[1]=b[1]=1;\n\tfor (i=2; i<=m; i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif (a[i]==a[i-1]){\n\t\t\tb[i-1]=max(b[i-1],b[i]); i--; m--; continue;\n\t\t}\n\t\tif (b[i]<=b[i-1]){ i--; m--; continue; }\n\t\twhile (a[i]>b[i-1]+1){\n\t\t\ta[i+1]=a[i]; b[i+1]=b[i];\n\t\t\ta[i]=b[i]=b[i-1]+1;\n\t\t\ti++; m++;\n\t\t}\n\t}\n\tfor (; b[m]<=n; m++) a[m+1]=b[m+1]=b[m]+1;\n\tdp[0][0]=1;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++) cbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tfor (i=1; i<m; i++){\n\t\tfor (j=max(a[i+1]-1-b[i]+s[b[i]],0); j<=s[b[i]]; j++)\n\t\t\tfor (k=0; k<=a[i+1]-a[i] && k<=j; k++) dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k]*cbn[a[i+1]-a[i]][k])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[m-1][s[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 3002\n\n#define MOD 1000000007\n\nint n;\nint m;\n\nlong long int dp[MAX][MAX];\n\ndeque<pair<int, int> > v;\n\nchar buf[MAX];\n\nvector<int> V;\n\nint im[MAX];\n\nint rng(int a, int b){\n\tif (a > b)return 0;\n\tint r = im[b];\n\tif (a){\n\t\tr -= im[a - 1];\n\t}\n\treturn max(r,0);\n}\n\n\nint belong[MAX];\nint att[MAX];\n\nint add_point[MAX];\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", buf);\n\tfor (int i = 0; i < n; i++){\n\t\tV.push_back(buf[i] - '0');\n\t\tif (V.back() == 1){\n\t\t\tim[i]++;\n\t\t}\n\t\tif (i){\n\t\t\tim[i] += im[i - 1];\n\t\t}\n\t}\n\tmemset(att, -1, sizeof(att));\n\tmemset(add_point, -1, sizeof(add_point));\n\tint pr_l = -1;\n\tint pr_r = -1;\n\tfor (int i = 0; i < m; i++){\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tr--;\n\t\tif (pr_r >= r){\n\t\t\tcontinue;\n\t\t}\n\t\tif (pr_l < l){\n\t\t\tv.push_back(make_pair(l, r));\n\t\t}\n\t\telse{\n\t\t\tv.back().second = max(v.back().second, r);\n\t\t}\n\t\tpr_l = l;\n\t\tpr_r = r;\n\t\tbelong[l]++;\n\t\tbelong[r + 1]--;\n\t\tatt[l] = v.size()-1;\n\t\tadd_point[l] = v.size()-1;\n\t}\n\n\tfor (int i = 0; i < n; i++){\n\t\tif (i){\n\t\t\tbelong[i] += belong[i - 1];\n\t\t}\n\t\tif (belong[i]&&att[i] == -1){\n\t\t\tatt[i] = att[i - 1];\n\t\t}\n\t\tif (belong[i] == 0){\n\t\t\tatt[i] = -1;\n\t\t}\n\t}\n\tif (v[0].first == 0){\n\t\tdp[0][rng(v[0].first, v[0].second)]=1;\n\t}\n\telse{\n\t\tdp[0][V[0]] = 1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < MAX; j++){\n\t\t\tif (dp[i][j]){\n\t\t\t\tint all = 1;\n\t\t\t\tif (belong[i]){\n\t\t\t\t\tall = v[att[i]].second - v[att[i]].first + 1;\n\t\t\t\t\tall -= i - v[att[i]].first;\n\t\t\t\t}\n\t\t\t\tint cnt0 = all - j;\n\t\t\t\tint cnt1 = j;\n\t\t\t\tint add_j = 0;\n\t\t\t\tif (add_point[i+1] != -1){\n\t\t\t\t\tint cur_ed = i + all - 1;\n\t\t\t\t\tint nex_ed = v[add_point[i + 1]].second;\n\t\t\t\t\tadd_j += rng(cur_ed+1, nex_ed);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (belong[i] == 0){\n\t\t\t\t\t\tadd_j += rng(i + 1, i + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif (all == 1){\n\t\t\t\t\t\t\tadd_j += rng(i + 1, i + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt0){\n\t\t\t\t\tint nex_j = j+add_j;\n\t\t\t\t\tdp[i + 1][nex_j] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][nex_j] >= MOD){\n\t\t\t\t\t\tdp[i + 1][nex_j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt1){\n\t\t\t\t\tint nex_j = j - 1+add_j;\n\t\t\t\t\tdp[i + 1][nex_j] += dp[i][j];\n\t\t\t\t\tif (dp[i + 1][nex_j] >= MOD){\n\t\t\t\t\t\tdp[i + 1][nex_j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[n][0];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[a[v[0].fi-1]]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int mi=INT_MAX,ma=0;\n        rep2(j,prel,prer){\n            int l = max((int)j,x-y+a[y]);\n            int r = min((int)j+x-v[i].fi+1,a[y]);\n            chmin(mi,l);chmax(ma,r);\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=mi,prer=ma;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define int long long\n\nusing namespace std;\n\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 6005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint s0[MAX_N];\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    make();\n    vp vec(m+1);\n    rep(i,m){\n        cin >> vec[i].fi >> vec[i].se;\n        --vec[i].fi,--vec[i].se;\n    }\n    rep(i,n){\n        if(s[i] == '0'){\n            s0[i+1] = s0[i] + 1;\n        }else{\n            s0[i+1] = s0[i];\n        }\n    }\n    int nw=0,l = vec[nw].fi,r = vec[nw].se;\n    vp data;\n    data.pb(P(s0[r+1]-s0[l],1));\n    vec[m] = P(n,n);\n    srep(i,1,m+1){\n        if(vec[i].se <= r){\n            continue;\n        }\n        if(r < vec[i].fi){\n            ll val = 0;\n            rep(j,len(data)){\n                ll zero = data[j].fi;\n                ll al = r-l+1;\n                val = add(val,mul(data[j].se,comb(al,zero)));\n            }\n            nw = i,l = vec[nw].fi,r = vec[nw].se;\n            vp hoge;\n            hoge.pb(P(s0[r+1]-s0[l],val));\n            data = hoge;\n            continue;\n        }\n        //重なり\n        int lm = r-vec[i].fi+1;\n        //右の覆われていない部分の0の個数\n        int sm = s0[vec[i].se+1] - s0[r+1];\n        // cout << vec[i].se << \" \" << r << \" \" << sm << \"\\n\";\n        int mnn = max(data[0].fi-vec[i].fi+l,0LL);\n        int mxx = min((data.back().fi),lm);\n        vector<int> nx(mxx-mnn+1,0LL);\n        rep(j,len(data)){\n            int cnt = data[j].fi;\n            int leng = vec[i].fi - l;\n            int mn = max(cnt-leng,0LL);\n            int mx = min(cnt,lm);\n            srep(k,mn,mx+1){\n                nx[k-mnn] = add(nx[k-mnn],mul(comb(leng,cnt-k),data[j].se));\n            }\n        }\n        vp hoge;\n        rep(j,len(nx)){\n            if(nx[j]){\n                hoge.pb(P(j+mnn+sm,nx[j]));\n            }\n        }\n        data = hoge;\n        nw = i,l = vec[nw].fi,r = vec[nw].se;\n    }\n    cout << data[0].se << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#define MAXN 3010\n#define LL long long\nusing namespace std;\n\nconst LL P=1000000007;\n\nint n,m;\nint s[MAXN];\nint p[MAXN][2];\nLL c[MAXN][MAXN];\nLL f[MAXN][MAXN];\n\nvoid init(){\n\tint _m;\n\tscanf(\"%d%d\",&n,&_m);\n\tstatic char str[MAXN];\n\tscanf(\"%s\",str+1);\n\tfor(int i=1;i<=n;i++) s[i]=s[i-1]+(str[i]=='1'?1:0);\n\tfor(int i=1;i<=_m;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(!m || r>p[m][1]){\n\t\t\tp[++m][0]=l;\n\t\t\tp[m][1]=r;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%P;\n\t}\n}\n\nvoid update(LL &x,LL y){ x=(x+y)%P; }\n\nvoid dp(){\n\tf[1][s[p[1][1]]-s[p[1][0]-1]]=1;\n\tfor(int i=1;i<m;i++)\n\t\tif(p[i+1][0]<=p[i][1]){\n\t\t\tint delta=s[p[i+1][1]]-s[p[i][1]];\n\t\t\tfor(int j=0;j<=p[i][1]-p[i][0]+1;j++)\n\t\t\t\tfor(int k=max(j-(p[i][1]-p[i+1][0]+1),0);k<=p[i+1][0]-p[i][0] && k<=j;k++)\n\t\t\t\t\tupdate(f[i+1][j-k+delta],f[i][j]*c[p[i+1][0]-p[i][0]][k]);\n\t\t\tfor(int j=p[i][1]-p[i][0]+2;j<=n;j++)\n\t\t\t\tassert(f[i][j]==0);\n\t\t}else{\n\t\t\tint delta=s[p[i+1][1]]-s[p[i+1][0]-1];\n\t\t\tfor(int j=0;j<=p[i][1]-p[i][0]+1;j++)\n\t\t\t\tupdate(f[i+1][delta],f[i][j]*c[p[i][1]-p[i][0]+1][j]);\n\t\t}\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tinit();\n\tdp();\n\tLL ans=0;\n\tfor(int i=0;i<=p[m][1]-p[m][0]+1;i++)\n\t\tupdate(ans,f[m][i]*c[p[m][1]-p[m][0]+1][i]);\n\tprintf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nmint dp[3030][3030];\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<int> cnt(n + 1, 0);\n    rep(i, n) {\n        cnt[i + 1] = cnt[i] + (s[i] == '1');\n    }\n    dp[0][0] = 1;\n    int cl = 0, cr = 0;\n    rep(i, m) {\n        int l, r; cin >> l >> r;\n        -- l, -- r;\n        for(;cl < l; ++ cl) {\n            if(cl == cr) ++ cr;\n            rep(j, 3001) {\n                if(j + 1 <= cnt[cr]) dp[cl + 1][j + 1] += dp[cl][j];\n                if(cl + 1 - j <= cl + 1 - cnt[cr]) dp[cl + 1][j] += dp[cl][j];\n            }\n        }\n        while(cr < r) {\n            ++ cr;\n        }\n    }\n    for(;cl < n; ++ cl) {\n        if(cl == cr) ++ cr;\n        rep(j, 3001) {\n            if(j + 1 <= cnt[cr]) dp[cl + 1][j + 1] += dp[cl][j];\n            if(cl + 1 - j <= cl + 1 - cnt[cr]) dp[cl + 1][j] += dp[cl][j];\n        }\n    }\n    cout << dp[n][cnt[cr]] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint mod=1e9+7;\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint N,M,l[3000],r[3000];\nint mn[3001],mx[3001];\nint dp[3001][3001];\nstring s,so;\nint main(){\n\tcin>>N>>M;\n\tcin>>s;\n\tso=s;\n\trep(i,M) cin>>l[i]>>r[i],l[i]--;\n\trep(t,2){\n\t\ts=so;\n\t\trep(i,M){\n\t\t\tint c[2]={};\n\t\t\tfor(int j=l[i];j<r[i];j++) c[s[j]-'0']++;\n\t\t\tfor(int j=l[i];j<l[i]+c[t];j++) s[j]='0'+t;\n\t\t\tfor(int j=l[i]+c[t];j<r[i];j++) s[j]='0'+(1-t);\n\t\t}\n\t\tif(t==0){\n\t\t\trep(i,N) mn[i+1]=mn[i]+(s[i]=='1');\n\t\t}\n\t\tif(t==1){\n\t\t\trep(i,N) mx[i+1]=mx[i]+(s[i]=='1');\n\t\t}\n\t}\n\tdp[0][0]=1;\n\trep(i,N) rep(j,i+1) if(dp[i][j]){\n\t\trep(k,2){\n\t\t\tint ni=i+1;\n\t\t\tint nj=j+k;\n\t\t\tif(mn[ni]<=nj&&nj<=mx[ni]) add(dp[ni][nj],dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[N][mn[N]]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(prel,x-y+a[y]) ,r=min(prer+x-v[i].fi+1,a[y]);\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=next;\n            prel=prer=l;\n            continue;\n        }\n        int l = max(0,x-y+a[y]) , r=a[y];\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[prel].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\n\tassert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = min(y[i] - rightmost, y[i] - x[i] + 1);\n\t\tfix[i] = min(x[i+1] - x[i], y[i] - x[i] + 1);\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\tll idx = y[i] - append[i] + 1;\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxm+8],r[maxm+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l0[N], r0[N], l[N], r[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) scanf(\"%d%d\", &l0[i], &r0[i]);\n\tint m0 = 0;\n\tRep(i, m) {\n\t\tbool flag = true;\n\t\tRep(j, m) if (l0[j] <= l0[i] && r0[i] <= r0[j]) flag = false;\n\t\tif (flag) l[++ m0] = l0[i], r[m0] = r0[i];\n\t}\n\t//printf(\"%d\\n\", m0);\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, n) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j]);\n\t\telse {\n\t\t\tRep0(j, n) if (f[i][j]){\n\t\t\t\t//printf(\"%d %d %lld\\n\", i, j, f[i][j]);\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, n) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n9 3\n110111110\n1 4\n4 6\n6 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <numeric>\n#include <random>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\ntypedef pair<int,int>PI; typedef vector<int> VI;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=1E9+7;\nlong long modpow(long long a, long long n){\n    if(n==0) return 1;\n    long long re=modpow((a*a)%MOD,n/2)%MOD;\n    if(n%2==1) re= (re*a)%MOD;\n    return re;\n}\nLL dp[3003][3003];\ninline LL inv(LL a, LL b){return a*modpow(b,MOD-2)%MOD;}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    int cnt[3003]={},l[3003]={},u[3003]={};\n    cin >> n >> m;\n    string s;\n    cin >> s;\n\n    cnt[1]=(s[0]=='1'?1:0);\n    FOR(i,2,n+1){\n        cnt[i]=cnt[i-1]+(s[i-1]=='1'?1:0);\n    }\n    FOR(i,0,n+1)l[i]=u[i]=cnt[i];\n\n    vector<PI> q;\n    q.push_back({0,0});\n    REP(i,m){\n        int a,b;\n        cin >> a>>b;\n        q.push_back({a,b});\n    }\n\n    for(auto it= q.begin()+1;it<q.end();){\n        if(it->second<=(it-1)->second){\n            it=q.erase(it);\n        }else{\n            it++;\n        }\n    }\n    for(auto it= q.begin();it<q.end()-1;){\n        if(it->first==(it+1)->first){\n            it=q.erase(it);\n        }else{\n            it++;\n        }\n    }\n\n    q.insert(q.begin(),{0,0});\n    FOR(i,1,q.size()){\n        int f=cnt[q[i].second]-l[q[i].first-1];\n        FOR(j,q[i].first,q[i].second+1){\n            l[j]=l[q[i].first-1]+max(0,f-q[i].second+j);\n            u[j]=min(cnt[q[i].second],u[q[i].first-1]+j-q[i].first+1);\n        }\n    }\n    dp[0][0]=1;\n    FOR(i,1,n+1){\n        FOR(j,l[i],u[i]+1){\n            dp[i][j]=(dp[i-1][j]+(j==0?0:dp[i-1][j-1]))%MOD;\n            //cout << i << j << dp[i][j]<<endl;\n        }\n    }\n    cout << dp[n][cnt[n]]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n神题\n朴素DP-->O(n^3)\nDP：f[i][j]=填完了前i-1个数，当前需要考虑的区间[i,R]中需要填入j个1，方案数\nans=f[n+1][0]\n转移枚举i位置的数即可O(1)转移\nO(n^2)\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 3010\n#define mod 1000000007\nusing namespace std;\nint n, m, x, y, f[N][N], s[N], sum, R[N];\nchar S[N];\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, S+1);\n\ts[0]=0; for(int i=1; i<=n; i++)s[i]=s[i-1]+S[i]-'0'; s[n+1]=s[n];\n\tfor(int i=1; i<=n+1; i++)R[i]=i;\n\tfor(int i=1; i<=m; i++){scanf(\"%d%d\", &x, &y); R[x]=max(R[x], y);}\n\tmemset(f, 0, sizeof(f)); f[1][s[R[1]]]=1; x=R[1];\n\tfor(int i=1; i<=n; i++){\n\t\ty=max(x, R[i+1]); sum=s[y]-s[x];\n\t\tfor(int j=0; j<=x-i+1; j++){\n\t\t\tif(j)f[i+1][j-1+sum]=(f[i+1][j-1+sum]+f[i][j])%mod;\n\t\t\tif(j<=x-i)f[i+1][j+sum]=(f[i+1][j+sum]+f[i][j])%mod;\n\t\t}\n\t\tx=y;\n\t}\n\tprintf(\"%d\", f[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=3005;\nconst int mod=1000000007;\n\nstruct node{\n\tint l,r;\n\tnode(){}\n\tnode(int l,int r):l(l),r(r){}\n}a[N];\nint n,Q,m,L,R,l,r,x;\nint c[N][N],sum[N],dp[N][N];\nchar s[N];\n\nvoid init(int n){\n\tint i,j;\n\tc[0][0]=1;\n\tfor (i=1;i<=n;i++){\n\t\tc[i][0]=1;\n\t\tfor (j=1;j<=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&Q);\n\tscanf(\"%s\",s+1);\n\tinit(n);\n\tfor (i=1;i<=Q;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (r<=R) continue;\n\t\tif (L==l) R=max(R,r);\n\t\telse{\n\t\t\ta[++m]=node(l,r);\n\t\t\tL=l; R=r;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) sum[i]=sum[i-1]+(s[i]=='1');\n\ta[m+1].l=n+1;\n\tdp[0][sum[a[1].l-1]]=1;\n\tfor (i=1;i<=m;i++){\n\t\tL=a[i].l; R=a[i].r; l=a[i+1].l;\n\t\tif (l>R){\n\t\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\t\tx=sum[R]-j;\n\t\t\t\t(dp[i][sum[l-1]]+=1ll*dp[i-1][j]*c[R-L+1][x]%mod)%=mod;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\tx=sum[R]-j;\n\t\t\tfor (k=max(x-R+l-1,0);k<=min(l-L,x);k++)\n\t\t\t\t(dp[i][j+k]+=1ll*dp[i-1][j]*c[l-L][k]%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[m][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n, m;\nstring s;\n\nint cnt[3005];\nint mx[3005], mn[3005];\nint dp[3005][3005];\nsigned main()\n{\n\tcin>>n>>m>>s;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcnt[i]=cnt[i-1]+(s[i-1]=='1');\n\t\tmx[i]=cnt[i], mn[i]=cnt[i];\n\t}\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint l, r;\n\t\tcin>>l>>r;\n\n\t\tint lol=mn[r]-mn[l-1], lel=mx[r]-mx[l-1];\n\n\t\tfor(int j=l; j<=r; j++)\n\t\t{\n\t\t\tmn[j]=min(mn[j], mn[l-1]+max(0ll, lol-(r-j)));\n\t\t\tmx[j]=max(mx[j], mx[l-1]+min(j-l+1, lel));\n\t\t}\n\t}\n\t// for(int i=1; i<=n; i++)\n\t// {\n\t// \tcout<<mx[i]<<\" \"<<mn[i]<<endl;\n\t// }\n\tdp[0][0]=1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=mn[i]; j<=mx[i]; j++)\n\t\t{\n\t\t\tif(j>0)\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t}\n\t\t\tdp[i][j]%=1000000007;\n\t\t}\n\t}\n\tcout<<dp[n][cnt[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n\n#define mod 1000000007\nusing namespace std;\n\nlong long dp[3010][3010],a[3010],l[3010],r[3010],mx;\nint main(){\n\tstring s;\n\tpair<int,int> p[3010],q[3010];\n\tint i,j,n,m,x,y;\n\tcin >> n >> m >> s;\n\tj = 0;\n\tcin >> l[0] >> r[0];\n\tmx = r[0];\n\tfor(i=1;i<m;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(l[i]==l[i-1]){\n\t\t\tmx = max(mx,r[i]);\n\t\t}else{\n\t\t\tq[j] = make_pair(l[i-1],mx);\n\t\t\tmx = r[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tq[j] = make_pair(l[m-1],mx);\n\tint k = 0;\n\tp[0] = q[0];\n\tfor(i=1;i<=j;i++){\n\t\tif(q[i].second>p[k].second){\n\t\t\tk++;\n\t\t\tp[k] = q[i];\n\t\t}\n\t}\n\t\n\t/*for(i=0;i<=k;i++){\n\t\tcout << p[i].first << \" \" << p[i].second << endl;\n\t}*/\n\tp[k+1] = make_pair(3010,3010);\n\tk = 0;\n\ta[0] = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tk++;\n\t\t}\n\t\ta[i+1] = k;\n\t}\n\t\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\t\n\tk = 0;\n\tdp[0][0] = 1;\n\tfor(i=1;i<=n;i++){\n\t\tif(p[k].first==i){\n\t\t\tk++;\n\t\t}\n\t\t//cout << i << \" \" << k << endl;\n\t\tfor(j=0;j<i;j++){\n\t\t\tif(k==0 || (i<p[k].first && i>p[k-1].second)){\n\t\t\t\tif(i==22){\n\t\t\t\t\t//cout << i << endl;\n\t\t\t\t}\n\t\t\t\tif(s[i-1]=='1'){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}\n\t\t\t}else{// k>=1 && p[mx-1].first<=i<=p[mx-1].second\n\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\tif(a[p[k-1].second]<j+1 || a[p[k-1].second]-(p[k-1].second-i)>j+1){\n\t\t\t\t\t//cout << i << \" \"<< j << endl;\n\t\t\t\t\tdp[i][j+1] = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif(a[p[k-1].second]<j || a[p[k-1].second]-(p[k-1].second-i)>j){\n\t\t\t\t\t//cout <<\" \" << i << \" \" << j << endl;\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(i=0;i<=n;i++){\n\t\tcout << a[i] << \" \" ;\n\t}\n\tcout << endl;\n\tcout << \"  \" ;\n\tfor(i=0;i<=n;i++){\n\t\tcout << i << \" \" ;\n\t}\n\tcout << endl;\n\tfor(i=0;i<=n;i++){\n\t\tcout << i << \" \" ;\n\t\tfor(j=0;j<=n;j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tcout << dp[n][a[n]] << endl;\n}\n\n/*\n22 15\n1010011100010100100000\n2 7\n4 6\n5 8\n8 9\n10 12\n11 13\n11 14\n12 14\n12 17\n12 14\n13 17\n15 16\n16 21\n17 21\n18 20\n*/\n\t"
  },
  {
    "language": "C++",
    "code": "//Link : https://codeforces.com/contest/1279/problem/D\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n\n#define N 3002\n#define mod 1000000007\nint add(int x,int y) {\n  return (x+y)%mod;\n}\nint mul(int x,int y) {\n  return (ll)x*y%mod;\n}\nint dp[N][N];\nint maxR[N];\nchar s[N];\nint preNumZero[N];\nint solveDp(int ind,int zero,int n) {\n  if(ind>n) {\n    assert(zero==0);\n    return 1;\n  }\n  int &ret = dp[ind][zero];\n  if(ret!=-1) {\n    return ret;\n  }\n  if(maxR[ind-1]<maxR[ind]) {\n    zero += preNumZero[maxR[ind]] - preNumZero[maxR[ind-1]];\n  }\n  int one = (maxR[ind] - preNumZero[maxR[ind]])\n    - ( ind-1 - preNumZero[maxR[ind]] +zero);\n  ret = 0;\n  if(zero>0) {\n    ret = add(ret, solveDp(ind+1,zero-1,n));\n  }\n  if(one>0) {\n    ret = add(ret, solveDp(ind+1,zero,n));\n  }\n  return ret;\n}\nvoid solve() {\n  int n,m;scanf(\"%d %d \", &n,&m);\n  scanf(\" %s \", s+1);\n  for(int i=1;i<=n;++i) {\n    preNumZero[i] = preNumZero[i-1] + (s[i]=='0' ? 1 : 0);\n  }\n  for(int i=0;i<m;++i) {\n    int l,r;scanf(\"%d %d \", &l,&r);\n    maxR[l] = max(maxR[l],r);\n  }\n  for(int i=1;i<=n;++i) {\n    maxR[i] = max(maxR[i],maxR[i-1]);\n    maxR[i] = max(maxR[i],i);\n  }\n  memset(dp,-1,sizeof(dp));\n  printf(\"%d\\n\", solveDp(1,0,n));\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=3005;\nconst int mod=1000000007;\n\nstruct node{\n\tint l,r;\n\tnode(){}\n\tnode(int l,int r):l(l),r(r){}\n}a[N];\nint n,Q,m,L,R,l,r,x,tot;\nint c[N][N],sum[N],dp[N][N];\nchar s[N];\n\nvoid init(int n){\n\tint i,j;\n\tc[0][0]=1;\n\tfor (i=1;i<=n;i++){\n\t\tc[i][0]=1;\n\t\tfor (j=1;j<=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n}\n\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout); \n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&Q);\n\tscanf(\"%s\",s+1);\n\tinit(n);\n\tfor (i=1;i<=Q;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (r<=R) continue;\n\t\ta[++tot]=node(l,r);\n\t}\n\tfor (i=1;i<=n;i=j+1){\n\t\tj=i; m++;\n\t\ta[m]=a[i];\n\t\twhile (j<n&&a[j+1].l==a[i].l){\n\t\t\ta[m].r=max(a[m].r,a[j+1].r);\n\t\t\tj++;\n\t\t}\n\t\tif (a[m].r<=a[m-1].r) m--;\n\t}\n\tfor (i=1;i<=n;i++) sum[i]=sum[i-1]+(s[i]=='1');\n\ta[m+1].l=n+1;\n\tdp[0][sum[a[1].l-1]]=1;\n\tfor (i=1;i<=m;i++){\n\t\tL=a[i].l; R=a[i].r; l=a[i+1].l;\n\t\tif (l>R){\n\t\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\t\tx=sum[R]-j;\n\t\t\t\t(dp[i][sum[l-1]]+=1ll*dp[i-1][j]*c[R-L+1][x]%mod)%=mod;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\tx=sum[R]-j;\n\t\t\tfor (k=max(x-R+l-1,0);k<=min(l-L,x);k++)\n\t\t\t\t(dp[i][j+k]+=1ll*dp[i-1][j]*c[l-L][k]%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[m][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(uint64_t num) { return MInt(num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) \n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=3005,MOD=1000000007;\n\nint PowMod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tret=(1LL*a*ret)%MOD;\n\t\tb>>=1;\n\t\ta=(1LL*a*a)%MOD;\n\t}\n\treturn ret;\n}\n\nint N,M;\nint fac[MAXN],ifac[MAXN];\nint sum[MAXN],A[MAXN],l[MAXN],r[MAXN],len[MAXN],cnt1[MAXN];\npair<int,int> seg[MAXN];\nint dp[MAXN][MAXN];\n\nint F(int a,int b)\n{\n\tif(a<b)\n\t\treturn 0;\n\treturn 1LL*fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\t\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(1LL*fac[i-1]*i)%MOD;\n\tifac[N]=PowMod(fac[N],MOD-2);\n\tfor(int i=N-1;i>=0;i--)\n\t\tifac[i]=(1LL*ifac[i+1]*(i+1))%MOD;\n\t\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tscanf(\"%1d\",&A[i]);\n\t\tsum[i]=sum[i-1]+A[i];\n\t}\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tseg[i]=make_pair(l[i],r[i]);\n\t}\n\tsort(seg+1,seg+M+1);\n\tint tmp=0;\n\tfor(int i=2;i<=M+1;i++)\n\t\tif(seg[i].first!=seg[i-1].first&&seg[i-1].second>r[tmp])\n\t\t{\n\t\t\tl[++tmp]=seg[i-1].first;\n\t\t\tr[tmp]=seg[i-1].second;\n\t\t}\n\tM=tmp;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tlen[i]=r[i]-l[i]+1;\n\t\tcnt1[i]=sum[r[i]]-sum[l[i]-1];\n\t}\n\tM++;\n\tl[M]=r[M]=N+1;\n\tlen[M]=1;cnt1[M]=0;\n\t\n\tdp[1][sum[r[1]]-sum[l[1]-1]]=1;\n\tfor(int i=2;i<=M;i++)\n\t{\n\t\tif(l[i]>r[i-1])\n\t\t\tfor(int j=0;j<=len[i-1];j++)\n\t\t\t\t(dp[i][cnt1[i]]+=(1LL*dp[i-1][j]*F(len[i-1],j)%MOD))%=MOD;\n\t\telse\n\t\t\tfor(int j=0;j<=r[i-1]-l[i]+1;j++)\n\t\t\t\tfor(int k=j;k<=len[i-1];k++)\n\t\t\t\t\t(dp[i][j+sum[r[i]]-sum[r[i-1]]]+=(1LL*dp[i-1][k]*F(l[i]-l[i-1],k-j)%MOD))%=MOD;\n\t}\n\t\n\tprintf(\"%d\\n\",dp[M][0]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\nint n, m;\nchar s[N];\nint f[N][N];\nint mxr[N];\nint add(int x, int y) {\n    x+= y;\n    return x >= mod ?x - mod : x;\n}\nint sub(int x, int y) {\n    x -= y;\n    return x < 0 ? x +mod : x;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n ; i++ )\n        mxr[i] = i;\n    for (int i = 1; i <= m; i ++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        mxr[x] = max(mxr[x], y);\n    }\n    f[0][0] = 1;\n    for (int i = 0; i < n; i ++ ) {\n        int ones = 0;\n        mxr[i +1] = max(mxr[i+1], mxr[i]);\n        if (mxr[i + 1] != mxr[i]) {\n            for (int j = mxr[i]+ 1; j <= mxr[i + 1]; j ++)\n                if (s[j] == '1')\n                    ones ++;\n        }\n        int all = mxr[i + 1] - i;\n        for (int j = 0; j <= n; j++)\n            if (f[i][j]) {\n                if (ones + j)\n                    f[i + 1][ones + j -1] = add(f[i + 1][ones + j - 1], f[i][j]);\n                if (ones + j != all)\n                    f[i + 1][ones + j] = add(f[i + 1][ones + j], f[i][j]);\n            }\n    }\n    printf(\"%d\\n\", f[n][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\n    const int MAX =200002;\nconst int MOD =  998244353;\n\n     signed main(){\nint n,m;\ncin>>n>>m;\nstring s;\ncin>>s;\nint x[n+1];\nfor(int i=0;i<=n;i++)x[i]=i;\nint l,r;\nfor(int i=0;i<m;i++){\n    cin>>l>>r;\n    x[l]=max(x[l],r);\n}\nfor(int i=0;i<n;i++)x[i+1]=max(x[i],x[i+1]);\nmap<pair<int,int>,int> mp1,mp2;\nmp1[{0,0}]=1;\n\nfor(int i=0;i<n;i++){\n    int t0=0,t1=0;\n    for(int j=x[i];j<x[i+1];j++){\n        if(s[j]=='0')t0++;\n        else t1++;\n    }\n    for(auto&& j:mp1){\n        pair<int,int>p={j.first.first+t0,j.first.second+t1};\n        if(p.first!=0)mp2[{p.first-1,p.second}]=(mp2[{p.first-1,p.second}]+j.second)%MOD;\n        if(p.second!=0)mp2[{p.first,p.second-1}]=(mp2[{p.first,p.second-1}]+j.second)%MOD;\n    }\n    swap(mp1,mp2);\n    mp2.clear();\n   \n}\n  \ncout<<mp1[{0,0}]<<endl;\n\n     }\n\n\n \n\n\n \n\n\n\n\n\n\n    \n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005;\nconst int MOD = 1e9 + 7;\nint dp[N][N], cnt[2];\nchar s[N], t[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n, m; cin >> n >> m >> (s + 1);\n    strcpy(t + 1, s + 1); dp[0][0] = 1;\n    for (int i = 1; i <= m; i++) {\n        int l, r; cin >> l >> r;\n        sort(s + l, s + r + 1);\n        sort(t + l, t + r + 1, greater <char> ());\n    }\n    for (int i = 1; i <= n; i++) {\n        cnt[0] += s[i] == '0';\n        cnt[1] += t[i] == '0';\n        for (int j = cnt[1]; j <= cnt[0]; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j) dp[i][j] += dp[i - 1][j - 1];\n            if (dp[i][j] >= MOD) dp[i][j] -= MOD;\n        }\n    }\n    int res = 0;\n    for (int j = cnt[1]; j <= cnt[0]; j++) {\n        res += dp[n][j];\n        if (res >= MOD) res -= MOD;\n    }\n    cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define countof(a) (sizeof(a)/sizeof(*a))\n\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vpi vector<pi >\n#define pi pair<int,int>\n#define fi first\n#define se second\n#define all(n) n.begin(), n.end()\n\n#define FROMTO(var, from, to) for (register int var = (from), var##down = ((int)(to)) < ((int)(from));var##down ? (var >= (int)(to)) : (var <= (int)(to));var##down ? var-- : var++)\n#define UPTO(var, from, to)   for (register int var = (from); var <= ((int)to); var++)\n#define DOWNTO(var, from, to) for (register int var = (from); var >= ((int)to); var--)\n#define FOR(var, to)          UPTO(var, 0, (to)-1)\n#define DOWN(var, from)       DOWNTO(var, (from)-1, 0) \n\n#define INIT(var, val) FOR(i,countof(var)) var[i] = val\n#define INPUT(var) FOR(i,countof(var)) cin >> var[i]\n#define INPUT1(var) FOR(i,countof(var)) cin >> var[i], var[i]--\n\n#define SORT(v) qsort(v,countof(v),sizeof(*v),int_less)\n#define SORTT(v) qsort(v,countof(v),sizeof(*v),int_greater)\n#define QSORT(v,b) qsort(v,countof(v),sizeof(*v),b)\n\n#define MOD 1000000007\n#define INF ((1 << 30)-1)\n#define LINF ((1LL << 62)-1)\n\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t s8;\ntypedef int16_t s16;\ntypedef int32_t s32;\ntypedef int64_t s64;\n\n/* ------------------------ */\n/* BEGIN EXTERNAL LIBRARIES */\n/* ------------------------ */\n\ntemplate<int mod>\nstruct ModInt{\n    int x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=mod-p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1LL*x*p.x%mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        *this*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(-x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    bool operator==(const ModInt &p)const{return x==p.x;}\n    bool operator!=(const ModInt &p)const{return x!=p.x;}\n    explicit operator int() const { return x; }                           // added by QCFium\n    ModInt operator=(const int p) {x = p; return ModInt(*this);} // added by QCFium\n    ModInt inverse()const{\n        int a=x,b=mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            a-=t*b;\n            swap(a,b);\n            u-=t*v;\n            swap(u,v);\n        }\n        return ModInt(u);\n    }\n    friend ostream &operator<<(ostream &os,const ModInt<mod> &p){\n        return os<<p.x;\n    }\n    friend istream &operator>>(istream &is,ModInt<mod> &a){\n        long long x;\n        is>>x;\n        a=ModInt<mod>(x);\n        return (is);\n    }\n};\ntypedef ModInt<MOD> mint;\n\nstruct UnionFind{\n    vi data;\n    UnionFind(int size):data(size,-1){}\n    bool unite(int x,int y) {\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    bool find(int x,int y) {\n        return root(x)==root(y);\n    }\n    int root(int x) {\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // added by QCFium\n    bool united() {\n        int comroot = -1;\n        FOR(i,data.size()) {\n            if (comroot != -1 && root(i) != comroot) return false;\n            comroot = root(i);\n        }\n        return true;\n    }\n};\n\n/* ---------------------- */\n/* END EXTERNAL LIBRARIES */\n/* ---------------------- */\n\nint mpow(s64 num, s64 times) { // O(log(times))\n    mint next = num%MOD;\n\tmint res = 1;\n\twhile (times) {\n\t\tif (times%2)\n            res *= next;\n\t\tnext *= next;\n\t\ttimes /= 2;\n\t}\n\treturn (int)res;\n}\n\nstruct Comb {\n    vector<vector<s64> > data;\n    Comb(int n) { // O(n^2)\n        data = vector<vector<s64> >(n+1,vector<s64>(n+1,1));\n        UPTO(i,1,n) {\n            FOR(j,i+1) {\n                if (!j || j == i) data[i][j] = 1;\n                else data[i][j] = data[i-1][j-1] + data[i-1][j];\n            }\n        }\n    }\n    \n    s64 ncr(int n, int r) {\n        return data[n][r];\n    }\n};\n\nstruct MComb {\n    vector<mint> fact;\n    vector<mint> inversed;\n    MComb(int n) { // O(n+log(mod))\n        fact = vector<mint>(n+1,1);\n        UPTO(i,1,n) fact[i] = fact[i-1]*mint(i);\n        inversed = vector<mint>(n+1);\n        inversed[n] = mpow((int)fact[n], MOD-2);\n        DOWN(i,n) inversed[i]=inversed[i+1]*mint(i+1);\n    }\n    \n    int ncr(int n, int r) {\n        return (int)(fact[n] * inversed[r] * inversed[n-r]);\n    }\n    \n    int npr(int n, int r) {\n        return (int)(fact[n] * inversed[n-r]);\n    }\n    \n    int nhr(int n, int r) {\n        assert(n+r-1 < (int)fact.size());\n        return ncr(n+r-1, r);\n    }\n};\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+(set<Key>& a, set<Key>& b) {\n    set<Key> c = a;\n    for (auto i : b) \n        c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+=(set<Key>& a, set<Key>& b) {\n    for (auto& i : b)\n        a.insert(i);\n    return a;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\nstatic inline int ri() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\n\nint int_less(const void *a, const void *b) {\n  return (*((const int*)a) - *((const int*)b));\n}\nint int_greater(const void *a, const void *b) {\n  return (*((const int*)b) - *((const int*)a));\n}\n\nint main() {\n    int n = ri();\n\tint m = ri();\n\tbool a[n];\n\t{\n\t\tstring s; cin >> s;\n\t\tFOR(i,n) a[i] = s[i]=='1';\n\t}\n\t\n\tvector<pi > lr;\n\tFOR(i,m) {\n\t\tint l = ri()-1;\n\t\tint r = ri()-1;\n\t\tif (!lr.size() || r > lr.back().se) lr.push_back(pi(l,r));\n\t}\n\t\t\n\tMComb com(3001);\n\t// sum\n\tint sum[n];\n\tsum[0] = a[0];\n\tFROMTO(i,1,n-1) sum[i] = sum[i-1] + a[i];\n\t\n\tvector<mint> dp;\n\tdp = vector<mint>(1,1);\n\t\n\tint minn = 0;\n\t\n\tint r = lr[0].fi-1;\n\tFOR(i,lr.size()) {\n\t\tif (r < lr[i].fi) {\n\t\t\t// just to be safe\n\t\t\tr = lr[i].fi-1;\n\t\t\tminn = 0;\n\t\t\tassert(dp.size() == 1);\n\t\t}\n\t\t\n\t\tif (i == (int)lr.size()-1 || lr[i+1].fi > lr[i].se) { // reset\n\t\t\t// cout << \"i:\" << i << \" min:\" << minn << \" not covered\" << endl;\n\t\t\tFOR(j,dp.size()){\n\t\t\t\t// cout << \"    j:\" << j << \" dp[j]:\" << dp[j] << endl;\n\t\t\t}\n\t\t\tint base = sum[lr[i].se] - (r<0?0:sum[r]) + minn;\n\t\t\tint range = lr[i].se - lr[i].fi + 1;\n\t\t\tmint tmp = 0;\n\t\t\tFOR(j,dp.size()) {\n\t\t\t\ttmp += dp[j]*(mint)com.ncr(range,base+j);\n\t\t\t}\n\t\t\tdp.resize(1);\n\t\t\tdp[0] = tmp;\n\t\t\tminn = 0;\n\t\t\tif (i < (int)lr.size()-1) r = lr[i+1].fi-1;\n\t\t} else {\n\t\t\tint base = sum[lr[i].se] - (r<0?0:sum[r]) + minn;\n\t\t\tint left = lr[i+1].fi - lr[i].fi;\n\t\t\tint right = lr[i].se - lr[i+1].fi + 1;\n\t\t\t// cout << \"i:\" << i << \" left:\" << left << \" right:\" << right << \" base:\" << base << endl;\n\t\t\tvector<mint> dp_new(min(right,(int)(base+dp.size()-1))-max(0,base-left)+1,0);\n\t\t\t// cout << \"dp_new size:\" << dp_new.size() << endl;\n\t\t\tFOR(j,dp.size()) {\n\t\t\t\tif (!j) minn = max(0,base+j-left);\n\t\t\t\tint maxx = min(right,base+j);\n\t\t\t\t// cout << \"i:\" << i << \" j:\" << j << \" min:\"<<max(0,base+j-left) << \" max:\" << maxx << endl;\n\t\t\t\tFROMTO(k,max(0,base+j-left),maxx) {\n\t\t\t\t\tmint next = ((mint)com.ncr(left,base+j-k))*dp[j];\n\t\t\t\t\tdp_new[k-minn] += next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp_new;\n\t\t\tr = lr[i].se;\n\t\t}\n\t}\n\tcout << dp[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 4010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\nchar s[MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s + 1);\n    for(i = 1; i <= n; ++i){\n        a[i] = s[i] - '0';\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad = 0;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j, ad = 0){\n            if(j > R){\n                R = j;\n                ad += a[j];\n            }\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad += sum[r] - sum[R];\n            R = r;\n        }\n//        for(; j < l; ++j, ad = 0){\n//            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n//                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n//                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n//            }\n//        }\n    }\n    for(; j <= n; ++j, ad = 0){\n        if(j > R){\n            R = j;\n            ad += a[j];\n        }\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tdp[0][0] = 1;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if(i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if(j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<n;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=3030,P=1000000007;\nint i,j,k,n,m,x,y;\nint r[N],sum[N],f[N][N];\nchar s[N];\nvoid Up(int &x,int y) {\n\tx=(x+y)%P;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (i=1;i<=n;i++) sum[i]=sum[i-1]+s[i]-'0';\n\tfor (i=1;i<=n;i++) r[i]=i;\n\tfor (i=1;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tf[1][sum[r[1]]]=1;\n\tint ma=r[1];\n\tfor (i=1;i<n;i++) {\n\t\tint tmp=ma;\n\t\tma=max(ma,r[i+1]);\n\t\tfor (j=0;j<=tmp-i+1;j++) if (f[i][j]) {\n\t\t\tif (j) Up(f[i+1][j-1+sum[ma]-sum[tmp]],f[i][j]);\n\t\t\tif (j!=tmp-i+1) Up(f[i+1][j+sum[ma]-sum[tmp]],f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(f[n][0]+f[n][1])%P);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1e9 + 7;\nint D[4040][4040];\n\nvoid solve(){\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tchar S[2][3030];\n\tscanf(\"%s\", S[0]+1);\n\tfor(int i=1;i<=n;i++)S[1][i] = S[0][i];\n\trep(i, m){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tsort(S[0]+x, S[0]+y+1);\n\t\tsort(S[1]+x, S[1]+y+1, [](int x,int y){return x > y;});\n\t}\n\tint s[2][4040] = {};\n\trep(u, 2)for(int i=1;i<=n;i++)s[u][i] = s[u][i-1] + (S[u][i] == '1');\n\tD[0][0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=s[0][i];j<=s[1][i];j++)D[i][j] = ((j?D[i-1][j-1]:0) + D[i-1][j]) % MOD;\n\t}\n\tprintf(\"%d\", D[n][s[0][n]]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tban[i][j] = false;\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\t//assert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\ttable.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = max(table[i].second, rightmost);\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\t//assert(problemid == 0);\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nsigned main(){\n\tint n,m,MOD=1000000007;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvi co(n+1);\n\trep(i,n)co[i+1]=co[i]+(s[i]=='1');\n\tvi ma(n);\n\trep(i,n)ma[i]=i+1;\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tcmax(ma[a],b);\n\t}\n\tint w=0;\n\tvi dp(n+1);\n\tdp[0]=1;\n\trep(i,n){\n\t\tif(w<ma[i]&&co[ma[i]]-co[w])\n\t\t\tfor(int j=n;j>=0;j--)if(j+co[ma[i]]-co[w]<=n)\n\t\t\t\tdp[j+co[ma[i]]-co[w]]=dp[j],dp[j]=0;\n\t\tcmax(w,ma[i]);\n\t\trep(j,n)(dp[j]+=dp[j+1])%=MOD;\n\t\tloop(j,w-i,n+1)dp[j]=0;\n\t}\n\tcout<<dp[0]<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nint l[3005], r[3005];\nll ncr[3005][3005];\nll dp[3005][3005];\nchar buf[3005];\nint cu[3005];\nint n, m;\n\nll slv(int at, int ones)\n{\n\tif (at == m) return 1;\n\tif (dp[at][ones]) return dp[at][ones];\n\tif (r[at] >= l[at+1])\n\t{\n\t\tint lim = min(l[at+1]-l[at], ones);\n\t\tfor (int i = max(0, ones-r[at]+l[at+1]-1);i <= lim;i++)\n\t\t{\n\t\t\tdp[at][ones] += slv(at+1, ones-i+cu[r[at+1]]-cu[r[at]])*ncr[l[at+1]-l[at]][i];\n\t\t\tdp[at][ones] %= MOD;\n\t\t}\n\t} else\n\t{\n\t\tdp[at][ones] = ncr[r[at]-l[at]+1][ones] * slv(at+1, cu[r[at+1]]-cu[l[at+1]-1]);\n\t\tdp[at][ones] %= MOD;\n\t}\n\treturn dp[at][ones];\n}\n\nint main()\n{\n\tncr[0][0] = 1;\n\tfor (int i = 1;i < 3005;i++)\n\t{\n\t\tncr[i][0] = 1;\n\t\tfor (int j = 1;j <= i;j++) ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % MOD;\n\t}\n\tscanf(\"%d%d%s\", &n, &m, buf);\n\tfor (int i = 0;i < m;i++) scanf(\"%d%d\", l+i, r+i), --l[i], --r[i];\n\tfor (int i = 1;i < m;i++) r[i] = max(r[i], r[i-1]);\n\tfor (int i = 0;i < n;i++) cu[i] = buf[i]-'0';\n\tfor (int i = 1;i < n;i++) cu[i] += cu[i-1];\n\tl[m] = r[m] = n;\n\tprintf(\"%lld\\n\", slv(0, cu[r[0]]-(l[0]?cu[l[0]-1]:0)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n \nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n \nusing namespace std;\nconst int N=3010,mod=1e9+7;\nchar s[N];\nint n,m,ans,fac[N],ifac[N],l[N],r[N],lb[N],rb[N],f[2][N],a[N];\n\nint inv(int x)\n{\n    return x>1? 1ll*(mod-mod/x)*inv(mod%x)%mod:1;\n}\n\nint c(int n,int m)\n{\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n \nint main()\n{\n    n=get(),m=get();\n    fac[0]=1;\n    rep(i,1,n)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=inv(fac[n]);\n    repd(i,n,1)\n        ifac[i-1]=1ll*ifac[i]*i%mod;\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        static int *f=::f[0],*g=::f[1];\n        swap(f,g);\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        lb[i]=max(0,lb[i-1]+w-s),rb[i]=min(mx,rb[i-1]+w);\n        rep(j,lb[i],rb[i])\n            rep(k,max(j-w,lb[i-1]),min(s+j-w,rb[i-1]))\n                f[j]=(f[j]+1ll*g[k]*c(s,k+w-j))%mod;\n        memset(g+lb[i-1],0,sizeof(int)*(rb[i-1]-lb[i-1]+1));\n    }\n    rep(i,lb[m],rb[m])\n        ans=(ans+f[m&1][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\n#define x first\n#define y second\n#define MOD 1000000007\n#define NMAX 3005\n\nint n, m, d[NMAX][NMAX], ones;\nchar s[NMAX];\npair<int,int> interval[NMAX];\n\nstruct segTree{\n    int sum, lazy;\n};\n\nsegTree aintL[4 * NMAX], aintR[4 * NMAX];\n\nvoid updateNode(segTree aint[], int n, int left, int right, int val){\n    aint[n].sum= (right - left + 1) * val;\n    aint[n].lazy = val;    \n}\n\nvoid update(segTree aint[], int n, int left, int right, int a, int b, int val){\n    if(a > b)\n        return ;\n    if(a <= left  && right <= b){\n        updateNode(aint, n, left, right, val);\n        return ;\n    }\n    int mid = (left + right) / 2;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        update(aint, 2 * n, left, mid, a, b, val);\n    if(b > mid)\n        update(aint, 2 * n + 1, mid + 1, right, a, b, val);\n    aint[n].sum = aint[2 * n].sum + aint[2 * n + 1].sum;\n}\n\nint queryCount(segTree aint[], int n, int left, int right, int a, int b){\n    if(a <= left && right <= b){\n        return aint[n].sum;\n    }\n    int mid = (left + right) / 2, ans1 = 0, ans2 = 0;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        ans1 = queryCount(aint, 2 * n, left, mid, a, b);\n    if(b > mid)\n        ans2 = queryCount(aint, 2 * n + 1, mid + 1, right, a, b);\n    return ans1 + ans2;\n}\n\nint main (){\n    pair<int,int> seg;\n    \n    scanf(\"%d%d\\n\",&n,&m);\n    scanf(\"%s\",s + 1);\n    for(int i = 1; i <= n; i++){\n        update(aintL, 1, 1, n, i, i, s[i] - '0');\n        update(aintR, 1, 1, n, i, i, s[i] - '0');\n    }\n    for(int i = 1; i <= m; i++){\n        scanf(\"%d%d\",&seg.x,&seg.y);\n        int cnt = queryCount(aintL, 1, 1, n, seg.x, seg.y);\n        update(aintL, 1, 1, n, seg.x, seg.x + cnt - 1, 1);\n        update(aintL, 1, 1, n, seg.x + cnt, seg.y, 0);\n        \n        cnt = queryCount(aintR, 1, 1, n, seg.x, seg.y);\n        update(aintR, 1, 1, n, seg.x, seg.y - cnt, 0);\n        update(aintR, 1, 1, n, seg.y - cnt + 1, seg.y, 1);\n    }\n    \n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintL, 1, 1, n, i, i)){\n            interval[++ones].x = i;\n        }\n    }\n    ones = 0;\n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintR, 1, 1, n, i, i)){\n            interval[++ones].y = i;\n        }\n    }\n    \n    d[0][0] = 1;\n    for(int i = 1; i <= n; i++)\n        for(int j = 0; j <= ones; j++){\n            d[i][j] = d[i - 1][j];\n            if(j && interval[j].x <= i && i <= interval[j].y)\n                d[i][j] += d[i - 1][j - 1];\n            if(d[i][j] >= MOD)\n                d[i][j] -= MOD;\n        }\n    printf(\"%d\\n\", d[n][ones]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3030;\nconst int mod = 1e9 + 7;\n\nvoid add(int &x, int y) {\n   x += y;\n   if (x >= mod) {\n      x -= mod;\n   }\n}\n\nint n, m;\nchar s[N];\nint go[N];\nint f[N][N];\n\nint main() {\n   scanf(\"%d %d %s\", &n, &m, s + 1);\n   for (int i = 1; i <= n; ++i) {\n      go[i] = i;\n   }\n   for (int i = 0; i < m; ++i) {\n      int l, r;\n      scanf(\"%d %d\", &l, &r);\n      go[l] = max(go[l], r);\n   }\n   for (int i = 1; i <= n; ++i) {\n      go[i] = max(go[i], go[i - 1]);\n   }\n   f[0][0] = 1;\n   for (int i = 1; i <= n; ++i) {\n      int ad = 0;\n      for (int j = go[i - 1] + 1; j <= go[i]; ++j) {\n         ad += (s[j] - '0');\n      }\n      for (int j = 0; j <= n; ++j) {\n         if (!f[i - 1][j]) continue;\n         if ((j + ad)) {\n            add(f[i][j + ad - 1], f[i - 1][j]);\n         }\n         if (go[i] - i + 1 - (j + ad)) {\n            add(f[i][j + ad], f[i - 1][j]);\n         }\n      }\n   }\n   printf(\"%d\\n\", f[n][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\t//cout << \"start: \" << x << \" \" << ones << \" \" << maxr[x] - x + 1 << \"\\n\";\n\tif (x == n + 1) return 1ll;\n\tif (ones > maxr[x] - x + 1) return 0;\n\t\n\t\n\t\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tdp[x][ones] %= mod;\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << x << \" \" << ones << \" \" << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t\n\t//for (int i =1;i<=n;i++) {\n\t\t//cout << i << \" \" << maxr[i] << \"\\n\";\n\t//}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(firstl,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN=3005,MOD=1e9+7;\nchar s[MAXN];\nint n,m,x,y,pre[MAXN],lst[MAXN],dp[MAXN][MAXN];\n\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);s[n+1]='0';\n\tfor(int i=1;i<=n+1;i++) \n\t\tpre[i]=(s[i]-'0')+pre[i-1],lst[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d%d\",&x,&y),lst[x]=max(lst[x],y);\n\tfor(int i=1;i<=n+1;i++) lst[i]=max(lst[i],lst[i-1]);\n\t\n\tdp[1][pre[lst[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(dp[i][j])\n\t\t\t{\n\t\t\t\tint l=lst[i]+1,r=lst[i+1];\n\t\t\t\tif(j) (dp[i+1][pre[r]-pre[l-1]+j-1]+=dp[i][j])%=MOD;\n\t\t\t\tif(lst[i]-(i-1)-j) (dp[i+1][pre[r]-pre[l-1]+j]+=dp[i][j])%=MOD;\n\t\t\t}\n\tprintf(\"%d\",dp[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimise (\"ofast\")\n#pragma GCC optimise(\"unroll-loops\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 3000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000000000000000;\nconst ll LOG = 25;\n\nint n, m, a[N], dp[N][N], DP[N], mark[N], ps[N], nCr[N][N], PS[N];\nstruct SEG{\n\tint l, r;\n};\nvector<SEG> seg1, seg;\nvector<int> koj[N];\n\nvoid calc(){\n\tnCr[0][0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\tnCr[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++){\n\t\t\tnCr[i][j] = nCr[i - 1][j - 1] + nCr[i - 1][j];\n\t\t\tnCr[i][j] %= MOD;\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcalc();\n\tcin >> n >> m;\n\t//cout << nCr[6][3] << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tchar c;\n\t\tcin >> c;\n\t\tif (c == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tPS[i] = PS[i - 1];\n\t\tPS[i] += a[i];\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tSEG a;\n\t\tcin >> a.l >> a.r;\n\t\tseg1.pb(a);\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tif (i == j) continue;\n\t\t\tif (seg1[i - 1].l <= seg1[j - 1].l && seg1[j - 1].r <= seg1[i - 1].r) mark[j] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tif (!mark[i]) seg.pb(seg1[i - 1]);\n\t}\n\tfor (auto u:seg){\n\t\tkoj[u.l].pb(u.r);\n\t\t//cout << u.l << ' ' << u.r << '\\n';\n\t\tps[u.l]++;\n\t\tps[u.r + 1] --;\n\t}\n\tfor (int i = 1; i <= n; i++) ps[i] += ps[i - 1];\n\tDP[n + 1] = 1;\n\tint last = n + 1;\n\tfor (int i = n; i >= 1; i--){\n\t\tif (ps[i] == 0) DP[i] = DP[i + 1];\n\t\telse if(koj[i].size() == 0) DP[i] = DP[i + 1];\n\t\telse{\n\t\t\tif (last <= koj[i][0]){\n\t\t\t\tfor (int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tfor (int k = max(0, j - (koj[i][0] - last + 1)); k <= min(j, last - i); k++){\n\t\t\t\t\t\t//if (i == 4 && j == 3) cout << k << ' ' << dp[last][j - k + PS[koj[last][0]] - PS[koj[i][0]]] << ' ' <<  nCr[last - i][k] << '\\n';\n\t\t\t\t\t\tdp[i][j] %= MOD;;\n\t\t\t\t\t\tdp[i][j] += (dp[last][j - k + PS[koj[last][0]] - PS[koj[i][0]]] * 1ll * nCr[last - i][k]) % MOD;\n\t\t\t\t\t\tdp[i][j] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j <= koj[i][0] - i + 1; j++){\n\t\t\t\t\tdp[i][j] = nCr[koj[i][0] - i + 1][j] * 1ll * DP[koj[i][0] + 1] % MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tDP[i] = dp[i][PS[koj[i][0]] - PS[i - 1]];\n\t\t\tlast = i;\n\t\t}\n\t\t//cout << i << ' ' << DP[i] << '\\n';\n\t}\n\tcout << DP[1];\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nconst int maxN = 3005;\nint n, m;\nint tp[maxN];\nint mx[maxN];\nint l[maxN], r[maxN];\nint inv[maxN], fact[maxN], invfact[maxN];\n\nvoid init() {\n    fact[0] = fact[1] = invfact[0] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n}\n\nint cnk(int a, int b) {\n    if (a < b || b < 0) return 0;\n    return mult(fact[a], mult(invfact[a - b], invfact[b]));\n}\n\nint dp[maxN][maxN];\nint pref[maxN];\n\nint ones(int l, int r) {\n    return pref[r] - pref[l - 1];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    init();\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        char c;\n        cin >> c;\n        tp[i] = c - '0';\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> l[i] >> r[i];\n        mx[l[i]] = max(mx[l[i]], r[i]);\n    }\n    int cur_max = 0;\n    for (int i = 1; i <= n; i++) {\n        if (cur_max >= mx[i]) {\n            mx[i] = 0;\n        }\n        cur_max = max(cur_max, mx[i]);\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++) {\n        if (mx[i] != 0) {\n            m++;\n            l[m] = i;\n            r[m] = mx[i];\n        }\n    }\n    assert(m != 0);\n    for (int i = 1; i <= n; i++) {\n        pref[i] = pref[i - 1] + tp[i];\n    }\n    dp[1][ones(l[1], r[1])] = 1;\n    /*for (int i = 0; i <= n; i++) {\n        cout << dp[1][i] << \" \";\n    }\n    cout << endl;*/\n    for (int i = 1; i + 1 <= m; i++) {\n        if (l[i + 1] > r[i]) {\n            int will = ones(l[i + 1], r[i + 1]);\n            int tot = r[i] - l[i] + 1;\n            for (int j = 0; j <= tot; j++) {\n                dp[i + 1][will] = sum(dp[i + 1][will], mult(dp[i][j], cnk(tot, j)));\n            }\n        }\n        else {\n            int tot = r[i] - l[i] + 1;\n            for (int j = 0; j <= tot; j++) {\n                if (dp[i][j] == 0) continue;\n                for (int ones_here = 0; ones_here <= l[i + 1] - l[i] && ones_here <= j; ones_here++) {\n                    int coef = cnk(l[i + 1] - l[i], ones_here);\n                    int will_ones = ones(r[i] + 1, r[i + 1]);\n                    if (j - ones_here > r[i] - l[i + 1] + 1) continue;\n                    dp[i + 1][j - ones_here + will_ones] = sum(dp[i + 1][j - ones_here + will_ones], mult(dp[i][j], coef));\n                }\n            }\n        }\n    }\n    int tot = 0;\n    for (int i = 0; i <= n; i++) {\n        tot = sum(tot, mult(dp[m][i], cnk(r[m] - l[m] + 1, i)));\n    }\n    cout << tot;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n// #define dump(x)  cerr << #x << \" = \" << (x) << endl\n\n#ifndef ONLINE_JUDGE\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << ' ' << H; debug_out(T...); }\n#define debug(...) cerr << 'L' << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << 'L' << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    int &l = lm[i];\n    int &r = rm[i];\n    rep(j, l+1) tmp[l+1] += dp[j];\n    rep2(j, l+1, r+1) tmp[j+1] = tmp[j] + dp[j];\n    swap(dp, tmp);\n    debug(dp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define rg register\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 3005;\nconst int MOD = 1e9 + 7;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n\tif (x < y) x = y;\n}\n\nchar s[MAXN];\nint n, m, sum[MAXN], rbd[MAXN];\nint dp[MAXN][MAXN];\n\ninline void Inc(int &x, int y) {\n\tx += y; if (x >= MOD) x -= MOD;\n}\n\nvoid init() {\n\tread(n); read(m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i=1;i<=n;++i) {\n\t\tsum[i] = sum[i-1] + s[i] - '0';\n\t\trbd[i] = i;\n\t}\n\tsum[n+1] = sum[n]; rbd[n+1] = n+1;\n\tfor (int i=1;i<=m;++i) {\n\t\tint l, r;\n\t\tread(l); read(r);\n\t\tcmax(rbd[l], r);\n\t}\n\tfor (int i=1;i<=n;++i) {\n\t\tcmax(rbd[i], rbd[i-1]);\n\t}\n}\n\nvoid solve() {\n\tdp[1][sum[rbd[1]]] = 1;\n\tfor (int i=1;i<=n;++i) {\n\t\tfor (int j=0;j<=n;++j) {\n\t\t\tint x = dp[i][j];\n\t\t\tif (!x) continue;\n\t\t\tint l = rbd[i] + 1, r = rbd[i+1];\n\t\t\tint cnt1 = j, cnt0 = rbd[i] - i + 1 - j;\n\t\t\tif (cnt0) Inc(dp[i+1][j+sum[r]-sum[l-1]], x);\n\t\t\tif (cnt1) Inc(dp[i+1][j-1+sum[r]-sum[l-1]], x);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n+1][0]);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid read(int &x) {\n\tchar ch; bool ok;\n\tfor(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n\tfor(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=3010,mod=1e9+7;\nchar ch[maxn];\nint n,m,f[maxn][maxn],tot,sum[maxn],las[maxn];\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint main()\n{\n\tread(n),read(m);scanf(\"%s\",ch+1);\n\tfor(rg int i=1;i<=n+1;i++){\n\t\tsum[i]=sum[i-1],las[i]=i;\n\t\tif(ch[i]=='1')tot++,sum[i]++;\n\t}\n\tfor(rg int i=1,x,y;i<=m;i++)read(x),read(y),las[x]=max(las[x],y);\n\tfor(rg int i=1;i<=n+1;i++)las[i]=max(las[i],las[i-1]);\n\tf[1][sum[las[1]]]=1;\n\tfor(rg int i=1;i<=n;i++){\n\t\tfor(rg int j=0;j<=tot;j++){\n\t\t\tint a=las[i],b=las[i+1];\n\t\t\tif(j)f[i+1][j+sum[b]-sum[a]-1]=add(f[i+1][j+sum[b]-sum[a]-1],f[i][j]);\n\t\t\tif(las[i]+1-i-j)f[i+1][j+sum[b]-sum[a]]=(f[i+1][j+sum[b]-sum[a]],f[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){int i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\ntemplate<long long MOD>istream & operator >> (istream &i,Mod_Int<MOD> &A){ll a; cin>>a; A=Mod_Int<MOD>(a); return i;}\ntemplate<long long MOD>ostream & operator << (ostream &i,const Mod_Int<MOD> &A){i<<A.a; return i;}\n\nusing Int=Mod_Int<MOD>;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll N,M;\n  cin>>N>>M;\n  string s;\n  cin>>s;\n  vector<int> cnt(N,0);\n  for(int i=0;i<N;i++){cnt[i]=s[i]-'0';}\n  for(int i=1;i<N;i++){cnt[i]+=cnt[i-1];}\n  vector<ll> mx(N,0);\n  for(int i=0;i<N;i++){mx[i]=i;}\n  for(int i=0;i<M;i++){\n    ll l,r;\n    cin>>l>>r;\n    l--; r--;\n    mx[l]=max(mx[l],r);\n  }\n  for(int i=1;i<N;i++){mx[i]=max(mx[i],mx[i-1]);}\n  vector<Int> dp(N+1,0),nx(N+1,0);\n  dp[0]=1;\n  for(int i=0;i<N;i++){\n    for(auto &I:nx){I=0;}\n    for(int j=0;j<=N;j++){\n      if(cnt[mx[i]]>=j+1){nx[j+1]+=dp[j];}\n      if(mx[i]+1-cnt[mx[i]]>=i-j+1){nx[j]+=dp[j];}\n    }\n    swap(dp,nx);\n  }\n  Int ans=0;\n  for(auto &I:dp){ans+=I;}\n  cout<<ans<<endl;\n  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nint main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]])q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max(0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j+t<=jb&&j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max(0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<f[m][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 3030;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\ninline void reduce(int & x) {\n\tx += x >> 31 & mod;\n}\nint n, m;\nchar c[maxn];\nint max[maxn], s[maxn];\nint f[maxn][maxn];\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> m;\n\trep(i, 1, n) {\n\t\tcin >> c[i];\n\t\ts[i] = s[i - 1] + c[i] % 2;\n\t\tmax[i] = i;\n\t}\n\trep(i, 1, m) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tmax[l] = std::max(max[l], r);\n\t}\n\tf[1][s[max[1]]] = 1;\n\trep(i, 1, n) {\n\t\tmax[i + 1] = std::max(max[i + 1], max[i]);\n\t\tint lol = s[max[i + 1]] - s[max[i]];\n\t\trep(j, 0, n) {\n\t\t\tif(j != 0) { \n\t\t\t\treduce(f[i + 1][j + lol - 1] += f[i][j] - mod);\n\t\t\t}\n\t\t\tif(i + j - 1 != max[i]) {\n\t\t\t\treduce(f[i + 1][j + lol] += f[i][j] - mod);\n\t\t\t}\n\t\t}\n\t}\n\tcout << f[n + 1][0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 3000 + 5\n#define Mod 1000000007\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nchar s[N];\nint n, m, tot, L, R, r[N], sum[N], dp[N][N];\nint read(){\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while(c > '9' || c < '0'){ if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b){\n    return (a += b) >= Mod ? a - Mod : a;\n}\nint main(){\n    n = read(), m = read(), scanf(\"%s\", s + 1);\n    rep(i, 1, n) sum[i] = sum[i - 1] + s[i] - '0';\n    rep(i, 1, m) L = read(), R = read(), r[L] = max(r[L], R);\n    dp[0][0] = 1, R = 0;\n    rep(i, 1, n){\n        int D = 0; if(r[i] > R) D = sum[r[i]] - sum[R];\n        R = max(R, max(r[i], i));\n        rep(j, max(D - 1, 0), R - i){\n            if(j >= D) dp[i][j] = Inc(dp[i][j], dp[i - 1][j - D]);\n            dp[i][j] = Inc(dp[i][j], dp[i - 1][j - D + 1]);\n        }   \n    } \n    printf(\"%d\", dp[n][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\tvector<ll> s(N + 1);\n\trepn(i, N) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ts[i] = c - '0';\n\t}\n\n\tvector<ll> l(M + 1, 0), r(M + 1, 0);\n\trepn(i, M) cin >> l[i] >> r[i];\n\n\tvector<ll> rx(M + 1, 0);\n\trepn(i, M) rx[i] = max(rx[i - 1], r[i]);\n\n\tvector<vector<ll>> c(2, vector<ll>(N + 1, 0));\n\trepn(i, N) {\n\t\trep(j, 2) {\n\t\t\tif (s[i] == j) { c[j][i] = c[j][i - 1] + 1; }\n\t\t\telse { c[j][i] = c[j][i - 1]; }\n\t\t}\n\t}\n\n\tvector<vector<mint>> dp(N + 1, vector<mint>(N + 1, 0));\n\tdp[0][0] = 1;\n\n\trep(i, N+1)rep(j, N+1) {\n\t\tll k = i + j;\n\t\tif (k > N) { continue; }\n\t\tif (i == 0 && j == 0) { continue; }\n\n\t\tauto itr = upper_bound(l.begin(), l.end(), k);\n\t\tll t = distance(l.begin(), itr) - 1;\n\n\t\tll x = max(k, rx[t]);\n\t\n\t\tif (c[0][x] >= i && c[1][x] >= j) {\n\t\t\tif (i == 0) { dp[i][j] = dp[i][j - 1]; }\n\t\t\telse if (j == 0) { dp[i][j] = dp[i - 1][j]; }\n\t\t\telse { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; }\n\t\t}\n\t\telse { dp[i][j] = 0; }\n\n\t\t//cout << i << j << \" \"<<t<<\" \"<<  dp[i][j] << endl;\n\t}\n\n\tmint ans = 0;\n\t\n\trep(i, N + 1) {\n\t\tans += dp[i][N - i];\n\t}\n\tcout << ans << endl;\n\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n \nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n \nusing namespace std;\nconst int N=1e5+10,mod=1e9+7;\nchar s[N];\nint n,m,ans,fac[N],ifac[N],l[N],r[N],lb[N],rb[N],f[2][N],a[N];\n\nint inv(int x)\n{\n    return x>1? 1ll*(mod-mod/x)*inv(mod%x)%mod:1;\n}\n\nint c(int n,int m)\n{\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n \nint main()\n{\n    n=get(),m=get();\n    fac[0]=1;\n    rep(i,1,n)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=inv(fac[n]);\n    repd(i,n,1)\n        ifac[i-1]=1ll*ifac[i]*i%mod;\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        static int *f=::f[0],*g=::f[1];\n        swap(f,g);\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        lb[i]=max(0,lb[i-1]+w-s),rb[i]=min(mx,rb[i-1]+w);\n        rep(j,lb[i],rb[i])\n            rep(k,lb[i-1],rb[i-1])\n                f[j]=(f[j]+1ll*g[k]*c(s,k+w-j))%mod;\n        memset(g+lb[i-1],0,sizeof(int)*(rb[i-1]-lb[i-1]+1));\n    }\n    rep(i,0,n)\n        ans=(ans+f[m&1][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\nconst int maxn = 3005;\nconst int mo = 1e9 + 7;\nusing namespace std;\nint f[2][maxn], s[maxn], Max[maxn];\nint n, m;\nint main(){\n\tscanf(\"%d%d\", &n, &m); getchar();\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + getchar() - '0';\n\tfor (int l, r, i = 1; i <= m; i++){\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tMax[l] = max(Max[l], r);\n\t}\n\tfor (int i = 1; i <= n; i++) Max[i] = max(i, max(Max[i], Max[i - 1]));\n\tf[0][0] = 1; int T = 1;\n\tfor (int i = 1; i <= n; T ^= 1, i++){\n\t\tmemset(f[T], 0, sizeof f[T]);\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tif (j - 1 + s[Max[i]] - s[Max[i - 1]] >= 0) (f[T][j - 1 + s[Max[i]] - s[Max[i - 1]]] += f[T ^ 1][j]) %= mo;\n\t\t\tif (j + s[Max[i]] - s[Max[i - 1]] < Max[i] - (i - 1)) (f[T][j + s[Max[i]] - s[Max[i - 1]]] += f[T ^ 1][j]) %= mo;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[T ^ 1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\nll mod = inf;\nll dp[3001][3001];\nll pt[3001][3001];\nll nm[3001];\nvector<pair<int,int> > v;\n\nvoid init(){\n    for(int i=0;i<3001;i++){\n        pt[i][0] = 1;\n        pt[i][i] = 1;\n    }\n    for(int i=2;i<3001;i++){\n        for(int j=1;j<i;j++){\n            pt[i][j] = (pt[i-1][j-1] + pt[i-1][j])%mod;\n        }\n    }\n    return;\n}\n\n\nll saiki(int i,int s){\n    if(dp[i][s]!=0)return dp[i][s];\n    if(i==v.size()-1){\n        return pt[v[i].second-v[i].first+1][s+nm[i]];\n    }\n    ll ans = 0;\n    int tmp = s+nm[i];\n    if(v[i].second < v[i+1].first){\n        return dp[i][s] = (pt[v[i].second-v[i].first+1][tmp]*saiki(i+1,0))%mod;\n    }else{\n        for(int j=max(0,tmp-(v[i].second-v[i+1].first+1));j<=min(tmp,v[i+1].first-v[i].first);j++){\n            ans = (ans + (pt[v[i+1].first-v[i].first][j] * saiki(i+1,tmp-j))%mod ) %mod;\n        }\n    }\n    return dp[i][s] = ans;\n}\n\n\n\n\n\nint main(){\n    init();\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    int l,r;\n    cin >> l >> r;\n    v.PB(MP(l,r));\n    for(int i=0;i<m-1;i++){\n        cin >> l >> r;\n        if(v[v.size()-1].first==l){\n            if(r>v[v.size()-1].second){\n                v[v.size()-1].second =r;\n            }\n        }else{\n            if(r>v[v.size()-1].second){\n                v.PB(MP(l,r));\n            }\n        }\n    }\n    // for(int i=0;i<v.size();i++){\n    //     cout << v[i].first << \" \" <<v[i].second << endl;\n    // }\n    for(int i=1;i<v.size();i++){\n        int tmp = 0;\n        if(v[i].first>v[i].second){\n            for(int j=v[i].first;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }else{\n            for(int j=v[i-1].second+1;j<=v[i].second;j++){\n                if(s[j-1]=='1'){\n                    tmp++;\n                }\n            }\n        }\n        nm[i] = tmp;\n    }\n    int tmp = 0;\n    for(int i=v[0].first;i<=v[0].second;i++){\n        if(s[i-1]=='1'){\n            tmp++;\n        }\n    }\n    if(v.size()==1){\n        cout << pt[v[0].second-v[0].first+1][tmp] << endl;\n        return 0;\n    }\n    ll ans = 0;\n    if(v[0].second <v[1].first){\n        ans = (pt[v[0].second-v[0].first][tmp]*saiki(1,0))%mod;\n    }else{\n        for(int i=max(0,tmp-(v[0].second-v[1].first+1));i<=min(tmp,v[1].first-v[0].first);i++){\n            ans = (ans + (pt[v[1].first-v[0].first][i] * saiki(1,tmp-i))%mod ) %mod;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 3010;\nconst int mod = 1000000007;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nchar buf[MAXN];\nint rs[MAXN], n, m;\nint pre[MAXN];\nint f[MAXN][MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n >> m >> buf + 1;\n\tfor (int i = 1; i <= n + 1; ++i) rs[i] = i;\n\tfor (int i = 1, a, b; i <= m; ++i)\n\t\tstd::cin >> a >> b, rs[a] = std::max(rs[a], b);\n\tfor (int i = 1; i <= n; ++i) rs[i] = std::max(rs[i], rs[i - 1]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tpre[i] = pre[i - 1] + (buf[i] & 1);\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j <= n; ++j) if (int t = f[i - 1][j]) {\n\t\t\tint hav = j + pre[rs[i]] - pre[rs[i - 1]];\n\t\t\treduce(f[i][hav] += t - mod);\n\t\t\tif (hav) reduce(f[i][hav - 1] += t - mod);\n\t\t}\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tif (rs[i] - i - j < 0) f[i][j] = 0;\n\t}\n\tstd::cout << f[n][0] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid read(int &x) {\n\tchar ch; bool ok;\n\tfor(ok=0,ch=getchar(); !isdigit(ch); ch=getchar()) if(ch=='-') ok=1;\n\tfor(x=0; isdigit(ch); x=x*10+ch-'0',ch=getchar()); if(ok) x=-x;\n}\n#define rg register\nconst int maxn=3010,mod=1e9+7;\nchar ch[maxn];\nint n,m,f[maxn][maxn],tot,sum[maxn],las[maxn];\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint main()\n{\n\tread(n),read(m);scanf(\"%s\",ch+1);\n\tfor(rg int i=1;i<=n+1;i++){\n\t\tsum[i]=sum[i-1],las[i]=i;\n\t\tif(ch[i]=='1')tot++,sum[i]++;\n\t}\n\tfor(rg int i=1,x,y;i<=m;i++)read(x),read(y),las[x]=max(las[x],y);\n\tfor(rg int i=1;i<=n+1;i++)las[i]=max(las[i],las[i-1]);\n\tf[1][sum[las[1]]]=1;\n\tfor(rg int i=1;i<=n;i++)\n\t\tfor(rg int j=0;j<=tot;j++)\n\t\t\tif(f[i][j]){\n\t\t\t\tint a=las[i],b=las[i+1];\n\t\t\t\tif(j)f[i+1][j+sum[b]-sum[a]-1]=add(f[i+1][j+sum[b]-sum[a]-1],f[i][j]);\n\t\t\t\tif(las[i]+1-i-j)f[i+1][j+sum[b]-sum[a]]=(f[i+1][j+sum[b]-sum[a]],f[i][j]);\n\t\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<map>\nusing namespace std;\ntypedef long long int llint;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\nconst int mod=1000000007;\nconst llint big=1e18+10;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-9;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}//a>b\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD> &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD> &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD> &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD> &other) noexcept\n\t{a += other.a;if (MOD <= a) { a -= MOD; };return *this;}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD> &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + MOD) - other.a;}return *this;}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD> &other) noexcept\n\t{a *= other.a;a %= MOD;return *this;}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{return{ MOD - a, mod_value_tag{} };}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{if (MOD <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{if (a <= 0) { a = MOD; };--a;return *this;}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD> &other) noexcept\n\t{a = other.a;return *this;}\n\tconstexpr operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return MOD;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{os << (uint64_t)i;return os;}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{uint64_t tmp;is >> tmp;i = tmp;return is;}\n\nint main(void){\n\tint i,j,k,n,m;cin>>n>>m;\n\tstring str;cin>>str;\n\tvector<mint_base<mod>>ans(n+1);//1を持つ数\n\tans[0]=1;\n\tvector<int>doco(n);//どこまでのものをとれるか\n\tvector<int>ika(n);//1の数\n\tvector<int>oka(n);//0の数\n\tfor(i=0;i<m;i++){\n\t\tint l,r;cin>>l>>r;l--;r--;\n\t\tmaxeq(doco[l],r);\n\t}\n\tfor(i=1;i<n;i++){\n\t\tmaxeq(doco[i],doco[i-1]);\n\t\tmaxeq(doco[i],i);\n\t}\n\tint iwa=0,owa=0;\n\tfor(i=0;i<n;i++){\n\t\tif(str[i]=='1'){iwa++;}else{owa++;}\n\t\tika[i]=iwa;\n\t\toka[i]=owa;\n\t}\n\tfor(i=0;i<n;i++){ika[i]=ika[doco[i]],oka[i]=oka[doco[i]];}\n\tvector<mint_base<mod>>dp(n+1);\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n+1;j++){dp[j]=0;}\n\t\tfor(j=max(0,i+1-oka[i]);j<=min(n,ika[i]);j++){\n\t\t\tif(j!=0){dp[j]=ans[j-1]+ans[j];}\n\t\t\telse{dp[j]=ans[j];}\n\t\t}\n\t\tswap(dp,ans);\n\t}\n\tcout<<ans[ika[n-1]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i] - 1) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nconst int BIT_MAX = 3333;\n\ntemplate <class T> class BIT{\n\tT x[BIT_MAX + 1];\n\t\npublic:\n\t\n\tvoid dft(){\n\t\tfill(x,x+BIT_MAX+1,0);\n\t}\n\t\n\tvoid add(int a , T b){\n\t\t++a;\n\t\tfor(; a <= BIT_MAX ; a += a & -a) x[a] += b;\n\t}\n\t\n\tT get(int a){\n\t\t++a;\n\t\tT b = 0;\n\t\tfor(; a > 0 ; a -= a & -a) b += x[a];\n\t\treturn b;\n\t}\n};\n\nint N,M;\nchar s[3333];\nBIT<int> bit[3333];\nint p[3333];\nlong long dp[3333][3333];\nconst int mod = 1e9 + 7;\n\nint main(){\n\tscanf(\"%d%d %s\" , &N , &M , s);\n\tint x = 0;\n\tbit[0].add(0,1);\n\tbit[0].add(1,-1);\n\tp[0] = 0;\n\trepp(i,0,N){\n\t\tif(s[i] == '1') ++x;\n\t\tbit[i+1].add(x,1);\n\t\tbit[i+1].add(x+1,-1);\n\t\tp[i+1] = x;\n\t}\n\tint r = 0;\n\trepp(i,0,M){\n\t\tint x , y;\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tif(r >= y) continue;\n\t\t--x;\n\t\tint b = 0;\n\t\twhile(bit[x].get(b) == 0) ++b;\n\t\tint e = b + 1;\n\t\twhile(bit[x].get(e) > 0) ++e;\n\t\trepp(j,x+1,y){\n\t\t\tif(j + p[y] - b > y) ++b;\n\t\t\tif(p[y] >= e) ++e;\n\t\t\tbit[j].add(b,1);\n\t\t\tbit[j].add(e,-1);\n\t\t}\n\t\tr = y;\n\t}\n\tdp[0][0] = 1;\n\trepp(i,1,N+1){\n\t\trepp(j,0,p[N]+1){\n\t\t\tif(bit[i].get(j) > 0){\n\t\t\t\tdp[i][j] = (dp[i-1][j] + (j > 0 ? dp[i-1][j-1] : 0)) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\" , dp[N][p[N]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nconst int Max_N(3050);\nconst int MOD(1000000007);\nconst int Add(3010);\ntypedef long long int LL;\n\ninline int Mult(const int &a, const int &b)\n{\n\treturn static_cast<int>(static_cast<LL>(a) * static_cast<LL>(b) % static_cast<LL>(MOD));\n}\n\ninline void update(int &a, const int &b)\n{\n\t((a += b) >= MOD) ? (a -= MOD) : 0;\n}\n\nstruct node\n{\n\tint l, r;\n\tvoid give(const int &_l, const int &_r)\n\t{\n\t\tl = _l, r = _r;\n\t}\n};\nint N, M, S0[Max_N][Max_N], S1[Max_N][Max_N], C[Max_N][Max_N], R[Max_N], Pre[Max_N];\nchar S[Max_N];\nnode V[Max_N];\n\nvoid init()\n{\n\tGet_Val(N), Get_Val(M);\n\tC[0][0] = 1;\n\tfor (int i = 1;i <= N;++i)\n\t{\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1;j < i;++j)\n\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n\t}\n\tscanf(\"%s\", S + 1);\n\tfor (int i = 0;i <= N;++i)\n\t{\n\t\tS0[i][i] = (S[i] == '0');\n\t\tS1[i][i] = (S[i] == '1');\n\t\tfor (int j = i + 1;j <= N;++j)\n\t\t{\n\t\t\tS0[i][j] = S0[i][j - 1] + (S[j] == '0');\n\t\t\tS1[i][j] = S1[i][j - 1] + (S[j] == '1');\n\t\t}\n\t}\n\tfor (int i = 1, l, r;i <= M;++i)\n\t{\n\t\tGet_Val(l), Get_Val(r);\n\t\tR[l] = max(R[l], r);\n\t}\n\tM = 0;\n\tfor (int i = 1, Max = 0;i <= N;++i)\n\t\tif (R[i] > Max)\n\t\t\tV[++M].give(i, Max = R[i]);\n}\n\nint F[Max_N][Max_N << 1];\nvoid dp()\n{\n\t//首先去除所有被包含的区间\n\t//考虑两个相交的区间[l1, r1]和[l2, r2]，满足l1 < l2 <= r1 < r2\n\t//等价于可以把[l1, l2 - 1]乱排，并将[l1, l2 - 1]中的1/0与[l2, r1]中的0/1交换\n\t//根据此dp，F[i][j]表示dp到第i个区间，多了j个1\n\tF[0][0 + Add] = 1;\n\tfor (int i = 0;i <= M - 1;++i)\n\t\tif (V[i].r < V[i + 1].l)//不相交 \n\t\t{\n\t\t\tfor (int j = -S1[V[i].l][V[i].r];j <= S0[V[i].l][V[i].r];++j)\n\t\t\t\tupdate(F[i + 1][0 + Add], Mult(F[i][j + Add], C[V[i].r - V[i].l + 1][S1[V[i].l][V[i].r] + j]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = -S1[V[i].l][V[i].r], s1, s0;j <= S0[V[i].l][V[i].r];++j)\n\t\t\t{\n\t\t \t\ts1 = S1[V[i].l][V[i].r] + j;\n\t\t \t\ts0 = (V[i].r - V[i].l + 1) - s1;\n\t\t \t\tfor (int k = max(-s0, -S1[V[i + 1].l][V[i].r]);k <= min(s1, S0[V[i + 1].l][V[i].r]);++k)\n\t\t \t\t\tupdate(F[i + 1][k + Add], Mult(F[i][j + Add], C[V[i + 1].l - V[i].l][s1 - (S1[V[i + 1].l][V[i].r] + k)]));\n\t\t\t}\n\t\t}\n\tint Ans(0);\n\tfor (int j = -S1[V[M].l][V[M].r];j <= S0[V[M].l][V[M].r];++j)\n\t\tupdate(Ans, Mult(F[M][j + Add], C[V[M].r - V[M].l + 1][S1[V[M].l][V[M].r] + j]));\n\tprintf(\"%d\", Ans);\n}\n\nint main()\n{\n\tinit();\n\tdp();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=3e3;\nconst long long Mod=1e9+7;\nint n,m,f[Max+10][Max+10]={},c[Max+10][Max+10]={},b[Max+10]={},l[Max+10]={},r[Max+10]={};\nstruct kk{\n    int l,r,v;\n} e[Max+10]={};\nchar a[Max+10]={};\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",a+1);\n    for(int i=1;i<=n;i++)\n     b[i]=b[i-1]+(a[i]=='1');\n    c[0][0]=c[0][1]=c[1][1]=1;\n    for(int i=2;i<=Max;i++){\n        c[0][i]=c[i][i]=1;\n        for(int j=1;j<i;j++)\n         c[j][i]=(c[j-1][i-1]+c[j][i-1])%Mod;\n    }\n    int Max=0;\n    for(int i=1;i<=m;i++) {\n        scanf(\"%d%d\",&e[i].l,&e[i].r);\n    }\n    for(int i=1;i<=m;i++)\n     for(int j=1;j<=m;j++)\n      if(i!=j&&e[j].l>=e[i].l&&e[j].r<=e[i].r&&!e[i].v) e[j].v=1;\n    int s=0;\n    for(int i=1;i<=m;i++)\n     if(!e[i].v) ++s,l[s]=e[i].l,r[s]=e[i].r;\n    m=s;\n    f[0][0]=1;\n    for(int i=1;i<m;i++){\n        if(l[i+1]>r[i]){\n            for(int j=0;j<=n;j++)\n             f[i][0]+=f[i-1][j]*c[j+b[r[i]]-b[max(r[i-1],l[i]-1)]][r[i]-l[i]+1]%Mod,f[i][0]%=Mod;\n        }else{\n            for(int j=0;j<=r[i]-l[i+1]+1;j++)\n             for(int k=0;k<=n;k++)\n              if(k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j>=0){\n                f[i][j]+=f[i-1][k]*c[k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j][l[i+1]-l[i]]%Mod,f[i][j]%=Mod;\n              }\n        }\n    }    \n    int ans=0; \n     for(int i=0;i<=n;i++)\n      ans+=f[m-1][i]*c[i+b[r[m]]-b[max(r[m-1],l[m]-1)]][r[m]-l[m]+1]%Mod,ans%=Mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  /*bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };*/\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[3331][3333];\nint l[3331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[3331];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v[2];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(int n,int m)\n{\n  if(n>a) return 1;\n  //if(m>u[l[n]].y-n+1) return 0;\n  if(o[n][m]>=0) return o[n][m];\n  if(o[n]==0) return f(n+1,m);\n  long long k=0;\n  if(l[n+1]==0)\n  {\n    k=f(n+1,m);\n  }\n  else if(l[n+1]!=l[n])\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m+j[u[l[n+1]].y]-j[u[l[n]].y]);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1+j[u[l[n+1]].y]-j[u[l[n]].y]))%mod;\n  }\n  else\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1))%mod;\n  }\n  return o[n][m]=k;\n}\n\nint main()\n{\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  scanf(\"%s\",r+1);\n  for(int t=1;t<=a;j[t]+=j[t-1],t++)\n  if(r[t]=='1') j[t]=1;\n  for(int t=1;t<=b;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    if(u[c].x==n) u[c].y=max(u[c].y,m);\n    else if(u[c].y<m)\n    {\n      c++;\n      u[c]={n,m};\n    }\n  }\n  u[0].x=1;\n  for(int t=1;t<=c;t++)\n  {\n    for(int i=u[t].x;i<=u[t].y;i++)\n      l[i]=t;\n  }\n  printf(\"%lld\",f(u[1].x,j[u[1].y]-j[u[1].x-1]));\n}\n//3\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 1 << 20;\n\nint n, m, f[N], g[N], r[N], L[N], R[N], tot[N], dp[1 << 12][1 << 12], ones[N], A[N], B[N], C[N];\nchar a[N];\npair<int, int> p[N];\n\ninline int calc_ones(int st, int en) {\n\tif (st == 0) return ones[en];\n\treturn ones[en] - ones[st - 1];\n}\n\ninline int nCm(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn (long long)f[n] * g[m] % mod * g[n - m] % mod;\n}\n\nnamespace FFT {\n\tconst int M = 1<<18;\n\n\tusing DB = long double;\n\tusing LL = long long;\n\n\tstruct CP {\n\t\tDB x, y;\n\t\tCP(DB x=0, DB y=0) : x(x), y(y) {}\n\t\tCP operator+(const CP &rhs) const {\n\t\t\treturn CP(x+rhs.x, y+rhs.y);\n\t\t}\n\t\tvoid operator+=(const CP &rhs) {\n\t\t\tx += rhs.x, y += rhs.y;\n\t\t}\n\t\tCP operator-(const CP &rhs) const {\n\t\t\treturn CP(x-rhs.x, y-rhs.y);\n\t\t}\n\t\tCP operator*(const CP &rhs) const {\n\t\t\treturn CP(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);\n\t\t}\n\t\tCP operator!() const {\n\t\t\treturn (CP) {\n\t\t\t\tx, -y\n\t\t\t};\n\t\t}\n\t\tvoid operator*=(const CP &rhs) {\n\t\t\tDB tx = x*rhs.x-y*rhs.y, ty = x*rhs.y+y*rhs.x;\n\t\t\tx = tx, y = ty;\n\t\t}\n\t} f[M], g[M], h[M], p_w[M+1];\n\n\tint bit_inv[M];\n\n\tvoid init() {\n\t\tDB alpha = acos(-1)/M*2;\n\t\tfor (int i = 0; i <= M; i++) p_w[i] = CP(cos(alpha*i), sin(alpha*i));\n\t\tfor (int i = 0, j = 1; j < M; j++) {\n\t\t\tfor (int k = M >> 1; (i ^= k) < k; k >>= 1);\n\t\t\tbit_inv[j] = i;\n\t\t}\n\t}\n\n\tvoid FFT(CP *A, int N, int D = 1) {\n\t\tfor (int j = 1, i, d = __builtin_ctz(M/N); j < N-1; j++) if ((i = (bit_inv[j] >> d)) < j) swap(A[i], A[j]);\n\t\tfor (int n = 1, m = M/2*D; n < N; m /= 2, n <<= 1) {\n\t\t\tfor (int i = 0; i < N; i += n<<1) {\n\t\t\t\tCP *w = (D == 1 ? p_w : p_w + M), *a = A+i, *b = A+i+n;\n\t\t\t\tfor (int j = 0; j < n; j++, a++, b++, w += m) {\n\t\t\t\t\tCP x = *w **b;\n\t\t\t\t\t*b = *a - x;\n\t\t\t\t\t*a += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D != 1) for (int i = 0; i < N; i++) A[i].x /= N, A[i].y /= N;\n\t}\n\n\tvoid conv(int *A, int *B, int *C, int N, int MOD) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t}\n\t\t\tmemcpy(C, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) g[i] = CP(B[i]>>15, B[i]&32767);\n\t\tFFT(g, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=((f[i]+!f[j])*(!g[j]-g[i])+(!f[j]-f[i])*(g[i]+!g[j]))*CP(0,0.25);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (LL(h[i].x+0.5)%MOD<<15)%MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=(!f[j]-f[i])*(!g[j]-g[i])*CP(-0.25, 0)+CP(0, 0.25)*(f[i]+!f[j])*(g[i]+!g[j]);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (C[i] + LL(h[i].x+0.5)+((LL(h[i].y+0.5)%MOD)<<30)) % MOD;\n\t}\n\n\tvoid conv(int *A, int *B, int N, int P) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * A[j]) % P;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * A[j]) % P;\n\t\t\t}\n\t\t\tmemcpy(B, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=((!(f[j]*f[j]))-f[i]*f[i])*CP(0,0.5);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (LL(g[i].x+0.5)%P<<15)%P;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=(!f[j]-f[i])*(!f[j]-f[i])*CP(-0.25,0)+CP(0,0.25)*(f[i]+!f[j])*(f[i]+!f[j]);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (B[i] + LL(g[i].x+0.5)+((LL(g[i].y+0.5)%P)<<30)) % P;\n\t}\n};\n\nint solve(int st, int en) {\n\tfor (int i = st; i <= en; i++) {\n\t\tint common = 0;\n\t\tif (i < en) common = p[i].second - p[i + 1].first + 1;\n\t\tR[i] = min(p[i].second - p[st].first + 1 - common, calc_ones(p[st].first, p[i].second));\n\t\tL[i] = max(0, R[i] - common);\n\t\ttot[i] = p[i].second - p[i].first + 1 - common;\n\t}\n\tfor (int i = st; i <= en; i++) {\n\t\tif (i == st) {\n\t\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = nCm(tot[i], j);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) A[k] = dp[i - 1][k];\n\t\tfor (int k = 0; k < n; k++) B[k] = nCm(tot[i], k);\n\t\tFFT::conv(A, B, C, 1 << (32 - __builtin_clz(n + n - 1)), mod);\n\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = C[j];\n//\t\t{\n//\t\t\tfor (int k = L[i - 1]; k <= R[i - 1]; k++) {\n//\t\t\t\tdp[i][j] = (dp[i][j] + (long long)dp[i - 1][k] * nCm(tot[i], j - k)) % mod;\n//\t\t\t}\n//\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = L[en]; i <= R[en]; i++) ret = (ret + dp[en][i]) % mod;\n\treturn ret;\n}\n\nint main() {\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tFFT::init();\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tf[0] = r[0] = r[1] = g[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) f[i] = (long long)f[i - 1] * i % mod;\n\t\tif (i > 1) r[i] = (long long)(mod - mod / i) * r[mod % i] % mod;\n\t\tif (i) g[i] = (long long)g[i - 1] * r[i] % mod;\n\t}\n//\tint ans = 0;\n//\tfor (int a = 2; a <= 3; a++) {\n//\t\tfor (int b = 4 - a; b <= 5 - a; b++) {\n//\t\t\tint c = 7 - a - b;\n//\t\t\tans += nCm(3, a) * nCm(2, b) * nCm(4, c);\n//\t\t}\n//\t}\n//\tcout << ans << endl;\n\tcin >> n >> m >> a;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) ones[i] = ones[i - 1];\n\t\tif (a[i] == '1') ones[i]++;\n\t}\n\tvector<pair<int, int>> vec;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> p[i].first >> p[i].second;\n\t\tp[i].first--;\n\t\tp[i].second--;\n\t\tif (i && p[i].second <= p[i - 1].second) continue;\n\t\tvec.push_back(p[i]);\n\t}\n\tm = vec.size();\n\tfor (int i = 0; i < m; i++) p[i] = vec[i];\n\tcout << solve(0, m - 1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=3000+10,mo=1000000007;\nint f[maxn][maxn],right[maxn],sum[maxn];\nint i,j,k,l,r,t,n,m,ans,one,zero;\nchar get(){\n    char ch=getchar();\n    while (ch!='0'&&ch!='1') ch=getchar();\n    return ch;\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    fo(i,1,n) sum[i]=get()-'0';\n    fo(i,1,n+1) sum[i]+=sum[i-1];\n    fo(i,1,n+1) right[i]=i;\n    fo(i,1,m){\n        scanf(\"%d%d\",&j,&k);\n        right[j]=max(right[j],k);\n    }\n    fo(i,1,n) right[i]=max(right[i],right[i-1]);\n    f[1][sum[right[1]]]=1;\n    fo(i,1,n)\n        fo(j,0,n)\n            if (f[i][j]){\n                l=right[i]+1;r=right[i+1];\n                one=j;zero=right[i]-i+1-j;\n                if (zero) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n                if (one) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n            }\n    ans=f[n+1][0];\n    (ans+=mo)%=mo;\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=3005;\nconst int mod=1000000007;\n\nstruct node{\n\tint l,r;\n\tnode(){}\n\tnode(int l,int r):l(l),r(r){}\n}a[N];\nint n,Q,m,L,R,l,r,x;\nint c[N][N],sum[N],dp[N][N];\nchar s[N];\n\nvoid init(int n){\n\tint i,j;\n\tc[0][0]=1;\n\tfor (i=1;i<=n;i++){\n\t\tc[i][0]=1;\n\t\tfor (j=1;j<=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n}\n\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&Q);\n\tscanf(\"%s\",s+1);\n\tinit(n);\n\tfor (i=1;i<=Q;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif (r<=R) continue;\n\t\tif (L==l) R=max(R,r);\n\t\telse{\n\t\t\ta[++m]=node(l,r);\n\t\t\tL=l; R=r;\n\t\t}\n\t}\n\tfor (i=1;i<=n;i++) sum[i]=sum[i-1]+(s[i]=='1');\n\ta[m+1].l=n+1;\n\tdp[0][sum[a[1].l-1]]=1;\n\tfor (i=1;i<=m;i++){\n\t\tL=a[i].l; R=a[i].r; l=a[i+1].l;\n\t\tif (l>R){\n\t\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\t\tx=sum[R]-j;\n\t\t\t\t(dp[i][sum[l-1]]+=1ll*dp[i-1][j]*c[R-L+1][x]%mod)%=mod;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=0;j<=n;j++) if (dp[i-1][j]){\n\t\t\tx=sum[R]-j;\n\t\t\tfor (k=x-R+l-1;k<=min(l-L,x);k++)\n\t\t\t\t(dp[i][j+k]+=1ll*dp[i-1][j]*c[l-L][k]%mod)%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[m][sum[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nconst int N=100000;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u];i;i=sq[i].nxt)\n#define fir first\n#define sec second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define maxd 1000000007\n#define eps 1e-8\nint n,m,R[3030],sum[3030];\nll f[3030][6060];\nchar s[3030];\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint main()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",s+1);\n\trep(i,1,n+1) sum[i]=sum[i-1]+(s[i]=='1');\n\trep(i,1,n+1) R[i]=i;\n\trep(i,1,m)\n\t{\n\t\tint l=read(),r=read();\n\t\tR[l]=max(R[l],r);\n\t}\n\trep(i,1,n) R[i]=max(R[i],R[i-1]);\n\tf[1][sum[R[1]]]=1;\n\trep(i,1,n)\n\t{\n\t\trep(j,0,n)\n\t\t{\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\tint l=R[i]+1,r=R[i+1],add=sum[r]-sum[l-1];\n\t\t\t\tif (j) f[i+1][j+add-1]=(f[i+1][j+add-1]+f[i][j])%maxd;\n\t\t\t\tif (R[i]-i+1>j) f[i+1][j+add]=(f[i+1][j+add]+f[i][j])%maxd;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n+1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int N = 3005;\nint n, m;\nint mx[N], mn[N];\nint dp[N][N];\nstring s;\n\nsigned main()\n{\n\tint cnt = 0;\n\tcin >> n >> m;\n\tcin >> s;\n\ts = \"a\" + s;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcnt += (s[i] == '1');\n\t\tmn[i] = cnt,\n\t\tmx[i] = cnt;\n\t}\n\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tint tmp1 = mn[r] - mn[l - 1],\n\t\t\ttmp2 = mx[r] - mx[l - 1];\n\n\t\tfor(int j = l; j <= r; j++)\n\t\t{\n\t\t\tmn[j] = min(mn[j], mn[l - 1] + max(0LL, tmp1 - r + j));\n\t\t\tmx[j] = max(mx[j], mx[l - 1] + min(j - l + 1, tmp2));\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = mn[i]; j <= mx[i]; j++)\n\t\t{\n\t\t\tif(j > 0)\n\t\t\t \tdp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];\n\t\t\t else\n\t\t\t \tdp[i][j] = dp[i - 1][j];\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t\t\n\t}\n\tcout << dp[n][cnt];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 3009\nusing namespace std;\nstruct node{ \n\tint l, r;\n\tbool operator < (const node &rhs) const{ \n\t\treturn (l < rhs.l) || (l == rhs.l && r > rhs.r);\n\t}\n}a[maxn];\nint n, m, dp[maxn][maxn], C[maxn][maxn], sum[maxn];\nchar s[maxn];\nconst int MOD = 1e9 + 7;\n\nbool in(int L, int R, int x){\n\treturn L <= x && x <= R;\n}\nlong long solve(int L ,int R){\n\tif(L == R){\n\t\treturn C[R - L + 1][sum[R] - sum[L - 1]];\n\t}\n\n\tfor(int i = 0; i <= sum[a[L].r] - sum[a[L].l - 1]; i++){\n\t\tint part1 = a[L + 1].l - a[L].l;\n\t\tint part2 = a[L].r - a[L].l + 1 - part1;\n\t\tif(i > part2) \n\t\t\tbreak;\n\t\tdp[L][i] = C[part1][sum[a[L].r] - sum[a[L].l - 1] - i];\n\t}\n\n\n\tfor(int i = L + 1; i < R; i++){\n\t\tint part1 = a[i + 1].l - a[i].l;\n\t\tint part2 = a[i].r - a[i].l + 1 - part1;\n\t\tint one = sum[a[i].r] - sum[a[i - 1].r];\n\n\t\tfor(int j = 0; j <= part2; j++){\n\t\t\tfor(int k = max(0, j - one) ; k <= part1 + j - one; k++)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1LL * C[part1][k + one - j] * dp[i - 1][k]) % MOD;\n\t\t}\n\t}\n\n\tint last1 = a[R - 1].r - a[R].l + 1;\n\tint one = sum[a[R].r] - sum[a[R - 1].r];\n\n\tlong long ans = 0;\n\tfor(int k = 0; k <= last1; k++)\n\t\tans = (ans + 1LL * dp[R - 1][k] * C[a[R].r - a[R].l + 1][one + k]) % MOD;\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tscanf(\"%s\", s + 1);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + (s[i] == '1');\n\n\tfor(int i = 0; i <= n; i++){\n\t\tC[i][i] = C[i][0] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n\n\tfor(int i = 1; i <= m; i++){\n\t\tscanf(\"%d%d\", &a[i].l, &a[i].r);\n\t}\n\tsort(a + 1, a + 1 + m);\n\n\tint tot = 0, last = -1;\n\tfor(int i = 1; i <= m; i++){\n\t\tif(a[i].r <= last)\n\t\t\tcontinue;\n\t\t++tot;\n\t\ta[tot] = a[i];\n\t\tlast = a[i].r;\n\t}\n\n\tint cur = 1;\n\tlong long ans = 1;\n\twhile(cur <= tot){\n\t\tint L = cur;\n\t\twhile(cur + 1 <= tot && in(a[cur].l, a[cur].r, a[cur+1].l))\n\t\t\tcur++;\n\t\tint R = cur;\n\t\tans = ans * solve(L, R) % MOD;\n\t\tcur++;\n\t}\n\n\tcout<< ans << endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    int pos = -1;\n    dp[0][0] = 1;\n    queue<pair<int, int>> q;\n    rep (i, n) {\n        if (pos != n - 1) while (L[++pos] <= i) q.push({pos, s[pos] == '1'});\n        if (q.size()) while (R[q.front().first] < i) {\n            memo[q.front().second]++; q.pop();\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] %= mod, dp[j+1][i-j] %= mod;\n        }\n    }\n    // rep (i, 4) {\n    //     rep (j, 3) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // rep (i, n) cout << cnt[0][i] << \" \"; cout << endl;\n    // rep (i, n) cout << cnt[1][i] << \" \"; cout << endl;\n    int ans = 0;\n    rep (i, n + 1) {\n        ans += dp[i][n-i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint n, m, l[3009], r[3009], p[3009], dp[3009][3009], R, s[3009], t[3009], mod = 1000000007; bool used[3009]; string S;\nint main() {\n\tcin >> n >> m >> S; S = \"#\" + S;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (R >= r[i])continue;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (l[j] == l[i])used[j] = false;\n\t\t}\n\t\tR = r[i]; used[i] = true;\n\t}\n\tfor (int i = 0; i <= n; i++) { s[i] = -1; t[i] = 1e9; }\n\tint V = 1, W = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (used[i] == false)continue;\n\t\tif (W < l[i]) {\n\t\t\tint u = 0; for (int j = 1; j <= W; j++)u += (S[j] - '0');\n\t\t\ts[W] = u; t[W] = u;\n\t\t\tV = l[i];\n\t\t}\n\t\tint cnt = 0, u = 0; for (int j = 1; j < V; j++)cnt += (S[j] - '0');\n\t\tfor (int j = V; j <= W; j++)u += (S[j] - '0');\n\t\ts[l[i] - 1] = cnt + max(0, (l[i] - V) - max(0, ((W - V + 1) - u)));\n\t\tt[l[i] - 1] = cnt + min(l[i] - V, u);\n\t\tW = r[i];\n\t}\n\tint u = 0; for (int j = 1; j <= W; j++)u += (S[j] - '0');\n\ts[W] = u; t[W] = u;\n\n\tint X = 0; for (int i = 1; i <= n; i++)X += (S[i] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (!(s[i] <= j && j <= t[i])) { dp[i][j] = 0; continue; }\n\t\t\tdp[i + 1][j] += dp[i][j]; dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t}\n\t}\n\tcout << dp[n][X] % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,q; string s;\nvector<P>vec;\nll dp[3005][3005],C[3005][3005];\nint main(){\n    C[0][0]=1;\n    for(int i=1;i<3005;i++)for(int j=0;j<=i;j++){\n        if(j==0||j==i)C[i][j]=1LL;\n        else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    }\n\tcin>>n>>q>>s;\n\trep(i,q){\n\t\tint a,b;cin>>a>>b;\n\t\tif(vec.empty() || vec[vec.size()-1].sc<b){\n\t\t\tif(!vec.empty() && vec[vec.size()-1].fi == a){\n\t\t\t\tvec.pop_back();\n\t\t\t}\n\t\t\tvec.pb(mp(--a,--b));//cout<<vec[vec.size()-1].fi<<vec[vec.size()-1].sc<<endl;\n\t\t}\n\t}\n\tdp[0][0] =1LL;\n\tint sum = 0,nxt2 = 0;\n\tint S=0,T=0;\n\trep(i,vec.size()){\n\t\tint nxt = (i==vec.size()-1?vec[i].sc+1:min(vec[i].sc+1,vec[i+1].fi));\n\t\t//[vec[i].fi,nxt) wo kettei\n\t\tint S2 = 0,T2 = 0;\n\t\tfor(int ii=max(nxt2,vec[i].fi);ii<vec[i].sc+1;ii++){\n\t\t\tif(s[ii]=='0')S++;else T++;\n\t\t}\n\t\tfor(int ii=0;ii<=sum;ii++){\n\t\t\tif(dp[ii][sum-ii]==0LL)continue;\n\t\t\tint zan = S-ii,zan2 = T-(sum-ii); \n\t\t\tfor(int x=0;x<=nxt-vec[i].fi;x++){\n\t\t\t\tif(x>zan||(nxt-vec[i].fi-x)>zan2) continue;\n\t\t\t\tdp[ii+x][sum-ii+(nxt-vec[i].fi-x)] += dp[ii][sum-ii]*C[nxt-vec[i].fi][x]%mod;\n\t\t\t\twhile(dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]>=mod) dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]-=mod;\n\t\t\t}\n\t\t}\n\t\tsum += nxt-vec[i].fi; nxt2 = vec[i].sc+1;\n\t}\n\tll ret = 0;\n\trep(i,S+T) ret=(ret+dp[i][S+T-i])%mod; cout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nint n, m;\nstring s;\nint c[3000];\nll dp[3001][3001];\nint v[3000];\nint main() {\n\tcin >> n >> m >> s;\n\trep(i, n) {\n\t\tif (i > 0)c[i] = c[i - 1];\n\t\tif (s[i] == '1')c[i]++;\n\t}\n\tint ri = 0;\n\trep(i, n) {\n\t\tv[i] = i;\n\t}\n\trep(i, m) {\n\t\tint l, r; cin >> l >> r; l--; r--;\n\t\tv[l] = max(v[l], r);\n\t}\n\tdp[0][0] = 1;\n\trep(i, n) {\n\t\t\trep(j, i-1 - ri + c[ri]) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t\tRep(j, c[ri] + 1, i + 1) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\tri = max(ri, v[i]);\n\t\trep(j, i+1) {\n\t\t\t(dp[i + 1][j + 1] += dp[i][j]) %= mod;\n\t\t\t(dp[i + 1][j] += dp[i][j]) %= mod;\n\t\t}\n\t\t/*rep(j, i + 1) {\n\t\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}*/\n\t}\n\tcout << dp[n][c[n-1]] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=3030;\n\nconst int32_t M=1e9+7;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nmint fc[N],ifc[N];\nstruct pc{pc(){\n        fc[0]=1;\n        for(int i=1;i<N;++i)fc[i]=fc[i-1]*i;\n        ifc[N-1]=1/fc[N-1];\n        for(int i=N-2;i>=0;--i)ifc[i]=ifc[i+1]*(i+1);\n}}pc;\nmint bin(int n,int k){\n    if(k<0||k>n)return 0;\n    return fc[n]*ifc[k]*ifc[n-k];\n}\nmint dp[N],ndp[N];\nint p0[N]/*,p1[N]*/;\nint get0(int l,int r){return p0[r]-p0[l-1];}\n// int get1(int l,int r){return p1[r]-p1[l-1];}\nint32_t main(){\n    int n,q;\n    cin>>n>>q;\n    string s;\n    cin>>s;\n    s=\"#\"+s;\n    for(int i=1;i<=n;++i)p0[i]=p0[i-1]+(s[i]=='0');\n    int pl=-1,pm=-1,pr=-1,pmna=-1,pmxa=-1;\n    forn(t,q){\n        int l,r;\n        cin>>l>>r;\n        if(r<=pr)continue;\n        forn(i,n+1)ndp[i]=0;\n        // memset(ndp,0,sizeof ndp);\n        if(l>pr){\n            if(pl!=-1){\n                int len=pr-pl+1;\n                int b0=get0(pm+1,pr);\n                mint cur=0;\n                for(int a0=pmna;a0<=pmxa;++a0){\n                    cur+=bin(len,b0+a0)*dp[a0];\n                }\n                ndp[0]=cur;\n            }else{\n                ndp[0]=1;\n            }\n            pl=l,pm=l-1,pr=r,pmna=pmxa=0;\n        }else{\n            int m=pr;\n            int b0=get0(pm+1,pr);\n            for(int c0=0;c0<=m-l+1;++c0){\n                // dbg(c0,b0,l-pl);\n                for(int a0=pmna;a0<=pmxa;++a0){\n                    ndp[c0]+=bin(l-pl,a0+b0-c0)*dp[a0];\n                }\n            }\n            pl=l,pm=m,pr=r,pmna=0,pmxa=m-l+1;\n        }\n        memcpy(dp,ndp,sizeof dp);\n        // for(int i=pmna;i<=pmxa;++i){\n        //     dbg(dp[i]);\n        // }\n        // dbg(\"====\");\n    }\n    mint cur=0;\n    int len=pr-pl+1;\n    int b0=get0(pm+1,pr);\n    for(int a0=pmna;a0<=pmxa;++a0){\n        cur+=bin(len,b0+a0)*dp[a0];\n    }\n    cout<<cur<<'\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\t//if (l[i]<=r[i-1])\n\t\t//{\n\t\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(min(l[i+1],r[i]+1)-l[i],j-k))%mo;\n\t\t//}\n\t\t//else f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)x.size()\n#define f first\n#define s second\n#define MAXN 3010\nll MOD = 1e9+7;\n\nll A[MAXN];\nll N,K,a,b;\nll E[MAXN];\nstring S;\nvpi V;\nll memo[MAXN][MAXN];\nll overlap[MAXN];\nll fact[MAXN];\nll invfact[MAXN];\n\nll exp(ll a, ll b){\n\tif (b==0)return 1;\n\tll c = exp(a,b/2);\n\tc = (c*c)%MOD;\n\tif (b%2)c=(c*a)%MOD;\n\treturn c;\n}\n\nll inv(ll x){\n\treturn exp(x, MOD-2);\n}\n\nll C(ll a, ll b){\n\treturn ((fact[a] * invfact[a-b]) %MOD) * invfact[b]%MOD;\n}\n\nint main(){\n\tcin>>N>>K>>S;\n\tfact[0] = 1;\n\tfor (int i=1;i<=N;++i)fact[i] = (fact[i-1]*i)%MOD;\n\tfor (int i=0;i<=N;++i)invfact[i] = inv(fact[i]);\n\n\tfor (int i=1;i<=N;++i){\n\t\tif (S[i-1] == '1')A[i] = 1;\n\t\tA[i] += A[i-1];\n\t}\n\tfor (int i=0;i<K;++i){\n\t\tcin>>a>>b;\n\t\tE[a] = max(E[a], b);\n\t}\n\tV.pb(-1,-1);\n\tfor (int i=1;i<=N;++i)if(E[i]){\n\t\tif (SZ(V) && V.back().s >= E[i])continue;\n\t\tV.pb(i,E[i]);\n\t}\n\tfor (int i=1;i<SZ(V)-1; ++i){\n\t\toverlap[i] = max(0LL,V[i].s - V[i+1].f + 1);\n\t}\n\n\t// for (int i=1;i<SZ(V);++i)cout<<overlap[i]<<' ';\n\t// cout<<'\\n';\n\tmemo[0][0] = 1;\n\tfor (int i=1;i<SZ(V);++i){\n\t\t// cout<<\"Hi\\n\";\n\t\tint s = max(V[i].f, V[i-1].s+1);\n\t\tint e = V[i].s;\n\t\t// cout<<\"R \"<<s<<' '<<e<<' '<<A[e]-A[s-1]<<'\\n';\n\t\tint l = V[i].s - V[i].f + 1;\n\t\tfor (int j=0;j<=overlap[i-1];++j){\n\t\t\tfor (int k=0;k<=overlap[i];++k){\n\t\t\t\tint ones = j + A[e] - A[s-1];\n\t\t\t\t// cout<<ones<<'\\n';\n\t\t\t\tint zeroes = l - ones;\n\t\t\t\tif (ones < k)continue;\n\t\t\t\tif (zeroes < overlap[i] - k)continue;\n\t\t\t\tmemo[i][k] += (memo[i-1][j] * C(l-overlap[i], ones-k))%MOD;\n\t\t\t\tmemo[i][k]%=MOD;\n\t\t\t}\n\t\t}\n\t\tll t=0;\n\t\tfor (int k=0;k<=overlap[i];++k)t=(t+memo[i][k])%MOD;\n\t\tif (i+1==SZ(V))cout<<t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mod = 1000000007;\n\nint main () {\n  vector<long long> kai(3030);\n  vector<long long> gkai(3030);\n  long long bk = 1;\n  long long bkt;\n  long long bkmod;\n  for (int i=1; i<3030; i++) {\n    bk *= i;\n    bk %= mod;\n    kai[i] = bk;\n    bkmod = bk;\n    for (int i=0; i<9; i++) {\n      bkt = bkmod;\n      for (int j=0; j<9; j++) {\n        bkmod *= bkt;\n        bkmod %= mod;\n      }\n    }\n    for (int i=0; i<5; i++) {\n      bkmod *= bk;\n      bkmod %= mod;\n    }\n    gkai[i] = bkmod;\n  }\n  kai[0] = kai[1];\n  gkai[0] = gkai[1];\n  \n  int N,M;\n  string S;\n  cin >> N >> M >> S;\n  vector<long long> l(M+1,N+1),r(M+1,N+1);\n  for (int i=0; i<M; i++) {\n    cin >> l[i] >> r[i];\n    if (i >= 1) {\n      if (l[i] == l[i-1]) {\n        l[i-1] = -1;\n        r[i] = max(r[i],r[i-1]);\n      }\n    }\n  }\n  vector<int> n1(N+1,0);\n  for (int i=0; i<N; i++) {\n    if (S[i] == '1') n1[i+1] = n1[i] + 1;\n    else n1[i+1] = n1[i];\n  }\n  long long L=0;\n  long long R=0;\n  long long com;\n  long long ll,rr;\n  vector<vector<long long>> dp(N+1,vector<long long>(N+1,0));\n  for (int i=0; i<M+1; i++) {\n    ll = l[i];\n    rr = r[i];\n    if (ll == -1) continue;\n    if(L == 0) {\n      dp[ll-1][n1[ll-1]] = 1;\n      L = ll;\n      R = rr;\n      continue;\n    }\n    if (R < ll) {\n      for (int j=n1[R]-(R-L+1); j<n1[R]+1; j++) {\n        if (j<0) continue;\n        com = kai[R-L+1] * gkai[n1[R]-j] % mod * gkai[(R-L+1)-(n1[R]-j)] % mod;\n        dp[ll-1][n1[ll-1]] += dp[L-1][j] * com % mod;\n      }\n      dp[ll-1][n1[ll-1]] %= mod;\n      L = l[i];\n      R = r[i];\n      continue;\n    }\n    for (int j=n1[R]-(R-ll+1); j<n1[R]+1; j++) {\n      for (int k=0; k<=ll-L; k++) {\n        if (j-k < 0) continue;\n        com = kai[ll-L] * gkai[k] % mod * gkai[ll-L-k] % mod;\n        dp[ll-1][j] += dp[L-1][j-k] * com % mod;\n      }\n      dp[ll-1][j] %= mod;\n    }\n    L = ll;\n    R = max(rr,R);\n  }\n  cout << dp[N][n1[N]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int N=3005;\nconst int mod=1e9+7;\nchar str[N];\nint r[N];\nint d[N][N];\nint s[N];\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",str+1);\n    for(int i=1;i<=n;i++){\n        s[i]=str[i]-'0';\n    }\n    for(int i=1;i<=n+1;i++)\n        s[i]+=s[i-1];\n    for(int i=1;i<=n+1;i++)\n        r[i]=i;\n    for(int i=1;i<=m;i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        r[a]=max(r[a],b);\n    }\n    for(int i=1;i<=n;i++)\n        r[i]=max(r[i],r[i-1]);\n    d[1][s[r[1]]]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            if(d[i][j]){\n                int a=r[i],b=r[i+1];\n                int f=s[b]-s[a];\n                if(j){\n                    d[i+1][j+f-1]+=d[i][j];\n                    d[i+1][j+f-1]%=mod;\n                }\n                if(r[i]!=i+j-1){\n                    d[i+1][j+f]+=d[i][j];\n                    d[i+1][j+f]%=mod;\n                }\n            }\n    int ans=d[n+1][0];\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-(r[i]-l[i+1]+1));j<=sum[r[i]];j++)\n\t{\n\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(l[i+1]-l[i],j-k))%mo;\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}\n\t\n\t\n\t\n\t\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, -1, 1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n);i--;)\n#define rrep2(i,n) for(ll i=(n);i--;)\n#define rrep3(i,a,b) for(ll i=(b);i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto&& i:a)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<uint> divisor(uint x){ vector<uint> ans; for(uint i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T, ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline int __lg(int __n){ return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nstruct PartialSum{\n    vector<ll> data;\n    template<class T> PartialSum(const T& v): data(v.size() + 1){\n        for(ll i = 0; i < v.size(); i++) data[i + 1] = data[i] + v[i];\n    }\n    ll get(ll l, ll r) const {\n        return data[r] - data[l];\n    }\n    ll operator[](ll at) const { return data[at]; }\n};\nconstexpr uint mod = MOD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(n,m);\n    STR(s);\n    VEC(pll,a,m);\n    each(i,a)i.first--;\n    a.emplace_back(n,n);\n    each(i,s)i-='0';\n    PartialSum acc(s);\n    ll l=0,r=0;\n    Modint ans=1;\n    vec(Modint,dp,n+1);\n    dp[0]=1;\n    each(p,a){\n        if(r<p.first){\n            Modint sum=sum(dp);\n            each(i,dp)i=0;\n            dp[acc.get(0,p.first)]=sum;\n            l=r=p.first;\n        }\n        rep(p.first-l)rrep(n)dp[i+1]+=dp[i];\n        ll one=acc.get(0,r),zero=r-one;\n        rep(i,one+1,n+1)dp[i]=0;\n        rep(p.first-zero)dp[i]=0;\n        l=p.first;\n        chmax(r,p.second);\n    }\n    out(dp[acc[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint n, m, l[3009], r[3009], p[3009], dp[3009][3009], R, s[3009], t[3009], mod = 1000000007; bool used[3009]; string S;\nint main() {\n\tcin >> n >> m >> S; S = \"#\" + S;\n\tfor (int i = 1; i <= m; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tif (R >= r[i])continue;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (l[j] == l[i])used[j] = false;\n\t\t}\n\t\tR = r[i]; used[i] = true;\n\t}\n\tfor (int i = 0; i <= n; i++) { s[i] = -1; t[i] = 1e9; }\n\tint V = 1, W = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (used[i] == false)continue;\n\t\tif (W < l[i]) {\n\t\t\tint u = 0; for (int j = 1; j <= W; j++)u += (S[j] - '0');\n\t\t\ts[W] = u; t[W] = u;\n\t\t\tfor (int j = W + 1; j < l[i]; j++) {\n\t\t\t\tif (S[j] == '1')u++; s[j] = u; t[j] = u;\n\t\t\t}\n\t\t\tV = l[i];\n\t\t}\n\t\tint cnt = 0, u = 0; for (int j = 1; j < V; j++)cnt += (S[j] - '0');\n\t\tfor (int j = V; j <= W; j++)u += (S[j] - '0');\n\t\ts[l[i] - 1] = cnt + max(0, (l[i] - V) - max(0, ((W - V + 1) - u)));\n\t\tt[l[i] - 1] = cnt + min(l[i] - V, u);\n\t\tW = r[i];\n\t}\n\tint u = 0; for (int j = 1; j <= W; j++)u += (S[j] - '0');\n\ts[W] = u; t[W] = u;\n\tfor (int j = W + 1; j <= n; j++) {\n\t\tif (S[j] == '1')u++; s[j] = u; t[j] = u;\n\t}\n\n\tint X = 0; for (int i = 1; i <= n; i++)X += (S[i] - '0');\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (!(s[i] <= j && j <= t[i])) { dp[i][j] = 0; continue; }\n\t\t\tdp[i + 1][j] += dp[i][j]; dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += dp[i][j]; dp[i + 1][j + 1] %= mod;\n\t\t}\n\t}\n\tcout << dp[n][X] % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 3010\n#define mod 1000000007\nusing namespace std;\nint dp[maxn][maxn],n,m,l[maxn],r[maxn],tp,s[maxn],C[maxn][maxn];\nchar ss[maxn];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(int i=1;i<=n;++i)\n\t\ts[i]=s[i-1]+(ss[i]=='1');\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&l[i],&r[i]);\n\t\tif(l[i]==l[tp])r[tp]=max(r[tp],r[i]);\n\t\telse if(r[tp]<r[i])l[++tp]=l[i],r[tp]=r[i];\n\t}\n\tdp[1][s[r[1]]-s[l[1]-1]]=1;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=*C[i]=1;j<=i;++j)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tfor(int i=2;i<=tp;++i){\n\t\tint k=s[r[i]]-s[r[i-1]],A=l[i]-l[i-1],len=r[i-1]-l[i-1]+1,len2=r[i]-l[i]+1;\n\t\tfor(int j=k;j<=len2&&j<=r[i-1]-l[i]+1+k;++j)\n\t\t\tfor(int a=0;a<=A&&a+j-k<=len;++a)\n\t\t\t\tdp[i][j]=(dp[i][j]+1ll*dp[i-1][a+j-k]*C[A][a])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=r[tp]-l[tp]+1;++i)\n\t\tans=(ans+1ll*dp[tp][i]*C[r[tp]-l[tp]+1][i])%mod;\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 3010;\nconst int mod = 1e9 + 7;\n\nchar s[N];\nint g[N], l0[N], r0[N], l[N], r[N];\nLL c[N][N], f[N][N];\n\nvoid upd(LL &a, LL b) { a = (a + b) % mod;}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tc[0][0] = 1;\n\tRep(i, n) {\n\t\tc[i][0] = 1;\n\t\tRep(j, i) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\t\n\tscanf(\"%s\", s + 1);\n\tRep(i, n) g[i] = g[i - 1] + s[i] - '0';\n\t\n\tRep(i, m) scanf(\"%d%d\", &l0[i], &r0[i]);\n\tint m0 = 0;\n\tRep(i, m) {\n\t\tbool flag = true;\n\t\tRep(j, m0) if (l[j] <= l0[i] && r0[i] <= r[j]) flag = false;\n\t\tif (flag) l[++ m0] = l0[i], r[m0] = r0[i];\n\t}\n\t//printf(\"%d\\n\", m0);\n\tf[0][0] = 1;\n\tRep0(i, m0 - 1){\n\t\tif (l[i + 1] > r[i])\n\t\t\tRep0(j, n) upd(f[i + 1][g[r[i + 1]] - g[l[i + 1] - 1]], f[i][j]);\n\t\telse {\n\t\t\tRep0(j, n) if (f[i][j]){\n\t\t\t\t//printf(\"%d %d %lld\\n\", i, j, f[i][j]);\n\t\t\t\tfor (int k = max(0, j - (r[i] - l[i + 1] + 1)); k <= min(l[i + 1] - l[i], j); k ++)\n\t\t\t\t\tupd(f[i + 1][j - k + g[r[i + 1]] - g[r[i]]], f[i][j] * c[l[i + 1] - l[i]][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tLL ans = 0;\n\tRep0(i, n) upd(ans, f[m0][i] * c[r[m0] - l[m0] + 1][i]);\n\t\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n/*\n9 3\n110111110\n1 4\n4 6\n6 9\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m,ans;\nstring s;\nll ac[3001];\nll l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return x*x%MOD;\n}\nint modpow(ll x,int y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=(ret*(x-i)*inv(i+1))%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        ll le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max((ll)0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\nconst int mod=1e9+7;\n\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n\nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n\nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])];k++)\n\t\t\t{\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n       int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<set>\n#define SF scanf\n#define PF printf\n#define MAXN 3010\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\nll dp[MAXN][MAXN];\nint n,m;\nchar s[MAXN];\nint endx[MAXN],pre[MAXN];\nint main(){\n\tSF(\"%d%d\",&n,&m);\n\tSF(\"%s\",s+1);\n\tfor(int i=1;i<=n+1;i++)\n\t\tpre[i]=pre[i-1]+(s[i]=='1');\n\tint las=1;\n\tint u,v;\n\tfor(int i=1;i<=n+1;i++)\n\t\tendx[i]=max(endx[i],i);\n\tfor(int i=1;i<=m;i++){\n\t\tSF(\"%d%d\",&u,&v);\t\n\t\tendx[u]=max(endx[u],v);\n\t}\n\tfor(int i=1;i<=n+1;i++)\n\t\tendx[i]=max(endx[i],endx[i-1]);\n\tdp[1][pre[endx[1]]]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(dp[i][j]){\n\t\t\t\tint l=endx[i];\n\t\t\t\tint r=endx[i+1];\n\t\t\t\tint one=j;\n\t\t\t\tint zero=endx[i]-i+1-j;\n\t\t\t\tif(zero)\n\t\t\t\t\t(dp[i+1][j+pre[r]-pre[l]]+=dp[i][j])%=MOD;\n\t\t\t\tif(one)\n\t\t\t\t\t(dp[i+1][j-1+pre[r]-pre[l]]+=dp[i][j])%=MOD;\n\t\t\t}\n\tPF(\"%lld\",dp[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename T> constexpr T fpow_eq(T& x, ll y, T identity = 1) {\n    for(; y > 0; x *= x, y >>= 1) {\n        if(y & 1) {\n            identity *= x;\n        }\n    }\n    return x = identity;\n}\ntemplate <typename T> constexpr T fpow(T x, ll y, T identity = 1) { return fpow_eq(x, y, identity); }\n#ifdef __TOTIENT_INCLUDED_\ntemplate <int M, int PHI_M = phi(M)> struct modint {\n#else\ntemplate <int M, int PHI_M> struct modint {\n#endif\n    static constexpr int MOD = M;\n    int val;\n    constexpr modint() : val(0) {}\n    constexpr modint(int val) : val(val % M) { val += val < 0 ? M : 0; }\n    constexpr modint(long long val) : modint(int(val % M)) {}\n    constexpr modint(const modint& m) : val(m.val) {}\n    constexpr explicit operator int() const { return val; }\n    constexpr bool operator==(const modint& y) const { return val == y.val; }\n    constexpr bool operator!=(const modint& y) const { return val != y.val; }\n    constexpr bool operator< (const modint& y) const { return val <  y.val; }\n    constexpr bool operator<=(const modint& y) const { return val <= y.val; }\n    constexpr bool operator> (const modint& y) const { return val >  y.val; }\n    constexpr bool operator>=(const modint& y) const { return val >= y.val; }\n    constexpr modint& operator=(const modint& y) { val = y.val; return *this; }\n    constexpr modint& operator+=(const modint& y) { val += y.val; val -= val >= M ? M : 0; return *this; }\n    constexpr modint& operator-=(const modint& y) { val -= y.val; val += val <  0 ? M : 0; return *this; }\n    constexpr modint& operator*=(const modint& y) { val = ll(val) * y.val % M; return *this; }\n    constexpr modint& operator/=(const modint& y) { val = ll(val) * fpow(y, PHI_M - 1).val % M; return *this; }\n    constexpr modint& operator^=(ll y) { fpow_eq(*this, y); return *this; }\n    constexpr modint operator+(const modint& y) const { return modint(val) += y; }\n    constexpr modint operator-(const modint& y) const { return modint(val) -= y; }\n    constexpr modint operator*(const modint& y) const { return modint(val) *= y; }\n    constexpr modint operator/(const modint& y) const { return modint(val) /= y; }\n    constexpr modint operator^(ll y) const { return modint(val) ^= y; }\n    constexpr modint operator-() const { return modint(0) -= *this; }\n    constexpr modint operator~() const { return modint(1) /= *this; }\n    constexpr modint& operator++() { val = val == M - 1 ? 0 : val + 1; return *this; }\n    constexpr modint& operator--() { val = val == 0 ? M - 1 : val - 1; return *this; }\n    constexpr modint operator++(int) { modint m = *this; ++(*this); return m; }\n    constexpr modint operator--(int) { modint m = *this; --(*this); return m; }\n    friend constexpr modint operator+(long long x, const modint& y) { return modint(x) + y; }\n    friend constexpr modint operator*(long long x, const modint& y) { return modint(x) * y; }\n    friend constexpr modint operator-(long long x, const modint& y) { return modint(x) - y; }\n    friend constexpr modint operator/(long long x, const modint& y) { return modint(x) / y; }\n    friend ostream& operator<<(ostream& os, const modint& m) { return os << m.val; }\n    friend istream& operator>>(istream& is, modint& m) { ll val; is >> val; m = modint(val); return is; }\n};\nconstexpr int M = 1'000'000'007;\nusing mint = modint<M, M - 1>;\nmint operator\"\"_m(unsigned long long int x) { return mint(ll(x)); }\ntemplate <typename T> struct grid : public vector<vector<T>> {\n    int n, m;\n    grid(int n, int m) : vector<vector<T>>(n, vector<T>(m)), n(n), m(m) {}\n    grid(int n, int m, T zero) : vector<vector<T>>(n, vector<T>(m, zero)), n(n), m(m) {}\n    grid(const grid& a) : vector<vector<T>>(a), n(a.n), m(a.m) {}\n};\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    map<int, int> ops;\n    for(int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        ops[l] = max(ops[l], r);\n    }\n    int zeros = 0, ones = 0, r = -1;\n    vector<int> zeros_at(n), ones_at(n);\n    for(int i = 0; i < n; i++) {\n        if(ops.count(i)) {\n            for(int j = r + 1; j <= ops[i]; j++) {\n                zeros += s[j] == '0';\n                ones += s[j] == '1';\n            }\n            r = max(r, ops[i]);\n        } else if(i > r) {\n            zeros += s[i] == '0';\n            ones += s[i] == '1';\n            r++;\n        }\n        zeros_at[i] = zeros;\n        ones_at[i] = ones;\n    }\n    grid<mint> C(n + 1, n + 1);\n    for(int pos = n; pos >= 0; pos--) {\n        for(int zeros_used = pos; zeros_used >= 0; zeros_used--) {\n            if(pos == n) {\n                C[pos][zeros_used] = 1;\n            } else {\n                int ones_used = pos - zeros_used;\n                if(zeros_used < zeros_at[pos]) {\n                    C[pos][zeros_used] += C[pos + 1][zeros_used + 1];\n                }\n                if(ones_used < ones_at[pos]) {\n                    C[pos][zeros_used] += C[pos + 1][zeros_used];\n                }\n            }\n        }\n    }\n    cout << C[0][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define NMAX 3005\n#define MMAX 3005\n#define mod 1000000007\n#define PIE 3.14159265358979\n#define rep(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\ntypedef long long int LL;\n\nint N,M;\nstring S;\nint l[MMAX],r[MMAX];\n\nLL mpow(LL a,LL n){\n    LL ans = 1;\n    while(n>0){\n        if(n&1){ans=(ans*a)%mod;}\n        a=(a*a)%mod;\n        n>>=1;\n    }\n    return ans;\n}\n\nLL fact[NMAX+1];\nLL factinv[NMAX+1];\n\nLL comb(LL a,LL b){\n    LL ret = (fact[a]*factinv[b])%mod;\n    ret = (ret*factinv[a-b])%mod;\n    return ret;\n}\n\nvoid init(){\n    fact[0]=1;\n    rep(i,NMAX){\n        fact[i+1]=fact[i]*(i+1);\n        fact[i+1]%=mod;\n    }\n    rep(i,NMAX+1){\n        factinv[i]=mpow(fact[i],mod-2);\n    }\n}\n\nLL dfs(int step,int czero){\n    if(step==M)return 1;\n    int rp=0,ln=N;\n    int l_=l[step];\n    int r_=r[step];\n    if(step>0){\n        rp=r[step-1];\n    }\n    if(step<M-1){\n        ln=l[step+1];\n    }\n    for(int i = max(l_,rp);i < r_;i++){\n        if(S[i]=='0')czero++;\n    }\n    if(ln>=r_){\n        return (comb(r_-l_,czero)*dfs(step+1,0))%mod;\n    }\n    LL ans = 0;\n    int nczeromax=min(r_-ln,czero);\n    for(int nczero = max(0,czero-(ln-l_));nczero<=nczeromax;nczero++){\n        ans += comb(ln-l_,czero-nczero)*dfs(step+1,nczero);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main(){\n    init();\n    cin>>N>>M;\n    cin>>S;\n    int now = 0;\n    int M_=M;\n    rep(i,M_){\n        cin>>l[now]>>r[now];\n        r[now]++;\n        if(i==0){now++;}\n        else if(l[now]==l[now-1]){\n            M--;\n            r[now-1]=max(r[now],r[now-1]);\n        }else{\n            now++;\n        }\n    }\n    cout<<dfs(0,0)<<endl;\n//    rep(i,M){\n//        cout<<l[i]<<\" \"<<r[i];\n//    }\n    init();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nlong long n,m,cc[3005],a[3005],dp[3005][3005];\nchar s[3005];\nint main()\n{\n\tscanf(\"%lld%lld%s\",&n,&m,s+1);\n\tfor(long long i=1;i<=n;a[i]=i,i++)cc[i]=cc[i-1]+(s[i]-'0');\n\tfor(long long i=1,l,r;i<=m;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&l,&r);\n\t\tfor(long long j=l;j<=r;j++)a[j]=max(a[j],r);\n\t}\n\tdp[0][0]=1;\n\tfor(long long i=1;i<=n;i++)\n\t{\n\t\tfor(long long j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j>cc[a[i]])continue;\n\t\t\tif(i-j>a[i]-cc[a[i]])continue;\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%md;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][cc[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n  else return mpow(a,b-1) * a % MOD;\n}\nll lpow(ll a, ll b){\n  if(b==0) return 1;\n  else if(b%2==0){ll memo = lpow(a,b/2); return memo*memo;}\n  else return lpow(a,b-1) * a;\n}\nll gcd(ll a, ll b){\n  if(b==0) return a;\n  else return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n  if(kaijo_memo.size() > n) return kaijo_memo[n];\n  if(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n  while(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n  return kaijo_memo[n];\n}\nvector<ll> gyaku_kaijo_memo;\nll gyaku_kaijo(ll n){\n  if(gyaku_kaijo_memo.size() > n) return gyaku_kaijo_memo[n];\n  if(gyaku_kaijo_memo.size() == 0) gyaku_kaijo_memo.push_back(1);\n  while(gyaku_kaijo_memo.size() <= n) gyaku_kaijo_memo.push_back(gyaku_kaijo_memo[gyaku_kaijo_memo.size()-1] * mpow(gyaku_kaijo_memo.size(), MOD-2) % MOD);\n  return gyaku_kaijo_memo[n];\n}\n\nll nCr(ll n, ll r){\n  if(n == r) return 1;//0個の丸と-1個の棒みたいな時に時に効く？不安.\n  if(n < r || r < 0) return 0;\n  ll ret = 1;\n  ret *= kaijo(n); ret %= MOD;\n  ret *= gyaku_kaijo(r); ret %= MOD;\n  ret *= gyaku_kaijo(n-r); ret %= MOD;\n  return ret;\n}\n\n\nint main(void){\n  ll n,m;\n  cin>>n>>m;\n  string s; cin>>s;\n  vector<ll> ones,zeros;\n  ones.push_back(0);\n  zeros.push_back(0);\n  rep(i,s.size()){\n    ones.push_back(ones[i] + s[i] - '0');\n    zeros.push_back(zeros[i] + '1' - s[i]);\n  }\n  vector<pair<ll,ll>> com;\n  ll mr = -1;\n  rep(i,m){\n    ll l,r;cin>>l>>r; l--;r--;\n    if(i > 0 && com.back().first == l){\n      if(com.back().second < r){\n        com.pop_back();\n      }\n    }\n    if(mr < r){\n      com.push_back({l,r});\n      mr = r;\n    }\n  }\n  com.push_back({LINF,LINF});\n  vector<ll> L,R;\n  rep(i,com.size()){\n    L.push_back(com[i].first);\n    R.push_back(com[i].second);\n  }\n  int ci = 0;\n  vector<vector<ll>> dp;\n  rep(i,s.size()+1){\n    dp.push_back(vector<ll>());\n    rep(j,s.size()+1){\n      dp[i].push_back(0);\n    }\n  }\n  dp[0][0] = 1;\n  rep(i,s.size()){\n    if(L[ci+1] <= i){\n      ci++;\n    }\n    ll l = L[ci];\n    ll r = R[ci];\n    if(r < i || l > i){\n      r = i;\n    }\n    rep(j,s.size()){  \n      if(zeros[r+1] >= (i+1) - j){\n        dp[i+1][j] += dp[i][j];\n        dp[i+1][j] %= MOD;\n      }\n      if(ones[r+1] >= j+1){\n        dp[i+1][j+1] += dp[i][j];\n        dp[i+1][j+1] %= MOD;\n      }\n      \n    }\n  }\n  cout<<dp[n][ones.back()]<<endl;\n  /*rep(i,n+1){\n    rep(j,n){\n      cout<<dp[i][j]<<\" \";\n    }\n    cout<<endl;\n  }*/\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint N, M;\nstring S;\nstatic ll dp[3002][3002];\n\nconst ll MODP = 1000000007;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\nint main(void){\n\tcin >> N >> M;\n\tcin >> S;\n\tint l[M], r[M], c[M];\n\tint sum[N+1]={0};\n\tfor(int i=1;i<=N;i++){\n\t\tsum[i] = sum[i-1] + ((S[i-1]=='1') ? 1 : 0);\n\t}\n\tvpii a;\n\tint maxi = 0;\n\tfor(int i=0;i<=M;i++){\n\t\tif (i<M){\n\t\t\tcin >> l[i] >> r[i];\n\t\t}\n\t\tif (i==M || (i>0 && l[i]>l[i-1])){\n\t\t\ta.pb(mp(l[i-1], maxi));\n\t\t\tmaxi = 0;\n\t\t}\n\t\tif (i<M){\n\t\t\tmaxi = max(maxi, r[i]);\n\t\t}\n\t}\n\tvpii b;\n\tmaxi = -1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif (maxi < a[i].second){\n\t\t\tb.pb(a[i]);\n\t\t\tmaxi = a[i].second;\n\t\t}\n\t}\n\tfor(int i=0;i<b.size();i++){\n\t\tc[i] = sum[b[i].second] - sum[b[i].first-1];\n\t\tb[i].first--;\n\t\t//cout << b[i].first << \" \" << b[i].second << \" \" << c[i] << endl;\n\t}\n\t\n\tdp[0][c[0]] = 1;\n\tfor(int i=0;i+1<b.size();i++){\n\t\tif (b[i].second > b[i+1].first){\n\t\t\tfor(int j=0;j<=b[i].second-b[i].first;j++){\n\t\t\t\tfor(int k=0;k<=b[i+1].second-b[i+1].first;k++){\n\t\t\t\t\tint d = sum[b[i+1].second] - sum[b[i].second];\n\t\t\t\t\tint c1 = j - k + d;\n\t\t\t\t\tint c2 = k - d;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << d << endl;\n\t\t\t\t\tif (d<0 || c1<0 || c2<0 || c2>b[i].second-b[i+1].first) continue;\n\t\t\t\t\tdp[i+1][k] = (dp[i+1][k] + dp[i][j] * comb(b[i+1].first - b[i].first, c1)) % MODP;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<3002;j++){\n\t\t\t\tdp[i+1][c[i+1]] = (dp[i+1][c[i+1]] + dp[i][j] * comb(b[i].second - b[i].first, j)) % MODP;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<b.size();i++){\n\t\tcout << \"i = \" << i << endl;\n\t\tfor(int j=0;j<3002;j++){\n\t\t\tif (dp[i][j]!=0){\n\t\t\t\tcout << \"dp[i][\" << j << \"] = \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tll ans = 0;\n\tfor(int i=0;i<3002;i++){\n\t\tans = (ans + dp[b.size()-1][i] * comb(b[b.size()-1].second - b[b.size()-1].first, i)) % MODP;\n\t}\n\tcout << ans << endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N,M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> sum(N+1,0);\n    for (int i=0;i<N;++i) sum[i+1]=sum[i]+(S[i]-'0');\n    vector<pair<int,int>> sec;\n    for (int i=0;i<M;++i){\n        int l,r; cin >> l >> r; --l,--r;\n        if (!sec.empty()&&sec.back().second>=r) continue;\n        if (!sec.empty()&&sec.back().first==l) sec.pop_back();\n        sec.emplace_back(l,r);\n    }\n    int m=sec.size();\n    vector<vector<mint>> dp(m+1,vector<mint>(N+1,0));\n    dp[0][0]=1;\n    mint ans=0;\n    int prel=-1,prer=-1;\n    for (int i=0;i<m;++i){\n        int l=sec[i].first,r=sec[i].second;\n        int nxt=(prer<l?0:l-prel),add=sum[r+1]-sum[prer+1],rest=max(0,prer-l+1);\n        for (int j=0;j<=N;++j){\n            if (dp[i][j]==0) continue;\n            for (int k=0;k<=min(j,nxt);++k){\n                if (j-k<=rest) dp[i+1][j+add-k]+=dp[i][j]*COM(nxt,k);\n            }\n        }\n        if (i==m-1) for (int j=0;j<=N;++j){\n            ans+=dp[i+1][j]*COM(r-l+1,j);\n        }\n        prel=l,prer=max(prer,r);\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cassert>\n#include<utility>\n#include<algorithm>\n#define llong long long\n#define pii pair<int,int>\n#define mkpr make_pair\nusing namespace std;\n\nconst int N = 3e3;\nconst int P = 1e9+7;\nchar a[N+3];\nint s[N+3];\nint mxr[N+3];\nllong dp[N+3][N+3];\nint n,m,mm;\nllong ans;\n\nllong updmax(llong &x,llong y) {x = (x+y)%P;}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1); for(int i=1; i<=n; i++) a[i] -= 48;\n\tfor(int i=1; i<=n+1; i++) s[i] = s[i-1]+a[i];\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tint x,y; scanf(\"%d%d\",&x,&y); mxr[x] = max(mxr[x],y);\n\t}\n\tfor(int i=1; i<=n+1; i++) mxr[i] = max(mxr[i],max(i,mxr[i-1]));\n//\tprintf(\"mxr: \"); for(int i=1; i<=n+1; i++) printf(\"%d \",mxr[i]); puts(\"\");\n\tdp[1][s[mxr[1]]] = 1ll;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=0; j<=n; j++)\n\t\t{\n\t\t\tif(dp[i][j])\n\t\t\t{\n\t\t\t\tint cnt1 = j,cnt0 = mxr[i]-(i-1)-j;\n\t\t\t\tif(cnt0>0) {updmax(dp[i+1][j+s[mxr[i+1]]-s[mxr[i]]],dp[i][j]);}\n\t\t\t\tif(cnt1>0) {updmax(dp[i+1][j+s[mxr[i+1]]-s[mxr[i]]-1],dp[i][j]);}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define f first\n#define s second\n#define pb push_back\n#define reset(a,b) memset(a,b,sizeof a);\n#define ALL(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sz(x) (int)(x.size())\n#define lt(x) (int)(x.length())\n#define MOD 1000000007 \n#define mx 3003\n\nlong long fak[10003], inv[10003];\n\nlong long POW(long long a, int b){\n\tlong long ret = 1;\n\twhile(b > 0){\n\t\tif(b & 1)\n\t\t\tret = ret * a % MOD;\n\t\tb >>= 1;\n\t\ta = a * a % MOD;\n\t}\n\treturn ret;\n}\n\nlong long C(int n, int k){\n\tif(k > n)\n\t\treturn 0;\n\treturn fak[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nlong long dep[mx][mx], n, m, pref0[mx], pref1[mx], l, r;\nstring ss;\nvector<pair<int, int>> ve;\n\n\n\nlong long dp(int now, int satu){\n\tif(now == sz(ve))\n\t\treturn 1;\n\tlong long &ret = dep[now][satu];\n\tif(ret != -1)\n\t\treturn ret;\n\tret = 0;\n\tif(now == sz(ve) - 1 || ve[now].s < ve[now + 1].f){\n\t\tint kiri = ve[now].f;\n\t\tint tengah = kiri;\n\t\tint kanan = ve[now].s;\n\t\tif(now > 0 && ve[now - 1].s >= kiri)\n\t\t\ttengah = ve[now - 1].s + 1;\n\t\t//dari kiri -> tengah - 1 dan tengah -> kanan\n\t\tint nol = pref0[kanan] - pref0[tengah - 1] + tengah - kiri - satu;\n\t\tint sat = pref1[kanan] - pref1[tengah - 1] + satu;\n\t\tret = dp(now + 1, 0) * C(nol + sat, sat) % MOD;\n\t\t// cout << now << ' ' << satu << ' ' << ret <<endl;\n\t\treturn ret;\n\t}\n\tint kiri = ve[now].f;\n\tint tengah = kiri;\n\tint kanan = ve[now].s;\n\tint batas = ve[now + 1].f - 1;\n\tif(now > 0 && ve[now - 1].s >= kiri){\n\t\t// debug(tengah);\n\t\ttengah = ve[now - 1].s + 1;\n\t}\n\tint berapa = batas - kiri + 1;\n\n\tint nol = pref0[kanan] - pref0[tengah - 1] + tengah - kiri - satu;\n\tint sat = pref1[kanan] - pref1[tengah - 1] + satu;\n\t// cout << now << ' ' << satu << ' ' << nol << ' ' << sat << ' ' << kiri << ' ' << tengah << ' ' << kanan << endl;\n\tfor(int i = max(0, berapa - sat); i <= min(nol, berapa); i++){\n\t\tint j = berapa - i;\n\t\tassert(0 <= i && i <= nol);\n\t\tassert(0 <= j && j <= sat);\n\t\tret = (ret + dp(now + 1, sat - j) * C(i + j, i)) % MOD;\n\t}\n\t// cout << now << ' ' << satu << ' ' << ret <<endl;\n\treturn ret;\n\n}\n\nint main(){\n\tfak[0] = 1;\n\tfor(int i = 1; i <= 10000; i++)\n\t\tfak[i] = fak[i - 1] * i % MOD;\n\n\tinv[10000] = POW(fak[10000], MOD - 2);\n\tfor(int i = 10000 - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % MOD;\n\t// for(int i = 0; i <= 10000; i++)\n\t\t// inv[i] = POW(fak[i], MOD - 2);\n\t// debug(inv[2]);\n\tcin >> n >> m >> ss;\n\n\tfor(int i = 0; i < n; i++){\n\t\tif(i > 0){\n\t\t\tpref0[i] = pref0[i - 1];\n\t\t\tpref1[i] = pref1[i - 1];\n\t\t}\n\t\tif(ss[i] == '0')\n\t\t\tpref0[i] += 1;\n\t\telse pref1[i] += 1;\n\t}\n\n\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> l >> r;\n\t\tl -= 1;\n\t\tr -= 1;\n\t\tve.pb({l, r});\n\t}\n\tsort(ALL(ve), [&](pair<int, int> x, pair<int, int> y){\n\t\tif(x.f == y.f)\n\t\t\treturn x.s > y.s;\n\t\treturn x.f < y.f;\n\t});\n\tvector<pair<int, int>> sem = ve;\n\tve.clear();\n\tfor(auto i : sem){\n\t\tif(ve.empty())\n\t\t\tve.pb(i);\n\t\telse if(ve.back().s < i.s)\n\t\t\tve.pb(i);\n\t}\n\treset(dep, -1);\n\tcout << dp(0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=3005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(b<0) return 0;\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nll dp[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    make();\n    \n    int N,q;cin>>N>>q;\n    string S;cin>>S;\n    vector<pair<int,int>> Q;\n    while(q--){\n        int s,t;cin>>s>>t;\n        if(Q.size()==0) Q.push_back({s,t});\n        else if(Q.back().first==s) chmax(Q.back().second,t);\n        else if(Q.back().second<t) Q.push_back({s,t});\n    }\n    Q.push_back({N+1,N+2});\n    \n    vector<int> T(N+1);\n    int M=int(Q.size());\n    \n    for(int i=1;i<=N;i++){\n        if(S[i-1]=='1') T[i]=T[i-1]+1;\n        else T[i]=T[i-1];\n    }\n    \n    ll ans=1;\n    \n    dp[0][0]=1;\n    \n    int left=Q[0].first-1;\n    \n    for(int i=1;i<M;i++){\n        if(Q[i-1].second<Q[i].first){\n            ll sum=0;\n            for(int j=0;j<=T[Q[i-1].second];j++){\n                sum+=dp[i-1][j]*comb(Q[i-1].second-left,T[Q[i-1].second]-j);\n                //cout<<sum<<endl;\n                sum%=mod;\n            }\n            ans*=sum;\n            ans%=mod;\n            left=Q[i].first-1;\n            dp[i][T[Q[i-1].second]]=1;\n        }else{\n            for(int j=0;j<=T[Q[i-1].second];j++){\n                for(int d=0;d<=Q[i].first-1-left;d++){\n                    if(j-d<0) continue;\n                    if(T[Q[i-1].second]-j>Q[i-1].second-(Q[i].first-1)) continue;\n                    \n                    dp[i][j]+=dp[i-1][j-d]*comb(Q[i].first-1-left,d);\n                    dp[i][j]%=mod;\n                }\n            }\n            left=Q[i].first-1;\n        }\n    }\n    \n    /*for(int i=1;i<=M;i++){\n        for(int j=0;j<=N;j++){\n            cout<<dp[i][j]<<\" \";\n        }\n        cout<<endl;\n    }*/\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=3005;\nconst int mod=1e9+7;\nint n,q,dp[N],lim_r[N],sum0[N];\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nint main(){\n\tstatic char str[N];\n\tn=nxi(),q=nxi();\n\tscanf(\"%s\",str+1);\n\tfor(int i=1; i<=n; ++i){\n\t\tlim_r[i]=i;\n\t\tsum0[i]=sum0[i-1]+(str[i]=='0');\n\t}\n\tfor(int i=1; i<=q; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tfor(int i=x; i<y; ++i){\n\t\t\tapx(lim_r[i],y);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tapx(lim_r[i],lim_r[i-1]);\n\t}\n\tdp[0]=1;\n\tfor(int i=0; i<n; ++i){\n\t\tstatic int fp[N];\n\t\tmemcpy(fp,dp,n*sizeof(int));\n\t\tmemset(dp,0,n*sizeof(int));\n\t\tint r=lim_r[i+1];\n\t\tint add_0=sum0[r]-sum0[lim_r[i]];\n\t\tfor(int j=0; j<=i; ++j){\n\t\t\tif(!fp[j]) continue;\n\t\t\t//print 1\n\t\t\tif(j+add_0<r-i){\n\t\t\t\tdp[j+add_0]=(dp[j+add_0]+fp[j])%mod;\n\t\t\t}\n\t\t\t//print 0\n\t\t\tif(j+add_0-1>=0){\n\t\t\t\tdp[j+add_0-1]=(dp[j+add_0-1]+fp[j])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,q;\n  string s;\n  cin>>n>>q>>s;\n  vector<Int> v(n);\n  for(Int i=0;i<n;i++) v[i]=i+1;\n  for(Int i=0;i<q;i++){\n    Int l,r;\n    cin>>l>>r;\n    l--;\n    chmax(v[l],r);\n  }\n  for(Int i=1;i<n;i++) chmax(v[i],v[i-1]);\n  vector<Int> c(n+1,0);\n  for(Int i=0;i<n;i++) c[i+1]=c[i]+(s[i]=='1');\n\n  const Int MOD = 1e9+7;\n  vector<Int> dp(n+1,0);\n  dp[0]=1;\n  for(Int i=0;i<n;i++){\n    vector<Int> nx(n+1,0);\n    for(Int j=0;j<=n;j++){\n      //cout<<i<<\" \"<<j<<\":\"<<dp[j]<<endl;\n      if(j<c[v[i]]) nx[j+1]+=dp[j];\n      if(i-j<v[i]-c[v[i]]) nx[j]+=dp[j];\n      nx[j]%=MOD;\n    }\n    swap(dp,nx);\n  }\n  cout<<dp[c[n]]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll l[5000], r[5000];\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cnk[0][0] = 1;\n    for (int i = 0; i <= 3000; i++) cnk[i][0] = cnk[i][i] = 1;\n    for (int i = 0; i <= 3000; i++) for (int j = 1; j < i; j++) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % MOD;\n    //s = \"0\" + s;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    cout << endl;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> l[i] >> r[i];\n        if (i > 1 && l[i - 1] <= l[i] && r[i] <= r[i - 1])\n        {\n            i--;\n            m--;\n        }\n    }\n    m++;\n    l[m] = n;\n    r[m] = n;\n    dp[0][summ(l[1], r[1])] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        for (int y = summ(r[i] + 1, r[i + 1]); y <= r[i + 1] - l[i + 1] + 1; y++)\n        {\n            int delta = y - summ(r[i] + 1, r[i + 1]);\n            for (int x = delta; x <= r[i] - l[i] + 1; x++)\n            {\n                dp[i][y] = (dp[i][y] + cnk[x][delta] * dp[i - 1][x]) % MOD;\n            }\n        }\n    }\n    cout << (dp[m - 1][0] + dp[m - 1][1]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<int, int> P;\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nll dp[3001][3001];\nint cnt[3001];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tcnt[i + 1] = S[i] - '0' + cnt[i];\n\t}\n\tvector<P> v;\n\tv.emplace_back(0, 0);\n\tint prev_r = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (prev_r < r) {\n\t\t\tv.emplace_back(l, r);\n\t\t\tprev_r = r;\n\t\t}\n\t}\n\tv.emplace_back(N + 1, N + 1);\n\tcomb_init(N);\n\tdp[0][0] = 1;\n\tfor (int i = 0; i + 2 < v.size(); i++) {\n\t\tint now = max(v[i].second - v[i + 1].first + 1, 0);\n\t\tint nxt = max(v[i + 1].second - v[i + 2].first + 1, 0);\n\t\tint now_len = v[i + 1].second - v[i + 1].first + 1;\n\t\tfor (int j = 0; j <= now; j++) {\n\t\t\tint one = j + cnt[v[i + 1].second] - cnt[v[i + 1].second - (now_len - now)];\n\t\t\tfor (int k = 0; k <= min(one, now_len - nxt); k++) {\n\t\t\t\tif (one - k > nxt) continue;\n\t\t\t\t(dp[i + 1][one - k] += (dp[i][j] * comb(now_len - nxt, k)) % MOD) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[v.size() - 2][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<iomanip>\n#include<math.h>\n#include<bitset>\n#include<cassert>\n#include<random>\n#include<time.h>\n#include<functional>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll N = 100010;\nll bit[100010];\nvoid add(ll a, ll w) {\n\ta++;\n\tfor (ll x = a; x <= N; x += x & -x) bit[x] += w;\n}\nll sum(ll a) {\n\ta++;\n\tll ret = 0;\n\tfor (ll x = a; x > 0; x -= x & -x) ret += bit[x];\n\treturn ret;\n}\n// return the sum of [a, b)\nll sum(ll a, ll b) {\n\tll ret = 0;\n\tif(b == 0) return 0;\n\tret += sum(b - 1);\n\tif(a) ret -= sum(a - 1);\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<ll> cons(n, -1);\n\tREP(i, n) cons[i] = i;\n\tREP(i, m) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--; r--;\n\t\tcons[l] = max(cons[l], r);\n\t}\n\tll tmp = -1;\n\tREP(i, n) {\n\t\tif(cons[i] > tmp) {\n\t\t\ttmp = cons[i];\n\t\t} else cons[i] = -1;\n\t}\n\tREP(i, n) if(s[i] == '1') add(i, 1);\n\ttmp = -1; // どこまで見た\n\tvector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));\n\tdp[0][0] = 1;\n\tREP(i, n) {\n\t\tll diff = 0;\n\t\tif(cons[i] != -1) {\n\t\t\tdiff += sum(tmp + 1, cons[i] + 1);\n\t\t\ttmp = cons[i];\n\t\t}\n\t\tREP(j, n + 1) {\n\t\t\tdp[i][j] %= MOD;\n\t\t\tll one = j + diff;\n\t\t\tif(one) dp[i + 1][one - 1] += dp[i][j];\n\t\t\tif(tmp - i + 1 > one) dp[i + 1][one] += dp[i][j];\n\t\t}\n\t}\n\tcout << dp[n][0] % MOD << endl;\n\treturn 0;\n}\n\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\nint N, M, mod, s[3009], rgt[3009], dp[3009][3009];\nchar sir[3009];\n\nvoid ad (int &i, int j)\n{\n    i += j;\n    if (i >= mod) i -= mod;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\\n\", &N, &M), mod = 1e9 + 7;\nscanf (\"%s\", sir + 1);\nfor (int i=1; i<=N; i++)\n    s[i] = s[i - 1] + (sir[i] == '1');\nfor (int i=1; i<=N; i++)\n    rgt[i] = i;\nwhile (M --)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    if (y > rgt[x]) rgt[x] = y;\n}\ndp[0][0] = 1;\nint R = 0;\nfor (int i=0; i<N; i++)\n{\n    for (int j=0; j<=R - i; j++)\n    if (dp[i][j])\n    {\n        //printf (\"primele %d si pe [%d, %d] inca %d de 1 -> %d\\n\", i, i + 1, R, j, dp[i][j]);\n        int k1 = j, k0 = (R - i) - j, mk0 = 0, mk1 = 0;\n        if (rgt[i + 1] > R) mk1 = s[rgt[i + 1]] - s[R], mk0 = rgt[i + 1] - R - mk1;\n        k0 += mk0, k1 += mk1;\n        if (k1 >= 1) ad (dp[i + 1][k1 - 1], dp[i][j]);\n        if (k0 >= 1) ad (dp[i + 1][k1], dp[i][j]);\n    }\n    if (rgt[i + 1] > R) R = rgt[i + 1];\n}\nprintf (\"%d\\n\", dp[N][0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n\n//#include \"IntMod.h\"\ntypedef IntMod<1000000007> MInt;\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) {\n\t//if (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn MInt(n).Fact() / (MInt(r).Fact() * MInt(n - r).Fact());\n}\n\nint main() {\n\t/* さすがに無理か？ */\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 3005, MOD = 1000000007;\ntypedef long long i64;\ni64 f[2][MAX_N];\nint L[MAX_N], R[MAX_N], C[MAX_N][MAX_N];\nchar s[MAX_N];\n\nint main() {\n  int N, M;\n  \n  scanf(\"%d%d\", &N, &M);\n  scanf(\"%s\", s + 1);\n  \n  for (int i = 1; i <= M; ++i) {\n    scanf(\"%d%d\", &L[i], &R[i]);\n    if (R[i] <= R[i - 1]) i--, M--;\n  }\n  \n  for (int i = 0; i <= N; ++i) {\n    C[i][0] = 1;\n    for (int j = 1; j <= i; ++j)\n      C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]);\n  }\n  \n  int o = 0, p;\n  R[0] = L[1] - 1, f[0][0] = 1, L[M + 1] = N + 1;\n  \n  for (int i = 1; i <= M; ++i) {\n    p = o, o ^= 1;\n    memset(f[o], 0, sizeof f[o]);\n    int num = 0;\n    for (int j = R[i - 1] + 1; j <= R[i]; ++j)\n      if (s[j] == '1') num++;\n    \n    int temp1 = R[i - 1] - L[i] + 1, temp2 = max(R[i] - L[i + 1] + 1, 0);\n    \n    for (int k1 = 0; k1 <= temp1; ++k1) {\n      int num1 = num + k1, num0 = R[i] - L[i] + 1 - num1;\n      for (int k2 = 0; k2 <= temp2; ++k2) {\n\tint rest1 = num1 - k2, rest0 = num0 - temp2 + k2;\n\tif (rest1 < 0 || rest0 < 0) continue;\n\tf[o][k2] = (f[o][k2] + C[rest1 + rest0][rest1] * f[p][k1] % MOD) % MOD;\n      }\n    }\n    if (R[i] < L[i + 1] - 1) R[i] = L[i + 1] - 1;\n  }\n\n  printf(\"%lld\\n\", f[o][0]);\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\ntemplate <typename T> inline bool chkmax(T &x, T y) {\n  return x<y? x=y, true : false;\n}\n\nenum {\n  MAXN = 3000 + 5,\n};\n\nconst int MOD = 1000000007;\n\nint n, m;\nchar s[MAXN];\n\nint dp[MAXN][MAXN];\nint pre[MAXN];\nint R[MAXN];\n\nvoid clear() {\n  int i;\n  for (i=0; i<MAXN; ++i)\n    R[i] = i+1;\n}\n\nvoid exec() {\n  int i, l, r, nj, j;\n  clear();\n  scanf(\"%d%d%s\", &n, &m, s);\n  for (i=0; i<m; ++i) {\n    scanf(\"%d%d\", &l, &r), --l;\n    chkmax(R[l], r);\n  }\n\n  for (i=1; i<n; ++i)\n    chkmax(R[i], R[i-1]);\n\n  R[n] = n;\n  for (i=0; i<n; ++i)\n    pre[i+1] = pre[i] + (s[i] == '1');\n\n  for (i=0; i<=R[0]; ++i)\n    dp[1][i] = (pre[R[0]] == i);\n  for (i=1; i<=n; ++i) {\n    for (j=1; j<=R[i-1]-(i-1); ++j) {\n      nj = j + pre[R[i]] - pre[R[i-1]] - 1;\n      (dp[i+1][nj] += dp[i][j]) %= MOD;\n    }\n    for (j=0; j< R[i-1]-(i-1); ++j) {\n      nj = j + pre[R[i]] - pre[R[i-1]];\n      (dp[i+1][nj] += dp[i][j]) %= MOD;\n    }\n  }\n  printf(\"%d\\n\", dp[n+1][0]);\n}\n\nint main() {\n  if (fopen(\"F.in\", \"r\") != NULL) {\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n  }\n  exec();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=3003,p=1000000007;\nint f[N][N],R[N],s[N],i,j,k,n,m,d,x;\nchar c;\n\ninline char getc()\n{\n\t#define VV 10000000\n\tstatic char s[VV],*l=s,*r=s;\n\tif (l==r)\n\t\tl=s,r=s+fread(s,1,VV,stdin);\n\treturn l==r?0:*l++;\n}\n\nint read(){ int z=0; do c=getc(); while (c<'0'||c>'9'); while (c>='0'&&c<='9') z*=10,z+=c-'0',c=getc(); return z; }\n\nvoid chkmax(int &a,int b){ a=a<b?b:a; }\n\nvoid Plus(int &a,int b){ a+=b,a-=a<p?0:p; }\n\nbool getC()\n{\n\tdo c=getc(); while (c<'0'||c>'1');\n\treturn c-'0';\n}\n\nint main()\n{\n\tn=read(),m=read();\n\tfor (i=1;i<=n;++i) R[i]=i,s[i]=s[i-1]+getC();\n\tfor (i=1;i<=m;++i) x=read(),chkmax(R[x],read());\n\td=R[1],f[1][s[d]]=1;\n\tfor (i=2;i<=n;++i)\n\t{\n\t\tfor (j=d-i+2;~j;--j)\n\t\t{\n\t\t\tint z=f[i-1][j];\n\t\t\tif (j<d-i+2)\n\t\t\t\tPlus(f[i][j],z);\n\t\t\tif (j)\n\t\t\t\tPlus(f[i][j-1],z);\n\t\t}\n\t\t\n\t\tif (d<R[i])\n\t\t{\n\t\t\tx=s[R[i]]-s[d],\n\t\t\td=R[i];\n\t\t\tfor (j=R[i]-i+1;j>=x;--j)\n\t\t\t\tf[i][j]=f[i][j-x];\n\t\t\tfill(f[i],f[i]+x,0);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(f[n][0]+f[n][1])%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nLL N, M;\nstring S;\nvector<LL>lef, rht;\n\nint dp[3456][10000];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> S;\n\tlef.push_back(0);\n\trht.push_back(0);\n\tfor (int i = 0; i < M; ++i)\n\t{\n\t\tLL l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tif (lef.back() == l)\n\t\t{\n\t\t\trht[rht.size() - 1] = max(rht.back(), r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(lef.back() < l);\n\t\t\tif (rht.back() < r)\n\t\t\t{\n\t\t\t\tlef.push_back(l);\n\t\t\t\trht.push_back(r);\n\t\t\t}\n\t\t}\n\t}\n\tif (rht[0] == 0)\n\t{\n\t\tlef.erase(lef.begin());\n\t\trht.erase(rht.begin());\n\t}\n\tvector<bool>flag(N);\n\tint K = lef.size();\n\tassert(K == rht.size());\n\tfor (int i = 0; i < K; ++i)\n\t{\n\t\tfor (int j = lef[i]; j < rht[i]; ++j)\n\t\t{\n\t\t\tflag[j] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tif (!flag[i])\n\t\t{\n\t\t\tlef.push_back(i);\n\t\t\trht.push_back(i + 1);\n\t\t}\n\t}\n\tsort(lef.begin(), lef.end());\n\tsort(rht.begin(), rht.end());\n\n\t//rendを求める\n\tvector<LL>rend(N);\n\tfor (LL ll : lef)rend[ll]++;\n\tfor (int i = 1; i < N; ++i)rend[i] += rend[i - 1];\n\tfor (int i = 0; i < N; ++i)rend[i] = rht[rend[i] - 1];\n\trend.push_back(rend.back());\n\n\t//oneを求める\n\tvector<LL>one;\n\tone.push_back(0);\n\tfor (char c : S)one.push_back(c - '0');\n\tfor (int i = 0; i < N; ++i)one[i + 1] += one[i];\n\n\tconst LL MOD = 1000000007;\n\t//仮想的にdp[-1][0] = 1,dp[-1][n] = 0と置く\n\tdp[0][one[rend[0]]] = 1;\n\t//配るDP\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tLL P = one[rend[i + 1]] - one[rend[i]];\n\t\tfor (int j = 0; j <= N; ++j)\n\t\t{\n\t\t\tint jj = j + P;\n\t\t\tif (j > 0)\n\t\t\t{\n\t\t\t\tdp[i + 1][jj - 1] += dp[i][j];//1\n\t\t\t\tdp[i + 1][jj - 1] %= MOD;\n\t\t\t}\n\t\t\tif (rend[i] - i - j > 0)\n\t\t\t{\n\t\t\t\tdp[i + 1][jj] += dp[i][j];//0\n\t\t\t\tdp[i + 1][jj] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tLL ans = dp[N][0];\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    REP(i, M){\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        int t = n1[rmax + 1];\n        if(l1 <= rmax){\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            REP(k, t + 1){\n                dp[i + 1][t] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][t] %= mod;\n            }\n        }\n    }\n    //debug(dp);\n    cout << dp[M][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass CumulativeSum{\npublic:\n  vector<int> sum;\n  CumulativeSum(){}\n  CumulativeSum(vector<int> A){\n    int n = A.size();\n    sum.resize(n+1,0);\n    for(int i=1;i<=n;i++) sum[i] += sum[i-1] + A[i-1];\n  }\n  int get(int l,int r){assert(l>=0 && r<=(int)sum.size());return sum[r] - sum[l];} //[l,r)\n};\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nll divi(ll a,ll b){\n  return a * mod_pow(b,mod-2) % mod;\n}\n\nll factorial(int i){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n  return k[i];\n}\n\nll nCr(ll n,ll r){\n  ll a = mod_pow( factorial(r) * factorial(n-r) % mod ,mod-2);\n  return factorial(n) * a % mod;\n}\n\nconst int N = 3010;\nCumulativeSum sum0,sum1;\nint n,m;\nvector<P> A;\nint mem[N][N],used[N][N];\n\nint dfs(int idx,int cnt0,int cnt1,int overlap){\n  //pr(idx,cnt0,cnt1,overlap);\n  if(used[idx][cnt0]++) return mem[idx][cnt0];\n  int l,r; tie(l,r) = A[idx];\n  int len = r - l + 1;\n  int zero = cnt0 + sum0.get(l+overlap, r+1);\n  int one = cnt1 + sum1.get(l+overlap, r+1);\n  assert(zero + one == len);\n  if(idx == m-1) return mem[idx][cnt0] = nCr(len, zero);\n\n\n\n  int res = 0;  \n  int noverlap = r - A[idx+1].first + 1;\n  // pr(len,zero,one,noverlap);\n\n  if(noverlap <= 0){\n    int a = nCr(len, zero);\n    int b = dfs(idx+1,0,0,0);\n    res = a * b % mod;\n  }\n  else {\n    for(int i = 0;i<=noverlap; i++){ //overlapしてない区間の0の数\n      int ncnt0 = i;\n      int ncnt1 = (noverlap - i);\n      if(zero < ncnt0 ||  one < ncnt1) continue;\n      int a = nCr(len - noverlap, zero - i);\n      int b = dfs(idx+1, ncnt0, ncnt1, noverlap);\n      //pr(i,ncnt0,ncnt1,a,b);\n      res += a * b;\n      res %= mod;\n    }\n  }\n  return mem[idx][cnt0] = res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n>>m;\n  string str;\n  cin>>str;\n  {\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) tmp[i] = str[i] == '0';\n    sum0 = CumulativeSum(tmp);\n    \n  }\n\n  {\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) tmp[i] = str[i] == '1';\n    sum1 = CumulativeSum(tmp);\n  }\n  \n  {\n    \n    int pre = -1;\n      for(int i=0;i<m;i++){\n        int l,r;\n        cin>>l>>r; l--, r--;\n        if(pre<r) {\n          while(!A.empty() && A.back().first == l) A.pop_back();\n          A.push_back(P(l,r));\n        }\n        Max(pre,r);\n      }\n      m = A.size();\n  }\n\n  //pr(A);\n  int ans = dfs(0,0,0,0);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)x.size()\n#define f first\n#define s second\n#define MAXN 3010\nll MOD = 1e9+7;\n\nint A[MAXN];\nint N,K,a,b;\nint E[MAXN];\nstring S;\nvpi V;\nint memo[MAXN][MAXN];\nint overlap[MAXN];\nll fact[MAXN];\nll invfact[MAXN];\n\nll exp(ll a, ll b){\n\tif (b==0)return 1;\n\tll c = exp(a,b/2);\n\tc = (c*c)%MOD;\n\tif (b%2)c=(c*a)%MOD;\n\treturn c;\n}\n\nll inv(ll x){\n\treturn exp(x, MOD-2);\n}\n\nll C(ll a, ll b){\n\treturn (fact[a] * invfact[a-b]) %MOD * invfact[b]%MOD;\n}\n\nint main(){\n\tcin>>N>>K>>S;\n\tfact[0] = 1;\n\tfor (int i=1;i<=N;++i)fact[i] = (fact[i-1]*i)%MOD;\n\tfor (int i=0;i<=N;++i)invfact[i] = inv(fact[i]);\n\n\tfor (int i=1;i<=N;++i){\n\t\tif (S[i-1] == '1')A[i] = 1;\n\t\tA[i] += A[i-1];\n\t}\n\tfor (int i=0;i<K;++i){\n\t\tcin>>a>>b;\n\t\tE[a] = max(E[a], b);\n\t}\n\tV.pb(-1,-1);\n\tfor (int i=1;i<=N;++i)if(E[i]){\n\t\tif (SZ(V) && V.back().s >= E[i])continue;\n\t\tV.pb(i,E[i]);\n\t}\n\tfor (int i=1;i<SZ(V)-1; ++i){\n\t\toverlap[i] = max(0LL,V[i].s - V[i+1].f + 1);\n\t}\n\n\t// for (int i=1;i<SZ(V);++i)cout<<overlap[i]<<' ';\n\t// cout<<'\\n';\n\n\tmemo[0][0] = 1;\n\tfor (int i=1;i<SZ(V);++i){\n\t\t// cout<<\"Hi\\n\";\n\t\tint s = V[i-1].s+1;\n\t\tint e = V[i].s;\n\t\t// cout<<\"R \"<<s<<' '<<e<<' '<<A[e]-A[s-1]<<'\\n';\n\t\tint l = V[i].s - V[i].f + 1;\n\t\tfor (int j=0;j<=overlap[i-1];++j){\n\t\t\tfor (int k=0;k<=overlap[i];++k){\n\t\t\t\tint ones = j + A[e] - A[s-1];\n\t\t\t\t// cout<<ones<<'\\n';\n\t\t\t\tint zeroes = l - ones;\n\t\t\t\tif (ones < k)continue;\n\t\t\t\tif (zeroes + k > l)continue;\n\t\t\t\tmemo[i][k] += (memo[i-1][j] * C(l-overlap[i], ones-k))%MOD;\n\t\t\t\tmemo[i][k]%=MOD;\n\t\t\t}\n\t\t}\n\t\t// for (int k=0;k<=overlap[i];++k)cout<<memo[i][k]<<' ';cout<<'\\n';\n\t}\n\tll ans =0;\n\tfor (int k=0;k<=overlap[SZ(V) - 1];++k)ans=(ans+memo[SZ(V)-1][k])%MOD;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=acos(-1.0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll par[800010];\nll len[800010];\nll you[800010];\nvoid init(ll n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    len[i]=0;\n    you[i]=1;\n  }\n}\nll root(ll n){\n  if(par[n]==n)return n;\n  return par[n]=root(par[n]);\n}\nvoid unit(ll a,ll b){\n  a=root(a);\n  b=root(b);\n  if(a==b)return;\n  if(len[a]<len[b]){\n    par[a]=b;\n    you[b]+=you[a];\n  }\n  else{\n    par[b]=a;\n    you[a]+=you[b];\n    if(len[a]==len[b])len[a]++;\n  }\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n,m;cin>>n>>m;\n    string s;cin>>s;\n    ll ma[n+1];\n    rep(i,0,n+1)ma[i]=i;\n    rep(i,0,m){\n        ll l,r;cin>>l>>r;\n        ma[l]=max(ma[l],r);\n    }\n    rep(i,1,n+1){\n        ma[i]=max(ma[i],ma[i-1]);\n    }\n    ll cn[n+1];\n    cn[0]=0;\n    rep(i,0,n){\n        if(s[i]=='0')cn[i+1]=cn[i]+1;\n        else cn[i+1]=cn[i];\n    }\n    ll ze=cn[n];\n    ll dp[n+1][ze+1];\n    memset(dp,0,sizeof dp);\n    dp[0][0]=1;\n    rep(i,0,n){\n        rep(j,0,ze+1){\n            if(dp[i][j]==0)continue;\n            ll maa=ma[i+1];\n            ll oj=i-j;\n            ll zz=cn[maa]-j;\n            ll zo=maa-cn[maa]-oj;\n            if(zz>0){\n                (dp[i+1][j+1]+=dp[i][j])%=mod;\n            }\n            if(zo>0){\n                (dp[i+1][j]+=dp[i][j])%=mod;\n            }\n        }\n    }\n    cout<<dp[n][ze]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll M = 1000000007;\nchar str[3010];\nint n, m, c = 1, sum[3010], s[3010], e[3010];\nll dp[3010][3010], cm[3010][3010], chk[3010][3010];\n\nint get(int s, int e){ return sum[e] - sum[s - 1]; }\n\nll f(int x, int y){\n\tif(x > m) return 1;\n\tif(y < 0 || e[x] - s[x] + 1 < y) return 0;\n\tif(chk[x][y]) return dp[x][y];\n\tif(e[x] < s[x + 1]){\n\t\tdp[x][y] = cm[e[x] - s[x] + 1][y] * f(x + 1, get(s[x + 1], e[x + 1]));\n\t}\n\telse{\n\t\tfor(int i = max(0, y - (e[x] - s[x + 1] + 1)); i <= min(s[x + 1] - s[x], y); i++){\n\t\t\tdp[x][y] = (dp[x][y] + cm[s[x + 1] - s[x]][i] *\n\t\t\t\t\t\tf(x + 1, y - i + get(e[x] + 1, e[x + 1]))) % M;\n\t\t}\n\t}\n\tchk[x][y] = 1;\n\treturn dp[x][y];\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, str + 1);\n\tfor(int i = 1; i <= n; i++) sum[i] = sum[i - 1] + (str[i] == '1');\n\tfor(int x, y, l = 0; m--; ){\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(y <= l) continue;\n\t\tl = y;\n\t\tif(s[c - 1] == x) e[c - 1] = y;\n\t\telse{\n\t\t\ts[c] = x; e[c] = y;\n\t\t\tc++;\n\t\t}\n\t}\n\tm = c - 1;\n\ts[m + 1] = n + 1;\n\tfor(int i = 0; i <= n; i++){\n\t\tcm[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++) cm[i][j] = (cm[i - 1][j - 1] + cm[i - 1][j]) % M;\n\t}\n\tprintf(\"%lld\\n\", f(1, get(s[1], e[1])));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nlong long n,m,i,j,dp[3005][3005],l[3005],r[3005],mod=1000000007,cnt[3005],x,y;\nstring st;\nint main()\n{\n\tcin>>n>>m>>st;\n\tst=\" \"+st;\n\tfor (i=1;i<=n;i++) \n\t{\n\t\tcnt[i]=cnt[i-1]+st[i]-'0';\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tl[i]=i;\n\t\tr[i]=i;\n\t}\n\tfor (i=1;i<=m;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tr[x]=max(r[x],y);\n\t}\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tr[i]=max(r[i],r[i-1]);\n\t}\n\tdp[0][0]=1;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tfor (j=0;j<=r[i];j++)\n\t\t{\n\t\t\tif (j>cnt[r[i]]) break;\n\t\t\tif (j>=cnt[r[i]]-r[i]+i)\n\t\t\t{\n\t\t\t\tdp[i][j]=dp[i-1][j]+dp[i-1][j-1];\n\t\t\t\tdp[i][j]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][cnt[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=3010;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N,M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> sum(N+1,0);\n    for (int i=0;i<N;++i) sum[i+1]=sum[i]+(S[i]-'0');\n    vector<pair<int,int>> sec;\n    for (int i=0;i<M;++i){\n        int l,r; cin >> l >> r; --l,--r;\n        if (!sec.empty()&&sec.back().second>=r) continue;\n        if (!sec.empty()&&sec.back().first==l) sec.pop_back();\n        sec.emplace_back(l,r);\n    }\n    int m=sec.size();\n    vector<vector<mint>> dp(m+1,vector<mint>(N+1,0));\n    dp[0][0]=1;\n    mint ans=0;\n    int prel=-1,prer=-1;\n    for (int i=0;i<m;++i){\n        int l=sec[i].first,r=sec[i].second;\n        int nxt=(!i?0:min(l,prer+1)-prel),add=sum[r+1]-sum[max(prer+1,l)],rest=max(0,prer-l+1);\n        for (int j=0;j<=N;++j){\n            if (dp[i][j]==0) continue;\n            for (int k=0;k<=min(j,nxt);++k){\n                if (j-k<=rest) dp[i+1][j+add-k]+=dp[i][j]*COM(nxt,k);\n            }\n        }\n        if (i==m-1) for (int j=0;j<=N;++j){\n            ans+=dp[i+1][j]*COM(r-l+1,j);\n        }\n        prel=l,prer=r;\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define countof(a) (sizeof(a)/sizeof(*a))\n\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vpi vector<pi >\n#define pi pair<int,int>\n#define fi first\n#define se second\n#define all(n) n.begin(), n.end()\n\n#define FROMTO(var, from, to) for (register int var = (from), var##down = ((int)(to)) < ((int)(from));var##down ? (var >= (int)(to)) : (var <= (int)(to));var##down ? var-- : var++)\n#define UPTO(var, from, to)   for (register int var = (from); var <= ((int)to); var++)\n#define DOWNTO(var, from, to) for (register int var = (from); var >= ((int)to); var--)\n#define FOR(var, to)          UPTO(var, 0, (to)-1)\n#define DOWN(var, from)       DOWNTO(var, (from)-1, 0) \n\n#define INIT(var, val) FOR(i,countof(var)) var[i] = val\n#define INPUT(var) FOR(i,countof(var)) cin >> var[i]\n#define INPUT1(var) FOR(i,countof(var)) cin >> var[i], var[i]--\n\n#define SORT(v) qsort(v,countof(v),sizeof(*v),int_less)\n#define SORTT(v) qsort(v,countof(v),sizeof(*v),int_greater)\n#define QSORT(v,b) qsort(v,countof(v),sizeof(*v),b)\n\n#define MOD 1000000007\n#define INF ((1 << 30)-1)\n#define LINF ((1LL << 62)-1)\n\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t s8;\ntypedef int16_t s16;\ntypedef int32_t s32;\ntypedef int64_t s64;\n\n/* ------------------------ */\n/* BEGIN EXTERNAL LIBRARIES */\n/* ------------------------ */\n\ntemplate<int mod>\nstruct ModInt{\n    int x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=mod-p.x)>=mod)x-=mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1LL*x*p.x%mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        *this*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(-x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    bool operator==(const ModInt &p)const{return x==p.x;}\n    bool operator!=(const ModInt &p)const{return x!=p.x;}\n    operator int() const { return x; }                           // added by QCFium\n    ModInt operator=(const int p) {x = p; return ModInt(*this);} // added by QCFium\n    ModInt inverse()const{\n        int a=x,b=mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            a-=t*b;\n            swap(a,b);\n            u-=t*v;\n            swap(u,v);\n        }\n        return ModInt(u);\n    }\n    friend ostream &operator<<(ostream &os,const ModInt<mod> &p){\n        return os<<p.x;\n    }\n    friend istream &operator>>(istream &is,ModInt<mod> &a){\n        long long x;\n        is>>x;\n        a=ModInt<mod>(x);\n        return (is);\n    }\n};\ntypedef ModInt<MOD> mint;\n\nstruct UnionFind{\n    vi data;\n    UnionFind(int size):data(size,-1){}\n    bool unite(int x,int y) {\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    bool find(int x,int y) {\n        return root(x)==root(y);\n    }\n    int root(int x) {\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // added by QCFium\n    bool united() {\n        int comroot = -1;\n        FOR(i,data.size()) {\n            if (comroot != -1 && root(i) != comroot) return false;\n            comroot = root(i);\n        }\n        return true;\n    }\n};\n\n/* ---------------------- */\n/* END EXTERNAL LIBRARIES */\n/* ---------------------- */\n\nint mpow(s64 num, s64 times) { // O(log(times))\n    mint next = num%MOD;\n\tmint res = 1;\n\twhile (times) {\n\t\tif (times%2)\n            res *= next;\n\t\tnext *= next;\n\t\ttimes /= 2;\n\t}\n\treturn res;\n}\n\nstruct Comb {\n    vector<vector<s64> > data;\n    Comb(int n) { // O(n^2)\n        data = vector<vector<s64> >(n+1,vector<s64>(n+1,1));\n        UPTO(i,1,n) {\n            FOR(j,i+1) {\n                if (!j || j == i) data[i][j] = 1;\n                else data[i][j] = data[i-1][j-1] + data[i-1][j];\n            }\n        }\n    }\n    \n    s64 ncr(int n, int r) {\n        return data[n][r];\n    }\n};\n\nstruct MComb {\n    vector<mint> fact;\n    vector<mint> inversed;\n    MComb(int n) { // O(n+log(mod))\n        fact = vector<mint>(n+1,1);\n        UPTO(i,1,n) fact[i] = fact[i-1]*mint(i);\n        inversed = vector<mint>(n+1);\n        inversed[n] = mpow(fact[n], MOD-2);\n        DOWN(i,n) inversed[i]=inversed[i+1]*mint(i+1);\n    }\n    \n    int ncr(int n, int r) {\n        return fact[n] * inversed[r] * inversed[n-r];\n    }\n    \n    int npr(int n, int r) {\n        return fact[n] * inversed[n-r];\n    }\n    \n    int nhr(int n, int r) {\n        assert(n+r-1 < (int)fact.size());\n        return ncr(n+r-1, r);\n    }\n};\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+(set<Key>& a, set<Key>& b) {\n    set<Key> c = a;\n    for (auto i : b) \n        c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator+=(set<Key>& a, set<Key>& b) {\n    for (auto& i : b)\n        a.insert(i);\n    return a;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator*=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return c;\n}\ntemplate<class Key, class Compare = less<Key>, class Allocator = allocator<Key>>\nset<Key> operator-=(set<Key>& a, set<Key>& b) {\n    set<Key> c;\n    for (auto& i : a)\n        if (!b.count(i)) c.insert(i);\n        \n    return a = c;\n}\n\nstatic inline int ri() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\n\nint int_less(const void *a, const void *b) {\n  return (*((const int*)a) - *((const int*)b));\n}\nint int_greater(const void *a, const void *b) {\n  return (*((const int*)b) - *((const int*)a));\n}\n\nint main() {\n    int n = ri();\n\tint m = ri();\n\tbool a[n];\n\t{\n\t\tstring s; cin >> s;\n\t\tFOR(i,n) a[i] = s[i]=='1';\n\t}\n\t\n\tvector<pi > lr;\n\tFOR(i,m) {\n\t\tint l = ri()-1;\n\t\tint r = ri()-1;\n\t\tif (!lr.size() || r > lr.back().se) lr.push_back(pi(l,r));\n\t}\n\t\t\n\tMComb com(3001);\n\t// sum\n\tint sum[n];\n\tsum[0] = a[0];\n\tFROMTO(i,1,n-1) sum[i] = sum[i-1] + a[i];\n\t\n\tvector<mint> dp;\n\tdp = vector<mint>(1,1);\n\t\n\tint minn = 0;\n\t\n\tint r = lr[0].fi-1;\n\tFOR(i,lr.size()) {\n\t\tif (r < lr[i].fi) {\n\t\t\t// just to be safe\n\t\t\tr = lr[i].fi-1;\n\t\t\tminn = 0;\n\t\t\tassert(dp.size() == 1);\n\t\t}\n\t\t\n\t\tif (i == (int)lr.size()-1 || lr[i+1].fi > lr[i].se) { // reset\n\t\t\t// cout << \"i:\" << i << \" min:\" << minn << \" not covered\" << endl;\n\t\t\tFOR(j,dp.size()){\n\t\t\t\t// cout << \"    j:\" << j << \" dp[j]:\" << dp[j] << endl;\n\t\t\t}\n\t\t\tint base = sum[lr[i].se] - (r<0?0:sum[r]) + minn;\n\t\t\tint range = lr[i].se - lr[i].fi + 1;\n\t\t\tmint tmp = 0;\n\t\t\tFOR(j,dp.size()) {\n\t\t\t\ttmp += dp[j]*(mint)com.ncr(range,base+j);\n\t\t\t}\n\t\t\tdp.resize(1);\n\t\t\tdp[0] = tmp;\n\t\t\tminn = 0;\n\t\t\tif (i < (int)lr.size()-1) r = lr[i+1].fi-1;\n\t\t} else {\n\t\t\tint base = sum[lr[i].se] - (r<0?0:sum[r]) + minn;\n\t\t\tint left = lr[i+1].fi - lr[i].fi;\n\t\t\tint right = lr[i].se - lr[i+1].fi + 1;\n\t\t\t// cout << \"i:\" << i << \" left:\" << left << \" right:\" << right << \" base:\" << base << endl;\n\t\t\tvector<mint> dp_new(min(right,(int)(base+dp.size()-1))-max(0,base-left)+1,0);\n\t\t\t// cout << \"dp_new size:\" << dp_new.size() << endl;\n\t\t\tFOR(j,dp.size()) {\n\t\t\t\tif (!j) minn = max(0,base+j-left);\n\t\t\t\tint maxx = min(right,base+j);\n\t\t\t\t// cout << \"i:\" << i << \" j:\" << j << \" min:\"<<max(0,base+j-left) << \" max:\" << maxx << endl;\n\t\t\t\tFROMTO(k,max(0,base+j-left),maxx) {\n\t\t\t\t\tmint next = com.ncr(left,base+j-k)*dp[j];\n\t\t\t\t\tdp_new[k-minn] += next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp_new;\n\t\t\tr = lr[i].se;\n\t\t}\n\t}\n\tcout << dp[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 3010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    for(i = 1; i <= n; ++i){\n        scanf(\"%1d\", a + i);\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j){\n            if(j > R){\n                R = j;\n                ad = a[j];\n            }\n            else ad = 0;\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad = sum[r] - sum[R];\n            R = r;\n        }\n        else ad = 0;\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j){\n        if(j > R){\n            R = j;\n            ad = a[j];\n        }\n        else ad = 0;\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n// #define dump(x)  cerr << #x << \" = \" << (x) << endl\n\n// #ifndef ONLINE_JUDGE\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << ' ' << H; debug_out(T...); }\n#define debug(...) cerr << 'L' << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << 'L' << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    int &l = lm[i];\n    int &r = rm[i];\n    rep(j, l+1) tmp[l+1] += dp[j];\n    rep2(j, l+1, r+1) tmp[j+1] = tmp[j] + dp[j];\n    swap(dp, tmp);\n    debug(dp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 6005;\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nll comb(int a,int b)\n{\n\tif(a<b){\n\t\treturn 0;\n\t}\n\treturn fac[a] * (finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint s0[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    make();\n    vp vec(m+1);\n    rep(i,m){\n        cin >> vec[i].fi >> vec[i].se;\n        --vec[i].fi,--vec[i].se;\n    }\n    rep(i,n){\n        if(s[i] == '0'){\n            s0[i+1] = s0[i] + 1;\n        }else{\n            s0[i+1] = s0[i];\n        }\n    }\n    int nw=0,l = vec[nw].fi,r = vec[nw].se;\n    vp data;\n    data.pb(P(s0[r+1]-s0[l],1));\n    vec[m] = P(n,n);\n    srep(i,1,m+1){\n        // show(i);\n        // show(nw);\n        // svecp(data);\n        if(vec[i].se <= r){\n            continue;\n        }\n        if(r < vec[i].fi){\n            ll val = 0;\n            rep(j,len(data)){\n                ll zero = data[j].fi;\n                ll al = r-l+1;\n                val = add(val,mul(data[j].se,comb(al,zero)));\n            }\n            nw = i,l = vec[nw].fi,r = vec[nw].se;\n            vp hoge;\n            hoge.pb(P(s0[r+1]-s0[l],val));\n            data = hoge;\n            continue;\n        }\n        //重なり\n        int lm = r-vec[i].fi+1;\n        //右の覆われていない部分の0の個数\n        int sm = s0[vec[i].se+1] - s0[r+1];\n        // cout << vec[i].se << \" \" << r << \" \" << sm << \"\\n\";\n        vector<int> nx(s0[vec[i].se+1] - s0[vec[i].fi+1]+2,0);\n        rep(j,len(data)){\n            int cnt = data[j].fi;\n            int leng = vec[i].fi - l;\n            int mn = max(cnt-leng,0);\n            int mx = min(cnt,lm);\n            // show(mn),show(mx);\n            srep(k,mn,mx+1){\n                nx[sm+k] = add(nx[sm+k],mul(comb(leng,cnt-k),data[j].se));\n            }\n        }\n        vp hoge;\n        rep(j,len(nx)){\n            if(nx[j]){\n                hoge.pb(P(j,nx[j]));\n            }\n        }\n        data = hoge;\n        nw = i,l = vec[nw].fi,r = vec[nw].se;\n    }\n    cout << data[0].se << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3001\n#define MOD 1000000007\n#define int ll\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\n\npi A[maxn];\nint fac[maxn];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = (res*x) % MOD;  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn (a * qexp(b,MOD-2)) % MOD;\n}\n\nint choose(int n,int k){\n\tif (n < k) return 0;\n\treturn modinv(fac[n],(fac[k] * fac[n-k]) % MOD);\n}\n\ninline int qry(pi i){\n\tint a = i.f, b = i.s;\n\tif (a == 0) return ss[b];\n\treturn ss[b] - ss[a-1];\n}\n\n\nint dpf(int i,int j){\n\tif (dp[i][j] != -1) return dp[i][j];\n\t\n\tif (i == M) return 1;\n\t\n\tdp[i][j] = 0;\n\t\n\tif (i == M-1){\n\t\tif (i == 0){\n\t\t\tdp[i][j] = choose(sz(A[i]),qry(A[i]));\n\t\t\treturn dp[i][j];\n\t\t}\n\t\tdp[i][j] = choose(sz(A[i]),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\t//cout<<dp[i][j]<<'\\n';\n\t\t//cout<<j<<' '<<sz(A[i])<<' '<<qry(pi(A[i-1].s + 1,A[i].s)) + j<<'\\n';\n\t\treturn dp[i][j];\n\t}\n\t\n\tint mxsize;\n\tint sm;\n\tif (i > 0){\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\tsm = qry(pi(A[i-1].s + 1,A[i].s)) + j;\n\t}else{\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(A[i]));\n\t\tsm = qry(A[i]);\n\t}\n\t\n\tFOR(k,0,mxsize){\n\t\tdp[i][j] += (dpf(i+1,k) * choose(sz(A[i]) - sz(inter(A[i],A[i+1])),sm - k)) % MOD;\n\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\t\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,N){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\tmem(dp,-1);\n\t\t\t\n\tcout<<dpf(0,0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cmath>\n#include<set>\nusing namespace std;\nconst int64_t mod = 1e9+7;\nint64_t dp[3001][3001]={};\nint64_t factorial[3010]={};\nint64_t mod_pow(int64_t n,int64_t x){//nをx乗\n    if(x%2==0){\n        if(x==0){\n            return 1;\n        }else{\n            int64_t z=mod_pow(n,x/2);\n            return (z*z)%mod;\n        }\n    }else{\n        if(x==1){\n            return n;\n        }else{\n            int64_t z=mod_pow(n,(x-1)/2);\n            return (z*((z*n)%mod))%mod;\n        }\n    }\n}\nint64_t comb(int64_t A,int64_t B){\n    if(B==0||B==A){\n        return 1;\n    }\n    int64_t res = factorial[A]*(mod_pow( factorial[B] , mod-2 ) * mod_pow( factorial[A-B] , mod-2 )%mod)%mod;\n    return res;\n}\nint main(){\n    int N,M;\n    string str;\n    cin>>N>>M;\n    cin>>str;\n    int num1[3001]={};//1,2,3,4と添え字を使う\n    for(int i=1;i<=N;i++){\n        if(str[i-1]=='1'){\n            num1[i]=num1[i-1]+1;\n        }else{\n            num1[i]=num1[i-1];\n        }\n    }\n    int L,R;\n    int num_of_1;\n    factorial[0]=1;\n    for(int i=1;i<3010;i++){\n        factorial[i]=factorial[i-1]*i%mod;\n    }\n    for(int k=0;k<M;k++){\n        int l,r;\n        cin>>l>>r;\n        if(k==0){\n            L=l;\n            R=r;\n            num_of_1 = num1[R]-num1[L-1];\n            dp[0][num_of_1]++;\n        }else{\n            if(r > R){\n                if(R<l){\n                    int64_t tmp=0;\n                    for(int i=0;i<=R-L+1;i++){\n                        tmp = (tmp + dp[k-1][i]*comb(R-L+1,i)%mod ) %mod;\n                    }\n                    num_of_1=num1[r]-num1[l-1];\n                    dp[k][num_of_1]=tmp;\n                    R=r;\n                    L=l;\n                }else{\n                    num_of_1 = num1[r]-num1[R];\n                    for(int i=0;i<=R-L+1;i++){//1がi個、0がR-L+1-i個、長さl-Lの順列の作り方\n                        for(int j=0;j<=min(i,l-L);j++){//1を使う数\n                            dp[k][i+num_of_1-j] = (dp[k][i+num_of_1-j] + dp[k-1][i] * comb(l-L,j))%mod;\n                        }\n                    }\n                    L=l;\n                    R=r;\n                }\n            }\n        }\n    }\n    int64_t res=0;\n    for(int i=0;i<=R-L+1;i++){\n        res = (res + dp[M-1][i]*comb(R-L+1,i)%mod)%mod;\n    }\n    cout<<res<<endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <sstream>\n#include <set>\nusing namespace std;\nusing ll = long long;\n\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\n\nconst int MOD = 1000*1000*1000+7;\nint add(int a, int b) { return ((ll)a+b)%MOD; }\nint mul(int a, int b) { return ((ll)a*b)%MOD; }\nvoid chadd(int& a, int b) { a = ((ll)a+b)%MOD; }\n\nstruct I {\n  int lo, hi;\n};\nbool include(I i1, I i2) {\n  return i1.lo <= i2.lo && i2.hi <= i1.hi;\n}\n\nint combin[3020][3020];\nint dp[3020][3020];\n\nint main() {\n  combin[0][0] = 1;\n  for (int i : range(1, 3010)) {\n    combin[i][0] = combin[i][i] = 1;\n    for (int j : range(1, i)) {\n      combin[i][j] = (combin[i-1][j-1] + combin[i-1][j])%MOD;\n    }\n  }\n\n  int N, M;\n  while (cin >> N >> M) {\n    string s; cin >> s;\n    vector<I> vi(M), vi2;\n    for (int i : range(M)) {\n      cin >> vi[i].lo >> vi[i].hi;\n      vi[i].lo--;\n      vi[i].hi--;\n    }\n    vi2.push_back(I{-1, -1});\n    // erase redundant elements\n    for (int i : range(M)) {\n      if (!include(vi2.back(), vi[i])) {\n        vi2.push_back(vi[i]);\n        // cout<<\"##\"<<endl;\n      }\n    }\n    vi = vi2;\n    M = vi.size();\n\n    for (int i : range(M)) {\n      //cout << \"#\" << vi[i].lo <<\" \" << vi[i].hi<<endl;\n    }\n\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int i : range(1, M)) {\n      int len = vi[i].hi + 1 - vi[i].lo;\n      int l = (i < M - 1)\n            ? (min(vi[i + 1].lo, vi[i].hi + 1) - vi[i].lo)\n            : len;\n      int m = max(vi[i - 1].hi - vi[i].lo + 1, 0);\n\n      int t = 0;\n      for (int j : range(len - m)) {\n        t += s[vi[i].lo + m + j] - '0';\n      }\n\n      for (int ones : range(0, len - l + 1)) {\n        for (int pones : range(max(0, ones - t), m + 1)) {\n          // pones + t - ones >= 0\n          if (pones + t - ones > l) break;\n\n          int val = mul(dp[i - 1][pones], combin[l][pones + t - ones]);\n          chadd(dp[i][ones], val);\n        }\n      }\n    }\n    \n    int res = 0;\n    for (int ones : range(N + 1)) chadd(res, dp[M - 1][ones]);\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint N, M;\nstring S;\nint dp[3001][3001];\n\nint OneMin[3001], OneMax[3001];\nint ZerMin[3001], ZerMax[3001];\nint sum[3001];\nint l[3001], r[3001];\n\nbool check(int idx, int OneBit)\n{\n  return (OneMin[idx] <= OneBit && OneBit <= OneMax[idx]);\n}\n\nvoid smallProblem()\n{\n  string T = S;\n  for(int i = M - 1; i >= 0; i--) {\n    int One = 0;\n    for(int j = l[i]; j < r[i]; j++) One += T[j] == '1';\n    for(int j = l[i]; j < r[i]; j++) {\n      if(One > 0) T[j] = '1';\n      else T[j] = '0';\n      --One;\n    }\n  }\n  int sum = 0;\n  for(int i = 0; i < N; i++) {\n    sum += T[i] == '1';\n    OneMax[i] = sum;\n  }\n\n  T = S;\n  for(int i = M - 1; i >= 0; i--) {\n    int One = 0;\n    for(int j = l[i]; j < r[i]; j++) One += T[j] == '1';\n    for(int j = r[i] - 1; j >= l[i]; j--) {\n      if(One > 0) T[j] = '1';\n      else T[j] = '0';\n      --One;\n    }\n  }\n  sum = 0;\n  for(int i = 0; i < N; i++) {\n    sum += T[i] == '1';\n    OneMin[i] = sum;\n  }\n\n\n  T = S;\n  for(int i = M - 1; i >= 0; i--) {\n    int One = 0;\n    for(int j = l[i]; j < r[i]; j++) One += T[j] == '0';\n    for(int j = l[i]; j < r[i]; j++) {\n      if(One > 0) T[j] = '0';\n      else T[j] = '1';\n      --One;\n    }\n  }\n  sum = 0;\n  for(int i = 0; i < N; i++) {\n    sum += T[i] == '1';\n    OneMax[i] = max(OneMax[i], sum);\n  }\n\n  T = S;\n  for(int i = M - 1; i >= 0; i--) {\n    int One = 0;\n    for(int j = l[i]; j < r[i]; j++) One += T[j] == '0';\n    for(int j = r[i] - 1; j >= l[i]; j--) {\n      if(One > 0) T[j] = '0';\n      else T[j] = '1';\n      --One;\n    }\n  }\n  sum = 0;\n  for(int i = 0; i < N; i++) {\n    sum += T[i] == '1';\n    OneMin[i] = min(sum, OneMin[i]);\n  }\n}\n\nint main()\n{\n  cin >> N >> M;\n  cin >> S;\n  for(int i = 0; i < M; i++) {\n    cin >> l[i] >> r[i];\n    --l[i];\n  }\n\n  smallProblem();\n  dp[0][1] = check(0, 1);\n  dp[0][0] = check(0, 0);\n  for(int i = 0; i < N - 1; i++) {\n    for(int j = 0; j <= N; j++) {\n      if(dp[i][j] == 0) continue;\n      if(check(i + 1, j + 1)) dp[i + 1][j + 1] += dp[i][j];\n      if(check(i + 1, j)) dp[i + 1][j] += dp[i][j];\n      dp[i + 1][j + 1] %= mod;\n      dp[i + 1][j] %= mod;\n    }\n  }\n  cout << dp[N - 1][count(begin(S), end(S), '1')] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define times(n, i)      uptil(0, n, i)\n#define rtimes(n, i)     downto((n) - 1, 0, i)\n#define upto(f, t, i)    for(auto i##0_to = (t), i = decltype(t)(f); i <= i##0_to; i++)\n#define uptil(f, t, i)   for(auto i##0_to = (t), i = decltype(t)(f); i <  i##0_to; i++)\n#define downto(f, t, i)  for(auto i##0_to = decltype(f)(t), i = (f); i >= i##0_to; i--)\n#define downtil(f, t, i) for(auto i##0_to = decltype(f)(t), i = (f); i >  i##0_to; i--)\n/** types **/\n    using LD = long double;\n    #define double LD\n    #define long long long\n    #define LL long\n    #define int long\n    template<class T> using vec = vector<T>;\n    using VB = vec<bool>;   using WB = vec<VB>;\n    using VC = vec<char>;   using WC = vec<VC>;\n    using VI = vec<int>;    using WI = vec<VI>;\n    using VD = vec<double>; using WD = vec<VD>;\n    using VS = vec<string>; using WS = vec<VS>;\n    using PI = pair<int, int>;  using VPI = vec<PI>; using WPI = vec<VPI>;\n    using MI = map<int, int>;   using VMI = vec<MI>;\n\nbool debug;\n#define _GLIBCXX_DEBUG\n#define _LIBCPP_DEBUG 2\n#define _LIBCPP_DEBUG2 2\n#define ln << '\\n'\n#define tb << '\\t'\n#define sp << ' '\n#define DD(x) if(debug) cerr << #x << \" = \" << (x) << \", \"\n#define DDD(x) if(debug) cerr << #x << \" = \" << (x) ln\n#define db dd\n#define dbg ddd\n\nvoid settings();\nvoid solve();\n\nsigned main(signed argc, char *argv[]) {\n    #ifdef EBUG\n        debug = true;\n    #elif defined(ONLINE_JUDGE)\n        debug = false;\n    #else\n        debug = argc >= 2;\n    #endif\n    if(!debug) {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n    cout << fixed << setprecision(20);\n    cerr << fixed << setprecision(20);\n\n    settings();\n    solve();\n\n    return 0;\n}\n\n/******************************* basic library ********************************/\n/** structure **/\n    template<class T> struct Graph { bool directed = false; int nv = -1; int ne = -1; vec<map<int,T>> e;\n        Graph<T> rev() { if(not directed) return *this; Graph<T> g = *this; for(auto& ei : g.e) ei.clear(); times(nv, i) for(auto& p : e[i]) g.e[p.first][i] = p.second; return g; }\n    };\n    using GraphI = Graph<int>;\n/** IO **/\n    template<class T> inline istream& operator>>(istream& s, vec<T>& v) { for(auto&& p : v) s >> p; return s; }\n    int INPUT_GRAPH_index_sub = 1, INPUT_GRAPH_cost = 0; bool INPUT_GRAPH_allow_empty = false;\n    template<class T> inline istream& operator>>(istream& s, Graph<T>& g) {\n        const int sub = INPUT_GRAPH_index_sub, cost = INPUT_GRAPH_cost, emptyp = INPUT_GRAPH_allow_empty;\n        if(g.nv + emptyp <= 0 and g.ne + emptyp <= 0) { s >> g.nv >> g.ne; } g.e = VMI(g.nv);\n        times(g.ne, i) { int x, y; T d = cost; s >> x >> y; if(!d) s >> d; g.e[x - sub][y - sub] = d; if(not g.directed) g.e[y - sub][x - sub] = d; } return s;\n    }\n    template<class T, class S> inline ostream& operator<<(ostream&, const pair<T, S>&);\n    template<class T>          inline ostream& operator<<(ostream&, const vec<T>&);\n    template<class T, class S> inline ostream& operator<<(ostream&, const map<T, S>&);\n    template<class T> inline ostream& operator<<(ostream&, const Graph<T>&);\n    #define DEFINE_ITER_OUTPUT(s, x, sep) { int i = 0; for(const auto& x##0_elem : x) { if(i++) s << sep; s << x##0_elem; } return s; }\n    template<class T, class S> inline ostream& operator<<(ostream& s, const pair<T, S>& p) { return s << \"(\" << p.first << \",\" << p.second << \")\"; }\n    template<class T>          inline ostream& operator<<(ostream& s, const vec<T>& v) DEFINE_ITER_OUTPUT(s, v, ' ')\n    template<class T, class S> inline ostream& operator<<(ostream& s, const map<T, S>& m) DEFINE_ITER_OUTPUT(s, m, ' ')\n    template<class T>          inline ostream& operator<<(ostream& s, const vec<vec<T>>& w) DEFINE_ITER_OUTPUT(s, w, '\\n')\n    template<class T, class S> inline ostream& operator<<(ostream& s, const vec<map<T, S>>& vm) DEFINE_ITER_OUTPUT(s, vm, '\\n')\n    template<class T> inline ostream& operator<<(ostream& s, const Graph<T>& g) { return s << \"Graph(nv:\" << g.nv << \" ne:\" << g.ne << \" e:[\" ln << g.e ln << \"])\"; }\n    inline void RD() {}\n    template<class T, class...S> inline T& RD(T& t, S&... s) { cin >> t; RD(s...); return t; } /* returns first side */\n    template<class T, class...S> inline vec<T>& RD(vec<T>& t, vec<S>&... s) { times(t.size(), i) { RD(t[i], s[i]...); } return t; }\n    #define RR(typ, ...) typ __VA_ARGS__; RD(__VA_ARGS__)\n    template<class T, class...A> inline T READ(A... a) { T t(a...); cin >> t; return t; }\n    template<class T> inline void dddf(const T& t) { if(debug) cerr << t ln; }\n    template<class T, class...U> inline void dddf(const T& t, const U&... u) { if(debug) { cerr << t << \", \"; dddf(u...); }}\n    #define ddd(...) if(debug) { cerr << #__VA_ARGS__ << \" = \"; dddf(__VA_ARGS__); }\n/** container **/\n    #define all(v) begin(v), end(v)\n    template<class T> inline T max(const pair<T, T>& p) { return max(p.first, p.second); }\n    template<class T> inline T min(const pair<T, T>& p) { return min(p.first, p.second); }\n    template<class T> inline T max(const vec<T>& v) { return *max_element(all(v)); }\n    template<class T> inline T min(const vec<T>& v) { return *min_element(all(v)); }\n    template<class T> inline T sum(const vec<T>& v) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) s += v[i]; return s; }\n    template<class T> inline T sum(const vec<T>& v, int mod) { T s = v.empty() ? 0 : v[0]; uptil(1, v.size(), i) (s += v[i]) %= mod; return s; }\n    template<class T, class U> inline T dig(const U& d, const T& t) { return t; }\n    template<class T, class U, class...I> inline U dig(const U& d, const T& t, int i, I... j) {\n        return 0 <= i && i < t.size() ? dig(d, t[i], j...) : d; }\n    #define first_itr_st_val_ge_ lower_bound\n    #define first_itr_st_val_gt_ upper_bound\n/** other **/\n    template<class T> inline signed SIZE(const T& t) { return t.size(); }\n    #define size SIZE\n    #define MP make_pair\n    #define MT make_tuple\n    #define b_max(x, y) x = max(x, y)\n    #define b_min(x, y) x = min(x, y)\n    inline LD AC(LD d) { return d ? d : 0; }\n[[maybe_unused]] constexpr long INF = 1LL << 60;\n[[maybe_unused]] constexpr long MOD = 1000000007; // 1000000009; // 998244353;\n\n/****************************** optional library ******************************/\n/* <sr.q.uf> */\n    // VERIFIED: arc090b\n    // ref: https://github.com/monyone/teihen_library/blob/master/DataStructure/01_WeightedUnionFind.md\n    struct UnionFind {\n        int n;\n        VI parents, treeSizes, weightDiffs;\n        UnionFind(int n_) : n(n_), parents(n), treeSizes(n, 1), weightDiffs(n, 0) { times(n, i) parents[i] = i; }\n        int root(int i) {\n            if(parents[i] == i) return i;\n            int p = root(parents[i]);\n            weightDiffs[i] += weightDiffs[parents[i]];\n            return parents[i] = p;\n        }\n        int weight(int i) { root(i); return weightDiffs[i]; }\n        void merge(int i, int j, int w = 0) { // w > 0 if i < j\n            if(same(i, j)) return;\n            int x = w + weight(i) - weight(j);\n            i = root(i); j = root(j);\n            if(treeSizes[i] < treeSizes[j]) { swap(i, j); x = -x; }\n            parents[j] = i;\n            treeSizes[i] += treeSizes[j]; treeSizes[j] = -1;\n            weightDiffs[j] = x;\n        }\n        bool same(int i, int j) { return root(i) == root(j); }\n        int diff(int base, int i) { return same(base, i) ? weight(i) - weight(base) : -INF; }\n    };\n/* </sr.q.uf> */\n/************************************ main ************************************/\n\nvoid settings() {\n    // INPUT_GRAPH_index_sub = 0;       // uncomment if input index is 0-based\n    // INPUT_GRAPH_allow_empty = true;  // uncomment to allow empty graph\n    INPUT_GRAPH_cost = 1;            // uncomment if all input costs are 1\n}\n\nvoid solve() {\n// NMSM(-LR)\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;VI L0(M);VI R0(M);times(M,Ri_0){cin>>L0[Ri_0\n];--L0[Ri_0];cin>>R0[Ri_0];}\n/* </foxy.memo-area> */\n    VI L, R; L.reserve(N); R.reserve(N);\n    times(M, i) {\n        if(size(R) == 0 or R0[i] >= R[size(R)-1]) {\n            L.push_back(L0[i]);\n            R.push_back(R0[i]);\n        }\n    }\n    M = size(L); /*!!!!!*/\n\n    VI c(N), rj(N), mnc(N), mxc(N);\n    times(N, j) {\n        c[j] = (j ? c[j-1] : 0) + (S[j] == '1');\n    }\n\n    times(M, i) rj[L[i]] = R[i] - 1;\n    times(N, j) {\n        rj[j] = max({rj[j], j, j ? rj[j-1] : 0});\n        mxc[j] = c[rj[j]];\n    }\n\n    ddd(L);ddd(R);\n    {\n        L.push_back(N); R.push_back(N);\n        int r1 = 0, cnt = 0;\n        times(M, i) {\n            uptil(max(r1, L[i]), R[i], j) {\n                cnt += S[j] == '1';\n                S[j] = '0';\n            }\n            int kab = max(0ll, R[i] - L[i+1]);\n            int d = max(0ll, cnt - kab);\n            cnt -= d;\n            ddd(cnt, kab, d);\n            downto(R[i]-cnt-1, R[i]-cnt-d, j) S[j] = '1';\n            r1 = R[i];\n        }\n        times(N, j) {\n            mnc[j] = (j ? mnc[j-1] : 0) + (S[j] == '1');\n        }\n    }\n    ddd(c); ddd(rj); ddd(mxc); ddd(mnc);\n\n    VI dp, dq; dp.push_back(1);\n    times(N, i) {\n        dq.resize(mxc[i]+1);\n        fill(all(dq), 0);\n        upto(mnc[i], mxc[i], j) {\n            dq[j] = (dig(0, dp, j-1) + dig(0, dp, j)) % MOD;\n        }\n        swap(dp, dq);\n        ddd(i, dp);\n    }\n    cout << sum(dp, MOD) ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\n\nint64_t dp[3001][3001];\n\nint main(){\n    int N, M;\n    string S;\n    int L[3001], R[3001], sum[3001];\n\n    cin >> N >> M >> S;\n    for(int i=0; i<M; i++){\n        cin >> L[i] >> R[i];\n        L[i]--; R[i]--;\n    }\n    for(int i=0; i<N; i++){\n        sum[i] = i>0 ? sum[i-1] : 0;\n        if(S[i] == '1') sum[i]++;\n    }\n\n    dp[0][0] = 1;\n    int pt = 0, right = 0;\n    for(int i=0; i<N; i++){\n        while(pt<M && L[pt] <= i){\n            right = max(right, R[pt]);\n            pt++;\n        }\n        right = max(right, i);\n\n        int mn = max(0, sum[right] - (right-i));\n        int mx = sum[right];\n        for(int j=mn; j<=mx; j++){\n            add(dp[i+1][j], dp[i][j]);\n            if(j>0) add(dp[i+1][j], dp[i][j-1]);\n        }\n    }\n\n    cout << dp[N][sum[N-1]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n// Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int N,M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> sum(N+1,0);\n    for (int i=0;i<N;++i) sum[i+1]=sum[i]+(S[i]-'0');\n    vector<pair<int,int>> sec;\n    for (int i=0;i<M;++i){\n        int l,r; cin >> l >> r; --l,--r;\n        if (!sec.empty()&&sec.back().second>=r) continue;\n        if (!sec.empty()&&sec.back().first==l) sec.pop_back();\n        sec.emplace_back(l,r);\n    }\n    int m=sec.size();\n    vector<vector<mint>> dp(m+1,vector<mint>(N+1,0));\n    dp[0][0]=1;\n    mint ans=0;\n    int prel=-1,prer=-1;\n    for (int i=0;i<m;++i){\n        int l=sec[i].first,r=sec[i].second;\n        int nxt=min(l,prer+1)-prel,add=sum[r+1]-sum[prer+1],rest=max(0,prer-l+1);\n        for (int j=0;j<=N;++j){\n            if (dp[i][j]==0) continue;\n            for (int k=0;k<=min(j,nxt);++k){\n                if (j-k<=rest) dp[i+1][j+add-k]+=dp[i][j]*COM(nxt,k);\n            }\n        }\n        if (i==m-1) for (int j=0;j<=N;++j){\n            ans+=dp[i+1][j]*COM(r-l+1,j);\n        }\n        prel=l,prer=max(prer,r);\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        sz = r[i] - l[i + 1] + 1;\n        if (l[i + 1] <= r[i]) {\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k)\n                    inc(f[i][j], 1ll * f[i - 1][k] * c[l[i + 1] - l[i]][k + sum[r[i]] - sum[r[i - 1]] - j] % Mod);\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? n : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * c[r[i] - l[i] + 1][k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]] % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll dp[3030][3030];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<P> lr = { {0,1} };\n\tREP(i, m) {\n\t\tll l, r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tif (lr.back().first == l && lr.back().second < r)lr.back().second = r;\n\t\telse if (lr.back().first < l && lr.back().second < r)lr.push_back({ l,r });\n\t}\n\tArray cnt(n + 1, 0);\n\tREP(i, n) cnt[i + 1] = cnt[i] + (s[i] == '1' ? 1 : 0);\n\tm = lr.size();\n\tArray mr(n, 0);\n\tll now = 0;\n\tREP(i, n) {\n\t\twhile (now != m - 1 && i >= lr[now + 1].first)now++;\n\t\tmr[i] = max(i + 1, lr[now].second);\n\t}\n\tdp[0][0] = 1;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (dp[i][j] == 0)continue;\n\t\t\tif (cnt[mr[i]] > j)(dp[i + 1][j + 1] += dp[i][j]) %= MOD;\n\t\t\tif (mr[i] - cnt[mr[i]] > i - j)(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t}\n\t}\n\tcout << dp[n][cnt[n]] << \"\\n\";\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod998 = 998244353;\nconst ll intmax = 2147483647;\nconst ll llmax = 9223372036854775807;\nconst char sp = ' ';\n\nint N, M,s[3001];\nll f[3001],inv[3001], DP[3001][3001];\nstring S;\nvector<pair<int, int>>v;\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1)a = a*x%mod;\n\t\tx = x*x%mod;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nll comb(int n, int r) {\n\tif (n < r)return 0;\n\treturn f[n] * inv[r] % mod*inv[n - r] % mod;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tint mxr = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif (r > mxr) {\n\t\t\tmxr = r;\n\t\t\tv.push_back({ l,r });\n\t\t}\n\t}\n\tv.push_back({ N + 1,N + 1 });\n\tf[0] = 1;\n\tfor (int i = 0; i < 3000; i++) {\n\t\tf[i + 1] = f[i] * (i + 1) % mod;\n\t}\n\tfor (int i = 0; i <= 3000; i++) {\n\t\tinv[i] = pw(f[i], mod - 2);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\ts[i + 1] = s[i] + S[i] - '0';\n\t}\n\tDP[s[v.front().first - 1]][0] = 1;\n\tfor (int i = 0; i < v.size() - 1; i++) {\n\t\tif (v[i].second < v[i + 1].first) {\n\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\tDP[s[v[i + 1].first - 1]][i + 1] += DP[j][i] * comb(v[i].second - v[i].first + 1, s[v[i].second] - j);\n\t\t\t\tDP[s[v[i + 1].first - 1]][i + 1] %= mod;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\tint t = s[v[i].second] - j;\n\t\t\t\tfor (int k = max(0, v[i + 1].first - v[i].second - 1 + t); k <= t&&k <= v[i + 1].first - v[i].first; k++) {\n\t\t\t\t\tDP[j + k][i + 1] += DP[j][i] * comb(v[i + 1].first - v[i].first, k);\n\t\t\t\t\tDP[j + k][i + 1] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[s[N]][v.size() - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> piipi;\ntypedef pair<pii, pii> piipii;\n\n#define mp make_pair\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\nconst int mod = 1000000007;\n\nint l[3005], r[3005], mx[3005];\nchar s[3005];\nint sum[3005][2];\nint dp[3005][3005];\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);   \n    scanf(\"%s\", s+1);\n    for(int i=1;i<=n;i++) mx[i] = i;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\", &l[i], &r[i]);\n        mx[l[i]] = max(mx[l[i]], r[i]);\n    }\n\n    for(int i=1;i<=n;i++){\n        sum[i][s[i]-'0']++;\n        sum[i][0] += sum[i-1][0];\n        sum[i][1] += sum[i-1][1];\n    }\n\n    for(int i=1;i<=n;i++) mx[i] = max(mx[i], mx[i-1]);\n\n    dp[0][0] = 1;\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<=n;j++){\n            if(dp[i-1][j]){\n                int c0 = sum[mx[i]][0] - j;\n                int c1 = sum[mx[i]][1] - (i-1-j);\n                if(c0 > 0) dp[i][j+1] = (dp[i][j+1] + dp[i-1][j])%mod;\n                if(c1 > 0) dp[i][j] = (dp[i][j] + dp[i-1][j])%mod;\n            }\n        }\n    }\n    int ans = 0;\n    for(int j=0;j<=n;j++) ans = (ans + dp[n][j])%mod;\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr lint MOD = 1000000007;\nint N, M;\nstring S;\nvector<int> l, r;\nvector<int> con;\n\nvector<int> ac0, ac1;\n\nint main()\n{\n    cin >> N >> M >> S;\n    l.resize(M);\n    r.resize(M);\n    con.resize(N);\n    for (int i=0; i<N; i++) con[i] = i;\n\n    for (int i=0; i<M; i++)\n    {\n        cin >> l[i] >> r[i];\n        l[i]--;\n        r[i]--;\n        for (int j=l[i]; j<r[i]; j++) con[j] = max(con[j], r[i]);\n    }\n    ac0.resize(N);\n    ac1.resize(N);\n    {\n        int n0 = 0, n1 = 0;    \n        for (int i=0; i<N; i++)\n        {\n            if (S[i] == '0') n0++;\n            else n1++;\n            ac0[i] = n0;\n            ac1[i] = n1;\n        }\n    }\n\n    vector<vector<lint> > dp(N, vector<lint>(N+1, 0)); // dp[何文字目まで][1の個数]\n    dp[0][0] = ac0[con[0]] > 0 ? 1 : 0;\n    dp[0][1] = ac1[con[0]] > 0 ? 1 : 0;\n    for (int i=1; i<N; i++)\n    {\n        for (int j=0; j <= i + 1; j++)\n        {\n            int n0 = i - j + 1;\n            int n1 = j;\n            if (n0 <= ac0[con[i]] && n1 <= ac1[con[i]])\n            {\n                dp[i][j] = dp[i-1][j];\n                if (j > 0) dp[i][j] += dp[i-1][j-1];\n                dp[i][j] %= MOD;\n                // cout << i << \" \" << j << \" \" << ac0[i] << \" \" << ac1[i] << endl;\n                // cout << \"dp[\" << i << \"][\" << j << \"]= \" << dp[i][j] << endl;\n            }\n        }\n    }\n    cout << accumulate(dp[N-1].begin(), dp[N-1].end(), 0LL) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <random>\n#include <chrono>\nusing namespace std;\n\nint n, m;\n\nconst int maxn = 3005;\nchar s[maxn];\n\nconst int mod = 1e9 + 7;\nint cnt[maxn];\nint dp[maxn][maxn];\nint c[maxn][maxn];\n\nvoid init(){\n    c[0][0] = 1;\n    for(int i = 1;i < maxn;i++){\n        c[i][0] = c[i][i] = 1;\n        for(int j = 1;j < i;j++){\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n        }\n    }\n}\n\ntypedef pair<int, int> pii;\n\npii p[maxn];\n\nbool cmp(pii a, pii b){\n    if(a.first != b.first)\n        return a.first < b.first;\n    return a.second > b.second;\n}\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nint main(){\n    init();\n    cin >> n >> m;\n    scanf(\"%s\", s + 1);\n    cnt[0] = 0;\n    for(int i = 1;i <= n;i++){\n        cnt[i] = cnt[i - 1] + (s[i] == '0');\n    }\n    for(int i = 1;i <= m;i++){\n        scanf(\"%d%d\", &p[i].first, &p[i].second);\n    }\n    p[m + 1] = make_pair(n + 1, n + 1);\n    sort(p + 1, p + m + 2, cmp);\n    int tot = 0;\n    dp[0][cnt[p[1].first - 1]] = 1;  \n    for(int i = 1, j = 1;i <= m;i = j + 1, j = i){\n        while(p[j + 1].second <= p[j].second){\n            j++;\n        }\n        int nxt = j + 1;\n        int l = p[i].first, r = p[i].second;\n        tot++;\n        if(p[nxt].first <= r){\n            int len = p[nxt].first - l;\n            for(int j = 0;j <= cnt[n];j++){\n                if(dp[tot - 1][j] == 0)\n                    continue;\n                int R = min(cnt[r] - j, len);\n                int L = max(0, cnt[r] - j - (r - p[nxt].first + 1));\n                for(int k = L;k <= R;k++){\n                    add(dp[tot][k + j], 1LL * dp[tot - 1][j] * c[len][k] % mod);\n                }\n            }\n        }else{\n            int len = r - l + 1;\n            for(int j = 0;j <= cnt[n];j++){\n                if(dp[tot - 1][j] == 0)\n                    continue;\n                int num = cnt[r] - j;\n                add(dp[tot][cnt[p[nxt].first - 1]], 1LL * dp[tot - 1][j] * c[len][num] % mod);\n            }\n        }\n    }\n    int ans = dp[tot][cnt[n]];\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3010\n#define MOD 1000000007\n#define int ull\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\nbool vis[maxn][maxn];\npi A[maxn];\nint fac[maxn];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = (res*x) % MOD;  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn (a * qexp(b,MOD-2)) % MOD;\n}\n\nint choose(ll n,ll k){\n\tif (n < k) return 0;\n\treturn modinv(modinv(fac[n],fac[k]),fac[n-k]);\n}\n\ninline int qry(pi i){\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint dpf(int i,int j){\n\tif (vis[i][j]) return dp[i][j];\n\tvis[i][j] = 1;\n\t\n\tif (i == M) return dp[i][j] = 1;\n\tif (i == M-1){\n\t\treturn dp[i][j] = choose(sz(A[i]),j);\n\t}\n\t\n\tdp[i][j] = 0;\n\t\n\tFOR(k,0,N){\n\t\tif (k > sz(inter(A[i],A[i+1]))) break;\n\t\tif (k > j) break;\n\t\t\n\t\tdp[i][j] += (dpf(i+1,qry(A[i+1]) - qry(inter(A[i],A[i+1])) + k) * choose(sz(A[i]) - sz(inter(A[i],A[i+1])),j - k))  % MOD;\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n\t\t\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,N){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\t\t\t\n\tcout<<dpf(0,qry(A[0]));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N,M;\nstring S;\nll dp [3001] [3001];\nconst ll MOD = 1e9 + 7;\n\nint main()\n{\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M >> S;\n\tvector< pair<int,int> > A(M);\n\tFOR(i,0,M){\n\t\tcin >> A [i].first >> A [i].second;\n\t\tA [i].first--;\n\t}\n\n\tdp [0] [0] = 1;\n\tint idx = 0,r = 0;\n\tFOR(i,0,N){\n\t\tint cnt = 0;\n\t\tif(r == i){\n\t\t\tcnt += S [i] == '0';\n\t\t\tr++;\n\t\t}\n\t\twhile(A [idx].first <= i){\n\t\t\tFOR(j,r,A [idx].second){\n\t\t\t\tcnt += S [j] == '0';\n\t\t\t}\n\t\t\tchmax(r,A [idx].second);\n\t\t\tidx++;\n\t\t}\n\t\tfor(int j = 0;j <= N;j++) if(dp [i] [j]){\n\t\t\tif(j + cnt > 0){\n\t\t\t\t(dp [i + 1] [j + cnt - 1] += dp [i] [j]) %= MOD;\n\t\t\t}\n\t\t\tif((r - i) - (j + cnt) > 0){\n\t\t\t\t(dp [i + 1] [j + cnt] += dp [i] [j]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp [N] [0]);\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nstring s;\nll dp[3010][3010];\nint tar[3010];\n\nconst ll mod=1000000007LL;\n\n\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m >> s;\n\trep(i,n) tar[i]=i+1;\n\ttar[n]=n;\n\t\n\trep(i,m){\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tl--;\n\t\tchmax(tar[l],r);\n\t}\n\n\trep(i,1,n+1) chmax(tar[i],tar[i-1]);\n\t\n\t//rep(i,n+1) cout << tar[i] << endl;\n\n\tint one=0;\n\trep(i,tar[0]) one+=(s[i]=='1');\n\tdp[0][one]=1LL;\n\t\n\trep(i,n){\n\t\tint add=0;\n\t\trep(j,tar[i],tar[i+1]) add+=(s[j]=='1');\n\t\t//cout << \"Len : \" << tar[i]-i << endl;\n\t\trep(c,tar[i]-i+1){\n\t\t\tif(c>0){\n\t\t\t\tdp[i+1][c-1+add]+=dp[i][c];\n\t\t\t\tdp[i+1][c-1+add]%=mod;\n\t\t\t}\n\t\t\tif(c<tar[i]-i){\n\t\t\t\tdp[i+1][c+add]+=dp[i][c];\n\t\t\t\tdp[i+1][c+add]%=mod;\n\t\t\t}\n\t\t}\n\t}\n\n\t//rep(i,2) cout << dp[n-1][i] << endl;\n\tcout << dp[n][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],d[3002][3002],sumd[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= mul(fact[n-r],Mod-2); tmp %= Mod;\n\ttmp *= mul(fact[r],Mod-2); tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][0] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tsumd[i-1][0] = d[i-1][0];\n\t\tfor(int j=1; j<=sum[maxr]; j++){\n\t\t\tsumd[i-1][j] = sumd[i-1][j-1]+d[i-1][j];\n\t\t\tsumd[i-1][j] %= Mod;\n\t\t}\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tint cnt1,cnt2;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t}else{\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Dim = 5e3 + 5;\nconst int Mod = 1e9 + 7;\n\nint mx[ Dim ], r[ Dim ], dp[ Dim ][ Dim ], sum[ Dim ];\nint n, m, x, y;\n\nchar s[ Dim ];\n\nint main() {\n  //  freopen (\"input.txt\", \"r\", stdin);\n\n    cin >> n >> m >> (s + 1);\n    for (int i = 1; i <= n; ++ i) {\n        r[ i ] = i;\n\n        sum[ i ] = sum[i - 1];\n        if (s[ i ] == '0')\n            ++sum[ i ];\n    }\n\n    for (int i = 1; i <= m; ++ i) {\n        cin >> x >> y;\n        r[ x ] = max (r[ x ], y);\n    }\n\n    for (int i = 1; i <= n; ++ i) {\n        mx[ i ] = max (r[ i ], mx[i - 1]);\n    }\n\n    mx[n + 1] = mx[ n ];\n    dp[ 1 ][ sum[ r[ 1 ] ] ] = 1;\n\n    for (int i = 1; i <= n; ++ i) {\n        for (int j = 0; j <= m; ++ j) {\n            if (dp[ i ][ j ] == 0)\n                continue;\n\n            int v1 = j;\n            int v2 = mx[ i ] - i + 1 - v1;\n\n            int nr1 = sum[ mx[i + 1] ] - sum[ mx[ i ] ];\n            if (v1) {\n                dp[i + 1][nr1 + j - 1] += dp[ i ][ j ];\n                dp[i + 1][nr1 + j - 1] %= Mod;\n            }\n\n            if (v2) {\n                dp[i + 1][nr1 + j] += dp[ i ][ j ];\n                dp[i + 1][nr1 + j] %= Mod;\n            }\n        }\n    }\n\n    cout << dp[n + 1][ 0 ] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define pb push_back\n#define mp make_pair\n#define snd second\n#define fst first\n#define debug printf(\"--%d--\\n\",__LINE__)\n#define ll long long int\n\nint N, M;\nstring S;\nstatic ll dp[3002][3002];\n\nconst ll MODP = 1000000007;\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll invMod(ll a, ll m) {\n  ll x, y;\n  if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n  else                         return 0; // unsolvable\n}\n\n\nll powmod(ll n, ll m){\n\tll ret = 1;\n\tfor(int i=0;i<m;i++){\n\t\tret = (ret * n) % MODP;\n\t}\n\treturn ret;\n}\n\n\nll comb(ll n, ll m){\n\tif (m<0 || n<m) return 0; //failsafe\n\tll ret = 1;\n\tfor(int i=1;i<=m;i++){\n\t\tret = (ret * (n-m+i)) % MODP;\n\t\tret = (ret * invMod(i, MODP)) % MODP;\n\t}\n\treturn ret % MODP;\n}\n\n\nint main(void){\n\tcin >> N >> M;\n\tcin >> S;\n\tint l[M], r[M], c[M];\n\tint sum[N+1]={0};\n\tfor(int i=1;i<=N;i++){\n\t\tsum[i] = sum[i-1] + ((S[i-1]=='1') ? 1 : 0);\n\t}\n\tvpii a;\n\tint maxi = 0;\n\tfor(int i=0;i<=M;i++){\n\t\tif (i<M){\n\t\t\tcin >> l[i] >> r[i];\n\t\t}\n\t\tif (i==M || (i>0 && l[i]>l[i-1])){\n\t\t\ta.pb(mp(l[i-1], maxi));\n\t\t\tmaxi = 0;\n\t\t}\n\t\tif (i<M){\n\t\t\tmaxi = max(maxi, r[i]);\n\t\t}\n\t}\n\tvpii b;\n\tmaxi = -1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif (maxi < a[i].second){\n\t\t\tb.pb(a[i]);\n\t\t\tmaxi = a[i].second;\n\t\t}\n\t}\n\tfor(int i=0;i<b.size();i++){\n\t\tc[i] = sum[b[i].second] - sum[b[i].first-1];\n\t\tb[i].first--;\n\t\t//cout << b[i].first << \" \" << b[i].second << \" \" << c[i] << endl;\n\t}\n\t\n\tdp[0][c[0]] = 1;\n\tfor(int i=0;i+1<b.size();i++){\n\t\tif (b[i].second > b[i+1].first){\n\t\t\tfor(int j=0;j<=b[i].second-b[i].first;j++){\n\t\t\t\tfor(int k=0;k<=b[i+1].second-b[i+1].first;k++){\n\t\t\t\t\tint d = sum[b[i+1].second] - sum[b[i].second];\n\t\t\t\t\tint c1 = j - k + d;\n\t\t\t\t\tint c2 = k - d;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << d << endl;\n\t\t\t\t\tif (d<0 || c1<0 || c2<0 || c2>b[i].second-b[i+1].first) continue;\n\t\t\t\t\tdp[i+1][k] += (dp[i][j] * comb(b[i+1].first - b[i].first, c1)) % MODP;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<3002;j++){\n\t\t\t\tdp[i+1][c[i+1]] = (dp[i+1][c[i+1]] + dp[i][j] * comb(b[i].second - b[i].first, j)) % MODP;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<b.size();i++){\n\t\tcout << \"i = \" << i << endl;\n\t\tfor(int j=0;j<3002;j++){\n\t\t\tif (dp[i][j]!=0){\n\t\t\t\tcout << \"dp[i][\" << j << \"] = \" << dp[i][j] << endl;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tll ans = 0;\n\tfor(int i=0;i<3002;i++){\n\t\tans = (ans + dp[b.size()-1][i] * comb(b[b.size()-1].second - b[b.size()-1].first, i)) % MODP;\n\t}\n\tcout << ans << endl;\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n#define pe pair<int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX_N = 3010;\nconst long long MOD = 1000000007;\n\nvector<pe> ops;\n\nclass cmp {\npublic:\n  inline bool operator()(const pe &a, const pe &b) {\n    if(a.se == b.se) {\n      return a.fi > b.fi;\n    }\n    return a.se > b.se;\n  }\n};\n\nint le[MAX_N];\nint ri[MAX_N];\n\nlong long d[MAX_N][MAX_N];\n\nstring s;\nstring copie;\n\nint main()\n{\n  int n, m;\n  cin >> n >> m >> s;\n\n  for(int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    ops.push_back(mp(a, b));\n  }\n\n  sort(ops.begin(), ops.end());\n\n  s = \" \" + s;\n  copie = s;\n\n  for(auto it : ops) {\n    int cnt0 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt0 += (s[i] == '0');\n    }\n\n    for(int i = it.fi; i < it.fi + cnt0; i++) {\n      s[i] = '0';\n    }\n    for(int i = it.fi + cnt0; i <= it.se; i++) {\n      s[i] = '1';\n    }\n  }\n  int cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      ri[++cnt] = i;\n    }\n  }\n\n\n  s = copie;\n  cnt = 0;\n\n  for(auto it : ops) {\n    int cnt1 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt1 += (s[i] == '1');\n    }\n    cout << it.fi << ' ' << cnt1 << \"#\\n\";\n\n    for(int i = it.fi; i < it.fi + cnt1; i++) {\n      s[i] = '1';\n    }\n    for(int i = it.fi + cnt1; i <= it.se; i++) {\n      s[i] = '0';\n    }\n  }\n\n  cout << s << '\\n';\n\n  cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      le[++cnt] = i;\n            cout << le[cnt] << ' ' << ri[cnt] << '\\n';\n\n    }\n  }\n\n  d[0][0] = 1;\n  for(int i = 1; i <= n; i++) {\n    d[i][0] = d[i - 1][0];\n    for(int j = 1; j <= min(cnt, i); j++) {\n      if(i >= le[j] && i <= ri[j]) {\n        d[i][j] += d[i - 1][j - 1];\n      }\n      d[i][j] = (d[i][j] + d[i - 1][j]) % MOD;\n    }\n  }\n\n  cout << d[n][cnt];\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n//region Template\n#include \"ext/pb_ds/assoc_container.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n\nconst int MOD = 1000000007;\n\nusing namespace std;\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset;\n\n#define finish(x) cout << x; exit(0);\n#define fastIO cin.tie(0); cin.sync_with_stdio(false);\n\nvoid setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\n//const string USCAO_TAG = \"mountains\";\nvoid usaco(const string& USACO_TAG) { setIn(USACO_TAG + \".in\"); setOut(USACO_TAG + \".out\"); }\n/*\ntemplate<typename... Args>\nvoid print(Args... args) {\n\t#ifdef LOCAL\n\t((std::cout << args << \" \"), ...);\n\tcout << endl;\n\t#endif\n}\n */\n//endregion\n\n/* Notes:\n * Farah </3\n */\n\nconst int MAXN = 2e3 + 6;\nstring s;\nint r[MAXN];\nint p[MAXN];\nint n, m;\n\nll dp[MAXN][MAXN];\n\nint ones(int l, int r){\n\treturn p[r] - p[l - 1];\n}\n\nll solve(int l, int c){\n\tif(l == n && c <= 1){\n\t\treturn dp[l][c] = 1;\n\t}\n\n\tif(dp[l][c] != 0) return dp[l][c];\n\n\tint nc = c + ones(r[l] + 1, r[l + 1]);\n\tint len = r[l] - l + 1;\n\tif(len > c) {\n\t\tdp[l][c] += solve(l + 1, nc);\n\t}\n\tif(c > 0) dp[l][c] += solve(l + 1, nc - 1);\n\n\treturn dp[l][c] % MOD;\n}\n\nint main() {\n\t#ifdef LOCAL\n\tsetIn(\"in.txt\");\n\tsetOut(\"out.txt\");\n\t#endif\n\n\tcin >> n >> m;\n\n\tcin >> s;\n\ts = \"#\" + s;\n\n\tp[1] = (s[1] == '1');\n\tfor(int i = 2; i <= n; i++){\n\t\tp[i] = p[i - 1] + (s[i] == '1');\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tr[i] = i;\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tint l, x;\n\t\tcin >> l >> x;\n\n\t\tr[l] = max(r[l], x);\n\t}\n\n\tfor(int i = 2; i <= n; i++){\n\t\tr[i] = max(r[i], r[i - 1]);\n\t}\n\n\tmemset(dp, 0, sizeof dp);\n\tcout << solve(1, ones(1, r[1]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll l[3005], r[3005];\nll N, M;\nstring S;\nll inv[1000000];\nll FactorialInv[1000000];\nll Factorial[1000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    FactorialInv[0] = 1;\n    inv[0] = 1;\n    for(int i = 2; i < 1000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nll dp[3005][3005];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination();\n    cin >> N >> M >> S;\n    S = \"#\" + S;\n    for(int i = 1; i <= M; i++) {\n        cin >> l[i] >> r[i];\n        if(r[i] <= r[i-1]) {\n            i--;\n            M--;\n        }\n    }\n    l[M+1] = N+1;\n    /*\n    for(int i = 1; i <= M; i++) {\n        cerr << l[i] << \" \" << r[i] << endl;\n    }\n    */\n    ll mini = 0;\n    ll maxi = 0;\n    dp[0][0] = 1;\n    for(int i = 1; i <= M; i++) {\n        ll newmini = 1e9;\n        ll newmaxi = 0;\n        ll num = 0;\n        ll interval = min(l[i+1]-1, r[i]) - l[i] + 1;\n        for(int j = max(l[i], r[i-1] + 1); j <= r[i]; j++) {\n            if(S[j] == '1') num++;\n        }\n        mini += num;\n        maxi += num;\n        for(ll before = mini; before <= maxi; before++) {\n            ll nowmaxi = min(before, r[i] - l[i+1] + 1);\n            chmax(nowmaxi, 0LL);\n            ll nowmini = before - (l[i+1] - l[i]);\n            chmax(nowmini, 0LL);\n            chmax(newmaxi, nowmaxi);\n            chmin(newmini, nowmini);\n            for(ll after = nowmini; after <= nowmaxi; after++) {\n                ll now = before - after;\n                //cerr << i << \" \" << before << \" \" << after << \" \" << mini << \" \" << maxi << \" \" << nowmini << \" \" << nowmaxi << endl;\n                dp[i][after] += dp[i-1][before-num] * combination(interval, now);\n                dp[i][after] %= mod;\n            }\n        }\n        maxi = newmaxi;\n        mini = newmini;\n        /*\n        for(int j = mini; j <= maxi; j++) {\n            cerr << i << \" \" << j << \" \" << dp[i][j] << endl;\n        }\n        */\n    }\n    cout << dp[M][0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll maxn = 100010;\nll fac[maxn],facinv[maxn],inv[maxn];\nvoid init(){\n    fac[0] = 1;\n    REP(i,1,maxn)fac[i] = i*(fac[i-1])%mod;\n    facinv[maxn-1]=inverse(fac[maxn-1], mod);\n    RREP(i,maxn-2,0){\n        facinv[i] = facinv[i+1]*(i+1)%mod;\n    }\n    inv[1]=1;\n    for(int i=2;i<maxn;i++)\n        inv[i]=(mod-(ll)mod/i*inv[mod%i]%mod);\n}\n\nll combi(int n,int m){\n    if(n<0 || m<0 || n<m)return 0;\n    return fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\n\nll get_len(ll a,ll b){\n    return max(b-a+1,0ll);\n}\nnamespace SOLVE {\n    void main(){\n        ll n,m;\n        cin>>n>>m;\n        string s;\n        cin>>s;\n        vector<PLL>v;\n        REP(i,0,m){\n            int l,r;in(l,r);\n            --l;--r;\n            if(sz(v) and v.back().se >= r){\n                continue;\n            }else{\n                if(sz(v) and v.back().fi == l){\n                    v.pop_back();\n                }\n                v.PB(MP(l,r));\n            }\n        }\n        \n        VLL dp(3010,0);\n        v.insert(v.begin(), MP(-1,-1));\n        v.PB(MP(inf,inf));\n        dp[0] = 1;\n        return;\n        REP(i,1,sz(v)-1){\n            ll last = v[i-1].se;\n            ll cnt = 0;\n            for(int j = max(last+1,v[i].fi);j<=v[i].se;j++){\n                cnt += s[j] == '1';\n            }\n            ll nxt = min(v[i+1].fi-1,v[i].se);\n            VLL new_dp(3010,0);\n            ll len = nxt-v[i].fi+1;\n            ll overlap = get_len(max(v[i].fi,v[i+1].fi),min(v[i].se,v[i+1].se));\n            REP(use,0,len+1){\n                REP(from,0,3010){\n                    if(from+cnt-use <= overlap)new_dp[from+cnt-use] += dp[from] * combi(len, use) % mod;\n                }\n            }\n            swap(dp, new_dp);\n            REP(i,0,3010)dp[i]%=mod;\n        }\n        cout<<dp[0]<<endl;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    init();\n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[0]=fac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]%mod*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn 1ll*fac[n]%mod*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tint cnt=0;\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d\",&p[i].l,&p[i].r);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j)%mod)%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 C[3030][3030];\n\nint N, M, L[3030], R[3030];\nchar S[3030];\nvector<pair<int, int> > ops;\n\ni64 dp[3030][3030];\nint ones[3030];\n\nint most[3030];\n\nint main()\n{\n\tC[0][0] = 1;\n\tfor (int i = 1; i <= 3010; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= 3010; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n\t}\n\n\tscanf(\"%d%d%s\", &N, &M, S);\n\tint lar = -1;\n\tfor (int i = 0; i < M; ++i) {\n\t\tscanf(\"%d%d\", L + i, R + i);\n\t\t--L[i];\n\t}\n\tS[N++] = '0';\n\tL[M] = N - 1;\n\tL[M++] = N;\n\n\tones[0] = 0;\n\tfor (int i = 1; i <= N; ++i) ones[i] = ones[i - 1] + (S[i - 1] == '1' ? 1 : 0);\n\n\tfor (int i = 0; i < N; ++i) most[i] = i + 1;\n\tfor (int i = 0; i < M; ++i) most[L[i]] = max(most[L[i]], R[i]);\n\tfor (int i = 1; i < N; ++i) most[i] = max(most[i], most[i - 1]);\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint rig = most[i];\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t//\tprintf(\"%d %d: %lld\\n\", i, j, dp[i][j]);\n\t\t\tint one = ones[rig] - j;\n\t\t\tint zero = (rig - ones[rig]) - (i - j);\n\t\t//\tprintf(\"%d %d\\n\", one, zero);\n\t\t\tif (one < 0 || zero < 0 || dp[i][j] == 0) continue;\n\t\t\tif (one) ADD(dp[i + 1][j + 1], dp[i][j]);\n\t\t\tif (zero) ADD(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[N][ones[N]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nstring s;\nvector<pair<int, int> > vec;\nint r[3005];\nllint dp[3005][3005];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> s;\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tvec.push_back(make_pair(a, b));\n\t}\n\tfor(int i = 1; i < vec.size(); i++){\n\t\tif(vec[i].second <= vec[i-1].second){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(int i = 0; i < vec.size()-1; i++){\n\t\tif(vec[i].first == vec[i+1].first){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\tint cur = 1, prev = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tfor(int j = cur; j < vec[i].first; j++) r[j] = max(j, prev);\n\t\tr[vec[i].first] = vec[i].second;\n\t\tcur = vec[i].first+1;\n\t\tprev = vec[i].second;\n\t}\n\tfor(int j = cur; j <= N; j++) r[j] = prev;\n\tr[N+1] = N;\n\t\n\t//for(int i = 1; i <= N; i++) cout << r[i] << \" \"; cout << endl;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tint Y = 0;\n\t\tfor(int j = r[i]+1; j <= r[i+1]; j++) if(s[j-1] == '1') Y++;\n\t\tfor(int j = 0; j <= N-Y; j++){\n\t\t\tif(j < r[i]-i+1){\n\t\t\t\tdp[i+1][j+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j+Y] %= mod;\n\t\t\t}\n\t\t\tif(j > 0){\n\t\t\t\tdp[i+1][j-1+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j-1+Y] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= 7; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tcout << dp[N+1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\t\n\tif (maxr[x] - x + 1 < ones) return 0;\n\tif (x == n) return 1;\n\t//cout << \"start: \" << x << \" \" << ones << \"\\n\";\n\t\n\tdp[x][ones] = 0;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tif (ones > 0) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(firstl,0);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, m;\nchar in[4000];\nint a[4000];\nint s[4000];\n\nll d[3005][3005];\n\nll ncr[3005][3005];\n\npii b[4000];\n\nint main()\n{\n\tint i, j, k, l;\n\tcin>>n>>m>>in;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tfor(j=0;j<=i;j++)\n\t\t{\n\t\t\tif(j == 0 || j == i) ncr[i][j]=1;\n\t\t\telse ncr[i][j]=ncr[i-1][j-1]+ncr[i-1][j], ncr[i][j]%=MOD;\n\t\t}\n\t}\n\tfor(i=0;i<n;i++) a[i]=in[i]-'0';\n\tpartial_sum(a, a+n, s);\n\tfor(i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\", &b[i].first, &b[i].second), b[i].first--, b[i].second--;\n\t\tif(i && b[i].second <= b[i-1].second)\n\t\t{\n\t\t\tm--;\n\t\t\ti--;\n\t\t}\n\t}\n\td[0][0]=1;\n\tb[m]=mp(n, n);\n\tfor(i=0;i<m;i++)\n\t{\n\t\tint st=(i?max(b[i-1].second+1, b[i].first):b[i].first);\n\t\tint jma=st-b[i].first+1;\n\t\tint kma=max(b[i].second-b[i+1].first+1, 0);\n\t\tint len=b[i].second-b[i].first+1;\n\t\tfor(j=0;j<=jma;j++)\n\t\t{\n\t\t\tif(d[i][j] == 0) continue;\n\t\t\tint ones=j+(s[b[i].second]-(st?s[st-1]:0));\n\t\t\tfor(k=ones+kma-len;k<=kma;k++)\n\t\t\t{\n\t\t\t\td[i+1][k]+=d[i][j]*ncr[len-kma][ones-k], d[i+1][k]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<d[m][0]<<endl;\n\treturn 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 3005;\nconst int mod = 1e9 + 7;\n\nint n, m, a[MAXN], s[MAXN], f[MAXN][MAXN];\nchar c[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read();\n\tscanf(\"%s\", c + 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\ta[i] = i, s[i] = s[i - 1] + (c[i] == '1');\n\tf[0][0] = 1;\n\tfor (int i = 1, l, r; i <= m; i ++)\n\t\tl = Read(), r = Read(), a[l] = max(a[l], r);\n\tfor (int i = 0, r = a[1]; i < n; i ++, r = max(r, a[i + 1]))\n\t\tfor (int j = 0; j <= s[r]; j ++)\n\t\t\tif (f[i][j])\n\t\t\t{\n\t\t\t\tif (s[r] - j < r - i)\n\t\t\t\t\tf[i + 1][j] = (f[i + 1][j] + f[i][j]) % mod;\n\t\t\t\tif (s[r] - j)\n\t\t\t\t\tf[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j]) % mod;\n\t\t\t}\n\treturn printf(\"%d\\n\", f[n][s[n]]), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tfor(ll i=0;i<=3000;i++){\n\t\tfor(ll j=0;j<=3000;j++){\n\t\t\tban[i][j] = false;\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\t//assert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\tm = table.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\ttable.pb(P(y.back() + 1, INF));\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = max(table[i].second, rightmost);\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\t//assert(problemid == 0);\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    vec rmax(N);\n    REP(i, N) rmax[i] = i;\n    int r0 = -1;\n    REP(i, M){\n        r0 = max(r0, r[i]);\n        FOR(j, l[i], min(l[i + 1], r0 + 1)) rmax[j] = r0;\n    }\n\n    int mod = 1000000007;\n\n    mat dp(N + 1, vec(N + 1, 0));\n    dp[0][0] = 1;\n    REP(i, N){\n        int t = n1[rmax[i] + 1];\n        int u = max(t - (rmax[i] - i), 0LL);\n        FOR(j, u, t + 1){\n            if(j == 0) dp[i + 1][0] = 1;\n            else dp[i + 1][j] = (dp[i][j - 1] + dp[i][j]) % mod;\n        }\n    }\n    //debug(dp);\n    \n    cout << dp[N][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 4003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[r[i - 1]] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[r[i - 1]]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\tint L[3000], R[3000];\n\trep(i, M) cin >> L[i] >> R[i];\n\n\tll mod = 1e9 + 7;\n\tll dp[3001][3001] = {};\n\tdp[0][0] = 1;\n\t//jが使ったゼロね\n\tint k = 0;\n\tint mae = 0;\n\tint zero = 0;\n\trep(i, N) {\n\t\tint k2 = max(mae, i + 1);\n\t\twhile (k < N && i >= L[k] - 1) {\n\t\t\tk2 = max(k2, R[k]);\n\t\t\tk++;\n\t\t}\n\t\tfor (int x = mae; x < k2; x++) {\n\t\t\tif (S[x] == '0') zero++;\n\t\t}\n\t\tmae = k2;\n\n\t\tce(i);\n\t\tcesp(mae);\n\t\tce(zero);\n\n\t\trep(j, N) {\n\t\t\tif (j + 1 <= zero) dp[i + 1][j + 1] += dp[i][j];\n\t\t\tif (i - j + 1 <= mae - zero) dp[i + 1][j] += dp[i][j];\n\t\t}\n\t\trep(j, N + 1) dp[i + 1][j] %= mod;\n\t}\n\n\tll kotae = 0;\n\trep(j, N + 1) kotae += dp[N][j];\n\tco(kotae);\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint const N = 3e3 + 41;\nint const MOD = 1e9 + 7;\n\nint n, m, a[N], dp[N][N], was[N][N], maxi[N], mini[N], sum, pMini[N], pMaxi[N];\n\nbool comp(int a, int b){\n\treturn b < a;\n}\n\nvoid read(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%1d\",&a[i]);\n\t\tsum += a[i];\n\t\tmini[i] = maxi[i] = a[i];\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint le, ri;\n\t\tscanf(\"%d %d\",&le,&ri);\n\t\tsort(mini+le,mini+ri+1,comp);\n\t\tsort(maxi+le,maxi+ri+1);\n\t}\n}\n\nvoid prepare(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n}\n\nvoid findP(){\n\tint curMini = 0;\n\tint curMaxi = 0;\n\tfor(int i=1;i<=n;++i){\n\t\tcurMini += mini[i];\n\t\tcurMaxi += maxi[i];\n\t\tif(mini[i] == 1){\n\t\t\tpMini[curMini] = i;\n\t\t}\n\t\tif(maxi[i] == 1){\n\t\t\tpMaxi[curMaxi] = i;\n\t\t}\n\t}\n}\n\nint rec(int one, int pos){\n\tif(was[one][pos]){\n\t\treturn dp[one][pos];\n\t}\n\twas[one][pos] = 1;\n\tif(one == 0){\n\t\treturn dp[one][pos] = 1;\n\t}\n\tif(pos == 0){\n\t\treturn dp[one][pos] = 0;\n\t}\n\n\tif(pos < pMini[one]){\n\t\treturn dp[one][pos] = 0;\n\t}\n\tif(pMini[one] <= pos && pos <= pMaxi[one]){\n\t\tdp[one][pos] += rec(one-1, pos-1);\n\t}\n\tdp[one][pos] += rec(one, pos-1);\n\tdp[one][pos] %= MOD;\n\n\treturn dp[one][pos];\n}\n\nvoid solve(){\n\tfindP();\n\tprintf(\"%d\\n\",rec(sum, n));\n}\n\nint main(){\n\tprepare();\n\tread();\n\tsolve();\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n    //freopen(\"std.in\",\"r\",stdin); freopen(\"my.out\",\"w\",stdout);\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read(); r[i]=max(r[i-1],r[i]);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tl[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[max(r[i-1],l[i]-1)];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t\t//cout<<c[jb][0+t]<<\" \"<<jb<<\" \"<<t<<endl;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<(f[m][0]+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    return ModInt(u);\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt< mod > &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt< mod > &a) {\n    long long x;\n    is >> x;\n    a = ModInt< mod >(x);\n    return (is);\n  }\n\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N, M;\n  string S;\n\n  cin >> N >> M;\n  vector< int > C(N);\n  iota(begin(C), end(C), 0);\n  cin >> S;\n  for(int i = 0; i < M; i++) {\n    int l, r;\n    cin >> l >> r;\n    --l, --r;\n    chmax(C[l], r);\n  }\n  for(int i = 1; i < N; i++) {\n    chmax(C[i], C[i - 1]);\n  }\n  vector< modint > dp(N + 1); // 0を何個持っているか\n  int zero = 0, one = 0, ptr = 0;\n  dp[0] = 1;\n  for(int i = 0; i < N; i++) {\n    while(ptr <= C[i]) {\n      zero += S[ptr] == '0';\n      one += S[ptr] == '1';\n      ++ptr;\n    }\n    vector< modint > dp2(N + 1);\n    for(int j = 0; j <= zero; j++) {\n      // ゼロを使う\n      if(j + 1 <= zero) dp2[j + 1] += dp[j];\n      int rev = i - j;\n      if(rev + 1 <= one) dp2[j] += dp[j];\n    }\n    dp.swap(dp2);\n  }\n  cout << accumulate(begin(dp), end(dp), modint(0)) << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nconst long long mod = 1000000007;\n\nint N, M;\nchar S[3030];\nint l[3030], r[3030];\nlong long comb[3030][3030];\nlong long p[3030],n[3030];\n\nint main()\n{\n\tscanf(\"%d %d %s\", &N, &M, S);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\", &l[i], &r[i]);\n\t\tl[i]--; r[i]--;\n\t\tif (i > 0 && l[i - 1] == l[i])\n\t\t{\n\t\t\tif (r[i - 1] < r[i])\n\t\t\t\tr[i - 1] = r[i];\n\t\t\ti--;\n\t\t\tM--;\n\t\t}\n\t\telse if (i > 0 && r[i] <= r[i-1])\n\t\t{\n\t\t\ti--;\n\t\t\tM--;\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= N; i++){\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % mod;\n\t}\n\n\tint have = 0;\n\tp[0] = 1;\n\tfor (int i = 0; i < M; i++){\n\t\tint nxt = ((i == M - 1) ? 0 : (r[i] < l[i + 1] ? 0 : r[i] - l[i + 1] + 1));\n\n\t\tint L = (i == 0 || r[i - 1] < l[i]) ? l[i] : r[i - 1] + 1;\n\t\tint R = r[i];\n\n\t\tint cnt = 0;\n\t\tfor (int j = L; j <= R; j++) if (S[j] == '1') cnt++;\n\t\tint all = r[i] - l[i] + 1;\n\n\t\tfor (int k = 0; k <= nxt; k++) n[k] = 0;\n\n\t\tfor (int j = 0; j <= have; j++){\n\t\t\tint v = cnt + j;\n\t\t\tfor (int k = 0; k <= nxt; k++){\n\t\t\t\tint p1 = v - k;\n\t\t\t\tint p0 = (all - nxt) - p1;\n\t\t\t\tif (p1 < 0 || p0 < 0) continue;\n\n\t\t\t\tn[k] = (n[k] + p[j] * comb[all - nxt][p1]) % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k <= nxt; k++) p[k] = n[k];\n\t\thave = nxt;\n\t}\n\n\tprintf(\"%lld\\n\", p[0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#define MAXN 3005\n#define mod 1000000007\nusing namespace std;\n\nint n, m, dp[MAXN][MAXN], cnt0[MAXN];\nint qr[MAXN], qrMax[MAXN];\nchar s[MAXN];\nbool uz[MAXN][MAXN];\n\nint getCnt0Pos(int pos) {\n    return cnt0[qrMax[pos]] - cnt0[pos - 1];\n}\n\nint computeDp(int l, int c) {\n    if(l == n) return 1;\n    if(uz[l][c]) return dp[l][c];\n\n    int r = qrMax[l];\n\n    int nextC = c + cnt0[qrMax[l + 1]] - cnt0[qrMax[l]];\n    \n    dp[l][c] = 0;\n    if(c < r - l + 1)\n        dp[l][c] += computeDp(l + 1, nextC);\n    if(c > 0)\n        dp[l][c] += computeDp(l + 1, nextC - 1);\n\n    while(dp[l][c] >= mod) dp[l][c] -= mod;\n    uz[l][c] = 1;\n\n    return dp[l][c];\n}\n\nint main() {\n\n    scanf(\"%d %d\\n\", &n, &m);\n    scanf(\"%s\", s + 1);\n\n    for(int i = 1; i <= n; ++i)\n        cnt0[i] = cnt0[i - 1] + (s[i] == '0');\n\n    for(int i = 1; i <= n; ++i)\n        qr[i] = i;\n\n    for(int i = 1; i <= m; ++i) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        qr[l] = max(qr[l], r);\n    }\n\n    for(int i = 1; i <= n; ++i)\n        qrMax[i] = max(qrMax[i - 1], qr[i]);\n\n    printf(\"%d\\n\", computeDp(1, getCnt0Pos(1)));\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nint n,m,a[maxn],dp[maxn][maxn];\nchar str[maxn];int s[maxn];\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc065f.in\",\"r\",stdin);\n\t\tfreopen(\"arc065f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d %s\",&n,&m,str+1);\n\tfor (int i=1;i<=n;i++)\n\t\ts[i]=s[i-1]+(str[i]=='1'),a[i]=i;\n\tfor (int l,r,i=1;i<=m;i++)\n\t\tscanf(\"%d %d\",&l,&r),a[l]=max(a[l],r);\n\tfor (int i=1;i<=n;i++)\n\t\ta[i]=max(a[i-1],a[i]);\n\t\t\n\tdp[0][0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint o=s[a[i]]-s[a[i-1]];\n\t\tfor (int j=0;j<=s[a[i]];j++)\n\t\tif (dp[i-1][j]) {\n\t\t\tif (a[i]-i>=j+o) (dp[i][j+o]+=dp[i-1][j])%=mod;\n\t\t\tif (a[i]-i>=j+o-1) (dp[i][j+o-1]+=dp[i-1][j])%=mod;\n\t\t}\n\t}\n\tprintf(\"%d\",dp[n][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(x) (x).begin(), (x).end()\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<typename T> using V = vector<T>;\ntemplate<typename T> using P = pair<T, T>;\nusing Vi = V<int>;\nusing Vl = V<ll>;\nusing Vd = V<ld>;\nusing Vb = V<bool>;\nusing VVi = V<Vi>;\nusing VVl = V<Vl>;\nusing VVb = V<Vb>;\nusing Pi = P<int>;\nusing Pl = P<ll>;\nusing Pd = P<ld>;\ntemplate<typename T> vector<T> make_vec(size_t n, T a) { return vector<T>(n, a); }\ntemplate<typename... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec(ts...))>(n, make_vec(ts...)); }\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int cDiv(const ll x, const ll y) { return (x+y-1) / y; } // ceil(x/y)\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); } // floor(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); } // ceil(log2(x))\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\ninline void fail() { cout << -1 << '\\n'; exit(0); }\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<60;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(ll _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD ) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) {\n    int a = y.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = ll(x) * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  constexpr ModInt pow(ll n) const noexcept {\n    ModInt x(1);\n    ModInt a = *this;\n    for (; n > 0; n >>= 1, a *= a) if (n&1) x *= a;\n    return x;\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\n\nint main() {\n  int n, m; cin >> n >> m;\n\n  string s; cin >> s;\n  V<Pi> lr(m); cin >> lr;\n  rep(i, m) --lr[i].first;\n\n  auto t1 = s;\n  auto t2 = s;\n  for (auto [l, r] : lr) sort(t1.begin()+l, t1.begin()+r);\n  for (auto [l, r] : lr) sort(t2.begin()+l, t2.begin()+r, [] (auto &i, auto &j) { return i > j; });\n\n  Vi lm, rm;\n  rep(i, n) if (t1[i] == '0') lm.push_back(i);\n  rep(i, n) if (t2[i] == '0') rm.push_back(i);\n\n  Vm dp(n+1);\n  dp[0] = 1;\n  rep(i, sz(lm)) {\n    Vm tmp(n+1);\n    rep(j, rm[i]+1) tmp[j+1] = tmp[j] + dp[j];\n    rep(j, lm[i]+1) tmp[j] = 0;\n    swap(dp, tmp);\n    // dump(dp);\n  }\n\n  mint ans = 0;\n  rep(i, n+1) ans += dp[i];\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define mod 1000000007\n\ntypedef long long ll;\n\nint N,M,m;\nll sum[300030] = {0};\nll que[300030][2] = {0};\nll F[300030] = {0},R[300003] = {0};\nll dp[3030][3030];\nvector<int> QL,QR;\n\nll con(ll a,ll b)\n{\n    return F[a] * R[b] % mod * R[a - b] % mod;\n}\n\nll P(ll n,ll s)\n{//printf(\"  %lld %lld\\n\",n,s);\n    if(dp[n][s] != -1)return dp[n][s];\n    ll res = 0;\n    ll l,r;\n    if(n == QR.size() - 1)\n    {\n        l = QL[n];r = QR[n];\n        res = con(r - l + 1,sum[r] - s);\n        return res;\n    }\n    l = QL[n],r = min(QR[n],QL[n + 1] - 1);\n    ll mem = sum[QR[n]] - s;\n    ll p = 0;\n    if(QR[n] < QL[n + 1])p = sum[QL[n + 1] - 1] - sum[QR[n] + 1];\n\n    //printf(\" %lld %lld %lld %lld\\n\",l,r,mem,(r - l + 1) - (QR[n] - l + 1 - mem));\n    for(int i = max((ll)0,(r - l + 1) - (QR[n] - l + 1 - mem)); i <= min(mem,r - l + 1); i++)\n    {\n        res += P(n + 1,s + i + p) * con(r - l + 1,i);\n        res %= mod;\n    }\n    return dp[n][s] = res;\n}\n\nll power(ll a,ll b)\n{\n    if(b == 0)return 1;\n    ll res = power(a * a % mod,b / 2);\n    if(b & 1)res = res * a % mod;\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i = 0; i < 3030; i++)for(int j = 0; j < 3030; j++)dp[i][j] = -1;\n    F[0] = 1;\n    for(int i = 1; i <= 3030; i++)F[i] = F[i - 1] * i % mod;\n    for(int i = 0; i <= 3030; i++)R[i] = power(F[i],mod - 2);\n    for(int i = 1; i <= N; i++)\n    {\n        char c;\n        scanf(\" %c\",&c);\n        sum[i] = sum[i - 1] + (c == '1');\n    }\n    for(int i = 0; i < M; i++)\n    {\n        scanf(\"%lld%lld\",&que[i][0],&que[i][1]);\n        if(i != 0)que[i][1] = max(que[i][1],que[i - 1][1]);\n    }\n    for(int i = 0; i < M; i++)\n    {\n        if(i == 0)\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n        if(QL[QL.size() - 1] == que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QR[QR.size() - 1] = que[i][1];\n        }\n        else if(QL[QL.size() - 1] < que[i][0] && QR[QR.size() - 1] < que[i][1])\n        {\n            QL.push_back(que[i][0]);\n            QR.push_back(que[i][1]);\n        }\n    }\n    /*\n    for(int i = 0; i < QR.size(); i++)\n    {\n        printf(\" %d %d\\n\",QL[i] ,QR[i]);\n    }\n    */\n    printf(\"%lld\\n\",P(0,sum[QL[0] - 1]));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tstring s=readString();\n\tint len=s.size();\n\tvi c(len,0);\n\tREP(i,len)if(s[i]=='1')\n\t\tc[i]++;\n\tFOR(i,1,len)\n\t\tc[i]+=c[i-1];\n\tvi cur(n+1,0),nx(n+1,0);\n\tvi qs(n);\n\tREP(i,n)\n\t\tqs[i]=i;\n\tREP(i,m){\n\t\tint l=read()-1,r=read()-1;\n\t\tchmax(qs[l],r);\n\t}\n\tint rMax=0;\n\tcur[0]=1;\n\tREP(i,n){\n\t\tchmax(rMax,qs[i]);\n\t\tfill(ALL(nx),0);\n\t\tREP(x,n+1)if(cur[x]){\n\t\t\tint p=c[rMax]-x;\n\t\t\tint q=(rMax+1-c[rMax])-(i-x);\n\t\t\tif(p>0){\n\t\t\t\tadd(nx[x+1],cur[x]);\n\t\t\t}\n\t\t\tif(q>0){\n\t\t\t\tadd(nx[x],cur[x]);\n\t\t\t}\n\t\t}\n\t\tswap(nx,cur);\n\t}\n\tcout<<cur[c[n-1]]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define pb emplace_back\n#define mp make_pair\n#define endl '\\n'\n#define f first\n#define s second\n\n#ifdef SEREZHKA\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T>\nvoid _dbg(const char* _s, T _h) { cerr << _s << \" = \" << _h << \"\\n\"; }\n\ntemplate<typename T, typename... Ts>\nvoid _dbg(const char*_s, T _h, Ts... _t) {\n    int _b = 0;\n    \n    while (((_b += *_s == '(') -= *_s == ')') != 0 || *_s != ',')\n        cerr << *_s++;\n    \n    cerr << \" = \" << _h << \",\";\n    _dbg(_s + 1, _t...);\n}\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7ll;\nconst ll LINF = INF * INF;\nconst int MAXN = static_cast<int>(3e3) + 17;\n\nint n, m, u;\nstring s;\nint R[MAXN];\nint S[MAXN];\nll binomial[MAXN][MAXN], dp[MAXN][MAXN];\nint U[MAXN][MAXN];\n\nbool read() {\n    if (!(cin >> n >> m >> s))\n        return false;\n\n    forn (i, m) {\n        int l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n\n    return true;\n}\n\nll add(ll a, ll b) { return (a += b) >= INF ? a - INF : a; }\n\nll dfs(int i, int cnt, const vector< pair<int, int> >& v) {\n    if (i == sz(v) - 1)\n        return binomial[v[i].s - v[i].f + 1][cnt];\n\n    if (U[i][cnt] == u)\n        return dp[i][cnt];\n\n    U[i][cnt] = u;\n    dp[i][cnt] = 0;\n    ll& res = dp[i][cnt];\n    \n    for (int k = 0; k <= cnt; ++k)\n        if (k <= v[i + 1].f - v[i].f && cnt - k <= v[i].s - v[i + 1].f + 1)\n            res = add(res, dfs(i + 1, cnt - k + S[v[i + 1].s] - S[v[i].s], v) * binomial[v[i + 1].f - v[i].f][k] % INF);\n\n    return dp[i][cnt];\n}\n\nvoid solve() {\n    forn (i, n)\n        S[i + 1] = s[i] - '0';\n\n    forn (i, n)\n        S[i + 1] += S[i];\n\n    binomial[0][0] = 1;\n\n    for (int i = 1; i <= n; ++i)\n        for (int j = 0; j <= i; ++j)\n            binomial[i][j] = add(binomial[i - 1][j], j ? binomial[i - 1][j - 1] : 0ll);\n\n    ll ans = 1ll;\n\n    for (int l = 1; l <= n; ) {\n        if (R[l] == 0) {\n            ++l;\n            continue;\n        }\n\n        int l1 = l, mxr = l1;\n        vector< pair<int, int> > vec;\n\n        for (; l1 <= mxr; ++l1)\n            if (R[l1] > mxr) {\n                mxr = R[l1];\n                vec.pb(mp(l1, R[l1]));\n            }\n\n        ++u;\n        ans = ans * dfs(0, S[vec[0].s] - S[vec[0].f - 1], vec);\n        l = l1;\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    \n    while (read())\n        solve();\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 1 << 20;\n\nint n, m, f[N], g[N], r[N], L[N], R[N], tot[N], dp[1 << 12][1 << 12], ones[N], A[N], B[N], C[N];\nchar a[N];\npair<int, int> p[N];\n\ninline int calc_ones(int st, int en) {\n\tif (st == 0) return ones[en];\n\treturn ones[en] - ones[st - 1];\n}\n\ninline int nCm(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn (long long)f[n] * g[m] % mod * g[n - m] % mod;\n}\n\nnamespace FFT {\n\tconst int M = 1<<18;\n\n\tusing DB = long double;\n\tusing LL = long long;\n\n\tstruct CP {\n\t\tDB x, y;\n\t\tCP(DB x=0, DB y=0) : x(x), y(y) {}\n\t\tCP operator+(const CP &rhs) const {\n\t\t\treturn CP(x+rhs.x, y+rhs.y);\n\t\t}\n\t\tvoid operator+=(const CP &rhs) {\n\t\t\tx += rhs.x, y += rhs.y;\n\t\t}\n\t\tCP operator-(const CP &rhs) const {\n\t\t\treturn CP(x-rhs.x, y-rhs.y);\n\t\t}\n\t\tCP operator*(const CP &rhs) const {\n\t\t\treturn CP(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);\n\t\t}\n\t\tCP operator!() const {\n\t\t\treturn (CP) {\n\t\t\t\tx, -y\n\t\t\t};\n\t\t}\n\t\tvoid operator*=(const CP &rhs) {\n\t\t\tDB tx = x*rhs.x-y*rhs.y, ty = x*rhs.y+y*rhs.x;\n\t\t\tx = tx, y = ty;\n\t\t}\n\t} f[M], g[M], h[M], p_w[M+1];\n\n\tint bit_inv[M];\n\n\tvoid init() {\n\t\tDB alpha = acos(-1)/M*2;\n\t\tfor (int i = 0; i <= M; i++) p_w[i] = CP(cos(alpha*i), sin(alpha*i));\n\t\tfor (int i = 0, j = 1; j < M; j++) {\n\t\t\tfor (int k = M >> 1; (i ^= k) < k; k >>= 1);\n\t\t\tbit_inv[j] = i;\n\t\t}\n\t}\n\n\tvoid FFT(CP *A, int N, int D = 1) {\n\t\tfor (int j = 1, i, d = __builtin_ctz(M/N); j < N-1; j++) if ((i = (bit_inv[j] >> d)) < j) swap(A[i], A[j]);\n\t\tfor (int n = 1, m = M/2*D; n < N; m /= 2, n <<= 1) {\n\t\t\tfor (int i = 0; i < N; i += n<<1) {\n\t\t\t\tCP *w = (D == 1 ? p_w : p_w + M), *a = A+i, *b = A+i+n;\n\t\t\t\tfor (int j = 0; j < n; j++, a++, b++, w += m) {\n\t\t\t\t\tCP x = *w **b;\n\t\t\t\t\t*b = *a - x;\n\t\t\t\t\t*a += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D != 1) for (int i = 0; i < N; i++) A[i].x /= N, A[i].y /= N;\n\t}\n\n\tvoid conv(int *A, int *B, int *C, int N, int MOD) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t}\n\t\t\tmemcpy(C, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) g[i] = CP(B[i]>>15, B[i]&32767);\n\t\tFFT(g, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=((f[i]+!f[j])*(!g[j]-g[i])+(!f[j]-f[i])*(g[i]+!g[j]))*CP(0,0.25);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (LL(h[i].x+0.5)%MOD<<15)%MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=(!f[j]-f[i])*(!g[j]-g[i])*CP(-0.25, 0)+CP(0, 0.25)*(f[i]+!f[j])*(g[i]+!g[j]);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (C[i] + LL(h[i].x+0.5)+((LL(h[i].y+0.5)%MOD)<<30)) % MOD;\n\t}\n\n\tvoid conv(int *A, int *B, int N, int P) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * A[j]) % P;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * A[j]) % P;\n\t\t\t}\n\t\t\tmemcpy(B, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=((!(f[j]*f[j]))-f[i]*f[i])*CP(0,0.5);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (LL(g[i].x+0.5)%P<<15)%P;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=(!f[j]-f[i])*(!f[j]-f[i])*CP(-0.25,0)+CP(0,0.25)*(f[i]+!f[j])*(f[i]+!f[j]);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (B[i] + LL(g[i].x+0.5)+((LL(g[i].y+0.5)%P)<<30)) % P;\n\t}\n};\n\nint solve(int st, int en) {\n\tfor (int i = st; i <= en; i++) {\n\t\tint common = 0;\n\t\tif (i < en) common = p[i].second - p[i + 1].first + 1;\n\t\tR[i] = min(p[i].second - p[st].first + 1 - common, calc_ones(p[st].first, p[i].second));\n\t\tL[i] = max(0, R[i] - common);\n\t\ttot[i] = p[i].second - p[i].first + 1 - common;\n\t}\n\tfor (int i = st; i <= en; i++) {\n\t\tif (i == st) {\n\t\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = nCm(tot[i], j);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= R[i]; k++) A[k] = dp[i - 1][k];\n\t\tfor (int k = 0; k <= R[i]; k++) B[k] = nCm(tot[i], k);\n\t\tint len = 1 << (32 - __builtin_clz(R[i] * 2 + 1));\n\t\tfor (int k = R[i] + 1; k < len; k++) A[k] = B[k] = 0;\n\t\tFFT::conv(A, B, C, len, mod);\n\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = C[j];\n//\t\t{\n//\t\t\tfor (int k = L[i - 1]; k <= R[i - 1]; k++) {\n//\t\t\t\tdp[i][j] = (dp[i][j] + (long long)dp[i - 1][k] * nCm(tot[i], j - k)) % mod;\n//\t\t\t}\n//\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = L[en]; i <= R[en]; i++) ret = (ret + dp[en][i]) % mod;\n\treturn ret;\n}\n\nint main() {\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tFFT::init();\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tf[0] = r[0] = r[1] = g[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) f[i] = (long long)f[i - 1] * i % mod;\n\t\tif (i > 1) r[i] = (long long)(mod - mod / i) * r[mod % i] % mod;\n\t\tif (i) g[i] = (long long)g[i - 1] * r[i] % mod;\n\t}\n//\tint ans = 0;\n//\tfor (int a = 2; a <= 3; a++) {\n//\t\tfor (int b = 4 - a; b <= 5 - a; b++) {\n//\t\t\tint c = 7 - a - b;\n//\t\t\tans += nCm(3, a) * nCm(2, b) * nCm(4, c);\n//\t\t}\n//\t}\n//\tcout << ans << endl;\n\tcin >> n >> m >> a;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) ones[i] = ones[i - 1];\n\t\tif (a[i] == '1') ones[i]++;\n\t}\n\tvector<pair<int, int>> vec;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> p[i].first >> p[i].second;\n\t\tp[i].first--;\n\t\tp[i].second--;\n\t\tif (i && p[i].second <= vec.back().second) continue;\n\t\tvec.push_back(p[i]);\n\t}\n\tm = vec.size();\n\tfor (int i = 0; i < m; i++) p[i] = vec[i];\n\tcout << solve(0, m - 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3005;\nconst int mod = 1e9+7;\n\nint n, m, f[N][N];\nchar s[N];\nint l[N], r[N], d[N], sum[N];\nint fact[N], rev[N];\n\nint pw(int a, int n) {\n    int result = 1;\n    while (n > 0) {\n        if (n & 1) result = (1LL * result * a) % mod;\n        a = (1LL * a * a) % mod;\n        n /= 2;\n    }\n    return result;\n}\n\nvoid prepare() {\n    fact[0] = rev[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = (1LL * fact[i - 1] * i) % mod;\n        rev[i] = pw(fact[i], mod - 2);\n    }\n}\n\nint c(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    int result = 1;\n    result = (1LL * result * fact[n]) % mod;\n    result = (1LL * result * rev[n - k]) % mod;\n    result = (1LL * result * rev[k]) % mod;\n    return result;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= mod) x -= mod;\n}\n\nint solve(int L, int R) {\n    int ones = sum[r[L]] - sum[l[L]-1];\n    for (int i = 0; i <= n; ++i) {\n        f[L][i] = 0;\n    }\n    f[L][ones] = 1;\n    for (int i = L; i < R; ++i) {\n        for (int ones = 0; ones <= n; ++ones) {\n            if (!f[i][ones]) continue;\n            int diff = r[i]-l[i+1]+1;\n            int nones = sum[r[i+1]]-sum[r[i]];\n            int len = r[i]-l[i]+1;\n            for (int x = max(0, ones-len+diff); x <= min(ones, diff); ++x) {\n                add(f[i+1][nones+x], 1LL * f[i][ones] * c(len-diff, ones-x) % mod);\n            }\n        }\n    }\n    int result = 0;\n    int len = r[R]-l[R]+1;\n    for (int i = 0; i <= len; ++i) {\n        add(result, 1LL * c(len, i) * f[R][i] % mod);\n    }\n    return result;\n}\n\nint main() {\n    prepare();\n    scanf(\"%d %d %s\", &n, &m, s + 1);\n    for (int i = 1; i <= n; ++i) {\n        sum[i] = sum[i - 1] + (s[i] == '1');\n    }\n    for (int i = 1; i <= m; ++i) {\n        scanf(\"%d %d\", l + i, r + i);\n    }\n    for (int i = 1; i <= m; ++i) {\n        if (d[i]) continue;\n        for (int j = 1; j <= m; ++j) {\n            if (i == j) continue;\n            if (l[i] <= l[j] && r[i] >= r[j]) d[j] = 1;\n        }\n    }\n    int pos = 1;\n    for (int i = 1; i <= m; ++i) {\n        if (!d[i]) {\n            l[pos] = l[i];\n            r[pos] = r[i];\n            ++pos;\n        }\n    }\n    m = pos - 1;\n    int result = 1;\n    for (int i = 1; i <= m; ++i) {\n        int j = i + 1;\n        while (j < m + 1 && r[j - 1] >= l[j]) ++j;\n        result = (1LL * result * solve(i, j - 1)) % mod;\n        i = j - 1;\n    }\n    printf(\"%d\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define int long long\n#define MOD 1000000007\nusing namespace std;\n\nsigned main(){\n\tint n,m,dp[2001][2001] = {},zero[2001] = {},one[2001] = {},migi[2001] = {};\n\tstring s;\n\tcin >> n >> m >> s;\n\tfor(int i = 0;i < n;i++){\n\t\tzero[i + 1] = zero[i];\n\t\tone[i + 1] = one[i];\n\t\tif(s[i] == '1') one[i + 1]++;\n\t\telse zero[i + 1]++;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tfor(int j = l;j <= r;j++) migi[j] = max(migi[j],r);\n\t}\n\tfor(int i = 1;i <= n;i++) migi[i] = max(migi[i],i);\n\tfor(int i = 0;i <= one[n];i++){\n\t\tfor(int j = 0;j <= zero[n];j++){\n\t\t\tif(!i && !j){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tdp[i + 1][j]++;\n\t\t\t\tdp[i][j + 1]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint t = migi[i + j];\n\t\t\t\tif(one[t] < i || zero[t] < j) dp[i][j] = 0;\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t\t\t(dp[i][j + 1] += dp[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[one[n]][zero[n]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int Maxn = 3005;\n\nint n, m;\nstring S;\nint ones[Maxn];\nint mx[Maxn];\nint dp[Maxn][Maxn];\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tcin >> S;\n\tfor (int i = 0; i < n; i++) {\n\t\tones[i] = (i? ones[i - 1]: 0) + (S[i] == '1');\n\t\tmx[i] = i;\n\t}\n\twhile (m--) {\n\t\tint l, r; scanf(\"%d %d\", &l, &r); l--; r--;\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tmx[i] = max(mx[i], r);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j <= i; j++) if (dp[i][j] > 0) {\n\t\t\tint lones = ones[mx[i]] - j;\n\t\t\tint lzeros = mx[i] - i + 1 - lones;\n\t\t\tif (lones > 0) dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % mod;\n\t\t\tif (lzeros > 0) dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;\n\t\t}\n\tprintf(\"%d\\n\", dp[n][ones[n - 1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nint l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return x*x%MOD;\n}\nint modpow(ll x,ll y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=ret*(x-i)%MOD;\n        ret=ret*inv(i+1)%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        int le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max(0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 100\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int, int> pii;\n\n#define maxn 500005\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 200000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\n\nvector < pair<int,int> > vp ;\n\nchar str[maxn] ;\nint s[maxn] ;\n\nint dp[3005][3005] ;\n\nint n , m ;\n\nint f(int i , int ones)\n{\n    if( i==m ) return 1 ;\n    if( dp[i][ones] != -1  ) return dp[i][ones] ;\n\n    int la = vp[i].xx , ra = vp[i].yy ;\n\n    int totones = ones ;\n    int lb = la , rb =  ra ;\n    if( i > 0 && vp[i-1].yy >= vp[i].xx ) lb = vp[i-1].yy+1 ;\n\n    totones += (s[rb]-s[lb-1]) ;\n\n    int totzeroes = (ra-la+1) - totones ;\n\n    int ans = 0 ;\n    int rc = ra ;\n    if( i+1 < m && vp[i+1].xx <= rc ) rc = vp[i+1].xx-1 ;\n\n //   printf(\"--- %d %d la:%d ra:%d lb:%d rb:%d rc:%d\\n\",i,ones,la,ra,lb,rb,rc) ;\n\n    for(int j=0 ; j<=(rc-la+1) ; j++ )\n    {\n        int cone = j , czero = (rc-la+1) - cone ;\n        if( cone > totones || czero > totzeroes ) continue ;\n\n        int ret = C(cone+czero,cone) ;\n        if( i+1 < m ) ret = (1LL*ret*f(i+1, totones-cone) )%mod ;\n//        DBG ;\n        ans = (ans+ ret)%mod ;\n    }\n\n    return dp[i][ones] = ans ;\n}\n\nint main()\n{\n    preprocess() ;\n\n    scanf(\"%d %d\",&n,&m) ;\n\n    scanf(\"%s\",str) ;\n    for(int i=1 ; i<=n ; i++)\n    {\n        s[i]  = s[i-1] ;\n        if( str[i-1]=='1' ) s[i]++ ;\n    }\n\n    for(int i=1 ; i<=m ; i++)\n    {\n        int l , r ;\n        scanf(\"%d %d\",&l,&r) ;\n\n        if( vp.size() != 0 )\n        {\n            int sz = (int)vp.size() ;\n\n            if( vp[sz-1].xx == l ) vp[sz-1].yy = max(vp[sz-1].yy,r) ;\n            else if( vp[sz-1].yy < r ) vp.pb( mp(l,r) ) ;\n        }\n        else vp.pb( mp(l,r) ) ;\n    }\n\n    m = vp.size() ;\n\n //   for( auto p: vp ) printf(\"%d %d\\n\",p.xx,p.yy ) ;\n\n    memset(dp,-1,sizeof(dp)) ;\n\n    int ans = f(0,0) ;\n\n    printf(\"%d\\n\",ans) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\nstruct segtree{\n  ll M=1, INIT;\n  vector<ll> dat;\n  segtree(ll N, ll num){\n    INIT = num;\n    while(M<N) M*=2;\n    for(int i=0;i<M*2-1;i++)  dat.push_back(num);\n  }\n  void update(ll x, ll k, ll l=0, int r=-1){\n    if(r==-1) r = M;\n    k+=M-1;\n    dat[k] += x;\n    while(k>0) k = (k-1)/2, dat[k] = dat[k*2+1] + dat[k*2+2];\n  }\n  ll query(ll a, ll b=-1, ll k=0, ll l=0, ll r=-1){\n    if(r==-1) r = M;\n    if(b==-1) b = M;\n    if(r<=a || b<=l) return INIT;\n    if(a<=l && r<=b) return dat[k];\n    ll A = query(a, b, k*2+1, l, (l+r)/2);\n    ll B = query(a, b, k*2+2, (l+r)/2, r);\n    return A + B;\n  }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, m;std::cin >> n >> m;\n  vvl dp = VV(n+1, n+1, 0, ll);\n  string s;std::cin >> s;\n  segtree b(n+1, 0);\n  for(int i=0;i<n;i++) b.update((s[i]=='1'), i);\n  dp[0][0] = 1;\n  vvl d;\n  ll r = -1;\n  for(int i=0;i<m;i++){\n    ll x, y;std::cin >> x >> y;\n    x--, y--;\n    if(r>=y) continue;\n    r = y;\n    if(d.size()!=0&&d[d.size()-1][0]==x){\n      d[d.size()][1] = r;\n    }else{\n      d.push_back(vll{x, y});\n    }\n  }\n  m = d.size();\n  for(int i=0;i<n;i++){\n    auto itr = upper_bound(all(d), vll{i, -1});\n    ll r;\n    if(itr==d.begin()) r = i-1;\n    else {\n      r = (*--itr)[1];\n      if(r < i) r = i-1;\n    }\n\n    ll sa = r - i + 1;\n    itr = upper_bound(all(d), vll{i, 100000});\n    ll ad = 0;\n    if(itr!=d.begin()){\n      itr--;\n      if((*itr)[0]==i){\n        ad = b.query(r+1, (*itr)[1]+1);\n        sa = (*itr)[1] - i + 1;\n      }\n    }\n    if(sa==0){\n      dp[i+1] = dp[i];\n    }else{\n      //元々のr\n      for(int j=0;j<=n;j++){\n        ll one = j + ad;\n        if(one>n || sa < one) continue;\n        ll zero = sa - one;\n        if(one) dp[i+1][one-1] = (dp[i+1][one-1] + dp[i][j])%P;\n        if(zero) dp[i+1][one] = (dp[i+1][one] + dp[i][j])%P;\n      }\n    }\n  }\n  std::cout << dp[n][0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int N=3005,P=1e9+7;\n\nint fac[N],ifac[N];\nint fpow(int a,int t){static int r;for(r=1;t;t>>=1,a=(ll)a*a%P)if(t&1)r=(ll)r*a%P;return r;}\nint C(int n,int m){if(n<m)return 0;return (ll)fac[n]*ifac[m]%P*ifac[n-m]%P;}\n\nint n,m,f[N],L,R,sum[N];\nchar str[N];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+(str[i]&1);\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%P;\n\tifac[n]=fpow(fac[n],P-2);\n\tfor(int i=n;i>=1;i--)ifac[i-1]=(ll)ifac[i]*i%P;\n\tf[0]=1;\n\tfor(int i=1,l,r;i<=m;i++){\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(r<=R)continue;\n\t\tif(R<l){\n\t\t\tint t=0;\n\t\t\tfor(int i=0;i<=n;i++)if(f[i])t=(t+(ll)C(R-L+1,i))%P,f[i]=0;\n\t\t\tL=l,R=r,f[sum[R]-sum[L-1]]=t;\n\t\t}else{\n\t\t\twhile(L<l){\n\t\t\t\tfor(int i=1;i<=n;i++)if(f[i])(f[i-1]+=f[i])%=P;\n\t\t\t\tL++;\n\t\t\t}\n\t\t\tfor(int i=R-L+2;i<=n;i++)f[i]=0;\n\t\t\tint t=sum[r]-sum[R];\n\t\t\tfor(int i=n,x;i>=0;i--)if(f[i])x=f[i],f[i]=0,f[i+t]=x;\n\t\t\tR=r;\n\t\t}\n\t}\n\tint t=0;\n\tfor(int i=0;i<=n;i++)if(f[i])t=(t+(ll)f[i]*C(R-L+1,i))%P;\n\tprintf(\"%d\\n\",t);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x first\n#define y second\n\nusing namespace std;\n\nint N, M, mod, s[3009], rgt[3009], dp[3009][3009];\nchar sir[3009];\n\nvoid ad (int &i, int j)\n{\n    i += j;\n    if (i >= mod) i -= mod;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\\n\", &N, &M), mod = 1e9 + 7;\ngets (sir + 1);\nfor (int i=1; i<=N; i++)\n    s[i] = s[i - 1] + (sir[i] == '1');\nfor (int i=1; i<=N; i++)\n    rgt[i] = i;\nwhile (M --)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    if (y > rgt[x]) rgt[x] = y;\n}\ndp[0][0] = 1;\nint R = 0;\nfor (int i=0; i<N; i++)\n{\n    for (int j=0; j<=R - i; j++)\n    if (dp[i][j])\n    {\n        //printf (\"primele %d si pe [%d, %d] inca %d de 1 -> %d\\n\", i, i + 1, R, j, dp[i][j]);\n        int k1 = j, k0 = (R - i) - j, mk0 = 0, mk1 = 0;\n        if (rgt[i + 1] > R) mk1 = s[rgt[i + 1]] - s[R], mk0 = rgt[i + 1] - R - mk1;\n        k0 += mk0, k1 += mk1;\n        if (k1 >= 1) ad (dp[i + 1][k1 - 1], dp[i][j]);\n        if (k0 >= 1) ad (dp[i + 1][k1], dp[i][j]);\n    }\n    if (rgt[i + 1] > R) R = rgt[i + 1];\n}\nprintf (\"%d\\n\", dp[N][0]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n\t#define debug(...) printf(__VA_ARGS__)\n#else\n\t#define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nconst int MAXN = 3030;\nconst int MAXM = 3030;\nconst int MOD = 1000000007;\ninline int add(int x, int y) { return (x + y) % MOD; }\n\nchar S[MAXN];\nint cnt[MAXN];\nint dp[MAXN][MAXN];\nint l[MAXM], r[MAXM];\n\nint main() {\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int i = 0; i < M; i++)\n\t\tscanf(\"%d%d\", &l[i], &r[i]);\n\tcnt[0] = 0;\n\tfor(int i = 1; i <= N; i++)\n\t\tcnt[i] = cnt[i - 1] + S[i] - '0';\n\tdp[l[0] - 1][cnt[l[0] - 1]] = 1;\n\tint ans = -1;\n\tfor(int i = 0; i < M; i++) {\n\t\tint tl = l[i], tr = r[i];\n\t\twhile(i + 1 < M && (l[i + 1] == tl || r[i + 1] <= tr)) {\n\t\t\ti++;\n\t\t\ttr = max(tr, r[i]);\n\t\t}\n\t\tfor(int j = tl; (i == M - 1 || j < l[i + 1]) && j <= tr; j++) {\n\t\t\tfor(int k = 0; k <= N; k++) {\n\t\t\t\tif(cnt[tr] >= k && tr - cnt[tr] >= j - k) \n\t\t\t\t\tdp[j][k] = add(dp[j][k], add(dp[j - 1][k - 1], dp[j - 1][k]));\n\t\t\t\t/*if(cnt[tr] )\n\t\t\t\t\tdp[j][k] += dp[j - 1][k];*/\n\t\t\t\tdebug(\"dp[%d][%d] = %d\\n\", j, k, dp[j][k]);\n\t\t\t}\n\t\t}\n\t\tif(i == M - 1) {\n\t\t\tans = dp[tr][cnt[tr]];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nchar s[5000];\nint c[5000];\nll dp[3005][3005],nck[3005][3005];\nint u[N];\nll solve(vector<pii> z){\n  REP(i,z.size()+1) REP(j,3005) dp[i][j]=0;\n  dp[0][c[z[0].Y]-c[z[0].X-1]]=1;\n  ll ans=0;\n  REP(i,z.size()) REP(j,3005) if(dp[i][j]){\n    if(i+1==z.size()){\n      ans+=nck[z[i].Y-z[i].X+1][j]*dp[i][j]%mod;\n    }else{\n      int ex=c[z[i+1].Y]-c[z[i].Y],zo=z[i].Y-z[i].X+1-j;\n      REP(k,min(j,z[i+1].X-z[i].X)+1) if(z[i+1].X-z[i].X-k<=zo){\n        dp[i+1][ex+j-k]+=nck[z[i+1].X-z[i].X][k]*dp[i][j]%mod;\n        dp[i+1][ex+j-k]%=mod;\n      }\n    }\n  }\n  return ans%mod;\n}\nint main(){\n  nck[0][0]=1;\n  REPP(i,1,3005){\n    nck[i][0]=1;\n    REPP(j,1,i+1) nck[i][j]=(nck[i-1][j]+nck[i-1][j-1])%mod;\n  }\n  int n,m; scanf(\"%d%d%s\",&n,&m,s);\n  vector<pii> a,nw;\n  ll ans=1;\n  REP(i,n) c[i+1]=c[i]+(s[i]=='1');\n  REP(i,m){\n    pii x;\n    scanf(\"%d%d\",&x.X,&x.Y);\n    a.pb(x);\n  }\n  sort(all(a));\n  a.resize(unique(all(a))-a.begin());\n  REP(i,m) REP(j,m) if(i!=j){\n    if(a[i].X<=a[j].X&&a[j].Y<=a[i].Y) u[j]=1;\n  }\n  REP(i,m) if(!u[i]) nw.pb(a[i]);\n  a=nw;\n  int tl=0;\n  while(tl<a.size()){\n    vector<pii> cur; cur.pb(a[tl++]);\n    while(tl<a.size()&&a[tl].X<=cur.back().Y) cur.pb(a[tl++]);\n    ans=ans*solve(cur)%mod;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nint getint()\n{\n    char ch=getchar();\n    int f=1,x=0;\n    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return f*x;\n}\n\nconst int N=3030;\nconst int MOD=1000000007;\n\nint n,m;\nchar s[N];\nint sum[N];\nint l[N],r[N];\nlong long c[N][N],f[N][N];\n\nvoid init()\n{\n    n=getint(),m=getint();\n    scanf(\"%s\",s+1);\n    for(int i=1; i<=n; i++) sum[i]=sum[i-1]+s[i]-'0';\n    int tot=0;\n    for(int i=1; i<=m; i++){\n        int ll=getint(),rr=getint();\n        if(ll==l[tot]){\n            r[tot]=max(r[tot],rr);\n        }else if(rr<=r[tot]){\n        }else{\n            tot++;\n            l[tot]=ll;\n            r[tot]=rr;\n        }\n    }\n    m=tot;\n    for(int i=0; i<=n; i++){\n        c[i][0]=1;\n        for(int j=1; j<=i; j++){\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;\n        }\n    }\n    l[m+1]=n+1;\n    r[m+1]=n+1;\n}\n\nint main()\n{\n    init();\n    f[0][0]=1;\n    for(int i=1; i<=m; i++){\n        int nxt=r[i]>=l[i+1]?r[i]-l[i+1]+1:0;\n        int pre=r[i-1]>=l[i]?r[i-1]-l[i]+1:0;\n        for(int j=0; j<=nxt; j++){\n            for(int k=0; k<=pre; k++){\n                //if(sum[min(r[i],l[i+1])]-sum[l[i]-1]+k-j<0) continue;\n                f[i][j]=(f[i][j]+f[i-1][k]*c[r[i]-l[i]+1-nxt][sum[r[i]]-sum[l[i]-1]-(sum[l[i]+pre-1]-sum[l[i]-1])+k-j])%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",f[m][0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#define Rep(i,a) for(int i = 0; i < (a); i++)\n#define rep(i,a,b) for(int i = (a); i <= (b); i++)//(a)!\n#define dep(i,a,b) for(int i = (a); i >= (b); i--)\n#define ab(a) ((a) > 0 ? (a) : -(a))\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long uLL;\nconst int N = 3010;\nchar s[N], t[N];\nint f[N][N];\nint main() {\n\tint n, m; scanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s + 1); rep(i,1,n) t[i] = s[i];\n\trep(j,1,m) {\n\t\tint l, r; scanf(\"%d%d\",&l,&r);\n\t\tint c = 0; rep(i,l,r) if (s[i] == '0') c++;\n\t\trep(i,l,l+c-1) s[i] = '0'; rep(i,l + c,r) s[i] = '1';\n\t\tc = 0; rep(i,l,r) if (t[i] == '1') c++;\n\t\trep(i,l,l+c-1) t[i] = '1'; rep(i,l + c,r) t[i] = '0';\n\t}\n\tf[0][0] = 1; int cnt_s = 0, cnt_t = 0;\n\trep(i,1,n) {\n\t\tcnt_s += s[i] - '0', cnt_t += t[i] - '0';\n\t\trep(j,0,i) if (cnt_s <= j && j <= cnt_t) {\n\t\t\tf[i][j] = f[i - 1][j]; if (j) f[i][j] += f[i - 1][j - 1];\n\t\t}\n\t}\n\tcout <<f[n][cnt_s]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=sum[i-1]+(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\tif (l[i]<=r[i-1])\n\t\t{\n\t\t\tfor (int k=max(0,l[i]-l[i+1]+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(l[i+1]-l[i],j-k))%mo;\n\t\t}\n\t\telse f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\nll R[5000];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = i;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = max(R[i], R[i - 1]);\n        //cout << R[i] << endl;\n    }\n    dp[1][summ(1, R[1])] = 1;\n    for (int p = 1; p <= n; p++)\n    {\n        if (p > 1 && R[p] > R[p - 1])\n        {\n            for (int j = n; j >= summ(R[p - 1] + 1, R[p]); j--)\n            {\n                dp[p][j] = dp[p][j - summ(R[p - 1] + 1, R[p])];\n                dp[p][j - summ(R[p - 1] + 1, R[p])] = 0;\n            }\n        }\n        for (int c = 0; c <= n; c++)\n        {\n            if (R[p] - (p + 1) + 1 >= c)\n                dp[p + 1][c] = (dp[p][c] + dp[p][c + 1]) % MOD;\n        }\n    }\n    cout << (dp[n][1] + dp[n][0]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\n \nint get()\n{\n    char c;\n    while (!isdigit(c=getchar()));\n    int k=c-'0';\n    for (; isdigit(c=getchar()); k=k*10+c-'0');\n    return k;\n}\n \nusing namespace std;\nconst int N=1e5+10,mod=1e9+7;\nchar s[N];\nint n,m,ans,fac[N],ifac[N],l[N],r[N],f[2][N],a[N];\n\nint inv(int x)\n{\n    return x>1? 1ll*(mod-mod/x)*inv(mod%x)%mod:1;\n}\n\nint c(int n,int m)\n{\n    return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n \nint main()\n{\n    n=get(),m=get();\n    fac[0]=1;\n    rep(i,1,n)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[n]=inv(fac[n]);\n    repd(i,n,1)\n        ifac[i-1]=1ll*ifac[i]*i%mod;\n    scanf(\"%s\",s+1);\n    rep(i,1,n)\n        a[i]=a[i-1]+s[i]-48;\n    int t=0;\n    rep(i,1,m)\n    {\n        int x=get(),y=get();\n        if (x==l[t])\n            r[t]=max(r[t],y);\n        else if (y>r[t])\n            ++t,l[t]=x,r[t]=y;\n    }\n    m=t,l[m+1]=n+1,f[0][0]=1;\n    rep(i,1,m)\n    {\n        int w=a[r[i]]-a[max(l[i]-1,r[i-1])];\n        int s=min(r[i],l[i+1]-1)-l[i]+1;\n        int mx=r[i]-l[i]+1-s;\n        memset(f[i&1],0,sizeof(f[i&1]));\n        rep(j,0,s)\n            rep(k,max(0,w-j),mx)\n                f[i&1][k]=(f[i&1][k]+1ll*f[(i&1)^1][j+k-w]*c(s,j))%mod;\n    }\n    rep(i,0,n)\n        ans=(ans+f[m&1][i])%mod;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=3005,Mod=1e9+7;\nint dp[N][N];//dp[i][j]表示前i个位置填满了，后面有j个1可以随便填的方案数 \nint r[N],a[N],sum[N];\nchar s[N];\ninline int Max(int a,int b){\n\treturn a>b?a:b;\n}\ninline int Min(int a,int b){\n\treturn a<b?a:b;\n}\ninline void mo(int&x){\n\tx=(x<Mod?x:x-Mod);\n}\nint main (){\n\tint n,m;scanf (\"%d%d\",&n,&m);\n\tscanf (\"%s\",s+1);\n\tfor (int i=1;i<=n;i++) a[i]=s[i]-'0';\n\tfor (int i=1;i<=n+1;i++) r[i]=i,sum[i]=sum[i-1]+a[i];\n\tfor (int i=1,x,y;i<=m;i++){\n\t\tscanf (\"%d%d\",&x,&y);\n\t\tr[x]=Max(r[x],y);\n\t}\n\tfor (int i=1;i<=n;i++) r[i]=Max(r[i],r[i-1]);\n\tdp[1][sum[r[1]]]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=n;j++)\n\t\t\tif (dp[i][j]){\n\t\t\t\tint L=r[i]+1,R=r[i+1];\n\t\t\t\tif (j) mo(dp[i+1][j-1-sum[L-1]+sum[R]]+=dp[i][j]);\n\t\t\t\tif (r[i]-i-j+1) mo(dp[i+1][j-sum[L-1]+sum[R]]+=dp[i][j]);\n\t\t\t}\n\tprintf (\"%d\",dp[n+1][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y)\n{\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y)\n{\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y)\n{\n\treturn ((ll)x * y) % MOD;\n}\n\nconst int N = 3030;\nint n;\nchar s[N];\nint a[N];\nint b[N];\nint dp[N][N];\nint C[N][N];\n\nvoid read()\n{\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\" %s \", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)(s[i] - '0');\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = i + 1;\n\twhile(m--)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tb[l] = max(b[l], r);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = max(b[i], b[i - 1]);\n}\n\nint main()\n{\n\tread();\n\n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n\t\n\tdp[0][0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint willAdd = 0;\n\t\twhile(cur < b[i])\n\t\t{\n\t\t\twillAdd += a[cur];\n\t\t\tcur++;\n\t\t}\n\t\tfor (int x = 0; x <= n; x++)\n\t\t{\n\t\t\tif (dp[i][x] == 0) continue;\n\t\t\tint y = x + willAdd;\n\t\t\tif (y != 0)\n\t\t\t\tdp[i + 1][y - 1] = add(dp[i + 1][y - 1], dp[i][x]);\n\t\t\tif (y != cur - i)\n\t\t\t\tdp[i + 1][y] = add(dp[i + 1][y], dp[i][x]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][0]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#include<complex>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long to; long long len;\n\tbool operator<(const edge& rhs) const {\n\t\treturn len > rhs.len;\n\t}\n};\n\nll const MAX = 3e3 + 5;\nll dp[MAX][MAX] = {};\nll const MOD = 1e9 + 7;\nll mod_p(ll x, ll y) {\n\treturn (x + y - MOD) % MOD;\n}\n\nll mod_m(ll x, ll y) {\n\treturn x * y%MOD;\n}\n\nll l[MAX], r[MAX];\nll sum0[MAX] = {}, sum1[MAX] = {};\n\nint main() {\n\tll n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tREP(i, 1, m) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\tll cur_0 = 0, cur_1 = 0;\n\tll header = 0;\n\tll cur_i = 1;\n\tdp[0][0] = 1;\n\tREP(i, 1, n) {\n\t\tsum0[i] = sum0[i - 1] + (s[i - 1] == '0');\n\t\tsum1[i] = sum1[i - 1] + (s[i - 1] == '1');\n\t}\n\tl[m + 1] = n + 1; r[m + 1] = n + 1;\n\tREP(i, 1, m + 1) {\n\t\twhile (cur_i < l[i]) {\n\t\t\theader = max(header, cur_i);\n\t\t\tll t1 = max(ll(0), cur_i - sum0[header]);\n\t\t\tll t2 = min(cur_i, sum1[header]);\n\t\t\tREP(j, t1,t2) {\n\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j]);\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tdp[cur_i][j] = mod_p(dp[cur_i][j], dp[cur_i - 1][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur_i++;\n\t\t}\t\n\t\theader = max(header, r[i]);\n\n\t}\n\tcout << dp[n][sum1[n]] << endl;\n\t/*\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\nstruct range { ll l, r; };\n\nint main() {\n  int N, M; cin >> N >> M;\n  string S; cin >> S;\n  int num0[N], num1[N]; rep(i,N) { num0[i] = S[i]=='1'; num1[i] = S[i]=='1'; }\n  range r[M]; rep(i,M) { cin >> r[i].l >> r[i].r; r[i].l--; r[i].r--; }\n  // rep(i,M) cout << r[i].l << \" \" << r[i].r << endl;\n\n  rep(i,M) {\n    sort(num0+r[i].l,num0+(r[i].r+1));\n    sort(num1+r[i].l,num1+(r[i].r+1), greater<int>());\n  }\n  // debug(num0,num0+N); debug(num1,num1+N);\n  \n  int l1[N+1] = {}, r1[N+1] = {};\n  rep(i,N) { l1[i+1] = l1[i]+num0[i]; r1[i+1] = r1[i]+num1[i]; }\n  // debug(l1,l1+(N+1)); debug(r1,r1+(N+1));\n\n  ll dp[N+1][N+1] = {}; dp[0][0] = 1;\n  repr(i,1,N+1) {\n    repr(j,l1[i],r1[i]+1) {\n      if (j==0) dp[i][j] = dp[i-1][j];\n      else dp[i][j] = (dp[i-1][j-1]+dp[i-1][j]) % MOD;\n    }\n  }\n  // rep(i,N+1) debug(dp[i],dp[i]+(N+1));\n\n  ll count = 0; rep(i,N) count += num1[i];\n  ll result = dp[N][count];\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define f1(a,b,c) for(int c=a;c<=b;c++)\n#define f2(a,b,c) for(int c=a;c>=b;c--)\n#define f3(a,b,c) for(int c=a;c;c=b)\n#define so1(a,n) sort(a+1,a+n+1,mycmp);\n#define so2(a,n) sort(a+1,a+n+1);\n#define ll long long\n#define itn int\n#define ubt int \n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\nconst int twx=3e3+100;\nconst int MOD=1000000007;\nconst int inf=0x3f3f3f3f;\nll read()\n{\n    ll sum=0;\n    ll flag=1;\n    char c=getchar();\n    while(c<'0'||c>'9')\n    {\n        if(c=='-')\n        {\n            flag=-1;\n        }\n        c=getchar();\n    }\n    while(c>='0'&&c<='9')\n    {\n        sum=((sum*10)+c-'0');\n        c=getchar();\n    }\n    return sum*flag;\n}\nint n,m;\nchar s[twx];\nint l[twx],r[twx];\nint ans=0;\nint one[twx];\nint asd[twx][twx];\nint To[twx];\nll add(ll x,ll y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\nll sub(ll x,ll y)\n{\n    return x-y<0?x-y+MOD:x-y;\n}\nll mul(ll x,ll y)\n{\n    return 1LL*x*y%MOD;\n}\nvoid init()\n{\n\tn=read();\n    m=read();\n    scanf(\"%s\",s+1);\n    f1(1,n,i)\n    {\n        if(s[i]=='1')\n        {\n            one[i]=one[i-1]+1;\n        }\n        else\n        {\n            one[i]=one[i-1];\n        }\n        To[i]=i;\n    }\n    one[n+1]=one[n];\n    f1(1,m,i)\n    {\n        l[i]=read();\n        r[i]=read();\n        To[l[i]]=max(To[l[i]],r[i]);\n    }\n    f1(2,n+1,i)\n    {\n        To[i]=max(To[i],To[i-1]);\n    }\n}\nvoid work()\n{\n    asd[1][one[To[1]]]=1;\n    f1(1,n,i)\n    {\n        f1(0,n,j)\n        {\n            if(asd[i][j])\n            {\n                int Left=To[i]+1;\n                int Right=To[i+1];\n                int tmp=one[Right]-one[Left-1];\n                int a=j;\n                int b=To[i]-i+1-a;\n                if(a)\n                {\n                    asd[i+1][j+tmp-1]=add(asd[i+1][j+tmp-1],asd[i][j]);\n                }\n                if(b)\n                {\n                    asd[i+1][j+tmp]=add(asd[i+1][j+tmp],asd[i][j]);\n                }\n            }\n        }\n    }\n}\nvoid print()\n{\n\tprintf(\"%d\\n\",asd[n+1][0]);\n}\nint main()\n{\n    init();\n    work();\n    print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=3e3+10,mod=1e9+7;\nchar s[maxn];\nint sum[maxn],dp[maxn][maxn],L[maxn],R[maxn],C[maxn][maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tREP(i,1,n) sum[i]=sum[i-1]+(s[i]=='1');\n\tREP(i,0,n){\n\t\tC[i][0]=C[i][i]=1;\n\t\tREP(j,1,i-1) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\tint tmp=0,lst=0;\n\tREP(i,1,m){\n\t\tint x=read(),y=read();\n\t\tif(y<=lst) continue;\n\t\tL[++tmp]=x,R[tmp]=y;\n\t\tlst=y;\n\t}\n\tdp[0][0]=1;\n\tL[tmp+1]=n+1;\n\tREP(i,1,tmp){\n\t\tif(L[i+1]>R[i]){\n\t\t\tREP(j,0,max(R[i-1]-L[i]+1,0)) if(dp[i-1][j]){\n\t\t\t\tint u=j+sum[R[i]]-sum[max(R[i-1],L[i]-1)];\n\t\t\t\tdp[i][0]=(dp[i][0]+(ll)C[R[i]-L[i]+1][u]*dp[i-1][j])%mod;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tREP(j,0,max(R[i-1]-L[i]+1,0)) if(dp[i-1][j]){\n\t\t\tint u=j+sum[R[i]]-sum[max(R[i-1],L[i]-1)];\n\t\t\tREP(k,max(u-R[i]+L[i+1]-1,0),min(u,L[i+1]-L[i]))\n\t\t\t\tdp[i][u-k]=(dp[i][u-k]+(ll)dp[i-1][j]*C[L[i+1]-L[i]][k])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[tmp][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<unordered_map>\n#include<queue>\n#define ll long long\n#define plus 0\n#define minus 1\nusing namespace std;\nconst int N=1e5+10;\nstruct Dot{\n\tint x,y,id;\n\tDot(){}\n\tDot(int x1,int y1,int id1){x=x1; y=y1; id=id1;}\n\tfriend bool operator < (Dot a,Dot b){\n\t\tif (a.x!=b.x) return a.x<b.x;\n\t\tif (a.y!=b.y) return a.y<b.y;\n\t\treturn a.id<b.id;\n\t}\n}a[N];\nint vis[N],LL;\nunordered_map<int,vector<int> >rec2[2];\nunordered_map<int,set<Dot> >rec1[2];\nset<Dot>::iterator it,it2;\nqueue<Dot> q;\nll ans;\nint n,A,B,D;\nint Abs(int x){return x<0?-x:x;}\nvoid prework(){\n\twhile (!q.empty()) q.pop();\n\tmemset(vis,false,sizeof(vis));\n\tfor (int i=1;i<=n;++i){\n\t\tif (i==A)\n\t\t\tq.push(a[i]),vis[i]=true;\n\t\telse{\n\t\t\trec1[plus][a[i].x+a[i].y].insert(a[i]);\n\t\t\trec1[minus][a[i].x-a[i].y].insert(a[i]);\n\t\t}\n\t}\n}\nvoid get_point(set<Dot> &tmp,int which,ll val,int lx,int rx){\n\tDot ttmp;\n\tif (rec1[which].find(val)==rec1[which].end()) return;\n\tit=lower_bound(tmp.begin(),tmp.end(),Dot(lx,0,0));\n\tttmp=*it;\n\tfor (;ttmp.x<=rx&&it!=tmp.end();it=it2,ttmp=*it2){\n\t\tit2=it; ++it2;\n\t\tq.push(ttmp),vis[ttmp.id]=true;\n\t\tLL++;\n\t\trec1[plus][ttmp.x+ttmp.y].erase(ttmp);\n\t\trec1[minus][ttmp.x-ttmp.y].erase(ttmp);\n\t}\n}\nvoid bfs(){\n\tDot u,v;\n\twhile (!q.empty()){\n\t\tv=q.front(); q.pop();\n\t\tif (1LL*v.x+v.y+D<=2e9)\n\t\t\tget_point(rec1[plus][1LL*v.x+v.y+D],plus,1LL*v.x+v.y+D,v.x,v.x+D);\n\t\tget_point(rec1[plus][1LL*v.x+v.y-D],plus,1LL*v.x+v.y-D,v.x-D,v.x);\n\n\t\tget_point(rec1[minus][1LL*v.x-v.y+D],minus,1LL*v.x-v.y+D,v.x,v.x+D);\n\t\tget_point(rec1[minus][1LL*v.x-v.y-D],minus,1LL*v.x-v.y-D,v.x-D,v.x);\n\n\t\t//printf(\"%d\\n\",(int)q.size());\n\t}\n\t//printf(\"%d\\n\",debug);\n}\nint calc(int which,int val,int lx,int rx){\n\tif (rec2[which].find(val)==rec2[which].end()) return 0;\n\tstatic vector<int> tmp;\n\ttmp=rec2[which][val];\n\treturn lower_bound(tmp.begin(),tmp.end(),rx+1)-lower_bound(tmp.begin(),tmp.end(),lx);\n}\n\nvoid solve(){\n\tsort(a+1,a+1+n);\n\tans=0;\n\tDot v;\n\tfor (int i=1;i<=n;++i){\n\t\tv=a[i];\n\t\t//printf(\"%d %d %d\\n\",v.x,v.y,v.id);\n\t\tif (!vis[v.id]) continue;\n\t\tif (1LL*v.x+v.y+D<=2e9)\n\t\t\tans+=calc(plus,v.x+v.y+D,v.x,v.x+D);\n\t\tans+=calc(plus,v.x+v.y-D,v.x-D,v.x);\n\n\t\tans+=calc(minus,v.x-v.y+D,v.x+1,v.x+D-1);\n\t\tans+=calc(minus,v.x-v.y-D,v.x-D+1,v.x-1);\n\n\t\trec2[plus][v.x+v.y].push_back(v.x);\n\t\trec2[minus][v.x-v.y].push_back(v.x);\n\t\t//printf(\"%lld\\n\",ans);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d%d\",&n,&A,&B);\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y),a[i].id=i;\n\tD=Abs(a[A].x-a[B].x)+Abs(a[A].y-a[B].y);\n\tprework();\n\tbfs();\n\tsolve();\n\tprintf(\"%d\",LL);\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\nnamespace mystd {\n\tint stoi(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tint res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\tlong long stoll(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tlong long res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\ttemplate<class T>\n\tstd::string to_string(T d) {\n\t\tstd::stringstream ss;\n\t\tss << d;\n\t\tstd::string res;\n\t\tss >> res;\n\t\treturn res;\n\t}\n}\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\n\nint dp[6003][3003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVAR(std::string, s);\n\tVEC_ROW(int, m, l, r);\n\n\tstd::stack<PAIR> st;\n\tREP(i, m) {\n\t\t--l[i];\n\t\tif (!st.empty()){\n\t\t\tif (r[i] <= st.top().second) continue;\n\t\t\tif (st.top().first == l[i] && st.top().second <= r[i]) {\n\t\t\t\tst.pop();\n\t\t\t\t--i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tst.push(PAIR(l[i], r[i]));\n\t}\n\n\tstd::vector<std::vector<PAIR>> lr;\n\tint pre = -1;\n\t{\n\t\tstd::vector<PAIR> pv;\n\t\twhile (!st.empty()) {\n\t\t\tPAIR p = st.top(); st.pop();\n\t\t\tpv.emplace_back(p);\n\t\t}\n\t\tstd::reverse(ALL(pv));\n\n\t\tfor (const auto& p : pv) {\n\t\t\tif (pre < p.first) {\n\t\t\t\tlr.emplace_back();\n\t\t\t}\n\t\t\tlr.back().emplace_back(p);\n\t\t\tpre = p.second;\n\t\t}\n\t}\n\n\tint ans = 1;\n\tint pos = 0;\n\tfor (auto& v : lr) {\n\t\tdp[pos][0] = 1;\n\n\t\tint L = v.front().first, R = v.front().first;\n\t\tint t = v.back().second;\n\t\tint sz = 0;\n\t\tint preR = INFINT;\n\t\tv.emplace_back(t, t);\n\t\tfor (const auto& p : v) {\n\t\t\tint add = 0, del = 0;\n\t\t\twhile (R < p.second) {\n\t\t\t\tadd += s[R] == '1';\n\t\t\t\t++R;\n\t\t\t}\n\t\t\twhile (L < p.first) {\n\t\t\t\t++del;\n\t\t\t\t++L;\n\t\t\t}\n\n\t\t\tREP(i, del + 1) FOR(j, i, sz + 1) {\n\t\t\t\tif (dp[pos][j] == 0) continue;\n\t\t\t\tif (j - i > preR - p.first) continue;\n\t\t\t\t(dp[pos + 1][j - i + add] += Combination(del, i) * dp[pos][j]) %= MOD;\n\t\t\t}\n\t\t\tsz = p.second - p.first;\n\t\t\tpreR = p.second;\n\t\t\t++pos;\n\t\t}\n\t\t(ans *= dp[pos][0]) %= MOD;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}\n/*\n|-------|\n   |--------|\n---      ----\ndel       add\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sz(x) ((int) (x).size())\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef long long i64;\ntypedef long double ld;\nconst int inf = int(1e9) + int(1e5);\nconst ll infl = ll(2e18) + ll(1e10);\n\nconst int maxn = 3005;\nint d[maxn][maxn];\nint pr[maxn];\nint l[maxn], r[maxn], to[maxn];\n\nconst int mod = 1e9 + 7;\n\nvoid udd(int &a, int b) {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nint mul(ll a, ll b) {\n    return a * b % mod;\n}\n\nint main() {\n    #ifdef LOCAL\n    assert(freopen(\"f.in\", \"r\", stdin));\n    #else\n    #endif\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    forn (i, n)\n        pr[i + 1] = pr[i] + (s[i] == '1');\n    forn (i, m) {\n        cin >> l[i] >> r[i];\n        --l[i];\n    }\n    int last = 0, ptr = 0;\n    forn (i, n) {\n        last = max(last, i + 1);\n        while (ptr < m && l[ptr] == i) {\n            last = max(last, r[ptr]);\n            ++ptr;\n        }\n        to[i] = last;\n    }\n    d[0][0] = 1;\n    forn (i, n) {\n        int b = to[i];\n        forn (j, i + 1) {\n            if (d[i][j] == 0)\n                continue;\n\n            if (j < pr[b]) {\n                udd(d[i + 1][j + 1], d[i][j]);\n                //cerr << \"go 1\\n\";\n            }\n            if ((i - j) < (b - pr[b])) {\n                udd(d[i + 1][j], d[i][j]);\n                //cerr << \"go 0\\n\";\n            }\n        }\n    }\n    cout << d[n][pr[n]] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int maxm=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxm+8][maxm+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n\n//#include \"IntMod.h\"\ntypedef IntMod<1000000007> MInt;\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nMInt DP[3001][3001];\nMInt SUM[3001][3001];\n\nMInt C(int n, int r) {\n\t//if (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn MInt(n).Fact() / (MInt(r).Fact() * MInt(n - r).Fact());\n}\n\nint main() {\n\t/* さすがに無理か？ */\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t}\n\t}\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\nnamespace mystd {\n\tint stoi(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tint res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\tlong long stoll(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tlong long res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\ttemplate<class T>\n\tstd::string to_string(T d) {\n\t\tstd::stringstream ss;\n\t\tss << d;\n\t\tstd::string res;\n\t\tss >> res;\n\t\treturn res;\n\t}\n}\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 1000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\n\nint dp[6003][3003];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVAR(std::string, s);\n\tVEC_ROW(int, m, l, r);\n\n\tstd::stack<PAIR> st;\n\tREP(i, m) {\n\t\t--l[i];\n\t\tif (!st.empty()){\n\t\t\tif (r[i] <= st.top().second) continue;\n\t\t\tif (st.top().first == l[i] && st.top().second <= r[i]) {\n\t\t\t\tst.pop();\n\t\t\t\t--i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tst.push(PAIR(l[i], r[i]));\n\t}\n\n\tstd::vector<std::vector<PAIR>> lr;\n\tint pre = -1;\n\t{\n\t\tstd::vector<PAIR> pv;\n\t\twhile (!st.empty()) {\n\t\t\tPAIR p = st.top(); st.pop();\n\t\t\tpv.emplace_back(p);\n\t\t}\n\t\tstd::reverse(ALL(pv));\n\n\t\tfor (const auto& p : pv) {\n\t\t\tif (pre < p.first) {\n\t\t\t\tlr.emplace_back();\n\t\t\t}\n\t\t\tlr.back().emplace_back(p);\n\t\t\tpre = p.second;\n\t\t}\n\t}\n\n\tint ans = 1;\n\tint pos = 0;\n\tfor (auto& v : lr) {\n\t\tdp[pos][0] = 1;\n\n\t\tint L = v.front().first, R = v.front().first;\n\t\tint t = v.back().second;\n\t\tint sz = 0;\n\t\tint preR = INFINT;\n\t\tv.emplace_back(t, t);\n\t\tfor (const auto& p : v) {\n\t\t\tint add = 0, del = 0;\n\t\t\twhile (R < p.second) {\n\t\t\t\tadd += s[R] == '1';\n\t\t\t\t++R;\n\t\t\t}\n\t\t\twhile (L < p.first) {\n\t\t\t\t++del;\n\t\t\t\t++L;\n\t\t\t}\n\n\t\t\tREP(i, del + 1) FOR(j, i, sz + 1) {\n\t\t\t\tif (dp[pos][j] == 0) continue;\n\t\t\t\tif (j - i > preR - p.first) continue;\n\t\t\t\t(dp[pos + 1][j - i + add] += Combination(del, i) * dp[pos][j]) %= MOD;\n\t\t\t}\n\t\t\tsz = p.second - p.first;\n\t\t\tpreR = p.second;\n\t\t\t++pos;\n\t\t}\n\t\t(ans *= dp[pos][0]) %= MOD;\n\t\t++pos;\n\t}\n\tOUT(ans)BR;\n\treturn 0;\n}\n/*\n|-------|\n   |--------|\n---      ----\ndel       add\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n\n#define mod 1000000007\nusing namespace std;\n\nlong long dp[3010][3010],a[3010],l[3010],r[3010],mx;\nint main(){\n\tstring s;\n\tpair<int,int> p[3010],q[3010];\n\tint i,j,n,m,x,y;\n\tcin >> n >> m >> s;\n\tj = 0;\n\tcin >> l[0] >> r[0];\n\tmx = r[0];\n\tfor(i=1;i<m;i++){\n\t\tcin >> l[i] >> r[i];\n\t\tif(l[i]==l[i-1]){\n\t\t\tmx = max(mx,r[i]);\n\t\t}else{\n\t\t\tq[j] = make_pair(l[i-1],mx);\n\t\t\tmx = r[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tq[j] = make_pair(l[m-1],mx);\n\tint k = 0;\n\tp[0] = q[0];\n\tfor(i=1;i<=j;i++){\n\t\tif(q[i].second>p[k].second){\n\t\t\tk++;\n\t\t\tp[k] = q[i];\n\t\t}\n\t}\n\tp[k+1] = make_pair(3010,3010);\n\t\n\tk = 0;\n\ta[0] = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tk++;\n\t\t}\n\t\ta[i+1] = k;\n\t}\n\t\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++){\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n\t\n\tk = 0;\n\tdp[0][0] = 1;\n\tfor(i=1;i<=n;i++){\n\t\tif(p[k].first==i){\n\t\t\tk++;\n\t\t}\n\t\tfor(j=0;j<i;j++){\n\t\t\tif(k==0 || (i<p[k].first && i>p[k-1].second)){\n\t\t\t\tif(s[i-1]=='1'){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\tdp[i][j+1] %= mod;\n\t\t\t\tif(a[p[k-1].second]<j+1 || a[p[k-1].second]-(p[k-1].second-i)>j+1){\n\t\t\t\t\tdp[i][j+1] = 0;\n\t\t\t\t}\n\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t\tif(a[p[k-1].second]<j || a[p[k-1].second]-(p[k-1].second-i)>j){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[n][a[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nconst int p = 1000000007;\nint sum[N],a[N],n,m;\nchar s[N];\nint r[N],f[N][N];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++)a[i]=s[i]-'0',sum[i]=sum[i-1]+a[i];\n    int t1,t2;\n    for(int i=1;i<=n;i++)r[i]=i;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&t1,&t2);\n        r[t1]=max(r[t1],t2);\n    }\n    f[0][0]=1;int now=0;\n    for(int i=1;i<=n;i++)\n    {\n        now=max(now,r[i]);\n        for(int j=0;j<=n;j++)\n        {\n            if(f[i-1][j])\n            {\n                if(sum[now]!=j+now-i+1)(f[i][j]+=f[i-1][j])%=p;\n                if(sum[now]!=j)(f[i][j+1]+=f[i-1][j])%=p;\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<=n;i++)ans+=f[n][i],ans%=p;\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#define prim 1000000007\n#define LL long long\nusing namespace std;\n\nLL N,M,a[3010],C[3010][3010],inv[3010],l[3010],r[3010],K,dp[3010],s[3010],ndp[3010];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N >> M;\n\n    int i,j; char c;\n    s[0]=0;\n    for (i=1; i<=N; i++){\n        cin >> c;\n        a[i]=c-'0';\n        s[i]=s[i-1];\n        if (a[i]==0) s[i]++;\n    }\n\n    C[0][0]=1;\n    for (i=1; i<=N; i++){\n        C[i][0]=1;\n        for (j=1; j<=i; j++)\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%prim;\n    }\n\n    inv[1]=1;\n    for (i=2; i<=N; i++){\n        inv[i]=(-inv[prim%i]*(prim/i))%prim;\n        inv[i]+=prim;\n    }\n\n    for (i=1; i<=M; i++){\n        K++;\n        cin >> l[K] >> r[K];\n        if (r[K]<=r[K-1]) K--;\n        else if (l[K]==l[K-1]){\n            l[K-1]=l[K],r[K-1]=r[K],K--;\n        }\n    }\n\n    LL res=1,aux,cnt=0,len,k;\n\n\n    for (i=1; i<=K; i++){\n        if (r[i]<l[i+1] || i==K){\n            aux=0;\n            if (cnt==0)\n                res=(res*C[r[i]-l[i]+1][s[r[i]]-s[l[i]-1]])%prim;\n            else{\n                for (j=0; j<=r[i-1]-l[i]+1; j++)\n                    aux=(aux+dp[j]*C[r[i]-l[i]+1][s[r[i]]-s[r[i-1]]+j])%prim;\n                res=(res*aux)%prim;\n            }\n            cnt=0;\n        }\n        else{\n            if (cnt==0){\n                memset(dp,0,sizeof(dp));\n                for (j=0; j<=r[i]-l[i+1]+1 && j<=s[r[i]]-s[l[i]-1]; j++)\n                    dp[j]=C[l[i+1]-l[i]][s[r[i]]-s[l[i]-1]-j];\n            }\n            else{\n                memset(ndp,0,sizeof(ndp));\n                len=r[i]-l[i+1]+1;\n                for (j=0; j<=len; j++)\n                    for (k=0; k<=r[i-1]-l[i]+1; k++){\n                        if (k+s[r[i]]-s[r[i-1]]<j) continue;\n                        ndp[j]=(ndp[j]+dp[k]*C[r[i]-l[i]+1-len][k+s[r[i]]-s[r[i-1]]-j])%prim;\n                    }\n\n                memset(dp,0,sizeof(dp));\n                for (j=0; j<=len; j++)\n                    dp[j]=ndp[j];\n\n            }\n            cnt++;\n        }\n    }\n\n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define VIZ {printf(\"digraph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) printf(\"%d->%d;\\n\",i,vb[e]); puts(\"}\");}\n#define VIZ2 {printf(\"graph G{\\n\"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf(\"%d--%d;\\n\",i,vb[e]); puts(\"}\");}\n#define SZ 666666\nint n,m,l[SZ],r[SZ],qzh[SZ];\nchar s[SZ];\nll dp[3003][3003],MOD=1e9+7;\nll tmp[3003];\nint sum(int l,int r)\n{\n\tif(l<=r)\n\treturn qzh[r]-qzh[l-1];\n\treturn 0;\n}\nll fac[SZ],rfac[SZ];\nll qp(ll a,ll b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&1) ans=ans*a%MOD;\n        a=a*a%MOD; b>>=1;\n    }\n    return ans;\n}\nll C(int a,int b)\n{\n\tif(b>a) return 0;\n\treturn fac[a]*rfac[b]%MOD*rfac[a-b]%MOD;\n}\nint main()\n{\n\tfac[0]=rfac[0]=1;\n\tfor(int i=1;i<=200000;i++)\n\tfac[i]=fac[i-1]*i%MOD, rfac[i]=rfac[i-1]*qp(i,MOD-2)%MOD;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;i++) qzh[i]=qzh[i-1]+s[i]-48;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",l+i,r+i);\n\t\tif(r[i]<r[i-1]) {--i; --m; continue;}\n\t}\n\tl[m+1]=n+1; r[m+1]=n+1;\n\tdp[0][0]=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++) tmp[j]=0;\n\t\tint s=sum(max(r[i-1]+1,l[i]),r[i]);\n\t\tfor(int j=0;j<=n;j++) tmp[j+s]+=dp[i-1][j];\n\t\tint ol=max(r[i]-l[i+1]+1,0),p=r[i]-l[i]+1-ol;\n\t\tfor(int j=0;j<=ol;j++)\n\t\tfor(int k=j;k<=n&&k-j<=p;k++)\n\t\t\tdp[i][j]=(dp[i][j]+C(p,k-j)*tmp[k]%MOD)%MOD;\n\t}\n\tll ans=dp[m][0];\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(\"%d\\n\",int(ans));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int mo=1000000007;\nint f[3005],a[3005];\nchar s[3005];\nvoid dp(int i,int &R){\n\tR=i>R?i:R;\n\tfor (int j=i;j>=0;j--)\n\t\tif (j<a[R]-R+i || j>a[R]) f[j]=0;\n\t\t\telse if (j) (f[j]+=f[j-1])%=mo;\n}\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\\n%s\",&n,&m,s+1);\n\tfor (int i=1;i<=n;i++) a[i]=a[i-1]+s[i]-'0';\n\tint L=1,R=0;f[0]=1;\n\tfor (int i=1;i<=m;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\\n\",&l,&r);\n\t\tfor (int j=L;j<l;j++) dp(j,R);\n\t\tL=l;R=r>R?r:R;\n\t}\n\tfor (int i=L;i<=n;i++) dp(i,R);\n\tprintf(\"%d\\n\",f[a[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=3005;\nconst int INF=0x3f3f3f3f;\nconst int MOD=1e9+7;\n\nstruct Question{\n\tint l,r;\n}q[maxn],p[maxn];\n\nLL C[maxn][maxn],dp[maxn][maxn];\nint sum[maxn];\nchar s[maxn];\nint n,m;\n\nvoid pre_C(){\n\tfor(int i=0;i<=n;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tpre_C();\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+s[i]-'0';\n\tint cnt=0;\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d\",&p[i].l,&p[i].r);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tq[m+1].l=n+1;q[m+1].r=n+1;\n\tsum[n+1]=sum[n];\n\tdp[1][sum[q[1].r]-sum[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint len=q[i].r-q[i].l+1;\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]+=dp[i][j]*C[len][j]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i+1].l-1]]%=MOD;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint LEN=q[i].r-q[i].l+1;//qujianchang\n\t\t\tint len=q[i].r-q[i+1].l+1;//jiaojichang\n\t\t\tint pre=q[i+1].l-q[i].l;//qianzhui\n\t\t\tfor(int j=0;j<=LEN;j++)\n\t\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;k++){\n\t\t\t\t\tdp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]+=dp[i][j]*C[pre][j-k]%MOD,dp[i+1][sum[q[i+1].r]-sum[q[i].r]+k]%=MOD;\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 3054, mod = 1000000007;\n\nint n, q;\nint ri[N], f[N][N];\nint S[N];\nchar s[N];\n\ninline int & up(int &x, const int y) {return x < y ? x = y : x;}\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\n\nint main() {\n\tint i, j, k, l, r, cur, append;\n\tscanf(\"%d%d%s\", &n, &q, s + 1);\n\tfor (; q; --q) scanf(\"%d%d\", &l, &r), up(ri[l], r);\n\tfor (i = 1; i <= n; ++i) up(up(ri[i], ri[i - 1]), i), S[i] = S[i - 1] + (s[i] & 1);\n\tf[0][ S[ri[1]] ] = 1, ri[n + 1] = n;\n\tfor (i = 0; i < n; ++i)\n\t\tfor (j = 0, k = ri[i + 1] - i; k >= 0; ++j, --k) if (cur = f[i][j]) {\n\t\t\tappend = S[ri[i + 2]] - S[ri[i + 1]];\n\t\t\tif (j) add(f[i + 1][j - 1 + append], cur);\n\t\t\tif (k) add(f[i + 1][j + append], cur);\n\t\t}\n\tprintf(\"%d\\n\", *f[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define ph push\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n// #define cerr if(0)cout\n#define MAXN (3006)\nll n, m, mod=1e9+7, memo[MAXN][MAXN], sum[MAXN], f[MAXN], inv[MAXN];\nstring S;\nvector<pi> ranges;\nint main()\n{\n\tFAST\n\tcin>>m>>n>>S; S='*'+S; FOR(i,1,m) sum[i]=sum[i-1]+S[i]-'0';\n\tFOR(i,0,n-1) {\n\t\tll a, b; cin>>a>>b; ranges.eb(a, b);\n\t}\n\tsort(all(ranges), [](pi x,pi y){return (x.f!=y.f?x.f<y.f:x.s>y.s); });\n\tvector<pi>final;\n\tll mx=0;\n\tFOR(i,0,n-1) {\n\t\tif(mx >= ranges[i].s) {\n\t\t\tcontinue;\n\t\t}\n\t\tmx=ranges[i].s;\n\t\tfinal.eb(ranges[i]);\n\t}\n\tswap(ranges,final), n=siz(ranges);\n\tmmst(memo,-1);\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tfunction<ll(ll,ll)>qexp=[&](ll x,ll e){\n\t\tif(e==0)return 1ll;\n\t\tll half=qexp(x,e>>1); half*=half, half%=mod;\n\t\tif(e&1) half*=x,half%=mod;\n\t\treturn half;\n\t};\n\tFOR(i,0,MAXN-1) inv[i]=qexp(f[i],mod-2);\n\tauto C=[&](ll n,ll k) {\n\t\tif(n<k) return 0ll;\n\t\treturn f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tauto ones=[&](ll x,ll y) {\n\t\treturn sum[y]-sum[x-1];\n\t};\n\tauto zeros=[&](ll x,ll y) {\n\t\treturn (y-x+1) - ones(x,y);\n\t};\n\tfunction<ll(ll,ll)>dp=[&](ll x,ll y) {\n\t\tif(~memo[x][y]) return memo[x][y];\n\t\tll &ans=memo[x][y]=0;\n\t\tll one=ones(ranges[x].f,ranges[x].s), zero=zeros(ranges[x].f,ranges[x].s);\n\t\tif(x && ranges[x-1].s >= ranges[x].f) {\n\t\t\tll inter = ranges[x-1].s - ranges[x].f + 1;\n\t\t\tone -= ones(ranges[x].f, ranges[x].f+inter-1);\n\t\t\tzero -= zeros(ranges[x].f, ranges[x].f+inter-1);\n\t\t\tone += y;\n\t\t\tzero += inter-y;\n\t\t}\n\t\tif(x == n-1 || ranges[x+1].f > ranges[x].s) { // independent case\n\t\t\tans = C(ranges[x].s-ranges[x].f+1, one);\n\t\t} else {\n\t\t\tll inter = ranges[x].s - ranges[x+1].f + 1;\n\t\t\tFOR(i,0,min(one,inter)) {\n\t\t\t\tif(inter-i > zero) continue;\n\t\t\t\tone -= i;\n\t\t\t\tans += C(ranges[x].s-ranges[x].f+1-inter,one) * dp(x+1, i) % mod, ans%=mod; \n\t\t\t\tone += i;\n\t\t\t}\n\t\t}\n\t\t// cerr<<x<<\" \"<<y<<\" \"<<ans<<' '<<one<<' '<<zero<<'\\n';\n\t\treturn ans;\n\t};\n\tll ans=1;\n\tFOR(i,0,n-1) {\n\t\tif(i == 0 || ranges[i-1].s < ranges[i].f) {\n\t\t\tans*=dp(i, 0),ans%=mod;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//void __(){\n//    _(int,n);\n//    _(int,m);\n//    _(string,s);\n//    string s_lo = s, s_hi = s;\n//    rep(i,m){\n//        _(int,l);\n//        _(int,r);\n//        --l;\n//        sort(s_lo.begin()+l,s_lo.begin()+r);\n//        sort(s_hi.begin()+l,s_hi.begin()+r);\n//        reverse(s_hi.begin()+l,s_hi.begin()+r);\n//    }\n//    vi lo(n), hi(n);\n//    {\n//        int cnt = 0;\n//        rep(i,n)\n//            if(s_lo[i] == '1'){\n//                hi[cnt] = i;\n//                ++cnt;\n//            }\n//    }\n//    {\n//        int cnt = 0;\n//        rep(i,n)\n//            if(s_hi[i] == '1'){\n//                lo[cnt] = i;\n//                ++cnt;\n//            }\n//    }\n//    vvi dp(n+1,vi(n+1));\n//    dp[0][0] = 1;\n//    rep(i,n)\n//        rep(ones,i+1){\n//            if(!dp[i][ones]) continue;\n//            if(lo[ones] <= i && i <= hi[ones]){\n//                dp[i+1][ones+1] += dp[i][ones];\n//                if(dp[i+1][ones+1] >= MOD)\n//                    dp[i+1][ones+1] -= MOD;\n//            }\n//            dp[i+1][ones] += dp[i][ones];\n//            if(dp[i+1][ones] >= MOD)\n//                dp[i+1][ones] -= MOD;\n//        }\n//    int ones = count(all(s),'1');\n//    print dp[n][ones];\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define REP_ZERO_INT(i,r) for(int i = 0; i < r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT,REP_ZERO_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout)\n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\n#define INPUT_WITHOUT_INIT(type,name) type name; cin >> name\n#define GET_INPUT_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define _(...) GET_INPUT_MACRO(__VA_ARGS__,_IWI,_IWI,_IWI,_IWI,_IWI,_IWI,INPUT_WITHOUT_INIT)(__VA_ARGS__)\nvoid __(){\n    _(int,n);\n    _(int,m);\n    _(string,s);\n    string s_lo = s, s_hi = s;\n    rep(i,m){\n        _(int,l);\n        _(int,r);\n        --l;\n        sort(s_lo.begin()+l,s_lo.begin()+r);\n        sort(s_hi.begin()+l,s_hi.begin()+r);\n        reverse(s_hi.begin()+l,s_hi.begin()+r);\n    }\n    vi lo(n), hi(n);\n    {\n        int cnt = 0;\n        rep(i,n)\n            if(s_lo[i] == '1'){\n                hi[cnt] = i;\n                ++cnt;\n            }\n    }\n    {\n        int cnt = 0;\n        rep(i,n)\n            if(s_hi[i] == '1'){\n                lo[cnt] = i;\n                ++cnt;\n            }\n    }\n    vvi dp(n+1,vi(n+1));\n    dp[0][0] = 1;\n    rep(i,n)\n        rep(ones,i+1){\n            if(!dp[i][ones]) continue;\n            if(lo[ones] <= i && i <= hi[ones]){\n                dp[i+1][ones+1] += dp[i][ones];\n                if(dp[i+1][ones+1] >= MOD)\n                    dp[i+1][ones+1] -= MOD;\n            }\n            dp[i+1][ones] += dp[i][ones];\n            if(dp[i+1][ones] >= MOD)\n                dp[i+1][ones] -= MOD;\n        }\n    int ones = count(all(s),'1');\n    print dp[n][ones];\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tptmp.erase(std::unique(ptmp.begin(), ptmp.end()), ptmp.end());\n\tvector<int> lefs;\n\tfor(int i=0;i<ptmp.size();i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second){\n\t\tif( i == ptmp.size()-1 || ptmp[i].first != ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tdp[i][j+s[i-1]-'0'] += dp[i-1][j];\n\t\t\t\tdp[i][j+s[i-1]-'0'] %= inf;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j ){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 3e3 + 3;\nconst int mod = 1e9 + 7;\nint n , m;\nchar str[N];\nint sum[N];\nint arr[N];\nint a , b;\nint dp[N][N];\nint solve(int l , int r , int cnt){\n    if(cnt > r - l + 1){\n        return 0;\n    }\n    if(l > n){\n        return 1;\n    }\n    if(arr[l] > r){\n        cnt += sum[arr[l]] - sum[r];\n        r = arr[l];\n    }\n    if(dp[l][cnt] != -1){\n        return dp[l][cnt];\n    }\n    int res = 0;\n    if(cnt){\n        res += solve(l + 1 , r , cnt - 1);\n    }\n    res += solve(l + 1 , r , cnt);\n    if(res >= mod){\n        res -= mod;\n    }\n    return dp[l][cnt] = res;\n}\nint main(){\n    scanf(\"%d %d\" , &n , &m);\n    scanf(\"%s\" , str + 1);\n    sum[0] = 0;\n    for(int i = 1 ; i <= n ; ++i){\n        sum[i] = sum[i - 1] + str[i] - '0';\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        arr[i] = i;\n    }\n    for(int i = 1 ; i <= n ; ++i){\n        scanf(\"%d %d\" , &a , &b);\n        arr[a] = max(arr[a] , b);\n    }\n    memset(dp , -1 , sizeof(dp));\n    printf(\"%d\\n\" , solve(1 , 0 , 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n};\ntypedef ModInt<1000000007> mint;\n\nint main() {\n\tint N; int M;\n\twhile(~scanf(\"%d%d\", &N, &M)) {\n\t\tchar S[3001];\n\t\tscanf(\"%s\", S);\n\t\tvector<pair<int, int>> lrs(M);\n\t\trep(i, M) {\n\t\t\tint l; int r;\n\t\t\tscanf(\"%d%d\", &l, &r), -- l;\n\t\t\tlrs[i] = { l, -r };\n\t\t}\n\t\tsort(lrs.begin(), lrs.end());\n\t\tvector<int> nextR(N);\n\t\trep(i, N)\n\t\t\tnextR[i] = i + 1;\n\t\t{\n\t\t\tint prevR = 0;\n\t\t\trep(i, M) {\n\t\t\t\tint l = lrs[i].first, r = -lrs[i].second;\n\t\t\t\tif(prevR < r) {\n\t\t\t\t\treu(j, l, r)\n\t\t\t\t\t\tnextR[j] = r;\n\t\t\t\t\tprevR = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> prefix(N + 1);\n\t\trep(i, N)\n\t\t\tprefix[i + 1] = prefix[i] + (S[i] == '1');\n\t\tvector<mint> dp, ndp(N + 1);\n\t\tndp[0] = 1;\n\t\trep(i, N) {\n\t\t\tdp.swap(ndp);\n\t\t\tndp.assign(N + 1, mint());\n\t\t\tint r = nextR[i], jR = prefix[r], jL = i + 1 - (r - prefix[r]);\n\t\t\trer(j, 0, i) {\n\t\t\t\tmint x = dp[j];\n\t\t\t\tif(x.x == 0) continue;\n\t\t\t\trep(b, 2) {\n\t\t\t\t\tint nj = j + (b == 1);\n\t\t\t\t\tif(jL <= nj && nj <= jR)\n\t\t\t\t\t\tndp[nj] += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint ans = ndp[prefix[N]];\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1001001001;\nconst ll LONGINF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v((a %= mod) < 0 ? a + mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<MOD>;\nmint dp[3010][3010];\n\nint main() {\n    int N, M; cin >> N >> M;\n    string s; cin >> s;\n\n    vector<int> acc(N+1);\n    for(int i=0; i<N; i++) {\n        acc[i+1] = acc[i] + (s[i] == '1');\n    }\n\n    vector<int> query(N, -1);\n    for(int i=0; i<M; i++) {\n        int l, r; cin >> l >> r; l--;\n        chmax(query[l], r);\n    }\n\n    int acc_max = 0;\n    dp[0][0] = mint(1);\n    for(int i=0; i<=N; i++) {\n        for(int j=0; j<=i; j++) {\n            if(dp[i][j].v == 0) continue;\n            // fprintf(stderr, \"dp[%d][%d] = %lld\\n\", i, j, dp[i][j].v);\n        }\n        if(i >= N) continue;\n        \n        chmax(acc_max, query[i]);\n        \n        // 今までのクエリの累積 max が i を含んでない\n        // i 番目に関係するクエリは存在しないのでのばすだけ\n        if(acc_max <= i) {\n            for(int j=0; j<=i; j++) {\n                int nj = j + (s[i] == '1');\n                if(acc[i+1] >= nj) dp[i+1][nj] += dp[i][j];\n            }\n        }\n        else {\n            // 使用可能な 1 (cnt1) は acc[acc_max] - j 個\n            // 使用可能な 0 (cnt0) は acc_max - i - cnt1 個\n            for(int j=0; j<=i; j++) {\n                int cnt1 = acc[acc_max] - j;\n                int cnt0 = acc_max - i - cnt1;\n                if(cnt1 < 0 or cnt0 < 0) continue;\n\n                if(cnt1) dp[i+1][j+1] += dp[i][j];\n                if(cnt0) dp[i+1][j  ] += dp[i][j];\n            }\n        }\n    }\n\n    cout << dp[N][ acc[N] ] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define pb push\n#define mp make_pair\n#define X first\n#define Y second\n#define Mad(a,b) a=(a+b)%mod;\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\nqueue<P> Q;\n#define N 3010\nll n,m,d[N],c[N];string s;\nint main(){\n    cin>>n>>m>>s;\n    Q.pb(mp(0,0));\n    while(m--){\n\tll a,b;cin>>a>>b;\n\tif(Q.back().Y<b)Q.pb(mp(a,b));\n    }\n    lol(i,N)d[i]=0;d[0]=1;\n    for(ll i=0,rnd=0;i<=n;i++){\n\tll cnt=0;\n\twhile(!Q.empty()){\n\t    if(not(Q.front().X<=i))break;\n\t    for(ll j=max(i-1,rnd);j<Q.front().Y;j++)cnt+=s[j]-'0';\n\t    rnd=Q.front().Y;Q.pop();\n\t}\n\tfor(ll j=N-1;j>=0;j--)d[j]=(j-cnt>=0?d[j-cnt]:0);\n\tll lim=max(0LL,rnd-i);\n\tfor(ll j=0;j<=lim;j++)Mad(d[j],d[j+1]);\n\tfor(ll j=lim+1;j<N;j++)d[j]=0;\n    }\n    cout<<d[0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n\ntypedef IntMod<1000000007> MInt;\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nPP P[3000];\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) {\n\tif (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn MInt(n).Fact() / (MInt(r).Fact() * MInt(n - r).Fact());\n}\n\nint main() {\n\t/* さすがに無理か？ */\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t}\n\t}\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, 0, N + 1) {\n\t\t\tREP(k, 0, j + 1) {\n\t\t\t\tint p = O[i - 1] - j;\n\t\t\t\tif (p < 0) continue;\n\t\t\t\tif (W[i - 1] - X[i - 1] - p < 0) continue;\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\nconst int maxn = 3005;\nconst int mo = 1e9 + 7;\nusing namespace std;\nint f[2][maxn], s[maxn], Max[maxn];\nint n, m;\nint main(){\n\tscanf(\"%d%d\", &n, &m); getchar();\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + getchar() - '0';\n\tfor (int l, r, i = 1; i <= m; i++){\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tMax[l] = max(Max[l], r);\n\t}\n\tfor (int i = 1; i <= n; i++) Max[i] = max(i, max(Max[i], Max[i - 1]));\n\tf[0][0] = 1; int T = 1;\n\tfor (int i = 1; i <= n; T ^= 1, i++){\n\t\tmemset(f[T], 0, sizeof f[T]);\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\tif (j + s[Max[i]] - s[Max[i - 1]] > 0) (f[T][j - 1 + s[Max[i]] - s[Max[i - 1]]] += f[T ^ 1][j]) %= mo;\n\t\t\tif (j + s[Max[i]] - s[Max[i - 1]] < Max[i] - (i - 1)) (f[T][j + s[Max[i]] - s[Max[i - 1]]] += f[T ^ 1][j]) %= mo;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[T ^ 1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i];\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint p=0;\n\t\t\trep(i,m) if(p<rs[i]){\n\t\t\t\tts.emplace_back(ls[i]-1,rs[i]);\n\t\t\t\tp=rs[i];\n\t\t\t}\n\t\t\tint l0=get<0>(ts[0]);\n\t\t\ts=s.substr(l0);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=l0,rs[i]-=l0;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m){\n\t\t\tfor(int i=ls[k];i<ls[k+1];i++){\n\t\t\t\tfor(int j=0;j<=i;j++){\n\t\t\t\t\t// use 0\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\t// use 1\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nvoid act(int& a, int b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n\n    string s; cin >> s;\n    vector<int> ones(n), zero(n);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '1') ones[i] = 1;\n        else zero[i] = 1;\n        if (i > 0) {\n            ones[i] += ones[i - 1];\n            zero[i] += zero[i - 1];\n        }\n    }\n\n    vector<int> best(n);\n    for (int i = 0; i < n; ++i)\n        best[i] = i;\n\n    for (int i = 0; i < m; ++i) {\n        int l, r; cin >> l >> r; --l; --r;\n        best[l] = max(best[l], r);\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        best[i + 1] = max(best[i + 1], best[i]);\n    }\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; i + j <= n; ++j) {\n            int at = i + j;\n            bool can_zero = zero[best[at]] > i;\n            bool can_ones = ones[best[at]] > j;\n            if (can_zero) act(dp[i + 1][j], dp[i][j]);\n            if (can_ones) act(dp[i][j + 1], dp[i][j]);\n        }\n    }\n    \n    int ans = 0;\n    for (int i = 0, j = n; i <= n; ++i, --j)\n        act(ans, dp[i][j]);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> pi;\n#define f first\n#define s second\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\n#define all(x) x.begin(),x.end()\nconst int maxn = 3005;\nconst int mod = 1e9+7;\n\nstring S;\nint maxr[maxn];\nint dp[maxn][maxn];\nint co[maxn];\nint n,m;\n\nint dpf(int x, int ones) {\n\tif (dp[x][ones] != -1) return dp[x][ones];\n\tif (ones > maxr[x] - x + 1) return 0;\n\tif (x == n) return 1ll;\n\t//cout << \"start: \" << x << \" \" << ones << \"\\n\";\n\t\n\tif (maxr[x] > maxr[x-1]) \n\t\tones += co[maxr[x]] - co[maxr[x-1]];\n\t\n\tdp[x][ones] = 0ll;\n\tif (ones <= maxr[x] - x) dp[x][ones] += dpf(x+1,ones);\n\tdp[x][ones] %= mod;\n\tif (ones > 0ll) dp[x][ones] += dpf(x+1,ones-1);\n\tdp[x][ones] %= mod;\n\t\n\t//cout << x << \" \" << maxr[x] << \" \" << ones << \"\\n\";\n\t//cout << x << \" \" << ones << \" \" << dp[x][ones] << \"\\n\";\n\t\n\treturn dp[x][ones];\n}\n\nint32_t main() {\n\tFAST\n\tcin >> n >> m;\n\tcin >> S;\n\tint firstl = -1;\n\t\n\tfor (int i =1;i<=n;i++) maxr[i] = i;\n\t\n\tfor (int i =1;i<=m;i++) {\n\t\tint l,r; cin >> l >> r;\n\t\tif (firstl == -1) firstl = l;\n\t\tmaxr[l] = max(maxr[l],r);\n\t}\n\t\n\tfor (int i =1;i<=n;i++) {\n\t\tmaxr[i] = max(maxr[i],maxr[i-1]);\n\t\tco[i] = co[i-1];\n\t\tif (S[i-1] == '1') co[i]++;\n\t\t//cout << i << \" \" << co[i] << \" \" << maxr[i] << \"\\n\";\n\t}\n\t\n\t//for (int i =1;i<=n;i++) {\n\t\t//cout << i << \" \" << maxr[i] << \"\\n\";\n\t//}\n\t \t\n\tmemset(dp,-1,sizeof dp);\n\tcout << dpf(firstl,0ll) % mod;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,tot,q[N],sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read();\n\t\tif(r[i]>r[q[tot]]&&tot)q[++tot]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tfor(int i=1;i<=tot;i++){\n\t\tl[i]=l[q[i]]; r[i]=r[q[i]];\n\t}\n\tm=tot; l[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<(f[m][0]+mod)%mod<<endl;\n}\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nint fac[3010],nifac[3010],sum[3010],l[3010],r[3010],f[3010][3010];\nbool bo[3010];\nint getmi(int a,int x)\n{\n\tint ans=1;\n\twhile (x)\n\t{\n\t\tif (x&1) ans=(long long)ans*a%mo;\n\t\ta=(long long)a*a%mo;\n\t\tx>>=1;\n\t}\n\treturn ans;\n}\nint C(int n,int m)\n{\n\tif ((m>n)||(n<0)||(m<0)) return 0;\n\treturn (long long)fac[n]*nifac[m]%mo*nifac[n-m]%mo;\n}\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tint n,m;scanf(\"%d%d\\n\",&n,&m);\n\tfac[0]=nifac[0]=1;\n\tfor (int i=1;i<=n;i++) {fac[i]=(long long)fac[i-1]*i%mo;nifac[i]=getmi(fac[i],mo-2);}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tchar ch=getchar();\n\t\tsum[i]=(ch=='1');\n\t}\n\tfor (int i=1;i<=m;i++) scanf(\"%d%d\",&l[i],&r[i]);\n\tbo[1]=true;int ed=1;\n\tfor (int i=2;i<=m;i++)\n\t{\n\t\tif (l[i]==l[ed]) {if (r[i]>=r[ed]) {bo[ed]=false;bo[i]=true;ed=i;}continue;}\n\t\tif (r[i]>r[ed]) {bo[i]=true;ed=i;}\n\t}\n\tint top=0;\n\tfor (int i=1;i<=m;i++) if (bo[i])\n\t{\n\t\ttop++;\n\t\tl[top]=l[i];r[top]=r[i];\n\t}\n\tfor (int i=1;i<=top;i++) \n\tl[top+1]=r[top]+1;\n\tf[0][0]=1;\n\tfor (int i=1;i<=top;i++) for (int j=r[i-1]+1;j<l[i];j++) sum[j]=0;\n\tfor (int i=1;i<=n;i++) sum[i]+=sum[i-1];\n\t\n\tfor (int i=1;i<=top;i++)\n\tfor (int j=max(0,sum[r[i]]-max(0,(r[i]-l[i+1]+1)));j<=sum[r[i]];j++)\n\t{\n\t\t//if (l[i]<=r[i-1])\n\t\t//{\n\t\t\tfor (int k=max(0,l[i]-min(l[i+1],r[i]+1)+j);k<=min(sum[r[i-1]],j);k++)\n\t\t\t\tf[i][j]=(f[i][j]+(long long)f[i-1][k]*C(min(l[i+1],r[i]+1)-l[i],j-k))%mo;\n\t\t//}\n\t\t//else f[i][j]=f[i-1][sum[r[i-1]]];\n\t\t//cerr<<i<<' '<<j<<' '<<f[i][j]<<endl;\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=sum[r[top]];i++) ans=(ans+f[top][i])%mo;\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\n#define pe pair<int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int MAX_N = 3010;\nconst long long MOD = 1000000007;\n\nvector<pe> ops;\n\nclass cmp {\npublic:\n  inline bool operator()(const pe &a, const pe &b) {\n    if(a.se == b.se) {\n      return a.fi > b.fi;\n    }\n    return a.se > b.se;\n  }\n};\n\nint le[MAX_N];\nint ri[MAX_N];\n\nlong long d[MAX_N][MAX_N];\n\nstring s;\nstring copie;\n\nint main()\n{\n  int n, m;\n  cin >> n >> m >> s;\n\n  for(int i = 1; i <= m; i++) {\n    int a, b;\n    cin >> a >> b;\n    ops.push_back(mp(a, b));\n  }\n\n  sort(ops.begin(), ops.end());\n\n  s = \" \" + s;\n  copie = s;\n\n  for(auto it : ops) {\n    int cnt0 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt0 += (s[i] == '0');\n    }\n\n    for(int i = it.fi; i < it.fi + cnt0; i++) {\n      s[i] = '0';\n    }\n    for(int i = it.fi + cnt0; i <= it.se; i++) {\n      s[i] = '1';\n    }\n  }\n  int cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      ri[++cnt] = i;\n    }\n  }\n\n\n  s = copie;\n  cnt = 0;\n\n  for(auto it : ops) {\n    int cnt1 = 0;\n    for(int i = it.fi; i <= it.se; i++) {\n      cnt1 += (s[i] == '1');\n    }\n    cout << it.fi << ' ' << cnt1 << \"#\\n\";\n\n    for(int i = it.fi; i < it.fi + cnt1; i++) {\n      s[i] = '1';\n    }\n    for(int i = it.fi + cnt1; i <= it.se; i++) {\n      s[i] = '0';\n    }\n  }\n\n  cout << s << '\\n';\n\n  cnt = 0;\n  for(int i = 1; i <= n; i++) {\n    if(s[i] == '1') {\n      le[++cnt] = i;\n            cout << le[cnt] << ' ' << ri[cnt] << '\\n';\n\n    }\n  }\n\n  d[0][0] = 1;\n  for(int i = 1; i <= n; i++) {\n    d[i][0] = d[i - 1][0];\n    for(int j = 1; j <= min(cnt, i); j++) {\n      if(i >= le[j] && i <= ri[j]) {\n        d[i][j] += d[i - 1][j - 1];\n      }\n      d[i][j] = (d[i][j] + d[i - 1][j]) % MOD;\n    }\n  }\n\n  cout << d[n][cnt] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll maxn = 100010;\nll fac[maxn],facinv[maxn],inv[maxn];\nvoid init(){\n    fac[0] = 1;\n    REP(i,1,maxn)fac[i] = i*(fac[i-1])%mod;\n    facinv[maxn-1]=inverse(fac[maxn-1], mod);\n    RREP(i,maxn-2,0){\n        facinv[i] = facinv[i+1]*(i+1)%mod;\n    }\n    inv[1]=1;\n    for(int i=2;i<maxn;i++)\n        inv[i]=(mod-(ll)mod/i*inv[mod%i]%mod);\n}\n\nll combi(int n,int m){\n    if(n<0 || m<0 || n<m)return 0;\n    return fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\n\nll get_len(ll a,ll b){\n    return max(b-a+1,0ll);\n}\nnamespace SOLVE {\n    void main(){\n        ll n,m;\n        cin>>n>>m;\n        string s;\n        cin>>s;\n        vector<PLL>v;\n        REP(i,0,m){\n            int l,r;in(l,r);\n            --l;--r;\n            if(sz(v) and v.back().se >= r){\n                continue;\n            }else{\n                if(sz(v) and v.back().fi == l){\n                    v.pop_back();\n                }\n                v.PB(MP(l,r));\n            }\n        }\n        \n        VLL dp(3010,0);\n        v.insert(v.begin(), MP(-1,-1));\n        v.PB(MP(inf,inf));\n        dp[0] = 1;\n        REP(i,1,sz(v)-1){\n            ll last = v[i-1].se;\n            ll cnt = 0;\n            for(int j = max(last+1,v[i].fi);j<=v[i].se;j++){\n                cnt += s[j] == '1';\n            }\n            ll nxt = min(v[i+1].fi-1,v[i].se);\n            VLL new_dp(3010,0);\n            ll len = nxt-v[i].fi+1;\n            ll overlap = get_len(max(v[i].fi,v[i+1].fi),min(v[i].se,v[i+1].se));\n            REP(use,0,len+1){\n                REP(from,0,3010){\n                    if(0 <= from+cnt-use and from+cnt-use <= overlap)new_dp[from+cnt-use] += dp[from] * combi(len, use) % mod;\n                }\n            }\n            swap(dp, new_dp);\n            REP(i,0,3010)dp[i]%=mod;\n        }\n        cout<<dp[0]<<endl;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    init();\n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 1);\n    fi.resize(n + 1);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * mint(i);\n    }\n    fi[n] = mint(1) / f[n];\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * mint(i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r) {\n        return mint(0);\n    }\n    if (r == 0) {\n        return mint(1);\n    }\n    return f[n] * fi[n - r] * fi[r];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> co(n + 1);\n    for (int i = 0; i < n; i++) {\n        co[i + 1] = co[i] + (s[i] == '1');\n    }\n    int mr = 0;\n    vector<P> v;\n    vector<int> rs(n, -1);\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        --l;\n        --r;\n        chmax(rs[l], r);\n    }\n    for (int i = 0; i < n; i++) {\n        if (rs[i] != -1 && rs[i] > mr) {\n            mr = rs[i];\n            v.push_back(P(i, rs[i]));\n        }\n    }\n    v.push_back(P(n - 1, n - 1));\n    vector<vector<mint>> dp(m + 1, vector<mint>(n + 1));\n    dp[0][0] = 1;\n    comb(n + 10);\n    for (int i = 0; i + 1 < v.size(); i++) {\n        int l = v[i].first, r = v[i].second;\n        int a = r - l + 1, c = a;\n        chmin(c, v[i + 1].first - l);\n        for (int j = 0; j <= n; j++) {\n            if (dp[i][j].a == 0) {\n                continue;\n            }\n            int b = co[r + 1] - j;\n            for (int d = max(0, b - a + c); d <= min(b, c); d++) {\n                int to = j + d;\n                if (c == a) {\n                    to = co[v[i + 1].first];\n                }\n                dp[i + 1][to] += dp[i][j] * ncr(c, d);\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i <= n; i++) {\n        res += dp[v.size() - 1][i];\n    }\n    cout << res.a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return vec<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\n\n\nnamespace math {\n\ntemplate <typename T>\nconstexpr T pow(const T &n, ll k) {\n    T ret = n.mul_id_ele();\n    T cur = n;\n    while (k) {\n        if (k & 1) ret *= cur;\n        cur *= cur;\n        k /= 2;\n    }\n    return ret;\n}\n\n}\n\nnamespace math {\n\ntemplate <ll Mod>\nstruct Modint {\n\n    constexpr Modint(ll x) : x(x % Mod) { }\n    \n    constexpr Modint() : Modint(0) { }\n    \n    constexpr Modint<Mod> add_id_ele() const { \n        return Modint<Mod>(0); \n    }\n    \n    constexpr Modint<Mod> mul_id_ele() const {\n        return Modint<Mod>(1); \n    }\n    \n    constexpr ll& value() { \n        return x; \n    }\n    \n    constexpr ll value() const {\n        return x; \n    }\n\n    constexpr Modint& operator +=(const Modint &oth) {\n        x += oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator -=(const Modint &oth) {\n        x += Mod - oth.value();\n        if (Mod <= x) x -= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator *=(const Modint &oth) {\n        x *= oth.value();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint& operator /=(const Modint &oth) {\n        x *= oth.inv();\n        x %= Mod;\n        return *this;\n    }\n\n    constexpr Modint operator +(const Modint &oth) const {\n        return Modint(x) += oth;\n    }\n\n    constexpr Modint operator -(const Modint &oth) const {\n        return Modint(x) -= oth;\n    }\n\n    constexpr Modint operator *(const Modint &oth) const {\n        return Modint(x) *= oth;\n    }\n\n    constexpr Modint operator /(const Modint &oth) const {\n        return Modint(x) /= oth;\n    }\n\n    constexpr Modint operator -() const {\n        return Modint((x != 0) * (Mod - x)); \n    }\n\n    template <typename T>\n    constexpr typename std::enable_if<std::is_integral<T>::value, const Modint&>::type\n    operator =(T t) {\n        (*this) = Modint(std::forward<T>(t)); \n        return *this;\n    }\n\n    constexpr Modint inv() const {\n        return ::math::pow(*this, Mod - 2);\n    }\n\n    constexpr ll mod() const {\n        return Mod;\n    }\n\nprivate:\n    ll x;\n};\n\n}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 5e15;\nusing mint = math::Modint<mod>;\nconst std::size_t SIZE = 3010;\nmint dp_buf[2][SIZE];\nauto dp1 = dp_buf[0], dp2 = dp_buf[1];\n\nint main() {\n    ll n, m;\n    std::string s;\n    std::cin >> n >> m >> s;\n    vec<ll> rights(n, -inf);\n    for (ll i = 0; i < m; i++) {\n        ll l, r;\n        std::cin >> l >> r;\n        chmax(rights[l - 1], r);\n    }\n\n    {\n        ll maxr = -inf;\n        for (ll i = 0; i < n; i++) {\n            if (rights[i] <= maxr) rights[i] = -inf;\n            else maxr = rights[i];\n        }\n    }\n\n    std::queue<pll> ops;\n    for (ll i = 0; i < n; i++) if (rights[i] != -inf) ops.emplace(i, rights[i]);\n\n    vec<ll> sum(n + 1);\n    for (ll i = 0; i < n; i++) sum[i + 1] = sum[i] + (s[i] == '1');\n\n    auto calc_dp = [&](std::queue<pll> &ranges) {\n        ll minl, cr;\n        std::tie(minl, cr) = ranges.front();\n        ranges.pop();\n        std::fill(dp1, dp1 + SIZE, mint(0));\n        dp1[0] = 1;\n        for (ll i = minl;; i++) {\n            if (ranges.empty() && i == cr) break;\n            std::fill(dp2, dp2 + SIZE, mint(0));\n            if (ranges.size() && ranges.front().first == i) {\n                cr = ranges.front().second;\n                ranges.pop();\n            }\n            for (ll j = 0; j <= sum[cr] - sum[minl]; j++) {\n                if (j < sum[cr] - sum[minl]) dp2[j + 1] += dp1[j];\n                if (sum[cr] - sum[minl] <= j + (cr - i) - 1) dp2[j] += dp1[j];\n            }\n            std::copy(dp2, dp2 + SIZE, dp1);\n        }\n\n        return dp1[sum[cr] - sum[minl]];\n    };\n\n    mint ans = 1;\n    while (ops.size()) {\n        std::queue<pll> que;\n        auto move_ele = [&] {\n            que.push(ops.front());\n            ops.pop();\n        };\n\n        move_ele();\n        ll cr = que.front().second;\n        while (ops.size()) {\n            ll l, r;\n            std::tie(l, r) = ops.front();\n            if (cr <= l) break;\n            cr = r;\n            move_ele();\n        }\n\n        ans *= calc_dp(que);\n    }\n\n    std::cout << ans.value() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nint modpow(int x, int n, int m){\n    int a = 1;\n    IREP(i, 64){\n        a = (a * a) % m;\n        if(((n >> i) & 1) == 1) a = (a * x) % m;\n    }\n    return a;\n}\n\nclass Combination\n{\npublic:\n\n    vec fact, invfact;\n    int MAX_N, mod;\n\n    Combination(int MAX_N, int mod): MAX_N(MAX_N), mod(mod) {\n        initialize();\n    }\n\n    void initialize(){\n        fact = vec(MAX_N + 1);\n        invfact = vec(MAX_N + 1);\n        fact[0] = 1;\n        FOR(i, 1, MAX_N + 1){\n            fact[i] = (fact[i - 1] * i) % mod;\n        }\n        invfact[MAX_N] = modpow(fact[MAX_N], mod - 2, mod);\n        IREP(i, MAX_N){\n            invfact[i] = (invfact[i + 1] * (i + 1)) % mod;\n        }\n    }\n\n    int nCr(int n, int r){\n        if(r > n || r < 0 || n < 0) return 0;\n        if(n > MAX_N){\n            MAX_N = n;\n            initialize();\n        }\n        int a = fact[n];\n        a = (a * invfact[r]) % mod;\n        a = (a * invfact[n - r]) % mod;\n        return a;\n    }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    int mod = 1000000007;\n    Combination comb(N, mod);\n\n    mat dp(M + 1, vec(N + 1, 0));\n    dp[0][n1[l[0]]] = 1;\n    int rmax = -1;\n    REP(i, M){\n        rmax = max(rmax, r[i]);\n        int l0 = l[i], l1 = l[i + 1];\n        if(l1 <= rmax){\n            int t = n1[rmax + 1];\n            int u = max(0LL, t - (rmax - l1 + 1));\n            FOR(j, u, t + 1){ \n                REP(k, j + 1){\n                    dp[i + 1][j] += dp[i][k] * comb.nCr(l1 - l0, j - k);\n                    dp[i + 1][j] %= mod;\n                }\n            }\n        }else{\n            int t = n1[l1];\n            REP(k, t + 1){\n                dp[i + 1][t] += dp[i][k] * comb.nCr(rmax - l0 + 1, t - k);\n                dp[i + 1][t] %= mod;\n            }\n        }\n    }\n    //debug(dp);\n    cout << dp[M][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3005\nusing namespace std;\n\nint n,m,s[N],a[N],b[N],dp[N][N],cbn[N][N]; char ch[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) s[i]=s[i-1]+(ch[i]=='1');\n\tm++; a[1]=b[1]=1;\n\tfor (i=2; i<=m; i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif (a[i]==a[i-1]){\n\t\t\tb[i-1]=max(b[i-1],b[i]); i--; m--; continue;\n\t\t}\n\t\tif (b[i]<=b[i-1]){ i--; m--; continue; }\n\t\twhile (a[i]>b[i-1]+1){\n\t\t\ta[i+1]=a[i]; b[i+1]=b[i];\n\t\t\ta[i]=b[i]=b[i-1]+1;\n\t\t\ti++; m++;\n\t\t}\n\t}\n\tfor (; b[m]<=n; m++) a[m+1]=b[m+1]=b[m]+1;\n\tdp[0][0]=1;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++) cbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tfor (i=1; i<=m; i++){\n\t\tfor (j=max(a[i+1]-1-b[i]+s[b[i]],0); j<=s[b[i]]; j++)\n\t\t\tfor (k=0; k<=a[i+1]-a[i] && k<=j; k++) dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k]*cbn[a[i+1]-a[i]][k])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[m][s[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 1 << 20;\n\nint n, m, f[N], g[N], r[N], L[N], R[N], tot[N], dp[1 << 12][1 << 12], ones[N], A[N], B[N], C[N];\nchar a[N];\npair<int, int> p[N];\n\ninline int calc_ones(int st, int en) {\n\tif (st == 0) return ones[en];\n\treturn ones[en] - ones[st - 1];\n}\n\ninline int nCm(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn (long long)f[n] * g[m] % mod * g[n - m] % mod;\n}\n\nnamespace FFT {\n\tconst int M = 1<<18;\n\n\tusing DB = long double;\n\tusing LL = long long;\n\n\tstruct CP {\n\t\tDB x, y;\n\t\tCP(DB x=0, DB y=0) : x(x), y(y) {}\n\t\tCP operator+(const CP &rhs) const {\n\t\t\treturn CP(x+rhs.x, y+rhs.y);\n\t\t}\n\t\tvoid operator+=(const CP &rhs) {\n\t\t\tx += rhs.x, y += rhs.y;\n\t\t}\n\t\tCP operator-(const CP &rhs) const {\n\t\t\treturn CP(x-rhs.x, y-rhs.y);\n\t\t}\n\t\tCP operator*(const CP &rhs) const {\n\t\t\treturn CP(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);\n\t\t}\n\t\tCP operator!() const {\n\t\t\treturn (CP) {\n\t\t\t\tx, -y\n\t\t\t};\n\t\t}\n\t\tvoid operator*=(const CP &rhs) {\n\t\t\tDB tx = x*rhs.x-y*rhs.y, ty = x*rhs.y+y*rhs.x;\n\t\t\tx = tx, y = ty;\n\t\t}\n\t} f[M], g[M], h[M], p_w[M+1];\n\n\tint bit_inv[M];\n\n\tvoid init() {\n\t\tDB alpha = acos(-1)/M*2;\n\t\tfor (int i = 0; i <= M; i++) p_w[i] = CP(cos(alpha*i), sin(alpha*i));\n\t\tfor (int i = 0, j = 1; j < M; j++) {\n\t\t\tfor (int k = M >> 1; (i ^= k) < k; k >>= 1);\n\t\t\tbit_inv[j] = i;\n\t\t}\n\t}\n\n\tvoid FFT(CP *A, int N, int D = 1) {\n\t\tfor (int j = 1, i, d = __builtin_ctz(M/N); j < N-1; j++) if ((i = (bit_inv[j] >> d)) < j) swap(A[i], A[j]);\n\t\tfor (int n = 1, m = M/2*D; n < N; m /= 2, n <<= 1) {\n\t\t\tfor (int i = 0; i < N; i += n<<1) {\n\t\t\t\tCP *w = (D == 1 ? p_w : p_w + M), *a = A+i, *b = A+i+n;\n\t\t\t\tfor (int j = 0; j < n; j++, a++, b++, w += m) {\n\t\t\t\t\tCP x = *w **b;\n\t\t\t\t\t*b = *a - x;\n\t\t\t\t\t*a += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D != 1) for (int i = 0; i < N; i++) A[i].x /= N, A[i].y /= N;\n\t}\n\n\tvoid conv(int *A, int *B, int *C, int N, int MOD) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t}\n\t\t\tmemcpy(C, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) g[i] = CP(B[i]>>15, B[i]&32767);\n\t\tFFT(g, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=((f[i]+!f[j])*(!g[j]-g[i])+(!f[j]-f[i])*(g[i]+!g[j]))*CP(0,0.25);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (LL(h[i].x+0.5)%MOD<<15)%MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=(!f[j]-f[i])*(!g[j]-g[i])*CP(-0.25, 0)+CP(0, 0.25)*(f[i]+!f[j])*(g[i]+!g[j]);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (C[i] + LL(h[i].x+0.5)+((LL(h[i].y+0.5)%MOD)<<30)) % MOD;\n\t}\n\n\tvoid conv(int *A, int *B, int N, int P) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * A[j]) % P;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * A[j]) % P;\n\t\t\t}\n\t\t\tmemcpy(B, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=((!(f[j]*f[j]))-f[i]*f[i])*CP(0,0.5);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (LL(g[i].x+0.5)%P<<15)%P;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=(!f[j]-f[i])*(!f[j]-f[i])*CP(-0.25,0)+CP(0,0.25)*(f[i]+!f[j])*(f[i]+!f[j]);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (B[i] + LL(g[i].x+0.5)+((LL(g[i].y+0.5)%P)<<30)) % P;\n\t}\n};\n\nint solve(int st, int en) {\n\tfor (int i = st; i <= en; i++) {\n\t\tint common = 0;\n\t\tif (i < en) common = p[i].second - p[i + 1].first + 1;\n\t\tR[i] = min(p[i].second - p[st].first + 1 - common, calc_ones(p[st].first, p[i].second));\n\t\tL[i] = max(0, R[i] - common);\n\t\ttot[i] = p[i].second - p[i].first + 1 - common;\n\t}\n\tfor (int i = st; i <= en; i++) {\n\t\tif (i == st) {\n\t\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = nCm(tot[i], j);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= R[i]; k++) A[k] = dp[i - 1][k];\n\t\tfor (int k = 0; k <= R[i]; k++) B[k] = nCm(tot[i], k);\n\t\tint len = 1 << (32 - __builtin_clz(R[i] * 2 - 1));\n\t\tfor (int k = R[i] + 1; k < len; k++) A[k] = B[k] = 0;\n\t\tFFT::conv(A, B, C, len, mod);\n\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = C[j];\n//\t\t{\n//\t\t\tfor (int k = L[i - 1]; k <= R[i - 1]; k++) {\n//\t\t\t\tdp[i][j] = (dp[i][j] + (long long)dp[i - 1][k] * nCm(tot[i], j - k)) % mod;\n//\t\t\t}\n//\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = L[en]; i <= R[en]; i++) ret = (ret + dp[en][i]) % mod;\n\treturn ret;\n}\n\nint main() {\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tFFT::init();\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tf[0] = r[0] = r[1] = g[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) f[i] = (long long)f[i - 1] * i % mod;\n\t\tif (i > 1) r[i] = (long long)(mod - mod / i) * r[mod % i] % mod;\n\t\tif (i) g[i] = (long long)g[i - 1] * r[i] % mod;\n\t}\n//\tint ans = 0;\n//\tfor (int a = 2; a <= 3; a++) {\n//\t\tfor (int b = 4 - a; b <= 5 - a; b++) {\n//\t\t\tint c = 7 - a - b;\n//\t\t\tans += nCm(3, a) * nCm(2, b) * nCm(4, c);\n//\t\t}\n//\t}\n//\tcout << ans << endl;\n\tcin >> n >> m >> a;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) ones[i] = ones[i - 1];\n\t\tif (a[i] == '1') ones[i]++;\n\t}\n\tvector<pair<int, int>> vec;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> p[i].first >> p[i].second;\n\t\tp[i].first--;\n\t\tp[i].second--;\n\t\tif (i && p[i].second <= vec.back().second) continue;\n\t\tvec.push_back(p[i]);\n\t}\n\tm = vec.size();\n\tfor (int i = 0; i < m; i++) p[i] = vec[i];\n\tcout << solve(0, m - 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    int sum[2]; rep (i, 2) sum[i] = 0;\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        sum[s[i] == '1']++;\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    dp[0][0] = 1;\n    rep (i, n) {\n        memo[0] = memo[1] = 0;\n        rep (j, n) {\n            if (R[j] < i) memo[s[j] == '1']++;\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] %= mod, dp[j+1][i-j] %= mod;\n        }\n    }\n    cout << dp[sum[0]][sum[1]] << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T,class S,class R> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv3(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c; cin>>a>>b>>c; v[i]={a,b,c};} return move(v);}\ntemplate<class T,class S,class R,class Q> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline vector<T> cinv4(ll N){\n\tvector<T> v(N); REP(i, N){ll a,b,c,d; cin>>a>>b>>c>>d; v[i]={a,b,c,d};} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nstruct LR{\n\tll l, r;\n};\nvoid solve()\n{\n\tll n, m;  cin >> n >> m;\n\tstring s;  cin >> s;\n\tvector<LR> lr_ = cinv2<LR>(m);\n\teach(e, lr_){\n\t\te.l--; e.r--;\n\t}\n\n\tdeque<LR> lr;\n\teach(e, lr_){\n\t\tif (lr.empty() or lr.back().r < e.r){\n\t\t\tlr.push_back(e);\n\t\t}\n\t}\n\n\tvvmll dp(n+1, vmll(n+1));\n\tauto Dp = [&](ll i, ll j)->mll&{\n\t\tstatic mll dmy=0;\n\t\tif (j>n or j<0)return dmy;\n\t\treturn dp[i+1][j];\n\t};\n\tDp(-1, 0)=1;\n\n\tll en=-1;\n\t\n\trep(i, -1, n-2){\n\t\tll ii=i+1;\n\t\tll adj=0;\n\t\tif (!lr.empty() and lr.front().l==ii){\n\t\t\tll pre_en=en;\n\t\t\ten=lr.front().r;\n\t\t\t//pre_en+1～enの間の1の数\n\t\t\tadj=count(s.begin()+(pre_en+1), s.begin()+en+1, '1');\n\t\t\tlr.pop_front();\n\t\t}\n\t\tif (en<ii)en=ii;\n\n\t\trep(j, 0, n){\n\t\t\tif (j+adj<=en-ii){\n\t\t\t\tDp(ii, j+adj)+=Dp(i, j);\n\t\t\t}\n\t\t\tif (j+adj-1<=en-ii){\n\t\t\t\tDp(ii, j+adj-1)+=Dp(i, j);\n\t\t\t}\n\t\t}\n\n\t\tif (en==ii){\n\t\t\trep(j, 1, n) Dp(ii, j)=0;\n\t\t}\n\t}\n\tmll ans=Dp(n-1, 0);\n\tcout << ans << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=3e3+7;\nll dp[maxn][maxn];\nint last[maxn];\nint main()\n{\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tfor(int i=1;i<=n;i++) last[i]=i;\n\tfor(int i=1,l,r;i<=m;i++)\n\t{\n\t\tcin>>l>>r;\n\t\tlast[l]=max(last[l],r);\n\t}\n\tdp[0][0]=1;\n\tint cur=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint cc=0;\n\t\tif(last[i]>cur)\n\t\t{\n\t\t\tfor(int j=cur;j<last[i];j++)\n\t\t\t\tcc+=(s[j]=='1');\n\t\t}\n\t\tcur=max(cur,last[i]);\n\t\tfor(int j=0;j<=cur;j++)\n\t\t{\n\t\t\tint nxt=j+cc;\n\t\t\tif(i+nxt<=cur)\n\t\t\t\tdp[i][nxt]=(dp[i][nxt]+dp[i-1][j])%mod;\n\t\t\tif(nxt>=1)\n\t\t\t\tdp[i][nxt-1]=(dp[i][nxt-1]+dp[i-1][j])%mod;\n\t\t\t//dbg(i,j,cc,dp[i][j]);\n\t\t}\n\t}\n\tcout<<dp[n][0]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 3030;\nconst int mod = 1e9 + 7;\n\nint add(int x, int y) {\n  x += y;\n  if (x >= mod)\n    x -= mod;\n  return x;\n}\n\nint udd(int &x, int y) {\n  return x = add(x, y);\n}\n\nint n, m;\nint l[M], r[M];\nint up[M], down[M];\nint d[M][M];\nstring s;\n\nvoid read() {\n  cin >> n >> m >> s;\n  for (int i = 0; i < m; ++i) {\n    int l, r;\n    cin >> l >> r;\n    --l;\n    ::l[i] = l;\n    ::r[i] = r;\n  }\n}\n\nvoid calc(string s, function<bool(char, char)> cmp, int *to) {\n  for (int i = 0; i < m; ++i)\n    sort(s.begin() + l[i], s.begin() + r[i], cmp);\n  for (int i = 0; i < n; ++i)\n    to[i + 1] = to[i] + (s[i] - '0');\n}\n\nvoid kill() {\n  calc(s, less<char>(), down);\n  calc(s, greater<char>(), up);\n  d[0][0] = 1;\n  int A = down[n];\n  int B = n - A;\n  for (int i = 0; i <= A; ++i)\n    for (int j = 0; j <= B; ++j) {\n      int k = i + j;\n      if (down[k] <= i && i <= up[k]) {\n        int cur = d[i][j];\n        udd(d[i + 1][j], cur);\n        udd(d[i][j + 1], cur);\n      }\n    }\n\n  cout << d[A][B] << endl;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"f.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\n#define MOD 1000000007\nconst int NUM_FAC = 2000001;\nll modfact(ll x) {\n\tstatic ll _fact[NUM_FAC + 1];\n\tif (_fact[0] == 0) {\n\t\t_fact[0] = 1;\n\t\tfor (int i = 1; i <= NUM_FAC; ++i) _fact[i] = _fact[i - 1] * i%MOD;\n\t}\n\treturn _fact[x];\n}\nll modpow(ll a, ll n) {\n\ta %= MOD;\n\tif (a == 0) return 0;\n\tll r = 1;\n\twhile (n) r = r*((n % 2) ? a : 1) % MOD, a = a*a%MOD, n >>= 1;\n\treturn r;\n}\nll moddiv(ll a, ll b)\n{\n\tll ap_2 = modpow(b, MOD - 2);\n\treturn (a * ap_2) % MOD;\n}\nll aCb(ll a, ll b) {\n\treturn moddiv(modfact(a), (modfact(a - b) * modfact(b)) % MOD);\n}\n//-----------------------------------------------------------------\nint N, M;\nstring S;\nint L[3010], R[3010];\nll dp[3010][3010];\n//-----------------------------------------------------------------\nint imos[3010];\nint main() {\n\tcin >> N >> M >> S;\n\tS = \"#\" + S;\n\trep(i, 0, M) {\n\t\tcin >> L[i] >> R[i];\n\t}\n\n\trep(i, 0, N + 1) if (S[i] == '1') imos[i] = 1;\n\trep(i, 0, N) imos[i + 1] += imos[i];\n\n\trep(i, 0, 3010) rep(j, 0, 3010) dp[i][j] = -1;\n\tdp[0][0] = 1;\n\n\trep(i, 1, N + 1) {\n\t\tdp[i][imos[i]] = 1;\n\t}\n\n\t/*rep(ii, 0, N + 1) {\n\t\trep(jj, 0, N + 1) printf(\"dp[%02d][%02d] = %lld \", ii, jj, dp[ii][jj]);\n\t\tcout << endl;\n\t}\n\tcout << \"-------------------------\" << endl;*/\n\n\trep(i, 0, M) {\n\t\trep(j, L[i], R[i] + 1) {\n\t\t\tint l = max(j - (R[i] - imos[R[i]]), 0);\n\t\t\tint r = min(imos[R[i]], j) + 1;\n\t\t\t//printf(\"<< %d, %d >>\\n\", l, r);\n\t\t\trep(k, l, r) {\n\t\t\t\tll a;\n\t\t\t\tif (0 <= k - 1)\n\t\t\t\t\ta = max(0LL, dp[j - 1][k - 1]);\n\t\t\t\telse\n\t\t\t\t\ta = 0;\n\t\t\t\tll b = max(0LL, dp[j - 1][k]);\n\t\t\t\tdp[j][k] = (a + b) % MOD;\n\t\t\t}\n\t\t}\n\n\t\t/*rep(ii, 0, N + 1) {\n\t\t\trep(jj, 0, N + 1) printf(\"dp[%02d][%02d] = %lld \", ii, jj, dp[ii][jj]);\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"-------------------------\" << endl;*/\n\t}\n\n\tint maxR = 0;\n\trep(i, 0, M) maxR = max(maxR, R[i]);\n\tint maxL = L[M - 1];\n\n\tcout << dp[maxR][imos[maxR]] << endl;\n\t\n\tll ans = 0;\n\trep(i, 0, maxL + 1) if(0 <= dp[maxL][i]){\n\t\tif (maxR - maxL + 1 < imos[maxR] - i) continue;\n\t\tll t = (dp[maxL][i] * aCb(maxR - maxL + 1, imos[maxR] - i)) % MOD;\n\t\tans = (ans + t) % MOD;\n\t}\n\n\t//cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 1 << 20;\n\nint n, m, f[N], g[N], r[N], L[N], R[N], tot[N], dp[1 << 12][1 << 12], ones[N], A[N], B[N], C[N];\nchar a[N];\npair<int, int> p[N];\n\ninline int calc_ones(int st, int en) {\n\tif (st == 0) return ones[en];\n\treturn ones[en] - ones[st - 1];\n}\n\ninline int nCm(int n, int m) {\n\tif (m < 0 || m > n) return 0;\n\treturn (long long)f[n] * g[m] % mod * g[n - m] % mod;\n}\n\nnamespace FFT {\n\tconst int M = 1<<18;\n\n\tusing DB = long double;\n\tusing LL = long long;\n\n\tstruct CP {\n\t\tDB x, y;\n\t\tCP(DB x=0, DB y=0) : x(x), y(y) {}\n\t\tCP operator+(const CP &rhs) const {\n\t\t\treturn CP(x+rhs.x, y+rhs.y);\n\t\t}\n\t\tvoid operator+=(const CP &rhs) {\n\t\t\tx += rhs.x, y += rhs.y;\n\t\t}\n\t\tCP operator-(const CP &rhs) const {\n\t\t\treturn CP(x-rhs.x, y-rhs.y);\n\t\t}\n\t\tCP operator*(const CP &rhs) const {\n\t\t\treturn CP(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);\n\t\t}\n\t\tCP operator!() const {\n\t\t\treturn (CP) {\n\t\t\t\tx, -y\n\t\t\t};\n\t\t}\n\t\tvoid operator*=(const CP &rhs) {\n\t\t\tDB tx = x*rhs.x-y*rhs.y, ty = x*rhs.y+y*rhs.x;\n\t\t\tx = tx, y = ty;\n\t\t}\n\t} f[M], g[M], h[M], p_w[M+1];\n\n\tint bit_inv[M];\n\n\tvoid init() {\n\t\tDB alpha = acos(-1)/M*2;\n\t\tfor (int i = 0; i <= M; i++) p_w[i] = CP(cos(alpha*i), sin(alpha*i));\n\t\tfor (int i = 0, j = 1; j < M; j++) {\n\t\t\tfor (int k = M >> 1; (i ^= k) < k; k >>= 1);\n\t\t\tbit_inv[j] = i;\n\t\t}\n\t}\n\n\tvoid FFT(CP *A, int N, int D = 1) {\n\t\tfor (int j = 1, i, d = __builtin_ctz(M/N); j < N-1; j++) if ((i = (bit_inv[j] >> d)) < j) swap(A[i], A[j]);\n\t\tfor (int n = 1, m = M/2*D; n < N; m /= 2, n <<= 1) {\n\t\t\tfor (int i = 0; i < N; i += n<<1) {\n\t\t\t\tCP *w = (D == 1 ? p_w : p_w + M), *a = A+i, *b = A+i+n;\n\t\t\t\tfor (int j = 0; j < n; j++, a++, b++, w += m) {\n\t\t\t\t\tCP x = *w **b;\n\t\t\t\t\t*b = *a - x;\n\t\t\t\t\t*a += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (D != 1) for (int i = 0; i < N; i++) A[i].x /= N, A[i].y /= N;\n\t}\n\n\tvoid conv(int *A, int *B, int *C, int N, int MOD) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * B[j]) % MOD;\n\t\t\t}\n\t\t\tmemcpy(C, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) g[i] = CP(B[i]>>15, B[i]&32767);\n\t\tFFT(g, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=((f[i]+!f[j])*(!g[j]-g[i])+(!f[j]-f[i])*(g[i]+!g[j]))*CP(0,0.25);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (LL(h[i].x+0.5)%MOD<<15)%MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\th[i]=(!f[j]-f[i])*(!g[j]-g[i])*CP(-0.25, 0)+CP(0, 0.25)*(f[i]+!f[j])*(g[i]+!g[j]);\n\t\t}\n\t\tFFT(h, N, -1);\n\t\tfor (int i = 0; i < N; i++) C[i] = (C[i] + LL(h[i].x+0.5)+((LL(h[i].y+0.5)%MOD)<<30)) % MOD;\n\t}\n\n\tvoid conv(int *A, int *B, int N, int P) {\n\t\tif (N <= 64) {\n\t\t\tstatic int temp[64];\n\t\t\tmemset(temp, 0, sizeof(int)*N);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N-i; j++) temp[i+j] = (temp[i+j] + 1LL * A[i] * A[j]) % P;\n\t\t\t\tfor (int j = N-i; j < N; j++) temp[i+j-N] = (temp[i+j-N] + 1LL * A[i] * A[j]) % P;\n\t\t\t}\n\t\t\tmemcpy(B, temp, sizeof(int)*N);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) f[i] = CP(A[i]>>15, A[i]&32767);\n\t\tFFT(f, N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=((!(f[j]*f[j]))-f[i]*f[i])*CP(0,0.5);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (LL(g[i].x+0.5)%P<<15)%P;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint j=i?N-i:0;\n\t\t\tg[i]=(!f[j]-f[i])*(!f[j]-f[i])*CP(-0.25,0)+CP(0,0.25)*(f[i]+!f[j])*(f[i]+!f[j]);\n\t\t}\n\t\tFFT(g, N, -1);\n\t\tfor (int i = 0; i < N; i++) B[i] = (B[i] + LL(g[i].x+0.5)+((LL(g[i].y+0.5)%P)<<30)) % P;\n\t}\n};\n\nint solve(int st, int en) {\n\tfor (int i = st; i <= en; i++) {\n\t\tint common = 0;\n\t\tif (i < en) common = p[i].second - p[i + 1].first + 1;\n\t\tR[i] = min(p[i].second - p[st].first + 1 - common, calc_ones(p[st].first, p[i].second));\n\t\tL[i] = max(0, R[i] - common);\n\t\ttot[i] = p[i].second - p[i].first + 1 - common;\n\t}\n\tfor (int i = st; i <= en; i++) {\n\t\tif (i == st) {\n\t\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = nCm(tot[i], j);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int k = 0; k <= R[i]; k++) A[k] = dp[i - 1][k];\n\t\tfor (int k = 0; k <= R[i]; k++) B[k] = nCm(tot[i], k);\n\t\tint len = 1 << (32 - __builtin_clz(R[i] * 2 + 1)) * 2;\n\t\tfor (int k = R[i] + 1; k < len; k++) A[k] = B[k] = 0;\n\t\tFFT::conv(A, B, C, len, mod);\n\t\tfor (int j = L[i]; j <= R[i]; j++) dp[i][j] = C[j];\n//\t\t{\n//\t\t\tfor (int k = L[i - 1]; k <= R[i - 1]; k++) {\n//\t\t\t\tdp[i][j] = (dp[i][j] + (long long)dp[i - 1][k] * nCm(tot[i], j - k)) % mod;\n//\t\t\t}\n//\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = L[en]; i <= R[en]; i++) ret = (ret + dp[en][i]) % mod;\n\treturn ret;\n}\n\nint main() {\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\tFFT::init();\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tf[0] = r[0] = r[1] = g[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i) f[i] = (long long)f[i - 1] * i % mod;\n\t\tif (i > 1) r[i] = (long long)(mod - mod / i) * r[mod % i] % mod;\n\t\tif (i) g[i] = (long long)g[i - 1] * r[i] % mod;\n\t}\n//\tint ans = 0;\n//\tfor (int a = 2; a <= 3; a++) {\n//\t\tfor (int b = 4 - a; b <= 5 - a; b++) {\n//\t\t\tint c = 7 - a - b;\n//\t\t\tans += nCm(3, a) * nCm(2, b) * nCm(4, c);\n//\t\t}\n//\t}\n//\tcout << ans << endl;\n\tcin >> n >> m >> a;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i) ones[i] = ones[i - 1];\n\t\tif (a[i] == '1') ones[i]++;\n\t}\n\tvector<pair<int, int>> vec;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> p[i].first >> p[i].second;\n\t\tp[i].first--;\n\t\tp[i].second--;\n\t\tif (i && p[i].second <= vec.back().second) continue;\n\t\tvec.push_back(p[i]);\n\t}\n\tm = vec.size();\n\tfor (int i = 0; i < m; i++) p[i] = vec[i];\n\tcout << solve(0, m - 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i],ls[i]--;\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\tint pl=-1,pr=-1;\n\t\t\trep(i,m) if(pr<rs[i]){\n\t\t\t\tif(pl<ls[i])\n\t\t\t\t\tts.emplace_back(ls[i],rs[i]);\n\t\t\t\telse\n\t\t\t\t\tts.back()=mt(ls[i],rs[i]);\n\t\t\t\ttie(pl,pr)=ts.back();\n\t\t\t}\n\t\t\tint first=get<0>(ts[0]),last=get<1>(ts.back());\n\t\t\ts=s.substr(first,last-first);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=first,rs[i]-=first;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['0'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m){\n\t\t\trepi(i,ls[k],min(rs[k],ls[k+1]))\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\t\t\trepi(i,rs[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(s[i]=='0')\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\telse\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\t\t}\n\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\nll R[5000];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = i;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = max(R[i], R[i - 1]);\n        //cout << R[i] << endl;\n    }\n    dp[1][summ(1, R[1])] = 1;\n    for (int p = 1; p <= n; p++)\n    {\n        if (p > 1 && R[p] > R[p - 1])\n        {\n            for (int j = n; j >= summ(R[p - 1] + 1, R[p]); j--)\n            {\n                dp[p][j] = dp[p][j - summ(R[p - 1] + 1, R[p])];\n                dp[p][j - summ(R[p - 1] + 1, R[p])] = 0;\n            }\n        }\n        for (int c = 0; c <= n; c++)\n        {\n            if (R[p + 1] - (p + 1) + 1 >= c)\n                dp[p + 1][c] = (dp[p][c] + dp[p][c + 1]) % MOD;\n        }\n    }\n    /*for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n    cout << (dp[n][1] + dp[n][0]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define N 1000015\nconst int p=1e9+7;\nint n,m,dp[3002][3002],mx[N],s[N];\nchar ch[N];\ninline int ksm(int d,int tk){int ret=1;while(tk){if(tk&1)ret=1ll*ret*d%p;d=1ll*d*d%p;tk>>=1;}return ret;}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",ch+1);\n    for(int i=1;i<=n;i++)s[i]=s[i-1]+ch[i]-'0',mx[i]=i;s[n+1]=s[n];\n    for(int i=1;i<=m;i++)\n    {\n    \tint l,r;scanf(\"%d%d\",&l,&r);\n    \tmx[l]=max(mx[l],r);\n\t}\n\tfor(int i=1;i<=n;i++)mx[i]=max(mx[i],mx[i-1]);mx[n+1]=mx[n];\n\tdp[0][s[mx[1]]]=1;\n\tfor(int i=0;i<n;i++)for(int j=0;j<=n;j++)\n\t{\n\t\tif(j)(dp[i+1][j+s[mx[i+2]]-s[mx[i+1]]-1]+=dp[i][j])%=p;\n\t\tif(mx[i+1]-i-j>0)(dp[i+1][j+s[mx[i+2]]-s[mx[i+1]]]+=dp[i][j])%=p;\n\t}\n\tprintf(\"%d\\n\",dp[n][0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define taskname \"A\"\n#define pb push_back\n#define mp make_pair\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 3e3 + 5;\nconst int logn = log2(maxn) + 1;\nconst int mod = 1e9 + 7;\nint n , m;\nstring s;\nint r[maxn];\nint dp[maxn][maxn];\nint sum[maxn];\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    if(fopen(taskname\".INP\", \"r\")) {\n        freopen(taskname\".INP\", \"r\", stdin);\n        freopen(taskname\".OUT\", \"w\", stdout);\n    }\n    cin >> n >> m;\n    cin >> s;\n    for(int i = 1 ; i <= n ; ++i){\n        sum[i] = sum[i - 1] + (s[i - 1] == '1');\n        r[i] = i;\n    }\n    for(int i = 1 ; i <= m ; ++i){\n        int l , rr;cin >> l >> rr;\n        r[l] = max(r[l] , rr);\n    }\n    for(int i = 1 ; i <= n ; ++i)r[i] = max(r[i] , r[i - 1]);\n    r[n + 1] = r[n];\n    dp[1][sum[r[1]]] = 1;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 0 ; j <= n ; ++j){\n            auto add = [&](int & x , int y){\n                x += y;\n                if(x >= mod)x-=mod;\n            };\n            if(j > 0)add(dp[i + 1][j + sum[r[i + 1]] - sum[r[i]] - 1] , dp[i][j]);\n            if(r[i] - i + 1 > j)add(dp[i + 1][j + sum[r[i + 1]] - sum[r[i]]] , dp[i][j]);\n        }\n    }\n    cout << dp[n + 1][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint D[3010][3010], P[3010], Mod = 1000000007;\nint S[3010], n, m;\nchar p[3010];\nint main(){\n    int i, a, b, j;\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",p+1);\n    for(i=1;i<=n;i++){\n        P[i]=i;\n        S[i]=S[i-1]+p[i]-'0';\n    }\n    for(i=1;i<=m;i++){\n        scanf(\"%d%d\",&a,&b);\n        for(j=a;j<=b;j++)P[j]=max(P[j],b);\n    }\n    D[0][0]=1;\n    for(i=0;i<n;i++){\n        int bb, ee;\n        bb = max(0, i - (P[i] - S[P[i]])), ee = min(i, S[P[i]]);\n        for(j=bb;j<=ee;j++){\n            D[i+1][j]=(D[i+1][j]+D[i][j])%Mod;\n            D[i+1][j+1]=(D[i+1][j+1]+D[i][j])%Mod;\n        }\n    }\n    printf(\"%d\\n\",D[n][S[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\n#define ANS(f) if(f) cout << \"YES\" << endl; else cout << \"NO\" << endl;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\nvoid debug(mat m){REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl; }}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    vec l(M), r(M);\n    REP(i, M){\n        cin >> l[i] >> r[i];\n        l[i]--; r[i]--; \n    }\n    l.push_back(N);\n    r.push_back(N);\n\n    vec n1(N + 1, 0);\n    REP(i, N){\n        n1[i + 1] = n1[i];\n        if(S[i] == '1') n1[i + 1]++;\n    }\n\n    vec rmax(N);\n    REP(i, N) rmax[i] = i;\n    int r0 = -1;\n    REP(i, M){\n        r0 = max(r0, r[i]);\n        FOR(j, l[i], min(l[i + 1], r0 + 1)) rmax[j] = r0;\n    }\n\n    int mod = 1000000007;\n\n    mat dp(N + 1, vec(N + 1, 0));\n    dp[0][0] = 1;\n    REP(i, N){\n        int t = n1[rmax[i] + 1];\n        int u = max(t - (rmax[i] - i), 0LL);\n        FOR(j, u, t + 1){\n            if(j == 0) dp[i + 1][0] = dp[i][0];\n            else dp[i + 1][j] = (dp[i][j - 1] + dp[i][j]) % mod;\n        }\n    }\n    //debug(dp);\n    \n    cout << dp[N][n1[N]] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_>\nstruct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n \nprivate:\n\tusing ll = long long;\n \n\tint v;\n \n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n \npublic:\n \n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n \n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n \n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n \n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n \n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n \n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9) + 7>;\n\nconst int MAXN = 3010;\nint N;\nint M;\nstring s;\n\nint rightMost[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> M >> s;\n\tfor (int i = 0; i < N; i++) {\n\t\trightMost[i] = i+1;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint l, r; cin >> l >> r; l--;\n\t\trightMost[l] = max(rightMost[l], r);\n\t}\n\tfor (int i = 1; i < N; i++) {\n\t\trightMost[i] = max(rightMost[i], rightMost[i-1]);\n\t}\n\n\tvector<num> dp(N+1);\n\tdp[0] = 1;\n\tfor (int i = 0, cur = 0; i < N; i++) {\n\t\tint incr = 0;\n\t\twhile (cur < rightMost[i]) {\n\t\t\tincr += int(s[cur] - '0');\n\t\t\tcur++;\n\t\t}\n\n\t\tvector<num> ndp(N+1);\n\t\tfor (int c = 0; c <= N; c++) {\n\t\t\tif (!int(dp[c])) continue;\n\t\t\tint d = c + incr;\n\t\t\tif (d) {\n\t\t\t\tndp[d-1] += dp[c];\n\t\t\t}\n\t\t\tif (d != cur-i) {\n\t\t\t\tndp[d] += dp[c];\n\t\t\t}\n\t\t}\n\t\tdp = std::move(ndp);\n\t}\n\tcout << dp[0] << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 3100;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nstring s, s0;\nint mn[MAXN];\nint mx[MAXN];\nint dp[MAXN][MAXN];\nint l[MAXN];\nint r[MAXN];\n\nvoid add(int &a, int b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint main() {\n\tcin >> n >> m;\n\tcin >> s;\n\tfor (int i = 0; i < m; ++i)\n\t\tcin >> l[i] >> r[i], --l[i];\n\ts0 = s;\n\tfor (int i = 0; i < m; ++i)\n\t\tsort(s0.begin() + l[i], s0.begin() + r[i]);\n\tint now = 0;\n\tmn[0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnow += (s0[i] == '1' ? 1 : 0);\n\t\tmn[i + 1] = now;\n\t}\n\ts0 = s;\n\tfor (int i = 0; i < m; ++i) {\n\t\tsort(s0.begin() + l[i], s0.begin() + r[i]);\n\t\treverse(s0.begin() + l[i], s0.begin() + r[i]);\n\t}\n\tnow = 0;\n\tmx[0] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tnow += (s0[i] == '1' ? 1 : 0);\n\t\tmx[i + 1] = now;\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = mn[i]; j <= mx[i]; ++j) {\n\t\t\tif (j >= mn[i + 1] && j <= mx[i + 1])\n\t\t\t\tadd(dp[i + 1][j], dp[i][j]);\n\t\t\tif (j + 1 >= mn[i + 1] && j + 1 <= mx[i + 1])\n\t\t\t\tadd(dp[i + 1][j + 1], dp[i][j]);\n\t\t}\n\t}\n\tcout << dp[n][mn[n]] << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <numeric>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconst int M = 1000000007;\n\nint main() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n#if 1\n    int cnt[n+1];\n    cnt[0] = 0;\n    for (int i = 0; i < n; i++) cnt[i+1] = cnt[i] + (s[i] == '0');\n    int R[n+1];\n    iota(R, R+n+1, 0);\n    for (int i = 0; i < m; i++) {\n        int l, r; cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++) R[i] = max(R[i], R[i-1]);\n    long long dp[2][n+1];\n    int cur = 0, prev = 1;\n    memset(dp, 0, sizeof dp);\n    dp[prev][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fill(dp[cur], dp[cur]+n, 0);\n        if (R[i] < i) continue;\n        const int s = cnt[R[i]] - cnt[R[i-1]];\n        // cerr << i << \" \" << s << endl;\n        for (int k = 0; k <= n && k+s-1 <= n; k++) {\n            if (0 <= k + s - 1) dp[cur][k+s-1] += dp[prev][k];\n            if (k + s < R[i] - i + 1) dp[cur][k+s] += dp[prev][k];\n        }\n        for (int k = 0; k <= n; k++) dp[cur][k] %= M;\n        swap(cur, prev);\n        // for (long long x : dp[prev]) cerr << x << \" \"; cerr << endl;\n    }\n    cout << dp[prev][0] << endl;\n#else\n    int l[m], r[m];\n    for (int i = 0; i < m; i++) cin >> l[i] >> r[i];\n    int ans = 0;\n    function<bool(int)> check = [&](int ss) {\n        int c0 = 0, c1 = 0, j = 0, R = 0;\n        for (int i = 0; i < n; i++) {\n            while (l[j] == i + 1) {\n                while (R < r[j]) {\n                    if (s[R] == '0') c0++; else c1++;\n                    R++;\n                }\n                j++;\n            }\n            while (R <= i) {\n                if (s[R] == '0') c0++; else c1++;\n                R++;\n            }\n            if ((ss >> i) & 1) {\n                if (c1 == 0) return false;\n                else c1--;\n            } else {\n                if (c0 == 0) return false;\n                else c0--;\n            }\n        }\n        return true;\n    };\n\n    for (int s = 0; s < 1<<n; s++) if (check(s)) ans++;\n    cout << ans << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 3000;\nconst int MaxM = 3000;\nconst int M = 1000000007;\n\nint n, m;\nchar s[MaxN + 3];\n\nint sum[MaxN + 1];\n\nint pos[MaxN + 1];\n\nint f[MaxN + 2][MaxN + 1];\n\ninline void add(int i, int j, int d)\n{\n\tf[i][j] = (f[i][j] + d) % M;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s + 1;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tsum[i] = s[i] - '0';\n\tfor (int i = 2; i <= n + 1; ++i)\n\t\tsum[i] += sum[i - 1];\n\n\tfor (int i = 1; i <= n + 1; ++i)\n\t\tpos[i] = i;\n\tfor (int i = 1; i <= m; ++i)\n\t{\n\t\tint l = getint();\n\t\tpos[l] = max(pos[l], getint());\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tpos[i] = max(pos[i], pos[i - 1]);\n\n\tf[1][sum[pos[1]]] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t{\n\t\t\tint cur = f[i][j];\n\t\t\tif (cur == 0)\n\t\t\t\tcontinue;\n\n\t\t\tint l = sum[pos[i + 1]] - sum[pos[i]];\n\t\t\tint k = pos[i] - i + 1 - j;\n\t\t\tif (k > 0)\n\t\t\t\tadd(i + 1, j + l - 0, cur);\n\t\t\tif (j > 0)\n\t\t\t\tadd(i + 1, j + l - 1, cur);\n\t\t}\n\n\tcout << f[n + 1][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll l[5000], r[5000];\nll cnk[3001][3001];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //freopen(\"input.in\", \"r\", stdin);\n    //freopen(\"output.out\", \"w\", stdout);\n    cin >> n >> m >> s;\n    s = \"#\" + s;\n    for (int i = 0; i < m; i++)\n    {\n        cin >> l[i] >> r[i];\n        if (i > 0 && l[i - 1] <= l[i] && r[i] <= r[i - 1])\n        {\n            i--;\n            m--;\n        }\n    }\n    cnk[0][0] = 1;\n    for (int i = 1; i <= 3000; i++)\n    {\n        cnk[i][0] = 1;\n        cnk[i][i] = 1;\n    }\n    for (int i = 1; i <= 3000; i++)\n    {\n        for (int j = 1; j < i; j++)\n        {\n            cnk[i][j] = cnk[i - 1][j] + cnk[i - 1][j - 1];\n            if (cnk[i][j] >= MOD)\n                cnk[i][j] -= MOD;\n        }\n    }\n    ll k = 0;\n    for (int i = l[0]; i <= r[0]; i++)\n    {\n        k += s[i] - '0';\n    }\n    cout << cnk[r[0] - l[0] + 1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int i = 0; i < n; i++ ){ cout << x[i] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n     \nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ ll x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\n\nint n, m;\nstring s;\n\nint sum[3010];\nint to[3010];\n\nMod dp[3010][3010];\n\nint main(){\n\n  n = in();\n  m = in();\n  s = stin();\n\n  sum[0] = 0;\n  REP( i , n ){\n    sum[i+1] = sum[i] + ( s[i] == '1' ? 1 : 0 );\n  }\n\n  // SHOWA( sum , n+1 );\n  \n  REP( i , n ){\n    to[i] = i + 1;\n  }\n  to[n] = n;\n  \n  REP( i , m ){\n    int l = in() - 1;\n    int r = in();\n    chmax( to[l] , r );\n  }\n\n  REP( i , n ){\n    chmax( to[i+1] , to[i] );\n  }\n\n  // SHOWA( to , n+1 );\n\n  dp[0][ sum[ to[0] ] ] = 1;\n\n  REP( i , n ){\n    REP( j , n+1 ){\n      int ne = j + sum[ to[i+1] ] - sum[ to[i] ];\n      \n      // one\n      if( j > 0 ){\n\tdp[i+1][ne-1] += dp[i][j];\n      }\n\n      // zero\n      if( to[i] - i - j > 0 ){\n\tdp[i+1][ne] += dp[i][j];\n      }\n    }\n  }\n\n  /*\n  REP( i , n+1 ){\n    REP( j , n+1 ){\n      cout << dp[i][j].n <<  \" \";\n    }\n    cout << endl;\n  }\n  */\n  \n  cout << dp[n][0].n << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nstring s;\nvector<pair<int, int> > vec;\nint r[3005];\nllint dp[3005][3005];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> s;\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tvec.push_back(make_pair(a, b));\n\t}\n\tfor(int i = 1; i < vec.size(); i++){\n\t\tif(vec[i].second <= vec[i-1].second){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(int i = 0; i < vec.size()-1; i++){\n\t\tif(vec[i].first == vec[i+1].first){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t}\n\t}\n\t\n\tint cur = 1, prev = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tfor(int j = cur; j < vec[i].first; j++) r[j] = max(j, prev);\n\t\tr[vec[i].first] = vec[i].second;\n\t\tcur = vec[i].first+1;\n\t\tprev = vec[i].second;\n\t}\n\tfor(int j = cur; j <= N; j++) r[j] = prev;\n\tr[N+1] = N;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tint Y = 0;\n\t\tfor(int j = r[i]+1; j <= r[i+1]; j++) if(s[j-1] == '1') Y++;\n\t\tfor(int j = 0; j <= N; j++){\n\t\t\tif(j < r[i]-i+1){\n\t\t\t\tdp[i+1][j+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j+Y] %= mod;\n\t\t\t}\n\t\t\tif(j > 0){\n\t\t\t\tdp[i+1][j-1+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j-1+Y] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << dp[N+1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp                  make_pair\n#define pb                  push_back\n#define f                   first\n#define s                   second\n#define F                   first\n#define S                   second\n#define clr(a, b)           memset(a, b, sizeof(a))\n#define fore(i, b, e)       for(ll i = b; i < e; i++)\n#define forr(i, b, e)       for(ll i = b; i < e; i++)\n#define forg(i, b, e,au)    for(ll i = b; i < e; i+=au)\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\nconst ll tam = 4000;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nint sum[tam],nxt[tam];\nint dp[tam][tam];\nvoid MODUL(int &num)\n{\n    while(num>=MOD)num-=MOD;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    string txt;\n    cin>>txt;\n    sum[0]=0;\n    forr(i,0,txt.size())\n    {\n        sum[i+1]=sum[i]+txt[i]-'0';\n    }\n    sum[n+1]=sum[n];\n    int iz,der;\n    forr(i,0,tam)\n        nxt[i]=i;\n    forr(i,0,m)\n    {\n        cin>>iz>>der;\n        forr(j,iz,der+1)\n        {\n            nxt[j]=max(nxt[j],der);\n        }\n    }\n    /*forr(i,1,n+1)\n    cout<<nxt[i]<<' ';\n    cout<<endl;*/\n    int cantini=sum[nxt[1]],R,newR,nuevo;\n    //cout<<cantini<<' ';\n    dp[1][cantini]=1;\n    int c0,c1;\n    forr(L,1,n+1)\n    {\n        R=nxt[L];\n        newR=nxt[L+1];\n        nuevo=sum[newR]-sum[R];\n        forr(c,0,n+1)\n        {\n            c0=R-L+1-c;\n            c1=c;\n            if (c0>0)\n                dp[L+1][c+nuevo]+=dp[L][c],MODUL(dp[L+1][c+nuevo]);\n            if (c1>0)\n                dp[L+1][c+nuevo-1]+=dp[L][c],MODUL(dp[L+1][c+nuevo-1]);\n        }\n    }\n    cout<<dp[n+1][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3010\n#define MOD 1000000007\n#define int ull\nint N,M;\nstring S;\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\nbool vis[maxn][maxn];\npi A[maxn];\nint fac[maxn];\nint dp[maxn][maxn];\nint ss[maxn];\n\nint qexp(int x, int y){  \n    int res = 1; \n  \n    x = x % MOD;\n  \n    while (y > 0){  \n        if (y & 1) res = (res*x) % MOD;  \n \n        y = y>>1; \n        x = (x*x) % MOD;  \n    }  \n    return res;  \n}  \n\ninline int modinv(int a,int b){\n\treturn (a * qexp(b,MOD-2)) % MOD;\n}\n\nint choose(ll n,ll k){\n\tif (n < k) return 0;\n\treturn modinv(modinv(fac[n],fac[k]),fac[n-k]);\n}\n\ninline int qry(pi i){\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint dpf(int i,int j){\n\tif (vis[i][j]) return dp[i][j];\n\tvis[i][j] = 1;\n\t\n\tif (i == M) return dp[i][j] = 1;\n\t\n\tdp[i][j] = 0;\n\t\n\tif (i == M-1){\n\t\tif (i == 0){\n\t\t\tdp[i][j] = choose(sz(A[i]),qry(A[i]));\n\t\t\treturn dp[i][j];\n\t\t}\n\t\tdp[i][j] = choose(sz(A[i]),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\treturn dp[i][j];\n\t}\n\t\n\tint mxsize;\n\tint sm;\n\tif (i > 0){\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(pi(A[i-1].s + 1,A[i].s)) + j);\n\t\tsm = qry(pi(A[i-1].s + 1,A[i].s)) + j;\n\t}else{\n\t\tmxsize = min(sz(inter(A[i],A[i+1])),qry(A[i]));\n\t\tsm = qry(A[i]);\n\t}\n\t\n\tFOR(k,0,mxsize){\n\t\tdp[i][j] += (dpf(i+1,k) * choose((ll)sz(A[i]) - (ll)sz(inter(A[i],A[i+1])),(ll)sm - (ll)k)) % MOD;\n\n\t\tdp[i][j] %= MOD;\n\t}\n\treturn dp[i][j];\n}\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\t\n\tDEC(i,M-1,0){\n\t\tA[i] = st.top();\n\t\tst.pop();\n\t}\n\t\n\tfac[0] = 1;\n\tFOR(i,1,N){\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t}\n\t\n\tS = 'a' + S;\n\t\n\tif (S[1] == '0') ss[1] = 0;\n\telse ss[1] = 1;\n\t\n\tFOR(i,2,S.size()){\n\t\tif (S[i] == '0') ss[i] = ss[i-1];\n\t\telse ss[i] = ss[i-1] + 1;\n\t}\n\t\n\n\t\t\t\n\tcout<<dpf(0,0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nconst lint mod = 1e9 + 7;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n  V<> a(n);\n  for (int i = 0; i < n; i++) a[i] = i + 1;\n  for (int i = 0; i < m; i++) {\n    int l, r; cin >> l >> r, l--;\n    for (int j = l; j < r; j++) a[j] = max(a[j], r);\n  }\n  V<> c(n + 1);\n  for (int i = 0; i < n; i++) c[i + 1] = c[i] + (s[i] == '1');\n  VV<lint> dp; assign(dp, n + 1, n + 1);\n  dp[1][0] = a[0] - c[a[0]] > 0;\n  dp[1][1] = c[a[0]] > 0;\n  for (int i = 1; i < n; i++) for (int j = 0; j < n + 1; j++) {\n    if ((a[i] - i) - (c[a[i]] - j) > 0) (dp[i + 1][j] += dp[i][j]) %= mod;\n    if (c[a[i]] - j > 0) (dp[i + 1][j + 1] += dp[i][j]) %= mod;\n  }\n  lint res = 0;\n  for (int j = 0; j < n + 1; j++) (res += dp[n][j]) %= mod;\n  cout << emod(res) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll ncr[3001][3001];\nconst int MOD = 1e9 + 7;\n\nll choose(int n, int r)\n{\n\tif(r==0) return 1;\n\tif(n<r) return 0;\n\tif(ncr[n][r]!=-1) return ncr[n][r];\n\tncr[n][r]=(choose(n-1,r-1)+choose(n-1,r))%MOD;\n\treturn ncr[n][r];\n}\n\nll dp[3001][3001];\nll modinv[3001];\nll fact[3001];\n\nll modpow(ll a, ll b)\n{\n\tll r = 1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=(r*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn r;\n}\n\nll inv(ll a)\n{\n\treturn modpow(a,MOD-2);\n}\n\nint pre[3001];\nint countone(int l, int r)\n{\n\tif(l==0) return pre[r];\n\treturn pre[r]-pre[l-1];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tmemset(ncr,-1,sizeof(ncr));\n\tfor(int i = 1; i <= 3000; i++) modinv[i] = inv(i);\n\tfact[0]=1;\n\tfor(int i = 1; i <= 3000; i++) fact[i]=(fact[i-1]*i)%MOD;\n\tint n, m; cin>>n>>m;\n\tstring s; cin >> s;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(s[i]=='1') pre[i]=1;\n\t\tif(i>0) pre[i]+=pre[i-1];\n\t}\n\tvector<ii> vec;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint l, r; cin>>l>>r;\n\t\tl--; r--;\n\t\tvec.pb(mp(l,r));\n\t}\t\n\tvector<ii> move;\n\tsort(vec.begin(),vec.end());\n\tint cur = -1;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tif(vec[i].se>cur)\n\t\t{\n\t\t\tmove.pb(vec[i]);\n\t\t\tcur=vec[i].se;\n\t\t}\n\t}\n\tmove.pb(mp(n,n));\n\tm = move.size();\n\t//dp[0][countone(move[0].fi,move[0].se)] = choose(move[0].se-move[0].fi+1, countone(move[0].fi,move[0].se));\n\tfor(int i = 0; i <= n; i++)\n\t{\n\t\tint l = move[0].fi;\n\t\tint mid = min(move[1].fi-1, move[0].se);\n\t\tint r = move[0].se;\n\t\tint cnt = countone(l,r);\n\t\t//i is [mid+1,r]\n\t\tif(i>cnt) break;\n\t\tdp[0][i] = choose(mid-l+1,cnt-i);\n\t\t//cerr<<0<<' '<<i<<' '<<dp[0][i]<<'\\n';\n\t}\n\tfor(int i = 1; i < m - 1; i++)\n\t{\n\t\tint l = move[i].fi;\n\t\tint mid = min(move[i+1].fi-1, move[i].se);\n\t\tint r = move[i].se;\n\t\tint cnt = countone(l,r);\n\t\tif(move[i].fi>move[i-1].se)\n\t\t{\n\t\t\tll an = 0;\n\t\t\tfor(int j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\tan=(an+dp[i-1][j])%MOD;\n\t\t\t}\n\t\t\tfor(int j = 0; j <= n; j++)\n\t\t\t{\n\t\t\t\tif(j>cnt) break;\n\t\t\t\tdp[i][j] = (an*choose(mid-l+1,cnt-j))%MOD;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt = countone(move[i-1].se+1,r);\n\t\t\t//this is the number of ones in the later part\n\t\t\t//Naive way\n\t\t\tll cur;\n\t\t\tfor(int x = 0; x <= r-mid; x++)\n\t\t\t{\n\t\t\t\tfor(int j = n; j >= max(0,x - cnt); j--)\n\t\t\t\t{\n\t\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int j = n; j >= max(0,r-mid - cnt); j--)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tdp[i][x] = (dp[i][x]+(dp[i-1][j]*choose(mid-l+1,j+cnt-x))%MOD)%MOD;\n\t\t\t}\n\t\t\tfor(int x = r-mid; x >= 0; x--)\n\t\t\t{\n\t\t\t\t\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tfor(int j = 0; j <= n; j++)\n\t\t{\n\t\t\tcerr<<i<<' '<<j<<' '<<dp[i][j]<<'\\n';\n\t\t}\n\t\t*/\n\t}\n\tll ans = dp[m-2][0];\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAXN=3000;\nconst int MOD=1e9+7;\nvoid A(int& a,int b){a+=b;if(a>=MOD)a-=MOD;}\nint n,m,r[MAXN+10],f[MAXN+10][MAXN+10],sm[MAXN+10];\nchar s[MAXN+10];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=1;i<=n;++i)sm[i]=sm[i-1]+s[i]-'0',r[i]=i;\n\tfor(int i=1,a,b;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tr[a]=max(r[a],b);\n\t}\n\tfor(int i=1;i<=n;++i)r[i]=max(r[i],r[i-1]);\n\tf[1][sm[r[1]]]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tif(f[i][j]==0)continue;\n\t\t\tint k=sm[r[i+1]]-sm[r[i]];\n\t\t\tif((r[i]>i||s[i]=='0')&&j<r[i]-i+1&&j+k<=r[i+1]-i)A(f[i+1][j+k],f[i][j]);\n\t\t\tif((r[i]>i||s[i]=='1')&&j>0&&j+k-1<=r[i+1]-i)A(f[i+1][j+k-1],f[i][j]);\n\t\t}\n\t}\n\tint ans=0;A(ans,f[n][0]);A(ans,f[n][1]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n\ntemplate <unsigned int Modulus>\nclass IntMod {\n\ttypedef unsigned long long ULL;\nprivate:\n\tunsigned int value_m;\n\n\tvoid Copy(const IntMod& other) { value_m = other.value_m; }\n\tbool Modulus_is_valid() { return Modulus != 0; }\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(unsigned int value) { value_m = value % Modulus; }\n\tIntMod(unsigned long long value) { value_m = value % Modulus; }\n\tIntMod(int value) {\n\t\tif (Modulus >= 0x80000000UL) {\n\t\t\tvalue_m = value >= 0 ? (unsigned int)value % Modulus : Modulus - (unsigned int)(-value);\n\t\t} else {\n\t\t\tint tmp = value % (int)Modulus;\n\t\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t\t}\n\t}\n\tIntMod(const IntMod& other) { Copy(other); }\n\tIntMod& operator=(const IntMod& other) { Copy(other); return *this; }\n\tbool operator==(const IntMod& right) const { return value_m == right.value_m; }\n\tbool operator!=(const IntMod& right) const { return value_m != right.value_m; }\n\tIntMod& operator++() {\n\t\t++value_m; \n\t\tvalue_m %= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) { value_m = Modulus - 1; }\n\t\telse { --value_m; }\n\t\treturn *this;\n\t}\n\tIntMod operator-() const {\n\t\tif (value_m == 0) return IntMod(0);\n\t\treturn IntMod(Modulus - value_m);\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tULL sum = (ULL)value_m + right.value_m;\n\t\tif (sum >= (ULL)Modulus) { value_m = (unsigned int)(sum - (ULL)Modulus); }\n\t\telse { value_m = (unsigned int)sum; }\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\t(*this) += (-right);\n\t\treturn *this;\n\t}\n\tIntMod operator+(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret += right;\n\t\treturn ret;\n\t}\n\tIntMod operator-(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret -= right;\n\t\treturn ret;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tULL tmp = (ULL)value_m * right.value_m;\n\t\tvalue_m = tmp % (ULL)Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\tIntMod operator*(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret *= right;\n\t\treturn ret;\n\t}\n\tIntMod operator/(const IntMod& right) const {\n\t\tIntMod ret(*this);\n\t\tret /= right;\n\t\treturn ret;\n\t}\n\t/* 素数判定は自分でしろ */\n\tIntMod Inverse() const {\n\t\treturn (*this).Pow(Modulus - 2);\n\t}\n\tIntMod Pow(unsigned int exp) const {\n\t\tunsigned int arr[32];\t\t// 32じゃなくてもいい\n\t\tULL sum = 1;\n\t\tarr[0] = value_m;\n\t\tfor (int i = 1; i < 32; ++i) {\n\t\t\tarr[i] = ((ULL)arr[i - 1] * arr[i - 1]) % (ULL)Modulus;\n\t\t}\n\t\tfor (int i = 0; i < 32; ++i) {\n\t\t\tif (exp & (0x1 << i)) {\n\t\t\t\tsum *= arr[i]; sum %= (ULL)Modulus;\n\t\t\t}\n\t\t}\n\t\treturn (unsigned int)sum;\n\t}\n\tIntMod Fact() const {\n\t\tstatic std::vector<IntMod> table;\n\t\tint factoriand = Get_value();\n\t\tif (table.size() > factoriand) {\n\t\t\treturn table[factoriand];\n\t\t}\n\n\t\tint old_size = table.size();\n\t\ttable.resize(factoriand + 1);\n\t\tfor (int i = old_size; i <= factoriand; i++) {\n\t\t\ttable[i] = (i == 0 ? 1 : table[i - 1] * i);\n\t\t}\n\t\treturn table[factoriand];\n\t}\n\tunsigned int Get_value() const {\n\t\treturn value_m;\n\t}\n};\n\n#endif\n//#include \"IntMod.h\"\ntypedef IntMod<1000000007> MInt;\n\n//#include \"Union_Find.h\"\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nPP P[3000];\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nMInt DP[3001][3001];\nMInt SUM[3001][3001];\n\nMInt C(int n, int r) {\n\tif (n < 0 || r < 0 || n - r < 0) return 0;\n\treturn MInt(n).Fact() / (MInt(r).Fact() * MInt(n - r).Fact());\n}\n\nint main() {\n\t/* さすがに無理か？ */\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t}\n\t}\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N + 1, O[i - 1] + 1)) {\n\t\t\tREP(k, 0, j + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tll ans = dp[zero][one];\n\tif(ans > mod){\n\t\tassert(1 == 0);\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing lli = long long int;\nusing pii = pair<int,int>;\n\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\n\nint n,m;\nchar s[maxn],t[maxn];\nint f[maxn][maxn]={};\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(nullptr);\n    //freopen(\"t.inp\",\"r\",stdin);freopen(\"t.out\",\"w\",stdout);\n    cin>>n>>m>>(s+1);\n    strcpy(t+1,s+1);\n    for(int i=1,u,v;i<=m;i++){\n        cin>>u>>v;\n        sort(s+u,s+v+1);\n        sort(t+u,t+v+1,greater<char>());\n    }\n    int cnt[2]={};\n    f[0][0]=1;\n    for(int i=1;i<=n;i++){\n        cnt[0]+=(s[i]=='1');\n        cnt[1]+=(t[i]=='1');\n        for(int j=cnt[0];j<=cnt[1];j++){\n            f[i][j]=f[i-1][j];\n            if (j) f[i][j]+=f[i-1][j-1];\n            if (f[i][j]>=mod) f[i][j]-=mod;\n        }\n    }\n    int res=0;\n    for(int j=cnt[0];j<=cnt[1];j++){\n        res+=f[n][j];\n        if (res>=mod) res-=mod;\n    }\n    cout<<res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cassert>\n#include<utility>\n#define llong long long\n#define pii pair<int,int>\n#define mkpr make_pair\nusing namespace std;\n\nconst int N = 3e3;\nconst int P = 1e9+7;\nstruct Interval\n{\n\tint l,r;\n} b[N+3],bb[N+3];\nchar a[N+3];\nint s[N+3];\nbool f[N+3];\nllong dp[N+3][N+3];\nllong fact[N+3],finv[N+3];\nint n,m,mm;\nllong ans;\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong mulinv(llong x) {return quickpow(x,P-2);}\nllong comb(llong x,llong y) {return fact[x]*finv[y]%P*finv[x-y]%P;}\n\nint main()\n{\n\tfact[0] = 1ll; for(int i=1; i<=N; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N] = quickpow(fact[N],P-2); for(int i=N-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1); for(int i=1; i<=n; i++) a[i] -= 48;\n\tfor(int i=1; i<=n; i++) s[i] = s[i-1]+a[i];\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tscanf(\"%d%d\",&b[i].l,&b[i].r);\n\t}\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tfor(int j=1; j<=m; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(b[i].l<=b[j].l && b[i].r>=b[j].r) {f[j] = true;}\n\t\t}\n\t}\n\tfor(int i=1; i<=m; i++) {if(f[i]==false) {bb[++mm] = b[i];}}\n\tfor(int i=1; i<=mm; i++) b[i] = bb[i]; m = mm;\n//\tprintf(\"m=%d: \",m); for(int i=1; i<=m; i++) printf(\"(%d,%d) \",b[i].l,b[i].r); puts(\"\");\n\tans = 1ll;\n\tb[m+1].l = n+1; b[m+1].r = n+1;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(b[i+1].l>b[i].r && b[i].l>b[i-1].r)\n\t\t{\n\t\t\tllong tmp = comb(b[i].r-b[i].l+1,s[b[i].r]-s[b[i].l-1]);\n//\t\t\tprintf(\"Case1 %d\\n\",i);\n\t\t\tans = ans*tmp%P;\n\t\t}\n\t\telse if(b[i+1].l>b[i].r)\n\t\t{\n\t\t\tllong cur = 0ll;\n\t\t\tfor(int j=0; j<=b[i-1].r-b[i].l+1; j++)\n\t\t\t{\n\t\t\t\tllong tmp = comb(b[i].r-b[i].l+1,s[b[i].r]-s[b[i-1].r]+j)*dp[i-1][j]%P;\n\t\t\t\tcur = (cur+tmp)%P;\n\t\t\t}\n//\t\t\tprintf(\"Case2 %d\\n\",i);\n\t\t\tans = ans*cur%P;\n\t\t}\n\t\telse if(b[i].l>b[i-1].r)\n\t\t{\n\t\t\tfor(int j=0; j<=b[i].r-b[i+1].l+1; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = comb(b[i+1].l-b[i].l,s[b[i].r]-s[b[i].l-1]-j)%P;\n//\t\t\t\tprintf(\"dp[%d][%d]=%lld\\n\",i,j,dp[i][j]);\n\t\t\t}\n//\t\t\tprintf(\"Case3 %d\\n\",i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int j=0; j<=b[i-1].r-b[i].l+1; j++)\n\t\t\t{\n\t\t\t\tint cnt1 = j+s[b[i].r]-s[b[i-1].r];\n\t\t\t\tfor(int k=0; k<=b[i+1].l-b[i].l && k<=cnt1; k++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][cnt1-k] = (dp[i][cnt1-k]+comb(b[i+1].l-b[i].l,k)*dp[i-1][j])%P;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int k=0; k<=b[i].r-b[i+1].l+1; k++) printf(\"dp[%d][%d]=%lld\\n\",i,k,dp[i][k]);\n//\t\t\tprintf(\"Case4 %d\\n\",i);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=3005,mo=1e9+7;\nint n,m,i,j,sum[N],r[N],f[N][N];char s[N];\nvoid add(int &x,int k){x=(x+k)%mo;}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);s[n+1]='0';\n\tfor (i=1;i<=n+1;i++)\n\t\tr[i]=i,sum[i]=sum[i-1]+s[i]-48;\n\tfor (;m--;){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tif (y>r[x]) r[x]=y;\n\t}\n\tfor (i=2;i<=n+1;i++)\n\t\tif (r[i-1]>r[i]) r[i]=r[i-1];\n\tf[1][sum[r[1]]]=1;\n\tfor (i=1;i<=n;i++) for (j=0;j<=n;j++) if (f[i][j]){\n\t\tint k=sum[r[i+1]]-sum[r[i]];\n\t\tif (r[i]-i+1-j) add(f[i+1][j+k],f[i][j]);\n\t\tif (j) add(f[i+1][j+k-1],f[i][j]);\n\t}\n\tprintf(\"%d\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n//region Template\n#include \"ext/pb_ds/assoc_container.hpp\"\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n\nconst int MOD = 1000000007;\n\nusing namespace std;\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_multiset;\n\n#define finish(x) cout << x; exit(0);\n#define fastIO cin.tie(0); cin.sync_with_stdio(false);\n\nvoid setIn(string s) { freopen(s.c_str(), \"r\", stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\n//const string USCAO_TAG = \"mountains\";\nvoid usaco(const string& USACO_TAG) { setIn(USACO_TAG + \".in\"); setOut(USACO_TAG + \".out\"); }\n/*\ntemplate<typename... Args>\nvoid print(Args... args) {\n\t#ifdef LOCAL\n\t((std::cout << args << \" \"), ...);\n\tcout << endl;\n\t#endif\n}\n */\n//endregion\n\n/* Notes:\n * Farah </3\n */\n\nconst int MAXN = 2e3 + 6;\nstring s;\nint r[MAXN];\nint p[MAXN];\nint n, m;\n\nll dp[MAXN][MAXN];\n\nint ones(int l, int r){\n\treturn p[r] - p[l - 1];\n}\n\nll solve(int l, int c){\n\tif(l == n && c <= 1){\n\t\treturn dp[l][c] = 1;\n\t}\n\n\tif(dp[l][c] != 0) return dp[l][c];\n\n\tint nc = c + ones(r[l] + 1, r[l + 1]);\n\tint len = r[l] - l + 1;\n\tif(len > c) {\n\t\tdp[l][c] += solve(l + 1, nc);\n\t}\n\tif(c > 0) dp[l][c] += solve(l + 1, nc - 1);\n\n\treturn dp[l][c] % MOD;\n}\n\nint main() {\n\t#ifdef LOCAL\n\tsetIn(\"in.txt\");\n\tsetOut(\"out.txt\");\n\t#endif\n\n\tcin >> n >> m;\n\n\tcin >> s;\n\ts = \"#\" + s;\n\n\tp[1] = (s[1] == '1');\n\tfor(int i = 2; i <= n; i++){\n\t\tp[i] = p[i - 1] + (s[i] == '1');\n\t}\n\n\tfor(int i = 1; i <= n; i++){\n\t\tr[i] = i;\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t\tint l, x;\n\t\tcin >> l >> x;\n\n\t\tr[l] = max(r[l], x);\n\t}\n\n\tfor(int i = 2; i <= n; i++){\n\t\tr[i] = max(r[i], r[i - 1]);\n\t}\n\n\tmemset(dp, 0, sizeof dp);\n\tcout << solve(1, ones(1, r[1]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nclass comb{\nprivate:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \npublic:\n    comb(ll mod=1000000007,ll mx=100000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<k){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\ncomb C;\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    vector<ll> cnt(n+1,0);\n    for(int i=0;i<n;i++){cnt[i+1]+=(s[i]=='1'?1:0); cnt[i+1]+=cnt[i];}\n    vector<pll> A;\n    for(int i=0;i<m;i++){\n        ll l,r;\n        cin>>l>>r;\n        if(A.empty() || r>A.back().S){A.push_back({l,r});}\n    }\n    vector<ll> dp(n+1,0);\n    vector<ll> next(n+1,0);\n    dp[0]=1;\n    ll l=0;\n    for(int i=0;i<A.size();i++){\n        l=max(l,A[i].F-1);\n        for(ll t=n;t>=0;t--){\n            if(t+cnt[A[i].S]-cnt[l]<=n){dp[t+cnt[A[i].S]-cnt[l]]=dp[t];}\n        }\n        for(ll t=n;t>=0;t--){\n            if(cnt[A[i].S]-cnt[l]>t){dp[t]=0;}\n        }\n        //for(auto &I:dp){cout<<I<<\" \";}\n        //cout<<endl;\n        for(auto &I:next){I=0;}\n        ll d=A[i].S-A[i].F+1;\n        ll s=A[i].S-A[i].F+1;\n        if(i+1<A.size() && A[i+1].F<=A[i].S){d=A[i+1].F-A[i].F;}\n        s-=d;\n        l=A[i].S;\n        for(int t=0;t<=n;t++){\n            if(t>s){continue;}\n            for(int j=0;j<=d && t+j<=n;j++){\n                next[t]+=dp[t+j]*C.c(d,j)%MOD; next[t]%=MOD;\n            }\n        }\n        dp=next;\n    }\n    ll ans=0;\n    for(auto &I:dp){ans+=I; ans%=MOD;}\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<algorithm>\n#include<functional>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int INF = -1 << 30;\n\nint main() {\n    int n, m;\n    string s;\n    cin >> n >> m >> s;\n    string r(s);\n    for (int i=0, x, y; i<m; i++) {\n        cin >> x >> y;\n        sort(s.begin() + x - 1, s.begin() + y, less<char>());\n        sort(r.begin() + x - 1, r.begin() + y, greater<char>());\n    }\n    int pmin[n + 1] = { 0 }, pmax[n + 1] = { 0 };\n    for (int i=1; i<=n; i++) {\n        pmin[i] = pmin[i - 1] + (s[i - 1] == '1');\n        pmax[i] = pmax[i - 1] + (r[i - 1] == '1');\n    }\n    int dp[n + 1][n + 1]; // dp[character][# of 1s]\n    dp[0][0] = 1;\n    fill(*dp + 1, *dp + n + 1, 0);\n    int ones = count(s.begin(), s.end(), '1');\n    for (int i=1; i<=n; i++) {\n        for (int j=0; j<=ones; j++) {\n            dp[i][j] = (pmin[i] <= j and j <= pmax[i])\n                     ? (dp[i - 1][j] + \n                             (j ? dp[i - 1][j - 1] : 0)\n                       ) % MOD : 0;\n        }\n    }\n    cout << dp[n][ones] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\n#define pb push_back\n#define mod 1000000007\n#define Mad(a,b) a=(a+b)%mod;\n#define X first\n#define Y second\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\n#define N 3010\nll n,m;\nstring s;\nvector<P>v;\nll dp[N][N];\nint main(){\n cin>>n>>m>>s;\n v.pb(mp(0,0));\n lol(i,m){\n  ll a,b;cin>>a>>b;a--,b--;\n  if(v[v.size()-1].Y<b){\n   v.pb(mp(a,b));   \n  }\n }\n v.pb(mp(n,n));\n lol(i,N)lol(j,N)dp[i][j]=0;dp[0][0]=1;\n ll pnt=0;\n lol(i,n){\n     ll cnt=0;\n     while(i==v[pnt+1].X){\n         for(ll j=v[pnt].Y+1;j<=v[pnt+1].Y;j++)cnt+=s[j]=='0';\n         pnt++;\n     }\n     lol(j,v[pnt+1].X-i+2){\n        if(j<=v[pnt+1].X-i)Mad(dp[i+1][j+cnt],dp[i][j]);\n        if(j)Mad(dp[i+1][j+cnt-1],dp[i][j]);\n     }\n }\n ll sum=0;\n lol(i,N)sum+=dp[n][i];\n cout<<sum%mod<<endl;\n \n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt b = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= b;\n            exp >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    string S; cin >> S;\n    vector<int> L(M),R(M);\n    rep(i,M) {\n        cin >> L[i] >> R[i];\n        --L[i]; --R[i];\n    }\n    vector<int> cnt(N+1);\n    rep(i,N) {\n        if (S[i]=='0') cnt[i+1] = 1;\n        cnt[i+1] += cnt[i];\n    }\n\n    int r = 0;\n    int cur = 0;\n    vector<vector<mint>> dp(N+1, vector<mint>(N+1));\n    dp[0][0] = 1;\n    rep(i,N) {\n        while (cur < M and L[cur]==i) {\n            chmax(r,R[cur]);\n            cur++;\n        }\n        rep(j,N+1) {\n            if (i+1-j <= r+1-cnt[r+1]) dp[i+1][j] += dp[i][j];\n            if (j <= cnt[r+1] and j) dp[i+1][j] += dp[i][j-1];\n        }\n        if (r==i) r++;\n    }\n\n    cout << dp[N][cnt[N]].a << ln;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt((uint64_t)num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) {\n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MOD 998244353\nusing namespace std;\nconst int MAXN = 3005;\nint f[MAXN][MAXN],n,m,r[MAXN];\nint sum[MAXN];\nchar s[MAXN];\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;++i)r[i]=i,sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tfor(int i=1;i<=n;++i)r[i]=max(r[i],r[i-1]);\n\tf[1][sum[r[1]]]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(!f[i][j])continue;\n\t\t\tint baseline=sum[r[i+1]]-sum[r[i]];\n\t\t\tif(j<r[i]-i+1)add(f[i+1][baseline+j],f[i][j]);\n\t\t\tif(j>=1)add(f[i+1][baseline+j-1],f[i][j]);\n\t\t}\n\t}\n\tcout<<(f[n][0]+f[n][1])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000007\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,q; string s;\nvector<P>vec;\nll dp[3005][3005],C[3005][3005];\nint main(){\n    C[0][0]=1;\n    for(int i=1;i<3005;i++)for(int j=0;j<=i;j++){\n        if(j==0||j==i)C[i][j]=1LL;\n        else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    }//cout<<C[3000][1500]<<endl;\n\tcin>>n>>q>>s;\n\trep(i,q){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tif(vec.empty() || vec[vec.size()-1].sc<b){\n\t\t\tif(!vec.empty() && vec[vec.size()-1].fi == a){\n\t\t\t\tvec.pop_back();\n\t\t\t}\n\t\t\tvec.pb(mp(a,b));//cout<<vec[vec.size()-1].fi<<vec[vec.size()-1].sc<<endl;\n\t\t}\n\t}\n\tdp[0][0] =1LL;\n\tint sum = 0,nxt2 = 0;\n\tint S=0,T=0;\n\trep(i,vec.size()){\n\t\tint nxt = (i==vec.size()-1?vec[i].sc+1:min(vec[i].sc+1,vec[i+1].fi));\n\t\t//[vec[i].fi,nxt) wo kettei\n\t\tfor(int ii=max(nxt2,vec[i].fi);ii<vec[i].sc+1;ii++){\n\t\t\tif(s[ii]=='0')S++;else T++;\n\t\t}//cout<<S<<T;\n\t\tfor(int ii=0;ii<=sum;ii++){\n\t\t\tif(dp[ii][sum-ii]==0LL)continue;//cout<<ii;\n\t\t\tint zan = S-ii,zan2 = T-(sum-ii); \n\t\t\tfor(int x=0;x<=nxt-vec[i].fi;x++){\n\t\t\t\tif(x>zan||(nxt-vec[i].fi-x)>zan2) continue;//cout<<x;\n\t\t\t\tdp[ii+x][sum-ii+(nxt-vec[i].fi-x)] += dp[ii][sum-ii]*C[nxt-vec[i].fi][x]%mod;\n\t\t\t\twhile(dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]>=mod) dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]-=mod;\n\t\t\t}\n\t\t}\n\t\tsum += nxt-vec[i].fi; nxt2 = vec[i].sc+1;//cout<<S<<T<<dp[S][T];\n\t}\n\tll ret = 0;\n\trep(i,S+T+1) ret=(ret+dp[i][S+T-i])%mod; cout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\nlli n,m;\nstring s;\nvector<lli> sum;\nvector<lli> rightend;\nvector<vector<lli> > dp;\nint main(){\n    cin >> n >> m;\n    cin >> s;\n    sum = vector<lli> (n+1);\n    rightend = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++){\n        rightend[i] = i;\n    }\n    for(lli i = 0;i < n;i++){\n        sum[i+1] = sum[i] + (s[i] - '0');\n    }\n    for(lli i = 0;i < m;i++){\n        lli l,r;\n        cin >> l >> r;\n        for(lli j = l,j <= r;j++) rightend[j] = max(rightend[j],r);\n    }\n    dp = vector<vector<lli> > (n+1,vector<lli> (n+1));\n    dp[0][0] = 1;\n    for(lli i = 0;i < n;i++){\n        lli b,e;\n        b = max(0,i - (rightend[i] - sum[rightend[i]]));\n        e = min(i,sum[rightend[i]]);\n        for(lli j = b;j <= e;j++){\n            dp[i+1][j] += dp[i][j];dp[i+1][j] %= 1000000007;\n            dp[i+1][j+1] += dp[i][j];dp[i+1][j] %= 1000000007;\n        }\n    }\n    cout < dp[n][sum[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n\ndouble pi = 3.141592653689793238;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n    \nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\n\nclass UnionFind {\nprivate:\n    vector<int> par;\npublic:\n    UnionFind(){}\n    UnionFind(int N) { par = vector<int>(N, -1); }\n    int find(int x);\n    ll size(int x);\n    void unite(int x, int y);\n    bool same(int x, int y);\n};\n \nint UnionFind::find(int x) {\n    if (par[x] < 0) return x;\n    else return par[x] = find(par[x]);\n}\n \nll UnionFind::size(int x) {\n    return -par[find(x)];\n}\n \nvoid UnionFind::unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    //大きい方に小さい方をくっ付ける\n    if (size(x) < size(y)) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n}\n \nbool UnionFind::same(int x, int y) {\n    x = find(x);\n    y = find(y);\n    return x == y;\n}\n\nint dp[3005][3005];\n\nvoid solve() {\n    int n, m; cin >> n >> m;\n    string s; cin >> s;\n    vector<pair<int, int>> lr(m);\n    vector<int> L(n), R(n);\n    rep (i, m) {\n        cin >> lr[i].first >> lr[i].second;\n        lr[i].first--, lr[i].second--;\n    }\n    rep (i, n) {\n        int migi = i, hidari = i;\n        rep (j, m) {\n            if (lr[j].first <= migi && migi <= lr[j].second) chmax(migi, lr[j].second);\n            if (lr[j].second >= i) chmin(hidari, lr[j].first);\n        }\n        L[i] = hidari, R[i] = migi;\n    }\n    vector<int> cnt[2];\n    rep (i, 2) cnt[i] = vector<int>(n);\n    rep (i, n) {\n        FOR (j, L[i], R[i] + 1) {\n            cnt[s[i] == '1'][j]++;\n        }\n    }\n    int memo[2]; rep (i, 2) memo[i] = 0;\n    int pos = -1;\n    dp[0][0] = 1;\n    queue<pair<int, int>> q;\n    rep (i, n) {\n        if (pos != n - 1) while (L[++pos] <= i) q.push({pos, s[pos] == '1'});\n        while (R[q.front().first] < i) {\n            memo[q.front().second]++; q.pop();\n        }\n        rep (j, i + 1) {\n            if (cnt[1][i] - (i - j) + memo[1] > 0) dp[j][i-j+1] += dp[j][i-j];\n            if (cnt[0][i] - (j) + memo[0] > 0) dp[j+1][i-j] += dp[j][i-j];\n            dp[j][i-j+1] %= mod, dp[j+1][i-j] %= mod;\n        }\n    }\n    // rep (i, 4) {\n    //     rep (j, 3) {\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // rep (i, n) cout << cnt[0][i] << \" \"; cout << endl;\n    // rep (i, n) cout << cnt[1][i] << \" \"; cout << endl;\n    int ans = 0;\n    rep (i, n + 1) {\n        ans += dp[i][n-i];\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return;\n}\n \nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nconst int mo=1e9+7;\nint n,m,len,a[N],l[N],r[N],L[N],R[N],f[N],g[N],C[N][N],vis[N],ans;\nint main()\n{\n\tint i,j,k;\n\tscanf(\"%d %d\\n\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=a[i-1]+getchar()-'0';\n\tfor(i=0;i<=n;i++){\n\t\tC[i][0]=C[i][i]=1;\n\t\tfor(j=1;j<i;j++)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t  }\n\tf[0]=1;\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d %d\",&L[i],&R[i]);\n\tfor(i=1;i<=m;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t\tif(L[i]>=L[j]&&R[i]<=R[j]&&j!=i){ vis[i]=1; break;}\n\tfor(i=1;i<=m;i++)\n\t\tif(!vis[i])\n\t\t\t++len,l[len]=L[i],r[len]=R[i];\n\tl[0]=1,m=len;\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<=n;j++) g[j]=f[j],f[j]=0;\n\t\tfor(j=0;j<=r[i]-l[i]+1;j++)\n\t\t\tif(r[i]<l[i+1])\n\t\t\t\tf[a[r[i+1]]-a[l[i+1]-1]]=(f[a[r[i+1]]-a[l[i+1]-1]]+1LL*g[j]*C[r[i]-l[i]+1][j])%mo;\n\t\t\telse{\n\t\t\t\tfor(k=max(j-r[i]+l[i+1]-1,0);k<=j&&k<=l[i+1]-l[i];k++)\n\t\t\t\t\tf[j+a[r[i+1]]-a[r[i]]-k]=(f[j+a[r[i+1]]-a[r[i]]-k]+1LL*g[j]*C[l[i+1]-l[i]][k])%mo;\n\t\t\t  }\n\t  }\n\tfor(i=0;i<=r[m]-l[m]+1;i++)\n\t\tans=(ans+1LL*f[i]*C[r[m]-l[m]+1][i])%mo;\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tfor(int i=1;i<=m;++i)\n\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j))%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 4007;\nconst int K = 5000;\nint used[N][N], dp[N][N], n, ps[N], r[N], a[N];\nint solve(int i, int p, int s){\n    if (s < 0) return 0;\n    if (s > p - i + 1) return 0;\n    if (used[i][s]) return dp[i][s];\n    if (i == n) return 1;\n    int s0 = s;\n    used[i][s] = 1;\n    if (r[i] > p){\n        s += ps[r[i]] - ps[p];\n        p = r[i];\n    }\n    return dp[i][s0] = (solve(i + 1, p, s - 1) + solve(i + 1, p, s)) % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    for (int i = 1; i <= n; i++) r[i] = i;\n    for (int i = 1; i <= m; i++){\n        int x, y;\n        cin >> x >> y;\n        r[x] = max(y, r[x]);\n    }\n    for (int i = 0; i < n; i++){\n        a[i + 1] = s[i] - '0';\n        ps[i + 1] = ps[i] + a[i + 1];\n    }\n    cout << solve(1, 1, a[1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=1000000007;\nusing P=pair<ll,ll>;\nll sum1[3005];ll sum2[3005];\nll N,M;\nstring s;\nll dp[3005][3005];\nint main(){\n  cin>>N>>M>>s;\n  vector<ll>A(N);\n  for(ll i=0;i<N;i++)\n    A[i]=s[i]-'0';\n  vector<P>C(M);\n  for(int i=0;i<M;i++){\n  ll l,r;cin>>l>>r;P p(l,r);\n    C[i]=p;\n  }vector<ll>A1(N);vector<ll>A2(N);\n  for(ll i=0;i<N;i++){A1[i]=A[i];A2[i]=A[i];}\n  for(ll i=0;i<M;i++){\n    ll l=C[i].first;ll r=C[i].second;\n  sort(A1.begin()+l-1,A1.begin()+r);\n     sort(A2.begin()+l-1,A2.begin()+r);\n    reverse(A2.begin()+l-1,A2.begin()+r);\n    }for(ll i=1;i<=N;i++){\n  sum1[i]=sum1[i-1]+A1[i-1];\n    sum2[i]=sum2[i-1]+A2[i-1];\n  }dp[0][0]=1;\n  for(ll i=1;i<=N;i++)\n    for(ll j=sum1[i];j<=sum2[i];j++){\n      dp[i][j]=dp[i-1][j];\n      if(0<=j-1)\n        dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n    }cout<<dp[N][sum1[N]]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=4000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])];k++)\n\t\t\t{\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=0;\n    for (int i=0;i<=n;i++) ans=(ans+f[tot-1][i])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tban[i][j] = false;\n\t\t\tdp[i][j] = 0;\n\t\t}\n\t}\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\t//assert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\ttable.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\tassert(problemid == 0);\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\nll R[5000];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = i;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = max(R[i], R[i - 1]);\n        cout << R[i] << endl;\n    }\n    dp[1][summ(1, R[1])] = 1;\n    for (int p = 1; p <= n; p++)\n    {\n        if (p > 1 && R[p] > R[p - 1])\n        {\n            for (int j = n; j >= summ(R[p - 1] + 1, R[p]); j--)\n            {\n                dp[p][j] = dp[p][j - summ(R[p - 1] + 1, R[p])];\n                dp[p][j - summ(R[p - 1] + 1, R[p])] = 0;\n            }\n        }\n        for (int c = 0; c <= n; c++)\n        {\n            dp[p + 1][c] = (dp[p][c] + dp[p][c + 1]) % MOD;\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= n; j++)\n        {\n            ;//cout << dp[i][j] << \" \";\n        }\n        ;//cout << endl;\n    }\n    cout << (dp[n][0] + dp[n][1]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nint l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return (x*x)%MOD;\n}\nint modpow(ll x,ll y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return (pow(modpow(x,y/2))*x)%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=(ret*(x-i)*inv(i+1))%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        int le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max(0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3005,M=1e9+7;\nint n,m,x,y,f[N],a[N],r[N];\nchar s[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;i++)r[i]=i,a[i]=a[i-1]+(s[i]=='1');\n\twhile (m--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tf[0]=1;\n\tfor (int i=1,R=0;i<=n;i++){\n\t\tR=r[i]>R?r[i]:R;\n\t\tfor (int j=a[R]<i?a[R]:i;j>=0;j--)\n\t\t\tif (j<a[R]-R+i)f[j]=0;\n\t\t\telse if (j)(f[j]+=f[j-1])%=M;\n\t}\n\tprintf(\"%d\\n\",f[a[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Mod=1e9+7;\nint n,m,fac[3010],inv[3010],f[3010][3010],g[3010][3010];\nstruct dsa {int l,r;}a[3010];\nchar S[3010];\nint ksm(int aa,int bb) \n{\n\tint an=1;\n\tfor (;bb;bb>>=1) {\n\t\tif (bb&1) an=1LL*an*aa%Mod;\n\t\taa=1LL*aa*aa%Mod;\n\t}\n\treturn an;\n}\nint C(int N,int M)\n{\n\tif (N<M||N<0||M<0) return 0;\n\treturn 1LL*fac[N]*inv[N-M]%Mod*inv[M]%Mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",S+1);\n\tfor (int i=1;i<=m;i++)\n  \t  scanf(\"%d%d\",&a[i].l,&a[i].r);\n\tint nu=0,mx=0;\n\tfor (int i=1;i<=m;i++) {\n\t\tif (mx>=a[i].r) continue;\n\t\ta[++nu].l=a[i].l;a[nu].r=a[i].r;\n\t\tmx=max(mx,a[i].r);\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tint s=0;\n  \t    for (int j=i;j<=n;j++) {\n\t\t    if (S[j]=='1') s++;\n\t\t\tg[i][j]=s;\n\t\t}\n\t}\n\tfac[0]=1;for (int i=1;i<=n;i++) fac[i]=1LL*fac[i-1]*i%Mod;\n\tinv[n]=ksm(fac[n],Mod-2);inv[0]=1;for (int i=n-1;i;i--) inv[i]=1LL*inv[i+1]*(i+1)%Mod;\n\tf[0][0]=1;a[nu+1].l=1e9;\n\tfor (int i=1;i<=nu;i++) \n\t  if (a[i].r<a[i+1].l) {\n\t  \t  if (a[i-1].r<a[i].l) f[i][0]+=1LL*f[i-1][0]*C(a[i].r-a[i].l+1,g[a[i].l][a[i].r])%Mod,f[i][0]%=Mod;\n\t\t\telse \n \t\t\t  for (int k=0;k<=a[i-1].r-a[i].l+1;k++)\n   \t\t\t  \tf[i][0]+=1LL*f[i-1][k]*C(a[i].r-a[i].l+1,k+g[a[i-1].r+1][a[i].r])%Mod,f[i][0]%=Mod;\n\t  }\n\t  else {\n\t\t  if (a[i-1].r<a[i].l)\n\t\t\tfor (int j=0;j<=g[a[i].l][a[i].r];j++) \n \t\t\t  f[i][j]+=1LL*f[i-1][0]*C(a[i+1].l-a[i].l,g[a[i].l][a[i].r]-j)%Mod,f[i][j]%=Mod;\n\t\t  else \n\t\t\tfor (int j=0;j<=a[i].r-a[i+1].l+1;j++)\t\t\t\t\n\t\t\t  for (int k=0;k<=a[i-1].r-a[i].l+1;k++)\n\t\t\t\tif (g[a[i-1].r+1][a[i].r]+k>=j) f[i][j]+=1LL*f[i-1][k]*C(a[i+1].l-a[i].l,g[a[i-1].r+1][a[i].r]+k-j)%Mod,f[i][j]%=Mod;\n\t  }\n\tcout<<f[nu][0];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 3010;\nll dp[N][N];\n\n\nconst int DEBUG = 0;\n\n\nint main(void){\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  VI que(n, 0);\n  REP(i, 0, n) {\n    que[i] = i;\n  }\n  REP(i, 0, m) {\n    int l, r;\n    cin >> l >> r;\n    l--, r--;\n    que[l] = max(que[l], r);\n  }\n  REP(i, 0, n - 1) {\n    que[i + 1] = max(que[i + 1], que[i]);\n  }\n  VI zs(n + 1), os(n + 1);\n  REP(i, 0, n) {\n    zs[i + 1] = zs[i] + (s[i] == '0');\n    os[i + 1] = os[i] + (s[i] == '1');\n  }\n  dp[0][0] = 1;\n  REP(i, 1, n + 1) {\n    int end = que[i - 1];\n    int zero = zs[end + 1];\n    int one = os[end + 1];\n    if (DEBUG) {\n      cerr << \"[\" << i << \"]:\" << zero << \" \" << one << endl;\n    }\n    REP(j, 0, i + 1) {\n      ll &ret = dp[i][j];\n      // adds zero\n      if (j <= zero && j >= 1) {\n\tret += dp[i - 1][j - 1];\n\tret %= mod;\n      }\n      // adds one\n      if (i - j <= one && j <= i - 1) {\n\tret += dp[i - 1][j];\n\tret %= mod;\n      }\n    }\n    if (DEBUG) {\n      cerr << \"dp[\" << i << \"]:\";\n      REP(j, 0, i + 1) { cerr << \" \" << dp[i][j]; }\n      cerr << endl;\n    }\n  }\n  ll tot = 0;\n  REP(i, 0, n) {\n    tot = (tot + dp[n][i]) % mod;\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define int long long\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=3005,mod=1000000007;\nint n,m,sum[N],l[N],r[N],f[N][N],c[N][N];\nchar ch[N];\nsigned main(){\n\tn=read(); m=read();\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)sum[i]=sum[i-1]+ch[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl[i]=read(); r[i]=read(); r[i]=max(r[i-1],r[i]);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\t}\n\tl[m+1]=n+1; f[0][0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint t=sum[r[i]]-sum[r[i-1]];\n\t\tif(r[i]<l[i+1]){\n\t\t\tint jb=r[i]-l[i]+1,meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=meiju;j++)f[i][0]=(f[i][0]+(ll)c[jb][j+t]*f[i-1][j])%mod;\n\t\t}else{\n\t\t\tint jb=l[i+1]-l[i],meiju=max((ll)0,r[i-1]-l[i]+1);\n\t\t\tfor(int j=0;j<=r[i]-l[i+1]+1;j++){\n\t\t\t\tfor(int k=max(j-t,(ll)0);k+t-j<=jb&&k<=meiju;k++){\n\t\t\t\t\tf[i][j]=(f[i][j]+(ll)c[jb][k+t-j]*f[i-1][k])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int j=0;j<=max(0,r[i]-l[i+1]);j++)cout<<f[i][j]<<\" \"<<i<<\" \"<<j<<endl;\n\t}\n\t//cout<<f[1][0]<<\" \"<<f[1][1]<<endl;\n\tcout<<(f[m][0]+mod)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* Copyright 2016 AcrossTheSky */\n#include <iostream>\n#include <cstdio>\n#include <utility>\n#include <cassert>\n#include <map>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <cctype>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#define REP(i, a, b) for (int i = (a); i <= (b); ++i)\n#define PER(i, a, b) for (int i = (a); i >= (b); --i)\n#define RVC(i, c) fot (int i = 0; i < (c).size(); ++i)\n#define RED(k, u) for (int k = head[(u)]; k; k = edge[k].next)\n#define SQR(k) (k) * (k)\n#define lowbit(x) ((x) & (-(x)))\n#define CL(x, v) memset(x, v, sizeof x)\n#define MP std::make_pair\n#define PB push_back\n#define FR first\n#define SC second\n#define rank rankk\n#define next nextt\n#define link linkk\n#define index indexx\n#define abs(x) ((x) > 0 ? (x) : (-(x)))\nusing namespace std;\ntypedef long long LL; typedef pair<int, int> PII;\n\ntemplate<class T> inline\nbool getmin(T *a, const T &b) {\n    if (b < *a) {\n        *a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline\nbool getmax(T *a, const T &b) {\n    if (b > *a) {\n        *a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline\nvoid read(T *a) {\n    char c;\n    while (isspace(c = getchar())) {}\n    bool flag = 0;\n    if (c == '-') flag = 1, *a = 0;\n    else\n        *a = c - 48;\n    while (isdigit(c = getchar())) *a = *a * 10 + c - 48;\n    if (flag) *a = -*a;\n}\n\nconst int mo = 1000000007;\ntemplate<class T>\nT pow(T a, T b, int c = mo) {\n    T res = 1;\n    for (T i = 1; i <= b; i <<= 1, a = 1LL * a * a % c) if (b & i) res = 1LL * res * a % c;\n    return res;\n}\n/*======================= TEMPLATE =======================*/\nconst int N = 3001;\nint c[N][N];\nint f[N][N];\nchar s[N], t[N], t2[N];\nint n, m;\nint l[N], r[N];\nint k;\nint dp() {\n    f[0][0] = 1;\n    REP(i, 1, n) l[i] = l[i - 1] + (t[i] == '1');\n    REP(i, 1, n) r[i] = r[i - 1] + (t2[i] == '1');\n    REP(i, 1, n) {\n        REP(j, l[i], r[i]) {\n            f[i][j] = (f[i][j] + f[i - 1][j]) % mo;\n            if (j)\n                f[i][j] = (f[i][j] + f[i - 1][j - 1]) % mo;\n        }\n    }\n    return f[n][k];\n}\nint main() {\n    cin >> n >> m;\n    k = 0;\n    scanf(\"%s\", s + 1);\n    REP(i, 1, n) if (s[i] == '1') ++k;\n    REP(i, 1, m) read(l + i), read(r + i);\n    REP(i, 0, n) {\n        c[i][0] = c[i][i] = 1;\n        REP(j, 1, i - 1) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mo;\n    }\n    REP(i, 1, n) t[i] = s[i];\n    REP(i, 1, m) sort(t + l[i], t + r[i] + 1);\n    REP(i, 1, n) t2[i] = s[i];\n    REP(i, 1, m) sort(t2 + l[i], t2 + r[i] + 1, greater<char>());\n    cout << dp() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define pb push\n#define mp make_pair\n#define X first\n#define Y second\n#define Mad(a,b) a=(a+b)%mod;\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\nqueue<P> Q;\n#define N 3010\nll n,m,d[N];string s;\nint main(){\n    cin>>n>>m>>s;\n    Q.pb(mp(0,0));\n    while(m--){\n\tll a,b;cin>>a>>b;\n\tif(Q.back().Y<b)Q.pb(mp(a,b));\n    }\n    lol(i,N)d[i]=0;d[0]=1;\n    for(ll i=0,rnd=0;i<=n;i++){\n\tll cnt=0;\n\twhile(!Q.empty()){\n\t    if(not(Q.front().X<=i))break;\n\t    for(ll j=max(i-1,rnd);j<Q.front().Y;j++)cnt+=s[j]-'0';\n\t    rnd=Q.front().Y;Q.pop();\n\t}\n\tfor(ll j=N-1;j>=0;j--)d[j]=(j-cnt>=0?d[j-cnt]:0);\n\tll lim=max(0LL,rnd-i);\n\tfor(ll j=0;j<=lim;j++)Mad(d[j],d[j+1]);\n\tfor(ll j=lim+1;j<N;j++)d[j]=0;\n    }\n    cout<<d[0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by tzupengwang™\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\n\nconst ll mod = 1000000007LL ;\n\nint n , m ;\nchar s[ 3005 ] ;\nii q[ 3005 ] ;\nvector< ii > v ;\nint pre[ 3005 ] ;\nll C[ 3005 ][ 3005 ] ;\n\nvoid init() {\n  scanf( \"%d%d%s\" , &n , &m , s + 1 ) ;\n  pre[ 0 ] = 0 ;\n  for ( int i = 1 ; i <= m ; i ++ ) {\n    scanf( \"%d%d\" , &q[ i ].first , &q[ i ].second ) ;\n    if ( v.size() == 0 ) v.push_back( q[ i ] ) ;\n    else {\n      q[ i ].second = max( v.back().second , q[ i ].second ) ;\n      if ( v.back().first < q[ i ].first ) v.push_back( q[ i ] ) ;\n      else v.back().second = max( v.back().second , q[ i ].second ) ;\n    }\n  }\n  for ( int i = 1 ; i <= n ; i ++ ) {\n    if ( s[ i ] == '1' ) pre[ i ] = pre[ i - 1 ] + 1 ;\n    else pre[ i ] = pre[ i - 1 ] ;\n  }\n}\n\nll dp[ 3005 ][ 3005 ] ;\n\nvoid process() {\n  dp[ v[ 0 ].first ][ pre[ v[ 0 ].first - 1 ] ] = 1 ;\n  for ( int i = 0 ; i + 1 < (int)v.size() ; i ++ ) {\n    ii nw = v[ i ] ;\n    ii nxt = v[ i + 1 ] ;\n    int lb = nw.first , rb = nw.second ;\n    int nlb = nxt.first ;\n    int emp = min( nlb - 1 , rb ) - ( lb - 1 ) ;\n    for ( int j = 0 ; j < lb ; j ++ ) if ( dp[ lb ][ j ] ) {\n      int ones = pre[ rb ] - j ;\n      int zeros = ( rb - lb + 1 ) - ones ;\n      int lbnd = max( j , emp - zeros + j ) ;\n      int bnd = min( pre[ rb ] , j + emp ) ;\n      int offs = 0 ;\n      if ( rb < nlb ) offs = pre[ nlb - 1 ] - pre[ rb ] ;\n      for ( int one = lbnd ; one <= bnd ; one ++ ) {\n        dp[ nlb ][ one + offs ] = ( dp[ nlb ][ one + offs ] + dp[ lb ][ j ] * C[ emp ][ one - j ] ) % mod ;\n      }\n    }\n  }\n  ll ans = 0 ;\n  ii nw = v.back() ;\n  for ( int j = 0 ; j < nw.first ; j ++ ) if ( dp[ nw.first ][ j ] ) {\n    int one = pre[ nw.second ] - j ;\n    if ( one <= nw.second - nw.first + 1 ) {\n      ans = ( ans + dp[ nw.first ][ j ] * C[ nw.second - nw.first + 1 ][ one ] ) % mod ;\n    }\n  }\n  printf( \"%lld\\n\" , ans ) ;\n}\n\nint main() {\n  for ( int i = 0 ; i <= 3000 ; i ++ )\n    C[ i ][ 0 ] = C[ i ][ i ] = 1 ;\n  for ( int i = 1 ; i <= 3000 ; i ++ ) {\n    for ( int j = 1 ; j < i ; j ++ ) {\n      C[ i ][ j ] = ( C[ i - 1 ][ j ] + C[ i - 1 ][ j - 1 ] ) % mod ;\n    }\n  }\n/*\n#ifdef ONLINE_JUDGE\nfreopen(\"input.txt\",\"r\",stdin);\nfreopen(\"output.txt\",\"w\",stdout);\n#endif\n  int Cases;\n  scanf( \"%d\" , &Cases ) ;\n  for ( int cases = 1 ; cases <= Cases ; cases ++ ) {\n*/\n    init() ;\n    process() ;\n/*\n  }\n*/\n  return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\ntemplate<int MOD>\nstruct ModInt {\n\tstatic const int Mod = MOD;\n\tunsigned x;\n\tModInt() : x(0) {}\n\tModInt(signed sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tModInt(signed long long sig) { int sigt = sig % MOD; if(sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tModInt &operator+=(ModInt that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator-=(ModInt that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n};\ntypedef ModInt<1000000007> mint;\n\nint main() {\n\tint N; int M;\n\twhile(~scanf(\"%d%d\", &N, &M)) {\n\t\tchar S[3001];\n\t\tscanf(\"%s\", S);\n\t\tvector<pair<int, int>> lrs(M);\n\t\trep(i, M) {\n\t\t\tint l; int r;\n\t\t\tscanf(\"%d%d\", &l, &r), -- l;\n\t\t\tlrs[i] = { l, -r };\n\t\t}\n\t\tsort(lrs.begin(), lrs.end());\n\t\tvector<int> nextR(N);\n\t\trep(i, N)\n\t\t\tnextR[i] = i + 1;\n\t\t{\n\t\t\tint prevL = 0, prevR = 0;\n\t\t\trep(i, M) {\n\t\t\t\tint l = lrs[i].first, r = -lrs[i].second;\n\t\t\t\tif(prevR < r) {\n\t\t\t\t\treu(j, l, N)\n\t\t\t\t\t\tnextR[j] = r;\n\t\t\t\t\tprevL = l;\n\t\t\t\t\tprevR = r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> prefix(N + 1);\n\t\trep(i, N)\n\t\t\tprefix[i + 1] = prefix[i] + (S[i] == '1');\n\t\tvector<mint> dp, ndp(N + 1);\n\t\tndp[0] = 1;\n\t\trep(i, N) {\n\t\t\tdp.swap(ndp);\n\t\t\tndp.assign(N + 1, mint());\n\t\t\tint r = nextR[i], jR = prefix[r], jL = i + 1 + prefix[r] - r;\n\t\t\trer(j, 0, i) {\n\t\t\t\tmint x = dp[j];\n\t\t\t\tif(x.x == 0) continue;\n\t\t\t\trep(b, 2) {\n\t\t\t\t\tint nj = j + (b == 1);\n\t\t\t\t\tif(jL <= nj && nj <= jR)\n\t\t\t\t\t\tndp[nj] += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint ans = ndp[prefix[N]];\n\t\tprintf(\"%d\\n\", ans.get());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=4005;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t\tif (!f[i-1][k]) continue;\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=(f[tot-1][0]+f[tot-1][1])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\nint dp[3030][3030];\nint r[3030],cnt[3030];\nchar s[3030];\nint main()\n{\n\tint n,m,l1,r1;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[i]=s[i]-'0';\n\tfor(int i=1;i<=n;i++)\n\t\tcnt[i]+=cnt[i-1];\n\tfor(int i=1;i<=n;i++)\n\t\tr[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&l1,&r1);\n\t\tr[l1]=max(r[l1],r1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tr[i]=max(r[i],r[i-1]);\n\tmemset(dp,0,sizeof(dp));\n\tdp[1][0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(dp[i][j])\n\t\t\t{\n\t\t\t\tif(cnt[r[i]]!=j)\n\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=mod;\n\t\t\t\tif(i-1-j!=r[i]-cnt[r[i]])\n\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=mod;\n\t\t\t}\n\tprintf(\"%d\",dp[n+1][cnt[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long comb(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\n//accumulative_sum_1d acc(vec, [](char x){return x=='c';});\n//long long sum = acc(lb,ub); //[lb,ub]\nclass accumulative_sum_1d{\n  using T=long long;\n public:\n  vector<T> acc;\n  template<class Comp>\n  accumulative_sum_1d(const string& vec, Comp comp_func) : acc(vec.size()){\n    for(size_t i=0; i<vec.size(); i++) acc[i] += comp_func(vec[i]) + (i?acc[i-1]:0);\n  }\n  T operator () (int lb, int ub){if(ub<lb) return 0; return acc[ub] - (lb-1>=0?acc[lb-1]:0); }\n};\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  string s;\n  cin >> s;\n\n  combination_mod cmb(mod,n+10);\n\n  vector<int> l(m),r(m);\n  for(auto i : range(m) ){\n    cin >> l[i], r[i];\n    l[i]--;\n  }\n  vector<pair<int,int>> q;\n  int ll_ = -1;\n  int rr_ = 0;\n  for(int i=0; i<m; i++){\n    int ll = l[i];\n    int rr = r[i];\n\n    while(i+1<m && l[i+1] == ll){\n      i++;\n      rr = max(rr, r[i]);\n    }\n\n    if( rr_ >= rr ) continue;\n\n    rr_ = rr;\n    q.push_back( {ll, rr} );\n  }\n\n  q.push_back({n,n-1});\n\n  accumulative_sum_1d a(s, [](char x){return x=='1';});\n\n  vector<long long> dp(n+1, 0);\n  dp[ a(q[0].first, q[0].second-1) ] = 1;\n  for(int i=0; i<q.size()-1; i++){\n    vector<long long> dp_(n+1, 0);\n    int ll = q[i].first;\n    int rr = q[i].second;\n\n    int nx_l = q[i+1].first;\n    int nx_r = q[i+1].second;\n\n    int len = rr-ll;\n\n    int d = min(rr-ll, nx_l - ll);\n    int e = a(rr, nx_r-1);\n\n    if(nx_l > rr){\n      for(int k=0; k<=len; k++){\n        if(dp[k] == 0) continue;\n        (dp[ a(nx_l, nx_r-1) ] += dp[k] * cmb.comb( len, k ) % mod) %= mod;\n      }\n\n    }else{\n\n      for(int k=0; k<=len; k++){\n        if(dp[k] == 0) continue;\n        for(int one=0; one<=k && one<=d; one++){\n          int zero = d-one;\n          if(zero > (len-k)) continue;\n          (dp_[ k-one + e ] += dp[k] * cmb.comb( d, one ) % mod) %= mod;\n        }\n      }\n    }\n\n    swap(dp, dp_);\n  }\n\n  println(dp[0]);\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int p=1e9+7;\nint n,m,i,j,x,y,re[5010],f[3010][3010],a[3010][2];\nchar s[3010];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=n;i++){\n\t\ta[i][0]=a[i-1][0];a[i][1]=a[i-1][1];\n\t\tif(s[i]=='0')a[i][0]++;\n\t\t else a[i][1]++;\n\t\tre[i]=i;\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tre[x]=max(re[x],y);\n\t}\n\tfor(i=1;i<=n;i++)re[i]=max(re[i],re[i-1]);\n\tf[0][0]=1;\n\tfor(i=1;i<=n;i++)\n\t for(j=0;j<i;j++)if(f[i-1][j]){\n\t \tif(j+1<=a[re[i]][0])f[i][j+1]=(f[i][j+1]+f[i-1][j])%p;\n\t \tif(i-j<=a[re[i]][1])f[i][j]=(f[i][j]+f[i-1][j])%p;\n\t }\n\tprintf(\"%d\",f[n][a[n][0]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\nusing namespace std;\nint n,m;\nstring s;\nll ac[3001];\nint l[3000],r[3000];\nvector<ll> dp(1000,0),_dp(1000,0),dc(1000,0);\nvoid accum(){\n    ac[0]=0;\n    rep(i,n){\n        ac[i+1]=ac[i]+(s[i]-'0');\n    }\n}\nint pow(ll x){\n    return x*x%MOD;\n}\nint modpow(ll x,ll y){\n    if (y==0){\n        return 1;\n    }else if (y==1){\n        return x%MOD;\n    }else if (y%2==0){\n        return pow(modpow(x,y/2));\n    }else{\n        return pow(modpow(x,y/2))*x%MOD;\n    }\n}\nint inv(ll x){\n    return modpow(x,MOD-2);\n}\nint nck(ll x,ll y){\n    if (y<0 || y>x) return 0;\n    y=min(y,x-y);\n    ll ret=1;\n    rep(i,y){\n        ret=ret*(x-i)%MOD;\n        ret=ret*inv(i+1)%MOD;\n    }\n    return ret;\n}\nint main(){\n    cin>>n>>m;\n    cin>>s;\n    accum();\n    int cnt=0;\n    rep(i,m){\n        int le,rr;\n        cin>>le>>rr;\n        le-=1;rr-=1;\n        if (cnt==0){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }else if (rr>r[cnt-1]){\n            l[cnt]=le;r[cnt]=rr;\n            cnt+=1;\n        }\n    }\n    m=cnt;\n    l[m]=INF,r[m]=INF;\n    int its;\n    dp[0]=1;\n    rep(i,m){\n        int pits=its;\n        int x=ac[r[i]+1]-ac[l[i]+pits];\n        its=max(0,r[i]-l[i+1]+1);\n        _dp=dc;\n        rep(j,pits+1){\n            rep(k,its+1){\n                _dp[k]=(_dp[k]+dp[j]*nck(r[i]-l[i]+1-its,x+j-k))%MOD;\n            }\n        }\n        dp=_dp;\n    }\n    cout<<dp[0]%MOD<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define all() (x).begin() , (x).end()\n#define rall(x) (x).rbegin() , (x).rend()\n#define len(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MOD = (int)1e9 + 7;\nconst int N = 3001;\nint dp[N][N];\nint sum(int x , int y){\n    x += y; if(x >= MOD)x-=MOD;\n    return x;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0) , cin.tie(0) , cout.tie(0);\n    int n , m;cin >> n >> m;\n    string s;cin >> s;\n    vector < int > r(n);\n    for(int i = 0 ; i < m; ++i){\n        int l , _r;cin >> l >> _r;\n        --l , --_r;\n        r[l] = max(r[l] , _r);\n    }\n    dp[0][0] = 1;\n    int all = 0 , j = 0;\n    for(int i = 0; i < n; ++i){\n        while(j <= r[i])\n            all += s[j] - '0' , j++;\n        for(int was = 0 ;was <= i; ++was){\n            /// put 1\n            if(was + 1 <= all)\n                dp[i + 1][was + 1] = sum(dp[i+1][was+1],dp[i][was]);\n            /// put 0\n            if((j - all) - (i - was))\n                dp[i + 1][was] = sum(dp[i+1][was] , dp[i][was]);\n        }\n    }\n    int answer = 0;\n    for(int i = 0; i <= n; ++i)\n        answer = sum(answer , dp[n][i]);\n    cout << answer;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint N, M;\nstring s;\nvector<pair<int, int> > vec;\nint r[3005];\nllint dp[3005][3005];\n\nint main(void)\n{\n\tcin >> N >> M;\n\tcin >> s;\n\tint a, b;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b;\n\t\tvec.push_back(make_pair(a, b));\n\t}\n\tfor(int i = 1; i < vec.size(); i++){\n\t\tif(vec[i].second <= vec[i-1].second){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\tfor(int i = 0; i < vec.size()-1; i++){\n\t\tif(vec[i].first == vec[i+1].first){\n\t\t\tvec.erase(vec.begin() + i);\n\t\t\ti--;\n\t\t}\n\t}\n\t\n\tint cur = 1, prev = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tfor(int j = cur; j < vec[i].first; j++) r[j] = max(j, prev);\n\t\tr[vec[i].first] = vec[i].second;\n\t\tcur = vec[i].first+1;\n\t\tprev = vec[i].second;\n\t}\n\tfor(int j = cur; j <= N; j++) r[j] = prev;\n\t\n\t//for(int i = 1; i <= N; i++) cout << r[i] << \" \"; cout << endl;\n\t\n\tdp[0][0] = 1;\n\tfor(int i = 0; i <= N; i++){\n\t\tint Y = 0;\n\t\tfor(int j = r[i]+1; j <= r[i+1]; j++) if(s[j-1] == '1') Y++;\n\t\tfor(int j = 0; j <= N-Y; j++){\n\t\t\tif(j < r[i]-i+1){\n\t\t\t\tdp[i+1][j+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j+Y] %= mod;\n\t\t\t}\n\t\t\tif(j > 0){\n\t\t\t\tdp[i+1][j-1+Y] += dp[i][j];\n\t\t\t\tdp[i+1][j-1+Y] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0; i <= N; i++){\n\t\tfor(int j = 0; j <= 7; j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n\tcout << dp[N+1][0] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#define prim 1000000007\n#define LL long long\nusing namespace std;\n\nLL N,M,a[3010],C[3010][3010],inv[3010],l[3010],r[3010],K,dp[3010],s[3010],ndp[3010];\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> N >> M;\n\n    int i,j; char c;\n    s[0]=0;\n    for (i=1; i<=N; i++){\n        cin >> c;\n        a[i]=c-'0';\n        s[i]=s[i-1];\n        if (a[i]==0) s[i]++;\n    }\n\n    C[0][0]=1;\n    for (i=1; i<=N; i++){\n        C[i][0]=1;\n        for (j=1; j<=i; j++)\n            C[i][j]=(C[i-1][j]+C[i-1][j-1])%prim;\n    }\n\n    inv[1]=1;\n    for (i=2; i<=N; i++){\n        inv[i]=(-inv[prim%i]*(prim/i))%prim;\n        inv[i]+=prim;\n    }\n\n    for (i=1; i<=M; i++){\n        K++;\n        cin >> l[K] >> r[K];\n        if (r[K]<=r[K-1]) K--;\n        else if (l[K]==l[K-1]){\n            l[K-1]=l[K],r[K-1]=r[K],K--;\n        }\n    }\n\n    LL res=1,aux,cnt=0,len,k;\n\n\n    for (i=1; i<=K; i++){\n        if (r[i]<l[i+1] || i==K){\n            aux=0;\n            if (cnt==0)\n                res=(res*C[r[i]-l[i]+1][s[r[i]]-s[l[i]-1]])%prim;\n            else{\n                for (j=0; j<=r[i-1]-l[i]+1; j++)\n                    aux=(aux+dp[j]*C[r[i]-l[i]+1][s[r[i]]-s[r[i-1]]+j])%prim;\n                res=(res*aux)%prim;\n            }\n            cnt=0;\n        }\n        else{\n            if (cnt==0){\n                for (j=0; j<=r[i]-l[i+1]+1 && j<=s[r[i]]-s[l[i]-1]; j++)\n                    dp[j]=C[l[i+1]-l[i]][s[r[i]]-s[l[i]-1]-j];\n            }\n            else{\n                memset(ndp,0,sizeof(ndp));\n                len=r[i]-l[i+1]+1;\n                for (j=0; j<=len; j++)\n                    for (k=0; k<=r[i-1]-l[i]+1; k++){\n                        if (k+s[r[i]]-s[r[i-1]]<j) continue;\n                        ndp[j]=(ndp[j]+dp[k]*C[r[i]-l[i]+1-len][k+s[r[i]]-s[r[i-1]]-j])%prim;\n                    }\n\n                memset(dp,0,sizeof(dp));\n                for (j=0; j<=len; j++)\n                    dp[j]=ndp[j];\n\n            }\n            cnt++;\n        }\n    }\n\n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Shuffling\n// * frank_c1\n// * 2017 / 09 / 30\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nconst int maxn = 3005;\nconst int mo = (int)(1e9) + 7;\nchar s[maxn];\npii b[maxn];\nint a[maxn], f[maxn], g[maxn];\nint n, m, tot, cnt;\n\ninline void addX(int p) {\n\tif (s[p] == '1') {\n\t\tfor (int j = n; j; --j) f[j] = f[j - 1]; f[0] = 0; ++cnt;\n\t} ++tot;\n}\n\ninline void add(int& x, int v) {\n\tx += v; if (x >= mo) x -= mo;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= m; ++i) scanf(\"%d%d\", &b[i].first, &b[i].second);\n\tint ps = 1, mx = 1; f[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\twhile (mx <= i) addX(mx++);\n\t\tfor (; ps <= n && b[ps].first == i; ++ps) {\n\t\t\twhile (mx <= b[ps].second) addX(mx++);\n\t\t}\n\t\tmemset(g, 0, sizeof(g));\n\t\tfor (int j = 0; j <= cnt; ++j) {\n\t\t\tif (j) add(g[j - 1], f[j]); \n\t\t\tif (j < tot) add(g[j], f[j]);\n\t\t}\n\t\tmemcpy(f, g, sizeof(g)); --tot;\n\t} printf(\"%d\\n\", f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<string>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iomanip>\n#include<set>\n#include<random>\nusing namespace std ;\n\n#define MOD 1000000007\n#define MAXN 3007\n\nint n , k ;\nstring a ;\nint mx[ MAXN ] ;\nlong long dp[ MAXN ][ MAXN ] ;\n\nvoid input ( ) {\n    cin >> n >> k ;\n    cin >> a ;\n    for ( int i = 0 ; i <= n ; ++ i ) {\n        mx[ i ] = i ;\n    }\n    for ( int i = 1 ; i <= k ; ++ i ) {\n        int x , y ;\n        cin >> x >> y ;\n        mx[ x ] = max ( mx[ x ] , y ) ;\n    }\n    for ( int i = 1 ; i <= n ; ++ i ) {\n        mx[ i ] = max ( mx[ i ] , mx[ i - 1 ] ) ;\n    }\n}\n\nvoid solve ( ) {\n    dp[ 0 ][ 0 ] = 1 ;\n    int cnt = 0 ;\n    int pos = 0 ; \n    for ( int i = 0 ; i < n ; ++ i ) {\n        while ( pos < mx[ i + 1 ] ) {\n            if ( a[ pos ] == '1' ) { ++ cnt ; }\n            ++ pos ;\n        }\n        for ( int j = 0 ; j <= cnt ; ++ j ) {\n            if ( dp[ i ][ j ] == 0 ) { continue ; }\n            if ( j < cnt ) {\n                dp[ i + 1 ][ j + 1 ] += dp[ i ][ j ] ;\n                if ( dp[ i + 1 ][ j + 1 ] >= MOD ) {\n                    dp[ i + 1 ][ j + 1 ] -= MOD ;\n                }\n            }\n            int used = i - j ;\n            int lft = pos - cnt ;\n            if ( used < lft ) {\n                dp[ i + 1 ][ j ] += dp[ i ][ j ] ;\n                if ( dp[ i + 1 ][ j ] >= MOD ) {\n                    dp[ i + 1 ][ j ] -= MOD ;\n                }\n            }\n        }\n    }\n    cout << dp[ n ][ cnt ] << \"\\n\" ;\n}\n\n\nint main ( ) {\n    ios_base :: sync_with_stdio ( false ) ;\n    cin.tie ( NULL ) ;\n    input ( ) ;\n    solve ( ) ;\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define lld long long\n#define pii pair<int,int>\n#define pb push_back\n#define next nextt\n#define Inf 1000000000\n#define Mod 1000000007\n\nusing namespace std;\n\nint N,M; lld ans;\nint a[3002],sum[3002];\nint x[3002],y[3002];\nlld fact[3002],inv[3002];\nlld d[3002][3002];\nchar s[3002];\n\nlld mul(lld x,int y){\n\tif(y == 0) return 1;\n\tlld tmp = mul(x,y/2);\n\ttmp *= tmp; tmp %= Mod;\n\tif(y%2==1){\n\t\ttmp *= x;\n\t\ttmp %= Mod;\n\t}\n\treturn tmp;\n}\nlld comb(int n,int r){\n\tlld tmp = fact[n];\n\ttmp *= inv[n-r]; tmp %= Mod;\n\ttmp *= inv[r]; tmp %= Mod;\n\treturn tmp;\n}\n\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tscanf(\"%s\",s);\n\tfact[0] = inv[0] = 1;\n\tfor(int i=1; i<=N; i++){\n\t\ta[i] = s[i-1]-'0';\n\t\tsum[i] = sum[i-1]+a[i];\n\t\tfact[i] = (fact[i-1]*i)%Mod;\n\t\tinv[i] = mul(fact[i],Mod-2);\n\t}\n\tint rear = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tint tx,ty;\n\t\tscanf(\"%d %d\",&tx,&ty);\n\t\tif(x[rear] == tx) y[rear] = max(y[rear],ty);\n\t\telse{\n\t\t\trear++;\n\t\t\tx[rear] = tx; y[rear] = ty;\n\t\t}\n\t}\n\tM = rear;\n\td[0][sum[x[1]-1]] = 1;\n\tx[M+1] = N+1;\n\tint maxr = 0;\n\tfor(int i=1; i<=M; i++){\n\t\tmaxr = max(maxr,y[i]);\n\t\tfor(int j=0; j<=sum[maxr]; j++){\n\t\t\tif(d[i-1][j] == 0) continue;\n\t\t\tint cnt1,cnt2;\n\t\t\tif(maxr < x[i+1]){\n\t\t\t\tcnt1 = cnt2 = sum[maxr]-j;\n\t\t\t}else{\n\t\t\t\tif(sum[maxr]-j > maxr-x[i]+1) while(true);\n\t\t\t\tcnt1 = max(0,sum[maxr]-j-(maxr-x[i+1]+1));\n\t\t\t\tcnt2 = min(sum[maxr]-j,x[i+1]-x[i]);\n\t\t\t}\n\t\t\tfor(int k=cnt1; k<=cnt2; k++){\n\t\t\t\td[i][j+k] += d[i-1][j]*comb(min(maxr,x[i+1]-1)-x[i]+1,k);\n\t\t\t\td[i][j+k] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<=sum[N]; i++){\n\t\tans += d[M][i];\n\t\tans %= Mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAXN=3000;\nconst int MOD=1e9+7;\nvoid A(int& a,int b){a+=b;if(a>=MOD)a-=MOD;}\nint n,m,r[MAXN+10],f[MAXN+10][MAXN+10],sm[MAXN+10];\nchar s[MAXN+10];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=1;i<=n;++i)sm[i]=sm[i-1]+s[i]-'0',r[i]=i;\n\tfor(int i=1,a,b;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tr[a]=max(r[a],b);\n\t}\n\tfor(int i=1;i<=n;++i)r[i]=max(r[i],r[i-1]);\n\tf[1][sm[r[1]]]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=0;j<=n;++j)\n\t\t{\n\t\t\tif(f[i][j]==0)continue;\n\t\t\tint k=sm[r[i+1]]-sm[r[i]];\n\t\t\tif((r[i]>i||s[i]=='0')&&j<r[i]-i+1&&j+k<=r[i+1]-i)A(f[i+1][j+k],f[i][j]);\n\t\t\tif((r[i]>i||s[i]=='1')&&j>0)A(f[i+1][j+k-1],f[i][j]);\n\t\t}\n\t}\n\tint ans=0;A(ans,f[n][0]);A(ans,f[n][1]);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {if(a<0)return -1;if(a>0)return 1;return 0;}\nstring to_string(string s) {return '\"' + s + '\"';}string to_string(const char* s) {return to_string((string) s);}string to_string(bool b) {return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void debug_out() { cerr << endl; }template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);debug_out(T...);}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {x = 0;T f = 1;char ch = getchar();while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}while (isdigit(ch))  {x = x * 10 + ch - '0';ch = getchar();}x *= f;}\nll twop(int x) {return 1LL<<x;}\ntemplate<typename T>T MOD(T a, T m){a %= m;if (a < 0)a += m;return a;}\ntemplate<typename T>T inverse(T a, T m){a = MOD(a, m);if (a <= 1)return a;return MOD((1 - inverse(m, a) * m) / a, m);}template<typename A,typename B > inline void in(A&x,B&y) {in(x);in(y);}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {in(x);in(y);in(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {in(x);in(y);in(z);in(d);}\ntemplate <typename T>T sqr(T x){return x*x;}\nll gcd(ll a,ll b){while(b!=0){a%=b;swap(a,b);}return a;}\nll fast(ll a,ll b,ll mod){ll ans = 1;while(b){if(b&1){b--;ans = ans * a % mod;}else{a = a * a % mod;b/=2;}}return ans%mod;}\n\n\nconst ll maxn = 100010;\nll fac[maxn],facinv[maxn],inv[maxn];\nvoid init(){\n    fac[0] = 1;\n    REP(i,1,maxn)fac[i] = i*(fac[i-1])%mod;\n    facinv[maxn-1]=inverse(fac[maxn-1], mod);\n    RREP(i,maxn-2,0){\n        facinv[i] = facinv[i+1]*(i+1)%mod;\n    }\n    inv[1]=1;\n    for(int i=2;i<maxn;i++)\n        inv[i]=(mod-(ll)mod/i*inv[mod%i]%mod);\n}\n\nll combi(int n,int m){\n    if(n<0 || m<0 || n<m)return 0;\n    return fac[n]*facinv[m]%mod*facinv[n-m]%mod;\n}\n\nll get_len(ll a,ll b){\n    return max(b-a+1,0ll);\n}\nnamespace SOLVE {\n    void main(){\n        ll n,m;\n        cin>>n>>m;\n        string s;\n        cin>>s;\n        vector<PLL>v;\n        REP(i,0,m){\n            int l,r;in(l,r);\n            --l;--r;\n            if(sz(v) and v.back().se >= r){\n                continue;\n            }else{\n                if(sz(v) and v.back().fi == l){\n                    v.pop_back();\n                }\n                v.PB(MP(l,r));\n            }\n        }\n        VLL dp(3010,0);\n        v.insert(v.begin(), MP(-1,-1));\n        v.PB(MP(inf,inf));\n        dp[0] = 1;\n        REP(i,1,sz(v)-1){\n            ll last = v[i-1].se;\n            ll cnt = 0;\n            for(int j = max(last+1,v[i].fi);j<=v[i].se;j++){\n                cnt += s[j] == '1';\n            }\n            ll nxt = min(v[i+1].fi-1,v[i].se);\n            VLL new_dp(3010,0);\n            ll len = nxt-v[i].fi+1;\n            ll overlap = get_len(max(v[i].fi,v[i+1].fi),min(v[i].se,v[i+1].se));\n            REP(use,0,len+1){\n                REP(from,0,3010){\n                    if(from+cnt-use <= overlap)new_dp[from+cnt-use] += dp[from] * combi(len, use) % mod;\n                }\n            }\n            swap(dp, new_dp);\n            REP(i,0,3010)dp[i]%=mod;\n        }\n        cout<<dp[0]<<endl;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n#endif\n    \n    \n    init();\n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint const MOD=1000000007;\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n,n_operation;std::cin>>n>>n_operation;\n\n\tstd::vector<int> acm;acm.reserve(n+1);acm.resize(n); // suffix sum accumulation\n\tfor(int& x:acm){\n\t\tchar c;std::cin>>c;\n\t\tx=c-'0';\n\t}\n\tfor(int i=n-1;i--;)\n\t\tacm[i]+=acm[i+1];\n\tacm.push_back(0);\n\n\tauto const sum=[&](int l,int r){return acm[l]-acm[r];};\n\n\n\tstd::vector<std::pair<int,int>> ops;ops.reserve(n_operation+1);\n\tfor(int _=n_operation;_--;){\n\t\tint l,r;std::cin>>l>>r;--l;\n\t\tif(!ops.empty()){\n\t\t\tif(ops.back().first==l){\n\t\t\t\tops.back().second=std::max(ops.back().second,r);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(ops.back().second>=r)\n\t\t\t\tcontinue;\n\t\t}\n\t\tops.push_back({l,r});\n\t}\n\n\tops.push_back({n,n});\n\n\tn_operation=-1;\n\n\tauto const l=[&](int x){return ops[x].first;};\n\tauto const r=[&](int x){return ops[x].second;};\n\n\tstd::vector<std::vector<int>> dp(ops.size());\n\t// dp[i][n] = number of states of the sequence [0,l(i)] after i steps with sum n\n\n\tdp[0].resize(n+1);\n\tdp[0][sum(0,l(0))]=1;\n\n\n\tstd::vector<std::vector<int>> binom(n+1);\n\tbinom[0].assign(1,1);\n\tfor(unsigned i=1;i<binom.size();++i){\n\t\tbinom[i].resize(i+1);\n\t\tstd::copy(begin(binom[i-1]),end(binom[i-1]),begin(binom[i]));\n\t\tstd::transform(begin(binom[i-1]),end(binom[i-1]),++begin(binom[i]),++begin(binom[i]),[](int a,int b){\n\t\t\t\ta+=b;\n\t\t\t\tif(a>=MOD)a-=b;\n\t\t\t\treturn a;\n\t\t\t\t});\n\t}\n\n\n\tfor(int i=1;i<(int)ops.size();++i){\n\t\tdp[i].resize(n+1);\n\t\tfor(int x=0;x<=n;++x){\n\t\t\t// x = sum [0,l(i)] after i steps\n\n\t\t\tint ans=0;\n\t\t\tfor(int y=0;y<=x;++y){\n\t\t\t\t// y = sum [0,l(i-1)] after >= i-1 steps\n\t\t\t\t// then perform permutation of l(i-1) .. r(i-1) (after i-1 steps there are\n\t\t\t\t// sum(0,r(i-1))-y   ones in the range and  y  ones before)\n\t\t\t\t// such that there are x ones before l(i) <-> x-y ones int  l(i-1) .. l(i)\n\n\t\t\t\tint const cntrange=sum(0,r(i-1))-y; // range l..r (i-1)\n\n\t\t\t\tint mid=l(i);\n\t\t\t\tint midcnt=x-y; // desired cnt int l(i-1) .. mid\n\t\t\t\tif(mid>r(i-1)){\n\t\t\t\t\tmidcnt-=sum(r(i-1),mid);\n\t\t\t\t\tmid=r(i-1);\n\t\t\t\t}\n\n\t\t\t\t// need to count number of seq [l(i-1) .. mid] with midcnt ones\n\t\t\t\tif(0<=midcnt&&midcnt<=cntrange&& midcnt<=mid-l(i-1) && cntrange-midcnt<=r(i-1)-mid)\n\t\t\t\t\tans=(ans+(int64_t)dp[i-1][y]*binom[mid-l(i-1)][midcnt])%MOD;\n\t\t\t}\n\t\t\tdp[i][x]=ans;\n\t\t}\n\t}\n\n\tstd::cout<<dp[ops.size()-1][sum(0,n)]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n// #define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\nvoid print(vmint v){\n    for(auto e:v)cout<<e.a<<\" \";\n    cout<<endl;\n}\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int n=in(),m=in();\n    calc();\n    string s;cin>>s;\n    vec a;\n    a.pb(0);\n    for(auto e:s){\n        a.pb(a.back()+(e=='1'));\n    }\n    vecpii v;\n    rep(i,m){\n        int l=in(),r=in();\n        if(!v.empty() and v.back().fi==l)chmax(v.back().se,r);\n        else if(!v.empty() and v.back().se>=r) continue;\n        else v.eb(l,r);\n    }\n    v.eb(n+1,n+1);\n    vmint dp(n+1);\n    dp[0]=1;\n    int prel=0,prer=0;\n    rep(i,v.size()-1){\n        int x = v[i+1].fi-1 , y = v[i].se;\n        vmint next(n+1);\n        if(v[i+1].fi>v[i].se){\n            int l = a[y];\n            rep2(j,prel,prer){\n                next[l]+=dp[j]*cmb(v[i].se-v[i].fi+1,l-j);\n            }\n            dp=vmint(n+1);\n            dp[a[v[i+1].fi-1]]=next[l];\n            prel=prer=a[v[i+1].fi-1];\n            continue;\n        }\n        int l = max(0,x-y+a[y]) , r=a[y];\n        rep2(j,prel,prer){\n            rep2(k,l,r){\n                next[k]+=dp[j]*cmb(x-v[i].fi+1,k-j);\n            }\n        }\n        dp=next;\n        prel=l,prer=r;\n    }\n    cout<<dp[a[n]].a<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int MAXN = 3007, MOD = 1000000007;\nint R[MAXN], N, M, dp[MAXN][MAXN];\nbool S[MAXN];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> N >> M;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tchar ch;\n\t\tcin >> ch;\n\t\tS[i] = ch - '0';\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tR[l] = max(R[l], r);\n\t}\n\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tR[i] = max(i, max(R[i], R[i - 1]));\n\t\tint add = 0;\n\t\tfor (int j = R[i - 1] + 1; j <= R[i]; ++j) add += S[j];\n\n\t\tfor (int j = 0; j <= N; ++j) if (dp[i - 1][j]) {\n\t\t\tif (j + add <= R[i] - i) {\n\t\t\t\tdp[i][j + add] += dp[i - 1][j];\n\t\t\t\tif (dp[i][j + add] >= MOD) dp[i][j + add] -= MOD;\n\t\t\t}\n\t\t\tif (j + add - 1 >= 0) {\n\t\t\t\tdp[i][j + add - 1] += dp[i - 1][j];\n\t\t\t\tif (dp[i][j + add - 1] >= MOD) dp[i][j + add - 1] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9+7;\n\nll add(ll a,ll b){\n  return (a+b)%mod;\n}\n\n#define MAX 3005\nint n,m;\nstring s;\nint a[MAX],b[MAX];\nint x[MAX];\n\nll dp[MAX][MAX];\n\nint main(){\n  cin>>n>>m>>s;\n  for(int i=0;i<n;i++){\n    x[i]=i;\n    a[i]=(s[i]=='0'?1:0) + (i?a[i-1]:0);\n    b[i]=(s[i]=='1'?1:0) + (i?b[i-1]:0);\n  }\n  for(int i=0;i<m;i++){\n    int l,r;\n    cin>>l>>r;\n    l--;\n    r--;\n    for(int j=l;j<r;j++){\n      x[j]=max(x[j],r);\n    }\n  }\n\n  dp[0][0]=1;\n  for(int i=0;i<n;i++){\n    int p=x[i];\n    for(int j=0;j<=i;j++){\n      if(dp[i][j]==0)continue;\n      int A=j;\n      int B=i-A;\n      if( A+1 <= a[p] ){\n        dp[i+1][A+1]=add(dp[i+1][A+1],dp[i][j]);\n      }\n      if( B+1 <= b[p] ){\n        dp[i+1][A]=add(dp[i+1][A],dp[i][j]);\n      }\n    }\n  }\n\n  cout<<dp[n][ a[n-1] ]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tptmp.erase(std::unique(ptmp.begin(), ptmp.end()), ptmp.end());\n\tvector<int> lefs;\n\tfor(int i=0;i<ptmp.size();i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second ){\n\t\tif( i == ptmp.size()-1 || ptmp[i].first < ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tdp[i][ct[i]] += dp[i-1][ct[i-1]];\n\t\t\tdp[i][ct[i]] %= inf;\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j && i-j>=0){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int MAXN = 3000, MOD = 1000 * 1000 * 1000 + 7;\nint dp[MAXN + 1][MAXN + 1], pr[MAXN + 1], ls[MAXN + 1];\n\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\n\nint main() {\n    //ios_base::sync_with_stdio(false);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    s = \"#\" + s;\n    for(int i = 1; i <= n; i++) {\n        ls[i] = i;\n        pr[i] = pr[i - 1] + s[i] - '0';\n    }\n    for(int i = 1; i <= m; i++) {\n        int l, r;\n        cin >> l >> r;\n        for(int j = l; j <= r; j++)\n            ls[j] = max(ls[j], r);\n    }\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++) {\n        int b = ls[i + 1];\n        for(int j = 0; j <= i + 1; j++) {\n            if(j < pr[b])\n                add(dp[i + 1][j + 1], dp[i][j]);\n            if((i - j) < b - pr[b])\n                add(dp[i + 1][j], dp[i][j]);\n        }\n    }\n    cout << dp[n][pr[n]] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=3005,mod=1000000007;\ntypedef long long LL;\nchar S[N];\nint n,m,s[N],x[N],y[N],c[N][N],tot,l[N],r[N],maxn;\nLL f[N][N];\nstruct data{int x,y;} dat[N];\n\nint getint()\n{\n\tchar ch;\n\tint f=1;\n\twhile(!isdigit(ch=getchar())) if(ch=='-') f=-1;\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x*f;\n}\n\nbool cmp(data a,data b)\n{\n\treturn a.x==b.x?a.y>b.y:a.x<b.x;\n}\n\nint main()\n{\n\tfreopen(\"065.in\",\"r\",stdin);\n\tn=getint(),m=getint(),scanf(\"%s\",S+1);\n\trep(i,0,n) c[i][0]=c[i][i]=1;\n\trep(i,1,n) rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;\n\trep(i,1,n) s[i]=s[i-1]+S[i]-48;\n\trep(i,1,m) dat[i].x=getint(),dat[i].y=getint();\n\tsort(dat+1,dat+1+m,cmp);\n\trep(i,1,m) if(dat[i].y>maxn) ++tot,x[tot]=dat[i].x,y[tot]=dat[i].y,maxn=dat[i].y;\n\tf[0][0]=1,x[tot+1]=y[tot+1]=n+1;\n\trep(i,1,tot)\n\t{\n\t\tint w=min(y[i]-x[i]+1,x[i+1]-x[i]),a=s[y[i]]-s[max(x[i]-1,y[i-1])];\n\t\tl[i]=max(0,l[i-1]+a-w),r[i]=min(y[i]-x[i+1]+1,r[i-1]+a);\n\t\trep(j,l[i],r[i])\n\t\t\trep(k,l[i-1],r[i-1])\n\t\t\t\tf[i][j]=(f[i][j]+f[i-1][k]*c[w][k+a-j])%mod;\n\t}\n\tprintf(\"%lld\\n\",f[tot][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T& y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T& y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <i64 mod = MOD>\nstruct ModInt{\n    i64 p;\n\n    ModInt() : p(0){}\n    ModInt(i64 x){p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}\n\n    ModInt& operator+=(const ModInt& y){p = p + *y - ((p + *y) >= mod ? mod : 0); return *this;}\n    ModInt& operator-=(const ModInt& y){p = p - *y + (p - *y < 0 ? mod : 0); return *this;}\n    ModInt& operator*=(const ModInt& y){p = (p * *y) % mod; return *this;}\n    ModInt& operator%=(const ModInt& y){if(y)p %= *y; return *this;}\n\n    ModInt operator+(const ModInt& y) const{ModInt x = *this; return x += y;}\n    ModInt operator-(const ModInt& y) const{ModInt x = *this; return x -= y;}\n    ModInt operator*(const ModInt& y) const{ModInt x = *this; return x *= y;}\n    ModInt operator%(const ModInt& y) const{ModInt x = *this; return x %= y;}\n\n    friend ostream& operator<<(ostream& stream, const ModInt<mod>& x){\n        stream << *x;\n        return stream;\n    }\n\n    friend ostream& operator>>(ostream& stream, const ModInt<mod>& x){\n        stream >> *x;\n        return stream;\n    }\n\n    ModInt& operator++(){p = (p + 1) % mod; return *this;}\n    ModInt& operator--(){p = (p - 1 + mod) % mod; return *this;}\n\n    bool operator==(const ModInt& y) const{return p == *y;}\n    bool operator!=(const ModInt& y) const{return p != *y;}\n\n    const i64& operator*() const{return p;}\n    i64& operator*(){return p;}\n\n};\n\nusing mint = ModInt<>;\n\n\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> l(m), r(m);\n    vector<int> v(n, 0);\n    iota(v.begin(), v.end(), 1);\n    for(int i = 0; i < m; ++i){\n        cin >> l[i] >> r[i];\n        chmax(v[--l[i]], r[i]);\n    }\n    for(int i = 0; i < n - 1; ++i)\n        chmax(v[i + 1], v[i]);\n\n    vector<int> cnt(n + 1, 0);\n    for(int i = 0; i < n; ++i)\n        cnt[i + 1] = cnt[i] + (s[i] == '1');\n\n    vector<vector<mint>> dp(n + 1, vector<mint>(n + 1, 0));\n    dp[0][0] = 1;\n\n    for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n            int one = cnt[v[i]] - j;\n            int zero = (v[i] - cnt[v[i]]) - (i - j);\n            if(one > 0)\n                dp[i + 1][j + 1] += dp[i][j];\n            if(zero > 0)\n                dp[i + 1][j] += dp[i][j];\n        }\n    }\n    cout << dp.back()[cnt.back()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::const_iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct __monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))__monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))__monostate& ms) { return os; }\n} ms;\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\nusing v_t = int;\nusing vv_t = ll;\ntemplate<v_t MOD> struct modnum {\n    v_t v;\n    modnum() : v(0) {}\n    modnum(vv_t _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator v_t() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { vv_t w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // x must be less than 2^32 * m so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x, quot, rem;\n        asm(\"divl %4\\n\"\n                : \"=a\" (quot), \"=d\" (rem)\n                : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = fast_mod(vv_t(v) * o.v); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(vv_t e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        v_t g = MOD, x = 0, y = 1;\n        for (v_t r = v; r != 0; ) {\n            v_t q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static constexpr v_t totient() {\n        v_t tot = MOD, tmp = MOD;\n        for (v_t p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static v_t primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        v_t tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (v_t p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (v_t r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (v_t p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static v_t discrete_log(modnum v) {\n        static const v_t M = ceil(sqrt(MOD));\n        static unordered_map<v_t, v_t> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (v_t i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (v_t i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum unity_root(int deg, int pow) {\n        static vector<modnum> table{ 0, 1 };\n        while (sz(table) <= deg) {\n            modnum w = unity_root(sz(table));\n            for (int i = sz(table)/2, s = sz(table); i < s; i++) {\n                table.push_back(table[i]);\n                table.push_back(table[i] * w);\n            }\n        }\n        return table[deg + (pow < 0 ? deg + pow : pow)];\n    }\n\n    static modnum factorial(int n) {\n        static vector<modnum> fact = {1};\n        assert(n >= 0);\n        if (sz(fact) <= n) {\n            int had = sz(fact);\n            fact.resize(n + 1);\n            for (int i = had; i <= n; i++) fact[i] = fact[i-1] * i;\n        }\n        return fact[n];\n    }\n    static modnum inverse_factorial(int n) {\n        static vector<modnum> finv = {1};\n        assert(n >= 0);\n        if (sz(finv) <= n) {\n            int had = sz(finv);\n            finv.resz(n + 1), finv[n] = factorial(n).inv();\n            for (int i = n - 1; i >= had; i--) finv[i] = finv[i+1] * (i+1);\n        }\n        return finv[n];\n    }\n\n    static modnum small_inv(int n) {\n        assert(n > 0); return factorial(n - 1) * inverse_factorial(n);\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return factorial(n) * inverse_factorial(r) * inverse_factorial(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nint main() {\n    setIO();\n\n    int N, M; re(N, M);\n    string s; re(s);\n\n    vpii moves;\n    F0R (_, M) {\n        int l, r; re(l, r); --l;\n        if (!moves.empty() && moves.back().f == l)\n            ckmax(moves.back().s, r);\n        else\n            moves.eb(l, r);\n    }\n\n    vmn dp(N + 1), DP = dp;\n    dp[0] = 1;\n\n    int tail = 0, ones = 0, zeroes = 0;\n\n    int m = 0;\n    F0R (i, N) {\n        int j = i + 1;\n        if (m < sz(moves) && moves[m].f == i) {\n            j = moves[m++].s;\n        }\n\n        while (tail < j) {\n            if (s[tail] == '1')\n                ones++;\n            else\n                zeroes++;\n            tail++;\n        }\n\n        fill(all(DP), 0);\n\n        F0R (p0, sz(dp)) {\n            int p1 = i - p0;\n\n            if (p0 < zeroes)\n                DP[p0 + 1] += dp[p0];\n            if (p1 < ones)\n                DP[p0] += dp[p0];\n        }\n\n        swap(dp, DP);\n    }\n\n    ps(dp[zeroes]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[3114][3514], ct[3100];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tstring s;\n\tcin>>s;\n\tvector< pair<int,int> > ptmp, p;\n\tfor(int i=0;i<m;i++){\n\t\tint xx,yy;\n\t\tcin>>xx>>yy;\n\t\tptmp.pb( mp(xx,yy) );\n\t}\n\tsort( ptmp.begin(), ptmp.end() );\n\tptmp.erase(std::unique(ptmp.begin(), ptmp.end()), ptmp.end());\n\tvector<int> lefs;\n\tfor(int i=0;i<ptmp.size();i++){\n\t\tif( i == 0 || ptmp[i].second > ptmp[i-1].second ){\n\t\tif( i == ptmp.size()-1 || ptmp[i].first < ptmp[i+1].first){\n\t\t\tp.pb(ptmp[i]);\n\t\t\tlefs.pb(ptmp[i].first);\n\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif( s[i-1] == '1') ct[i] = ct[i-1]+1;\n\t\telse ct[i] = ct[i-1];\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint idx = upper_bound(lefs.begin(),lefs.end(),i)-lefs.begin();\n\t\tif( idx == 0 || p[idx-1].second < i){\n\t\t\tdp[i][ct[i]] += dp[i-1][ct[i-1]];\n\t\t\tdp[i][ct[i]]%=inf;\n\t\t}\n\t\telse{\n\t\t\tint rig = p[idx-1].second;\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif( ct[rig] >= j+1 && j <= i-1 ){\n\t\t\t\t\tdp[i][j+1] += dp[i-1][j];\n\t\t\t\t\tdp[i][j+1] %= inf;\n\t\t\t\t}\n\t\t\t\tif( rig - ct[rig] >= i-j){\n\t\t\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\t\t\tdp[i][j] %= inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n][ct[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\n#include <cassert>\n#include <bits/stdc++.h>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000007\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,q; string s;\nvector<P>vec;\nll dp[3005][3005],C[3005][3005];\nint main(){\n    C[0][0]=1;\n    for(int i=1;i<3005;i++)for(int j=0;j<=i;j++){\n        if(j==0||j==i)C[i][j]=1LL;\n        else C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;\n    }\n\tcin>>n>>q>>s;\n\trep(i,q){\n\t\tint a,b;cin>>a>>b;\n\t\tif(vec.empty() || vec[vec.size()-1].sc<b){\n\t\t\tif(!vec.empty() && vec[vec.size()-1].fi == a){\n\t\t\t\tvec.pop_back();\n\t\t\t}\n\t\t\tvec.pb(mp(--a,--b));//cout<<vec[vec.size()-1].fi<<vec[vec.size()-1].sc<<endl;\n\t\t}\n\t}\n\tdp[0][0] =1LL;\n\tint sum = 0,nxt2 = 0;\n\tint S=0,T=0;\n\trep(i,vec.size()){\n\t\tint nxt = (i==vec.size()-1?vec[i].sc+1:min(vec[i].sc+1,vec[i+1].fi));\n\t\t//[vec[i].fi,nxt) wo kettei\n\t\tfor(int ii=max(nxt2,vec[i].fi);ii<vec[i].sc+1;ii++){\n\t\t\tif(s[ii]=='0')S++;else T++;\n\t\t}//cout<<S<<T;\n\t\tfor(int ii=0;ii<=sum;ii++){\n\t\t\tif(dp[ii][sum-ii]==0LL)continue;//cout<<ii;\n\t\t\tint zan = S-ii,zan2 = T-(sum-ii); \n\t\t\tfor(int x=0;x<=nxt-vec[i].fi;x++){\n\t\t\t\tif(x>zan||(nxt-vec[i].fi-x)>zan2) continue;//cout<<x;\n\t\t\t\tdp[ii+x][sum-ii+(nxt-vec[i].fi-x)] += dp[ii][sum-ii]*C[nxt-vec[i].fi][x]%mod;\n\t\t\t\twhile(dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]>=mod) dp[ii+x][sum-ii+(nxt-vec[i].fi-x)]-=mod;\n\t\t\t}\n\t\t}\n\t\tsum += nxt-vec[i].fi; nxt2 = vec[i].sc+1;//cout<<S<<T<<dp[S][T];\n\t}\n\tll ret = 0;\n\trep(i,S+T+1) ret=(ret+dp[i][S+T-i])%mod; cout<<ret<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <bitset>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\nconst int P = 1e9 + 7;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tvector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\n\tvector<int> a(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\ta[l] = max(r, a[l]);\n\t}\n\n\tdp[0][0] = 1;\n\n\tint rg = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] <= rg) {\n\t\t\tif (i < rg) {\n\t\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\t\tif (rg - i > j)\n\t\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i + 1][0] = dp[i][0];\n\t\t\t}\n\t\t} else {\n\t\t\tint x = 0;\n\t\t\tfor (int j = max(rg, i); j < a[i]; ++j) \n\t\t\t\tx += s[j] - '0';\n\n\t\t\trg = a[i];\n\n\t\t\tfor (int j = n; j >= 0; --j) {\n\t\t\t\tif (j + x <= n && x != 0) {\n\t\t\t\t\tdp[i][j + x] = dp[i][j];\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tdp[i + 1][j - 1] += dp[i][j];\n\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\tif (rg - i > j)\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tdp[i + 1][j] %= P;\n\t}\n\n\tcout << dp[n][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 3010;\nconst int moder = 1e9 + 7;\n\nint dp[N][N], a[N], pre[N], r[N], n, m;\nchar s[N];\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tfor (int i = 1; i <= n; ++ i){\n\t\tr[i] = i;\n\t}\n\tfor (int i = 0, l, right; i < m; ++ i){\n\t\tscanf(\"%d%d\", &l, &right);\n\t\tfor (int j = l; j <= right; ++ j){\n\t\t\tr[j] = std::max(r[j], right);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i){\n\t\ta[i] = s[i - 1] - '0';\n\t\tpre[i] = pre[i - 1] + (a[i] == 1);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n + 1; ++ i){\n\t\tfor (int j = 0; j <= i - 1; ++ j){\n\t\t\tint restone = pre[r[i]] - j;\n\t\t\tif (restone < 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (restone > 0){\n\t\t\t\tdp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j]) % moder;\n\t\t\t}\n\t\t\tif (restone != r[i] - i + 1){\n\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][j]) % moder;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][pre[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint fact[1000001];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nint N, M;\nint L[3000], R[3000];\nint T[3001];\nstring S;\nint dp[3001][3001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=1000000; i++) {\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n\n  cin >> N >> M >> S;\n  rep(i, N) T[i+1] = T[i] + (S[i] == '1');\n  rep(i, M) {\n    cin >> L[i] >> R[i];\n    L[i]--, R[i]--;\n  }\n  vector<P> qs;\n  rep(i, M) {\n    bool f = true;\n    rep(j, M) {\n      if (i == j) continue;\n      // j contains i\n      if (L[j] <= L[i] && R[i] <= R[j]) {\n        f = false;\n        break;\n      }\n    }\n    if (!f) continue;\n    qs.pb(P(L[i], R[i]));\n  }\n  dp[0][0] = 1;\n  int s = 1;\n  rep(i, qs.size()) {\n    int l = qs[i]._1, r = qs[i]._2;\n    bool end = true;\n    int n = 0;\n    int nl = N;\n    if (i+1 < qs.size()) {\n      nl = qs[i+1]._1;\n      if (r >= nl) {\n        end = false;\n        n = r-nl+1;\n      }\n    }\n    int ll = l;\n    if (i > 0) ll = max(ll, qs[i-1]._2+1);\n    int ones = T[r+1] - T[ll];\n    if (end) {\n      int len = r-l+1;\n      long long e = 0;\n      rep(k, N+1) {\n        e += (1LL * dp[i][k] * nCr(len, ones+k)) % MOD;\n        e %= MOD;\n      }\n      s = (1LL*s*e) % MOD;\n      dp[i+1][0] += 1;\n    }\n    else {\n      int det = nl-l;\n      rep(k, ll+1) {\n        if (dp[i][k] == 0) continue;\n        int r = ones+k;\n        rep(nk, n+1) {\n          if (r < nk) break;\n          // r-nk, nk\n          dp[i+1][nk] += (1LL * nCr(det, r-nk) * dp[i][k]) % MOD;\n          dp[i+1][nk] %= MOD;\n        }\n      }\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn=3000;\nconst int mod=1e9+7;\nint n,m,tot;\nint l[maxn+8],r[maxn+8],fac[maxn+8],fact[maxn+8],sum[maxn+8];\nint f[maxn+8][maxn+8];\nchar S[maxn+8];\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k)\n{\n    int sum=1;\n    for (;k;k>>=1,a=1ll*a*a%mod)\n\tif (k&1)\n\t    sum=1ll*sum*a%mod;\n    return sum;\n}\n \nint C(int n,int m){if (n<m) return 0;return 1ll*fac[n]*fact[m]%mod*fact[n-m]%mod;}\n \nint main()\n{\n    n=read(),m=read();\n    scanf(\"%s\",S+1);\n    for (int i=1;i<=m;i++)\n\t{\n\t    int x=read(),y=read();\n\t    if (r[tot]>=y) continue;\n\t    if (l[tot]==x&&r[tot]<y) tot--;\n\t    l[++tot]=x,r[tot]=y;\n\t}\n    l[++tot]=n,r[tot]=n;\n    fac[0]=fact[0]=1;\n    for (int i=1;i<=n;i++) sum[i]=sum[i-1]+(S[i]=='1');\n    for (int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    fact[n]=power(fac[n],mod-2);\n    for (int i=n-1;i;i--) fact[i]=1ll*fact[i+1]*(i+1)%mod;\n    f[0][0]=1;\n    for (int i=1;i<tot;i++)\n\t{\n\t    //printf(\"Time:%d\\n\",i);\n\t    if (l[i+1]>r[i])\n\t\t{\n\t\t    for (int j=0;j<=n;j++)\n\t\t\tf[i][0]=(f[i][0]+1ll*f[i-1][j]*C(r[i]-l[i]+1,j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t    continue;\n\t\t}\n\t    for (int j=0;j<=r[i]-l[i+1]+1;j++)\n\t\t    for (int k=0;k<=min(n,l[i+1]-l[i]+j-sum[r[i]]+sum[max(l[i]-1,r[i-1])]);k++)\n\t\t\t{\n\t\t\t    //printf(\"update:%d %d\\n\",j,k);\n\t\t\t    f[i][j]=(f[i][j]+1ll*f[i-1][k]*C(l[i+1]-l[i],k-j+sum[r[i]]-sum[max(l[i]-1,r[i-1])])%mod)%mod;\n\t\t\t}\n\t}\n    //for (int i=1;i<tot;i++,puts(\"\"))\n    // \tfor (int j=0;j<=n;j++)\n    //\t    \t    printf(\"%d \",f[i][j]);\n    int ans=0;\n    for (int i=0;i<=n;i++) ans=(ans+f[tot-1][i])%mod;\n       printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 7001;\n\n\nint N, M;\nint lastR[MAXN];\nll memo[MAXN][MAXN];\nstring s;\n\n\nvoid input() {\n  cin >> N >> M >> s;\n  s = \" \" + s;\n  for (int i = 1 ; i <= N ; i++) {\n    lastR[i] = i;\n  }\n  int l, r;\n  for (int i = 1 ; i <= M ; i++) {\n    cin >> l >> r;\n    lastR[l] = max(lastR[l], r);\n  }\n  for (int i = 1 ; i <= N ; i++) {\n    lastR[i] = max(lastR[i], lastR[i-1]);\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  int at = 1;\n  memo[1][0] = 1;\n  for(int i = 1 ; i <= N ; i++) {\n    int more = 0;\n    while (at <= lastR[i]) {\n      more += (s[at] == '1');\n      at++;\n    }\n    for (int j = 0 ; j <= N ; j++) {\n      int tot = j + more;\n      if (tot != 0) memo[i+1][tot-1] = modSum(memo[i+1][tot-1], memo[i][j]);\n      if (tot != at-i) memo[i+1][tot] = modSum(memo[i+1][tot], memo[i][j]);\n    }\n  }\n  cout << memo[N+1][0];\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n /+==================================================+\\\n//+--------------------------------------------------+\\\\\n|.|\\\\...>>>>>>> Hollwo_Pelw(ass) 's code <<<<<<<...//|.|\n\\\\+--------------------------------------------------+//\n \\+==================================================+/\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r)        for (int i = l; i < r; i++)\n//#define ForE(i, l, r)       for (int i = l; i <= r; i++)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O\n#define open(file, in, out) if (fopen(file in, \"r\")) {        \\\n                                freopen(file in, \"r\", stdin);  \\\n                                freopen(file out, \"w\", stdout); \\\n                            }\n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calculate\n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 100005, MAXM = 200010;\n// code\n#define int long long\nint dp[3003][3003], n, m, cnt[3003], rmx[3003];\nstring s;\nvoid Solve() {\n    cin >> n >> m >> s;\n    for (int i = 1; i <= n; i++){\n        cnt[i] = cnt[i-1] + s[i-1] - '0';\n        rmx[i] = i;\n    }\n    for (int i = 0, l, r; i < m; i++){\n        cin >> l >> r;\n        rmx[l] = max(rmx[l], r);\n    }\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++){\n        rmx[i] = max({rmx[i], rmx[i-1], i});\n        if (cnt[rmx[i]] < rmx[i] - i + 1)\n            dp[i][0] = dp[i-1][0];\n        for (int j = 1; j <= i; j++){\n            if (cnt[rmx[i]] - j < rmx[i] - i + 1)\n                dp[i][j] = dp[i-1][j];\n            if (cnt[rmx[i]] - j >= 0)\n                (dp[i][j] += dp[i-1][j-1]) %= mod;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= n; i++){\n        (ans += dp[n][i]) %= mod;\n    }\n    cout << ans;\n}\n\nsigned main(){\n    open(\"\", \".inp\", \".out\");\n    FAST_IO; int TC = 1;\n    //cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n/*\n\n./-=====>>><<<-------- DEBUG -------->>><<<=====-\\.\n/.................................................\\\n\n+====================== INP ======================+\n\n\n+====================== OUT ======================+\n\n\n\\................................................./\n.\\-=====>>><<<--------= END =-------->>><<<=====-/.\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 3000 + 10 , P = 1e9 + 7;\nint n , m , l[N] , r[N] , f[N];\nchar s[N];\n\nint main(){\n  scanf(\"%d%d%s\",&n,&m,s+1);\n  rep(i,1,m+1) scanf(\"%d%d\",l+i,r+i);\n  f[0] = 1;\n  int rightmost = -1;\n  rep(i,1,m+1) {\n    int from = l[i - 1] , to = rightmost;\n    while(from <= min(to , l[i] - 1)) {\n      int len = to - from + 1;\n      rep(j,0,n+1) {\n        if(j == len) f[j] = 0;\n        f[j] += f[j + 1];\n        if(f[j] >= P)\n          f[j] -= P;\n      }\n      from++;\n    }\n    from = max(rightmost + 1 , l[i]) , to = r[i];\n    int cnt1 = 0;\n    rep(j,from,to+1) cnt1 += s[j] == '1';\n    per(j,0,n+1) {\n      if(j - cnt1 < 0) f[j] = 0;\n      else f[j] = f[j - cnt1];\n    }\n    rightmost = max(rightmost , r[i]);\n  }\n  int from = l[m] , to = rightmost;\n  while(from <= to) {\n    int len = to - from + 1;\n    rep(j,0,n+1) {\n      if(j == len) f[j] = 0;\n      f[j] += f[j + 1];\n      if(f[j] >= P)\n        f[j] -= P;\n    }\n    from++;\n  }\n  printf(\"%d\\n\",f[0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 3010;\nconst ll MOD = 1000000007;\n\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll comb[MN][MN];\nll dp[MN][MN];\nint tr[MN];\nint num[MN];\n\nint main() {\n\trep(i, 3010) {\n\t\tcomb[i][0] = comb[i][i] = 1;\n\t\tfor (int j = 1; j < i; ++j) {\n\t\t\tcomb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n\t\t}\n\t}\n\n\tint N, M;\n\tstring s;\n\n\tscanf(\"%d %d\", &N, &M);\n\tcin >> s;\n\n\trep(i, N) tr[i] = i;\n\trep(i, N) num[i+1] = num[i] + (s[i] == '0');\n\n\trep(i, M) {\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\t--l; --r;\n\n\t\tfor (int k = l; k <= r; ++k) {\n\t\t\ttr[k] = max(tr[k], r);\n\t\t}\n\t}\n\n\tdp[0][0] = 1;\n\n\tint la = -1;\n\n\trep(i, N) {\n\t\trep(j, MN) if (dp[i][j] != 0) {\n\t\t\tint z = j + num[tr[i]+1] - num[la+1];\n\t\t\tif (z) add(dp[i+1][z-1], dp[i][j]);\n\t\t\tif (z < tr[i] - i + 1) add(dp[i+1][z], dp[i][j]);\n\t\t}\n\t\tla = tr[i];\n\t}\n\n\tcout << dp[N][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define mod 1000000007\n#define maxn 3005\nusing namespace std;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m;\nstruct P{\n    int l,r;\n}p[maxn];\nbool cmp(P a,P b)\n{\n    if(a.l!=b.l)  return a.l<b.l;\n    return a.r<b.r;\n}\nchar s[maxn];\nint a[maxn];\nint fac[maxn],inv[maxn];\nint quick_pow(int x,int p)\n{\n    int an=1,po=x;\n    while(p)\n    {\n        if(p&1)  an=1ll*an*po%mod;\n        po=1ll*po*po%mod;\n        p>>=1;\n    }\n    return an;\n}\nint f[maxn][maxn];\nint get(int i,int j)\n{\n    return max(p[i].r-p[j].l+1,0);\n}\nvoid add(int &x,int y)\n{\n    x+=y;\n    if(x>=mod)  x-=mod;\n}\nint C(int x,int y)\n{\n    if(x<y||x<0||y<0)  return 0;\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint sum[maxn],book[maxn];\nint main()\n{\n    n=read();m=read();\n    fac[0]=1;\n    for(int i=1;i<=n;i++)  fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=quick_pow(fac[n],mod-2);\n    for(int i=n-1;i>=0;i--)  inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=n;i++)  sum[i]=sum[i-1]+(s[i]=='1');\n    for(int i=1;i<=m;i++)  p[i].l=read(),p[i].r=read();\n    sort(p+1,p+m+1,cmp);\n    int top=0;\n    for(int i=1;i<=m;i++)\n    {\n        int flag=0;\n        for(int j=1;j<=m;j++)\n        {\n            if(i==j)  continue;\n            if(p[i].l>=p[j].l&&p[i].r<=p[j].r)\n            {\n                flag=1;\n                break;\n            }\n        }\n        if(!flag)  book[i]=1;\n    }\n    for(int i=1;i<=m;i++)\n      if(book[i])  p[++top]=p[i];\n    m=top;\n    f[0][0]=1;\n    for(int i=1;i<m;i++)\n    {\n        int len=get(i-1,i);\n        if(p[i].r<p[i+1].l)\n        {\n            for(int j=0;j<=len;j++)\n            {\n                add(f[i][0],1ll*f[i-1][j]*C(p[i].r-p[i].l+1,j+sum[p[i].r]-sum[max(p[i-1].r,p[i].l-1)])%mod);\n            }\n        }\n        else{\n            for(int j=0;j<=p[i].r-p[i+1].l+1;j++)\n            {\n                for(int k=0;k<=len;k++)\n                {\n                    add(f[i][j],1ll*f[i-1][k]*C(p[i+1].l-p[i].l,sum[p[i].r]-sum[max(p[i-1].r,p[i].l-1)]+k-j)%mod);\n                }\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<=get(m-1,m);i++)\n    {\n        add(ans,1ll*f[m-1][i]*C(p[m].r-p[m].l+1,i+sum[p[m].r]-sum[max(p[m-1].r,p[m].l-1)])%mod);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nint const MOD=1000000007;\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint n,n_operation;std::cin>>n>>n_operation;\n\n\tstd::vector<int> acm;acm.reserve(n+1);acm.resize(n); // suffix sum accumulation\n\tfor(int& x:acm){\n\t\tchar c;std::cin>>c;\n\t\tx=c-'0';\n\t}\n\tfor(int i=n-1;i--;)\n\t\tacm[i]+=acm[i+1];\n\tacm.push_back(0);\n\n\tauto const sum=[&](int l,int r){return acm[l]-acm[r];};\n\n\n\tstd::vector<std::pair<int,int>> ops;ops.reserve(n_operation+1);\n\tfor(int _=n_operation;_--;){\n\t\tint l,r;std::cin>>l>>r;--l;\n\t\tif(!ops.empty()){\n\t\t\tif(ops.back().first==l){\n\t\t\t\tops.back().second=std::max(ops.back().second,r);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(ops.back().second>=r)\n\t\t\t\tcontinue;\n\t\t}\n\t\tops.push_back({l,r});\n\t}\n\n\tops.push_back({n,n});\n\n\tn_operation=-1;\n\n\tauto const l=[&](int x){return ops[x].first;};\n\tauto const r=[&](int x){return ops[x].second;};\n\n\tstd::vector<std::vector<int>> dp(ops.size());\n\t// dp[i][n] = number of states of the sequence [0,l(i)] after i steps with sum n\n\n\tdp[0].resize(n+1);\n\tdp[0][sum(0,l(0))]=1;\n\n\n\tstd::vector<std::vector<int>> binom(n+1);\n\tbinom[0].assign(1,1);\n\tfor(unsigned i=1;i<binom.size();++i){\n\t\tbinom[i].resize(i+1);\n\t\tstd::copy(begin(binom[i-1]),end(binom[i-1]),begin(binom[i]));\n\t\tstd::transform(begin(binom[i-1]),end(binom[i-1]),++begin(binom[i]),++begin(binom[i]),[](int a,int b){\n\t\t\t\ta+=b;\n\t\t\t\tif(a>=MOD)a-=MOD;\n\t\t\t\treturn a;\n\t\t\t\t});\n\t}\n\n\n\tfor(int i=1;i<(int)ops.size();++i){\n\t\tdp[i].resize(n+1);\n\n\t\tint const mid=std::min(r(i-1),l(i));\n\t\tint const tmp2=sum(0,r(i-1));\n\t\tint const tmp3=l(i)>r(i-1)?sum(r(i-1),l(i)):0;\n\n\t\tint const* const binom_tmp_4=binom[mid-l(i-1)].data();\n\t\tint const* const dp_i_1=dp[i-1].data();\n\n\t\tfor(int x=0;x<=n;++x){\n\t\t\t// x = sum [0,l(i)] after i steps\n\n\t\t\tint ans=0;\n\t\t\tif((x-tmp3)<=tmp2&&tmp2-(x-tmp3)<=r(i-1)-mid){\n\t\t\t\tfor(int y_=std::max((x-tmp3)-mid+l(i-1),0)-x;y_<=-tmp3;++y_){\n\t\t\t\t\tans=(ans+(int64_t)dp_i_1[y_+x]*binom_tmp_4[-tmp3-y_])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][x]=ans;\n\t\t}\n\t}\n\n\tstd::cout<<dp[ops.size()-1][sum(0,n)]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x, ll n){\n    ll res = 1;\n    ll mul = x;\n    while(n){\n        if(n % 2) res = res * mul % MOD;\n        mul = mul * mul % MOD;\n        n /= 2;\n    }\n    return res;\n}\n\nstruct Combination\n{\n    int maxn;\n    vector<ll> fmemo;\n    vector<ll> imemo;\n    vector<ll> ifmemo;\n    \n    Combination(int maxn) : maxn(maxn){\n        fmemo.resize(maxn + 1);\n        imemo.resize(maxn + 1);\n        ifmemo.resize(maxn + 1);\n        for(ll i = 1; i <= maxn; i++){\n            imemo[i] = modpow(i, MOD - 2);\n        }\n    }\n\n    ll fact(ll n){\n        if(n == 0) return 1;\n        if(fmemo[n]) return fmemo[n];\n        return fmemo[n] = n * fact(n - 1) % MOD;\n    }\n\n    ll ifact(ll n){\n        if(n == 0) return 1;\n        if(ifmemo[n]) return ifmemo[n];\n        return ifmemo[n] = imemo[n] * ifact(n - 1) % MOD;\n    }\n\n    ll com(ll n, ll k){\n        if(k > n) return 0;\n        if(k < 0) return 0;\n        if(n < 0) return 0;\n        if(k == n || k == 0) return 1;\n        return (fact(n) * ifact(k) % MOD) * ifact(n - k) % MOD;\n    }\n};\n\nll dp[3002][3002];\nint l[3002], r[3002];\nint b[3002];\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    l[0] = r[0] = -1;\n    for(int i = 1; i <= m; i++){\n        cin >> l[i] >> r[i];\n        l[i]--;\n        if(i){\n            if(r[i] <= r[i - 1]){\n                m--;\n                i--;\n            }\n            else if(l[i] == l[i - 1]){\n                r[i - 1] = r[i];\n                m--;\n                i--;\n            }\n        }\n    }\n    l[m + 1] = r[m + 1] = MOD;\n    for(int i = 1; i <= n; i++){\n        b[i] = b[i - 1] + (s[i - 1] - '0');\n    }\n    Combination com(n);\n    dp[0][0] = 1;\n    for(int i = 1; i <= m; i++){\n        int d = b[r[i]] - b[max(r[i - 1], l[i])];\n        for(int j = 0; j <= max(0, r[i] - l[i + 1]); j++){\n            for(int k = 0; k <= max(0, r[i - 1] - l[i]); k++){\n                dp[i][j] = (dp[i][j] + dp[i - 1][k] * com.com(min(l[i + 1], r[i]) - l[i], d + k - j) % MOD) % MOD;\n            }\n        }\n    }\n    cout << dp[m][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=3005;\nconst int MOD=1e9+7;\n\nint n,m;\nint d[MAXN][MAXN],right[MAXN],sum[MAXN];\nchar s[MAXN];\n\nint main(){\n    scanf(\"%d%d%s\",&n,&m,s+1);\n    for(int i=1;i<=n;i++) sum[i]=s[i]-'0';\n    for(int i=1;i<=n+1;i++) sum[i]+=sum[i-1];\n    for(int i=1;i<=n+1;i++) right[i]=i;\n    for(int i=1;i<=m;i++){\n        int l,r;\n        scanf(\"%d%d\",&l,&r);\n        right[l]=max(right[l],r);\n    }\n    for(int i=1;i<=n;i++)\n        right[i]=max(right[i],right[i-1]);\n    d[1][sum[right[1]]]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=n;j++){\n            if(d[i][j]){\n                int l=right[i]+1,r=right[i+1];\n                int x=j,y=right[i]-i+1-j;\n                if(x) (d[i+1][j-1+sum[r]-sum[l-1]]+=d[i][j])%=MOD;\n                if(y) (d[i+1][j+sum[r]-sum[l-1]]+=d[i][j])%=MOD;\n            }\n        }\n    printf(\"%d\\n\",(d[n+1][0]+MOD)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t3005\n#define P\t1000000007\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, tmpm, l[MAXN], r[MAXN], sum[MAXN];\nint len[MAXN], tail[MAXN], head[MAXN];\nlong long fac[MAXN], inv[MAXN], dp[MAXN][MAXN];\nchar s[MAXN];\nvoid update(long long &x, long long y) {\n\tx = (x + y) % P;\n}\nlong long power(long long x, long long y) {\n\tif (y == 0) return 1;\n\tlong long tmpmp = power(x, y / 2);\n\tif (y % 2 == 0) return tmpmp * tmpmp % P;\n\telse return tmpmp * tmpmp % P * x % P;\n}\nlong long getc(long long x, long long y) {\n\treturn fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int N) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tfac[i] = fac[i - 1] * i % P;\n\tinv[N] = power(fac[N], P - 2);\n\tfor (int i = N - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % P;\n}\nint Sum(int l, int r) {\n\treturn sum[r] - sum[l - 1];\n}\nint main() {\n\tread(n), read(tmpm);\n\tinit(n);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + (s[i] == '1');\n\tfor (int i = 1; i <= tmpm; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\tif (x == l[m]) r[m] = max(r[m], y);\n\t\telse if (y > r[m]) {\n\t\t\tm++;\n\t\t\tl[m] = x;\n\t\t\tr[m] = y;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tlen[i] = r[i] - l[i] + 1;\n\t\thead[i] = min(l[i + 1] - l[i], len[i]);\n\t\ttail[i] = Sum(max(l[i], r[i - 1] + 1), r[i]);\n\t}\n\tdp[1][Sum(l[1], r[1])] = 1;\n\tfor (int i = 2; i <= m; i++)\n\tfor (int j = tail[i]; j <= len[i]; j++) {\n\t\tint unused = j - tail[i];\n\t\tif (unused && unused > r[i - 1] - l[i] + 1) continue;\n\t\tfor (int k = 0; k <= head[i - 1]; k++)\n\t\t\tupdate(dp[i][j], dp[i - 1][k + unused] * getc(head[i - 1], k));\n\t}\n\tlong long finalans = 0;\n\tfor (int j = tail[m]; j <= len[m]; j++)\n\t\tupdate(finalans, dp[m][j] * getc(len[m], j));\n\tcout << finalans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 3e3 + 5;\nconst int mod = 1e9 + 7;\nint n, m;\n\nchar s[maxn];\n\nint sum[maxn];\nint last[maxn];\n\nlong long dp[maxn][maxn], res;\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n >> m;\n\n    cin >> s + 1;\n\n    for(int i=1;i<=n;++i)\n    {\n        sum[i] = sum[i-1];\n        if( s[i] == '1' ) sum[i] ++;\n    }\n\n    for(int i=1;i<=n;++i) last[i] = i;\n\n    for(int i=1;i<=m;++i)\n    {\n        int x, y;\n        cin >> x >> y;\n        last[x] = max(last[x], y);\n    }\n    for(int i=1;i<=n;++i) last[i] = max(last[i], last[i-1]);\n\n    dp[0][0] = 1;\n\n    for(int i=1;i<=n;++i)\n    {\n        int tung = last[i];\n        if(tung - i + 1 > sum[tung] )  dp[i][0] = dp[i-1][0] % mod;\n\n        for(int j=1;j<=i;++j)\n        {\n            if( tung - i + 1 > sum[tung] - j ) dp[i][j] = dp[i-1][j] % mod;\n            if( sum[tung] >= j ) dp[i][j] = ( dp[i][j] + dp[i-1][j-1] ) % mod;\n        }\n    }\n\n    for(int i=1;i<=n;++i) res = ( res + dp[n][i] ) % mod;\n\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-11-04  19:01:50\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 3003\nusing namespace std;\nconst int Mod = 1e9 + 7;\n\ninline void inc(int &x, int y) {\n    x += y, x -= x >= Mod ? Mod : 0;\n}\n\nint n, m, f[N][N], l[N], r[N], sum[N], c[N][N];\nchar s[N];\n\ninline int C(int x, int y) {\n    return x < 0 || y < 0 || x < y ? 0 : c[x][y];\n}\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n\n    for (int i = 0; i <= n; ++i) {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % Mod;\n    }\n\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= n; ++i)\n        sum[i] = sum[i - 1] + (s[i] == '1');\n\n    int top = 0;\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (v > r[top]) l[++top] = u, r[top] = v;\n    } m = top;\n\n    l[m + 1] = r[m + 1] = n + 1;\n\n    f[0][0] = 1;\n\n    for (int i = 1, sz; i <= m; ++i) {\n        if (l[i + 1] <= r[i]) {\n            sz = r[i] - l[i + 1] + 1;\n            for (int j = 0; j <= sz; ++j)\n                for (int k = 0, S = (l[i] <= r[i - 1] ? r[i - 1] - l[i] + 1 : 0); k <= S; ++k) {\n                    if (j < k + sum[r[i]] - sum[r[i - 1]] - l[i + 1] + l[i]) continue;\n                    inc(f[i][j], 1ll * f[i - 1][k] * C(l[i + 1] - l[i], k + sum[r[i]] - sum[r[i - 1]] - j) % Mod);\n                }\n        } else {\n            for (int k = 0, S = (l[i] <= r[i - 1] ? r[i] - l[i] + 1 : 0); k <= S; ++k)\n                inc(f[i][0], 1ll * f[i - 1][k] * C(r[i] - l[i] + 1, k + sum[r[i]] - sum[max(r[i - 1], l[i] - 1)]) % Mod);\n        }\n    }\n    \n    cout << f[m][0] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n\n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nint n, r, arr[3005], DP[3005][3005], cnt[3005][2];\nchar str[3005];\n\n\nll dp(int i, int ones){\n\n\tif(i == r)\treturn 1;\n\tif(DP[i][ones] != -1)\treturn DP[i][ones];\n\n\tint zeroes = (arr[i]-i+1) - ones;\n\tll ans = 0;\n\tif(ones > 0){\n\t\tans += dp(i+1, (ones-1)+(cnt[arr[i+1]][1]-cnt[arr[i]][1]));\n\t\tans %= MOD;\n\t}\n\tif(zeroes > 0){\n\t\tans += dp(i+1, ones+(cnt[arr[i+1]][1]-cnt[arr[i]][1]));\n\t\tans %= MOD;\n\t}\n// cout<<\"dp \"<<i<<\" \"<<ones<<\" returns \"<<ans<<endl;\n\treturn DP[i][ones] = ans;\n}\n\n\n\nint main(){\n\n    ios_base::sync_with_stdio(0);\n\n    int m;\n    cin>>n>>m;\n    cin>>(str+1);\n\n    for(int i=1;i<=n;i++){\n    \tcnt[i][0] = cnt[i-1][0];\n    \tcnt[i][1] = cnt[i-1][1];\n    \tcnt[i][str[i]-'0']++;\n    \tarr[i] = i;\n    }\n\n    while(m--){\n    \tint a, b;\n    \tcin>>a>>b;\n    \tfor(int i=a;i<=b;i++)\n    \t\tarr[i] = max(arr[i], b);\n    }\n\n// for(int i=1;i<=n;i++)\tcout<<arr[i]<<\" \";cout<<endl;\n\n    memset(DP, -1, sizeof(DP));\n    ll ans = 1;\n    int i = 1;\n    while(i <= n){\n\n    \tif(arr[i] == i){\n    \t\ti++;\n    \t\tcontinue;\n    \t}\n\n    \tr = arr[i];\n    \tint j = i;\n    \twhile(j <= r){\n    \t\tr = max(r, arr[j]);\n    \t\tj++;\n    \t}\n\n    \tans = (ans * dp(i, cnt[arr[i]][1]-cnt[i-1][1])) % MOD;\n    \ti = j;\n    }\n\n    cout<<ans;\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MOD 1000000007\nusing namespace std;\nconst int MAXN = 3005;\nint f[MAXN][MAXN],n,m,r[MAXN];\nint sum[MAXN];\nchar s[MAXN];\ninline void add(int &x,int a)\n{\n\tx+=a;\n\tif(x>=MOD)x-=MOD;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=n;++i)r[i]=i,sum[i]=sum[i-1]+s[i]-'0';\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tr[x]=max(r[x],y);\n\t}\n\tfor(int i=1;i<=n;++i)r[i]=max(r[i],r[i-1]);\n\tf[1][sum[r[1]]]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\tif(!f[i][j])continue;\n\t\t\tint baseline=sum[r[i+1]]-sum[r[i]];\n\t\t\tif(j<r[i]-i+1)add(f[i+1][baseline+j],f[i][j]);\n\t\t\tif(j>=1)add(f[i+1][baseline+j-1],f[i][j]);\n\t\t}\n\t}\n\tcout<<(f[n][0]+f[n][1])%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)x.size()\n#define f first\n#define s second\n#define MAXN 3010\nll MOD = 1e9+7;\n\nll A[MAXN];\nll N,K,a,b;\nll E[MAXN];\nstring S;\nvpi V;\nll memo[MAXN][MAXN];\nll overlap[MAXN];\nll fact[MAXN];\nll invfact[MAXN];\n\nll exp(ll a, ll b){\n\tif (b==0)return 1;\n\tll c = exp(a,b/2);\n\tc = (c*c)%MOD;\n\tif (b%2)c=(c*a)%MOD;\n\treturn c;\n}\n\nll inv(ll x){\n\treturn exp(x, MOD-2);\n}\n\nll C(ll a, ll b){\n\treturn (fact[a] * invfact[a-b]) %MOD * invfact[b]%MOD;\n}\n\nint main(){\n\tcin>>N>>K>>S;\n\tfact[0] = 1;\n\tfor (int i=1;i<=N;++i)fact[i] = (fact[i-1]*i)%MOD;\n\tfor (int i=0;i<=N;++i)invfact[i] = inv(fact[i]);\n\n\tfor (int i=1;i<=N;++i){\n\t\tif (S[i-1] == '1')A[i] = 1;\n\t\tA[i] += A[i-1];\n\t}\n\tfor (int i=0;i<K;++i){\n\t\tcin>>a>>b;\n\t\tE[a] = max(E[a], b);\n\t}\n\tV.pb(-1,-1);\n\tfor (int i=1;i<=N;++i)if(E[i]){\n\t\tif (SZ(V) && V.back().s >= E[i])continue;\n\t\tV.pb(i,E[i]);\n\t}\n\tfor (int i=1;i<SZ(V)-1; ++i){\n\t\toverlap[i] = max(0LL,V[i].s - V[i+1].f + 1);\n\t}\n\n\t// for (int i=1;i<SZ(V);++i)cout<<overlap[i]<<' ';\n\t// cout<<'\\n';\n\n\tmemo[0][0] = 1;\n\tfor (int i=1;i<SZ(V);++i){\n\t\t// cout<<\"Hi\\n\";\n\t\tint s = max(V[i].f, V[i-1].s+1);\n\t\tint e = V[i].s;\n\t\t// cout<<\"R \"<<s<<' '<<e<<' '<<A[e]-A[s-1]<<'\\n';\n\t\tint l = V[i].s - V[i].f + 1;\n\t\tfor (int j=0;j<=overlap[i-1];++j){\n\t\t\tfor (int k=0;k<=overlap[i];++k){\n\t\t\t\tint ones = j + A[e] - A[s-1];\n\t\t\t\t// cout<<ones<<'\\n';\n\t\t\t\tint zeroes = l - ones;\n\t\t\t\tif (ones < k)continue;\n\t\t\t\tif (zeroes + k > l)continue;\n\t\t\t\tmemo[i][k] += (memo[i-1][j] * C(l-overlap[i], ones-k))%MOD;\n\t\t\t\tmemo[i][k]%=MOD;\n\t\t\t}\n\t\t}\n\t\tll t=0;\n\t\tfor (int k=0;k<=overlap[i];++k)t=(t+memo[i][k])%MOD;\n\t\tif (overlap[i] == 0)memo[i][0] = t;\n\t\tif (i+1==SZ(V))cout<<t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp                  make_pair\n#define pb                  push_back\n#define f                   first\n#define s                   second\n#define F                   first\n#define S                   second\n#define clr(a, b)           memset(a, b, sizeof(a))\n#define fore(i, b, e)       for(ll i = b; i < e; i++)\n#define forr(i, b, e)       for(ll i = b; i < e; i++)\n#define forg(i, b, e,au)    for(ll i = b; i < e; i+=au)\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\nconst ll tam = 3000;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\nint sum[tam],nxt[tam];\nint dp[tam][tam];\nvoid MODUL(int &num)\n{\n    while(num>=MOD)num-=MOD;\n}\nint main()\n{\n    int n,m;\n    cin>>n>>m;\n    string txt;\n    cin>>txt;\n    sum[0]=0;\n    forr(i,0,txt.size())\n    {\n        sum[i+1]=sum[i]+txt[i]-'0';\n    }\n    sum[n+1]=sum[n];\n    int iz,der;\n    forr(i,0,tam)\n        nxt[i]=i;\n    forr(i,0,m)\n    {\n        cin>>iz>>der;\n        forr(j,iz,der+1)\n        {\n            nxt[j]=max(nxt[j],der);\n        }\n    }\n    int cantini=sum[nxt[1]],R,newR,nuevo;\n    dp[1][cantini]=1;\n    int c0,c1;\n    forr(L,1,n+1)\n    {\n        R=nxt[L];\n        newR=nxt[L+1];\n        nuevo=sum[newR]-sum[R];\n        forr(c,0,n+1)\n        {\n            c0=R-L+1-c;\n            c1=c;\n            if (c0>0)\n                dp[L+1][c+nuevo]+=dp[L][c],MODUL(dp[L+1][c+nuevo]);\n            if (c1>0)\n                dp[L+1][c+nuevo-1]+=dp[L][c],MODUL(dp[L+1][c+nuevo-1]);\n        }\n    }\n    cout<<dp[n+1][0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=3005,md=1e9+7;\nint f[N][N],rg[N],pre[N],n,m;\nchar ss[N];\ninline void upd(int&a){a+=a>>31&md;}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ss+1);\n\tfor(int i=1;i<=n;++i)pre[i]=pre[i-1]+ss[i]-48,rg[i]=i;\n\tfor(int i=1;i<=m;++i){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(rg[l]<r)rg[l]=r;\n\t}\n\tfor(int i=2;i<=n+1;++i)if(rg[i-1]>rg[i])rg[i]=rg[i-1];\n\tf[1][pre[rg[1]]]=1;\n\tfor(int i=1;i<=n;++i)\n\tfor(int _1=0;_1<=n;++_1)\n\tif(int d=f[i][_1]){\n\t\tint s1=pre[rg[i+1]]-pre[rg[i]],_0=rg[i]-i+1-_1;\n\t\tif(_1)upd(f[i+1][_1-1+s1]+=d-md);if(_0)upd(f[i+1][_1+s1]+=d-md);\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=3005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint L[MAXN],R[MAXN],n,m,pos[MAXN],pos1[MAXN];\nchar ch[MAXN];\nint f[MAXN][MAXN];\nvoid wr(int msk,int L)\n{\n\tfor(int i=1;i<=L;i++)putchar(msk&(1<<(i-1))?'1':'0');puts(\"\");\n}\nint main()\n{\n\tn=read();m=read();int total=0,total0=0;\n\tscanf(\"%s\",ch+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(ch[i]=='1')pos[++total]=i;\n\t\telse pos1[++total0]=i;\n\t}\n\tfor(int i=1;i<=n;i++)L[i]=R[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint l=read(),r=read();\n\t\tfor(int j=l;j<=r;j++)chkmin(L[j],l),chkmax(R[j],r);\n\t}\n\tf[0][0]=1;\n\tfor(int i=0;i<n;i++)for(int j=0;j<=i&&j<=total;j++)if(f[i][j])\n\t{\n\t\tif(i+1-j<=total0&&L[pos1[i+1-j]]<=i+1)ad(f[i+1][j],f[i][j]);\n\t\tif(j+1<=total&&L[pos[j+1]]<=i+1)ad(f[i+1][j+1],f[i][j]);\n\t}pr2(f[n][total]);\n//\tLL S=0;\n//\tfor(int i=0;i<(1<<n);i++)if(__builtin_popcount(i)==total)\n//\t{\n//\t\tbool flag=true;\n//\t\tfor(int j=1,t1=0,t2=0;j<=n;j++)\n//\t\t{\n//\t\t\tif(i&(1<<(j-1)))++t1,flag&=(L[pos[t1]]<=j);\n//\t\t\telse ++t2,flag&=(L[pos1[t2]]<=j);\n//\t\t}\n//\t\tif(!flag)continue;\n//\t\twr(i,n);S+=flag;\n//\t}pr2(S);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//・途中のS(S1, S2)について{処理したクエリの個数, 今見てる区間に含まれる1の個数}が同じなら, S2はないものとしてよい。\n//・今見てる区間より左側を「何パターン作れるか？」が重要。\n//・クエリを変形すると → l_i+1 = l_i + 1, r_i+1 ≧ r_iを満たすクエリにできる。\n//あとは、0を追い出すか？1を追い出すか？を適当に試すだけで解ける。(DPで適当に状態をまとめるだけ)\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#define int long long\nusing namespace std;\n\nconst int mod = 1000000007;\nint n, m;\nstring s;\nint rui[3001];\nvector<int> r;\nint dp[3001][3001];\t\t//dp[処理したクエリ数][今見てる区間よりも左側にある1の個数] = 今見てる区間の左側が何パターンあるか？\n\nvector<int> input() {\n\tint l[3000], r[3000];\n\tint maxR[3001] = {0};\n\t\n\tcin >> n >> m >> s;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> l[i] >> r[i];\n\t\tmaxR[l[i]] = max(maxR[l[i]], r[i]);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tmaxR[i] = max(maxR[i - 1], max(i, maxR[i]));\n\t}\n\t\n\tvector<int> ret;\t//0-indexed\n\tfor (int i = 1; i <= n; i++) {\n\t\tret.push_back(maxR[i] - 1);\n\t}\n\treturn ret;\n}\n\nsigned main() {\n\tr = input();\n\tfor (int i = 1; i <= n; i++) rui[i] = rui[i - 1] + (s[i - 1] - '0');\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= i; j++) {\n\t\t\tint iti  = rui[r[i] + 1] - j;\n\t\t\tint zero = r[i] + 1 - i - iti;\n\t\t\t\n\t\t\tif (iti > 0) {\n\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\tdp[i + 1][j + 1] %= mod;\n\t\t\t}\n\t\t\tif (zero > 0) {\n\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\tdp[i + 1][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][rui[n]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=3010;\nconst int yql=1e9+7;\nusing namespace std;\nint a[N],dp[N][N],n,m,s[N];\nchar p[N];\ninline int read(){\n\tint f=1,x=0;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn f*x;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\"%s\",p+1);\n\tfor(int i=1;i<=n;i++){a[i]=i;s[i]=s[i-1];if(p[i]=='1')s[i]++;}\n\t//for(int i=1;i<=n;i++)printf(\"%d%c\",s[i],i==n?'\\n':' ');\n\tfor(int i=1;i<=m;i++){\n\t\tint l=read(),r=read();\n\t\tfor(int j=l;j<=r;j++)a[j]=max(a[j],r);\n\t}\n\tdp[0][0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tif(j>s[a[i]])continue;\n\t\t\tif(i-j>a[i]-s[a[i]])continue;\n\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\tif(j)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%yql;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][s[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll dp[3002][3002];\nll ps[5000];\nll cnk[3002][3002];\nll R[5000];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cin >> s;\n    s = \"0\" + s;\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = i;\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll l, r;\n        cin >> l >> r;\n        R[l] = max(R[l], r);\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        R[i] = max(R[i], R[i - 1]);\n    }\n    dp[1][summ(1, R[1])] = 1;\n    for (int p = 1; p <= n; p++)\n    {\n        if (p > 1 && R[p] > R[p - 1])\n        {\n            for (int j = n; j >= summ(R[p - 1] + 1, R[p]); j--)\n            {\n                dp[p][j] = dp[p][j - summ(R[p - 1] + 1, R[p])];\n                if (summ(R[p - 1] + 1, R[p]) != 0)\n                    dp[p][j - summ(R[p - 1] + 1, R[p])] = 0;\n            }\n        }\n        for (int c = 0; c <= n; c++)\n        {\n            if (R[p] - (p + 1) + 1 >= c)\n            {\n                dp[p + 1][c] = (dp[p][c] + dp[p][c + 1]) % MOD;\n            }\n        }\n    }\n    cout << (dp[n][1] + dp[n][0]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\n#define x first\n#define y second\n#define MOD 1000000007\n#define NMAX 3005\n\nint n, m, d[NMAX][NMAX], ones;\nchar s[NMAX];\npair<int,int> interval[NMAX];\n\nstruct segTree{\n    int sum, lazy;\n};\n\nsegTree aintL[4 * NMAX], aintR[4 * NMAX];\n\nvoid updateNode(segTree aint[], int n, int left, int right, int val){\n    aint[n].sum= (right - left + 1) * val;\n    aint[n].lazy = val;    \n}\n\nvoid update(segTree aint[], int n, int left, int right, int a, int b, int val){\n    if(a <= left  && right <= b){\n        updateNode(aint, n, left, right, val);\n        return ;\n    }\n    int mid = (left + right) / 2;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        update(aint, 2 * n, left, mid, a, b, val);\n    if(b > mid)\n        update(aint, 2 * n + 1, mid + 1, right, a, b, val);\n    aint[n].sum = aint[2 * n].sum + aint[2 * n + 1].sum;\n}\n\nint queryCount(segTree aint[], int n, int left, int right, int a, int b){\n    if(a <= left && right <= b){\n        return aint[n].sum;\n    }\n    int mid = (left + right) / 2, ans1 = 0, ans2 = 0;\n    if(aint[n].lazy != -1){\n        updateNode(aint, 2 * n, left, mid, aint[n].lazy);\n        updateNode(aint, 2 * n + 1, mid + 1, right, aint[n].lazy);\n        aint[n].lazy = -1;\n    }\n    if(a <= mid)\n        ans1 = queryCount(aint, 2 * n, left, mid, a, b);\n    if(b > mid)\n        ans2 = queryCount(aint, 2 * n + 1, mid + 1, right, a, b);\n    return ans1 + ans2;\n}\n\nint main (){\n    pair<int,int> seg;\n    \n    scanf(\"%d%d\\n\",&n,&m);\n    scanf(\"%s\",s + 1);\n    for(int i = 1; i <= n; i++){\n        update(aintL, 1, 1, n, i, i, s[i] - '0');\n        update(aintR, 1, 1, n, i, i, s[i] - '0');\n    }\n    for(int i = 1; i <= m; i++){\n        scanf(\"%d%d\",&seg.x,&seg.y);\n        int cnt = queryCount(aintL, 1, 1, n, seg.x, seg.y);\n        update(aintL, 1, 1, n, seg.x, seg.x + cnt - 1, 1);\n        update(aintL, 1, 1, n, seg.x + cnt, seg.y, 0);\n        \n        cnt = queryCount(aintR, 1, 1, n, seg.x, seg.y);\n        update(aintR, 1, 1, n, seg.x, seg.y - cnt, 0);\n        update(aintR, 1, 1, n, seg.y - cnt + 1, seg.y, 1);\n    }\n    \n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintL, 1, 1, n, i, i)){\n            interval[++ones].x = i;\n        }\n    }\n    ones = 0;\n    for(int i = 1; i <= n; i++){\n        if(queryCount(aintR, 1, 1, n, i, i)){\n            interval[++ones].y = i;\n        }\n    }\n    \n    d[0][0] = 1;\n    for(int i = 1; i <= n; i++)\n        for(int j = 0; j <= ones; j++){\n            d[i][j] = d[i - 1][j];\n            if(interval[j].x <= i && i <= interval[j].y)\n                d[i][j] += d[i - 1][j - 1];\n            if(d[i][j] >= MOD)\n                d[i][j] -= MOD;\n        }\n    printf(\"%d\\n\", d[n][ones]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector <ll> vi;\ntypedef vector <pi> vpi;\n#define f first\n#define s second\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\n#define aFOR(i,x) for (auto i: x)\n#define mem(x,i) memset(x,i,sizeof x)\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\n#define maxn 3001\n#define MOD 1000000007\n#define int ll\nint N,M;\nstring S;\n\nint A[maxn];\n\nint dp[maxn][maxn];\nint ss[maxn];\n\ninline pi inter(pi i,pi j){\n\treturn pi(max(i.f,j.f),min(i.s,j.s));\n}\ninline int sz(pi i){\n\treturn i.s - i.f + 1;\n}\n\n\ninline int qry(pi i){\n\tif (i.f == 0) return ss[i.s];\n\treturn ss[i.s] - ss[i.f-1];\n}\n\n\nint dpf(int i,int j,int k){\n\t//cout<<i<<' '<<j<<' '<<k<<'\\n';\n\tif (k > sz(pi(i,j))) return 0;\n\tif (k < 0) return 0;\n\tif (A[i] > j){\n\t\tk += qry(pi(j + 1, A[i]));\n\t\tj = A[i];\n\t}\n\t\n\tif (dp[i][k] != -1) return dp[i][k];\n\t\n\t\n\t\n\t\n\t\n\tif (i == N) return 1;\n\t\n\t\n\t\n\n\n\tif (k > 0) return dp[i][k] = (dpf(i+1,j,k-1) + dpf(i+1,j,k)) % MOD;\n\telse return dp[i][k] = dpf(i+1,j,k);\n}\n\nint32_t main(){\n\tfast;\n\t\n\tcin>>N>>M>>S;\n\n\tstack <pi> st;\n\t\n\tFOR(i,0,M-1){\n\t\tint a,b; cin>>a>>b;\n\t\t\n\t\twhile (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(st.top())) st.pop();\n\n\t\tif (!st.empty() && sz(inter(st.top(),pi(a,b))) == sz(pi(a,b))) continue;\n\t\tst.push(pi(a,b));\n\t}\n\t\n\tM = st.size();\n\tFOR(i,0,N-1) A[i] = i;\n\t\n\tDEC(i,M-1,0){\n\t\tA[st.top().f - 1] = st.top().s - 1;\n\t\tst.pop();\n\t}\n\t\n\tif (S[0] == '1') ss[0] = 1;\n\telse ss[0] = 0;\n\t\n\tFOR(i,1,N-1){\n\t\tif (S[i] == '1') ss[i] = ss[i-1] + 1;\n\t\telse ss[i] = ss[i-1];\n\t}\n\tmem(dp,-1);\n\t\n\tcout<<dpf(0,A[0],qry(pi(0,A[0])));\n\t\n\t\n\t\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define pb push\n#define mp make_pair\n#define X first\n#define Y second\n#define Mad(a,b) a=(a+b)%mod;\ntypedef long long ll;\n\nusing namespace std;\ntypedef pair<ll,ll> P;\nqueue<P> Q;\n#define N 3010\nll n,m,d[2][N];string s;\nint main(){\n    cin>>n>>m>>s;\n    Q.pb(mp(0,0));\n    while(m--){\n\tll a,b;cin>>a>>b;\n\tif(Q.back().Y<b)Q.pb(mp(a,b));\n    }\n    lol(i,N)lol(j,2)d[j][i]=0;d[0][0]=1;\n    for(ll i=0,rnd=0,bef=0;i<=n;i++){\n\tll cnt=0;\n\twhile(!Q.empty()){\n\t    if(not(Q.front().X<=i))break;\n\t    for(ll j=bef;j<rnd;j++)cnt+=s[j]-'0';\n\t    bef=rnd;Q.pop();rnd=Q.front().Y;\n\t}\n\tlol(j,N)d[1^i&1][j]=0;\n\tll lim=max(0LL,bef-i);\n\tfor(ll j=cnt;j<=lim;j++)Mad(d[1^i&1][j],d[i&1][j-cnt]);\n\tfor(ll j=cnt;j<=lim;j++)Mad(d[1^i&1][j],d[i&1][j-cnt+1]);\n    }\n    cout<<d[1^n&1][0]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n\n\nint n, m, a, b, r[3030], c[3030], dp[3030][3030];\nstring s;\n\nsigned main() {\n\tcin >> n >> m >> s;\n\trep(i,n) c[i+1] = s[i]-'0' + (i ? c[i] : 0);\n\trep(i,3030) r[i] = i;\n\trep(i,m) {\n\t\tcin >> a >> b;\n\t\treps(j,a,b+1) chmax(r[j],b);\n\t}\n\tdp[0][0] = 1;\n\treps(i,1,n+1) rep(j,min(c[r[i]],i)+1) {\n\t\t// [0,r[i]] 0-count\n\t\tif (r[i]-c[r[i]]<i-j) continue;\n\t\t// i文字目を0に\n\t\tdp[i][j] = dp[i-1][j];\n\t\t// i文字目を1に\n\t\tif (j) (dp[i][j] += dp[i-1][j-1]) %= mod;\n\t}\n\tcout << dp[n][c[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int Max=3e3;\nconst long long Mod=1e9+7;\n#define int long long\nint n,m,f[Max+10][Max+10]={},c[Max+10][Max+10]={},b[Max+10]={},l[Max+10]={},r[Max+10]={};\nstruct kk{\n    int l,r,v;\n} e[Max+10]={};\nchar a[Max+10]={};\nmain(){\n // freopen(\"a.in\",\"r\",stdin);\n//  freopen(\"a.out\",\"w\",stdout);\n    scanf(\"%lld%lld\",&n,&m);\n    scanf(\"%s\",a+1);\n    for(int i=1;i<=n;i++)\n     b[i]=b[i-1]+(a[i]=='1');\n    c[0][0]=c[0][1]=c[1][1]=1;\n    for(int i=2;i<=Max;i++){\n        c[0][i]=c[i][i]=1;\n        for(int j=1;j<i;j++)\n         c[j][i]=(c[j-1][i-1]+c[j][i-1])%Mod;\n    }\n    int Max=0;\n    for(int i=1;i<=m;i++) {\n        scanf(\"%d%d\",&e[i].l,&e[i].r);\n    }\n    for(int i=1;i<=m;i++)\n     for(int j=1;j<=m;j++)\n      if(i!=j&&e[j].l>=e[i].l&&e[j].r<=e[i].r&&!e[i].v) e[j].v=1;\n    int s=0;\n    for(int i=1;i<=m;i++)\n     if(!e[i].v) ++s,l[s]=e[i].l,r[s]=e[i].r;\n    m=s;\n    f[0][0]=1;\n    for(int i=1;i<m;i++){\n        if(l[i+1]>r[i]){\n            for(int j=0;j<=n;j++)\n             f[i][0]+=f[i-1][j]*c[j+b[r[i]]-b[max(r[i-1],l[i]-1)]][r[i]-l[i]+1]%Mod,f[i][0]%=Mod;\n        }else{\n            for(int j=0;j<=r[i]-l[i+1]+1;j++)\n             for(int k=0;k<=n;k++)\n              if(k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j>=0){\n                f[i][j]+=f[i-1][k]*c[k+b[r[i]]-b[max(r[i-1],l[i]-1)]-j][l[i+1]-l[i]]%Mod,f[i][j]%=Mod;\n              }\n        }\n    }    \n    int ans=0; \n     for(int i=0;i<=n;i++)\n      ans+=f[m-1][i]*c[i+b[r[m]]-b[max(r[m-1],l[m]-1)]][r[m]-l[m]+1]%Mod,ans%=Mod;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            cout<<x<<\"/\"<<y<<endl;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\nvector<l_l>convert(vector<l_l>v){\n    vector<l_l>r;\n    ll n=v.size();\n    rep(i,0,n-1){\n        if(i==n-1||v[i].fi!=v[i+1].fi)r.pb(v[i]);\n        else if(v[i]>v[i+1])swap(v[i],v[i+1]);\n    }\n    n=r.size();\n    vector<l_l>res;\n    ll mx=-inf;\n    rep(i,0,n-1){\n        if(chmax(mx,r[i].se)){\n            res.pb(r[i]);\n        }\n    }\n    return res;\n}\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 2000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\n\nint main(){fastio\n    calc();\n    ll n,m;cin>>n>>m;\n    string s;cin>>s;\n    vector<l_l>v(m);\n    rep(i,0,m-1){\n        cin>>v[i].fi>>v[i].se;\n        v[i].fi--;v[i].se--;\n    }\n    v=convert(v);\n   // for(auto x:v)cout<<x.fi<<\" \"<<x.se<<endl;cout<<\"***\"<<endl;\n    m=v.size();\n    ll cnt[n+1];\n    cnt[0]=0;\n    rep(i,0,n-1){\n        cnt[i+1]=cnt[i]+s[i]-'0';\n    }\n    ll dp[m+1][n+1];memset(dp,0,sizeof(dp));\n    dp[0][0]=1;\n    rep(i,0,m-1){\n        ll ad=(i==0?cnt[v[i].se+1]-cnt[v[i].fi]:cnt[v[i].se+1]-max(cnt[v[i].fi],cnt[v[i-1].se+1]));\n        ll sp=(i==m-1?v[i].se+1-v[i].fi:min(v[i+1].fi,v[i].se+1)-v[i].fi);\n        rep(j,0,n){\n            if(dp[i][j]==0)continue;\n            rep(k,0,sp){\n                ll nxj=j+ad-k;\n                if(nxj<0||nxj>n)continue;\n                Add(dp[i+1][nxj],dp[i][j]*comb(sp,k));\n            }\n        }\n       // cout<<ad<<\" \"<<sp<<endl;\n        if(i==m-1)break;\n        ll mx=v[i].se-v[i+1].fi+1;\n        chmax(mx,0);\n        rep(j,mx+1,n)dp[i+1][j]=0;\n    }\n    /*\n    rep(i,0,m){\n        rep(j,0,n){\n            cout<<dp[i][j]<<\" \";\n        }cout<<endl;\n    }cout<<endl;*/\n    \n    cout<<mod(dp[m][0])<<endl;\n    \n    return 0;\n}\n/*\n 11 3\n 10010010010\n 1 4\n 5 7\n 11 11\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\n\nconstexpr ll MOD = 1000000007LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\nclass Modulo\n{\npublic:\n    Modulo(const int n, const ll mod = MOD) : size{n + 1}, mod{mod}, fact(n + 1, 1), inv(n + 1, 1), inv_fact(n + 1, 1)  // mod should be prime\n    {\n        for (ll i = 2; i <= n; i++) {\n            fact[i] = (fact[i - 1] * i) % mod;\n            inv[i] = ((mod - (mod / i)) * inv[mod % i]) % mod;\n            inv_fact[i] = (inv_fact[i - 1] * inv[i]) % mod;\n        }\n    }\n    ll factorial(const int n) const\n    {\n        assert(n < size);\n        return fact[n];\n    }\n    ll inverse(const int n) const\n    {\n        assert(n < size);\n        return inv[n];\n    }\n    ll inverseFactorial(const int n) const\n    {\n        assert(n < size);\n        return inv_fact[n];\n    }\n    ll permutation(const int n, const int k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (fact[n] * inv_fact[n - k]) % mod;\n    }\n    ll combination(const int n, const int k) const\n    {\n        assert(n < size);\n        assert(k <= n);\n        return (((fact[n] * inv_fact[k]) % mod) * inv_fact[n - k]) % mod;\n    }\n    ll homogenious(const int n, const int k) const { return (n == 0 and k == 0 ? 1 : combination(n + k - 1, k)); }\n\nprivate:\n    const int size;\n    const ll mod;\n    vector<ll> fact;\n    vector<ll> inv;\n    vector<ll> inv_fact;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    vector<vector<int>> tmp(3001);\n    for (int i = 0; i < M; i++) {\n        int l, r;\n        cin >> l >> r;\n        l--, r--;\n        if (tmp[l].size() > 0) {\n            if (tmp[l][0] < r) {\n                tmp[l][0] = r;\n            }\n        } else {\n            tmp[l].push_back(r);\n        }\n    }\n    using P = pair<int, int>;\n    vector<P> R;\n    int r = 0;\n    for (int i = 0; i <= 3000; i++) {\n        if (tmp[i].size() > 0 and tmp[i][0] > r) {\n            R.push_back({i, tmp[i][0]});\n            r = tmp[i][0];\n        }\n    }\n    const int size = R.size();\n    vector<P> intersect(size);\n    intersect[0] = {-1, -1};\n    for (int i = 1; i < size; i++) {\n        intersect[i] = {R[i].first, R[i - 1].second};\n    }\n    intersect.push_back({N, N});\n    vector<int> one(size + 1, 0);\n    vector<int> one_orig(size, 0);\n    for (int i = 0; i < size; i++) {\n        if (i == 0) {\n            one[i] = 0;\n        } else {\n            for (int j = intersect[i].first; j <= intersect[i].second; j++) {\n                one[i] += (S[j] == '1' ? 1 : 0);\n            }\n        }\n        for (int j = R[i].first; j <= R[i].second; j++) {\n            one_orig[i] += (S[j] == '1' ? 1 : 0);\n        }\n    }\n    Modulo mod(N + 1);\n    vector<ll> dp(N + 1, 0);  // i番目の区間\n    dp[0] = 1;\n    for (int i = 0; i < size; i++) {\n        vector<ll> tmp(N + 1, 0);\n        for (int j = 0; j <= intersect[i].second - intersect[i].first + 1; j++) {\n            if (dp[j] > 0) {\n                const int tot = one_orig[i] - one[i] + j;\n                const int next = intersect[i + 1].second - intersect[i + 1].first + 1;\n                const int rest = R[i].second - R[i].first + 1 - next;\n                for (int k = max(0, tot - rest); k <= min(tot, next); k++) {\n                    (tmp[k] += mod.combination(rest, tot - k) * dp[j] % MOD) %= MOD;\n                }\n            }\n        }\n        dp = tmp;\n    }\n    ll ans = 0;\n    for (int i = 0; i <= N; i++) {\n        (ans += dp[i]) %= MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint fact[1000001];\n\nint modpow(int x, int k) {\n  int a = 1;\n  while (k > 0) {\n    if (k & 1) a = (1LL*a*x) % MOD;\n    x = (1LL*x*x) % MOD;\n    k >>= 1;\n  }\n  return a;\n}\n\nint inv(int x) {\n  return modpow(x, MOD-2);\n}\n\nint nCr(int n, int k) {\n  if (n < 0 || k < 0 || n < k) return 0;\n  return (1LL * fact[n] * inv((1LL*fact[k]*fact[n-k]) % MOD)) % MOD;\n}\n\nint N, M;\nint L[3000], R[3000];\nint T[3001];\nstring S;\nint dp[3001][3001];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=1000000; i++) {\n    fact[i] = (1LL*i*fact[i-1]) % MOD;\n  }\n\n  cin >> N >> M >> S;\n  rep(i, N) T[i+1] = T[i] + (S[i] == '1');\n  map<P, bool> ss;\n  rep(i, M) {\n    cin >> L[i] >> R[i];\n    L[i]--, R[i]--;\n    if (ss[P(L[i], R[i])]) L[i] = R[i] = -1;\n    else {\n      ss[P(L[i], R[i])] = true;\n    }\n  }\n  vector<P> qs;\n  rep(i, M) {\n    if (L[i] == -1) continue;\n    bool f = true;\n    rep(j, M) {\n      if (L[j] == -1) continue;\n      if (i == j) continue;\n      // j contains i\n      if (L[j] <= L[i] && R[i] <= R[j]) {\n        f = false;\n        break;\n      }\n    }\n    if (!f) continue;\n    qs.pb(P(L[i], R[i]));\n  }\n  dp[0][0] = 1;\n  int s = 1;\n  rep(i, qs.size()) {\n    int l = qs[i]._1, r = qs[i]._2;\n    bool end = true;\n    int n = 0;\n    int nl = N;\n    if (i+1 < qs.size()) {\n      nl = qs[i+1]._1;\n      if (r >= nl) {\n        end = false;\n        n = r-nl+1;\n      }\n    }\n    int ll = l;\n    if (i > 0) ll = max(ll, qs[i-1]._2+1);\n    int ones = T[r+1] - T[ll];\n    if (end) {\n      int len = r-l+1;\n      long long e = 0;\n      rep(k, N+1) {\n        e += (1LL * dp[i][k] * nCr(len, ones+k)) % MOD;\n        e %= MOD;\n      }\n      s = (1LL*s*e) % MOD;\n      dp[i+1][0] = 1;\n    }\n    else {\n      int det = nl-l;\n      rep(k, (ll-l)+1) {\n        if (k > N) break;\n        if (dp[i][k] == 0) continue;\n        int r = ones+k;\n        rep(nk, n+1) {\n          if (r < nk) break;\n          // r-nk, nk\n          dp[i+1][nk] += (1LL * nCr(det, r-nk) * dp[i][k]) % MOD;\n          dp[i+1][nk] %= MOD;\n        }\n      }\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=3e3+5,mo=1e9+7;\nint i,j,n,a,b,m,ri[maxn];\nint sum[maxn],f[maxn][maxn];\nchar s[maxn];\nvoid mod(int &x){\n\tx-=(x>=mo)?mo:0;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfo(i,1,n) sum[i]=sum[i-1]+(s[i]=='1'),ri[i]=i;\n\tfo(i,1,m){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tri[a]=max(ri[a],b);\n\t}\n\tfo(i,1,n) ri[i]=max(ri[i-1],ri[i]);\n\tf[1][sum[ri[1]]]=1,ri[n+1]=n;\n\tfo(i,1,n){\n\t\tint ad=sum[ri[i+1]]-sum[ri[i]];\n\t\tfo(j,0,n-i+1) if (f[i][j]){\n\t\t\tint s=f[i][j];\n\t\t\tif (j)mod(f[i+1][j-1+ad]+=s);\n\t\t\tif (ri[i]-i+1>j)mod(f[i+1][j+ad]+=s);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint solve(string s, vector<int> l, vector<int> r) {\n\tint N = s.length(), M = l.size();\n\tint R = l[0], zero = 0, one = 0;\n\tint j = 0;\n\tvector<int> dp(N + 1);\n\tdp[0] = 1;\n\tfor (int i = l[0]; i < r[M - 1]; i++) {\n\t\tif (j < M && i == l[j]) {\n\t\t\tfor (int i = R; i < r[j]; i++) {\n\t\t\t\tif (s[i] == '0') zero++;\n\t\t\t\tif (s[i] == '1') one++;\n\t\t\t}\n\t\t\tR = r[j];\n\t\t\tj++;\n\t\t}\n\t\tvector<int> _dp(N + 1);\n\t\tfor (int x = 0; x <= N; x++) {\n\t\t\tint k0 = i - l[0] - x, k1 = x;\n\t\t\tif (k0 < 0 || k1 < 0) continue;\n\t\t\tif (k0 < zero) _dp[x] = (_dp[x] + dp[x]) % MOD;\n\t\t\tif (k1 < one) _dp[x + 1] = (_dp[x + 1] + dp[x]) % MOD;\n\t\t}\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= N; x++)\n\t\tans = (ans + dp[x]) % MOD;\n\treturn ans;\n}\n\nsigned main() {\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tvector<int> l, r;\n\tint ma = 0;\n\twhile (M--) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--;\n\t\tif (y <= ma) continue;\n\t\tma = y;\n\t\tl.pb(x); r.pb(y);\n\t}\n\tM = l.size();\n\tvector<int> v;\n\tv.pb(0);\n\tfor (int j = 0; j + 1 < M; j++)\n\t\tif (r[j] <= l[j + 1])\n\t\t\tv.pb(j + 1);\n\tv.pb(M);\n\tint ans = 1;\n\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\tvector<int> _l, _r;\n\t\tfor (int j = v[k]; j < v[k + 1]; j++)\n\t\t\t_l.pb(l[j]), _r.pb(r[j]);\n\t\tans = (ll)ans * solve(s, _l, _r) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int32_t Int;\n\ttypedef uint32_t UInt;\n\ttypedef int64_t Long;\n\ttypedef uint64_t ULong;\n\npublic:\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <unsigned int Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](unsigned int exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(UInt exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus> right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <unsigned int Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <unsigned int Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <unsigned int Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <unsigned int Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <unsigned int Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <unsigned int Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <unsigned int Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt((uint64_t)num); }\n#endif\n\n#endif\n\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <list>\n#include <bitset>\n\nusing namespace std;\n#define REP(i,a,n) for(int i = (a); i < (int)(n); ++i)\n#define REPM(i,n,a) for(int i = ((n) - 1); i >= (a); --i)\n#define EPS 0.0001\n#define INF 0x3FFFFFFF\n#define INFLL 0x3FFFFFFF3FFFFFFF\n#define INFD 1.0e+308\n#define FLOAT setprecision(16)\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(begin(dest), end(dest), val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\n//sum, 累積和\n// 負のときの割り算に注意\n#if 1\n#include <array>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<class T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\t// コスト小を優先\n#endif\n\nstruct CompBySecond {\n\tbool operator()(const PP& a, const PP& b) const {\n\t\treturn a.second < b.second || (a.second == b.second && a.first < b.first);\n\t}\n};\n\ntemplate<class T>\nclass Array {\n\tT* ptr_m;\n\tsize_t size_m;\n};\n\n//#include \"Union_Find.h\"\n\nint N, M;\nstring S;\nvector<int> L, R;\nint X[3000];\nint W[3000];\nint O[3000];\nbool flg[3000];\nMInt DP[3001][3001];\n\nMInt C(int n, int r) \n\treturn MInt::Combi(n, r);\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\tREP(i, 0, M) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\t--l;\n\t\tL.push_back(l);\n\t\tR.push_back(r);\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] >= R[i]) {\n\t\t\tL.erase(L.begin() + i);\n\t\t\tR.erase(R.begin() + i);\n\t\t\t--i;\n\t\t}\n\t}\n\tREP(i, 1, L.size()) {\n\t\tif (R[i - 1] < L[i]) {\n\t\t\tL.insert(L.begin() + i, R[i - 1]);\n\t\t\tR.insert(R.begin() + i, R[i - 1] + 1);\n\t\t}\n\t}\n\n\n\tM = L.size();\n\tREP(i, 0, M) {\n\t\tX[i] = i == M - 1 ? R[M - 1] - L[M - 1] : L[i + 1] - L[i];\n\t\tW[i] = R[i] - L[i];\n\t\tO[i] = count(S.begin(), S.begin() + R[i], '1');\n\t}\n\n\tDP[0][count(S.begin(), S.begin() + L[0], '1')] = 1;\n\tREP(i, 1, M + 1) {\n\t\tREP(j, max(0, X[i - 1] + O[i - 1] - W[i - 1]), min(N, O[i - 1]) + 1) {\n\t\t\tREP(k, 0, min(j, X[i - 1]) + 1) {\n\t\t\t\tDP[i][j] += DP[i - 1][j - k] * C(X[i - 1], k);\n\t\t\t}\n\t\t}\n\t}\n\tcout << DP[M][O[M - 1]].Get_value() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if(i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if(j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\t//p(rightmost);\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\nll dp[3002][3002];\nint dat[3002];\nint rui[3002];\nint main()\n{\n\tint num, way;\n\tscanf(\"%d%d\", &num, &way);\n\tstring s;\n\tcin >> s;\n\treverse(s.begin(), s.end());\n\ts.push_back('0');\n\treverse(s.begin(), s.end());\n\tnum++;\n\tfor (int i = 1; i < num; i++)rui[i] = rui[i - 1] + s[i] - '0';\n\tfor (int i = 0; i < num; i++)dat[i] = i;\n\tfor (int i = 0; i < way; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tdat[za] = max(dat[za], zb);\n\t}\n\tfor (int i = 1; i < num; i++)dat[i] = max(dat[i], dat[i - 1]);\n\tdp[0][0] = 1;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tint a0 = (dat[i] - dat[i - 1]) - (rui[dat[i]] - rui[dat[i - 1]]);\n\t\tint a1 = (rui[dat[i]] - rui[dat[i - 1]]);\n\t\tint sum = dat[i - 1] - (i - 1);\n\t\t//printf(\"%d %d %d\\n\", a0, a1, sum);\n\t\tfor (int j = 0; j <= sum; j++)\n\t\t{\n\t\t\tif (sum - j + a0 != 0)dp[i][j + a1] += dp[i - 1][j], dp[i][j + a1] %= mod;\n\t\t\tif (j + a1 != 0)dp[i][j + a1 - 1] += dp[i - 1][j], dp[i][j + a1 - 1] %= mod;\n\t\t}\n\t\t//for (int j = 0; j < num; j++)printf(\"%lld \", dp[i][j]); printf(\"\\n\");\n\t}\n\tprintf(\"%lld\\n\", dp[num - 1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long lli;\nlli n,m;\nstring s;\nvector<lli> rightend;\nvector<vector<lli> > dp;\nvector<lli> sum;\nint main(){\n    cin >> n >> m;\n    cin >> s;\n    rightend = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) rightend[i] = i;\n    for(lli i = 0;i < m;i++){\n        lli l,r;\n        cin >> l >> r;\n        rightend[l] = max(rightend[l],r);\n    }\n    sum = vector<lli> (n+1);\n    for(lli i = 1;i <= n;i++) sum[i] = s[i-1] - '0';\n    for(lli i = 0;i < n;i++) sum[i+1] += sum[i];\n    for(lli i = 0;i < n;i++) rightend[i+1] = max(rightend[i+1],rightend[i]);\n    dp = vector<vector<lli> > (n+2,vector<lli>(n+2));\n    dp[0][0] = 1;\n    for(lli i = 0;i < n;i++){\n        lli b,e;\n        b = max(0ll,i - (rightend[i] - sum[rightend[i]]));\n        e = min(i,sum[rightend[i]]);\n        for(lli j = b;j <= e;j++){\n            dp[i+1][j] += dp[i][j];\n            dp[i+1][j+1] += dp[i][j];\n        }\n    }\n    cout << dp[n][sum[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1e9+7;\nusing Lint=long long;\n\ntemplate<int mod> class ModInt\n{\n private:\n    Lint val;\n public:\n    Lint value(){ return val; }\n    ModInt(Lint x=0){ val=x%mod; }\n    ModInt pow(int n){\n        ModInt res(1),x(val);\n        while(n>0){ if(n&1) res*=x; x*=x; n>>=1; }\n        return res;\n    }\n    ModInt inv(){ return pow(mod-2); }\n    ModInt& operator+=(ModInt rhs){ val+=rhs.val; if(val>=mod) val-=mod; return *this; }\n    ModInt& operator-=(ModInt rhs){ val+=mod-rhs.val; if(val>=mod) val-=mod; return *this; }\n    ModInt& operator*=(ModInt rhs){ val=val*rhs.val%mod; return *this; }\n    ModInt& operator/=(ModInt rhs){ *this*=rhs.inv(); return *this; }\n    ModInt operator+(ModInt rhs){ return ModInt(val)+=rhs; }\n    ModInt operator-(ModInt rhs){ return ModInt(val)-=rhs; }\n    ModInt operator*(ModInt rhs){ return ModInt(val)*=rhs; }\n    ModInt operator/(ModInt rhs){ return ModInt(val)/=rhs; }\n};\nusing mint=ModInt<1000000007>;\n\ntemplate<typename T> class BiCoef\n{\n public:\n    vector<T> fact,ifact,inv;\n    BiCoef(int N):fact(N+1),ifact(N+1),inv(N+1){\n        fact[0]=ifact[N]=inv[0]=1;\n        for(int i=1;i<=N;i++) fact[i]=fact[i-1]*i;\n        ifact[N]/=fact[N];\n        for(int i=N-1;i>=0;i--) ifact[i]=ifact[i+1]*(i+1);\n        for(int i=1;i<=N;i++) inv[i]=ifact[i]*fact[i-1];\n    }\n    T comb(int n,int k){\n        if(n<0 or k<0 or n<k) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n};\n\nint main()\n{\n   int N,M; cin>>N>>M;\n   string s; cin>>s;\n   vector<int> _l(M),_r(M);\n   for(int i=0;i<M;i++) cin>>_l[i]>>_r[i];\n\n   vector<int> l,r;\n   l.push_back(_l[0]);\n   r.push_back(_r[0]);\n   for(int i=1;i<N;i++){\n      if(_r[i]>r.back()){\n         l.push_back(_l[i]);\n         r.push_back(_r[i]);\n      }\n   }\n   M=l.size();\n   // for(int i=0;i<M;i++) cout<<l[i]<<' '<<r[i]<<endl;\n   for(int i=0;i<M;i++) l[i]--;\n\n   vector<int> cnt(N+1);\n   for(int i=0;i<N;i++) cnt[i+1]=cnt[i]+(s[i]=='1');\n\n   BiCoef<mint> bc(100010);\n   vector<vector<mint>> dp(M,vector<mint>(N+1));\n   dp[0][cnt[r[0]]-cnt[l[0]]]=1;\n   for(int i=0;i+1<M;i++) for(int j=0;j<=r[i]-l[i];j++){\n      if(r[i]<=l[i+1]){\n         dp[i+1][cnt[r[i+1]]-cnt[l[i+1]]]+=dp[i][j]*bc.comb(r[i]-l[i],j);\n      }else{\n         for(int k=0;k<=min(j,r[i]-l[i+1]);k++) if(j-k<=l[i+1]-l[i]){\n            dp[i+1][k+cnt[r[i+1]]-cnt[r[i]]]+=dp[i][j]*bc.comb(l[i+1]-l[i],j-k);\n         }\n      }\n   }\n   mint ans=0;\n   for(int j=0;j<=r[M-1]-l[M-1];j++) ans+=dp[M-1][j]*bc.comb(r[M-1]-l[M-1],j);\n   cout<<ans.value()<<endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nLL dp[3010][3010];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  string S; cin >> S;\n  VI zs(N+1, 0);\n  REP(i,N) zs[i+1] = zs[i] + (S[i]=='0');\n\n  VI rs(N+1);\n  REP(i,N+1) rs[i] = i+1;\n  REP(i,M){\n\tint l, r; cin >> l >> r;\n\t--l;\n\tfor(int k=l;k<r;++k)\n\t  rs[k] = max(rs[k], r);\n  }\n\n  int rr = 0;\n  dp[0][0] = 1;\n  for(int i=0;i<N;++i){\n\tint dz = (rs[i] <= rr? 0: zs[rs[i]]-zs[rr]);\n\trr = rs[i];\n\tfor(int z=0;z<=N;++z){\n\t  int zz = z + dz;\n\t  if(zz > N) continue;\n\t  if(zz > 0)\n\t\t(dp[i+1][zz-1] += dp[i][z]) %= MOD;\n\t  if(rr - i - zz > 0)\n\t\t(dp[i+1][zz] += dp[i][z]) %= MOD;\n\t}\n\trr = rs[i];\n  }\n  cout << dp[N][0] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 1000000007\n#define N 3005\nusing namespace std;\n\nint n,m,s[N],a[N],b[N],dp[N][N],cbn[N][N]; char ch[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i,j,k;\n\tfor (i=1; i<=n; i++) s[i]=s[i-1]+(ch[i]=='1');\n\tm++; a[1]=b[1]=1;\n\tfor (i=2; i<=m; i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tif (a[i]==a[i-1]){\n\t\t\tb[i-1]=max(b[i-1],b[i]); i--; m--; continue;\n\t\t}\n\t\tif (b[i]<=b[i-1]){ i--; m--; continue; }\n\t\twhile (a[i]>b[i-1]+1){\n\t\t\ta[i+1]=a[i]; b[i+1]=b[i];\n\t\t\ta[i]=b[i]=b[i-1]+1;\n\t\t\ti++; m++;\n\t\t}\n\t}\n\ta[m+1]=n+1;\n\tdp[0][0]=1;\n\tfor (i=0; i<=n; i++)\n\t\tfor (j=cbn[i][0]=1; j<=i; j++) cbn[i][j]=(cbn[i-1][j]+cbn[i-1][j-1])%mod;\n\tfor (i=1; i<=m; i++){\n\t\tfor (j=max(a[i+1]-1-b[i]+s[b[i]],0); j<=s[b[i]]; j++)\n\t\t\tfor (k=0; k<=a[i+1]-a[i] && k<=j; k++) dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k]*cbn[a[i+1]-a[i]][k])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[m][s[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint main() {\n    // TODO\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 3009\nusing namespace std;\nstruct node{ \n\tint l, r;\n\tbool operator < (const node &rhs) const{ \n\t\treturn (l < rhs.l) || (l == rhs.l && r > rhs.r);\n\t}\n}a[maxn];\nint n, m, dp[maxn][maxn], C[maxn][maxn], sum[maxn];\nchar s[maxn];\nconst int MOD = 1e9 + 7;\n\nbool in(int L, int R, int x){\n\treturn L <= x && x <= R;\n}\nlong long solve(int L ,int R){\n\tif(L == R){\n\t\treturn C[a[L].r - a[L].l + 1][sum[a[L].r] - sum[a[L].l - 1]];\n\t}\n\n\tfor(int i = 0; i <= sum[a[L].r] - sum[a[L].l - 1]; i++){\n\t\tint part1 = a[L + 1].l - a[L].l;\n\t\tint part2 = a[L].r - a[L].l + 1 - part1;\n\t\tif(i > part2) \n\t\t\tbreak;\n\t\tdp[L][i] = C[part1][sum[a[L].r] - sum[a[L].l - 1] - i];\n\t}\n\n\n\tfor(int i = L + 1; i < R; i++){\n\t\tint part1 = a[i + 1].l - a[i].l;\n\t\tint part2 = a[i].r - a[i].l + 1 - part1;\n\t\tint one = sum[a[i].r] - sum[a[i - 1].r];\n\n\t\tfor(int j = 0; j <= part2; j++){\n\t\t\tfor(int k = max(0, j - one) ; k <= part1 + j - one; k++)\n\t\t\t\tdp[i][j] = (dp[i][j] + 1LL * C[part1][k + one - j] * dp[i - 1][k]) % MOD;\n\t\t}\n\t}\n\n\tint last1 = a[R - 1].r - a[R].l + 1;\n\tint one = sum[a[R].r] - sum[a[R - 1].r];\n\n\tlong long ans = 0;\n\tfor(int k = 0; k <= last1; k++)\n\t\tans = (ans + 1LL * dp[R - 1][k] * C[a[R].r - a[R].l + 1][one + k]) % MOD;\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tscanf(\"%s\", s + 1);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + (s[i] == '1');\n\n\tfor(int i = 0; i <= n; i++){\n\t\tC[i][i] = C[i][0] = 1;\n\t\tfor(int j = 1; j < i; j++)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;\n\t}\n\n\tfor(int i = 1; i <= m; i++){\n\t\tscanf(\"%d%d\", &a[i].l, &a[i].r);\n\t}\n\tsort(a + 1, a + 1 + m);\n\n\tint tot = 0, last = -1;\n\tfor(int i = 1; i <= m; i++){\n\t\tif(a[i].r <= last)\n\t\t\tcontinue;\n\t\t++tot;\n\t\ta[tot] = a[i];\n\t\tlast = a[i].r;\n\t}\n\n\tint cur = 1;\n\tlong long ans = 1;\n\twhile(cur <= tot){\n\t\tint L = cur;\n\t\twhile(cur + 1 <= tot && in(a[cur].l, a[cur].r, a[cur+1].l))\n\t\t\tcur++;\n\t\tint R = cur;\n\t\tans = ans * solve(L, R) % MOD;\n\t\tcur++;\n\t}\n\n\tcout<< ans << endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(va_0, va_1, va_2, name, ...) name\n#define rep_0(i, n) for(int i = 0; i < (n); ++i)\n#define rep_1(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModInt {\nprivate: using ll = int_fast64_t;\npublic: ll x;\n    constexpr ModInt(ll t = 0) noexcept : x((t %= mod) < 0 ? t + mod : t) {}\n    constexpr friend istream& operator >> (istream& s, ModInt& m) noexcept {\n        s >> m.x; m.x %= mod; if(m.x < 0)m.x += mod; return s;\n    }\n    constexpr friend ostream& operator << (ostream& s, ModInt m) noexcept {\n        return s << m.x;\n    }\n    constexpr ModInt operator + (const ModInt m) noexcept { return ModInt(*this) += m; }\n    constexpr ModInt& operator += (const ModInt m) noexcept {\n        if((x += m.x) >= mod)x -= mod; return *this;\n    }\n    constexpr ModInt operator - (const ModInt m) noexcept { return ModInt(*this) -= m; }\n    constexpr ModInt& operator -= (const ModInt m) noexcept {\n        if((x += mod - m.x) >= mod)x -= mod; return *this;\n    }\n    constexpr ModInt operator * (const ModInt m) noexcept { return ModInt(*this) *= m; }\n    constexpr ModInt& operator *= (const ModInt m) noexcept {\n        x = x * m.x % mod; return *this;\n    }\n    constexpr ModInt operator / (const ModInt m) noexcept { return ModInt(*this) /= m; }\n    constexpr ModInt& operator /= (const ModInt m) noexcept {\n        return *this *= m.inv();\n    }\n    constexpr ModInt inv() const noexcept {\n        return pow(mod - 2);\n    }\n    constexpr ModInt pow(ll p) const noexcept {\n        ModInt res(1), mult(*this);\n        for(; p; p >>= 1){ if(p & 1)res *= mult; mult *= mult; }\n        return res;\n    }\n};\n\ntemplate<const int_fast64_t mod = 1000000007>\nstruct ModFact {\nprivate:\n    using mint = ModInt<mod>;\n    vector<mint> fact, ifact;\npublic:\n    constexpr ModFact(int sz = 200000) noexcept : fact(sz + 1), ifact(sz + 1) {\n        fact[0] = mint(1);\n        for(int i = 1; i <= sz; ++i)fact[i] = fact[i - 1] * mint(i);\n        ifact[sz] = fact[sz].inv();\n        for(int i = sz; i > 0; --i)ifact[i - 1] = ifact[i] * mint(i);\n    }\n    constexpr mint operator [] (int id) const noexcept { return fact[id]; }\n    constexpr mint operator () (int n, int r) noexcept {\n        return fact[n] * ifact[n - r] * ifact[r];\n    }\n    constexpr mint nPr(int n, int r) noexcept {\n        return fact[n] * ifact[r];\n    }\n    constexpr mint inv(int id) const noexcept { return ifact[id]; }\n};\n\n// declarations\nusing mint = ModInt<>;\nusing mfact = ModFact<>;\n\nint N, M;\nint cnt[3010];\nint ls[3010], rs[3010];\nint L[3010], R[3010];\nmint dp[3010][3010];\nmfact fact;\n\n// solve\nint main(){\n\n    int N, M;\n    cin >> N >> M;\n\n    rep(i, N){\n        char c; \n        cin >> c;\n        if(c == '1')cnt[i + 1]++;\n        cnt[i + 1] += cnt[i];\n    }\n\n    rep(i, M){\n        cin >> ls[i] >> rs[i];\n        ls[i]--;\n    }\n\n    int size_q = 0, pos = 0, last_r = 0;\n    while(pos < M){\n        int l = ls[pos], r = rs[pos++];\n        if(last_r >= r)continue;\n        for(; pos < M; pos++){\n            if(ls[pos] > l)break;\n            chmax(r, rs[pos]);\n        }\n        L[size_q] = l;\n        R[size_q++] = last_r = r;\n    }\n\n    L[size_q] = N;\n    dp[L[0]][cnt[L[0]]] = mint(1);\n    rep(i, size_q){\n        int l = L[i], r = min(R[i], L[i + 1]);\n        rep(j, 0, N){\n            int usable = cnt[R[i]] - j;\n            if(usable < 0)break;\n            int mi = max(0, r - (R[i] - usable)), ma = min(r - l, usable);\n            rep(k, mi, ma){\n                dp[r][j + k] += dp[l][j] * fact(r - l, k);\n            }\n        }\n        int until_next = cnt[L[i + 1]] - cnt[r];\n        rep(j, 0, N){\n            if(j + until_next > N)break;\n            dp[L[i + 1]][j + until_next] = dp[r][j];\n        }\n    }\n\n    cout << dp[N][cnt[N]] << '\\n';\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 3005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint ri[MAXN],f[2][MAXN];\nint N,M;\nchar s[MAXN];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nvoid Solve() {\n    read(N);read(M);\n    scanf(\"%s\",s + 1);\n    int l,r;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(l);read(r);\n\tri[l] = max(ri[l],r);\n    }\n    int p = 0,all = 0;\n    int cur = 0;\n    f[cur][0] = 1;\n    \n    for(int i = 1 ; i <= N ; ++i) {\n\tif(p < i - 1) {p = i - 1;}\n\tif(ri[i] > p) {\n\t    all += ri[i] - p;\n\t    int a = 0,b = 0;\n\t    for(int j = p + 1 ; j <= ri[i] ; ++j) {\n\t\tif(s[j] == '0') ++a;\n\t\telse ++b;\n\t    }\n\t    p = ri[i];\n\t    memset(f[cur ^ 1],0,sizeof(f[cur ^ 1]));\n\t    for(int j = a ; j <= N ; ++j) f[cur ^ 1][j] = f[cur][j - a];\n\t    cur ^= 1;\n\t}\n\tif(!all) continue;\n\tmemset(f[cur ^ 1],0,sizeof(f[cur ^ 1]));\n\tfor(int j = 0 ; j <= all ; ++j) {\n\t    if(j < all) update(f[cur ^ 1][j],f[cur][j]);\n\t    if(j >= 1) update(f[cur ^ 1][j - 1],f[cur][j]);\n\t}\n\t--all;\n\tcur ^= 1;\n    }\n    out(f[cur][0]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define R register\nusing namespace std;\nconst int mod=1000000007;\nconst int MAXN=3100;\nint pre[MAXN];\nint dp[MAXN][MAXN],r[MAXN];\nchar s[MAXN];\n\nvoid reads(char* st)\n{\n\tint len=0;char ch=getchar();\n\twhile(ch<'0'||ch>'1')ch=getchar();\n\twhile(ch>='0'&&ch<='1')st[++len]=ch,ch=getchar();\n}\n\nvoid add(int &x,int y)\n{x=(x+y)%mod;}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\treads(s);\n\tfor(int i=1;i<=n;++i)\n\t  if(s[i]=='1')pre[i]=pre[i-1]+1;\n\t  else pre[i]=pre[i-1];\n\tpre[n+1]=pre[n];\n\tint t1,t2;\n\tfor(R int i=1;i<=n+1;++i)r[i]=i;\n\tfor(R int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tif(t2>r[t1])r[t1]=t2;\n\t}\n\tfor(R int i=1;i<=n+1;++i)\n\t  if(r[i-1]>r[i])r[i]=r[i-1];\n\tdp[1][pre[r[1]]]=1;\n\tfor(R int i=1;i<=n;++i)\n\t  for(R int j=0;j<=n;++j)\n\t    if(dp[i][j])\n\t    {\n\t    \tif(r[i]-i-j+1)add(dp[i+1][j+pre[r[i+1]]-pre[r[i]]],dp[i][j]);\n\t    \tif(j)add(dp[i+1][j-1+pre[r[i+1]]-pre[r[i]]],dp[i][j]);\n\t    }\n\tprintf(\"%d\\n\",dp[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\n\ntemplate<uint MD>\nstruct ModInt {\n    uint v;\n    ModInt() : v{0} {}\n    ModInt(ll v) : v{normS(v%MD+MD)} {}\n    static uint normS(const uint &x) {return (x<MD)?x:x-MD;};\n    static ModInt make(const uint &x) {ModInt m; m.v = x; return m;}\n    ModInt operator+(const ModInt &r) const {return make(normS(v+r.v));}\n    ModInt operator-(const ModInt &r) const {return make(normS(v+MD-r.v));}\n    ModInt operator*(const ModInt &r) const {return make((ull)v*r.v%MD);}\n    ModInt& operator+=(const ModInt &r) {return *this=*this+r;}\n    ModInt& operator-=(const ModInt &r) {return *this=*this-r;}\n    ModInt& operator*=(const ModInt &r) {return *this=*this*r;}\n    static ModInt inv(const ModInt &x) {\n        return pow(ModInt(x), MD-2);\n    }\n};\nusing Mint = ModInt<TEN(9)+7>;\nconst int MN = 3030;\nint co;\nint A[MN], B[MN];\n\nMint calc(int n, int b) {\n    static Mint dp[MN][MN];\n    static bool used[MN][MN];\n    if (n == co) return 1;\n    if (B[n] <= b) return 0;\n    if (used[n][b]) return dp[n][b];\n    used[n][b] = true;\n    Mint &ans = dp[n][b];\n    ans = calc(n, b+1);\n    if (A[n] <= b) ans += calc(n+1, b+1);\n    return ans;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    string t = s;\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r; l--;\n        sort(s.begin()+l, s.begin()+r);\n        sort(t.begin()+l, t.begin()+r, greater<char>());\n    }\n    co = 0;\n    for (int i = 0; i < n; i++) {\n        if (t[i] == '0')continue;\n        A[co++] = i;\n    }\n    co = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '0') continue;\n        B[co++] = i+1;\n    }\n    /*  cout << co << endl;\n        for (int i = 0; i < co; i++) {\n        cout << A[i] << \" \" << B[i] << endl;\n    }*/\n    cout << calc(0, 0).v << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint N, M; string S; \n\tcin >> N >> M >> S; \n\tint dp[3010][3010] = {};\n\tint mod = 1000000007; \n\tstring T = S; \n\tstring U = S; \n\tfor(int i = 0; i < M; i++){\n\t\tint l, r; cin >> l >> r; l--; \n\t\tsort(T.begin() + l, T.begin() + r); \n\t\tsort(U.begin() + l, U.begin() + r, greater<char>()); \n\t}\n\tint low[3010] = {}; int high[3010] = {}; \n\tfor(int i = 0; i < N; i++){\n\t\tif(U.at(i) == '1') high[i+1] = high[i] + 1; \n\t\telse high[i+1] = high[i]; \n\t\tif(T.at(i) == '1') low[i+1] = low[i] + 1; \n\t\telse low[i+1] = low[i]; \n\t}\n\tdp[0][0] = 1; \n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = low[i]; j <= high[i]; j++){\n\t\t\tif(j > 0) dp[i][j] += dp[i-1][j-1]; \n\t\t\tdp[i][j] += dp[i-1][j];\n\t\t\tif(dp[i][j] >= mod) dp[i][j] -= mod; \n\t\t}\n\t}\n\tcout << dp[N][high[N]] << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\n  public:\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint operator^(const u64 rhs) const noexcept {\n        return modint(*this) ^= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr modint &operator^=(u64 exp) {\n        modint rhs = modint(*this);\n        a = 1;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 1);\n    fi.resize(n + 1);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * mint(i);\n    }\n    fi[n] = mint(1) / f[n];\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * mint(i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r) {\n        return mint(0);\n    }\n    if (r == 0) {\n        return mint(1);\n    }\n    return f[n] * fi[n - r] * fi[r];\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    vector<int> co(n + 1);\n    for (int i = 0; i < n; i++) {\n        co[i + 1] = co[i] + (s[i] == '1');\n    }\n    int mr = 0;\n    vector<P> v;\n    for (int i = 0; i < m; i++) {\n        int l, r;\n        cin >> l >> r;\n        --l;\n        --r;\n        if (mr >= r) {\n            continue;\n        }\n        chmax(mr, r);\n        v.push_back(P(l, r));\n    }\n    v.push_back(P(n - 1, n - 1));\n    vector<vector<mint>> dp(m + 1, vector<mint>(n + 1));\n    dp[0][0] = 1;\n    comb(n + 10);\n    for (int i = 0; i + 1 < v.size(); i++) {\n        int l = v[i].first, r = v[i].second;\n        int a = r - l + 1, c = a;\n        chmin(c, v[i + 1].first - l);\n        for (int j = 0; j <= n; j++) {\n            if (dp[i][j].a == 0) {\n                continue;\n            }\n            int b = co[r + 1] - j;\n            for (int d = max(0, b - a + c); d <= min(b, c); d++) {\n                int to = j + d;\n                if (c == a) {\n                    to = co[v[i + 1].first];\n                }\n                dp[i + 1][to] += dp[i][j] * ncr(c, d);\n            }\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i <= n; i++) {\n        res += dp[v.size() - 1][i];\n    }\n    cout << res.a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n#define ADD(a,b) a=((a)+(b))%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n,m;\nchar s[3535];\nint rightmost[3535];\n\nll dp[3535][3535];\n\nint sum1[3535];\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s);\n  REP(i,n)rightmost[i] = i;\n  REP(i,m){\n    int l,r;\n    scanf(\"%d%d\",&l,&r);\n    --l;--r;\n    CHMAX(rightmost[l],r);\n  }\n  sum1[0] = 0;\n  REP(i,n)sum1[i+1] = sum1[i] + (int)(s[i]=='1');\n  REP(i,n)CHMAX(rightmost[i+1],rightmost[i]);\n  dp[0][sum1[rightmost[0]+1]] = 1;\n  // REP(i,n+1)DEBUG(rightmost[i]);\n  // REP(i,n+1)DEBUG(sum1[i]);\n  // REP(i,n){\n  //   DEBUG(sum1[rightmost[i+1]+1]);\n  //   DEBUG(sum1[rightmost[i]+1]);\n  //   DEBUG(sum1[rightmost[i+1]+1] - sum1[rightmost[i]+1]);\n  // }\n  REP(i,n)REP(j,n+1){\n    // printf(\"[%d,%d] : %lld\\n\",i,j,dp[i][j]);\n    int left = i;\n    int free1 = j;\n    int right = rightmost[i];\n    int sz = right - i + 1;\n    int nextright = rightmost[i+1];\n    int add = sum1[nextright+1] - sum1[right+1];\n    // choose 0\n    if(sz-j > 0)ADD(dp[i+1][j-0+add], dp[i][j]);\n    if(j>0)ADD(dp[i+1][j-1+add], dp[i][j]);\n  }\n  printf(\"%lld\\n\",dp[n][0]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#define int long long\n#define MOD 1000000007\nusing namespace std;\n\nsigned main(){\n\tint n,m,dp[3010][3010] = {},zero[3010] = {},one[3010] = {},migi[3010] = {};\n\tstring s;\n\tcin >> n >> m >> s;\n\tfor(int i = 0;i < n;i++){\n\t\tzero[i + 1] = zero[i];\n\t\tone[i + 1] = one[i];\n\t\tif(s[i] == '1') one[i + 1]++;\n\t\telse zero[i + 1]++;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tfor(int j = l;j <= r;j++) migi[j] = max(migi[j],r);\n\t}\n\tfor(int i = 1;i <= n;i++) migi[i] = max(migi[i],i);\n\tfor(int i = 0;i <= one[n];i++){\n\t\tfor(int j = 0;j <= zero[n];j++){\n\t\t\tif(!i && !j){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tdp[i + 1][j]++;\n\t\t\t\tdp[i][j + 1]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint t = migi[i + j];\n\t\t\t\tif(one[t] < i || zero[t] < j) dp[i][j] = 0;\n\t\t\t\t(dp[i + 1][j] += dp[i][j]) %= MOD;\n\t\t\t\t(dp[i][j + 1] += dp[i][j]) %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[one[n]][zero[n]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 3005\n#define mod 1000000007\nusing namespace std;\ninline int read(){\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c); c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c); c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn 0-x;\n}\nint n,m; char s[N];\nint R[N],sum[N],f[N][N];\nint main(){\n    n=read(), m=read(); scanf(\"%s\",s+1);\n    for(int i=1; i<=n; ++i) sum[i]=s[i]-'0';\n    for(int i=1; i<=n+1; ++i) sum[i]+=sum[i-1];\n    for(int i=1; i<=n+1; ++i) R[i]=i;\n    int l,r;\n    for(int i=1; i<=m; ++i){\n        l=read(), r=read();\n        R[l]=max(R[l],r);\n    }\n    for(int i=1; i<=n; ++i) R[i]=max(R[i],R[i-1]);\n    f[1][sum[R[1]]]=1;\n    int flag0,flag1;\n    for(int i=1; i<=n; ++i)\n        for(int j=0; j<=n; ++j)\n            if(f[i][j]){\n                l=R[i]+1, r=R[i+1];\n                flag1=j, flag0=R[i]-(i-1)-flag1;\n                if(flag0) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mod;\n                if(flag1) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mod;\n            }\n    printf(\"%d\\n\",f[n+1][0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass CumulativeSum{\npublic:\n  vector<int> sum;\n  CumulativeSum(){}\n  CumulativeSum(vector<int> A){\n    int n = A.size();\n    sum.resize(n+1,0);\n    for(int i=1;i<=n;i++) sum[i] += sum[i-1] + A[i-1];\n  }\n  int get(int l,int r){assert(l>=0 && r<=(int)sum.size());return sum[r] - sum[l];} //[l,r)\n};\n\nll mod_pow(ll x,ll n){\n  ll res=1;\n  while(n){\n    if(n%2) res=res*x%mod;\n    x=x*x%mod;\n    n/=2;\n  }\n  return res;\n}\n\nll divi(ll a,ll b){\n  return a * mod_pow(b,mod-2) % mod;\n}\n\nll factorial(int i){\n  static vector<ll> k(1e6);\n  if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n  return k[i];\n}\n\nll nCr(ll n,ll r){\n  ll a = mod_pow( factorial(r) * factorial(n-r) % mod ,mod-2);\n  return factorial(n) * a % mod;\n}\n\nconst int N = 3010;\nCumulativeSum sum0,sum1;\nint n,m;\nvector<P> A;\nint mem[N][N],used[N][N];\n\nint dfs(int idx,int cnt0,int cnt1,int overlap){\n  //pr(idx,cnt0,cnt1,overlap);\n  //if(used[idx][cnt0]++) return mem[idx][cnt0];\n  int l,r; tie(l,r) = A[idx];\n  int len = r - l + 1;\n  int zero = cnt0 + sum0.get(l+overlap, r+1);\n  int one = cnt1 + sum1.get(l+overlap, r+1);\n  assert(zero + one == len);\n  if(idx == m-1) return mem[idx][cnt0] = nCr(len, zero);\n\n\n\n  int res = 0;  \n  int noverlap = r - A[idx+1].first + 1;\n  // pr(len,zero,one,noverlap);\n\n  if(noverlap <= 0){\n    int a = nCr(len, zero);\n    int b = dfs(idx+1,0,0,0);\n    res = a * b % mod;\n  }\n  else {\n    for(int i = 0;i<=noverlap; i++){ //overlapしてない区間の0の数\n      int ncnt0 = i;\n      int ncnt1 = (noverlap - i);\n      if(zero < ncnt0 ||  one < ncnt1) continue;\n      int a = nCr(len - noverlap, zero - i);\n      int b = dfs(idx+1, ncnt0, ncnt1, noverlap);\n      //pr(i,ncnt0,ncnt1,a,b);\n      res += a * b;\n      res %= mod;\n    }\n  }\n  return mem[idx][cnt0] = res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin>>n>>m;\n  string str;\n  cin>>str;\n  {\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) tmp[i] = str[i] == '0';\n    sum0 = CumulativeSum(tmp);\n    \n  }\n\n  {\n    vector<int> tmp(n);\n    for(int i=0;i<n;i++) tmp[i] = str[i] == '1';\n    sum1 = CumulativeSum(tmp);\n  }\n  \n  {\n    \n    int pre = -1;\n      for(int i=0;i<m;i++){\n        int l,r;\n        cin>>l>>r; l--, r--;\n        if(pre<r) A.push_back(P(l,r));\n        Max(pre,r);\n      }\n      m = A.size();\n  }\n\n  //pr(A);\n  int ans = dfs(0,0,0,0);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(a) for(int k=head[a];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ll,ll> pa;\nconst int N=5e3+5,M=5e3+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nchar s[N];\nint sum[N],r[N],f[N][N],m,n;\nint main(){\n\tread(n,m);\n\tscanf(\"%s\",s+1);\n\trep(i,1,n)sum[i]=(s[i]=='1')+sum[i-1];\n\trep(i,1,n)r[i]=i;\n\trep(i,1,m){\n\t\tint x,y;read(x,y);\n\t\tgmax(r[x],y);\n\t}rep(i,1,n)gmax(r[i],r[i-1]);\n\tf[0][0]=1;\n\trep(i,0,n-1){\n\t\trep(j,0,sum[r[i]])if(f[i][j]){\n\t\t\tif(sum[r[i+1]]>j)(f[i+1][j+1]+=f[i][j])%=mod;\n\t\t\tif(sum[r[i+1]]-j<r[i+1]-i)(f[i+1][j]+=f[i][j])%=mod;\n\t\t}\n\t}cout<<f[n][sum[n]]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long comb(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\n//accumulative_sum_1d acc(vec, [](char x){return x=='c';});\n//long long sum = acc(lb,ub); //[lb,ub]\nclass accumulative_sum_1d{\n  using T=long long;\n public:\n  vector<T> acc;\n  template<class Comp>\n  accumulative_sum_1d(const string& vec, Comp comp_func) : acc(vec.size()){\n    for(size_t i=0; i<vec.size(); i++) acc[i] += comp_func(vec[i]) + (i?acc[i-1]:0);\n  }\n  T operator () (int lb, int ub){if(ub<lb) return 0; return acc[ub] - (lb-1>=0?acc[lb-1]:0); }\n};\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  string s;\n  cin >> s;\n\n  combination_mod cmb(mod,n+10);\n\n  vector<int> l(m),r(m);\n  for(auto i : range(m) ){\n    cin >> l[i], r[i];\n    l[i]--;\n  }\n  vector<pair<int,int>> q;\n  int ll_ = -1;\n  int rr_ = 0;\n  for(int i=0; i<m; i++){\n    int ll = l[i];\n    int rr = r[i];\n\n    while(i+1<m && l[i+1] == ll){\n      i++;\n      rr = max(rr, r[i]);\n    }\n\n    if( rr_ >= rr ) continue;\n\n    rr_ = rr;\n    q.push_back( {ll, rr} );\n  }\n\n  q.push_back({n,n-1});\n\n  accumulative_sum_1d a(s, [](char x){return x=='1';});\n\n  vector<long long> dp(n+1, 0);\n  dp[ a(q[0].first, q[0].second-1) ] = 1;\n  for(int i=0; i<q.size()-1; i++){\n    vector<long long> dp_(n+1, 0);\n    int ll = q[i].first;\n    int rr = q[i].second;\n\n    int nx_l = q[i+1].first;\n    int nx_r = q[i+1].second;\n\n    int len = rr-ll;\n\n    int d = min(rr-ll, nx_l - ll);\n    int e = a(rr, nx_r-1);\n\n    if(nx_l >= rr){\n      for(int k=0; k<=len; k++){\n        if(dp[k] == 0) continue;\n        (dp_[ a(nx_l, nx_r-1) ] += dp[k] * cmb.comb( len, k ) % mod) %= mod;\n      }\n\n    }else{\n\n      for(int k=0; k<=len; k++){\n        if(dp[k] == 0) continue;\n        for(int one=0; one<=k && one<=d; one++){\n          int zero = d-one;\n          if(zero > (len-k)) continue;\n          (dp_[ k-one + e ] += dp[k] * cmb.comb( d, one ) % mod) %= mod;\n        }\n      }\n    }\n\n    swap(dp, dp_);\n  }\n\n  println(dp[0]);\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define mt make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate<int MOD>\nclass ModInt{\npublic:\n    ModInt():value(0){}\n    ModInt(long long val):value((int)(val<0?MOD+val%MOD:val%MOD)){ }\n\n    ModInt& operator+=(ModInt that){\n        value = value+that.value;\n        if(value>=MOD)value-=MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that){\n        value -= that.value;\n        if(value<0)value+=MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that){\n        value = (int)((long long)value * that.value % MOD);\n        return *this;\n    }\n    ModInt &operator/=(ModInt that){\n        return *this *= that.inverse();\n    }\n    ModInt operator+(ModInt that) const{\n        return ModInt(*this)+=that;\n    }\n    ModInt operator-(ModInt that) const{\n        return ModInt(*this)-=that;\n    }\n    ModInt operator*(ModInt that) const{\n        return ModInt(*this)*=that;\n    }\n    ModInt operator/(ModInt that) const {\n        return ModInt(*this) /= that;\n    }\n    ModInt pow(long long k) const{\n        if(value == 0)return 0;\n        ModInt n = *this, res = 1;\n        while(k){\n            if(k & 1)res *= n;\n            n *= n;\n            k >>= 1;\n        }\n        return res;\n    }\n    ModInt inverse() const {\n        long long a = value, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n    int toi() const{ return value; }\n\nprivate:\n    int value;\n};\ntypedef ModInt<1000000007> mint;\nostream& operator<<(ostream& os, const mint& x){\n    os << x.toi();\n    return os;\n}\n\nmint dp[3002][3002];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    // iにある文字はto[i]まで運べる(i<=to[i])\n    vi to(N);\n    iota(all(to), 1);\n    rep(i, M) {\n        int l, r;\n        cin >> l >> r;\n        --l;\n        smax(to[l], r);\n    }\n    rep(i, N - 1)smax(to[i + 1], to[i]);\n\n    vi a(N);\n    rep(i, N)a[i] = S[i] - '0';\n\n    \n    int right = 0;\n    dp[0][0] = 1;\n    // 1桁ずつ決めていく\n    rep(i, N) {\n        int x = 0;\n        while(right < to[i]) {\n            x += a[right++];\n        }\n        for(int j = 0; j <= N; ++j)if(dp[i][j].toi()) {\n            // cntはrightまで自由に移動できる1の数\n            int cnt = j + x;\n            // ここを1にする\n            if(cnt > 0)dp[i + 1][cnt - 1] += dp[i][j];\n            // ここを0にする\n            if(right - i - 1 >= cnt)dp[i + 1][cnt] += dp[i][j];\n        }\n    }\n    cout << dp[N][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 3030;\n\nconst int mod = 1e9 + 7;\n\nint n, m, far[maxn], dp[maxn][maxn], a[maxn], s[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tchar c = getchar();\n\twhile(c != '0' && c != '1') {\n\t\tc = getchar();\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\ta[i] = c - '0';\n\t\ts[i] = s[i - 1] + a[i];\n\t\tc = getchar();\n\t}\n\twhile(m--) {\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\t(r > far[l]) && (far[l] = r);\n\t}\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\t(far[i] > mx) ? (mx = far[i]) : (far[i] = 0);\n\t}\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(far[i]) {\n\t\t\tfor (int j = i; ; ++j) {\n\t\t\t\tif(j > i && far[j] || j > far[i]) {\n\t\t\t\t\t--j;\n\t\t\t\t\tfor (int k = 0; k + far[i] - j < s[far[i]]; ++k) {\n\t\t\t\t\t\tdp[j][k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ti = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k <= s[far[i]]; ++k) {\n\t\t\t\t\tdp[j][k] = dp[j - 1][k];\n\t\t\t\t\tif(k) {\n\t\t\t\t\t\t(dp[j][k] += dp[j - 1][k - 1]) %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdp[i][s[i]] = dp[i - 1][s[i - 1]];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][s[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int maxn = 3010;\nconst int mo = 1000000007;\nusing namespace std;\nint a[maxn], b[maxn], f[maxn][maxn], n, m; char s[maxn];\nvoid solve1(int l, int r) {\n\tint tot = 0;\n\trep(i, l, r) tot += a[i];\n\trep(i, l, l + tot - 1) a[i] = 1;\n\trep(i, l + tot, r) a[i] = 0;\n}\nvoid solve2(int l, int r) {\n\tint tot = 0;\n\trep(i, l, r) tot += 1 - b[i];\n\trep(i, l, l + tot - 1) b[i] = 0;\n\trep(i, l + tot, r) b[i] = 1;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\trep(i, 1, n) a[i] = b[i] = (s[i] == '1');\n\trep(i, 1, n) b[i] = a[i]; int x, y;\n\trep(i, 1, m) scanf(\"%d%d\", &x, &y), solve1(x, y), solve2(x, y);\n\trep(i, 2, n) a[i] += a[i - 1], b[i] += b[i - 1];\n\tf[0][0] = 1;\n\trep(i, 1, n) rep(j, b[i], a[i]) f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mo;\n\tprintf(\"%d\\n\", f[n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 3010;\nconst ll mod = 1e9 + 7;\nll dp[N][N];\n\nint main(){\n    int n, m;\n    string s;\n    cin >> n >> m >> s;\n\n    VI ma(n);\n    REP(i,m){\n        int l, r;\n        cin >> l >> r;\n        l--;\n        r--;\n        ma[l] = max(ma[l], r);\n    }\n\n    VI r(n);\n    REP(i,n){\n        r[i] = max(i, ma[i]);;\n        if (i > 0) r[i] = max(r[i], r[i-1]);;\n    }\n\n    VI ones(n+1);\n    REP(i,n) ones[i+1] = ones[i] + (s[i] == '1');\n\n    dp[0][0] = 1;\n    REP(i,n){\n        int one = ones[r[i]+1];\n        if (i > 0) one -= ones[r[i-1]+1];\n        // cout << one << endl;\n\n        int d = r[i] - i + 1;\n        REP(j,N-one+1){\n            int next = j + one;\n            if (next < d) dp[i+1][next] = (dp[i+1][next] + dp[i][j]) % mod;\n            if (next > 0) dp[i+1][next-1] = (dp[i+1][next-1] + dp[i][j]) % mod;\n        }\n    }\n\n    // REP(i,n+1){\n    //     REP(j,6){\n    //         cout << dp[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    cout << dp[n][0] << endl;\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\nconst int ha = 1000000007;\ninline void add(int &p, const int &val) {\n  p += val; if(p >= ha) p -= ha;\n}\n\nconst int maxn = 3005;\nint R[maxn], f[maxn][maxn];\nchar S[maxn]; int sum[maxn];\nint main() {\n  int n, m; scanf(\"%d%d\", &n, &m);\n  scanf(\"%s\", S + 1);\n  for(int i = 1; i <= n; i ++) {\n    sum[i] = sum[i - 1] + S[i] - '0';\n    R[i] = i;\n  }\n  while(m --) {\n    int l, r; scanf(\"%d%d\", &l, &r);\n    R[l] = std::max(R[l], r);\n  }\n  for(int i = 2; i <= n; i ++) R[i] = std::max(R[i], R[i - 1]);\n  R[n + 1] = n;\n  f[1][sum[R[1]]] = 1;\n  for(int i = 1; i <= n; i ++) {\n    for(int j = 0; j <= n; j ++) {\n      int th = f[i][j];\n      if(!th) continue;\n#ifdef LOCAL\n      printf(\"f[%d][%d] : %d\\n\", i, j, f[i][j]);\n#endif\n      int delta = sum[R[i + 1]] - sum[R[i]];\n      if(j) add(f[i + 1][j + delta - 1], th);\n      if(R[i] - i >= j) add(f[i + 1][j + delta], th);\n    }\n  }\n  printf(\"%d\\n\", f[n + 1][0]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pi 3.1415926535897932384626\nusing namespace std;\n      \nstruct P{\n  int x,y;\n  /*bool operator < (const P &a )const{\n    //if(y!=a.y)\n    return y<a.y;\n  };*/\n};\n\nint a,b,c,d,i,k,n,m,e,dx[10]={1,0,-1,0,1,1,-1,-1},dy[10]={0,1,0,-1,1,-1,1,-1};\nlong long o[3331][3333];\nint l[3331];\nint j[3331];\n\nlong long x,y,z,mod=1000000007;\n//string r;\nchar r[3331];\n\nP u[3331];\nqueue<int> q;\n//stack<int> s;\nset<int> s;\nmap<int,int> p;\n\nvector<int> v[2];\n\nbool as(P a,P b)\n{\n  //if(a.x!=b.x)\n  //return a.x<b.x;\n  return a.x<b.x;\n}\n\nlong long f(int n,int m)\n{\n  if(n>a) return 1;\n  //if(m>u[l[n]].y-n+1) return 0;\n  if(o[n][m]>=0) return o[n][m];\n  if(l[n]==0)\n  {\n   if(l[n+1]==0) return f(n+1,m);\n  else return f(n+1,m+j[u[l[n+1]].y]-j[n]);\n  }\n  long long k=0;\n  if(l[n+1]==0)\n  {\n    k=f(n+1,m);\n  }\n  else if(l[n+1]!=l[n])\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m+j[u[l[n+1]].y]-j[u[l[n]].y]);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1+j[u[l[n+1]].y]-j[u[l[n]].y]))%mod;\n  }\n  else\n  {\n    if(m<=u[l[n]].y-n) k=f(n+1,m);\n    if(m&&m-1<=u[l[n]].y-n) k=(k+f(n+1,m-1))%mod;\n  }\n  return o[n][m]=k;\n}\n\nint main()\n{\n  memset(o,-1,sizeof(o));\n  scanf(\"%d %d\",&a,&b);\n  scanf(\"%s\",r+1);\n  for(int t=1;t<=a;j[t]+=j[t-1],t++)\n  if(r[t]=='1') j[t]=1;\n  for(int t=1;t<=b;t++)\n  {\n    scanf(\"%d %d\",&n,&m);\n    if(u[c].x==n) u[c].y=max(u[c].y,m);\n    else if(u[c].y<m)\n    {\n      c++;\n      u[c]={n,m};\n    }\n  }\n  for(int t=1;t<=c;t++)\n  {\n    for(int i=u[t].x;i<=u[t].y;i++)\n      l[i]=t;\n  }\n  printf(\"%lld\",f(u[1].x,j[u[1].y]-j[u[1].x-1]));\n}\n//3\n//21\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nconst int maxn = 3010;\nconst int mo = 1000000007;\nusing namespace std;\nint a[maxn], b[maxn], f[maxn][maxn], n, m; char s[maxn];\nvoid solve1(int l, int r) {\n\tint tot = 0;\n\trep(i, l, r) tot += a[i];\n\trep(i, l, l + tot - 1) a[i] = 1;\n\trep(i, l + tot, r) a[i] = 0;\n}\nvoid solve2(int l, int r) {\n\tint tot = 0;\n\trep(i, l, r) tot += 1 - b[i];\n\trep(i, l, l + tot - 1) b[i] = 0;\n\trep(i, l + tot, r) b[i] = 1;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\trep(i, 1, n) a[i] = b[i] = (s[i] == '1');\n\trep(i, 1, n) b[i] = a[i]; int x, y;\n\trep(i, 1, m) scanf(\"%d%d\", &x, &y), solve1(x, y), solve2(x, y);\n\trep(i, 2, n) a[i] += a[i - 1], b[i] += b[i - 1];\n\tf[0][0] = 1;\n\trep(i, 1, n) rep(j, b[i], a[i]) f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mo;\n\tprintf(\"%d\\n\", f[n][a[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint& operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nbool done[3030][3030];\nmint dp[3030][3030];\nint mxR[3030];\nint cum[3030];\nint N, M;\nmint rec(int l,int R, int c) {\n\tif (l == N)return c==0;\n\tif (done[l][c])return dp[l][c];\n\tdone[l][c] = true;\n\tint R2 = mxR[l];\n\tint c2 = c + cum[R2] - cum[R];\n\tmint res = 0;\n\tif(R2-l-c2>0)res += rec(l + 1,R2, c2);\n\tif(c2 > 0)res+= rec(l + 1,R2, c2 - 1);\n\treturn dp[l][c] = res;\n}\n\nvoid solve() {\n\tcin >> N >> M;\n\tstring S; cin >> S;\n\tREP(i, N) {\n\t\tcum[i + 1] = cum[i] + (S[i] == '1');\n\t}\n\tREP(l, N + 1) {\n\t\tmxR[l] = l + 1;\n\t}\n\tREP(i, M) {\n\t\tint l, r; cin >> l >> r;\n\t\tl--;\n\t\tchmax(mxR[l], r);\n\t}\n\tFOR(i, 1, N + 1) {\n\t\tchmax(mxR[i], mxR[i - 1]);\n\t}\n\tmint ans = rec(0, 0,0);\n\tprint(ans);\n}\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//while (test());\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[3005][3005];\nbool ban[3005][3005];\nvector<P> problem[500005];\n// zero one\n\nvoid init(){\n\tmemset(ban, false, 3005 * 3005);\n\tmemset(dp, 0, 3005 * 3005);\n\treturn;\n}\nvoid bind(ll n, ll zero, ll one){\n\t//pe(zero);pe(one);p(n);\n\t//assert(zero + one >= n);\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t\n\t\n\tfor(ll i=0;i<=n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<=n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nll solve(ll id){\n\tvector<P> table = problem[id];\n\tll idx = table[0].first;\n\tm = table.size();\n\tll leftmost = table[0].first;\n\tll rightmost = table[0].first - 1;\n\ttable.pb(P(y.back() + 1, INF));\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = table[i].second - rightmost;\n\t\tfix[i] = table[i+1].first - table[i].first;\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\n\t\trightmost = max(table[i].second, rightmost);\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tinit();\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<=rightmost;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\tfor(ll i=0;i<=zero;i++){\n\t\tfor(ll j=0;j<=one;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}else if(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if (i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if (j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\t//p(rightmost);\n\t//pe(leftmost);p(rightmost);\n\t\n\t//pe(one);p(zero);\n\treturn dp[zero][one];\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = -1;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\n\tll problemid = 0;\n\tm = x.size();\n\n\tfor(ll i=0;i<m-1;i++){\n\t\tproblem[problemid].pb(P(x[i], y[i]));\n\t\tif(x[i+1] > y[i]){\n\t\t\tproblemid ++;\n\t\t}\n\t}\n\tproblem[problemid].pb(P(x[m-1], y[m-1]));\n\tans = 1;\n\t//assert(problemid == 0);\n\tfor(ll i=0;i<=problemid;i++){\n\t\tans *= solve(i);\n\t\t//p(ans);\n\t\tans %= mod;\n\t}\n\tp(ans);\n\n\t\n\t/*\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<=n;i++){\n\t\tfor(ll j=0;j<=n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\t\n\n\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define MAXN 4010\n#define mo 1000000007\n\nint n, m, a[MAXN];\nint sum[MAXN];\nint f[MAXN][MAXN];\nchar s[MAXN];\n\nvoid Init()\n{\n    int i;\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s + 1);\n    for(i = 1; i <= n; ++i){\n        a[i] = s[i] - '0';\n        sum[i] = sum[i - 1] + a[i];\n    }\n}\n\nvoid Dp()\n{\n    int i, j = 1, k, l, r, R = 0, ad = 0;\n    f[0][0] = 1;\n    for(i = 1; i <= m; ++i){\n        scanf(\"%d %d\", &l, &r);\n        for(; j < l; ++j, ad = 0){\n            if(j > R){\n                R = j;\n                ad += a[j];\n            }\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n        if(r > R){\n            ad += sum[r] - sum[R];\n            R = r;\n        }\n        for(; j <= l; ++j, ad = 0){\n            for(k = 0; k <= sum[R] && j + k <= R; ++k){\n                if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n                if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n            }\n        }\n    }\n    for(; j <= n; ++j, ad = 0){\n        if(j > R){\n            R = j;\n            ad += a[j];\n        }\n        for(k = 0; k <= sum[R] && j + k <= R; ++k){\n            if(k - ad >= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad]) % mo;\n            if(k - ad + 1>= 0) f[j][k] = (f[j][k] + f[j - 1][k - ad + 1]) % mo;\n        }\n    }\n    printf(\"%d\\n\", f[n][0]);\n}\n\nint main()\n{\n    Init();\n    Dp();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 3e3 + 5;\nconst int mod = 1e9 + 7; \nusing namespace std;\n\nint n, m, a[N], l[N], r[N], vis[N], sum[N], c[N][N], f[N][N], mx[N], len[N]; \nstruct node\n{\n\tint l, r;\n\tbool operator < (const node &p) const\n\t\t{\n\t\t\treturn l == p.l ? r > p.r : l < p.l; \n\t\t}\n} p[N];\nchar s[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (), scanf(\"%s\", s + 1);\n\tfor(int i = 1; i <= n; i++) a[i] = s[i] - '0';\n\tfor(int i = 1; i <= m; i++) p[i].l = read <int> (), p[i].r = read <int> ();\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = p[i].l; j <= p[i].r; j++) vis[j] = 1; \n\tsort(p + 1, p + m + 1); int tmp = m; m = 0;\n\tfor(int x = 0, i = 1; i <= tmp; i++)\n\t\tif(p[i].r > x) x = p[i].r, p[++m] = p[i]; \n\tp[m + 1].l = n * 2; \n\tfor(int i = 1; i <= n; i++) sum[i] = sum[i - 1] + vis[i] * a[i]; \n\tfor(int i = 1; i <= m; i++) mx[i] = sum[p[i].r]; \n\tfor(int i = 1; i <= m; i++) l[i] = p[i].l, r[i] = min(p[i + 1].l - 1, p[i].r), len[i] = len[i - 1] + r[i] - l[i] + 1; \n\tfor(int i = 0; i <= n; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t\tc[i][j] = (!j ? 1 : (c[i - 1][j - 1] + c[i - 1][j]) % mod); \n\tf[0][0] = 1; \n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = 0; j <= mx[i - 1]; j++)\n\t\t\tfor(int k = 0; k <= mx[i] - j; k++)\n\t\t\t{\n\t\t\t\tif((mx[i] - j - k) > p[i].r - r[i] || (p[i].r - r[i] + j + k - mx[i]) > p[i].r - r[i]) continue; \n\t\t\t\tf[i][j + k] = (1ll * c[r[i] - l[i] + 1][k] * f[i - 1][j] + f[i][j + k]) % mod;\n\t\t\t}\n\tprintf(\"%d\\n\", f[m][sum[n]]); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m&&n|m;){\n\t\tstring s; cin>>s;\n\t\tvi ls(m),rs(m);\n\t\trep(i,m) cin>>ls[i]>>rs[i];\n\n\t\t{\n\t\t\tvector<tuple<int,int>> ts;\n\t\t\trep(i,m) if(ts.empty()||rs[i-1]<rs[i]){\n\t\t\t\tif(ts.size()&&ls[i-1]==ls[i])\n\t\t\t\t\tts.back()=mt(ls[i]-1,rs[i]);\n\t\t\t\telse\n\t\t\t\t\tts.emplace_back(ls[i]-1,rs[i]);\n\t\t\t}\n\t\t\tint l0=get<0>(ts[0]);\n\t\t\ts=s.substr(l0);\n\t\t\tn=s.size();\n\t\t\tm=ts.size();\n\t\t\tls.resize(m),rs.resize(m);\n\t\t\trep(i,m){\n\t\t\t\ttie(ls[i],rs[i])=ts[i];\n\t\t\t\tls[i]-=l0,rs[i]-=l0;\n\t\t\t}\n\t\t}\n\n\t\tvi zcount(n+1),ocount(n+1);\n\t\trep(i,n){\n\t\t\tzcount[i+1]=zcount[i];\n\t\t\tocount[i+1]=ocount[i];\n\t\t\t(s[i]=='0'?zcount:ocount)[i+1]++;\n\t\t}\n\n\n\t\tvvi dp(n+1,vi(n+1));  // [文字数]['0'の使用回数]\n\t\tdp[0][0]=1;\n\n\t\tls.push_back(n);\n\t\trep(k,m)\n\t\t\trepi(i,ls[k],ls[k+1])\n\t\t\t\trep(j,i+1){\n\t\t\t\t\tif(j+1<=zcount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j+1]+=dp[i][j])%=MOD;\n\t\t\t\t\tif(i+1-j<=ocount[rs[k]])\n\t\t\t\t\t\t(dp[i+1][j]+=dp[i][j])%=MOD;\n\t\t\t\t}\n\n\t\tcout<<dp[n][zcount[n]]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=3005;\nconst int mod=1e9+7;\nint n,q,dp[N],lim_r[N],sum0[N];\n\nnamespace utils{\n\ttemplate <class T> inline void apx(T &x,const T y){\n\t\tx<y?x=y:0;\n\t}\n\ttemplate <class T> inline void apn(T &x,const T y){\n\t\tx>y?x=y:0;\n\t}\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n}\nusing namespace utils;\n\nint main(){\n\tstatic char str[N];\n\tn=nxi(),q=nxi();\n\tscanf(\"%s\",str+1);\n\tfor(int i=1; i<=n; ++i){\n\t\tlim_r[i]=i;\n\t\tsum0[i]=sum0[i-1]+(str[i]=='0');\n\t}\n\tfor(int i=1; i<=q; ++i){\n\t\tconst int x=nxi(),y=nxi();\n\t\tfor(int i=x; i<y; ++i){\n\t\t\tapx(lim_r[i],y);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tapx(lim_r[i],lim_r[i-1]);\n\t}\n\tdp[0]=1;\n\tfor(int i=0; i<n; ++i){\n\t\tstatic int fp[N];\n\t\tmemcpy(fp,dp,n*sizeof(int));\n\t\tmemset(dp,0,n*sizeof(int));\n\t\tint r=lim_r[i+1];\n\t\tint add_0=sum0[r]-sum0[lim_r[i]];\n\t\tfor(int j=0; j<=r; ++j){\n\t\t\tif(!fp[j]) continue;\n\t\t\t//print 1\n\t\t\tif(j+add_0<r-i){\n\t\t\t\tdp[j+add_0]=(dp[j+add_0]+fp[j])%mod;\n\t\t\t}\n\t\t\t//print 0\n\t\t\tif(j+add_0-1>=0){\n\t\t\t\tdp[j+add_0-1]=(dp[j+add_0-1]+fp[j])%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//void __(){\n//    _(int,n);\n//    _(int,m);\n//    _(string,s);\n//    string s_lo = s, s_hi = s;\n//    rep(i,m){\n//        _(int,l);\n//        _(int,r);\n//        --l;\n//        sort(s_lo.begin()+l,s_lo.begin()+r);\n//        sort(s_hi.begin()+l,s_hi.begin()+r);\n//        reverse(s_hi.begin()+l,s_hi.begin()+r);\n//    }\n//    print s_lo;\n//    print s_hi;\n//    vi lo(n), hi(n);\n//    {\n//        int cnt = 0;\n//        rep(i,n)\n//            if(s_lo[i] == '1'){\n//                hi[cnt] = i;\n//                ++cnt;\n//            }\n//    }\n//    {\n//        int cnt = 0;\n//        rep(i,n)\n//            if(s_hi[i] == '1'){\n//                lo[cnt] = i;\n//                ++cnt;\n//            }\n//    }\n//    vvi dp(n+1,vi(n+1));\n//    dp[0][0] = 1;\n//    rep(i,n)\n//        rep(ones,i+1){\n//            if(!dp[i][ones]) continue;\n//            if(lo[ones] <= i && i <= hi[ones]){\n//                dp[i+1][ones+1] += dp[i][ones];\n//                if(dp[i+1][ones+1] >= MOD)\n//                    dp[i+1][ones+1] -= MOD;\n//            }\n//            dp[i+1][ones] += dp[i][ones];\n//            if(dp[i+1][ones] >= MOD)\n//                dp[i+1][ones] -= MOD;\n//        }\n//    int ones = count(all(s),'1');\n//    print dp[n][ones];\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define REP_ZERO_INT(i,r) for(int i = 0; i < r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT,REP_ZERO_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst ll MOD = 1e9 + 7;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nstruct _print {\n    string sep,end;\n    bool space;\n    ostream &stream;\n    _print(string _sep=\" \",string _end=\"\\n\",\n            ostream &_stream = cout)\n        : sep(_sep),end(_end),space(false),\n            stream(_stream) {}\n    ~_print() { stream << end; }\n    template <typename T>\n        _print &operator , (const T &t) {\n            if (space) stream << sep;\n            space = true;\n            stream << t;\n            return *this;\n        }\n};\n#define print _print(),\n#define INPUT_WITHOUT_INIT(type,name) type name; cin >> name\n#define GET_INPUT_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define _(...) GET_INPUT_MACRO(__VA_ARGS__,_IWI,_IWI,_IWI,_IWI,_IWI,_IWI,INPUT_WITHOUT_INIT)(__VA_ARGS__)\nvoid __(){\n    _(int,n);\n    _(int,m);\n    _(string,s);\n    string s_lo = s, s_hi = s;\n    rep(i,m){\n        _(int,l);\n        _(int,r);\n        --l;\n        sort(s_lo.begin()+l,s_lo.begin()+r);\n        sort(s_hi.begin()+l,s_hi.begin()+r);\n        reverse(s_hi.begin()+l,s_hi.begin()+r);\n    }\n    print s_lo;\n    print s_hi;\n    vi lo(n), hi(n);\n    {\n        int cnt = 0;\n        rep(i,n)\n            if(s_lo[i] == '1'){\n                hi[cnt] = i;\n                ++cnt;\n            }\n    }\n    {\n        int cnt = 0;\n        rep(i,n)\n            if(s_hi[i] == '1'){\n                lo[cnt] = i;\n                ++cnt;\n            }\n    }\n    vvi dp(n+1,vi(n+1));\n    dp[0][0] = 1;\n    rep(i,n)\n        rep(ones,i+1){\n            if(!dp[i][ones]) continue;\n            if(lo[ones] <= i && i <= hi[ones]){\n                dp[i+1][ones+1] += dp[i][ones];\n                if(dp[i+1][ones+1] >= MOD)\n                    dp[i+1][ones+1] -= MOD;\n            }\n            dp[i+1][ones] += dp[i][ones];\n            if(dp[i+1][ones] >= MOD)\n                dp[i+1][ones] -= MOD;\n        }\n    int ones = count(all(s),'1');\n    print dp[n][ones];\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        __();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <cmath>\n#include <bitset>\n#include <map>\n\ntypedef long long ll;\n\nusing namespace std;\n\n#define all(x) x.begin(), x.end()\n\nconst long long MOD = 1e9 + 7;\n\nll n, m;\nstring s;\nll l[5000], r[5000];\nll dp[3001][3001];\nll ps[5000];\nll cnk[3001][3001];\n\nint summ(int l, int r)\n{\n    return ps[r] - ps[l - 1];\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> m;\n    cnk[0][0] = 1;\n    for (int i = 0; i <= 3000; i++) cnk[i][0] = cnk[i][i] = 1;\n    for (int i = 0; i <= 3000; i++) for (int j = 1; j < i; j++) cnk[i][j] = (cnk[i - 1][j - 1] + cnk[i - 1][j]) % MOD;\n    //s = \"0\" + s;\n    cin >> s;\n    s = \"0\" + s + \"0\";\n    for (int i = 1; i <= n; i++)\n    {\n        ps[i] = ps[i - 1] + s[i] - '0';\n    }\n    cout << cnk[n][summ(1, n)] << endl;\n    return 0;\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> l[i] >> r[i];\n        if (i > 1 && l[i - 1] <= l[i] && r[i] <= r[i - 1])\n        {\n            i--;\n            m--;\n        }\n    }\n    m++;\n    l[m] = n + 1;\n    r[m] = n + 1;\n    dp[0][summ(l[1], r[1])] = 1;\n    for (int i = 1; i < m; i++)\n    {\n        if (r[i] < l[i + 1])\n        {\n            for (int j = 0; j <= n; j++)\n            {\n                dp[i][summ(l[i + 1], r[i + 1])] = (dp[i][summ(l[i + 1], r[i + 1])] + dp[i - 1][j]) % MOD;\n            }\n            continue;\n        }\n        for (int y = summ(r[i] + 1, r[i + 1]); y <= r[i + 1] - l[i + 1] + 1; y++)\n        {\n            int delta = y - summ(r[i] + 1, r[i + 1]);\n            for (int x = delta; x <= r[i] - l[i] + 1; x++)\n            {\n                dp[i][y] = (dp[i][y] + cnk[x][delta] * dp[i - 1][x]) % MOD;\n            }\n        }\n    }\n    cout << (dp[m - 1][0] + dp[m - 1][1]) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define ED(x) ((int)x.size()-1)\n#define _for(i,a,b) for(int i=(a);i<=(b);++i)\n#define _rep(i,a,b) for(int i=(a);i>=(b);--i)\n#define changxv ios::sync_with_stdio(0);cin.tie(0);\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int maxn=3003;\nconst int INF=0x3f3f3f3f;\nconst int mod=1e9+7;\n\nint f[maxn][maxn];\nint s[maxn],r[maxn];\n\nint main(){changxv\n\tint n,m;cin>>n>>m;\n\t_for(i,1,n){\n\t\tchar c;cin>>c;\n\t\ts[i]=s[i-1]+c-'0';\n\t}\n\ts[n+1]=s[n];\n//\t_for(i,1,n)cerr<<s[i]<<' ';\n//\tcerr<<'\\n';\n\t_for(i,1,n+1)r[i]=i;\n\t_for(i,1,m){\n\t\tint x,y;cin>>x>>y;\n\t\tr[x]=max(r[x],y);\n\t}\n\t_for(i,1,n+1)r[i]=max(r[i],r[i-1]);\n\t\n\tf[1][s[r[1]]]=1;\n\t_for(i,1,n){\n\t\t_for(j,0,n)if(f[i][j]){\n\t\t\tint L=r[i]+1,R=r[i+1];\n\t\t\tif(j)(f[i+1][j-1+s[R]-s[L-1]]+=f[i][j])%=mod;\n\t\t\tif(r[i]-i+1-j)(f[i+1][j+s[R]-s[L-1]]+=f[i][j])%=mod;\n\t\t}\n\t}\n\tcout<<f[n+1][0]<<'\\n';\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int MOD = 1e9 + 7;\n\nstruct Segment {\n    int l, r;\n};\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    string s;\n    cin >> s;\n\n    vector<Segment> seqs;\n    while (m-- > 0) {\n        int l, r;\n        cin >> l >> r;\n\n        if (SZ(seqs) > 0 && r <= seqs.back().r) {\n            continue;\n        }\n        seqs.push_back({l, r});\n    }\n    m = SZ(seqs);\n   \n    vector<int> dp0(n + 1, 0), dp1(n + 1, 0);\n    vector<int> ndp0(n + 1, 0), ndp1(n + 1, 0);\n\n    dp0[0] = 1;\n    dp1[0] = 0;\n    int last = 0;\n    for (int i = 1, j = 0; i <= n; ++i) {\n        while (j < m && i > seqs[j].r) {\n            j++;\n        }\n        if (j == m) {\n            break;\n        }\n        memset(ndp0.data(), 0, sizeof(int) * (i + 1));\n        memset(ndp1.data(), 0, sizeof(int) * (i + 1));\n        \n        if (s[i - 1] == '1') {\n            for (int k = i - 1; k >= seqs[j].l; --k) {\n                ndp0[k + 1] = dp0[k];\n            }\n            for (int k = 1; k <= i; ++k) {\n                ndp0[k] = (ndp0[k - 1] + ndp0[k]) % MOD;\n            }\n            for (int k = 0; k < i; ++k) {\n                ndp1[k] = dp1[k];\n            }\n            ndp1[i] = (dp0[i - 1] + ndp1[i - 1]) % MOD;\n        } else {\n            for (int k = i - 1; k >= seqs[j].l; --k) {\n                ndp1[k + 1] = dp1[k];\n            }\n            for (int k = 1; k <= i; ++k) {\n                ndp1[k] = (ndp1[k - 1] + ndp1[k]) % MOD;\n            }\n            for (int k = 0; k < i; ++k) {\n                ndp0[k] = dp0[k];\n            }\n            ndp0[i] = (dp1[i - 1] + ndp0[i - 1]) % MOD;\n        }\n        dp0.swap(ndp0);\n        dp1.swap(ndp1);\n        last = i;\n    }\n    int ans = (dp0[last] + dp1[last]) % MOD;\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int64_t\n\nconst ll mod=1e9+7;\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tvector<char> s(n+5),t(n+5);\n\tvector<vector<ll>> dp(n+5,vector<ll>(n+5));\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>s[i];\n\t\tt[i]=s[i];\n\t}\n\tfor(int i=0;i<m;++i){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tsort(s.begin()+l,s.begin()+r+1);\n\t\tsort(t.begin()+l,t.begin()+r+1,greater<char>());\n\t}\n\tdp[0][0]=1;\n\tint lo=0,hi=0;\n\tfor(int i=1;i<=n;++i){\n\t\tlo+=s[i]=='1';\n\t\thi+=t[i]=='1';\n\t\tfor(int j=lo;j<=hi;++j)\n\t\t\t(dp[i][j]=dp[i-1][j]+(j>0?dp[i-1][j-1]:0))%=mod;\n\t}\n\tcout<<dp[n][lo]<<'\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define R register\nusing namespace std;\nconst int mod=1000000007;\nconst int MAXN=3100;\nint pre[MAXN];\nint dp[MAXN][MAXN],r[MAXN];\nchar s[MAXN];\n\nvoid reads(char* st)\n{\n\tint len=0;char ch=getchar();\n\twhile(ch<'0'||ch>'1')ch=getchar();\n\twhile(ch>='0'&&ch<='1')st[++len]=ch,ch=getchar();\n}\n\nvoid add(int &x,int y)\n{x=(x+y)%mod;}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\treads(s);\n\tfor(int i=1;i<=n;++i)\n\t  if(s[i]=='1')pre[i]=pre[i-1]+1;\n\t  else pre[i]=pre[i-1];\n\tpre[n+1]=pre[n];\n\tint t1,t2;\n\tfor(R int i=1;i<=n+1;++i)r[i]=i;\n\tfor(R int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tif(t2>r[t1])r[t1]=t2;\n\t}\n\tfor(R int i=1;i<=n+1;++i)\n\t  if(r[i-1]>r[i])r[i]=r[i-1];\n\tdp[1][pre[r[1]]]=1;\n\tfor(R int i=1;i<=n;++i)\n\t  for(R int j=0;j<=n;++j)\n\t    if(dp[i][j])\n\t    {\n\t    \tif(r[i]-i-j+1)add(dp[i+1][j+pre[r[i+1]]-pre[r[i]]],dp[i][j]);\n\t    \tif(j)add(dp[i+1][j-1+pre[r[i+1]]-pre[r[i]]],dp[i][j]);\n\t    }\n\tprintf(\"%d\\n\",dp[n+1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<cstring>\n#define N 3005\nusing namespace std;\nconst int mod=1e9+7;\nint n,m;\nchar t[N];\nint s[N],val[N],dp[2][N];\nint main(){\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,t+1);\n\tfor(int i=1;i<=n;i++) s[i]=t[i]-'0'+s[i-1];\n\tint cnt=0;\n\tfor(int i=1,ml,mr;i<=m;i++)\n\t\tscanf(\"%d%d\",&ml,&mr),val[ml]=max(val[ml],mr);\n\tfor(int i=1;i<=n;i++) val[i]=max(max(i,val[i]),val[i-1]); \n\tint now=0;\n\tdp[now][0]=1;\n\tfor(int i=1;i<=n;i++,now^=1){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=s[val[i]]-(val[i]-i);j<=s[val[i]];j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+ (j==0?0:dp[now][j-1]) )%mod;\n\t}\n\tcout<<dp[now][s[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mo=int(1e9+7);\nint n,m,r[3010],sum[3010],f[3010][3010];\nchar s[3010];\n\nvoid work()\n{\n\tscanf(\"%d %d\\n%s\",&n,&m,s+1);\n\tfor (int i=1; i<=n; i++)  sum[i]=sum[i-1]+(s[i]=='1'),r[i]=i;\n\tfor (int i=1,x,y; i<=m; i++)  scanf(\"%d %d\",&x,&y),r[x]=max(r[x],y);\n\tfor (int i=1; i<=n; i++)  r[i]=max(r[i],r[i-1]);\n\tf[0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<=sum[r[i-1]]; j++)\n\t\t\tif (f[i-1][j])\n\t\t\t\t{\n\t\t\t\t\tif (sum[r[i]]>j)  f[i][j+1]=(f[i][j+1]+f[i-1][j])%mo;\n\t\t\t\t\tif (sum[r[i]]-j<r[i]-i+1)  f[i][j]=(f[i][j]+f[i-1][j])%mo;\n\t\t\t\t}\n\tprintf(\"%d\",f[n][sum[n]]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nlong long int INF = 3e18;\nconst ll fact_table = 800008;\ndouble Pi = 3.1415926535897932384626;\n \n//vector<ll> G[550010];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n \nll dx[8]={1,0,-1,0,1,1,-1,-1};\nll dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n \n \n#define p(x) cout<<x<<\"\\n\";\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define CLEAR(a) a = decltype(a)(); \n \n \n//ll mod = 998244353;\nll mod = 1000000007;\n \nll rui(ll number1,ll number2){\n \n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n \n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n \n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n \n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n \n/*\nll fact[fact_table + 5],rfact[fact_table + 5];\n \nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=fact_table; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n    rfact[fact_table] = rui(fact[fact_table],mod - 2);\n    for(ll i=fact_table; i>=1; i--){\n       rfact[i-1] = rfact[i] * i;\n       rfact[i-1] %= mod;\n    }\n    return;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod ) * rfact[n-r]) % mod;}\n*/\n \nll n,m,num,sum,a,b,c,d,e,g,h,w,i,j,q,r,l;\nll k;\nll ans;\nvector <ll> x;\nvector <ll> y;\nll fix[500005], append[500005];\nchar s[500005], t[500005], u[500005];\nll dp[4004][4004];\nbool ban[5005][5005];\n// zero one\nvoid bind(ll n, ll zero, ll one){\n\tfor(ll i=0;i<n;i++){\n\t\tll j = n - i;\n\t\tif(zero < i || one < j){\n\t\t\tban[i][j] = true;\n\t\t}\n\t}\n\t/*n\n\tfor(ll i=0;i<n;i++){\n\t\tif(i + one + 1 <= n){\n\t\t\tban[i][one + 1] = true;\n\t\t}\n\t}\n\tfor(ll j=0;j<n;j++){\n\t\tif(zero + 1 + j <= n){\n\t\t\tban[zero + 1][j] = true;\n\t\t}\n\t}\n\t*/\n\treturn;\n}\nint main(){\n\tcin >> n >> m;\n\tcin >> s;\n\tll leftmost = INF;\n\tll rightmost = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tcin >> a >> b;\n\t\ta --;\n\t\tb --;\n\t\tif(b <= rightmost)continue;\n\t\trightmost = max(b, rightmost);\n\t\tleftmost = min(a, leftmost);\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t}\n\tll idx = leftmost;\n\tm = x.size();\n\trightmost = x[0] - 1;\n\tx.pb(y.back() + 1);\n\tfor(ll i=0;i<m;i++){\n\t\tappend[i] = y[i] - rightmost;\n\t\tfix[i] = x[i+1] - x[i];\n\t\t//pe(append[i]);\n\t\t//p(fix[i]);\n\t\trightmost = y[i];\n\t}\n\tll zero = 0, one = 0;\n\tll fixsum = 0;\n\tfor(ll i=0;i<m;i++){\n\t\tll myappend = append[i];\n\t\twhile(myappend--){\n\t\t\tif(s[idx] == '1'){\n\t\t\t\tone++;\n\t\t\t}else{\n\t\t\t\tzero++;\n\t\t\t}\n\t\t\tidx ++;\n\t\t}\n\t\tfixsum += fix[i];\n\t\tbind(fixsum, zero, one);\n\t}\n\tdp[0][0] = 1;\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tif(ban[i][j]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i == 0 && j == 0){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}else if(i == 0){\n\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t}else if(j == 0){\n\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t}else{\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tone = 0, zero = 0;\n\tfor(ll i=leftmost;i<n;i++){\n\t\tif(s[i] == '1'){\n\t\t\tone ++;\n\t\t}else{\n\t\t\tzero ++;\n\t\t}\n\t}\n\t//pe(one);p(zero);\n\tp(dp[zero][one]);\n\t/*\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(ban[i][j]);\n\t\t}\n\t\tel;\n\t}\n\tfor(ll i=0;i<n;i++){\n\t\tfor(ll j=0;j<n;j++){\n\t\t\tpe(dp[i][j]);\n\t\t}\n\t\tel;\n\t}\n\t*/\n\n\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 3010\n#define LL long long\nusing namespace std;\n\nconst LL P=1000000009;\n\nint n,m;\nint s[MAXN];\nint p[MAXN][2];\nLL c[MAXN][MAXN];\nLL f[MAXN][MAXN];\n\nvoid init(){\n\tint _m;\n\tscanf(\"%d%d\",&n,&_m);\n\tstatic char str[MAXN];\n\tscanf(\"%s\",str+1);\n\tfor(int i=1;i<=n;i++) s[i]=s[i-1]+(str[i]=='1'?1:0);\n\tfor(int i=1;i<=_m;i++){\n\t\tint l,r;\n\t\tscanf(\"%d%d\",&l,&r);\n\t\tif(!m || r>p[m][1]){\n\t\t\tp[++m][0]=l;\n\t\t\tp[m][1]=r;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%P;\n\t}\n}\n\nvoid update(LL &x,LL y){ x=(x+y)%P; }\n\nvoid dp(){\n\tf[1][s[p[1][1]]-s[p[1][0]-1]]=1;\n\tfor(int i=1;i<m;i++)\n\t\tif(p[i+1][0]<=p[i][1]){\n\t\t\tint delta=s[p[i+1][1]]-s[p[i][1]];\n\t\t\tfor(int j=0;j<=p[i][1]-p[i][0]+1;j++)\n\t\t\t\tfor(int k=max(j-(p[i][1]-p[i+1][0]+1),0);k<=p[i+1][0]-p[i][0] && k<=j;k++)\n\t\t\t\t\tupdate(f[i+1][j-k+delta],f[i][j]*c[p[i+1][0]-p[i][0]][k]);\n\t\t}else{\n\t\t\tint delta=s[p[i+1][1]]-s[p[i+1][0]-1];\n\t\t\tfor(int j=0;j<=p[i][1]-p[i][0]+1;j++)\n\t\t\t\tupdate(f[i+1][delta],f[i][j]*c[p[i][1]-p[i][0]+1][j]);\n\t\t}\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tinit();\n\tdp();\n\tLL ans=0;\n\tfor(int i=0;i<=p[m][1]-p[m][0]+1;i++)\n\t\tupdate(ans,f[m][i]*c[p[m][1]-p[m][0]+1][i]);\n\tprintf(\"%lld\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n#define P 1000000007\n\nstruct BIT{\n  ll M=1;\n  vector<ll> dat;\n  BIT(ll N){\n    while(N>M) M*=2;\n    dat.resize(M*2-1, 0);\n  }\n  void update(ll x, ll k){\n    for(int i=k+1;i<=M;i+=(i&(-i))){\n      dat[i] += x;\n    }\n  }\n  ll sum(ll r){\n    ll ret = 0;\n    for(int k=r;k>0;k-=(k&(-k))) ret += dat[k];\n    return ret;\n  }\n\n  ll query(ll l, ll r){\n    return sum(r) - sum(l);\n  }\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, m;std::cin >> n >> m;\n  vvl dp = VV(n+1, n+1, 0, ll);\n  string s;std::cin >> s;\n  BIT b(n+1);\n  for(int i=0;i<n;i++) b.update((s[i]=='1'), i);\n  dp[0][0] = 1;\n  vvl d;\n  ll r = -1;\n  for(int i=0;i<m;i++){\n    ll x, y;std::cin >> x >> y;\n    x--, y--;\n    if(r>=y) continue;\n    r = y;\n    if(d.size()!=0&&d[d.size()-1][0]==x){\n      d[d.size()][1] = r;\n    }else{\n      d.push_back(vll{x, y});\n    }\n  }\n  m = d.size();\n  for(int i=0;i<n;i++){\n    auto itr = upper_bound(all(d), vll{i, -1});\n    ll r;\n\n    if(itr==d.begin()) r = i-1;\n    else {\n      r = (*--itr)[1];\n      if(r < i) r = i-1;\n    }\n    ll sa = r - i + 1;\n    itr = upper_bound(all(d), vll{i, 100000});\n\n    ll ad = 0;\n    if(itr!=d.begin()){\n      itr--;\n      if((*itr)[0]==i){\n        ad = b.query(r+1, (*itr)[1]+1);\n        sa = (*itr)[1] - i + 1;\n      }\n    }\n    if(sa==0){\n      dp[i+1] = dp[i];\n    }else{\n      //元々のr\n      for(int j=0;j<=n;j++){\n        ll one = j + ad;\n        if(one>n || sa < one) continue;\n        ll zero = sa - one;\n        if(one) dp[i+1][one-1] = (dp[i+1][one-1] + dp[i][j])%P;\n        if(zero) dp[i+1][one] = (dp[i+1][one] + dp[i][j])%P;\n      }\n    }\n  }\n  std::cout << dp[n][0] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nint solve(string s, vector<int> l, vector<int> r) {\n\tint N = s.length(), M = l.size();\n\tint R = l[0], zero = 0, one = 0;\n\tint j = 0;\n\tvector<int> dp(N + 1);\n\tdp[0] = 1;\n\tfor (int i = l[0]; i < r[M - 1]; i++) {\n\t\tif (j < M && i == l[j]) {\n\t\t\tfor (int i = R; i < r[j]; i++) {\n\t\t\t\tif (s[i] == '0') zero++;\n\t\t\t\tif (s[i] == '1') one++;\n\t\t\t}\n\t\t\tR = r[j];\n\t\t\tj++;\n\t\t}\n\t\tvector<int> _dp(N + 1);\n\t\tfor (int x = 0; x <= N; x++) {\n\t\t\tint k0 = i - l[0] - x, k1 = x;\n\t\t\tif (k0 < zero) _dp[x] = (_dp[x] + dp[x]) % MOD;\n\t\t\tif (k1 < one) _dp[x + 1] = (_dp[x + 1] + dp[x]) % MOD;\n\t\t}\n\t\tdp = _dp;\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= N; x++)\n\t\tans = (ans + dp[x]) % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tvector<int> l, r;\n\tint ma = 0;\n\twhile (M--) {\n\t\tint x, y; cin >> x >> y;\n\t\tx--;\n\t\tif (y <= ma) continue;\n\t\tma = y;\n\t\tl.pb(x); r.pb(y);\n\t}\n\tM = l.size();\n\tvector<int> v;\n\tv.pb(0);\n\tfor (int j = 0; j + 1 < M; j++)\n\t\tif (r[j] <= l[j + 1])\n\t\t\tv.pb(j + 1);\n\tv.pb(M);\n\tint ans = 1;\n\tfor (int k = 0; k + 1 < v.size(); k++) {\n\t\tvector<int> _l, _r;\n\t\tfor (int j = v[k]; j < v[k + 1]; j++)\n\t\t\t_l.pb(l[j]), _r.pb(r[j]);\n\t\tans = (ll)ans * solve(s, _l, _r) % MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <iostream>\nusing namespace std;\nconst int N=3010,mo=1e9+7;\nint n,m,f[N][N],mx[N],sum[N];\nint main()\n{\n    scanf(\"%d%d\\n\",&n,&m);\n    for (int i=1;i<=n;i++) sum[i]=getchar()-'0';\n    for (int i=1;i<=n+1;i++) sum[i]+=sum[i-1];\n    for (int i=1;i<=n+1;i++) mx[i]=i;\n    for (int i=1,x,y;i<=m;i++) scanf(\"%d%d\",&x,&y),mx[x]=max(mx[x],y);\n    for (int i=1;i<=n;i++) mx[i]=max(mx[i],mx[i-1]) ;\n    f[1][sum[mx[1]]]=1;\n    for (int i=1,l,r,x,y;i<=n;i++) for (int j=0;j<=n;j++) if (f[i][j])\n\t{\n    \tl=mx[i]+1,r=mx[i+1],x=j,y=mx[i]-i+1-j;\n        if (y) (f[i+1][j+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n        if (x) (f[i+1][j-1+sum[r]-sum[l-1]]+=f[i][j])%=mo;\n    }\n    printf(\"%d\\n\",f[n+1][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(i, a, b) for(int i = (int)a; i <= (int)b; i++)\n#define DEC(i, a, b) for(int i = (int)a; i >= (int)b; i--)\ntypedef pair<int, int> pi;\n#define f first\n#define s second\n#define pb push_back\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0)\n\nll dp[3005][3005], mm = 1e9+7;\n//dp[i][j] = fixed all before i, from [i, n] there are j 1's\nint n, m, num[3005], r[3005], a, b;\nstring s;\nvector<pi> v;\n\nvoid add(ll &a, ll b) {\n\tb %= mm;\n\ta += b;\n\ta %= mm;\n}\n\nint main() {\n\tcin >> n >> m >> s;\n\tFOR(i, 0, n-1) r[i] = i;\n\tFOR(i, 1, m) {\n\t\tcin >> a >> b; a--; b--;\n\t\tif (v.empty()) v.pb(pi(a, b));\n\t\telse if (v.back().f == a) v.back().s = max(v.back().s, b);\n\t\telse if (v.back().s < b) v.pb(pi(a, b));\n\t}\n\tfor(auto it:v) r[it.f] = it.s;\n\tFOR(i, 1, n-1) r[i] = max({i, r[i], r[i-1]});\n\t\n\tnum[0] = (s[0] == '1');\n\tFOR(i, 1, n-1) num[i] = num[i-1] + (s[i] == '1');\n\n\tdp[0][num[n-1]] = 1;\n\tFOR(i, 0, n-1) FOR(j, 0, num[n-1]) {\n\t\tif (dp[i][j] == 0) continue;\n\t\tint inr = j - (num[n-1] - num[r[i]]);\n\t\tif (inr > 0) add(dp[i+1][j-1], dp[i][j]);\n\t\tif (r[i] - i + 1 > inr) add(dp[i+1][j], dp[i][j]);\n\t}\n\tcout << dp[n][0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[3005],fx[3005],inv[3005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=3001;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=3001;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=3001;++i)fx[i]=inv[i]%mod*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][3005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn 1ll*fac[n]%mod*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tint cnt=0;\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d\",&p[i].l,&p[i].r);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j)%mod)%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k)%mod)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]%mod);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\ts = 'A' + s;\n\tvector<int>r(N+1, 0);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R;\n\t\tr[L] = max(r[L], R);\n\t}\n\tfor (int i = 1; i <= N; i++)r[i] = max(r[i], i);\n\tR = 0;\n\tint zero = 0;\n\tvector<vector<long  long int>>dp(N + 1, vector<long long int>(N + 1));\n\tdp[0][0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = R + 1; j <= max(R, r[i]); j++)if (s[j] == '0')zero++;\n\t\tR = max(R, r[i]);\n\t\tint mzero = zero - min(zero, (R - i));\n\t\tint Mzero = min(zero, i);\n\t\t//cout << i << \" zero \" << mzero << \" \" << Mzero << endl;\n\t\tfor (int j = mzero; j <= Mzero; j++) {\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\tif (j)dp[i][j] += dp[i - 1][j - 1];\n\t\t\tdp[i][j] %= MOD;\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t//\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}\n\t}\n\tcout << dp.back()[zero] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\nint getint()\n{\n    char ch=getchar();\n    int f=1,x=0;\n    while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-'0'; ch=getchar();}\n    return f*x;\n}\n\nconst int N=3030;\nconst int MOD=1000000007;\n\nint n,m;\nchar s[N];\nint sum[N];\nint l[N],r[N];\nlong long c[N][N],f[N][N];\n\nvoid init()\n{\n    n=getint(),m=getint();\n    scanf(\"%s\",s+1);\n    for(int i=1; i<=n; i++) sum[i]=sum[i-1]+s[i]-'0';\n    int tot=0;\n    for(int i=1; i<=m; i++){\n        int ll=getint(),rr=getint();\n        if(ll==l[tot]){\n            r[tot]=max(r[tot],rr);\n        }else if(rr<=r[tot]){\n        }else{\n            tot++;\n            l[tot]=ll;\n            r[tot]=rr;\n        }\n    }\n    m=tot;\n    for(int i=0; i<=n; i++){\n        c[i][0]=1;\n        for(int j=1; j<=i; j++){\n            c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;\n        }\n    }\n    l[m+1]=n+1;\n    r[m+1]=n+1;\n}\n\nint main()\n{\n    init();\n    f[0][0]=1;\n    for(int i=1; i<=m; i++){\n        int nxt=r[i]>=l[i+1]?r[i]-l[i+1]+1:0;\n        int pre=r[i-1]>=l[i]?r[i-1]-l[i]+1:0;\n        for(int j=0; j<=nxt; j++){\n            for(int k=0; k<=pre; k++){\n                if(sum[min(r[i],l[i+1])]-sum[l[i]-1]+k-j<0) continue;\n                f[i][j]=(f[i][j]+f[i-1][k]*c[r[i]-l[i]+1-nxt][sum[r[i]]-sum[l[i]-1]-(sum[l[i]+pre-1]-sum[l[i]-1])+k-j])%MOD;\n            }\n        }\n    }\n    printf(\"%lld\\n\",f[m][0]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\null c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\null ncr[3005][3005];\null dp[3005][3005];\nbool isok[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tncr[0][0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j <= i; j++) {\n\t\t\tif (j) ncr[i][j] += ncr[i - 1][j - 1];\n\t\t\tif (j < i) ncr[i][j] += ncr[i - 1][j];\n\t\t\tncr[i][j] %= MOD;\n\t\t}\n\t}\n\n\ta[m] = n;\n\tsll r = -1;\n\tfor (i = 0; i < m; i++) {\n\t\tif (b[i] <= r) continue;\n\n\t\tisok[i] = true;\n\t\tr = b[i];\n\t}\n\tull l = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tif (isok[i]) {\n\t\t\ta[l] = a[i];\n\t\t\tb[l] = b[i];\n\t\t\tl++;\n\t\t}\n\t}\n\tm = l;\n\n\n\ta[m] = n;\n\tr = -1;\n\tfor (i = 0; i < m; i++) {\n\t\tif (b[i] <= r) continue;\n\n\t\tj = smax(r, a[i] - 1);\n\t\twhile (++j <= b[i]) {\n\t\t\tif (s[j] == '1') d[i]++;\n\t\t}\n\t\t\n\t\t// printf(\"min(%lld,%lld)-%lld: \", a[i + 1], b[i] + 1, a[i]);\n\t\tc[i] = smin(a[i + 1], b[i] + 1) - a[i];\n\t\tr = b[i];\n\n\t\t// printf(\"%lld-%lld\\n\", c[i], d[i]);\n\t}\n\n\tdp[0][0] = 1;\n\tfor (i = 0; i < m; i++) {\n\t\t// if (r < a[i]) {\n\t\t// \tfor (j = 0; j <= n; j++) {\n\t\t// \t\tdp[i][j] = 0;\n\t\t// \t}\n\t\t// }\n\n\t\tif (c[i] == 0 && d[i] == 0) {\n\t\t\tfor (j = 0; j <= n; j++) {\n\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j <= (b[i] - a[i] + 1) - c[i]; j++) {\n\t\t\tfor (ki = smax(j - d[i], 0); ki <= c[i] + j; ki++) {\n\t\t\t\tif (ki > n) break;\n\n\t\t\t\tsll r = ki + d[i] - j;\n\t\t\t\tdp[i + 1][j] += dp[i][ki] * ncr[c[i]][ki + d[i] - j] % MOD;\n\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t}\n\t\t\t// printf(\"%3lld \", dp[i + 1][j]);\n\t\t}\n\t\t// puts(\"\");\n\t}\n\n\tresult = dp[m][0];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\tscanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < m; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &c[i]);\n\t// \t// c[i]--;\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long factorial[262144];\n\nvoid cfact(){\n    long long i;\n    factorial[0]=1;\n    factorial[1]=1;\n    for(i=2;i<262144;i++){\n        factorial[i]=factorial[i-1]*i;\n        factorial[i]%=mod;\n    }\n}\n\nlong long power(long long a, long long b){\n\tlong long x = 1, y = a;\n\twhile (b > 0){\n\t\tif(b%2){\n\t\t\tx = (x*y)%mod;\n\t\t}\n\t\ty = (y*y)%mod;\n\t\tb /= 2;\n\t}\n\treturn x%mod;\n}\n \nlong long modular_inverse(long long n){\n\treturn power(n, mod-2);\n}\n\nlong long calcnCr(long long n,long long k){\n\treturn (factorial[n]*(modular_inverse(factorial[k])*modular_inverse(factorial[n-k])%mod))%mod;\n}\n\nint main(void){\n    cfact();\n    long long i,j,n,m,k,a,b,c,h,w,l,r,t;\n    long long al=0,ar=0,ac=0;\n    long long dp[4096]={0};\n    char s[524288];\n    scanf(\"%lld%lld%s\",&n,&m,&s[1]);\n    dp[0]=1;\n    for(i=0;i<m;i++){\n      scanf(\"%lld%lld\",&l,&r);\n      if(al<l){\n        //if(al!=0){\n        t=llmin(ar,l-1);\n        w=t-al+1;\n        for(j=ac;j>=0;j--){\n          for(k=w;k>0;k--){\n            if(j+k>ac){continue;}\n            dp[j+k]+=(dp[j]*calcnCr(w,k));\n            dp[j+k]%=mod;\n          }\n        }\n        w=llmax(ar-l+1,0);\n        for(j=0;j<ac-w;j++){\n          dp[j]=0;\n        }\n        ar=llmax(ar,l-1);\n        //}\n        al=l;\n      }\n      for(j=ar+1;j<=r;j++){\n        if(s[j]=='1'){ac++;}\n      }\n      ar=llmax(ar,r);\n      //for(j=0;j<5;j++){printf(\"%lld \",dp[j]);}\n      //printf(\"\\n\");\n    }\n    r=0;\n    for(i=0;i<=ac;i++){\n      if(ar-al+1 < ac-i){continue;}\n      r+=dp[i]*calcnCr(ar-al+1,ac-i);\n      r%=mod;\n    }\n    printf(\"%lld\\n\",r);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N\t3000\n#define MD\t1000000007\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint main() {\n\tstatic char cc[N + 1];\n\tstatic int dp[N + 1];\n\tint n, m, k, k0, l_, r_;\n\n\tscanf(\"%d%d%s\", &n, &m, cc);\n\tl_ = 0, r_ = -1, k0 = 0;\n\tdp[0] = 1;\n\twhile (m--) {\n\t\tint l, r;\n\n\t\tscanf(\"%d%d\", &l, &r), l--, r--;\n\t\tif (r_ < r) {\n\t\t\tif (r_ < l)\n\t\t\t\tl_ = l, r_ = l - 1;\n\t\t\telse\n\t\t\t\twhile (l_ < l) {\n\t\t\t\t\tfor (k = k0; k > 0; k--)\n\t\t\t\t\t\tdp[k] = (dp[k] + dp[k - 1]) % MD;\n\t\t\t\t\tif (k0 >= r_ - l_ + 1)\n\t\t\t\t\t\tdp[k0 - (r_ - l_ + 1)] = 0;\n\t\t\t\t\tl_++;\n\t\t\t\t}\n\t\t\twhile (r_ < r)\n\t\t\t\tif (cc[++r_] == '0')\n\t\t\t\t\tk0++;\n\t\t}\n\t}\n\twhile (l_ <= r_) {\n\t\tfor (k = k0; k > 0; k--)\n\t\t\tdp[k] = (dp[k] + dp[k - 1]) % MD;\n\t\tif (k0 >= r_ - l_ + 1)\n\t\t\tdp[k0 - (r_ - l_ + 1)] = 0;\n\t\tl_++;\n\t}\n\tprintf(\"%d\\n\", dp[k0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nconst int mod=1e9+7;\nint n,m;\nint s[N],val[N],dp[2][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tchar t[2];gets(t);\n\tfor(int i=1;i<=n;i++) s[i]=getchar()-'0'+s[i-1];\n\tint cnt=0;\n\tfor(int i=1,ml,mr;i<=m;i++)\n\t\tscanf(\"%d%d\",&ml,&mr),val[ml]=max(val[ml],mr);\n\tfor(int i=1;i<=n;i++) val[i]=max(max(i,val[i]),val[i-1]); \n\tint now=0;\n\tdp[now][0]=1;\n\tfor(int i=1;i<=n;i++,now^=1){\n\t\tmemset(dp[now^1],0,sizeof(dp[0]));\n\t\tfor(int j=s[val[i]]-(val[i]-i);j<=s[val[i]];j++)\n\t\t\tdp[now^1][j]=(dp[now][j]+ (j==0?0:dp[now][j-1]) )%mod;\n\t}\n\tcout<<dp[now][s[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N\t3000\n#define MD\t1000000007\n\nint max(int a, int b) { return a > b ? a : b; }\n\nint main() {\n\tstatic char cc[N + 1];\n\tstatic int dp[N + 1];\n\tint n, m, k, k0, l_, r_;\n\n\tscanf(\"%d%d%s\", &n, &m, cc);\n\tl_ = 0, r_ = -1, k0 = 0;\n\tdp[0] = 1;\n\twhile (m--) {\n\t\tint l, r;\n\n\t\tscanf(\"%d%d\", &l, &r), l--, r--;\n\t\tif (r_ < r) {\n\t\t\twhile (l_ <= r_ && l_ < l) {\n\t\t\t\tfor (k = k0; k > 0; k--)\n\t\t\t\t\tdp[k] = (dp[k] + dp[k - 1]) % MD;\n\t\t\t\tif (k0 >= r_ - l_ + 1)\n\t\t\t\t\tdp[k0 - (r_ - l_ + 1)] = 0;\n\t\t\t\tl_++;\n\t\t\t}\n\t\t\tif (r_ < l)\n\t\t\t\tl_ = l, r_ = l - 1;\n\t\t\twhile (r_ < r)\n\t\t\t\tif (cc[++r_] == '0')\n\t\t\t\t\tk0++;\n\t\t}\n\t}\n\twhile (l_ <= r_) {\n\t\tfor (k = k0; k > 0; k--)\n\t\t\tdp[k] = (dp[k] + dp[k - 1]) % MD;\n\t\tif (k0 >= r_ - l_ + 1)\n\t\t\tdp[k0 - (r_ - l_ + 1)] = 0;\n\t\tl_++;\n\t}\n\tprintf(\"%d\\n\", dp[k0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = (long) (1e9 + 7);\n\tint n;\n\tint m;\n\tint[] c;\n\tint[] l;\n\tint[] r;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tint[] s = new int[n];\n\t\tchar[] S = sc.next().toCharArray();\n\t\tl = new int[m];\n\t\tr = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tr[i] = i;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\ts[i] = (S[i] == '0' ? 0 : 1);\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tl[i] = sc.nextInt();\n\t\t\t--l[i];\n\t\t\tr[l[i]] = Math.max(r[l[i]], sc.nextInt() - 1);\n\t\t}\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tr[i] = Math.max(r[i - 1], r[i]);\n\t\t}\n\t\tc = new int[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tc[i] = (i > 0 ? c[i - 1] : 0) + s[i];\n\t\t}\n\t\tmemo = new long[n][n];\n\t\tfor (int i = 0; i < memo.length; ++i) {\n\t\t\tfor (int j = 0; j < memo[i].length; ++j) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(f(0, c[r[0]]));\n\t}\n\n\tlong[][] memo;\n\n\tlong f(int l, int curC) {\n\t\tif (r[l] - (l - 1) < curC)\n\t\t\treturn memo[l][curC] = 0;\n\t\tif (l == n - 1) {\n\t\t\tif (curC > 1)\n\t\t\t\tthrow new AssertionError();\n\t\t\treturn memo[l][curC] = 1;\n\t\t}\n\t\tif (memo[l][curC] != -1)\n\t\t\treturn memo[l][curC];\n\t\tlong ret = 0;\n\t\tif (!(r[l] - (l - 1 + 1) < curC)) {\n\t\t\tret += f(l + 1, curC + c[r[l + 1]] - c[r[l]]);\n\t\t}\n\t\tif (!(curC == 0)) {\n\t\t\tret += f(l + 1, curC - 1 + c[r[l + 1]] - c[r[l]]);\n\t\t}\n\t\tret %= MODULO;\n\t\treturn memo[l][curC] = ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int mod = 1000000007;\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        var s = sc.nextChars();\n        var cum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            cum[i + 1] = cum[i] + s[i] - '0';\n        }\n        var comb = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            comb[i] = new long[i + 1];\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n                if (comb[i][j] >= mod) {\n                    comb[i][j] -= mod;\n                }\n            }\n        }\n        var segs = new ArrayList<IntPair>();\n        for (int i = 0; i < m; i++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt();\n            if (i == 0) {\n                segs.add(new IntPair(l, r));\n            } else {\n                var last = segs.get(segs.size() - 1);\n                if (last.fst == l && last.snd < r) {\n                    last.snd = r;\n                } else if (last.fst < l && last.snd < r) {\n                    segs.add(new IntPair(l, r));\n                }\n            }\n        }\n        m = segs.size();\n        var l = new int[m];\n        var r = new int[m];\n        for (int i = 0; i < m; i++) {\n            var seg = segs.get(i);\n            l[i] = seg.fst;\n            r[i] = seg.snd;\n        }\n        var dp = new long[m + 1][n + 1];\n        dp[0][cum[r[0]] - cum[l[0]]] = 1;\n        for (int i = 0; i < m - 1; i++) {\n            int w = r[i] - l[i];\n            int x = r[i] - l[i + 1];\n            if (x <= 0) {\n                long sum = 0;\n                for (int j = 0; j <= w; j++) {\n                    sum += dp[i][j] * comb[w][j];\n                }\n                sum %= mod;\n                dp[i + 1][cum[r[i + 1]] - cum[l[i + 1]]] = sum;\n                continue;\n            }\n            int p = cum[r[i + 1]] - cum[r[i]];\n            for (int j = 0; j <= n; j++) {\n                if (dp[i][j] == 0) continue;\n                int l1 = Math.max(0, x - (w - j));\n                int r1 = Math.min(j, x);\n                for (int k = l1; k <= r1; k++) {\n                    dp[i + 1][p + k] += comb[w - x][j - k] * dp[i][j];\n                    dp[i + 1][p + k] %= mod;\n                }\n            }\n        }\n        for (int j = 0, w = r[m - 1] - l[m - 1]; j <= w; j++) {\n            dp[m][j] = (dp[m - 1][j] * comb[w][j]) % mod;\n        }\n        long ans = 0;\n        for (int j = 0; j <= n; j++) {\n            ans += dp[m][j];\n        }\n        ans %= mod;\n        out.writeln(ans < 0 ? ans + mod : ans);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair {\n    public int fst, snd;\n    public IntPair(final int fst, final int snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair)) return false;\n        final IntPair p = (IntPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 1;\n        hash = hash * 31 + fst;\n        hash = hash * 31 + snd;\n        return hash;\n    }\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  private final int MOD = (int) (1e9 + 7);\n\n  private void solve(Scanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    char[] S = in.next().toCharArray();\n    int[] right = new int[N];\n    Arrays.fill(right, -1);\n    for (int i = 0; i < M; i++) {\n      int l = in.nextInt() - 1;\n      int r = in.nextInt() - 1;\n      if (right[l] < r) right[l] = r;\n    }\n\n    int max = 0;\n    for (int i = 0; i < N; i++) {\n      max = Math.max(max, i);\n      max = Math.max(max, right[i]);\n      right[i] = max;\n    }\n\n    int[] sum = new int[N];\n    for (int i = 0; i < N; i++) sum[i] = S[i] - '0';\n    for (int i = 0; i < N - 1; i++) sum[i + 1] += sum[i];\n\n    long[][] dp = new long[N + 1][N + 1];\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n      for (int usedOne = 0; usedOne < N; usedOne++) {\n        int r = right[i];\n        int restOne = sum[r] - usedOne;\n        if (restOne < 0) continue;\n        if (restOne > 0) {\n          dp[i + 1][usedOne + 1] += dp[i][usedOne];\n          if (dp[i + 1][usedOne + 1] >= MOD) dp[i + 1][usedOne + 1] -= MOD;\n        }\n        if (r - i + 1 != restOne) {\n          dp[i + 1][usedOne] += dp[i][usedOne];\n          if (dp[i + 1][usedOne] >= MOD) dp[i + 1][usedOne] -= MOD;\n        }\n      }\n    }\n    out.println(dp[N][sum[N - 1]]);\n  }\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(in, out);\n    in.close();\n    out.close();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\t/*\n\t * L 文字列Sの位置L-1まで既に決まっている\n\t * C S[L:newR[L]]の部分文字列に含まれる1の数\n\t */\n\tpublic long dfs(int L,int C){\n\t\tSystem.err.println(\"L=\"+L+\" C=\"+C);\n\n\t\tif(L == N){\n\t\t\tif(C == 0){\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*if(dp[L][C] != -1){\n\t\t\treturn dp[L][C];\n\t\t}*/\n\n\t\tlong ret = 0;\n\n\t\tif(L > 0 && newR[L-1] < newR[L]){\n\t\t\tC += sum[newR[L]] - sum[newR[L-1]];\n\t\t}\n\n\t\tSystem.err.println(\"after: L=\"+L+\" C=\"+C);\n\n\t\t//L番目に1を使った場合\n\t\tif(C > 0){\n\t\t\tret += dfs(L + 1,C - 1)%MOD;\n\t\t}\n\t\tret %= MOD;\n\n\t\t//L番目に0を使った場合\n\t\tif(C < newR[L] - L + 1){\n\t\t\tret += dfs(L + 1,C) %MOD;\n\t\t}\n\t\tret %= MOD;\n\t\treturn dp[L][C]=ret%MOD;\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,sum[newR[0]]));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1L;\n\n\t\t//i = 今見ているSの位置\n\t\tfor(int i = 0;i < N;i++){\n\n\t\t\t//j = これまで配置した1の数\n\t\t\tfor(int j = 0;j <= i;j++){\n\n\t\t\t\tif(dp[i][j] == 0)continue;\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] jがnewR[i]]の位置までに存在する1の数以下(これを超えていたら存在する1の数より多いのでありえない)\n\t\t\t\t * sum[newR[i]] - j <= newR[i] - i 残りの配置しなければならない1の数 <= newR[i]の位置まで配置できる0or1の数(これも超えていたら1が余分に存在している)\n\t\t\t\t *\n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j]に遷移する(iの位置に0を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] && sum[newR[i]] - j <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] - 1 iの位置に1を配置する分をsum[newR[i]]から引いてもちゃんとj以上になる(これがj未満になると矛盾していることになる)\n\t\t\t\t * sum[newR[i]] - j - 1 <= newR[i] - i 今iの位置に配置する分(-1)とこれまで配置した分(j)をsum[newR[i]]から引いた残りの数(これはnewR[i]の位置までに配置しなければならない1の数)が\n\t\t\t\t * 残りの配置できる位置の数以下(これが上回っていると配置することが出来ない1が出てきてしまう)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] - 1 && sum[newR[i]] - j - 1 <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(dp[N][sum[N-1]]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  private final int MOD = (int) (1e9 + 7);\n\n  private void solve(Scanner in, PrintWriter out) {\n    int N = in.nextInt();\n    int M = in.nextInt();\n    char[] S = in.next().toCharArray();\n    int[] right = new int[N];\n    Arrays.fill(right, -1);\n    for (int i = 0; i < M; i++) {\n      int l = in.nextInt() - 1;\n      int r = in.nextInt() - 1;\n      if (right[l] < r) right[l] = r;\n    }\n\n    int max = 0;\n    for (int i = 0; i < N; i++) {\n      max = Math.max(max, i);\n      max = Math.max(max, right[i]);\n      right[i] = max;\n    }\n\n    int[] sum = new int[N];\n    for (int i = 0; i < N; i++) sum[i] = S[i] - '0';\n    for (int i = 0; i < N - 1; i++) sum[i + 1] += sum[i];\n\n    long[][] dp = new long[N + 1][N + 1];\n    dp[0][0] = 1;\n    for (int i = 0; i < N; i++) {\n      for (int usedOne = 0; usedOne < N; usedOne++) {\n        int r = right[i];\n        int restOne = sum[r] - usedOne;\n        if (restOne < 0) continue;\n\n        if (restOne > 0)\n          dp[i + 1][usedOne + 1] = (dp[i + 1][usedOne + 1] + dp[i][usedOne]) % MOD;\n\n        if (r - i + 1 != restOne)\n          dp[i + 1][usedOne] = (dp[i + 1][usedOne] + dp[i][usedOne]) % MOD;\n      }\n    }\n    out.println(dp[N][sum[N - 1]]);\n  }\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(in, out);\n    in.close();\n    out.close();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long mod = 1_000_000_007;\n    long inf = Long.MAX_VALUE;\n\n    void solve(){\n        int n = ni();\n        int m = ni();\n        char[] c = ns().toCharArray();\n        int[][] res = new int[m][2];\n        for(int i = 0; i < m; i++){\n            res[i][0] = ni()-1;\n            res[i][1] = ni()-1;\n        }\n        char[] cmin = new char[n];\n        char[] cmax = new char[n];\n        for(int i = 0; i < n; i++){\n            cmin[i] = c[i];\n            cmax[i] = c[i];\n        }\n        for(int i = 0; i < m; i++){\n            int left = res[i][0];\n            int right = res[i][1];\n            int zero = 0;\n            int one = 0;\n            for(int j = left; j <= right; j++){\n                if(cmin[j]=='0') zero++;\n                else one++;\n            }\n            for(int j = left; j <= right; j++){\n                if(j<left+one) cmin[j] = '1';\n                else cmin[j] = '0';\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int left = res[i][0];\n            int right = res[i][1];\n            int zero = 0;\n            int one = 0;\n            for(int j = left; j <= right; j++){\n                if(cmax[j]=='0') zero++;\n                else one++;\n            }\n            for(int j = left; j <= right; j++){\n                if(j<left+zero) cmax[j] = '0';\n                else cmax[j] = '1';\n            }\n        }\n        int[] zeromin = new int[n];\n        int[] zeromax = new int[n];\n        for(int i = 0; i < n; i++){\n            if(cmin[i]=='0') zeromin[i]++;\n            if(cmax[i]=='0') zeromax[i]++;\n        }\n        for(int i = 1; i < n; i++){\n            zeromin[i] += zeromin[i-1];\n            zeromax[i] += zeromax[i-1];\n        }\n        Arrays.sort(res, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if(a[0] != b[0]) return a[0] - b[0];\n                return a[1] - b[1];\n            }\n        });\n        boolean[] l = new boolean[n];\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int min = 0;\n        for(int i = 0; i < m; i++){\n            if(res[i][1]>min){\n                map.put(res[i][0], res[i][1]);\n                min = res[i][1];\n                l[res[i][0]] = true;\n            }\n        }\n        long[] dp = new long[n+1];\n        dp[0] = 1;\n        boolean flag = false;\n        int target = n;\n        for(int i = 0; i < n; i++){\n            long[] ndp = new long[n+2];\n            if(l[i]){\n                flag = true;\n                target = map.get(i);\n                // データ消去の処理\n                for(int k = 0; k <= n; k++){\n                    if(i>0){\n                        if(k<zeromin[i-1]||k>zeromax[i-1]) dp[k] = 0;\n                    }\n                }\n            }\n            for(int j = 0; j <= n; j++){\n                if(!flag){\n                    if(c[i]=='0' && dp[j]>0) ndp[j+1] = dp[j];\n                    if(c[i]=='1' && dp[j]>0) ndp[j] = dp[j];\n                    ndp[j+1]%=mod;\n                    ndp[j]%=mod;\n                }else{\n                    if(dp[j]>0){\n                        ndp[j] += dp[j];\n                        ndp[j+1] += dp[j];\n                        ndp[j]%=mod;\n                        ndp[j+1]%=mod;\n                    }\n                }\n            }\n            if(i==target){\n                flag = false;\n                // データ消去の処理\n                for(int k = 0; k <= n; k++){\n                    if(k<zeromin[i]||k>zeromax[i]) ndp[k] = 0;\n                }\n            }\n            for(int j = 0; j <= n; j++) dp[j] = ndp[j];\n            // for(int j = 0; j < n; j++){\n            //     out.print(dp[j]+\" \");\n            // }\n            // out.println();\n        }\n        // for(int i = 0; i < n; i++){\n        //     out.println(dp[i]);\n        // }\n        out.println(dp[zeromin[n-1]]);\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[] s =ns(n);\n\t\tint[] cum = new int[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcum[i+1] = cum[i] + (s[i] == '1' ? 1 : 0);\n\t\t}\n\t\tint[][] lr = new int[m][];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tlr[i] = new int[]{ni()-1, ni()-1};\n\t\t}\n\t\tint mod = 1000000007;\n\t\t\n\t\tlong[][] C = new long[3500 + 1][3500 + 1];\n\t\tfor (int i = 0; i <= 3500; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\t\tif (C[i][j] >= mod)\n\t\t\t\t\tC[i][j] -= mod;\n\t\t\t}\n\t\t}\n\n\t\tlong[] dp = new long[n+1];\n\t\tdp[0] = 1;\n\t\tint reach = 0;\n\t\tint rp = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\treach = Math.max(reach, i);\n\t\t\twhile(rp < m && lr[rp][0] <= i){\n\t\t\t\treach = Math.max(reach, lr[rp][1]);\n\t\t\t\trp++;\n\t\t\t}\n\t\t\tfor(int j = n;j >= 0;j--){\n\t\t\t\tlong v = dp[j];\n\t\t\t\tdp[j] = 0;\n\t\t\t\tif(cum[reach+1]-j > 0){\n\t\t\t\t\tdp[j+1] += v;\n\t\t\t\t\tif(dp[j+1] >= mod)dp[j+1] -= mod;\n\t\t\t\t}\n\t\t\t\tif(reach+1-cum[reach+1]-(i-j) > 0){\n\t\t\t\t\tdp[j] += v;\n\t\t\t\t\tif(dp[j] >= mod)dp[j] -= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(Arrays.stream(dp).sum()%mod);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int mod = 1000000007;\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        var s = sc.nextChars();\n        var cum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            cum[i + 1] = cum[i] + s[i] - '0';\n        }\n        var comb = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            comb[i] = new long[i + 1];\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n                if (comb[i][j] >= mod) {\n                    comb[i][j] -= mod;\n                }\n            }\n        }\n        var segs = new ArrayList<IntPair>();\n        for (int i = 0; i < m; i++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt();\n            if (i == 0) {\n                segs.add(new IntPair(l, r));\n            } else {\n                var last = segs.get(segs.size() - 1);\n                if (last.fst == l && last.snd < r) {\n                    last.snd = r;\n                } else if (last.fst < l && last.snd < r) {\n                    segs.add(new IntPair(l, r));\n                }\n            }\n        }\n        m = segs.size();\n        var l = new int[m];\n        var r = new int[m];\n        for (int i = 0; i < m; i++) {\n            var seg = segs.get(i);\n            l[i] = seg.fst;\n            r[i] = seg.snd;\n            out.write(l[i]).write(' ').writeln(r[i]);\n        }\n        var dp = new long[m + 1][n + 1];\n        dp[0][cum[r[0]] - cum[l[0]]] = 1;\n        for (int i = 0; i < m - 1; i++) {\n            int w = r[i] - l[i];\n            int x = r[i] - l[i + 1];\n            if (x <= 0) {\n                long sum = 0;\n                for (int j = 0; j <= w; j++) {\n                    sum += dp[i][j] * comb[w][j];\n                }\n                sum %= mod;\n                dp[i + 1][cum[r[i + 1]] - cum[l[i + 1]]] = sum;\n                continue;\n            }\n            int p = cum[r[i + 1]] - cum[r[i]];\n            for (int j = 0; j <= n; j++) {\n                if (dp[i][j] == 0) continue;\n                int l1 = Math.max(0, x - (w - j));\n                int r1 = Math.min(j, x);\n                for (int k = l1; k <= r1; k++) {\n                    dp[i + 1][p + k] += comb[w - x][j - k] * dp[i][j];\n                    dp[i + 1][p + k] %= mod;\n                }\n            }\n        }\n        for (int j = 0, w = r[m - 1] - l[m - 1]; j <= w; j++) {\n            dp[m][j] = (dp[m - 1][j] * comb[w][j]) % mod;\n        }\n        long ans = 0;\n        for (int j = 0; j <= n; j++) {\n            ans += dp[m][j];\n        }\n        ans %= mod;\n        out.writeln(ans < 0 ? ans + mod : ans);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair {\n    public int fst, snd;\n    public IntPair(final int fst, final int snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair)) return false;\n        final IntPair p = (IntPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 1;\n        hash = hash * 31 + fst;\n        hash = hash * 31 + snd;\n        return hash;\n    }\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package atcoder.arc.arc065;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    private static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        char[] s = in.nextToken().toCharArray();\n\n        int[][] op = new int[m][2];\n        for (int i = 0; i < m ; i++) {\n            op[i][0] = in.nextInt()-1;\n            op[i][1] = in.nextInt()-1;\n        }\n\n        int[] lmax = new int[n];\n        Arrays.fill(lmax, -1);\n        for (int i = 0; i < m ; i++) {\n            lmax[op[i][0]] = Math.max(lmax[op[i][0]], op[i][1]);\n        }\n\n        List<int[]> q = new ArrayList<>();\n        int maxR = -1;\n        for (int i = 0; i < n ; i++) {\n            if (lmax[i] <= maxR) {\n                continue;\n            }\n            q.add(new int[]{i, lmax[i]});\n            maxR = lmax[i];\n        }\n\n        int[] imos = new int[n+1];\n        for (int i = 0; i < n ; i++) {\n            imos[i+1] = imos[i] + (s[i] == '0' ? 1 : 0);\n        }\n\n\n        for (int[] qqq : q) {\n            //debug(qqq);\n        }\n\n        int tail = -1;\n        int qi = 0;\n        int qn = q.size();\n        long[][] dp = new long[2][n+1];\n        dp[0][0] = 1;\n\n        int dec = 0;\n        int freeOne = 0;\n        int filledZero = 0;\n        for (int i = 0; i < n ; i++) {\n            int fr = i % 2;\n            int to = 1 - fr;\n\n            if (qi < qn) {\n                int[] pa = q.get(qi);\n                if (pa[0] == i) {\n                    int from = Math.max(tail+1, pa[0]);\n                    int ttail = pa[1];\n                    // debug(i, \"add\",from,ttail,imos[ttail+1] - imos[from]);\n                    int zcnt = imos[ttail+1] - imos[from];\n\n                    freeOne += ttail+1-from-zcnt;\n                    filledZero += zcnt;\n\n                    //debug(freeOne);\n\n\n                    tail = ttail;\n\n                    // copy\n                    Arrays.fill(dp[to], 0);\n                    for (int f = 0 ; f+zcnt <= n ; f++) {\n                        dp[to][f+zcnt] = dp[fr][f];\n                    }\n                    for (int j = 0; j < n ; j++) {\n                        dp[fr][j] = dp[to][j];\n                    }\n                    qi++;\n                }\n            }\n\n//            debug(i, tail);\n//            debug(dp[fr]);\n\n            Arrays.fill(dp[to], 0);\n            for (int f = 0 ; f <= n ; f++) {\n                if (dp[fr][f] == 0) {\n                    continue;\n                }\n                long base = dp[fr][f];\n                int usedZero = filledZero - f;\n                int usedOne = dec - usedZero;\n                int leftOne = freeOne - usedOne;\n\n\n                if (i <= tail) {\n                    if (f >= 1) {\n                        dp[to][f-1] += base;\n                        dp[to][f-1] %= MOD;\n                    }\n                    if (leftOne >= 1) {\n                        dp[to][f] += base;\n                        dp[to][f] %= MOD;\n                    }\n                } else {\n                    dp[to][f] += base;\n                    dp[to][f] %= MOD;\n                }\n            }\n\n            if (i <= tail) {\n                dec++;\n            }\n            if (i == tail) {\n                boolean wash = false;\n                if (qi+1 < qn) {\n                    int[] pa = q.get(qi+1);\n                    if (tail < pa[0]) {\n                        wash = true;\n                    }\n                } else {\n                    wash = true;\n                }\n                if (wash) {\n                    for (int j = 1; j <= n; j++) {\n                        dp[to][j] = 0;\n                    }\n                }\n            }\n            //debug(i, dp[to]);\n        }\n\n\n        // debug(dp[n%2]);\n\n        out.println(dp[n%2][0] % MOD);\n        out.flush();\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    private static final int MOD = 1000000007;\n\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        char[] s = in.nextToken().toCharArray();\n\n        int[] one = new int[n+1];\n        for (int i = 0; i < n ; i++) {\n            one[i+1] = one[i] + (s[i] == '1' ? 1 : 0);\n        }\n\n        int[] maxTo = new int[n];\n        Arrays.fill(maxTo, -1);\n        for (int i = 0; i < m ; i++) {\n            int l = in.nextInt()-1;\n            int r = in.nextInt();\n            maxTo[l] = Math.max(maxTo[l], r);\n        }\n\n        List<int[]> operations = new ArrayList<>();\n        int max = 0;\n        int[][] events = new int[n][4];\n        for (int i = 0; i < n ; i++) {\n            Arrays.fill(events[i], -1);\n        }\n        for (int i = 0; i < n ; i++) {\n            if (max < maxTo[i]) {\n                events[i] = new int[]{i, maxTo[i], maxTo[i]-max, one[maxTo[i]]-one[max]};\n                max = maxTo[i];\n            }\n        }\n\n        int[][] dp = new int[2][n+10];\n        dp[0][0] = 1;\n\n        int poolSum = 0;\n        for (int i = 0; i < n ; i++) {\n            int fr = i % 2;\n            int to = 1 - fr;\n            Arrays.fill(dp[to], 0);\n\n            if (events[i][0] != -1) {\n                poolSum += events[i][2];\n            }\n            for (int j = 0; j < dp[0].length ; j++) {\n                int base = dp[fr][j];\n                if (base == 0) {\n                    continue;\n                }\n                if (j == 0 && events[i][0] == -1) {\n                    add(dp, to, j, base);\n                    continue;\n                }\n                int cj = j;\n                if (events[i][0] != -1) {\n                    cj += events[i][3];\n                }\n                if (cj >= 1) {\n                    add(dp, to, cj-1, base);\n                }\n\n                int left = poolSum - i;\n                if (cj < left) {\n                    add(dp, to, cj, base);\n                }\n            }\n\n        }\n\n        out.println(dp[n%2][0]);\n        out.flush();\n    }\n\n    static void add(int[][] dp, int i, int j, int a) {\n        dp[i][j] += a;\n        dp[i][j] -= dp[i][j] >= MOD ? MOD : 0;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1L;\n\n\t\t//i = 今見ているSの位置\n\t\tfor(int i = 0;i < N;i++){\n\n\t\t\t//j = これまで配置した1の数\n\t\t\tfor(int j = 0;j <= i;j++){\n\n\t\t\t\tif(dp[i][j] == 0)continue;\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] jがnewR[i]]の位置までに存在する1の数以下(これを超えていたら存在する1の数より多いのでありえない)\n\t\t\t\t * sum[newR[i]] - j <= newR[i] - i 残りの配置しなければならない1の数 <= newR[i]の位置まで配置できる0or1の数(これも超えていたら1が余分に存在している)\n\t\t\t\t *\n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j]に遷移する(iの位置に0を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] && sum[newR[i]] - j <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] - 1 iの位置に1を配置する分をsum[newR[i]]から引いてもちゃんとj以上になる(これがj未満になると矛盾していることになる)\n\t\t\t\t * sum[newR[i]] - j - 1 <= newR[i] - i 今iの位置に配置する分(-1)とこれまで配置した分(j)をsum[newR[i]]から引いた残りの数(これはnewR[i]の位置までに配置しなければならない1の数)が\n\t\t\t\t * 残りの配置できる位置の数以下(これが上回っていると配置することが出来ない1が出てきてしまう)\n\t\t\t\t */\n\t\t\t\tif(j  + 1<= sum[newR[i]] && sum[newR[i]] - j - 1 <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(dp[N][sum[N-1]]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\n\tpublic long dfs(int L,int R,int C){\n\n\t\tif(L == N){\n\t\t\treturn 1;\n\t\t}\n\n\t\tif(dp[L][C] != -1)return dp[L][C];\n\n\t\tlong ret = 0;\n\t\tint add = 0;\n\n\t\tif(R < newR[L+1]){\n\t\t\tadd = sum[newR[L+1]] - sum[R];\n\t\t}\n\n\t\t//1を配置\n\t\tif(C > 0){\n\t\t\tret += dfs(L + 1,newR[L+1],C - 1 + add) % MOD;\n\t\t}\n\n\t\t//0を配置\n\t\tif(C < R - L  + 1){\n\t\t\tret += dfs(L + 1,newR[L+1],C + add) % MOD;\n\t\t}\n\n\t\treturn dp[L][C] = ret;\n\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,newR[0],sum[newR[0]]));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int mod = 1000000007;\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        var s = sc.nextChars();\n        var cum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            cum[i + 1] = cum[i] + s[i] - '0';\n        }\n        var comb = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            comb[i] = new long[i + 1];\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n                if (comb[i][j] >= mod) {\n                    comb[i][j] -= mod;\n                }\n            }\n        }\n        var segs = new ArrayList<IntPair>();\n        for (int i = 0; i < m; i++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt();\n            if (i == 0) {\n                segs.add(new IntPair(l, r));\n            } else {\n                var last = segs.get(segs.size() - 1);\n                if (last.fst == l && last.snd < r) {\n                    last.snd = r;\n                } else if (last.fst < l && last.snd < r) {\n                    segs.add(new IntPair(l, r));\n                }\n            }\n        }\n        m = segs.size();\n        var l = new int[m];\n        var r = new int[m];\n        for (int i = 0; i < m; i++) {\n            var seg = segs.get(i);\n            l[i] = seg.fst;\n            r[i] = seg.snd;\n        }\n        var dp = new long[m + 1][n + 1];\n        dp[0][cum[r[0]] - cum[l[0]]] = 1;\n        for (int i = 0; i < m - 1; i++) {\n            int w = r[i] - l[i];\n            int x = r[i] - l[i + 1];\n            int p = cum[r[i + 1]] - cum[r[i]];\n            for (int j = 0; j <= n; j++) {\n                if (dp[i][j] == 0) continue;\n                int l1 = Math.max(0, x - (w - j));\n                int r1 = Math.min(j, x);\n                for (int k = l1; k <= r1; k++) {\n                    dp[i + 1][p + k] += comb[w - x][j - k] * dp[i][j];\n                    dp[i + 1][p + k] %= mod;\n                }\n            }\n        }\n        for (int j = 0, w = r[m - 1] - l[m - 1]; j <= w; j++) {\n            dp[m][j] = (dp[m - 1][j] * comb[w][j]) % mod;\n        }\n        long ans = 0;\n        for (int j = 0; j <= n; j++) {\n            ans += dp[m][j];\n        }\n        ans %= mod;\n        out.writeln(ans < 0 ? ans + mod : ans);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntPair {\n    public int fst, snd;\n    public IntPair(final int fst, final int snd) {this.fst = fst; this.snd = snd;}\n    @Override @SuppressWarnings(\"all\")\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (!(o instanceof IntPair)) return false;\n        final IntPair p = (IntPair) o;\n        return this.fst == p.fst && this.snd == p.snd;\n    }\n    @Override\n    public int hashCode() {\n        int hash = 1;\n        hash = hash * 31 + fst;\n        hash = hash * 31 + snd;\n        return hash;\n    }\n    @Override\n    public String toString() {return \"(\" + this.fst + \", \" + this.snd + \")\";}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1L;\n\n\t\t//i = 今見ているSの位置\n\t\tfor(int i = 0;i < N;i++){\n\n\t\t\t//j = これまで配置した1の数\n\t\t\tfor(int j = 0;j <= i;j++){\n\n\t\t\t\tif(dp[i][j] == 0)continue;\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] jがnewR[i]]の位置までに存在する1の数以下(これを超えていたら存在する1の数より多いのでありえない)\n\t\t\t\t * sum[newR[i]] - j <= newR[i] - i 残りの配置しなければならない1の数 <= newR[i]の位置まで配置できる0or1の数(これも超えていたら1が余分に存在している)\n\t\t\t\t *\n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j]に遷移する(iの位置に0を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] && sum[newR[i]] - j <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] - 1 iの位置に1を配置する分をsum[newR[i]]から引いてもちゃんとj以上になる(これがj未満になると矛盾していることになる)\n\t\t\t\t * sum[newR[i]] - j - 1 <= newR[i] - i 今iの位置に配置する分(-1)とこれまで配置した分(j)をsum[newR[i]]から引いた残りの数(これはnewR[i]の位置までに配置しなければならない1の数)が\n\t\t\t\t * 残りの配置できる位置の数以下(これが上回っていると配置することが出来ない1が出てきてしまう)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] - 1 && sum[newR[i]] - j - 1 <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(dp[N][sum[N-1]]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    private static final int MOD = 1000000007;\n\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        char[] s = in.nextToken().toCharArray();\n\n        int[] one = new int[n+1];\n        for (int i = 0; i < n ; i++) {\n            one[i+1] = one[i] + (s[i] == '1' ? 1 : 0);\n        }\n\n        int[] maxTo = new int[n];\n        Arrays.fill(maxTo, -1);\n        for (int i = 0; i < m ; i++) {\n            int l = in.nextInt()-1;\n            int r = in.nextInt();\n            maxTo[l] = Math.max(maxTo[l], r);\n        }\n\n        int max = 0;\n        int[][] events = new int[n][4];\n        for (int i = 0; i < n ; i++) {\n            Arrays.fill(events[i], -1);\n        }\n        for (int i = 0; i < n ; i++) {\n            max = Math.max(max, i);\n            if (max < maxTo[i]) {\n                events[i] = new int[]{i, maxTo[i], maxTo[i]-max, one[maxTo[i]]-one[max]};\n                max = maxTo[i];\n            }\n        }\n        \n        int[][] dp = new int[2][n+10];\n        dp[0][0] = 1;\n\n        int poolSum = 0;\n        for (int i = 0; i < n ; i++) {\n            int fr = i % 2;\n            int to = 1 - fr;\n            Arrays.fill(dp[to], 0);\n\n            if (events[i][0] != -1) {\n                poolSum = events[i][1];\n            }\n            for (int j = 0; j < dp[0].length ; j++) {\n                int base = dp[fr][j];\n                if (base == 0) {\n                    continue;\n                }\n                if (j == 0 && events[i][0] == -1) {\n                    add(dp, to, j, base);\n                    continue;\n                }\n                int cj = j;\n                if (events[i][0] != -1) {\n                    cj += events[i][3];\n                }\n\n                if (cj >= 1) {\n                    add(dp, to, cj-1, base);\n                }\n\n                int left = poolSum - i;\n                if (cj < left) {\n                    add(dp, to, cj, base);\n                }\n            }\n\n        }\n\n        out.println(dp[n%2][0]);\n        out.flush();\n    }\n\n    static void add(int[][] dp, int i, int j, int a) {\n        dp[i][j] += a;\n        dp[i][j] -= dp[i][j] >= MOD ? MOD : 0;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    final int MOD = (int) (1e9 + 7);\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n      char[] S = in.next().toCharArray();\n\n      int[] right = new int[N];\n      Arrays.fill(right, -1);\n      for (int i = 0; i < M; i++) {\n        int l = in.nextInt() - 1;\n        int r = in.nextInt() - 1;\n        if (right[l] < r) right[l] = r;\n      }\n      int max = 0;\n      for (int i = 0; i < N; i++) {\n        max = Math.max(max, i);\n        max = Math.max(max, right[i]);\n        right[i] = max;\n      }\n\n      int[] sum = new int[N];\n      for (int i = 0; i < N; i++) sum[i] = S[i] - '0';\n      for (int i = 0; i < N - 1; i++) sum[i + 1] += sum[i];\n\n      long[][] dp = new long[N + 1][N + 1];\n      dp[0][0] = 1;\n      for (int i = 0; i < N; i++) {\n        //i文字目を決めたいぞ！\n        for (int usedOne = 0; usedOne < N; usedOne++) {\n          int r = right[i];\n          int restOne = sum[r] - usedOne;\n          if (restOne < 0) continue;\n          if (restOne > 0) {\n            dp[i + 1][usedOne + 1] += dp[i][usedOne];\n            if (dp[i + 1][usedOne + 1] >= MOD) dp[i + 1][usedOne + 1] -= MOD;\n          }\n          if (r - i + 1 != restOne) {\n            dp[i + 1][usedOne] += dp[i][usedOne];\n            if (dp[i + 1][usedOne] >= MOD) dp[i + 1][usedOne] -= MOD;\n          }\n        }\n      }\n      out.println(dp[N][sum[N - 1]]);\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskC solver = new TaskC();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskC {\n        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n        NumberTheory.Composite comp = new NumberTheory.Composite(10000, mod);\n        int[] preSum;\n        int[][] dp;\n        int n;\n        int m;\n        Interval[] intervals;\n        int zero = 3000;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            n = in.readInt();\n            m = in.readInt();\n            char[] s = (\" \" + in.readString()).toCharArray();\n            preSum = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                preSum[i] = preSum[i - 1] + s[i] - '0';\n            }\n\n            intervals = new Interval[m];\n            for (int i = 0; i < m; i++) {\n                intervals[i] = new Interval();\n                intervals[i].l = in.readInt();\n                intervals[i].r = in.readInt();\n            }\n            Arrays.sort(intervals, (a, b) -> a.l == b.l ? -(a.r - b.r) : a.l - b.l);\n            Deque<Interval> deque = new ArrayDeque<>(m);\n            for (int i = 0; i < m; i++) {\n                if (deque.isEmpty()) {\n                    deque.addLast(intervals[i]);\n                } else if (deque.peekLast().l < intervals[i].l && deque.peekLast().r < intervals[i].r) {\n                    deque.addLast(intervals[i]);\n                }\n            }\n            intervals = deque.toArray(new Interval[0]);\n            m = intervals.length;\n\n            dp = new int[m + 1][6001];\n            ArrayUtils.deepFill(dp, -1);\n            Arrays.fill(dp[m], 0);\n            dp[m][zero] = 1;\n\n            int ans = dp(0, 3000);\n            out.println(ans);\n        }\n\n        public int dp(int i, int j) {\n            if (dp[i][j] == -1) {\n                dp[i][j] = 0;\n                Interval interval = intervals[i];\n                int len = interval.r - interval.l + 1;\n                int oneCnt = j - zero + preSum[interval.r] - preSum[interval.l - 1];\n                int zeroCnt = len - oneCnt;\n\n                int commonLength = 0;\n                int originOneCnt = 0;\n                if (i < m - 1 && intervals[i + 1].l <= interval.r) {\n                    commonLength = interval.r - intervals[i + 1].l + 1;\n                    originOneCnt = preSum[interval.r] - preSum[intervals[i + 1].l - 1];\n                }\n                int nonCommonLength = len - commonLength;\n\n                for (int k = Math.max(commonLength - zeroCnt, 0); k <= oneCnt && k <= commonLength; k++) {\n                    int contri = mod.mul(dp(i + 1, zero - originOneCnt + k),\n                                    comp.composite(nonCommonLength, oneCnt - k));\n                    dp[i][j] = mod.plus(dp[i][j], contri);\n                }\n            }\n            return dp[i][j];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n        }\n\n        public static class Composite {\n            final NumberTheory.Factorial factorial;\n            final NumberTheory.Modular modular;\n\n            public Composite(NumberTheory.Factorial factorial) {\n                this.factorial = factorial;\n                this.modular = factorial.modular;\n            }\n\n            public Composite(int limit, NumberTheory.Modular modular) {\n                this(new NumberTheory.Factorial(limit, modular));\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n\n        }\n\n    }\n    static class ArrayUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n    static class Interval {\n        int l;\n        int r;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1L;\n\n\t\t//i = 今見ているSの位置\n\t\tfor(int i = 0;i < N;i++){\n\n\t\t\t//j = これまで配置した1の数\n\t\t\tfor(int j = 0;j <= i;j++){\n\n\t\t\t\tif(dp[i][j] == 0)continue;\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] jがnewR[i]]の位置までに存在する1の数以下(これを超えていたら存在する1の数より多いのでありえない)\n\t\t\t\t * sum[newR[i]] - j <= newR[i] - i 残りの配置しなければならない1の数 <= newR[i]の位置まで配置できる0or1の数(これも超えていたら1が余分に存在している)\n\t\t\t\t *\n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j]に遷移する(iの位置に0を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] && sum[newR[i]] - j <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] - 1 iの位置に1を配置する分をsum[newR[i]]から引いてもちゃんとj以上になる(これがj未満になると矛盾していることになる)\n\t\t\t\t * sum[newR[i]] - j - 1 <= newR[i] - i 今iの位置に配置する分(-1)とこれまで配置した分(j)をsum[newR[i]]から引いた残りの数(これはnewR[i]の位置までに配置しなければならない1の数)が\n\t\t\t\t * 残りの配置できる位置の数以下(これが上回っていると配置することが出来ない1が出てきてしまう)\n\t\t\t\t * \n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j + 1]に遷移する(iの位置に1を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j  + 1<= sum[newR[i]] && sum[newR[i]] - j - 1 <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j]%MOD;\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(dp[N][sum[N-1]]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tdp[0][0] = 1L;\n\n\t\t//i = 今見ているSの位置\n\t\tfor(int i = 0;i < N;i++){\n\n\t\t\t//j = これまで配置した1の数\n\t\t\tfor(int j = 0;j < N;j++){\n\n\t\t\t\tif(dp[i][j] == 0)continue;\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] jがnewR[i]]の位置までに存在する1の数以下(これを超えていたら存在する1の数より多いのでありえない)\n\t\t\t\t * sum[newR[i]] - j <= newR[i] - i 残りの配置しなければならない1の数 <= newR[i]の位置まで配置できる0or1の数(これも超えていたら1が余分に存在している)\n\t\t\t\t *\n\t\t\t\t * 以上の条件を満たした時、dp[i + 1][j]に遷移する(iの位置に0を配置して次の状態に移る)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] && sum[newR[i]] - j <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j] %= MOD;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * j <= sum[newR[i]] - 1 iの位置に1を配置する分をsum[newR[i]]から引いてもちゃんとj以上になる(これがj未満になると矛盾していることになる)\n\t\t\t\t * sum[newR[i]] - j - 1 <= newR[i] - i 今iの位置に配置する分(-1)とこれまで配置した分(j)をsum[newR[i]]から引いた残りの数(これはnewR[i]の位置までに配置しなければならない1の数)が\n\t\t\t\t * 残りの配置できる位置の数以下(これが上回っていると配置することが出来ない1が出てきてしまう)\n\t\t\t\t */\n\t\t\t\tif(j <= sum[newR[i]] - 1 && sum[newR[i]] - j - 1 <= newR[i] - i){\n\t\t\t\t\tdp[i + 1][j + 1] += dp[i][j];\n\t\t\t\t\tdp[i + 1][j + 1] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(dp[N][sum[N-1]]);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\t/*\n\t * L 文字列Sの位置L-1まで既に決まっている\n\t * C S[L:newR[L]]の部分文字列に含まれる1の数\n\t */\n\tpublic long dfs(int L,int C){\n\t\t//System.err.println(\"L=\"+L+\" C=\"+C);\n\n\t\tif(L == N){\n\t\t\tif(C == 0){\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t/*if(dp[L][C] != -1){\n\t\t\treturn dp[L][C];\n\t\t}*/\n\n\t\tlong ret = 0;\n\n\t\tif(L > 0 && newR[L-1] < newR[L]){\n\t\t\tC += sum[newR[L]] - sum[newR[L-1]];\n\t\t}\n\n\t\t//System.err.println(\"after: L=\"+L+\" C=\"+C);\n\n\t\t//L番目に1を使った場合\n\t\tif(C > 0){\n\t\t\tret += dfs(L + 1,C - 1)%MOD;\n\t\t}\n\t\tret %= MOD;\n\n\t\t//L番目に0を使った場合\n\t\tif(C < newR[L] - L + 1){\n\t\t\tret += dfs(L + 1,C) %MOD;\n\t\t}\n\t\tret %= MOD;\n\t\treturn dp[L][C]=ret%MOD;\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,sum[newR[0]]));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\n\tpublic long dfs(int L,int R,int C){\n\n\t\tif(L == N){\n\t\t\treturn 1;\n\t\t}\n\n\t\tif(dp[L][C] != -1)return dp[L][C];\n\n\t\tlong ret = 0;\n\t\tint add = 0;\n\n\t\tif(R < newR[L+1]){\n\t\t\tadd = sum[newR[L+1]] - sum[R];\n\t\t}\n\n\t\t//1を配置\n\t\tif(C > 0){\n\t\t\tret += dfs(L + 1,newR[L+1],C - 1 + add) % MOD;\n\t\t}\n\n\t\t//0を配置\n\t\tif(C < R - L  + 1){\n\t\t\tret += dfs(L + 1,newR[L+1],C + add) % MOD;\n\t\t}\n\t\tret %= MOD;\n\t\treturn dp[L][C] = ret;\n\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,newR[0],sum[newR[0]]));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\t/*\n\t * L 文字列Sの位置L-1まで見た\n\t * C 位置L-1までに配置した1の数\n\t */\n\tpublic long dfs(int L,int C){\n\t\t//System.err.println(\"L=\"+L+\" C=\"+C);\n\n\t\tif(L == N){\n\t\t\tif(sum[L-1] == C)return 1L;\n\t\t\telse return 0L;\n\t\t}\n\n\t\tif(dp[L][C] != -1){\n\t\t\treturn dp[L][C];\n\t\t}\n\n\t\tlong ret = 0;\n\n\t\t//0を配置する\n\t\tif(C <= sum[newR[L]] && sum[newR[L]] - C <= newR[L] - L){\n\t\t\tret += dfs(L + 1,C) % MOD;\n\t\t}\n\n\t\t//1を配置\n\t\tif(C + 1 <= sum[newR[L]] && sum[newR[L]] - C - 1 <= newR[L] - L){\n\t\t\tret += dfs(L+1,C+1) % MOD;\n\t\t}\n\n\t\t//System.err.println(\"after: L=\"+L+\" C=\"+C);\n\t\tret %= MOD;\n\t\treturn dp[L][C]=ret%MOD;\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tnewR[i] = i;\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,0));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\t/*\n\t * L 文字列Sの位置L-1まで見た\n\t * C 位置L-1までに配置した1の数\n\t */\n\tpublic long dfs(int L,int C){\n\t\t//System.err.println(\"L=\"+L+\" C=\"+C);\n\n\t\tif(L == N){\n\t\t\treturn 1L;\n\t\t}\n\n\t\tif(dp[L][C] != -1){\n\t\t\treturn dp[L][C];\n\t\t}\n\n\t\tlong ret = 0;\n\t\t\n\t\t//0を配置する\n\t\tif(C <= sum[newR[L]] && sum[newR[L]] - C <= newR[L] - L){\n\t\t\tret += dfs(L + 1,C) % MOD;\n\t\t}\n\t\t\n\t\t//1を配置する\n\t\tif(C + 1 <= sum[newR[L]] && sum[newR[L]] - C - 1 <= newR[L] - L){\n\t\t\tret += dfs(L+1,C+1) % MOD;\n\t\t}\n\n\t\t//System.err.println(\"after: L=\"+L+\" C=\"+C);\n\t\tret %= MOD;\n\t\treturn dp[L][C]=ret%MOD;\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,0));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\n\nimport lib.io.ExtendedScanner;\nimport lib.io.Out;\nimport lib.util.IntPair;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        int mod = 1000000007;\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        var s = sc.nextChars();\n        var cum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            cum[i + 1] = cum[i] + s[i] - '0';\n        }\n        var comb = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            comb[i] = new long[i + 1];\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n                if (comb[i][j] >= mod) {\n                    comb[i][j] -= mod;\n                }\n            }\n        }\n        var segs = new ArrayList<IntPair>();\n        for (int i = 0; i < m; i++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt();\n            if (i == 0) {\n                segs.add(new IntPair(l, r));\n            } else {\n                var last = segs.get(segs.size() - 1);\n                if (last.fst == l && last.snd < r) {\n                    last.snd = r;\n                } else if (last.fst < l && last.snd < r) {\n                    segs.add(new IntPair(l, r));\n                }\n            }\n        }\n        m = segs.size();\n        var l = new int[m];\n        var r = new int[m];\n        for (int i = 0; i < m; i++) {\n            var seg = segs.get(i);\n            l[i] = seg.fst;\n            r[i] = seg.snd;\n            out.write(l[i]).write(' ').writeln(r[i]);\n        }\n        var dp = new long[m + 1][n + 1];\n        dp[0][cum[r[0]] - cum[l[0]]] = 1;\n        for (int i = 0; i < m - 1; i++) {\n            int w = r[i] - l[i];\n            int x = r[i] - l[i + 1];\n            if (x <= 0) {\n                long sum = 0;\n                for (int j = 0; j <= w; j++) {\n                    sum += dp[i][j] * comb[w][j];\n                }\n                sum %= mod;\n                dp[i + 1][cum[r[i + 1]] - cum[l[i + 1]]] = sum;\n                continue;\n            }\n            int p = cum[r[i + 1]] - cum[r[i]];\n            for (int j = 0; j <= n; j++) {\n                if (dp[i][j] == 0) continue;\n                int l1 = Math.max(0, x - (w - j));\n                int r1 = Math.min(j, x);\n                for (int k = l1; k <= r1; k++) {\n                    dp[i + 1][p + k] += comb[w - x][j - k] * dp[i][j];\n                    dp[i + 1][p + k] %= mod;\n                }\n            }\n        }\n        for (int j = 0, w = r[m - 1] - l[m - 1]; j <= w; j++) {\n            dp[m][j] = (dp[m - 1][j] * comb[w][j]) % mod;\n        }\n        long ans = 0;\n        for (int j = 0; j <= n; j++) {\n            ans += dp[m][j];\n        }\n        ans %= mod;\n        out.writeln(ans < 0 ? ans + mod : ans);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic final int MOD = (int)1e9 + 7;\n\tint N,M;\n\tchar[] ch;\n\tint[] r,l,newR,sum;\n\tlong[][] dp;\n\n\t/*\n\t * L 文字列Sの位置L-1まで見た\n\t * C 位置L-1までに配置した1の数\n\t */\n\tpublic long dfs(int L,int C){\n\t\t//System.err.println(\"L=\"+L+\" C=\"+C);\n\n\t\tif(L == N){\n\t\t\tif(sum[L-1] == C)return 1L;\n\t\t\telse return 0L;\n\t\t}\n\n\t\tif(dp[L][C] != -1){\n\t\t\treturn dp[L][C];\n\t\t}\n\n\t\tlong ret = 0;\n\n\t\t//0を配置する\n\t\tif(C <= sum[newR[L]] && sum[newR[L]] - C <= newR[L] - L){\n\t\t\tret += dfs(L + 1,C) % MOD;\n\t\t}\n\n\t\t//1を配置\n\t\tif(C + 1 <= sum[newR[L]] && sum[newR[L]] - C - 1 <= newR[L] - L){\n\t\t\tret += dfs(L+1,C+1) % MOD;\n\t\t}\n\n\t\t//System.err.println(\"after: L=\"+L+\" C=\"+C);\n\t\tret %= MOD;\n\t\treturn dp[L][C]=ret%MOD;\n\t}\n\n\tpublic void solve() {\n\t\tN = nextInt();\n\t\tM = nextInt();\n\t\tch = next().toCharArray();\n\n\t\tl = new int[M];\n\t\tr = new int[M];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tl[i] = nextInt() - 1;\n\t\t\tr[i] = nextInt() - 1;\n\t\t}\n\n\t\tnewR = new int[N + 1];\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = l[i];\n\t\t}\n\t\tfor(int i = 0;i < M;i++){\n\t\t\tnewR[l[i]] = Math.max(newR[l[i]],r[i]);\n\t\t}\n\t\tfor(int i = 1;i < N;i++){\n\t\t\tnewR[i] = Math.max(newR[i], newR[i-1]);\n\t\t}\n\n\t\tsum = new int[N];\n\t\tfor(int i = 0;i < N;i++){\n\t\t\tsum[i] = ch[i] - '0';\n\t\t}\n\t\tfor(int i = 0;i < N - 1;i++){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\n\t\tdp = new long[N + 1][N + 1];\n\t\tfor(int i = 0;i < N + 1;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\n\t\tout.println(dfs(0,0));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by zzt on 17-1-26.\n */\npublic class Main {\n\n    private static int n, m;\n    private static char[] chars;\n    private static int[] l, r, newR, sum;\n    private static long[][] dp;\n    private static final int MOD = (int) (1e9 + 7);\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        chars = scanner.next().toCharArray();\n\n        l = new int[m];\n        r = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            l[i] = scanner.nextInt() - 1;\n            r[i] = scanner.nextInt() - 1;\n        }\n        newR = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            newR[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            newR[l[i]] = Math.max(newR[l[i]], r[i]);\n        }\n        for (int i = 1; i < n; i++) {\n            newR[i] = Math.max(newR[i], newR[i - 1]);\n        }\n        sum = new int[n];\n        for (int i = 0; i < n; i++) {\n            sum[i] = chars[i] - '0';\n        }\n        for (int i = 0; i < n - 1; i++) {\n            sum[i + 1] += sum[i];\n        }\n        dp = new long[n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) {\n            Arrays.fill(dp[i], -1);\n        }\n        System.out.println(dfs(0, newR[0], sum[newR[0]]));\n    }\n\n    static long dfs(int L, int R, int c) {\n        if (L == n)\n            return 1;\n        if (dp[L][c] != -1)\n            return dp[L][c];\n        long ret = 0;\n        int add = 0;\n        if (R < newR[L + 1])\n            add = sum[newR[L + 1]] - sum[R];\n        if (c > 0)\n            ret += dfs(L + 1, newR[L + 1], c - 1 + add) % MOD;\n        if (c < R - L + 1) {\n            ret += dfs(L + 1, newR[L + 1], c + add) % MOD;\n        }\n        ret %= MOD;\n        return dp[L][c] = ret;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.util.Deque;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"daltao\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskC solver = new TaskC();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskC {\n        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n        NumberTheory.Composite comp = new NumberTheory.Composite(10000, mod);\n        int[] preSum;\n        int[][] dp;\n        int n;\n        int m;\n        Interval[] intervals;\n        int zero = 3000;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            n = in.readInt();\n            m = in.readInt();\n            char[] s = (\" \" + in.readString()).toCharArray();\n            preSum = new int[n + 1];\n            for (int i = 1; i <= n; i++) {\n                preSum[i] = preSum[i - 1] + s[i] - '0';\n            }\n\n            intervals = new Interval[m];\n            for (int i = 0; i < m; i++) {\n                intervals[i] = new Interval();\n                intervals[i].l = in.readInt();\n                intervals[i].r = in.readInt();\n            }\n            Arrays.sort(intervals, (a, b) -> a.l == b.l ? -(a.r - b.r) : a.l - b.l);\n            Deque<Interval> deque = new ArrayDeque<>(m);\n            for (int i = 0; i < m; i++) {\n                if (deque.isEmpty()) {\n                    deque.addLast(intervals[i]);\n                } else if (deque.peekLast().l < intervals[i].l && deque.peekLast().r < intervals[i].r) {\n                    deque.addLast(intervals[i]);\n                }\n            }\n            intervals = deque.toArray(new Interval[0]);\n            m = intervals.length;\n\n            dp = new int[m + 1][6001];\n            ArrayUtils.deepFill(dp, -1);\n            Arrays.fill(dp[m], 0);\n            dp[m][zero] = 1;\n\n            int ans = dp(0, 3000);\n            out.println(ans);\n        }\n\n        public int dp(int i, int j) {\n            if (dp[i][j] == -1) {\n                dp[i][j] = 0;\n                Interval interval = intervals[i];\n                int len = interval.r - interval.l + 1;\n                int oneCnt = j - zero + preSum[interval.r] - preSum[interval.l - 1];\n                int zeroCnt = len - oneCnt;\n\n                int commonLength = 0;\n                int originOneCnt = 0;\n                if (i < m - 1 && intervals[i + 1].l <= interval.r) {\n                    commonLength = interval.r - intervals[i + 1].l + 1;\n                    originOneCnt = preSum[interval.r] - preSum[intervals[i + 1].l - 1];\n                }\n                int nonCommonLength = len - commonLength;\n\n                for (int k = Math.max(commonLength - zeroCnt, 0); k <= oneCnt && k <= commonLength; k++) {\n                    int contri = mod.mul(dp(i + 1, zero - originOneCnt + k),\n                                    comp.composite(nonCommonLength, oneCnt - k));\n                    dp[i][j] = mod.plus(dp[i][j], contri);\n                }\n            }\n            return dp[i][j];\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(1 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n        }\n\n        public static class Composite {\n            final NumberTheory.Factorial factorial;\n            final NumberTheory.Modular modular;\n\n            public Composite(NumberTheory.Factorial factorial) {\n                this.factorial = factorial;\n                this.modular = factorial.modular;\n            }\n\n            public Composite(int limit, NumberTheory.Modular modular) {\n                this(new NumberTheory.Factorial(limit, modular));\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n\n        }\n\n    }\n    static class ArrayUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n    static class Interval {\n        int l;\n        int r;\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        string s = Console.ReadLine();\n        int N = int.Parse(str[0]);\n        int[] R = new int[N];\n        {\n            int M = int.Parse(str[1]);\n            int l = 0;\n            int r = 0;\n            for(int i=0;i<M;i++){\n                str = Console.ReadLine().Split(' ');\n                int a = int.Parse(str[0])-1;\n                int b = int.Parse(str[1])-1;\n                if(l != a){\n                    for(int j=l;j<a;j++){\n                        R[j] = Math.Max(r,j);\n                    }\n                    l = a;\n                }\n                r = Math.Max(r,b);\n            }\n            for(int j=l;j<N;j++){\n                R[j] = Math.Max(r,j);\n            }\n        }\n        int[] one = new int[N];\n        one[0] = s[0] == '1' ? 1 : 0;\n        for(int i=1;i<N;i++){\n            one[i] = one[i-1] + (s[i] == '1' ? 1 : 0);\n        }\n        int C = one[N-1];\n        long[,] dp = new long[N,C+1];\n        dp[N-1,C] = 1;\n        for(int i=C-1;i>=0;i--){\n            dp[N-1,i] = 0;\n        }\n        for(int i=N-2;i>=0;i--){\n            for(int j=0;j<C;j++){\n                dp[i,j] = (one[R[i]] >= j && (R[i] + 1 - one[R[i]] >= i + 1 - j) && i+1 >= j) ? (dp[i+1,j] + dp[i+1,j+1]) % Define.mod : 0; \n            }\n            dp[i,C] = (one[R[i]] >= C && (R[i] + 1 - one[R[i]] >= i + 1 - C) && i+1 >= C) ? dp[i+1,C] : 0;\n        }\n        sb.Append((C != 0 ? (dp[0,0] + dp[0,1])%Define.mod : dp[0,0])+\"\\n\");\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        string s = Console.ReadLine();\n        int N = int.Parse(str[0]);\n        int[] R = new int[N];\n        {\n            int M = int.Parse(str[1]);\n            int l = 0;\n            int r = 0;\n            for(int i=0;i<M;i++){\n                str = Console.ReadLine().Split(' ');\n                int a = int.Parse(str[0])-1;\n                int b = int.Parse(str[1])-1;\n                if(l != a){\n                    for(int j=l;j<a;j++){\n                        R[j] = r;\n                    }\n                    l = a;\n                }\n                r = Math.Max(r,b);\n            }\n            for(int j=l;j<N;j++){\n                R[j] = Math.Max(r,j);\n            }\n        }\n        int[] one = new int[N];\n        one[0] = s[0] == '1' ? 1 : 0;\n        for(int i=1;i<N;i++){\n            one[i] = one[i-1] + (s[i] == '1' ? 1 : 0);\n        }\n        int C = one[N-1];\n        long[,] dp = new long[N,C+1];\n        dp[N-1,C] = 1;\n        for(int i=C-1;i>=0;i--){\n            dp[N-1,i] = 0;\n        }\n        for(int i=N-2;i>=0;i--){\n            for(int j=0;j<C;j++){\n                dp[i,j] = (one[R[i]] >= j && (R[i] + 1 - one[R[i]] >= i + 1 - j)) ? (dp[i+1,j] + dp[i+1,j+1]) % Define.mod : 0; \n            }\n            dp[i,C] = (one[R[i]] >= C && (R[i] + 1 - one[R[i]] >= i + 1 - C)) ? dp[i+1,C] : 0;\n        }\n        sb.Append((dp[0,0] + dp[0,1])%Define.mod+\"\\n\");\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nusing Enu = System.Linq.Enumerable;\n\npublic class Program\n{\n    static readonly int Mod = (int)1e9 + 7;\n    static void Add(ref int a, int b) { if ((a += b) >= Mod) a -= Mod; }\n    bool CheckMax(ref int a, int b) { if (b > a) { a = b; return true; } return false; }\n\n    public void Solve()\n    {\n        int N = Reader.Int(), M = Reader.Int();\n        var A = Reader.String().Select(c => c - '0').ToArray();\n        var seg = Reader.IntTable(M);\n\n        var R = new int[N];\n        foreach (var s in seg) CheckMax(ref R[s[0] - 1], s[1]);\n        for (int i = 1; i < N; i++)\n            if (R[i - 1] > i) CheckMax(ref R[i], R[i - 1]);\n\n        var sumOne = new int[N + 1]; // [0, i)\n        for (int i = 0; i < N; i++)\n            sumOne[i + 1] = sumOne[i] + A[i];\n\n        var dp = new int[N + 1, N + 1];\n        dp[0, 0] = 1;\n        for (int i = 0; i < N; i++)\n            for (int usedOne = 0; usedOne <= i; usedOne++)\n                if (dp[i, usedOne] > 0)\n                {\n                    if (R[i] == 0)\n                    {\n                        Add(ref dp[i + 1, usedOne + A[i]], dp[i, usedOne]);\n                        continue;\n                    }\n                    int remOne = sumOne[R[i]] - usedOne;\n                    int remZero = (R[i] - sumOne[R[i]]) - (i - usedOne);\n                    if (remOne > 0)\n                        Add(ref dp[i + 1, usedOne + 1], dp[i, usedOne]);\n                    if (remZero > 0)\n                        Add(ref dp[i + 1, usedOne], dp[i, usedOne]);\n                }\n\n        Console.WriteLine(dp[N, sumOne[N]]);\n    }\n}\n\n\nclass Entry { static void Main() { new Program().Solve(); } }\nclass Reader\n{\n    static TextReader reader = Console.In;\n    static readonly char[] separator = { ' ' };\n    static readonly StringSplitOptions op = StringSplitOptions.RemoveEmptyEntries;\n    static string[] A = new string[0];\n    static int i;\n    static void Init() { A = new string[0]; }\n    public static void Set(TextReader r) { reader = r; Init(); }\n    public static void Set(string file) { reader = new StreamReader(file); Init(); }\n    public static bool HasNext() { return CheckNext(); }\n    public static string String() { return Next(); }\n    public static int Int() { return int.Parse(Next()); }\n    public static long Long() { return long.Parse(Next()); }\n    public static double Double() { return double.Parse(Next()); }\n    public static int[] IntLine() { return Array.ConvertAll(Split(Line()), int.Parse); }\n    public static int[] IntArray(int N) { return Range(N, Int); }\n    public static int[][] IntTable(int H) { return Range(H, IntLine); }\n    public static string[] StringArray(int N) { return Range(N, Next); }\n    public static string[][] StringTable(int N) { return Range(N, () => Split(Line())); }\n    public static string Line() { return reader.ReadLine().Trim(); }\n    public static T[] Range<T>(int N, Func<T> f) { var r = new T[N]; for (int i = 0; i < N; r[i++] = f()) ; return r; }\n    static string[] Split(string s) { return s.Split(separator, op); }\n    static string Next() { CheckNext(); return A[i++]; }\n    static bool CheckNext()\n    {\n        if (i < A.Length) return true;\n        string line = reader.ReadLine();\n        if (line == null) return false;\n        if (line == \"\") return CheckNext();\n        A = Split(line);\n        i = 0;\n        return true;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\nusing System.Numerics;\nusing Number = System.Int64;\nnamespace Program\n{\n\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var max = Enumerate(n, x => x);\n            var s = sc.Scan();\n            for (int i = 0; i < m; i++)\n            {\n                var l = sc.Integer() - 1;\n                var r = sc.Integer() - 1;\n                max[l] = Math.Max(max[l], r);\n            }\n            for (int i = 1; i < n; i++)\n                max[i] = Math.Max(max[i], max[i - 1]);\n            var dp = new ModInteger[n + 1];\n            dp[0] = 1;\n            var a = 0; var b = 0;\n            for (int i = 0, r = 0; i < n; i++)\n            {\n                while (r <= max[i]) { if (s[r] == '0') a++; else b++; r++; }\n                var next = new ModInteger[n + 1];\n                for (int j = 0; j <= n; j++)\n                {\n                    if (dp[j].num == 0) continue;\n                    if (j + 1 <= a) next[j + 1] += dp[j];\n                    var k = i - j;\n                    if (k + 1 <= b) next[j] += dp[j];\n                }\n                dp = next;\n            }\n            IO.Printer.Out.WriteLine(dp[a]);\n\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger() { num = n }; }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        string s = Console.ReadLine();\n        int N = int.Parse(str[0]);\n        int[] R = new int[N];\n        {\n            int M = int.Parse(str[1]);\n            int l = 0;\n            int r = 0;\n            for(int i=0;i<M;i++){\n                str = Console.ReadLine().Split(' ');\n                int a = int.Parse(str[0])-1;\n                int b = int.Parse(str[1])-1;\n                if(l != a){\n                    for(int j=l;j<a;j++){\n                        R[j] = r;\n                    }\n                    l = a;\n                }\n                r = Math.Max(r,b);\n            }\n            for(int j=l;j<N;j++){\n                R[j] = Math.Max(r,j);\n            }\n        }\n        int[] one = new int[N];\n        one[0] = s[0] == '1' ? 1 : 0;\n        for(int i=1;i<N;i++){\n            one[i] = one[i-1] + (s[i] == '1' ? 1 : 0);\n        }\n        int C = one[N-1];\n        long[,] dp = new long[N,C+1];\n        dp[N-1,C] = 1;\n        for(int i=C-1;i>=0;i--){\n            dp[N-1,i] = 0;\n        }\n        for(int i=N-2;i>=0;i--){\n            for(int j=0;j<C;j++){\n                dp[i,j] = (one[R[i]] >= j && (R[i] + 1 - one[R[i]] >= i + 1 - j)) ? (dp[i+1,j] + dp[i+1,j+1]) % Define.mod : 0; \n            }\n            dp[i,C] = (one[R[i]] >= C && (R[i] + 1 - one[R[i]] >= i + 1 - C)) ? dp[i+1,C] : 0;\n        }\n        sb.Append((dp[0,0] + dp[0,1])+\"\\n\");\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto S = readln.chomp;\n    auto LR = M.iota.map!(_ => readln.split.map!(a => a.to!int - 1).array).array;\n\n    auto zeros = new long[](N+1);\n    foreach (i; 0..N) {\n        zeros[i+1] = zeros[i] + (S[i] == '0');\n    }\n\n    auto dp = new long[][](N+1, N+1);\n    dp[0][0] = 1;\n    int rmax = 0;\n    int q = 0;\n\n    foreach (i; 0..N) {\n        while (q < M && LR[q][0] <= i) {\n            rmax = max(LR[q][1], rmax);\n            q += 1;\n        }\n        rmax = max(rmax, i);\n        long zero = zeros[rmax+1];\n        long one = rmax + 1 - zero;\n\n        foreach (j; 0..i+1) {\n            long rest_zero = zero - j;\n            long rest_one = one - (i - j);\n            if (rest_zero < 0 || rest_one < 0) {\n                continue;\n            }\n            if (rest_zero > 0) {\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            }\n            if (rest_one > 0) {\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j] %= MOD;\n            }\n        }\n    }\n\n    long ans = 0;\n    foreach (a; dp[N]) {\n        ans += a;\n        ans %= MOD;\n    }\n\n    ans.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto S = readln.chomp;\n    auto LR = M.iota.map!(_ => readln.split.map!(a => a.to!int - 1).array).array;\n\n    auto zeros = new long[](N+1);\n    foreach (i; 0..N) {\n        zeros[i+1] = zeros[i] + (S[i] == '0');\n    }\n\n    auto dp = new long[][](N+1, N+1);\n    dp[0][0] = 1;\n    int rmax = 0;\n    int q = 0;\n\n    foreach (i; 0..N) {\n        while (q < M && LR[q][0] <= i) {\n            rmax = max(LR[q][1], rmax);\n            q += 1;\n        }\n        rmax = max(rmax, i);\n        long zero = zeros[rmax+1];\n        long one = rmax + 1 - zero;\n\n        foreach (j; 0..i+1) {\n            long rest_zero = zero - j;\n            long rest_one = one - (i - j);\n            if (rest_zero < 0 || rest_one < 0) {\n                continue;\n            }\n            if (rest_zero > 0) {\n                dp[i+1][j+1] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            }\n            if (rest_one > 0) {\n                dp[i+1][j] += dp[i][j];\n                dp[i+1][j+1] %= MOD;\n            }\n        }\n    }\n\n    long ans = 0;\n    foreach (a; dp[N]) {\n        ans += a;\n        ans %= MOD;\n    }\n\n    ans.writeln;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long fac[2005],fx[2005],inv[2005];\nconst int mod=1e9+7;\nvoid init()\n{\n\tfac[1]=1;for(int i=2;i<=2000;++i)fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;for(int i=2;i<=2000;++i)inv[i]=(mod-mod/i)%mod*inv[mod%i]%mod;\n\tfx[0]=fx[1]=1;for(int i=2;i<=2000;++i)fx[i]=inv[i]*fx[i-1]%mod;\n}\nstruct node\n{\n\tint l,r;\n}p[3005],q[3005];\nint a[3005];\nchar s[3005];\nlong long dp[3005][2005];\nint n,m;\nlong long C(int n,int m)\n{\n\treturn fac[n]*fx[m]%mod*fx[n-m]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",s);\n\tfor(int i=0;i<n;++i)\n\ta[i+1]=a[i]+s[i]-'0';\n\tfor(int i=1;i<=m;++i)\n\tscanf(\"%d%d\",&p[i].l,&p[i].r);\n\tint cnt=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(p[i].l==p[i+1].l&&p[i].r<=p[i+1].r){\n\t\t\tcontinue;\n\t\t}\n\t\tint j=i+1;\n\t\twhile(p[i].l<=p[j].l&&p[i].r>=p[j].r&&j<=m)\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tq[++cnt].l=p[i].l;q[cnt].r=p[i].r;\n\t\ti=j-1;\n\t}m=cnt;\n\tmemset(dp,0,sizeof(dp));\n\tq[m+1].l=n+1;q[m+1].r=n+1;a[n+1]=a[n];\n\tdp[1][a[q[1].r]-a[q[1].l-1]]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tif(q[i].r<q[i+1].l){\n\t\t\tint tmp=a[q[i+1].r]-a[q[i+1].l-1];\n\t\t\tfor(int j=0;j<=q[i].r-q[i].l+1;++j)\n\t\t\tdp[i+1][tmp]=(dp[i+1][tmp]+dp[i][j]*C(q[i].r-q[i].l+1,j))%mod;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=a[q[i+1].r]-a[q[i].r];\n\t\t\tint t=q[i].r-q[i].l+1;\n\t\t\tint pre=q[i+1].l-q[i].l;\n\t\t\tint len=q[i].r-q[i+1].l+1;\n\t\t\tfor(int j=0;j<=t;++j)\n\t\t\tfor(int k=max(0,j-pre);k<=j&&k<=len;++k){\n\t\t\t\tdp[i+1][tmp+k]=(dp[i+1][tmp+k]+dp[i][j]*C(pre,j-k))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",dp[m+1][0]);\n\treturn 0;\n} "
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nM = 10 ** 9 + 7\n\n\ndef solve(n, m, s, lst):\n\n    cnt = [0] * n\n    t = 0\n    for i in range(n):\n        if s[i] == '1':\n            t += 1\n        cnt[i] = t\n\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    r = 0\n    j = 0\n    for i in range(n):\n        while j < m:\n            lj, rj = lst[j]\n            if lj <= i:\n                r = max(r, rj)\n                j += 1\n            else:\n                break\n        if r <= i:\n            c = cnt[i]\n            if 0 < c:\n                dp[i + 1][cnt[i]] = (dp[i][c] + dp[i][c - 1]) % M\n            else:\n                dp[i + 1][0] = dp[i][0]\n        else:\n            for k in range(max(0, cnt[r] - r + i), min(i + 1, cnt[r]) + 1):\n                if 0 < k:\n                    dp[i + 1][k] = (dp[i][k] + dp[i][k - 1]) % M\n                else:\n                    dp[i + 1][0] = dp[i][0]\n\n    return dp[n][cnt[n - 1]]\n\n\ndef main():\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    s = input()\n    lst = []\n    for _ in range(m):\n        l, r = input().split()\n        l = int(l) - 1\n        r = int(r) - 1\n        lst.append((l, r))\n\n    print(solve(n, m, s, lst))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,m = map(int,readline().split())\ns = input()\nmp = map(int,read().split())\n\nr = list(range(n))\nfor i,j in zip(mp,mp):\n    if r[i-1] < j-1:\n        r[i-1] = j-1\n\nfor i in range(1,n):\n    if r[i] < r[i-1]: r[i] = r[i-1]\n\nzero = [0]*n\none = [0]*n\nfor i in range(n):\n    zero[i] = zero[i-1]\n    one[i] = one[i-1]\n    if s[i]==\"0\": zero[i] += 1\n    else: one[i] += 1\n\n\n#print(r)\n#print(s)\n#print(zero)\n\nMOD = 10**9+7\ndp = [0]*n\ndp[0] = 1\nfor i in range(n):\n    L = max(zero[r[i]] + i - r[i],0)\n    R = min(zero[r[i]],i+1)\n    ndp = [0]*n\n\n    for i in range(L,R+1):\n        if i: ndp[i] += dp[i-1]\n        ndp[i] += dp[i]\n        ndp[i] %= MOD        \n    dp = ndp\n\n\n    #print(L,R,r[i],zero[r[i]],dp)\nprint(sum(dp))\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc065/tasks/arc065_d\n\n圧倒的dp感\n\nlは非減少なので、 l[i-1] ～l[i] の間が確定する範囲\n\ndp[i][今の区間に残っている1の数] = 並び替えの通り数　でやると\ndp推移がO(N^2)になってしまう…\n\n1の位置さえ決まればよい。\nあらかじめ、それぞれの1に関して、移動しうる最小のindexと最大のindexを前計算\n→どうやって？\n→heapといもす法で、最小・最大値管理しつつ\n\nあとはdp中に一点取得、区間加算がO(N)で出来れば、O(N**2)で解ける\n→dp[i個目までの1を処理][右端にある1のindex]\nとし、最後に累積和で区間加算する→DP推移はO(N)なのでおｋ\n\n→なんか違う？\n→1をもってける範囲の右端が実際より短くなっているのが原因\n\n\n\"\"\"\nfrom collections import deque\nimport heapq\nN,M = map(int,input().split())\nS = input()\n\"\"\"\nlri = deque([])\nrpick = [ [] for i in range(N+1)]\nfor i in range(M):\n    l,r = map(int,input().split())\n    lri.append([l-1,r-1,i])\n    rpick[r].append(i)\n\nlheap = []\nrheap = []\nstate = [False] * M\n\nLRlis = []\n\nfor i in range(N):\n\n    while len(lri) > 0 and lri[0][0] == i: #新たに区間を入れる\n        l,r,ind = lri.popleft()\n        heapq.heappush(lheap,[l,ind])\n        heapq.heappush(rheap,[-1*r,ind])\n\n    for pickind in rpick[i]:\n\n        state[pickind] = True\n\n    while len(lheap) > 0 and state[ lheap[0][1] ]:\n        heapq.heappop(lheap)\n    while len(rheap) > 0 and state[ rheap[0][1] ]:\n        heapq.heappop(rheap)\n\n    if S[i] == \"1\":\n\n        if len(lheap) == 0 or len(rheap) == 0:\n            LRlis.append([i,i])\n        else:\n            LRlis.append([lheap[0][0] , -1 * rheap[0][0] ])\n\n\"\"\"\nlri = []\nfor i in range(M):\n    l,r = map(int,input().split())\n    lri.append([l-1,r-1,i])\nlri.append([N,float(\"inf\"),float(\"inf\")])\n\nnexvisit = 0\nonenum = 0\nLRlis = []\nLRlisind = 0\nr = 0\nfor loop in range(M):\n    \n    l,nr,tempi = lri[loop]\n    r = max(nr,r)\n    nexl = lri[loop+1][0]\n    #print (l,r,nexl)\n\n    for i in range( max(l,nexvisit) , r+1 ):\n        if S[i] == \"1\":\n            LRlis.append([l,None])\n            onenum += 1\n            nexvisit = max(nexvisit,i+1)\n    if r-nexl+1 < onenum:\n\n        for i in range(min(onenum , onenum - (r-nexl+1))):\n            LRlis[LRlisind][1] = r-onenum+1\n            onenum -= 1\n            LRlisind += 1\n            \nmod = 10**9+7\ndp = [0] * (N+1)\n#print (LRlis)\n\nfor i in range(len(LRlis)):\n\n    #print (dp)\n\n    l,r = LRlis[i]\n\n    ndp = [0] * (N+1)\n\n    if i == 0:\n        ndp[l] += 1\n        ndp[r+1] -= 1\n    else:\n\n        for v in range(r):\n\n            ndp[max(l,v+1)] += dp[v]\n            ndp[r+1] -= dp[v]\n\n    for j in range(N):\n        ndp[j+1] += ndp[j]\n        ndp[j] %= mod\n        ndp[j+1] % mod\n\n    dp = ndp\n\n#print (dp)\nprint (sum(dp[0:N]) % mod)\n\n\n    \n\n    \n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\nN, M = map(int, readline().split())\nS = list(map(int, readline().strip()))\nQuery = [tuple(map(lambda x: int(x) - 1, readline().split())) for _ in range(M)]\n\nPP = S.count(1)\n\nLi = [None]*PP\nRi = [None]*PP\n\nT1 = S[:]\nfor l, r in Query:\n    cnt = 0\n    for i in range(l, r+1):\n        cnt += T1[i]\n    for i in range(l, l+cnt):\n        T1[i] = 1\n    for i in range(l+cnt, r+1):\n        T1[i] = 0\nT2 = S[:]\nfor l, r in Query:\n    cnt = 0\n    for i in range(l, r+1):\n        cnt += 1 - T2[i]\n    for i in range(l, l+cnt):\n        T2[i] = 0\n    for i in range(l+cnt, r+1):\n        T2[i] = 1\n\ncnt = 0\nfor i in range(N):\n    if T1[i]:\n        Li[cnt] = i\n        cnt += 1\ncnt = 0\nfor i in range(N):\n    if T2[i]:\n        Ri[cnt] = i+1\n        cnt += 1\n\ndp = [0]*N\nfor i in range(Li[0], Ri[0]):\n    dp[i] = 1\n\nfor j in range(1, PP):\n    dp2 = [0] + dp[:-1]\n    for i in range(1, N):\n        dp2[i] = (dp2[i]+dp2[i-1])%MOD\n    for i in range(Li[j]):\n        dp2[i] = 0\n    for i in range(Ri[j], N):\n        dp2[i] = 0\n    dp = dp2[:]\nres = 0\nfor d in dp:\n    res = (res+d)%MOD\nprint(res)\n    \n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nM = 10 ** 9 + 7\n\ndef solve(n, m, s, p):\n\n    cnt = [0] * (n + 1)\n    c = 0\n    for i in range(n):\n        cnt[i] = c\n        if s[i] == '1':\n            c += 1\n    cnt[n] = c\n\n\n    ans = 1\n    for sp in p:\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n        l0, r0 = sp[0]\n        c0 = cnt[l0]\n        dp[1][1] = 1\n        t0 = 0\n        t1 = 0\n        r = r0\n        for tpl in sp:\n            nl, nr = tpl\n            nr = max(r, nr)\n            nt1 = cnt[nr] - c0\n            nt0 = nr - l0 - nt1\n            for i in range(max(nl - l0 - t1, 0), t0 + 1):\n                for j in range(t1 + 1, nt1 + 1):\n                    dp[i + 1][j + 1] = (dp[i + 1][j] + dp[i][j + 1]) % M\n            for i in range(t0 + 1, nt0 + 1):\n                for j in range(max(nl - l0 - t0, 0), t1 + 1):\n                    dp[i + 1][j + 1] = (dp[i + 1][j] + dp[i][j + 1]) % M\n            for i in range(t0 + 1, nt0 + 1):\n                for j in range(t1 + 1, nt1 + 1):\n                    dp[i + 1][j + 1] = (dp[i + 1][j] + dp[i][j + 1]) % M\n            t0 = nt0\n            t1 = nt1\n        ans *= dp[t0 + 1][t1 + 1]\n        ans %= M\n\n    return ans\n\n\ndef main():\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    s = input()\n    p = []\n    ll = -1\n    lr = 0\n    for _ in range(m):\n        l, r = input().split()\n        l = int(l) - 1\n        r = int(r)\n        r = max(lr, r)\n        if l == ll:\n            sp.pop()\n            sp.append((l, r))\n        else:\n            if lr <= l:\n                sp = []\n                p.append(sp)\n            sp.append((l, r))\n        ll = l\n        lr = r\n\n    print(solve(n, m, s, p))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n+1)]\n        self.rank = [0] * (n+1)\n        self.size = [1] * (n+1)\n    \n    # 譬ｹ繧呈､懃ｴ｢縺吶ｋ髢｢謨ｰ\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.find(self.par[x])\n  \n    # 邨仙粋(unite)縺吶ｋ髢｢謨ｰ\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    # 蜷後§繧ｰ繝ｫ繝ｼ繝励↓螻槭☆繧九°繧貞愛螳壹☆繧矩未謨ｰ\n    def same_check(self, x, y):\n        return self.find(x) == self.find(y)\n    \n    # 隕∫ｴ縺悟ｱ槭☆繧区惠縺ｮ豺ｱ縺輔ｒ霑斐☆髢｢謨ｰ\n    def get_depth(self, x):\n        return self.rank[self.find(x)]\n    \n    # 隕∫ｴ縺悟ｱ槭☆繧区惠縺ｮ繧ｵ繧､繧ｺ繧定ｿ斐☆髢｢謨ｰ\n    def get_size(self, x):\n        return self.size[self.find(x)]\n    \n    # 繧ｰ繝ｫ繝ｼ繝玲焚繧定ｿ斐☆髢｢謨ｰ\n    def group_sum(self):\n        c = 0\n        for i in range(len(self.par)):\n            if self.find(i) == i:\n                c += 1\n        return c\n\nif __name__ == \"__main__\":\n    N,K,L = map(int, input().split())\n    uf = UnionFind(N)\n\n    for i in range(K):\n        p, q = [int(i) for i in input().split()]\n        uf.unite(p, q)\n    \n    ans = [1]*N\n    for i in range(L):\n        r, s = [int(i) for i in input().split()]\n        if uf.same_check(r, s):\n            ans[r-1] += 1\n            ans[s-1] += 1\n    \n    print(*ans)\n    "
  },
  {
    "language": "Python",
    "code": "mod=10**9+7\n\nN,M=map(int,input().split())\nL=-1;R=-1\nS=input()\nope=[]\nfor i in range(M):\n    l,r=map(int,input().split())\n    l-=1;r-=1\n    if L<=l and r<=R:\n        continue\n    else:\n        L,R=l,r\n        ope.append((l,r))\n\nM=len(ope)\ndata=[-1]*N\nfor i in range(M):\n    l,r=ope[i]\n    for j in range(l,r+1):\n        data[j]=i\n\ndp=[[0 for i in range(N+1)] for j in range(N+1)]\n\nfor j in range(N+1):\n    dp[-1][j]=1\n\nfor i in range(N-1,-1,-1):\n    id=data[i]\n    if id!=-1:\n        l,r=ope[id]\n        temp1=sum(int(S[k]) for k in range(r+1))\n        temp0=r+1-temp1\n        for j in range(temp1+1):\n            np1=temp1-j\n            np0=temp0-(i-j)\n            if np1==0:\n                if np0>0:\n                    dp[i][j]=dp[i+1][j]\n            else:\n                if np0>0:\n                    dp[i][j]=(dp[i+1][j+1]+dp[i+1][j])%mod\n                elif np0==0:\n                    dp[i][j]=dp[i+1][j+1]\n    else:\n        if S[i]==\"1\":\n            for j in range(N):\n                dp[i][j]=dp[i+1][j+1]\n        else:\n            for j in range(N+1):\n                dp[i][j]=dp[i+1][j]\n\nprint(dp[0][0])"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn,m = map(int,readline().split())\ns = input()\nmp = map(int,read().split())\n\nr = [0]*n\nfor i,j in zip(mp,mp):\n    if r[i-1] < j-1:\n        r[i-1] = j-1\n\nfor i in range(1,n):\n    if r[i] < r[i-1]: r[i] = r[i-1]\n\nzero = [0]*n\nfor i in range(n):\n    zero[i] = zero[i-1]\n    if s[i]==\"0\": zero[i] += 1\n\n#print(r)\n#print(s)\n#print(zero)\n\nMOD = 10**9+7\ndp = [0]*n\ndp[0] = 1\nfor i in range(n):\n    L = max(zero[r[i]] + i - r[i],0)\n    R = min(zero[r[i]],i+1)\n    ndp = [0]*n\n\n    for i in range(L,R+1):\n        if i: ndp[i] += dp[i-1]\n        ndp[i] += dp[i]\n        ndp[i] %= MOD        \n    dp = ndp\n\n\n    #print(L,R,r[i],zero[r[i]],dp)\nprint(sum(dp)%MOD)\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n \ntypedef long long ll;\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y)\n{\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nint sub(int x, int y)\n{\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nint mult(int x, int y)\n{\n\treturn ((ll)x * y) % MOD;\n}\n \nconst int N = 3030;\nint n;\nchar s[N];\nint a[N];\nint b[N];\nint dp[N][N];\nint C[N][N];\n \nvoid read()\n{\n\tint m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\" %s \", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)(s[i] - '0');\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = i + 1;\n\twhile(m--)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tl--;\n\t\tb[l] = max(b[l], r);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tb[i] = max(b[i], b[i - 1]);\n}\n \nint main()\n{\n\tread();\n \n\tfor (int i = 0; i < N; i++)\n\t\tC[i][0] = C[i][i] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tC[i][j] = add(C[i - 1][j], C[i - 1][j - 1]);\n\t\n\tdp[0][0] = 1;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint willAdd = 0;\n\t\twhile(cur < b[i])\n\t\t{\n\t\t\twillAdd += a[cur];\n\t\t\tcur++;\n\t\t}\n\t\tfor (int x = 0; x <= n; x++)\n\t\t{\n\t\t\tif (dp[i][x] == 0) continue;\n\t\t\tint y = x + willAdd;\n\t\t\tif (y != 0)\n\t\t\t\tdp[i + 1][y - 1] = add(dp[i + 1][y - 1], dp[i][x]);\n\t\t\tif (y != cur - i)\n\t\t\t\tdp[i + 1][y] = add(dp[i + 1][y], dp[i][x]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[n][0]);\n \n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nMOD = 10**9 + 7\n\nN,M = map(int,input().split())\nS = np.array(list(input().rstrip()),dtype='U1')\nLR = [[int(x) for x in input().split()] for _ in range(M)]\n\ncnt_0 = (S=='0').cumsum()\ncnt_1 = (S=='1').cumsum()\ncanuse_0 = cnt_0\ncanuse_1 = cnt_1\nfor L,R in LR:\n    canuse_0[L-1] = max(canuse_0[L-1],cnt_0[R-1])\n    canuse_1[L-1] = max(canuse_1[L-1],cnt_1[R-1])\nnp.maximum.accumulate(canuse_0,out=canuse_0)\nnp.maximum.accumulate(canuse_1,out=canuse_1)\n\n# 1を使った個数で\ndp = np.zeros(N+1,dtype=np.int64)\ndp[0] = 1\nfor i in range(N):\n    prev = dp\n    dp = np.zeros(N+1,dtype=np.int64)\n    # i番目を置いた後で、1の個数の範囲\n    left = max(0,(i+1)-canuse_0[i])\n    right = canuse_1[i]\n    # 0を使う\n    dp[left:right+1] += prev[left:right+1]\n    # 1を使う\n    left = max(1,left)\n    dp[left:right+1] += prev[left-1:right]\n    dp %= MOD\n\nanswer = dp.sum()\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\nM = 10 ** 9 + 7\n\n\ndef solve(n, m, s, lst):\n\n    cnt = [0] * n\n    t = 0\n    for i in range(n):\n        if s[i] == '1':\n            t += 1\n        cnt[i] = t\n\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    r = 0\n    j = 0\n    for i in range(n):\n        while j < m:\n            lj, rj = lst[j]\n            if lj <= i:\n                r = max(r, rj)\n                j += 1\n            else:\n                break\n        if r <= i:\n            c = cnt[i]\n            if 0 < c:\n                dp[i + 1][cnt[i]] = dp[i][c] + dp[i][c - 1]\n            else:\n                dp[i + 1][0] = dp[i][0]\n        else:\n            for k in range(max(0, cnt[r] - r + i), min(i + 1, cnt[r]) + 1):\n                if 0 < k:\n                    dp[i + 1][k] = dp[i][k] + dp[i][k - 1]\n                else:\n                    dp[i + 1][0] = dp[i][0]\n\n    return dp[n][cnt[n - 1]]\n\n\ndef main():\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    s = input()\n    lst = []\n    for _ in range(m):\n        l, r = input().split()\n        l = int(l) - 1\n        r = int(r) - 1\n        lst.append((l, r))\n\n    print(solve(n, m, s, lst))\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn main() {\n    let (n, m): (usize, usize) = read();\n    let s: Vec<u8> = read::<String>().into_bytes();\n    let lr: Vec<(usize, usize)> = readn(m);\n    let mut imos: Vec<usize> = vec![0; n+1];\n    for i in 0..n {\n        let c = if s[i] == '1' as u8 { 1 } else { 0 };\n        imos[i+1] = imos[i] + c;\n    }\n\n    let mut maxto: Vec<usize> = vec![0; n];\n    for &(fr, to) in &lr {\n        maxto[fr-1] = max(maxto[fr-1], to);\n    }\n\n    let mut dp: Vec<Vec<i64>> = vec![vec![0; n+1]; n+1];\n    dp[0][0] = 1;\n\n    let mut prev = vec![0; n+1];\n    let mut to = 0;\n    for i in 0..n {\n        to = max(to, i);\n        let mut h = 0;\n        if to < maxto[i] {\n            h += imos[maxto[i]] - imos[to];\n        }\n        to = max(to, maxto[i]);\n\n        for j in 0..n+1 {\n            if j >= h {\n                prev[j] = dp[i][j-h];\n            }  else {\n                prev[j] = 0;\n            }\n        }\n\n        let size = to - i;\n        if size == 0 {\n            for j in 0..n+1 {\n                dp[i+1][j] = dp[i][j];\n            }\n        } else {\n            for j in 0..n+1 {\n                let left_zero = size - j;\n                let left_one = j;\n                let base = prev[j];\n                if base >= 1 {\n                    if left_zero >= 1 {\n                        dp[i+1][j] += base;\n                        dp[i+1][j] %= MOD;\n                    }\n                    if left_one >= 1 {\n                        dp[i+1][j-1] += base;\n                        dp[i+1][j-1] %= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n+1 {\n        ans += dp[n][i];\n    }\n    println!(\"{}\", ans % MOD);\n}"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nuse std::io::Read;\nuse std::cmp::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let s: Vec<usize> = it.next().unwrap().chars().map(|c| c.to_digit(10).unwrap() as usize).collect();\n    let pc = Precalc::new(n);\n    let mut dp = vec![ModInt::zero(); n + 1];\n    dp[0] = ModInt::one();\n    let mut range = (0, 0);\n    for _ in 0..m {\n        let l = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let r = it.next().unwrap().parse::<usize>().unwrap();\n        if range.0 < l {\n            let mut next = vec![ModInt::zero(); n + 1];\n            let w = range.1 - range.0;\n            let d = min(range.1, l) - range.0;\n            for (i, v) in dp.into_iter().enumerate() {\n                for j in 0..(i + 1) {\n                    if j <= d && d + i <= w + j {\n                        next[i - j] += v * pc.comb(d, j);\n                    }\n                }\n            }\n            range.0 = l;\n            range.1 = max(range.1, range.0);\n            dp = next;\n        }\n        if r <= range.1 {\n            continue;\n        }\n        let mut cnt = 0;\n        for i in range.1..r {\n            cnt += s[i];\n        }\n        range.1 = r;\n        let mut next = vec![ModInt::zero(); n + 1];\n        for i in cnt..(n + 1) {\n            next[i] = dp[i - cnt];\n        }\n        dp = next;\n    }\n    let mut ans = ModInt::zero();\n    let w = range.1 - range.0;\n    for (i, v) in dp.into_iter().enumerate() {\n        ans += v * pc.comb(w, i);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nconst MOD: i64 = 1e9 as i64 + 7;\n\nfn main() {\n    let (n, m): (usize, usize) = read();\n    let s: Vec<u8> = read::<String>().into_bytes();\n    let lr: Vec<(usize, usize)> = readn(m);\n    let mut imos: Vec<usize> = vec![0; n+1];\n    for i in 0..n {\n        let c = if s[i] == '1' as u8 { 1 } else { 0 };\n        imos[i+1] = imos[i] + c;\n    }\n\n    let mut maxto: Vec<usize> = vec![0; n];\n    for &(fr, to) in &lr {\n        maxto[fr-1] = max(maxto[fr-1], to);\n    }\n\n    let mut dp: Vec<Vec<i64>> = vec![vec![0; n+1]; n+1];\n    dp[0][0] = 1;\n\n    let mut prev = vec![0; n+1];\n    let mut to = 0;\n    for i in 0..n {\n        let mut h = 0;\n        if to < maxto[i] {\n            h += imos[maxto[i]] - imos[to];\n        }\n        to = max(i, max(to, maxto[i]));\n\n        for j in 0..n+1 {\n            if j >= h {\n                prev[j] = dp[i][j-h];\n            }  else {\n                prev[j] = 0;\n            }\n        }\n\n        let size = to - i;\n        if size == 0 {\n            for j in 0..n+1 {\n                dp[i+1][j] = dp[i][j];\n            }\n        } else {\n            for j in 0..n+1 {\n                let left_zero = size - j;\n                let left_one = j;\n                let base = prev[j];\n                if base >= 1 {\n                    if left_zero >= 1 {\n                        dp[i+1][j] += base;\n                        dp[i+1][j] %= MOD;\n                    }\n                    if left_one >= 1 {\n                        dp[i+1][j-1] += base;\n                        dp[i+1][j-1] %= MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n+1 {\n        ans += dp[n][i];\n    }\n    println!(\"{}\", ans % MOD);\n}"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\nconst MOD: u32 = 1_000_000_007;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n// ---------- begin Precalc ----------\n#[allow(dead_code)]\nstruct Precalc {\n    inv: Vec<ModInt>,\n    fact: Vec<ModInt>,\n    ifact: Vec<ModInt>,\n}\n\n#[allow(dead_code)]\nimpl Precalc {\n    pub fn new(n: usize) -> Precalc {\n        let mut inv = vec![ModInt::one(); n + 1];\n        let mut fact = vec![ModInt::one(); n + 1];\n        let mut ifact = vec![ModInt::one(); n + 1];\n        for i in 2..(n + 1) {\n            inv[i] = -inv[MOD as usize % i] * ModInt(MOD / i as u32);\n            fact[i] = fact[i - 1] * ModInt(i as u32);\n            ifact[i] = ifact[i - 1] * inv[i];\n        }\n        Precalc {\n            inv: inv,\n            fact: fact,\n            ifact: ifact,\n        }\n    }\n    pub fn inv(&self, n: usize) -> ModInt {\n        self.inv[n]\n    }\n    pub fn fact(&self, n: usize) -> ModInt {\n        self.fact[n]\n    }\n    pub fn ifact(&self, n: usize) -> ModInt {\n        self.ifact[n]\n    }\n    pub fn comb(&self, n: usize, k: usize) -> ModInt {\n        if k > n {\n            return ModInt::zero();\n        }\n        self.fact[n] * self.ifact[k] * self.ifact[n - k]\n    }\n}\n// ---------- end Precalc ----------\n\nuse std::io::Read;\nuse std::cmp::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let s: Vec<usize> = it.next().unwrap().chars().map(|c| c.to_digit(10).unwrap() as usize).collect();\n    let pc = Precalc::new(n);\n    let mut dp = std::collections::BTreeMap::<usize, ModInt>::new();\n    dp.insert(0, ModInt::one());\n    let mut range = (0, 0);\n    for _ in 0..m {\n        let l = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let r = it.next().unwrap().parse::<usize>().unwrap();\n        if range.0 < l {\n            let mut next = std::collections::BTreeMap::<usize, ModInt>::new();\n            let w = range.1 - range.0;\n            let d = min(range.1, l) - range.0;\n            for (i, v) in dp.into_iter() {\n                for j in 0..(i + 1) {\n                    if j <= d && d + i <= w + j {\n                        *next.entry(i - j).or_insert(ModInt::zero()) += v * pc.comb(d, j);\n                    }\n                }\n            }\n            range.0 = l;\n            range.1 = max(range.1, range.0);\n            dp = next;\n        }\n        if r <= range.1 {\n            continue;\n        }\n        let mut cnt = 0;\n        for i in range.1..r {\n            cnt += s[i];\n        }\n        range.1 = r;\n        let mut next = std::collections::BTreeMap::<usize, ModInt>::new();\n        for (k, v) in dp.into_iter() {\n            *next.entry(k + cnt).or_insert(ModInt::zero()) += v;\n        }\n        dp = next;\n    }\n    let mut ans = ModInt::zero();\n    let w = range.1 - range.0;\n    for (k, v) in dp.into_iter() {\n        ans += v * pc.comb(w, k);\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules !read_value {($iter :expr ,($($t :tt ) ,*) ) =>{($(read_value !($iter ,$t ) ) ,*) } ;($iter :expr ,[$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |read_value !($iter ,$t ) ) .collect ::<Vec <_ >>() } ;($iter :expr ,{chars :$base :expr } ) =>{read_value !($iter ,String ) .chars () .map (|c |(c as u8 -$base as u8 ) as usize ) .collect ::<Vec <usize >>() } ;($iter :expr ,{char :$base :expr } ) =>{read_value !($iter ,{chars :$base } ) [0 ] } ;($iter :expr ,chars ) =>{read_value !($iter ,String ) .chars () .collect ::<Vec <char >>() } ;($iter :expr ,char ) =>{read_value !($iter ,chars ) [0 ] } ;($iter :expr ,usize1 ) =>{read_value !($iter ,usize ) -1 } ;($iter :expr ,$t :ty ) =>{$iter .next () .unwrap () .parse ::<$t >() .unwrap () } ;}\nmacro_rules !input_inner {($iter :expr ) =>{} ;($iter :expr ,) =>{} ;($iter :expr ,mut $var :ident :$t :tt $($r :tt ) *) =>{let mut $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,mut $var :ident $($r :tt ) *) =>{input_inner !{$iter ,mut $var :usize $($r ) *} } ;($iter :expr ,$var :ident :$t :tt $($r :tt ) *) =>{let $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,$var :ident $($r :tt ) *) =>{input_inner !{$iter ,$var :usize $($r ) *} } ;}\nmacro_rules !input {(source =$s :expr ,$($r :tt ) *) =>{let mut iter =$s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;(iter =$iter :ident ,$($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut $iter =s .split_whitespace () ;input_inner !{$iter ,$($r ) *} } ;($($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut iter =s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;}\nconst MOD: i64 = 1_000_000_007;\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Modi64(pub i64);\nimpl Modi64 {\n    #[inline]\n    pub fn new(i: i64) -> Self {\n        Modi64(Self::modulo(i, MOD))\n    }\n    #[inline]\n    pub fn modulo(i: i64, m: i64) -> i64 {\n        let mut x = i % m;\n        if x < 0 {\n            x += m;\n        }\n        x\n    }\n    pub fn pow(self, y: i64) -> Self {\n        let mut y = Self::modulo(y, MOD - 1);\n        let mut x = Self::new(1);\n        let mut base = self;\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= base;\n            }\n            base *= base;\n            y = y >> 1;\n        }\n        x\n    }\n    #[inline]\n    pub fn inv(self) -> Self {\n        let (mut x, mut s, mut t, mut u) = (1, self.0, MOD, 0);\n        while t != 0 {\n            let k = s / t;\n            s -= k * t;\n            std::mem::swap(&mut s, &mut t);\n            x -= k * u;\n            std::mem::swap(&mut x, &mut u);\n        }\n        Modi64::new(x)\n    }\n}\nimpl From<i64> for Modi64 {\n    fn from(i: i64) -> Self {\n        Self::new(i)\n    }\n}\nimpl std::ops::Add for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        Modi64((self.0 + rhs.0) % MOD)\n    }\n}\nimpl<'a> std::ops::Add<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Modi64) -> Self::Output {\n        *self + rhs\n    }\n}\nimpl<'a> std::ops::Add<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: &'a Modi64) -> Self::Output {\n        self + *rhs\n    }\n}\nimpl<'a> std::ops::Add for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        *self + *rhs\n    }\n}\nimpl std::ops::AddAssign for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\nimpl<'a> std::ops::AddAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: &'a Modi64) {\n        *self += *rhs;\n    }\n}\nimpl std::ops::Sub for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        Self::new(self.0 - rhs.0)\n    }\n}\nimpl<'a> std::ops::Sub<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Modi64) -> Self::Output {\n        *self - rhs\n    }\n}\nimpl<'a> std::ops::Sub<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: &'a Modi64) -> Self::Output {\n        self - *rhs\n    }\n}\nimpl<'a> std::ops::Sub for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        *self - *rhs\n    }\n}\nimpl std::ops::SubAssign for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\nimpl<'a> std::ops::SubAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: &'a Modi64) {\n        *self -= *rhs;\n    }\n}\nimpl std::ops::Mul for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        Modi64(self.0 * rhs.0 % MOD)\n    }\n}\nimpl<'a> std::ops::Mul<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Modi64) -> Self::Output {\n        *self * rhs\n    }\n}\nimpl<'a> std::ops::Mul<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: &'a Modi64) -> Self::Output {\n        self * *rhs\n    }\n}\nimpl<'a> std::ops::Mul for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        *self * *rhs\n    }\n}\nimpl std::ops::MulAssign for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\nimpl<'a> std::ops::MulAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: &'a Modi64) {\n        *self *= *rhs;\n    }\n}\nimpl std::ops::Div for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Modi64) -> Self::Output {\n        *self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: &'a Modi64) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        *self * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: Self) {\n        *self = *self * rhs.inv();\n    }\n}\nimpl<'a> std::ops::DivAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: &'a Modi64) {\n        *self *= rhs.inv();\n    }\n}\nimpl std::ops::Neg for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Self::new(-self.0)\n    }\n}\nimpl<'a> std::ops::Neg for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        -*self\n    }\n}\nimpl std::iter::Sum for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), std::ops::Add::add)\n    }\n}\nimpl<'a> std::iter::Sum<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), |x, &y| x + y)\n    }\n}\nimpl std::fmt::Display for Modi64 {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> Result<(), std::fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\nimpl std::str::FromStr for Modi64 {\n    type Err = std::num::ParseIntError;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.parse::<i64>().map(|i| Modi64::new(i))\n    }\n}\nfn main() {\n    use std::cmp::max;\n    input! { n, m, s: {chars:'0'}, lr: [(usize,usize); m] };\n    let mut t = vec![0];\n    t.extend(s.clone());\n    let mut h = (0..n + 1).collect::<Vec<_>>();\n    for &(l, r) in &lr {\n        h[l] = max(h[l], r);\n    }\n    for i in 1..n + 1 {\n        t[i] += t[i - 1];\n        h[i] = max(h[i], h[i - 1]);\n    }\n    let mut dp = vec![vec![Modi64(0); n + 1]; n + 1];\n    dp[0][0] = 1.into();\n    for i in 0..n {\n        let ni = i + 1;\n        for j in 0..n + 1 {\n            let d = dp[i][j];\n            let k = t[h[ni]] - t[h[i]] + j;\n            if 0 < k && k <= n + 1 {\n                dp[ni][k - 1] += d;\n            }\n            if h[ni] - i > k {\n                dp[ni][k] += d;\n            }\n        }\n    }\n    println!(\"{}\", dp[n][0]);\n}\n"
  }
]