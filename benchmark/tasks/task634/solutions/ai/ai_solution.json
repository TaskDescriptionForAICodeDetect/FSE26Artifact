[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_CITIES 1000\n\ntypedef struct {\n    int x, y;\n} City;\n\nint compare(const void *a, const void *b) {\n    City *cityA = (City *)a;\n    City *cityB = (City *)b;\n    if (cityA->x != cityB->x)\n        return cityA->x - cityB->x;\n    return cityA->y - cityB->y;\n}\n\nbool is_reachable(City *cities, int n, City src, City dest) {\n    return (src.x <= dest.x && src.y <= dest.y) || \n           (src.x >= dest.x && src.y >= dest.y);\n}\n\nint count_reachable_cities(City *cities, int n, int k) {\n    int count = 0;\n    City current = cities[k];\n\n    for (int i = 0; i < n; i++) {\n        if (is_reachable(cities, n, current, cities[i])) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int n;\n    City cities[MAX_CITIES];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &cities[i].x, &cities[i].y);\n    }\n\n    qsort(cities, n, sizeof(City), compare);\n\n    for (int k = 0; k < n; k++) {\n        printf(\"%d\\n\", count_reachable_cities(cities, n, k));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y, index;\n} City;\n\nint compare(const void *a, const void *b) {\n    City *cityA = (City *)a;\n    City *cityB = (City *)b;\n    if (cityA->x != cityB->x) {\n        return cityA->x - cityB->x;\n    }\n    return cityA->y - cityB->y;\n}\n\nvoid merge(City *cities, int *reach, int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    City L[n1], R[n2];\n    \n    for (int i = 0; i < n1; i++) {\n        L[i] = cities[left + i];\n    }\n    for (int j = 0; j < n2; j++) {\n        R[j] = cities[mid + 1 + j];\n    }\n    \n    int i = 0, j = 0, k = left;\n    int count = 0;\n    \n    while (i < n1 && j < n2) {\n        if (L[i].y <= R[j].y) {\n            cities[k] = L[i];\n            reach[L[i].index] += count;\n            i++;\n        } else {\n            cities[k] = R[j];\n            count++;\n            j++;\n        }\n        k++;\n    }\n    \n    while (i < n1) {\n        cities[k] = L[i];\n        reach[L[i].index] += count;\n        i++;\n        k++;\n    }\n    \n    while (j < n2) {\n        cities[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(City *cities, int *reach, int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        mergeSort(cities, reach, left, mid);\n        mergeSort(cities, reach, mid + 1, right);\n        merge(cities, reach, left, mid, right);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    City cities[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &cities[i].x, &cities[i].y);\n        cities[i].index = i;\n    }\n    \n    qsort(cities, N, sizeof(City), compare);\n    \n    int reach[N];\n    for (int i = 0; i < N; i++) {\n        reach[i] = 1;\n    }\n    \n    mergeSort(cities, reach, 0, N - 1);\n    \n    int result[N];\n    for (int i = 0; i < N; i++) {\n        result[cities[i].index] = reach[cities[i].index];\n    }\n    \n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", result[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct City {\n    int x, y, index;\n};\n\nbool compareX(const City &a, const City &b) {\n    return a.x < b.x;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<City> cities(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cities[i].x >> cities[i].y;\n        cities[i].index = i;\n    }\n\n    sort(cities.begin(), cities.end(), compareX);\n\n    vector<int> maxPrefix(N), minSuffix(N);\n    maxPrefix[0] = cities[0].y;\n    for (int i = 1; i < N; ++i) {\n        maxPrefix[i] = max(maxPrefix[i-1], cities[i].y);\n    }\n\n    minSuffix[N-1] = cities[N-1].y;\n    for (int i = N-2; i >= 0; --i) {\n        minSuffix[i] = min(minSuffix[i+1], cities[i].y);\n    }\n\n    vector<int> reachable(N, 1);\n    for (int i = 0; i < N; ++i) {\n        if (i > 0 && cities[i].y <= maxPrefix[i-1]) {\n            reachable[cities[i].index] += reachable[cities[i-1].index];\n        }\n    }\n\n    for (int i = N-2; i >= 0; --i) {\n        if (cities[i].y >= minSuffix[i+1]) {\n            reachable[cities[i].index] += reachable[cities[i+1].index];\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cout << reachable[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass City {\n    int x, y, index;\n\n    City(int x, int y, int index) {\n        this.x = x;\n        this.y = y;\n        this.index = index;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        City[] cities = new City[N];\n        for (int i = 0; i < N; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            cities[i] = new City(x, y, i);\n        }\n\n        Arrays.sort(cities, (a, b) -> {\n            if (a.x != b.x) {\n                return Integer.compare(a.x, b.x);\n            } else {\n                return Integer.compare(a.y, b.y);\n            }\n        });\n\n        int[] result = new int[N];\n        Stack<City> stack = new Stack<>();\n        for (City city : cities) {\n            while (!stack.isEmpty() && stack.peek().y <= city.y) {\n                stack.pop();\n            }\n            int count = stack.size() + 1;\n            result[city.index] = count;\n            stack.push(city);\n        }\n\n        for (int i = 0; i < N; i++) {\n            System.out.println(result[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:24:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ReachableCities {\n    public static int[] countReachableCities(int[][] cities) {\n        int n = cities.length;\n        int[] result = new int[n];\n        \n        // Sort cities by coordinates\n        Arrays.sort(cities, (a, b) -> {\n            if (a[0] != b[0]) return Integer.compare(a[0], b[0]);\n            return Integer.compare(a[1], b[1]);\n        });\n        \n        for (int i = 0; i < n; i++) {\n            int count = 1;\n            \n            // Check lower left\n            for (int j = 0; j < i; j++) {\n                if (cities[j][0] <= cities[i][0] && cities[j][1] <= cities[i][1]) {\n                    count++;\n                }\n            }\n            \n            // Check upper right\n            for (int j = i + 1; j < n; j++) {\n                if (cities[j][0] >= cities[i][0] && cities[j][1] >= cities[i][1]) {\n                    count++;\n                }\n            }\n            \n            result[i] = count;\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        int[][] cities = {{1,1}, {2,2}, {3,3}, {4,4}};\n        int[] reachable = countReachableCities(cities);\n        \n        for (int count : reachable) {\n            System.out.println(count);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:24:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<pair<int, int>> cities(N);\n    for (int i = 0; i < N; i++) {\n        cin >> cities[i].first >> cities[i].second;\n    }\n    \n    vector<int> reachable(N, 1);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            \n            if ((cities[j].first <= cities[i].first && cities[j].second <= cities[i].second) ||\n                (cities[j].first >= cities[i].first && cities[j].second >= cities[i].second)) {\n                reachable[i]++;\n            }\n        }\n    }\n    \n    for (int count : reachable) {\n        cout << count - 1 << \" \";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:24:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def reachable_cities(cities):\n    def can_reach(city1, city2):\n        return (city2[0] < city1[0] and city2[1] < city1[1]) or (city2[0] > city1[0] and city2[1] > city1[1])\n\n    result = []\n    for k in range(len(cities)):\n        count = 0\n        for m in range(len(cities)):\n            if can_reach(cities[k], cities[m]) or k == m:\n                count += 1\n        result.append(count)\n    return result\n\n# Example usage:\ncities = [(1, 3), (3, 2), (4, 5), (0, 1)]\nprint(reachable_cities(cities))",
    "timestamp": "2025-08-13 10:24:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass City {\n    int x, y;\n    public City(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class ReachableCities {\n\n    public int[] countReachableCities(int[][] coordinates) {\n        int n = coordinates.length;\n        City[] cities = new City[n];\n        for (int i = 0; i < n; i++) {\n            cities[i] = new City(coordinates[i][0], coordinates[i][1]);\n        }\n\n        int[] result = new int[n];\n        Arrays.fill(result, 1); // Each city can at least reach itself\n\n        for (int i = 0; i < n; i++) {\n            City ci = cities[i];\n            for (int j = 0; j < n; j++) {\n                if (j == i) continue;\n                City cj = cities[j];\n                if ((ci.x <= cj.x && ci.y <= cj.y) || (ci.x >= cj.x && ci.y >= cj.y)) {\n                    result[i]++;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        ReachableCities solution = new ReachableCities();\n        int[][] coordinates = {{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}};\n        int[] result = solution.countReachableCities(coordinates);\n        System.out.println(Arrays.toString(result));\n    }\n}",
    "timestamp": "2025-08-13 10:24:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Struct for storing city coordinates\ntypedef struct City {\n    int x, y;\n} City;\n\n// Comparison function for sorting cities\nint compareCities(const void* a, const void* b) {\n    City* cityA = (City*)a;\n    City* cityB = (City*)b;\n\n    if (cityA->x == cityB->x) {\n        return cityA->y - cityB->y;\n    } else {\n        return cityA->x - cityB->x;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    City cities[N];\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &cities[i].x, &cities[i].y);\n    }\n\n    // Sort cities\n    qsort(cities, N, sizeof(City), compareCities);\n\n    int reachable[N];\n\n    // Calculate reachable cities for each city\n    for (int i = 0; i < N; i++) {\n        reachable[i] = 1; // Count the city itself\n        for (int j = 0; j < N; j++) {\n            if (i != j) {\n                if ((cities[j].x <= cities[i].x && cities[j].y <= cities[i].y) ||\n                    (cities[j].x >= cities[i].x && cities[j].y >= cities[i].y)) {\n                    reachable[i]++;\n                }\n            }\n        }\n    }\n\n    // Output the results\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", reachable[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:24:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def countReachableCities(coordinates):\n    N = len(coordinates)\n    coordinates.sort()\n    \n    dp = [1] * N\n    \n    for i in range(1, N):\n        for j in range(i):\n            if (coordinates[i][0] > coordinates[j][0] and \n                coordinates[i][1] > coordinates[j][1]):\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# Example usage\ncoordinates = [(1,1), (2,2), (3,3), (0,4), (4,0)]\nprint(countReachableCities(coordinates))",
    "timestamp": "2025-08-13 10:24:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom bisect import bisect_right\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    cities = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        cities.append((x, y))\n    \n    # Sort cities by x, then y\n    cities_sorted = sorted(cities)\n    x_coords = [x for x, y in cities_sorted]\n    y_coords = [y for x, y in cities_sorted]\n    \n    # Coordinate compression for y\n    unique_y = sorted(set(y_coords))\n    y_rank = {v: i+1 for i, v in enumerate(unique_y)}\n    \n    # Fenwick Tree for dynamic queries\n    class FenwickTree:\n        def __init__(self, size):\n            self.size = size\n            self.tree = [0] * (self.size + 2)\n        \n        def update(self, idx, delta=1):\n            while idx <= self.size:\n                self.tree[idx] += delta\n                idx += idx & -idx\n        \n        def query(self, idx):\n            res = 0\n            while idx > 0:\n                res += self.tree[idx]\n                idx -= idx & -idx\n            return res\n    \n    max_rank = len(unique_y)\n    ft = FenwickTree(max_rank)\n    \n    # Process cities in order of increasing x and decreasing y to handle lower left\n    # For upper right, process in order of increasing x and increasing y\n    # We need to process in two passes\n    \n    # First pass: lower left (x increasing, y decreasing)\n    cities_lower_left = sorted(cities, key=lambda c: (c[0], -c[1]))\n    res_lower_left = [0] * N\n    ft_lower = FenwickTree(max_rank)\n    \n    for i in range(N):\n        x, y = cities_lower_left[i]\n        rank = y_rank[y]\n        # Query number of elements with y >= current y (since sorted in decreasing order)\n        count = ft_lower.query(rank)\n        res_lower_left[i] = count + 1  # including itself\n        ft_lower.update(rank, 1)\n    \n    # Second pass: upper right (x increasing, y increasing)\n    cities_upper_right = sorted(cities, key=lambda c: (c[0], c[1]))\n    res_upper_right = [0] * N\n    ft_upper = FenwickTree(max_rank)\n    \n    for i in range(N):\n        x, y = cities_upper_right[i]\n        rank = y_rank[y]\n        # Query number of elements with y <= current y\n        count = ft_upper.query(rank)\n        res_upper_right[i] = count + 1  # including itself\n        ft_upper.update(rank, 1)\n    \n    # Combine results\n    city_to_index = {city: i for i, city in enumerate(cities)}\n    final_res = [0] * N\n    \n    for i in range(N):\n        city = cities_lower_left[i]\n        idx = city_to_index[city]\n        final_res[idx] = res_lower_left[i]\n    \n    for i in range(N):\n        city = cities_upper_right[i]\n        idx = city_to_index[city]\n        final_res[idx] += res_upper_right[i] - 1  # avoid double counting itself\n    \n    for num in final_res:\n        print(num)\n\nsolve()",
    "timestamp": "2025-08-13 10:25:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct City {\n    int x, y;\n    int index;\n};\n\n// Custom comparator to sort Cities based on x, and if equal, then on y\nbool compareCities(const City& a, const City& b) {\n    if (a.x == b.x)\n        return a.y < b.y;\n    return a.x < b.x;\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<City> cities(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cities[i].x >> cities[i].y;\n        cities[i].index = i;\n    }\n\n    // Sort cities based on x, and then y to perform a modified sweep line method\n    sort(cities.begin(), cities.end(), compareCities);\n\n    // Fenwick Tree (or BIT) to count reachable cities\n    vector<int> fenwickTree(N + 1, 0);\n\n    // Function to update Fenwick Tree\n    auto update = [&](int pos, int value) {\n        for (; pos <= N; pos += pos & -pos)\n            fenwickTree[pos] += value;\n    };\n\n    // Function to get sum from Fenwick Tree\n    auto sum = [&](int pos) {\n        int result = 0;\n        for (; pos > 0; pos -= pos & -pos)\n            result += fenwickTree[pos];\n        return result;\n    };\n    \n    // To store results\n    vector<int> reachable(N);\n\n    // Coordinate compression map\n    vector<int> compressedY(N);\n    for (int i = 0; i < N; ++i) {\n        compressedY[i] = cities[i].y;\n    }\n    sort(compressedY.begin(), compressedY.end());\n    compressedY.erase(unique(compressedY.begin(), compressedY.end()), compressedY.end());\n\n    auto getCompressedY = [&](int y) {\n        return lower_bound(compressedY.begin(), compressedY.end(), y) - compressedY.begin() + 1;\n    };\n\n    for (int i = 0; i < N; ++i) {\n        int cy = getCompressedY(cities[i].y);\n        reachable[cities[i].index] = sum(cy);\n        update(cy, 1);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        cout << reachable[i] + 1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:58:52"
  }
]