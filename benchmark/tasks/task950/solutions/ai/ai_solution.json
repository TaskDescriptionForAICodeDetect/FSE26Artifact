[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MOD 1000000007\n\nlong long modPow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp & 1) result = (result * base) % mod;\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n    return result;\n}\n\nlong long countDivisors(int N) {\n    long long divisors = 1;\n    int primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    int primeCount = sizeof(primes) / sizeof(primes[0]);\n\n    for (int i = 0; i < primeCount; i++) {\n        if (primes[i] > N) break;\n        long long totalExp = 0;\n        \n        for (int j = 1; primes[i] <= N; j++) {\n            totalExp += N / (int)pow(primes[i], j);\n        }\n        \n        divisors = (divisors * (totalExp + 1)) % MOD;\n    }\n\n    return divisors;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    printf(\"%lld\\n\", countDivisors(N));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MOD 1000000007\n#define MAX_N 1000000\n\nbool is_prime[MAX_N + 1];\nint primes[MAX_N], prime_count = 0;\n\nvoid sieve() {\n    for (int i = 2; i <= MAX_N; i++) {\n        is_prime[i] = true;\n    }\n    for (int i = 2; i * i <= MAX_N; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= MAX_N; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    for (int i = 2; i <= MAX_N; i++) {\n        if (is_prime[i]) {\n            primes[prime_count++] = i;\n        }\n    }\n}\n\nint count_powers(int n, int p) {\n    int count = 0;\n    while (n > 0) {\n        n /= p;\n        count += n;\n    }\n    return count;\n}\n\nint main() {\n    sieve();\n    int N;\n    scanf(\"%d\", &N);\n    long long result = 1;\n    for (int i = 0; i < prime_count && primes[i] <= N; i++) {\n        int p = primes[i];\n        int exponent = count_powers(N, p);\n        result = (result * (exponent + 1)) % MOD;\n    }\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<int> sieve(int n) {\n    vector<bool> is_prime(n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int p = 2; p * p <= n; ++p) {\n        if (is_prime[p]) {\n            for (int i = p * p; i <= n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n    vector<int> primes;\n    for (int p = 2; p <= n; ++p) {\n        if (is_prime[p]) {\n            primes.push_back(p);\n        }\n    }\n    return primes;\n}\n\nint count_exponents(int n, int p) {\n    int count = 0;\n    while (n > 0) {\n        n /= p;\n        count += n;\n    }\n    return count;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    if (N == 0) {\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<int> primes = sieve(N);\n    long long result = 1;\n    for (int p : primes) {\n        int exp = count_exponents(N, p);\n        result = (result * (exp + 1)) % MOD;\n    }\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        if (N == 0 || N == 1) {\n            System.out.println(1);\n            return;\n        }\n        boolean[] isPrime = new boolean[N + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n        for (int i = 2; i * i <= N; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= N; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        long result = 1;\n        for (int p = 2; p <= N; p++) {\n            if (isPrime[p]) {\n                int exponent = 0;\n                int current = p;\n                while (current <= N) {\n                    exponent += N / current;\n                    current *= p;\n                }\n                result = (result * (exponent + 1)) % MOD;\n            }\n        }\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:28:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n\n    public static int countDivisors(int N) {\n        long[] primeFactors = new long[N + 1];\n        \n        for (int i = 2; i <= N; i++) {\n            int num = i;\n            for (int j = 2; j * j <= num; j++) {\n                while (num % j == 0) {\n                    primeFactors[j]++;\n                    num /= j;\n                }\n            }\n            if (num > 1) {\n                primeFactors[num]++;\n            }\n        }\n        \n        long divisors = 1;\n        for (int i = 2; i <= N; i++) {\n            if (primeFactors[i] > 0) {\n                divisors = (divisors * (primeFactors[i] + 1)) % MOD;\n            }\n        }\n        \n        return (int) divisors;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        System.out.println(countDivisors(N));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:28:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvector<int> getPrimes(int n) {\n    vector<bool> isPrime(n + 1, true);\n    vector<int> primes;\n    \n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= n; i++) {\n        if (isPrime[i]) {\n            primes.push_back(i);\n            for (int j = i * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\nlong long countDivisors(int N) {\n    vector<int> primes = getPrimes(N);\n    vector<long long> primeFactors(N + 1, 0);\n    \n    for (int prime : primes) {\n        long long p = prime;\n        while (p <= N) {\n            for (int n = p; n <= N; n += p) {\n                int num = n;\n                while (num % prime == 0) {\n                    primeFactors[prime]++;\n                    num /= prime;\n                }\n            }\n            p *= prime;\n        }\n    }\n    \n    long long divisors = 1;\n    for (int i = 2; i <= N; i++) {\n        if (primeFactors[i] > 0) {\n            divisors = (divisors * (primeFactors[i] + 1)) % MOD;\n        }\n    }\n    \n    return divisors;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    cout << countDivisors(N) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def prime_sieve(limit):\n    is_prime = [True] * (limit + 1)\n    p = 2\n    while (p * p <= limit):\n        if is_prime[p] == True:\n            for i in range(p * p, limit + 1, p):\n                is_prime[i] = False\n        p += 1\n    primes = [p for p in range(2, limit + 1) if is_prime[p]]\n    return primes\n\ndef count_divisors_factorial(n):\n    MOD = 10**9 + 7\n    primes = prime_sieve(n)\n    divisors = 1\n    \n    # Count p^e for each prime p <= n, where e is the exponent of p in the factorization of N!\n    for p in primes:\n        e = 0\n        power = p\n        while power <= n:\n            e += n // power\n            power *= p\n        divisors = divisors * (e + 1) % MOD\n    \n    return divisors\n\n# Example usage:\nN = int(input())\nprint(count_divisors_factorial(N))",
    "timestamp": "2025-08-13 15:23:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class FactorialDivisors {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.close();\n        \n        long result = findNumberOfDivisors(N);\n        System.out.println(result);\n    }\n\n    private static long findNumberOfDivisors(int N) {\n        long[] primeCount = new long[N + 1];\n\n        // Use Sieve of Eratosthenes to count prime occurrences in factorials\n        for (int i = 2; i <= N; i++) {\n            if (primeCount[i] == 0) {  // means i is a prime\n                for (int j = i; j <= N; j += i) {\n                    primeCount[j]++;\n                }\n            }\n        }\n\n        // Calculate the number of divisors using prime factor exp\n        long divisors = 1;\n        for (int i = 2; i <= N; i++) {\n            if (primeCount[i] > 0) {\n                long count = 0;\n                long power = i;\n                while (power <= N) {\n                    count += N / power;\n                    power *= i;\n                }\n                divisors = divisors * (count + 1) % MOD;\n            }\n        }\n\n        return divisors;\n    }\n}",
    "timestamp": "2025-08-13 15:23:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long count_divisors_of_factorial(int N) {\n    int prime_count[N+1];\n    for (int i = 0; i <= N; i++) {\n        prime_count[i] = 0;\n    }\n\n    for (int i = 2; i <= N; i++) {\n        int x = i;\n        for (int j = 2; j * j <= x; j++) {\n            while (x % j == 0) {\n                prime_count[j]++;\n                x /= j;\n            }\n        }\n        if (x > 1) {\n            prime_count[x]++;\n        }\n    }\n\n    long long divisors = 1;\n    for (int i = 2; i <= N; i++) {\n        if (prime_count[i] > 0) {\n            divisors = (divisors * (prime_count[i] + 1)) % MOD;\n        }\n    }\n\n    return divisors;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    printf(\"%lld\\n\", count_divisors_of_factorial(N));\n    return 0;\n}",
    "timestamp": "2025-08-13 15:23:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\n\n// Function to calculate power with modulo\nlong long power(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Function to sieve primes\nstd::vector<int> sieve(int maxLimit) {\n    std::vector<bool> is_prime(maxLimit + 1, true);\n    std::vector<int> primes;\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= maxLimit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            for (int j = 2 * i; j <= maxLimit; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    return primes;\n}\n\n// Function to calculate number of divisors of N!\nint divisors_of_factorial(int N) {\n    if (N == 0 || N == 1) return 1;\n\n    std::vector<int> primes = sieve(N);\n    long long divisor_count = 1;\n\n    for (int prime : primes) {\n        long long exp = 0;\n        long long p = prime;\n        while (p <= N) {\n            exp += N / p;\n            if (p > N / prime) break;  // Avoid overflow for large values\n            p *= prime;\n        }\n        divisor_count = (divisor_count * (exp + 1)) % MOD;\n    }\n\n    return divisor_count;\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::cout << divisors_of_factorial(N) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 15:23:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_divisors_of_factorial(N):\n    MOD = 10**9 + 7\n    \n    # Count prime factors of numbers from 1 to N\n    prime_factors = {}\n    for i in range(2, N + 1):\n        num = i\n        for j in range(2, int(num**0.5) + 1):\n            while num % j == 0:\n                prime_factors[j] = prime_factors.get(j, 0) + 1\n                num //= j\n        if num > 1:\n            prime_factors[num] = prime_factors.get(num, 0) + 1\n    \n    # Calculate number of divisors\n    divisors = 1\n    for count in prime_factors.values():\n        divisors = (divisors * (count + 1)) % MOD\n    \n    return divisors",
    "timestamp": "2025-08-13 15:23:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef sieve(n):\n    sieve = [True] * (n + 1)\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if sieve[i]:\n            for j in range(i*i, n+1, i):\n                sieve[j] = False\n    primes = [i for i, is_prime in enumerate(sieve) if is_prime]\n    return primes\n\ndef count_p_in_factorial(p, n):\n    count = 0\n    while n > 0:\n        n = n // p\n        count += n\n    return count\n\ndef solve():\n    N = int(sys.stdin.readline())\n    if N == 0 or N == 1:\n        print(1)\n        return\n    primes = sieve(N)\n    result = 1\n    for p in primes:\n        exponent = count_p_in_factorial(p, N)\n        result = (result * (exponent + 1)) % MOD\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 15:23:45"
  }
]