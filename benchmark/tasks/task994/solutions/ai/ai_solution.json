[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint is_good_string(char* s) {\n    int len = strlen(s);\n    for (int k = 2; k <= len; k++) {\n        if (len % k == 0) {\n            int segment_len = len / k;\n            int is_repeated = 1;\n            for (int j = 1; j < k; j++) {\n                if (strncmp(s, s + j * segment_len, segment_len) != 0) {\n                    is_repeated = 0;\n                    break;\n                }\n            }\n            if (is_repeated) return 0;\n        }\n    }\n    return 1;\n}\n\nint count_best_representations(char* w) {\n    int w_len = strlen(w);\n    int min_elements = w_len;\n    int count_min_elements = 0;\n\n    for (int i = 1; i <= w_len; i++) {\n        if (w_len % i == 0) {\n            char* substring = malloc(i + 1);\n            strncpy(substring, w, i);\n            substring[i] = '\\0';\n\n            if (is_good_string(substring)) {\n                int repetitions = w_len / i;\n                int is_valid = 1;\n                for (int j = 1; j < repetitions; j++) {\n                    if (strncmp(substring, w + j * i, i) != 0) {\n                        is_valid = 0;\n                        break;\n                    }\n                }\n\n                if (is_valid) {\n                    if (repetitions < min_elements) {\n                        min_elements = repetitions;\n                        count_min_elements = 1;\n                    } else if (repetitions == min_elements) {\n                        count_min_elements++;\n                    }\n                }\n            }\n            free(substring);\n        }\n    }\n\n    return count_min_elements;\n}\n\nint main() {\n    char w[1001];\n    scanf(\"%s\", w);\n    \n    int elements = strlen(w);\n    int distinct_representations = count_best_representations(w);\n    \n    printf(\"%d %d\\n\", elements, distinct_representations);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nint is_good(const char *s, int len) {\n    for (int d = 1; d <= len / 2; d++) {\n        if (len % d != 0) continue;\n        int k = len / d;\n        if (k < 2) continue;\n        int ok = 1;\n        for (int i = 0; i < d; i++) {\n            for (int j = 1; j < k; j++) {\n                if (s[i] != s[i + j * d]) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (!ok) break;\n        }\n        if (ok) return 0;\n    }\n    return 1;\n}\n\nvoid solve(const char *w) {\n    int n = strlen(w);\n    int *dp_elements = (int *)malloc((n + 1) * sizeof(int));\n    int *dp_ways = (int *)malloc((n + 1) * sizeof(int));\n    \n    for (int i = 0; i <= n; i++) {\n        dp_elements[i] = n + 1;\n        dp_ways[i] = 0;\n    }\n    \n    dp_elements[0] = 0;\n    dp_ways[0] = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            int len = i - j;\n            if (is_good(w + j, len)) {\n                if (dp_elements[j] + 1 < dp_elements[i]) {\n                    dp_elements[i] = dp_elements[j] + 1;\n                    dp_ways[i] = dp_ways[j];\n                } else if (dp_elements[j] + 1 == dp_elements[i]) {\n                    dp_ways[i] = (dp_ways[i] + dp_ways[j]) % MOD;\n                }\n            }\n        }\n    }\n    \n    printf(\"%d %d\\n\", dp_elements[n], dp_ways[n]);\n    free(dp_elements);\n    free(dp_ways);\n}\n\nint main() {\n    char w[1001];\n    scanf(\"%1000s\", w);\n    solve(w);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <string>\n\nusing namespace std;\n\nbool isGood(const string &s) {\n    int n = s.size();\n    for (int len = 1; len <= n / 2; ++len) {\n        if (n % len != 0) continue;\n        bool ok = true;\n        for (int i = 0; i < n; ++i) {\n            if (s[i] != s[i % len]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solve(const string &w, int pos, vector<string> &current, unordered_set<string> &seen, int &min_len, int &count) {\n    if (pos == w.size()) {\n        if (current.size() < min_len) {\n            min_len = current.size();\n            count = 1;\n        } else if (current.size() == min_len) {\n            ++count;\n        }\n        seen.insert(current.begin(), current.end());\n        return;\n    }\n    for (int end = pos + 1; end <= w.size(); ++end) {\n        string sub = w.substr(pos, end - pos);\n        if (isGood(sub)) {\n            current.push_back(sub);\n            solve(w, end, current, seen, min_len, count);\n            current.pop_back();\n        }\n    }\n}\n\nint main() {\n    string w;\n    cin >> w;\n    int min_len = w.size() + 1;\n    int count = 0;\n    unordered_set<string> seen;\n    vector<string> current;\n    solve(w, 0, current, seen, min_len, count);\n    cout << min_len << \" \" << count << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GoodRepresentation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String w = scanner.next();\n        int n = w.length();\n        int[] dp = new int[n + 1];\n        int[] ways = new int[n + 1];\n        dp[0] = 0;\n        ways[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n            for (int j = 0; j < i; j++) {\n                String s = w.substring(j, i);\n                if (isGood(s)) {\n                    if (dp[j] + 1 < dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        ways[i] = ways[j];\n                    } else if (dp[j] + 1 == dp[i]) {\n                        ways[i] += ways[j];\n                    }\n                }\n            }\n        }\n        \n        System.out.println(dp[n] + \" \" + ways[n]);\n    }\n    \n    private static boolean isGood(String s) {\n        int n = s.length();\n        for (int len = 1; len <= n / 2; len++) {\n            if (n % len == 0) {\n                boolean isPeriodic = true;\n                for (int i = len; i < n; i++) {\n                    if (s.charAt(i) != s.charAt(i % len)) {\n                        isPeriodic = false;\n                        break;\n                    }\n                }\n                if (isPeriodic) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:37:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int[] bestRepresentation(String w) {\n        int n = w.length();\n        int[] dp = new int[n + 1];\n        int[] ways = new int[n + 1];\n        \n        dp[0] = 0;\n        ways[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            dp[i] = i;\n            ways[i] = 1;\n            \n            for (int j = 1; j < i; j++) {\n                if (isGoodString(w.substring(i - j, i))) {\n                    int candidate = dp[i - j] + 1;\n                    if (candidate < dp[i]) {\n                        dp[i] = candidate;\n                        ways[i] = ways[i - j];\n                    } else if (candidate == dp[i]) {\n                        ways[i] += ways[i - j];\n                    }\n                }\n            }\n        }\n        \n        return new int[]{dp[n], ways[n]};\n    }\n    \n    private static boolean isGoodString(String s) {\n        if (s.isEmpty()) return false;\n        \n        for (int k = 2; k <= s.length(); k++) {\n            if (s.length() % k == 0) {\n                boolean isRepeated = true;\n                String pattern = s.substring(0, s.length() / k);\n                \n                for (int i = 0; i < k; i++) {\n                    if (!s.substring(i * pattern.length(), (i + 1) * pattern.length()).equals(pattern)) {\n                        isRepeated = false;\n                        break;\n                    }\n                }\n                \n                if (isRepeated) return false;\n            }\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:37:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nbool is_good_string(const string& s) {\n    int n = s.length();\n    for (int k = 2; k * k <= n; k++) {\n        if (n % k == 0) {\n            string rep = s.substr(0, n / k);\n            bool is_repeated = true;\n            for (int i = 0; i < k; i++) {\n                if (s.substr(i * (n / k), n / k) != rep) {\n                    is_repeated = false;\n                    break;\n                }\n            }\n            if (is_repeated) return false;\n        }\n    }\n    return true;\n}\n\npair<int, int> solve(const string& w) {\n    int n = w.length();\n    vector<int> dp(n + 1, INT_MAX);\n    vector<int> ways(n + 1, 0);\n    \n    dp[0] = 0;\n    ways[0] = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            string substring = w.substr(j, i - j);\n            if (is_good_string(substring)) {\n                if (dp[j] + 1 < dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    ways[i] = ways[j];\n                } else if (dp[j] + 1 == dp[i]) {\n                    ways[i] += ways[j];\n                }\n            }\n        }\n    }\n    \n    return {dp[n], ways[n]};\n}\n\nint main() {\n    string w;\n    cin >> w;\n    \n    auto [best_rep_count, distinct_rep_count] = solve(w);\n    \n    cout << best_rep_count << \" \" << distinct_rep_count << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_good_string(s):\n    return all(s != s[:i] * (len(s) // i) for i in range(1, len(s)//2 + 1))\n\ndef find_best_representation(w):\n    n = len(w)\n    prefix_good = [0] * (n + 1)\n    prefix_good[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if is_good_string(w[j:i]):\n                prefix_good[i] += prefix_good[j]\n\n    distinct_representations = set()\n    def backtrack(end, current):\n        if end == 0:\n            distinct_representations.add(tuple(current))\n            return\n        for start in range(end):\n            if is_good_string(w[start:end]):\n                backtrack(start, [w[start:end]] + current)\n\n    backtrack(n, [])\n    \n    return prefix_good[n], len(distinct_representations)\n\n# Example usage:\nw = \"ababa\"\nprint(find_best_representation(w))",
    "timestamp": "2025-08-13 16:25:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class GoodStringRepresentation {\n   \n    public static void main(String[] args) {\n        String input = \"abac\";\n        int[] result = findBestRepresentation(input);\n        System.out.println(\"Number of elements: \" + result[0]);\n        System.out.println(\"Number of distinct representations: \" + result[1]);\n    }\n\n    public static int[] findBestRepresentation(String w) {\n        int n = w.length();\n        int minSize = n; // At worst, all individual characters are good strings\n        Set<String> goodRepresentations = new HashSet<>();\n        \n        for (int size = 1; size <= n; size++) {\n            Set<String> currentGoodStrings = new HashSet<>();\n            boolean[] isGood = new boolean[n / size];\n            \n            for (int start = 0; start + size <= n; start += size) {\n                String candidate = w.substring(start, start + size);\n                if (!isRepeat(candidate)) {\n                    currentGoodStrings.add(candidate);\n                }\n            }\n            \n            if (currentGoodStrings.size() == n / size) {\n                minSize = Math.min(minSize, n / size);\n                goodRepresentations.add(String.join(\"-\", currentGoodStrings));\n            }\n        }\n        \n        return new int[]{minSize, goodRepresentations.size()};\n    }\n\n    private static boolean isRepeat(String s) {\n        int len = s.length();\n        for (int size = 1; size <= len / 2; size++) {\n            if (len % size == 0) {\n                String repeated = s.substring(0, size);\n                StringBuilder builder = new StringBuilder();\n                for (int i = 0; i < len / size; i++) {\n                    builder.append(repeated);\n                }\n                if (builder.toString().equals(s)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 16:25:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint isGoodString(const char *str, int len) {\n    for (int i = 1; i <= len / 2; i++) {\n        if (len % i == 0) {\n            int isRepeat = 1;\n            for (int j = i; j < len; j++) {\n                if (str[j] != str[j % i]) {\n                    isRepeat = 0;\n                    break;\n                }\n            }\n            if (isRepeat) return 0;\n        }\n    }\n    return 1;\n}\n\nvoid findBestRepresentations(const char *str, int length, int *minElements, int *distinctCounts) {\n    int i, j;\n    int dp[length + 1];\n    int distinct[length + 1];\n    memset(dp, 0, sizeof(dp));\n    memset(distinct, 0, sizeof(distinct));\n\n    dp[0] = 0;\n    distinct[0] = 1;\n\n    for (i = 1; i <= length; i++) {\n        dp[i] = i;\n        distinct[i] = 0;\n        for (j = 0; j < i; j++) {\n            if (isGoodString(&str[j], i - j)) {\n                if (dp[j] + 1 < dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    distinct[i] = distinct[j];\n                } else if (dp[j] + 1 == dp[i]) {\n                    distinct[i] += distinct[j];\n                }\n            }\n        }\n    }\n    *minElements = dp[length];\n    *distinctCounts = distinct[length];\n}\n\nint main() {\n    char w[] = \"abcabcabc\";\n    \n    int minElements, distinctCounts;\n    findBestRepresentations(w, strlen(w), &minElements, &distinctCounts);\n\n    printf(\"Minimum Elements: %d\\n\", minElements);\n    printf(\"Distinct Best Representations: %d\\n\", distinctCounts);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:25:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nbool isGoodString(const string& str) {\n    int len = str.length();\n    for (int i = 1; i <= len / 2; ++i) {\n        if (len % i == 0) {\n            string sub = str.substr(0, i);\n            bool isRepeated = true;\n            for (int j = i; j < len; j += i) {\n                if (str.substr(j, i) != sub) {\n                    isRepeated = false;\n                    break;\n                }\n            }\n            if (isRepeated) return false;\n        }\n    }\n    return true;\n}\n\nvector<vector<string>> getGoodRepresentations(const string& w) {\n    vector<vector<string>> representations;\n    int n = w.length();\n\n    function<void(int, vector<string>&)> dfs = [&](int index, vector<string>& current) {\n        if (index == n) {\n            representations.push_back(current);\n            return;\n        }\n        for (int i = index; i < n; ++i) {\n            string sub = w.substr(index, i - index + 1);\n            if (isGoodString(sub)) {\n                current.push_back(sub);\n                dfs(i + 1, current);\n                current.pop_back();\n            }\n        }\n    };\n\n    vector<string> current;\n    dfs(0, current);\n    return representations;\n}\n\nint main() {\n    string w;\n    cin >> w;\n\n    vector<vector<string>> representations = getGoodRepresentations(w);\n\n    unordered_set<string> uniqueRepresentations;\n    for (const auto& rep : representations) {\n        string concat;\n        for (const auto& s : rep) {\n            concat += s + \"#\";\n        }\n        uniqueRepresentations.insert(concat);\n    }\n\n    int minLength = INT_MAX;\n    for (const auto& rep : representations) {\n        minLength = min(minLength, static_cast<int>(rep.size()));\n    }\n\n    cout << minLength << \" \" << uniqueRepresentations.size() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:25:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(w):\n    n = len(w)\n    dp = [float('inf')] * (n + 1)\n    count = [0] * (n + 1)\n    dp[0] = 0\n    count[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            substring = w[j:i]\n            is_good = True\n            for k in range(1, len(substring) + 1):\n                if len(substring) % k == 0:\n                    if substring == substring[:k] * (len(substring) // k):\n                        is_good = False\n                        break\n            \n            if is_good:\n                if dp[j] + 1 < dp[i]:\n                    dp[i] = dp[j] + 1\n                    count[i] = count[j]\n                elif dp[j] + 1 == dp[i]:\n                    count[i] += count[j]\n\n    return dp[n], count[n]",
    "timestamp": "2025-08-13 16:25:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef solve(w):\n    n = len(w)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    count = [0] * (n + 1)\n    count[0] = 1\n    \n    for i in range(1, n + 1):\n        for l in range(1, i + 1):\n            s = w[i - l:i]\n            is_good = True\n            for k in range(2, len(s) // l + 1):\n                if l * k <= len(s) and s[:l] * k == s[:l * k]:\n                    is_good = False\n                    break\n            if is_good:\n                dp[i] += dp[i - l]\n                count[i] = max(count[i], count[i - l] + 1)\n    \n    max_elements = count[n]\n    num_representations = dp[n]\n    \n    return (max_elements, num_representations)",
    "timestamp": "2025-08-13 16:26:00"
  }
]