[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100\n\nint solve(int N, int* aoki_scores, int* max_scores, int* importance) {\n    int study_hours = 0;\n    int takahashi_total = 0;\n    int aoki_total = 0;\n\n    for (int i = 0; i < N; i++) {\n        aoki_total += aoki_scores[i] * importance[i];\n    }\n\n    for (int i = 0; i < N; i++) {\n        int required_score = aoki_scores[i] + 1;\n        int study_needed = 0;\n\n        if (required_score > max_scores[i]) {\n            return -1;  // impossible to win\n        }\n\n        study_needed = required_score;\n        study_hours += study_needed;\n        takahashi_total += required_score * importance[i];\n    }\n\n    return study_hours;\n}\n\nint main() {\n    int N;\n    int aoki_scores[MAX_N];\n    int max_scores[MAX_N];\n    int importance[MAX_N];\n\n    // Input reading\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &aoki_scores[i], &max_scores[i], &importance[i]);\n    }\n\n    int result = solve(N, aoki_scores, max_scores, importance);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int a;\n    int b;\n    int c;\n    int max_h;\n} Exam;\n\nint compare(const void *a, const void *b) {\n    Exam *examA = (Exam *)a;\n    Exam *examB = (Exam *)b;\n    return (examB->c * examB->b) - (examA->c * examA->b);\n}\n\nlong long min_study_hours(int N, Exam exams[]) {\n    qsort(exams, N, sizeof(Exam), compare);\n    \n    long long aoki_total = 0;\n    for (int i = 0; i < N; i++) {\n        aoki_total += (long long)exams[i].a * exams[i].c;\n    }\n    \n    long long takahashi_total = 0;\n    long long hours = 0;\n    \n    for (int i = 0; i < N; i++) {\n        long long max_possible = exams[i].max_h;\n        long long needed = (aoki_total - takahashi_total) / exams[i].c + 1;\n        if (needed <= 0) {\n            continue;\n        }\n        long long add = (needed < max_possible) ? needed : max_possible;\n        hours += add;\n        takahashi_total += add * exams[i].c;\n        if (takahashi_total > aoki_total) {\n            return hours;\n        }\n    }\n    \n    return hours;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Exam exams[N];\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d\", &exams[i].a, &exams[i].b, &exams[i].c, &exams[i].max_h);\n    }\n    \n    printf(\"%lld\\n\", min_study_hours(N, exams));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Exam {\n    long long B, L, U;\n};\n\nbool canWin(long long N, long long X, const vector<Exam>& exams, long long hours) {\n    vector<long long> gains;\n    long long total = 0;\n\n    for (const auto& exam : exams) {\n        long long max_gain = exam.U * (X - exam.B) - exam.L * exam.B;\n        if (max_gain > 0) {\n            gains.push_back(max_gain);\n        }\n    }\n\n    sort(gains.rbegin(), gains.rend());\n\n    for (int i = 0; i < min((long long)gains.size(), hours / X); ++i) {\n        total += gains[i];\n    }\n\n    long long remaining_hours = hours % X;\n    if (remaining_hours > 0 && !gains.empty() && hours / X < (long long)gains.size()) {\n        long long partial_gain = exam.U * remaining_hours - exam.L * exam.B;\n        if (partial_gain > 0) {\n            total += partial_gain;\n        }\n    }\n\n    return total >= 0;\n}\n\nlong long minStudyHours(long long N, long long X, const vector<Exam>& exams) {\n    long long left = 0;\n    long long right = N * X;\n    long long answer = right;\n\n    while (left <= right) {\n        long long mid = (left + right) / 2;\n        if (canWin(N, X, exams, mid)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return answer;\n}\n\nint main() {\n    long long N, X;\n    cin >> N >> X;\n    vector<Exam> exams(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> exams[i].B >> exams[i].L >> exams[i].U;\n    }\n\n    cout << minStudyHours(N, X, exams) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Exam {\n        int a, b, c, maxA;\n\n        Exam(int a, int b, int c, int maxA) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.maxA = maxA;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Exam[] exams = new Exam[N];\n        long totalB = 0;\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n            int maxA = sc.nextInt();\n            exams[i] = new Exam(a, b, c, maxA);\n            totalB += (long) b * c;\n        }\n\n        long left = 0;\n        long right = 0;\n        for (Exam e : exams) {\n            right += (long) e.maxA * e.c;\n        }\n\n        long answer = Long.MAX_VALUE;\n        while (left <= right) {\n            long mid = (left + right) / 2;\n            if (canWin(exams, mid, totalB)) {\n                answer = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        System.out.println(answer);\n    }\n\n    private static boolean canWin(Exam[] exams, long hours, long totalB) {\n        long total = 0;\n        for (Exam e : exams) {\n            long maxPossible = Math.min(e.maxA, e.a + hours / e.c);\n            total += maxPossible * e.c;\n            if (total > totalB) {\n                return true;\n            }\n        }\n        return total > totalB;\n    }\n}",
    "timestamp": "2025-08-05 22:49:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ExamCompetition {\n    public static void solve(int N, int[] aokiScores, int[] aokiImportance, int[] maxScores) {\n        long[] takahashiImportance = new long[N];\n        long[] aokiWeightedScores = new long[N];\n        long[] takahashiWeightedScores = new long[N];\n\n        // Calculate Aoki's weighted scores\n        for (int i = 0; i < N; i++) {\n            aokiWeightedScores[i] = (long) aokiScores[i] * aokiImportance[i];\n        }\n\n        // Binary search for minimum study hours\n        long left = 0;\n        long right = (long) 1e15;\n        while (left < right) {\n            long mid = left + (right - left) / 2;\n            if (canWin(N, mid, aokiScores, aokiImportance, maxScores, aokiWeightedScores)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        System.out.println(left);\n    }\n\n    private static boolean canWin(int N, long studyHours, int[] aokiScores, int[] aokiImportance, int[] maxScores, long[] aokiWeightedScores) {\n        long[] takahashiImportance = new long[N];\n        long[] takahashiWeightedScores = new long[N];\n        long remainingHours = studyHours;\n\n        // Allocate importance values optimally\n        for (int i = 0; i < N; i++) {\n            takahashiImportance[i] = aokiImportance[i];\n        }\n\n        // Study for each exam\n        for (int i = 0; i < N; i++) {\n            long hoursNeeded = Math.max(0, aokiScores[i] + 1 - maxScores[i]);\n            if (hoursNeeded <= remainingHours) {\n                remainingHours -= hoursNeeded;\n                takahashiWeightedScores[i] = (long) maxScores[i] * takahashiImportance[i];\n            } else {\n                long score = maxScores[i] * remainingHours / hoursNeeded;\n                takahashiWeightedScores[i] = score * takahashiImportance[i];\n                remainingHours = 0;\n            }\n        }\n\n        // Check if Takahashi wins\n        for (int i = 0; i < N; i++) {\n            if (takahashiWeightedScores[i] <= aokiWeightedScores[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] aokiScores = new int[N];\n        int[] aokiImportance = new int[N];\n        int[] maxScores = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            aokiScores[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            aokiImportance[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < N; i++) {\n            maxScores[i] = scanner.nextInt();\n        }\n\n        solve(N, aokiScores, aokiImportance, maxScores);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:49:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint minimumStudyHours(int N, vector<int>& aokiScores, vector<int>& maxScores, vector<pair<int, int>>& importanceRanges) {\n    int totalHours = 0;\n    \n    for (int i = 0; i < N; i++) {\n        int bestStudyHours = 0;\n        int maxPossibleScore = maxScores[i];\n        int takahashiScore = 0;\n        int aokiScore = aokiScores[i];\n        int minImportance = importanceRanges[i].first;\n        int maxImportance = importanceRanges[i].second;\n        \n        for (int importance = minImportance; importance <= maxImportance; importance++) {\n            for (int studyHours = 0; studyHours <= maxPossibleScore - takahashiScore; studyHours++) {\n                int currentTakahashiScore = takahashiScore + studyHours;\n                int takahashiWeightedScore = currentTakahashiScore * importance;\n                int aokiWeightedScore = aokiScore * importance;\n                \n                if (takahashiWeightedScore > aokiWeightedScore) {\n                    bestStudyHours = max(bestStudyHours, studyHours);\n                }\n            }\n        }\n        \n        totalHours += bestStudyHours;\n    }\n    \n    return totalHours;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> aokiScores(N);\n    vector<int> maxScores(N);\n    vector<pair<int, int>> importanceRanges(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> aokiScores[i] >> maxScores[i] >> importanceRanges[i].first >> importanceRanges[i].second;\n    }\n    \n    int result = minimumStudyHours(N, aokiScores, maxScores, importanceRanges);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimum_study_hours(N, max_score, importance_limits, aoki_scores, takahashi_max_hours):\n    def calculate_score(scores, weights):\n        return sum(s * w for s, w in zip(scores, weights))\n\n    def can_win(importance_values):\n        aoki_score = calculate_score(aoki_scores, importance_values)\n        takahashi_scores = [max_score] * N\n        takahashi_score = calculate_score(takahashi_scores, importance_values)\n        return takahashi_score > aoki_score\n\n    def hours_required(importance_values):\n        hours = 0\n        diffs = []\n        for score, weight in zip(aoki_scores, importance_values):\n            best_improv = max_score - score\n            hours_needed = 0\n            if best_improv > 0:\n                hours_needed = min(best_improv, takahashi_max_hours)\n            diffs.append(hours_needed * weight)\n        needed_win = sum(diffs)\n        return needed_win\n\n    low, high = 1, max(importance_limits) * N\n    answer = high\n\n    while low <= high:\n        mid = (low + high) // 2\n        importance_values = [min(mid, limit) for limit in importance_limits]\n        \n        if can_win(importance_values):\n            answer = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return hours_required([min(answer, limit) for limit in importance_limits])\n\n# Example usage:\nN = 3\nmax_score = 100\nimportance_limits = [10, 20, 30]\naoki_scores = [70, 80, 90]\ntakahashi_max_hours = 100\n\nprint(minimum_study_hours(N, max_score, importance_limits, aoki_scores, takahashi_max_hours))",
    "timestamp": "2025-08-13 12:40:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ExamCompetition {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[] aokiScores = new int[N];\n        int[] maxScores = new int[N];\n        int[] importanceValues = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            aokiScores[i] = scanner.nextInt();\n            maxScores[i] = scanner.nextInt();\n            importanceValues[i] = scanner.nextInt();\n        }\n        \n        int totalImportance = 0;\n        for (int i = 0; i < N; i++) {\n            totalImportance += importanceValues[i];\n        }\n\n        int minHours = 0;\n        while (true) {\n            int takahashiScore = 0;\n            int aokiWeightedScore = 0;\n\n            for (int i = 0; i < N; i++) {\n                if (maxScores[i] * importanceValues[i] > aokiScores[i] * importanceValues[i]) {\n                    int studyHours = (maxScores[i] - aokiScores[i]);\n                    int takahashiExamScore = Math.min(studyHours, minHours);\n                    takahashiScore += takahashiExamScore * importanceValues[i];\n                }\n                aokiWeightedScore += aokiScores[i] * importanceValues[i];\n            }\n\n            if (takahashiScore > aokiWeightedScore) {\n                break;\n            }\n\n            minHours++;\n        }\n        \n        System.out.println(minHours);\n    }\n}",
    "timestamp": "2025-08-13 12:40:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_EXAMS 100\n#define MAX_SCORE 100\n\nint main() {\n    int N, L[MAX_EXAMS], Aoki[MAX_EXAMS];\n    int max_hours = INT_MAX, min_hours_needed = INT_MAX;\n\n    // Initialize Takahashi's scores\n    int Takahashi[MAX_EXAMS] = {0};\n\n    printf(\"Enter the number of exams: \");\n    scanf(\"%d\", &N);\n\n    printf(\"Enter the maximum importance value for each exam: \");\n    for (int i = 0; i < N; ++i)\n        scanf(\"%d\", &L[i]);\n\n    printf(\"Enter Aoki's scores for each exam: \");\n    for (int i = 0; i < N; ++i)\n        scanf(\"%d\", &Aoki[i]);\n\n    for (int mask = 0; mask < (1 << N); ++mask) {\n        int weight_Takahashi = 0, weight_Aoki = 0;\n        int total_hours = 0;\n        for (int i = 0; i < N; ++i) {\n            if (mask & (1 << i)) {\n                total_hours += MAX_SCORE;\n                weight_Takahashi += L[i] * MAX_SCORE;\n            }\n            weight_Aoki += L[i] * Aoki[i];\n        }\n        if (weight_Takahashi > weight_Aoki)\n            min_hours_needed = (total_hours < min_hours_needed) ? total_hours : min_hours_needed;\n    }\n\n    printf(\"Minimum hours Takahashi needs to study: %d\\n\", min_hours_needed == INT_MAX ? -1 : min_hours_needed);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:40:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumStudyHours(N, maxScores, scoreTakahashi, scoreAoki, maxImportance, minImportance) {\n    const exams = Array(N).fill(0).map((_, i) => ({\n        scoreDiff: scoreAoki[i] - scoreTakahashi[i],\n        maxScore: maxScores[i],\n        maxImportance: maxImportance[i],\n        minImportance: minImportance[i]\n    }));\n    \n    exams.sort((a, b) => (b.maxImportance - b.minImportance) - (a.maxImportance - a.minImportance));\n    \n    let hours = 0;\n    let currentScoreT = 0;\n    let currentScoreA = 0;\n\n    for (let i = 0; i < N; i++) {\n        currentScoreT -= exams[i].scoreDiff * exams[i].minImportance;\n        currentScoreA += exams[i].scoreDiff * exams[i].minImportance;\n    }\n\n    for (let i = 0; i < N; i++) {\n        if (currentScoreT > currentScoreA) break;\n\n        let scoreNeeded = Math.min(exams[i].maxScore - scoreTakahashi[i], exams[i].scoreDiff);\n\n        currentScoreT += scoreNeeded * (exams[i].maxImportance - exams[i].minImportance);\n        hours += scoreNeeded;\n    }\n\n    return currentScoreT > currentScoreA ? hours : -1;\n}",
    "timestamp": "2025-08-13 12:40:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_study_hours(N, max_scores, aoki_scores, max_importance):\n    def can_win(study_hours):\n        takahashi_scores = [min(max_scores[i], study_hours) for i in range(N)]\n        \n        max_weighted_score = 0\n        best_importance_allocation = None\n        \n        for importance_combination in range(1 << N):\n            current_importance = [0] * N\n            for j in range(N):\n                if importance_combination & (1 << j):\n                    current_importance[j] = max_importance\n            \n            takahashi_weighted_score = sum(takahashi_scores[i] * current_importance[i] for i in range(N))\n            aoki_weighted_score = sum(aoki_scores[i] * current_importance[i] for i in range(N))\n            \n            if takahashi_weighted_score > aoki_weighted_score:\n                if sum(current_importance) > max_weighted_score:\n                    max_weighted_score = sum(current_importance)\n                    best_importance_allocation = current_importance\n        \n        return best_importance_allocation is not None\n    \n    left, right = 0, sum(max_scores)\n    while left < right:\n        mid = (left + right) // 2\n        if can_win(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage\nN = int(input())\nmax_scores = list(map(int, input().split()))\naoki_scores = list(map(int, input().split()))\nmax_importance = int(input())\n\nresult = min_study_hours(N, max_scores, aoki_scores, max_importance)\nprint(result)",
    "timestamp": "2025-08-13 12:40:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumStudyHours(N, maxScores, aokiScores, importanceRanges) {\n    let left = 0;\n    let right = 1000000;\n\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (canWin(N, maxScores, aokiScores, importanceRanges, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}\n\nfunction canWin(N, maxScores, aokiScores, importanceRanges, studyHours) {\n    const dp = new Array(N + 1).fill(0).map(() => new Array(studyHours + 1).fill(-Infinity));\n    dp[0][0] = 0;\n\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j <= studyHours; j++) {\n            if (dp[i][j] === -Infinity) continue;\n\n            const [minImportance, maxImportance] = importanceRanges[i];\n            for (let importance = minImportance; importance <= maxImportance; importance++) {\n                for (let hours = 0; hours <= maxScores[i] - aokiScores[i] && j + hours <= studyHours; hours++) {\n                    const newScore = dp[i][j] + importance * hours;\n                    dp[i+1][j + hours] = Math.max(dp[i+1][j + hours], newScore);\n                }\n            }\n        }\n    }\n\n    return Math.max(...dp[N]) > 0;\n}",
    "timestamp": "2025-08-13 12:40:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    \n    A = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    B = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    C = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    D = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    # We need to select items (each item is a subject) where we can choose to study or not\n    # The goal is to minimize the total hours while ensuring sum (C_i * (B_i - A_i)) > sum (C_i * (D_i - A_i))\n    # Which simplifies to sum (C_i * (B_i - D_i)) > 0\n    \n    total_needed = 0\n    for i in range(N):\n        total_needed += C[i] * (D[i] - A[i])\n    \n    if total_needed < 0:\n        print(0)\n        return\n    \n    # Now, we need to find the minimal hours to make sum (C_i * (B_i - A_i)) > total_needed\n    # Which is sum (C_i * (B_i - A_i)) >= total_needed + 1\n    target = total_needed + 1\n    \n    # The problem now is to select a subset of subjects to study (B_i instead of A_i)\n    # The gain for each subject is C_i * (B_i - A_i)\n    # The cost is the hours (B_i - A_i)\n    # We need to minimize the total cost while the total gain >= target\n    \n    # This is a knapsack problem where we want to minimize the cost while achieving at least target gain\n    \n    max_gain = sum(C[i] * (B[i] - A[i]) for i in range(N))\n    if max_gain < target:\n        print(-1)\n        return\n    \n    # Initialize DP: dp[g] = minimal cost to achieve gain g\n    INF = float('inf')\n    max_possible_gain = target\n    dp = [INF] * (max_possible_gain + 1)\n    dp[0] = 0\n    \n    for i in range(N):\n        gain = C[i] * (B[i] - A[i])\n        cost = B[i] - A[i]\n        if gain <= 0:\n            continue\n        for g in range(max_possible_gain, -1, -1):\n            if g + gain <= max_possible_gain:\n                if dp[g] + cost < dp[g + gain]:\n                    dp[g + gain] = dp[g] + cost\n            else:\n                if dp[g] + cost < dp[max_possible_gain]:\n                    dp[max_possible_gain] = dp[g] + cost\n    \n    min_hours = INF\n    for g in range(target, max_possible_gain + 1):\n        if dp[g] < min_hours:\n            min_hours = dp[g]\n    \n    print(min_hours if min_hours != INF else -1)\n\nsolve()",
    "timestamp": "2025-08-13 12:41:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const A = input[1].split(' ').map(Number);\n    const B = input[2].split(' ').map(Number);\n    const C = input[3].split(' ').map(Number);\n    const D = input[4].split(' ').map(Number);\n\n    let exams = [];\n    for (let i = 0; i < N; i++) {\n        exams.push({ a: A[i], b: B[i], c: C[i], d: D[i] });\n    }\n\n    exams.sort((x, y) => x.c * y.d - y.c * x.d);\n\n    let dp = new Array(M + 1).fill(-Infinity);\n    dp[0] = 0;\n\n    for (const exam of exams) {\n        const { a, b, c, d } = exam;\n        for (let j = M; j >= 0; j--) {\n            if (dp[j] === -Infinity) continue;\n            for (let k = 1; k <= b - a; k++) {\n                if (j + k * c > M) break;\n                if (dp[j + k * c] < dp[j] + k * d) {\n                    dp[j + k * c] = dp[j] + k * d;\n                }\n            }\n        }\n    }\n\n    let totalAoki = B.reduce((sum, val, idx) => sum + val * D[idx], 0);\n    for (let j = 0; j <= M; j++) {\n        if (dp[j] > totalAoki) {\n            console.log(j);\n            return;\n        }\n    }\n\n    console.log(-1);\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:41:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Exam {\n    int aokiScore;\n    int maxTakahashiScore;\n    int importanceValue;\n    int currentTakahashiScore;\n    int requiredIncrement;\n};\n\nbool compareByPotentialIncrease(const Exam &e1, const Exam &e2) {\n    return e1.requiredIncrement < e2.requiredIncrement;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Exam> exams(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> exams[i].aokiScore >> exams[i].maxTakahashiScore >> exams[i].importanceValue;\n        exams[i].currentTakahashiScore = 0;\n        exams[i].requiredIncrement = exams[i].importanceValue * exams[i].maxTakahashiScore;\n    }\n    \n    int totalAokiWeightedScore = 0, totalTakahashiWeightedScore = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        totalAokiWeightedScore += exams[i].aokiScore * exams[i].importanceValue;\n    }\n    \n    sort(exams.begin(), exams.end(), compareByPotentialIncrease);\n    \n    int minimumNecessaryStudyHours = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        while (totalTakahashiWeightedScore <= totalAokiWeightedScore \n               && exams[i].currentTakahashiScore < exams[i].maxTakahashiScore) {\n            ++exams[i].currentTakahashiScore;\n            totalTakahashiWeightedScore += exams[i].importanceValue;\n            ++minimumNecessaryStudyHours;\n        }\n        \n        if (totalTakahashiWeightedScore > totalAokiWeightedScore) break;\n    }\n    \n    cout << minimumNecessaryStudyHours << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:58"
  }
]