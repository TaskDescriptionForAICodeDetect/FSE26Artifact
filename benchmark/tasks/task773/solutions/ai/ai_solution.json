[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nchar grid[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint H, W;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool has_black_neighbor(int x, int y) {\n    for (int k = 0; k < 4; k++) {\n        int nx = x + dx[k];\n        int ny = y + dy[k];\n        if (is_valid(nx, ny) && grid[nx][ny] == '#') {\n            return true;\n        }\n    }\n    return false;\n}\n\nint solve() {\n    int operations = 0;\n    bool changed;\n\n    do {\n        changed = false;\n        memset(visited, 0, sizeof(visited));\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '.' && has_black_neighbor(i, j) && !visited[i][j]) {\n                    grid[i][j] = '#';\n                    visited[i][j] = true;\n                    changed = true;\n                }\n            }\n        }\n\n        if (changed) {\n            operations++;\n        }\n    } while (changed);\n\n    return operations;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int i;\n    int j;\n} Point;\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    char grid[H][W+1]; // +1 for the null terminator\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    Point queue[H * W];\n    int front = 0, rear = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '#') {\n                queue[rear].i = i;\n                queue[rear].j = j;\n                rear++;\n            }\n        }\n    }\n\n    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int operations = 0;\n\n    while (front < rear) {\n        int current_size = rear - front;\n        int changed = 0;\n\n        for (int k = 0; k < current_size; k++) {\n            Point p = queue[front++];\n            for (int d = 0; d < 4; d++) {\n                int ni = p.i + directions[d][0];\n                int nj = p.j + directions[d][1];\n                if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] == '.') {\n                    grid[ni][nj] = '#';\n                    queue[rear].i = ni;\n                    queue[rear].j = nj;\n                    rear++;\n                    changed = 1;\n                }\n            }\n        }\n\n        if (changed) {\n            operations++;\n        }\n    }\n\n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n    queue<pair<int, int>> q;\n    vector<vector<int>> dist(H, vector<int>(W, -1));\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == '#') {\n                q.push({i, j});\n                dist[i][j] = 0;\n            }\n        }\n    }\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0, 1, -1};\n    int max_dist = 0;\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        int x = current.first;\n        int y = current.second;\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                max_dist = max(max_dist, dist[nx][ny]);\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    cout << max_dist << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        char[][] grid = new char[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        int[][] dist = new int[H][W];\n        for (int i = 0; i < H; i++) {\n            String row = sc.next();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = row.charAt(j);\n                if (grid[i][j] == '#') {\n                    queue.offer(new int[]{i, j});\n                    dist[i][j] = 0;\n                } else {\n                    dist[i][j] = -1;\n                }\n            }\n        }\n\n        int[] dx = {1, -1, 0, 0};\n        int[] dy = {0, 0, 1, -1};\n        int maxDist = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && dist[nx][ny] == -1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    maxDist = Math.max(maxDist, dist[nx][ny]);\n                    queue.offer(new int[]{nx, ny});\n                }\n            }\n        }\n\n        System.out.println(maxDist);\n    }\n}",
    "timestamp": "2025-08-05 22:52:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        H = Integer.parseInt(st.nextToken());\n        W = Integer.parseInt(st.nextToken());\n        \n        grid = new char[H][W];\n        visited = new boolean[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            String row = br.readLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = row.charAt(j);\n            }\n        }\n        \n        int operations = solve();\n        System.out.println(operations);\n    }\n    \n    static int solve() {\n        int operations = 0;\n        \n        while (true) {\n            Set<int[]> toBlack = new HashSet<>();\n            \n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (grid[i][j] == '.') {\n                        if (hasBlackNeighbor(i, j)) {\n                            toBlack.add(new int[]{i, j});\n                        }\n                    }\n                }\n            }\n            \n            if (toBlack.isEmpty()) break;\n            \n            for (int[] pos : toBlack) {\n                grid[pos[0]][pos[1]] = '#';\n            }\n            \n            operations++;\n        }\n        \n        return operations;\n    }\n    \n    static boolean hasBlackNeighbor(int r, int c) {\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        \n        for (int k = 0; k < 4; k++) {\n            int nr = r + dx[k];\n            int nc = c + dy[k];\n            \n            if (nr >= 0 && nr < H && nc >= 0 && nc < W && grid[nr][nc] == '#') {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:52:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    \n    vector<vector<char>> grid(H, vector<char>(W));\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<pair<int, int>> q;\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> grid[i][j];\n            if (grid[i][j] == '#') {\n                q.push({i, j});\n                visited[i][j] = true;\n            }\n        }\n    }\n    \n    int operations = 0;\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    \n    while (!q.empty()) {\n        int size = q.size();\n        bool changed = false;\n        \n        for (int k = 0; k < size; k++) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                \n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && grid[nx][ny] == '.') {\n                    grid[nx][ny] = '#';\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                    changed = true;\n                }\n            }\n        }\n        \n        if (changed) {\n            operations++;\n        }\n    }\n    \n    cout << operations << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_operations_to_blacken(grid, H, W):\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    operations = 0\n    while True:\n        new_black_squares = []\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == '.':\n                    for di, dj in directions:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == '#':\n                            new_black_squares.append((i, j))\n                            break\n        if not new_black_squares:\n            break\n        for i, j in new_black_squares:\n            grid[i][j] = '#'\n        operations += 1\n    return operations\n\n# Example usage:\nH = 3\nW = 3\ngrid = [\n    ['#', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n]\n\nprint(min_operations_to_blacken(grid, H, W))",
    "timestamp": "2025-08-13 12:48:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class BlackenGrid {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        \n        char[][] grid = new char[H][W];\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        \n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == '#') {\n                    queue.offer(new int[]{i, j});\n                    visited[i][j] = true;\n                }\n            }\n        }\n        \n        int[] dirX = {-1, 1, 0, 0};\n        int[] dirY = {0, 0, -1, 1};\n        int steps = 0;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            boolean changed = false;\n            \n            for (int s = 0; s < size; s++) {\n                int[] cell = queue.poll();\n                int x = cell[0];\n                int y = cell[1];\n                \n                for (int d = 0; d < 4; d++) {\n                    int newX = x + dirX[d];\n                    int newY = y + dirY[d];\n                    \n                    if (newX >= 0 && newX < H && newY >= 0 && newY < W && !visited[newX][newY] && grid[newX][newY] == '.') {\n                        grid[newX][newY] = '#';\n                        queue.offer(new int[]{newX, newY});\n                        visited[newX][newY] = true;\n                        changed = true;\n                    }\n                }\n            }\n            \n            if (changed) {\n                steps++;\n            }\n        }\n        \n        System.out.println(steps);\n    }\n}",
    "timestamp": "2025-08-13 12:48:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_H 1000\n#define MAX_W 1000\n\nchar grid[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint H, W;\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nbool canSpread(int x, int y) {\n    return isValid(x, y) && grid[x][y] == '.' && !visited[x][y];\n}\n\nvoid spread() {\n    char nextGrid[MAX_H][MAX_W];\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            nextGrid[i][j] = grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                if (canSpread(i+1, j)) nextGrid[i+1][j] = '#';\n                if (canSpread(i-1, j)) nextGrid[i-1][j] = '#';\n                if (canSpread(i, j+1)) nextGrid[i][j+1] = '#';\n                if (canSpread(i, j-1)) nextGrid[i][j-1] = '#';\n            }\n        }\n    }\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            grid[i][j] = nextGrid[i][j];\n            visited[i][j] = false;\n        }\n    }\n}\n\nbool allBlack() {\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '.') return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    int operations = 0;\n    while (!allBlack()) {\n        spread();\n        ++operations;\n    }\n    \n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:48:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Cell {\n    int x, y;\n};\n\nvector<vector<int>> directions {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nbool isWithinGrid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    queue<Cell> q;\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n\n    // Add all initial black cells to the queue\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                q.push({i, j});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int operations = 0;\n\n    while (!q.empty()) {\n        int size = q.size();\n        bool anyWhiteTurnedBlack = false;\n\n        for (int i = 0; i < size; ++i) {\n            Cell cell = q.front();\n            q.pop();\n\n            for (const auto& dir : directions) {\n                int newX = cell.x + dir[0];\n                int newY = cell.y + dir[1];\n\n                if (isWithinGrid(newX, newY, H, W) && !visited[newX][newY] && grid[newX][newY] == '.') {\n                    grid[newX][newY] = '#';\n                    q.push({newX, newY});\n                    visited[newX][newY] = true;\n                    anyWhiteTurnedBlack = true;\n                }\n            }\n        }\n\n        if (anyWhiteTurnedBlack) {\n            ++operations;\n        }\n    }\n\n    cout << operations << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:48:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_grid_coloring(H, W, grid):\n    def count_operations(grid):\n        operations = 0\n        while True:\n            to_color = set()\n            for i in range(H):\n                for j in range(W):\n                    if grid[i][j] == '.':\n                        if (i > 0 and grid[i-1][j] == '#') or \\\n                           (i < H-1 and grid[i+1][j] == '#') or \\\n                           (j > 0 and grid[i][j-1] == '#') or \\\n                           (j < W-1 and grid[i][j+1] == '#'):\n                            to_color.add((i, j))\n            \n            if not to_color:\n                break\n            \n            for x, y in to_color:\n                grid[x][y] = '#'\n            \n            operations += 1\n        \n        return operations\n\n    return count_operations(grid)\n\n# Input reading\nH, W = map(int, input().split())\ngrid = [list(input()) for _ in range(H)]\n\n# Output result\nprint(solve_grid_coloring(H, W, grid))",
    "timestamp": "2025-08-13 12:49:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\nH, W = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(H)]\n\nqueue = deque()\ndist = [[-1 for _ in range(W)] for _ in range(H)]\n\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j] == '#':\n            queue.append((i, j))\n            dist[i][j] = 0\n\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nmax_dist = 0\n\nwhile queue:\n    i, j = queue.popleft()\n    for di, dj in directions:\n        ni, nj = i + di, j + dj\n        if 0 <= ni < H and 0 <= nj < W and dist[ni][nj] == -1:\n            dist[ni][nj] = dist[i][j] + 1\n            max_dist = max(max_dist, dist[ni][nj])\n            queue.append((ni, nj))\n\nprint(max_dist)",
    "timestamp": "2025-08-13 12:49:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countOperationsToBlackenGrid(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    function isValid(x, y) {\n        return x >= 0 && x < H && y >= 0 && y < W;\n    }\n\n    function hasBlackNeighbor(x, y) {\n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (isValid(nx, ny) && grid[nx][ny] === '#') {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    let operations = 0;\n    while (true) {\n        let changed = false;\n        const newGrid = grid.map(row => row.slice());\n\n        for (let x = 0; x < H; x++) {\n            for (let y = 0; y < W; y++) {\n                if (grid[x][y] === '.' && hasBlackNeighbor(x, y)) {\n                    newGrid[x][y] = '#';\n                    changed = true;\n                }\n            }\n        }\n\n        if (!changed) break;\n        grid = newGrid;\n        operations++;\n    }\n\n    return operations;\n}",
    "timestamp": "2025-08-13 12:49:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n    let operations = 0;\n    \n    while (true) {\n        const toBlack = new Set();\n        let changed = false;\n        \n        for (let i = 0; i < H; i++) {\n            for (let j = 0; j < W; j++) {\n                if (grid[i][j] === '.') {\n                    const directions = [[0,1], [0,-1], [1,0], [-1,0]];\n                    for (const [di, dj] of directions) {\n                        const ni = i + di, nj = j + dj;\n                        if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] === '#') {\n                            toBlack.add(`${i},${j}`);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (toBlack.size === 0) break;\n        \n        for (const square of toBlack) {\n            const [i, j] = square.split(',').map(Number);\n            grid[i][j] = '#';\n        }\n        \n        operations++;\n    }\n    \n    return operations;\n}",
    "timestamp": "2025-08-13 12:49:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [H, W] = input[0].split(' ').map(Number);\n    const grid = input.slice(1, H + 1).map(row => row.split(''));\n    \n    let queue = [];\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    let steps = 0;\n    \n    // Initialize queue with all initial black squares\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (grid[i][j] === '#') {\n                queue.push([i, j]);\n            }\n        }\n    }\n    \n    while (queue.length > 0) {\n        const newQueue = [];\n        for (const [i, j] of queue) {\n            for (const [di, dj] of directions) {\n                const ni = i + di;\n                const nj = j + dj;\n                if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] === '.') {\n                    grid[ni][nj] = '#';\n                    newQueue.push([ni, nj]);\n                }\n            }\n        }\n        if (newQueue.length > 0) {\n            steps++;\n        }\n        queue = newQueue;\n    }\n    \n    console.log(steps);\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:50:06"
  }
]