[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N=(1<<20);\n\nll bit0[2][MAX_N+1],bit1[2][MAX_N+1];\n\nclass BIT{\n\npublic:\n  \n  int n,idx;\n  \n  BIT(){\n    n=MAX_N;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n  }\n\n  BIT(int n,int I){\n    this->n=n;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n    idx=I;\n  }\n  \n  ll sum(ll *b,int i){\n\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n  \n  // [a,b]テ」ツ?ォ xテ」ツつ津・ツ環?」ツ?暗」ツつ?\n  \n  void add(int a,int b,ll x){\n    add(bit0[idx],a,-x*(a-1));\n    add(bit1[idx],a,x);\n    add(bit0[idx],b+1,x*b);\n    add(bit1[idx],b+1,-x);\n  }\n  \n  // [a,b]テ」ツ?ョsumテ」ツつ津・ツセツ療」ツつ?\n  \n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0[idx],b)+sum(bit1[idx],b)*b;\n    res-=sum(bit0[idx],a-1)+sum(bit1[idx],a-1)*(a-1);\n    return res;\n  }\n  \n};\n\n\n\nstring s;\nint n,q;\n\n\nint main(){\n  \n  cin>>n>>q;\n  \n  cin>>s;\n  \n  BIT L(n,0), R(n,1);\n\n  for(int i=1;i<=n;i++){\n\n    if(s[i-1]=='(') L.add(i,i,1);\n    else R.add(i,i,1);\n    \n  }\n  \n  int x;\n  \n  for(int i=0;i<q;i++){\n    \n    scanf(\"%d\",&x);\n    \n    if(L.sum(x,x)){ // s[x]='('\n      \n      L.add(x,x,-1);\n      R.add(x,x,1);\n      \n      int l=1, r=n+1;\n      \n      while(l<r){\n\t\n\tint m=(l+r)/2;\n\n\tif(R.sum(1,m)>=1) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,1);\n      R.add(l,l,-1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    else{ // s[x]=')'\n\n      L.add(x,x,1);\n      R.add(x,x,-1);\n      \n      if(L.sum(x,n)>R.sum(x,n)){\n\t\n\tL.add(x,x,-1);\n\tR.add(x,x,1);\n      \n\tprintf(\"%d\\n\",x);\n\tcontinue;\n      }\n      \n      int l=1, r=n+1;\n\n      while(l<r){\n\n\tint m=(l+r)/2;\n\t\n\tif(L.sum(0,m-1)>=R.sum(0,m-1)+1) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,-1);\n      R.add(l,l,1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=1e9;\n\nconst int N_MAX=1<<20;\nconst int DAT_SIZE=N_MAX*2-1;\nint dat[DAT_SIZE],lazy[DAT_SIZE];\nint n;\n\nvoid init(int size){\n  fill(begin(dat),end(dat),INF);\n  n=1;\n  while(n<size){\n    n*=2;\n  }\n}\n\nvoid lazy_eval(int k){\n  dat[k]+=lazy[k];\n  if(k<n-1){\n    lazy[k*2+1]+=lazy[k];\n    lazy[k*2+2]+=lazy[k];\n  }\n  lazy[k]=0;\n}\n\nint rangemin(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return INF;\n  lazy_eval(k);\n  if(a<=l&&r<=b){\n    return dat[k];\n  }else{\n    int v1=rangemin(a,b,k*2+1,l,(l+r)/2);\n    int v2=rangemin(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n}\n\nint rangeadd(int v,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return INF;\n  if(a<=l&&r<=b){\n    lazy[k]+=v;\n    lazy_eval(k);\n    return dat[k];\n  }else{\n    lazy_eval(k);\n    int v1=rangeadd(v,a,b,k*2+1,l,(l+r)/2);\n    int v2=rangeadd(v,a,b,k*2+2,(l+r)/2,r);\n    return dat[k]=min(v1,v2);\n  }\n}\n\nvoid change(int x,int v,int k,int l,int r){\n  lazy_eval(k);\n  if(k<n-1){\n    if(x<(l+r)/2){\n      change(x,v,k*2+1,l,(l+r)/2);\n    }else{\n      change(x,v,k*2+2,(l+r)/2,r);\n    }\n    lazy_eval(k*2+1);\n    lazy_eval(k*2+2);\n    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n  }else{\n    dat[k]=v;\n  }\n}\n\nint main(){\n  int N,Q;\n  cin>>N>>Q;\n  init(N);\n  char s[323456];\n  cin>>s;\n  for(int i=0,c=0;i<N;i++){\n    c+=(s[i]=='(')-(s[i]==')');\n    change(i,c,0,0,n);\n  }\n  for(int i=0;i<n*2-1;i++){\n    //    cout<<i<<' '<<dat[i]<<endl;\n  }\n  while(Q--){\n    int q;\n    cin>>q;\n    q--;\n    if(s[q]=='('){\n      rangeadd(-2,q,N,0,0,n);\n      int l=-1,h=N;\n      while(h-l>1){\n\tint m=(l+h)/2;\n\tif(rangemin(m,m+1,0,0,n)==m+1){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      cout<<h+1<<endl;\n      rangeadd(2,h,N,0,0,n);\n      s[q]=')';\n      s[h]='(';\n    }else{\n      rangeadd(2,q,N,0,0,n);\n      int l=-1,h=q+1;\n      while(h-l>1){\n\tint m=(h+l)/2;\n\tif(rangemin(m,q+1,0,0,n)<=2){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      cout<<l+1<<endl;\n      rangeadd(-2,l,N,0,0,n);\n      s[q]='(';\n      s[l]=')';\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#include <cmath>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <algorithm>\n\n#include <queue>\n\n#include <vector>\n\n#include <map>\n\n\n\nusing namespace std;\n\n\n\ntypedef long long LL;\n\n\nchar s[300005];\nint a[300005],sum[300005];\nstruct Node\n{\n\tint x1,x2,bj;\n}tree[3000005];\nint n,m,ans,x;\nvoid build(int x,int l,int r)\n{\n\ttree[x].bj=0;tree[x].x1=19950920;tree[x].x2=19950920;\n\tif (l==r)\n\t{\n\t\tif (a[l]==-1) tree[x].x1=l;\n\t\telse tree[x].x1=19950920;\n\t\ttree[x].x2=sum[l];\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(x*2,l,mid);\n\tbuild(x*2+1,mid+1,r);\n\ttree[x].x2=min(tree[x*2].x2,tree[x*2+1].x2);\n\ttree[x].x1=min(tree[x*2].x1,tree[x*2+1].x1);\n}\n\nvoid change(int x,int l,int r,int ll,int rr,int w)\n{\n\tif (l==ll&&rr==r)\n\t{\n\t\ttree[x].x2+=w;\n\t\ttree[x].bj+=w;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif (tree[x].bj!=0)\n\t{\n\t\ttree[x*2].x2+=tree[x].bj;tree[x*2].bj+=tree[x].bj;\n\t\ttree[x*2+1].x2+=tree[x].bj;tree[x*2+1].bj+=tree[x].bj;\n\t\ttree[x].bj=0;\n\t}\n\tif (rr<=mid) change(x*2,l,mid,ll,rr,w);\n\telse if (ll>=mid+1) change(x*2+1,mid+1,r,ll,rr,w);\n\telse \n\t{\n\t\tchange(x*2,l,mid,ll,mid,w);\n\t\tchange(x*2+1,mid+1,r,mid+1,rr,w);\n\t}\n\ttree[x].x2=min(tree[x*2].x2,tree[x*2+1].x2);\n\ttree[x].x1=min(tree[x*2].x1,tree[x*2+1].x1);\n}\nint query(int x,int l,int r)\n{\n\tif (l==r) return l;\n\tint mid=(l+r)/2;\n\tif (tree[x].bj!=0)\n\t{\n\t\ttree[x*2].x2+=tree[x].bj;tree[x*2].bj+=tree[x].bj;\n\t\ttree[x*2+1].x2+=tree[x].bj;tree[x*2+1].bj+=tree[x].bj;\n\t\ttree[x].bj=0;\n\t}\n\tif (tree[x*2+1].x2<2) return query(x*2+1,mid+1,r);\n\telse return query(x*2,l,mid);\n}\nvoid change2(int x,int l,int r,int pos)\n{\n\tif (l==r)\n\t{\n\t\tif (a[l]==-1) tree[x].x1=l;\n\t\telse tree[x].x1=19950920;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif (pos<=mid) change2(x*2,l,mid,pos);\n\telse change2(x*2+1,mid+1,r,pos);\n\ttree[x].x1=min(tree[x*2].x1,tree[x*2+1].x1);\n}\n\nint main()\n\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=n;++i) \n\t{\n\t\tif (s[i]=='(') a[i]=1;\n\t\telse a[i]=-1;\n\t}\n\tsum[0]=0;\n\tfor (int i=1;i<=n;++i) sum[i]=sum[i-1]+a[i];\n\tbuild(1,1,n);\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif (a[x]==1)\n\t\t{\n\t\t\tchange(1,1,n,x,n,-2);\n\t\t\ta[x]=-a[x];\n\t\t\tchange2(1,1,n,x);\n\t\t\tans=tree[1].x1;\n\t\t\tchange(1,1,n,ans,n,+2);\n\t\t\ta[ans]=-a[ans];\n\t\t\tchange2(1,1,n,ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchange(1,1,n,x,n,+2);\n\t\t\ta[x]=-a[x];\n\t\t\tchange2(1,1,n,x);\n\t\t\tans=query(1,1,n)+1;\n\t\t\tchange(1,1,n,ans,n,-2);\n\t\t\ta[ans]=-a[ans];\n\t\t\tchange2(1,1,n,ans);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\t//for (int j=1;j<=n;++j) if (a[j]==1) cout<<\"(\";\n\t\t//else cout<<\")\";\n\t\t//cout<<endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  set<int> open_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  REP(i, N) if(S[i] == '(') open_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      open_parens.erase(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      open_parens.insert(min_idx);\n      \n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        // pos_seg.add(min_idx, min_idx + 1, -1);\n        // pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val;// = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        pos_pos = *open_parens.lower_bound(sum_pos+1);\n        \n        assert(S[pos_pos] == '(');\n        cout << pos_pos + 1 << endl;\n        \n\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        \n        // pos_seg.add(q, q + 1, -1);\n        // pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          \n          close_parens.erase(q);\n          close_parens.insert(pos_pos);\n        \n          open_parens.insert(q);\n          open_parens.erase(pos_pos);\n\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#ifndef ___Class_StarrySkyTree\n#define ___Class_StarrySkyTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\n// ------ Starry Sky Tree Class ------ //\ntemplate<typename Type> class StarrySkyTree {\nprivate:\n\tunsigned size_; std::vector<Type> dat1, dat2;\n\tinline void update_(unsigned a, unsigned b, Type x, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat2[k] += x; return;\n\t\t}\n\t\tupdate_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tupdate_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\tdat1[k] = std::min(dat1[k << 1] + dat2[k << 1], dat1[(k << 1) + 1] + dat2[(k << 1) + 1]);\n\t}\n\tinline Type query_(unsigned a, unsigned b, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return std::numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat1[k] + dat2[k];\n\t\tType lc = query_(a, b, (k << 1), l, (l + r) >> 1);\n\t\tType rc = query_(a, b, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn std::min(lc, rc) + dat2[k];\n\t}\npublic:\n\tStarrySkyTree() : size_(0), dat1(std::vector<Type>()), dat2(std::vector<Type>()) {};\n\tStarrySkyTree(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat1.resize(size_ << 1, 0);\n\t\tdat2.resize(size_ << 1, 0);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void add(unsigned i, Type x) {\n\t\tupdate_(i, i + 1, x, 1, 0, size_);\n\t}\n\tinline void add(unsigned l, unsigned r, Type x) {\n\t\tupdate_(l, r, x, 1, 0, size_);\n\t}\n\tinline Type query(unsigned l, unsigned r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, x; string s;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> Q >> s;\n\tBIT<int> r1(N);\n\tStarrySkyTree<int> r2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tr1.add(i, s[i] == '(' ? 1 : -1);\n\t\tr2.add(i, N, s[i] == '(' ? 1 : -1);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> x; x--;\n\t\tif (s[x] == '(') {\n\t\t\tr1.add(x, -2); s[x] = ')';\n\t\t\tr2.add(x, N, -2);\n\t\t\tint l = 0, r = N + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tint res = r1.sum(0, m);\n\t\t\t\tif (res != m) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(l, 2); s[l] = '(';\n\t\t\tr2.add(l, N, 2);\n\t\t\tcout << l + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tr1.add(x, 2); s[x] = '(';\n\t\t\tr2.add(x, N, 2);\n\t\t\tint l = 0, r = N;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (r2.query(m, N) >= 2) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(r, -2); s[r] = ')';\n\t\t\tr2.add(r, N, -2);\n\t\t\tcout << r + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  set<int> open_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  REP(i, N) if(S[i] == '(') open_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      open_parens.erase(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      open_parens.insert(min_idx);\n      \n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        // pos_seg.add(min_idx, min_idx + 1, -1);\n        // pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val;// = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        pos_pos = *open_parens.lower_bound(sum_pos+1);\n        \n        assert(S[pos_pos] == '(');\n        cout << pos_pos + 1 << endl;\n\n        \n        sum_seg.add(q + 1, N + 1, 2);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        \n        // pos_seg.add(q, q + 1, -1);\n        // pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          \n          close_parens.erase(q);\n          close_parens.insert(pos_pos);\n        \n          open_parens.insert(q);\n          open_parens.erase(pos_pos);\n\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;  // 対象区間とノードの区間が交わらないなら処理をしない\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k, r-l);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k, int size) {\n    if (size > 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k, int size) {\n    if (size == 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,n)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int k, int l, int r, int val) {\n    process_lazy(k, r-l);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    int ret_r = getLeftGt(RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2) return ret_r;\n    int ret_l = getLeftGt(LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<map>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst ll INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  ll n;\n  vector<ll> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(ll n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(ll a,ll b,ll x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  ll get_min(ll a,ll b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  ll add_getmin(ll a,ll b,ll x,ll k,ll l,ll r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  ll get_min(ll a,ll b,ll k,ll l,ll r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      ll vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      ll vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\nvoid debug_show(string str,Segment_Tree *ST,ll n)\n{\n  ll j;\n  cout<<str<<endl;\n  cout<<\"Sum \";\n  rep(j,n)\n    cout<<ST->get_min(j,j+1)<<\" \";\n  cout<<endl;\n  cout<<\"Min \" ;\n  rep(j,n)\n    cout<<ST->get_min(j,n)<<\" \";\n  cout<<endl;\n}\n\nint  main()\n{\n  string str;\n  ll n,q;\n  cin>>n>>q;\n  ll i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(n);\n  ll sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='('){\n\tST.add(i,n,1);\n      }\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      ll flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  ll ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  /* \n\t  ll p=-1;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{p=str.find('(',p+1);}\n\t    while(ST.get_min(p,n)<2);\n\t  \n\t  */\n\t  //cout<<\"bf \"<<flip+1<<\"changed\"<<endl;\n\t  //debug_show(str,&ST,n);\n\t  \n\t  ll p=0,e=n;\n\t  if(flip==n-1)p=flip;\n\t  else{\n\t    while(e>p+1){\n\t      if(ST.get_min((p+e)/2,n)<2)p=(p+e)/2;\n\t      else e=(p+e)/2;\n\t    }\n\t    p=str.find('(',p+1);\n\t  }\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t  //puts(\"af\");\n\t  //debug_show(str,&ST,n);\n\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nint fix(set<int> &a, set<int> &b, char *s, char before, int x)\n{\n    a.erase(x);\n    b.insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    \n    while (l != r){\n        int mid = (l + r) / 2;\n        int p = *b.lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        bool cond1 = (p ? abs(getMin(p - 1, p) - getMin(p, p + 1)) == 1 : getMin(0, 1) == 1);\n        bool cond2 = (p != n - 1 ? abs(getMin(p, p + 1) - getMin(p + 1, p + 2)) == 1 : getMin(0, n - 1) == 0);\n        \n        if (segMin[0] + segAdd[0] >= 0 && cond1 && cond2) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    int p = *b.lower_bound(l);\n    add(p, n, -2 * base);\n    b.erase(p);\n    a.insert(p);\n    s[p] = before;\n    \n    return (p);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '('){\n            printf(\"%d\\n\", fix(lf, rg, s, '(', x) + 1);\n        }\n        else {\n            printf(\"%d\\n\", fix(rg, lf, s, ')', x) + 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconstexpr type INIT = (1 << 28);\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> value;\n\tvector<type> lazy;\n\n\ttype function(type a, type b) {\n\t\treturn min(a, b);\n\t}\n\n\tvoid evaluate(int k, int number_of_children) {\n\t\tif(lazy[k] == 0) return;\n\t\tif(number_of_children > 1) {\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t}\n\n\t\tvalue[k] += lazy[k];\n\t\tlazy[k] = 0;\n\t}\n\n\t// [a, b)にvを加える\n\tvoid add(int a, int b, type v, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tlazy[k] += v;\n\t\t}\n\t\telse {\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tevaluate(k, r - l);\n\t\t\tadd(a, b, v, k * 2 + 1, l, m);\n\t\t\tadd(a, b, v, k * 2 + 2, m, r);\n\t\t\tvalue[k] += v;\n\t\t}\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INIT;\n\t\tevaluate(k, r - l);\n\t\tif(a <= l && r <= b) return value[k];\n\n\t\tconst int m = (l + r) / 2;\n\t\tconst type vl = query(a, b, k * 2 + 1, l, m);\n\t\tconst type vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn function(vl, vr);\n\t}\n\npublic:\n\tsegment_tree(int n_):n(1) {\n\t\twhile(n < n_) n *= 2;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\n\tsegment_tree(const vector<int> &a):n(1) {\n\t\tconst int n_ = a.size();\n\t\twhile(n < n_) n *= 2;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\n\t\tfor(int i = 0; i < n_; ++i) {\n\t\t\tvalue[i + n - 1] = a[i];\n\t\t}\n\n\t\tfor(int i = n - 2; i >= 0; --i) {\n\t\t\tvalue[i] = function(value[2 * i + 1], value[2 * i + 2]);\n\t\t}\n\t}\n\n\tvoid add(int a, int b, type v) {\n\t\tadd(a, b, v, 0, 0, n);\n\t}\n\n\ttype query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tstring s;\n\tcin >> s;\n\n\tset<int> S;\n\n\tint sum = 0;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(s[i] == '(') {\n\t\t\t++sum;\n\t\t}\n\t\telse {\n\t\t\t--sum;\n\t\t\tS.insert(i);\n\t\t}\n\n\t\ta[i] = sum;\n\t}\n\n\tsegment_tree seg(a);\n\n\twhile(q--) {\n\t\tint p;\n\t\tcin >> p;\n\t\t--p;\n\n\t\tif(s[p] == '(') {\n\t\t\ts[p] = ')';\n\t\t\tS.insert(p);\n\t\t\tseg.add(p, n, -2);\n\n \t\t\tconst int res = *S.begin();\n\n\t\t\ts[res] = '(';\n\t\t\tS.erase(res);\n\t\t\tseg.add(res, n, 2);\n\n\t\t\tcout << res + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\ts[p] = '(';\n\t\t\tS.erase(p);\n\t\t\tseg.add(p, n, 2);\n\n\t\t\tint L = 0, R = p;\n\t\t\twhile(L + 1 < R) {\n\t\t\t\tconst int M = (L + R) / 2;\n\n\t\t\t\tif(seg.query(M, p) <= 1) {\n\t\t\t\t\tL = M;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tR = M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(s[R] == '(');;\n\n\t\t\ts[R] = ')';\n\t\t\tS.insert(R);\n\t\t\tseg.add(R, n, -2);\n\n\t\t\tcout << R + 1 << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000], dat[1048576], size_; string s;\ninline void update(int i, int x) {\n\ti += size_; dat[i] = x;\n\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\tint lc = query(a, b, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < n; i++) update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - query(0, r, 1, 0, size_) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (l = r - 1; l >= 0; l--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[l];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; update(r, 0);\n\t\t\td[l] = -1; update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = query(0, pm + 1, 1, 0, size_);\n\t\t\t\tif (query(0, pm + 1, 1, 0, size_)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; update(r, 1);\n\t\t\td[pr] = 1; update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int INF = 1e9+9;\n\n// ????????????????????±\ntemplate <typename T, T INIT>\nstruct node {\n\tT v, lazy;\n\tnode(){\n\t\tv = INIT;\n\t\tlazy = 0;\n\t}\n\t// ?????????????????´??°\n\tvoid update(T _v){\n\t\tv = _v;\n\t}\n\t// ??????????????´??°\n\tvoid merge(T vl, T vr){\n\t\tv = min(vl, vr);\n\t}\n\t// ????????????????????????\n\tT get(){\n\t\treturn v;\n\t}\n\t// ??????????????´??°(lazy?????¨)\n\tT add(int l, int r, T _v=0){\n\t\tT sum = lazy + _v;\n\t\tv += sum;\n\t\tlazy = 0;\n\t\treturn sum;\n\t}\n\t// ?????????????????¶???????????????\n\tvoid addLazy(T v){\n\t\tlazy += v;\n\t}\n};\n\ntemplate <typename T, typename NODE=node<T,INF> >\nclass SegTree{\n\t// ?????¶??????????????¨??????\n\tvoid propLazy(int a, int b, int k, T v=0){\n\t\tT lazy = data[k].add(a, b, v);\n\t\tif( k < N ){\n\t\t\tdata[k*2+0].addLazy(lazy);\n\t\t\tdata[k*2+1].addLazy(lazy);\n\t\t}\n\t}\n\t// ?????°??????????????????????????????\n\tT prop(int l, int r, T v, int a, int b, int k=1){\n\t\t// ??????\n\t\tpropLazy(a, b, k);\n\t\t// ?????????\n\t\tNODE nd;\t// ??????????????¨(??????????????´????????????????????????)\n\t\tif( l <= a && b <= r ){\n\t\t\t// ?????¨?????????????????´???\n\t\t\tpropLazy(a, b, k, v);\n\t\t\treturn data[k].get();\n\t\t}else if( l < b && a < r ){\n\t\t\t// ?????????????????????????????´???\n\t\t\tint m = (a+b) / 2;\n\t\t\tT vl = prop(l,r,v, a, m, k*2);\n\t\t\tT vr = prop(l,r,v, m, b, k*2+1);\n\t\t\tdata[k].merge( data[k*2].get(), data[k*2+1].get() );\n\t\t\tnd.merge( vl, vr );\n\t\t}\n\t\treturn nd.get();\n\t}\n\npublic:\n\tvector<NODE> data;\n\tint N;\n\tSegTree(int _N){\n\t\t// _N <= (N = 2^k) ???????????????\n\t\tN = 1;\n\t\twhile( N < _N ) N<<=1;\n\t\tdata.resize(N*2);\n\t}\n\t// ?????°???????????????????????´??°\n\tvoid update(int l, T v){\n\t\tprop(l, l+1, v-get(l), 0, N);\n\t}\n\t// ?????°???????????????????????´??°(???????????????)\n\tT add(int l, int r, T v){\n\t\treturn prop(l,r,v,0,N);\n\t}\n\t// ???????????? [l,r)\n\tT get(int l, int r=-1){\n\t\tif( r == -1 ) r = l+1;\n\t\treturn prop(l,r,0,0,N);\n\t}\n};\n\n\n\n// ?¢????\n\n#include <algorithm>\n#include <set>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\ntypedef pair<int,int> pii;\n\n\n// AOJ DSL_2_A\n/*\nconst ll INF2 = ((ll)1<<31) - (ll)1;\nSegTree<ll,node<ll,INF2> > sg(100005);\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\trep(i,q){\n\t\tint c, x, y;\n\t\tcin >> c >> x >> y;\n\t\tif( c == 0 ){\n\t\t\tsg.update(x, y);\n\t\t}else{\n\t\t\ty++;\n\t\t\tcout << sg.get(x, y) << endl;\n\t\t}\n\t\t//rep(j,18) cout << sg.data[j].get() << \" \"; cout << endl;\n\t}\n\treturn 0;\n}\n*/\n\n\n// arc026_C\n/*\nSegTree<ll,node<ll,(ll)1e12> > sg(100005);\nint main(){\n\tint N, L;\n\tint l[100005], r[100005], c[100005];\n\tvector<pii> v;\n\n\tcin >> N >> L;\n\trep(i,N){\n\t\tcin >> l[i] >> r[i] >> c[i];\n\t\tv.emplace_back( r[i], i );\n\t}\n\tsort( all(v) );\n\n\tsg.update(0,0);\n\tfor(auto p: v){\n\t\tint i = p.second;\n\t\tll tmp = min( sg.get(r[i]), sg.get(l[i], r[i]) + (ll)c[i] );\n\t\tsg.update( r[i], tmp );\n\t}\n\n\tcout << sg.get(L) << endl;\n\n\treturn 0;\n}\n*/\n\n\n// ????????§?¢????\n/*\nSegTree<int,node<int,99> > sg(8);\nint main(){\n\tint q, x, y, v;\n\tsg.add(0,8,-99);\n\twhile(cin>>q>>x>>y){\n\t\tif( q == 0 ){\n\t\t\tcin >> v;\n\t\t\tsg.add(x,y,v);\n\t\t}else{\n\t\t\tcout << \"get : \" << sg.get(x,y) << endl;\n\t\t}\n\t\t// ?????°??????????????¶????????¨???\n\t\trep(i,sg.data.size()){\n\t\t\tif( __builtin_popcount(i) == 1 ) cout << endl;\n\t\t\tcout << sg.data[i].v << \"(\" << sg.data[i].lazy << \")\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n*/\n\n\n// ICPC 2014 Tokyo Regional G\nSegTree<int> sg(300005);\nint q[200005];\nint main(){\n\tint N, Q;\n\tstring s;\n\tcin >> N >> Q >> s;\n\trep(i,Q){\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t}\n\t\n\tset<int> op, cl;\n\tint sum = 0;\n\trep(i,N+1){\n\t\tsg.update(i, sum);\n\t\tif( s[i] == ')' ){\n\t\t\tcl.insert(i);\n\t\t\tsum--;\n\t\t}else{\n\t\t\top.insert(i);\n\t\t\tsum++;\n\t\t}\n\t}\n\n\trep(i,Q){\n\t\tauto &&c = s[ q[i] ];\n\t\tint ans;\n\t\tif( c == '(' ){\n\t\t\tc = ')';\n\t\t\tcl.insert( q[i] );\n\t\t\tif(op.find(q[i]) != op.end() ) op.erase( op.find(q[i]) );\n\t\t\tsg.add(q[i]+1, N+2, -2);\n\t\t\tans = *cl.begin();\n\t\t\ts[ans] = '(';\n\t\t\tsg.add(ans+1, N+2, 2);\n\t\t\tcl.erase( *cl.begin() );\n\t\t\top.insert( ans );\n\t\t}else{\n\t\t\tif(cl.find(q[i]) != cl.end() ) cl.erase( cl.find(q[i]) );\n\t\t\top.insert( q[i] );\n\t\t\tc = '(';\n\t\t\tsg.add(q[i]+1, N+2, 2);\n\n\t\t\tint l=1, r=N+2;\n\t\t\twhile( r-l > 1 ){\n\t\t\t\tint m = (l+r) / 2;\n\t\t\t\tsg.add(m, N+2, -2);\n\t\t\t\tif( sg.get(m, N+2) >= 0 ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t\tsg.add(m, N+2, 2);\n\t\t\t}\n\t\t\tauto it = op.upper_bound( l-1 );\n\n\t\t\tans = *it;\n\t\t\ts[ans] = ')';\n\t\t\tcl.insert( ans );\n\t\t\top.erase( it );\n\t\t\tsg.add(ans+1, N+2, -2);\n\t\t}\n\t\tcout << (ans+1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000]; string s;\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0, l = r;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tsum += d[i];\n\t\t\t\tif (sum < 2) l = r;\n\t\t\t\telse if (l == r) l = i;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1); d[r] = 1, d[l] = -1;\n\t\t}\n\t\telse {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (d[j] == -1) {\n\t\t\t\t\td[j] = 1, d[r] = -1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MAXN = 300000 + 10;\n\nstruct Node {\n  int mx, ps;\n  void set(int v) {\n    mx += v; ps += v;\n  }\n} T[MAXN << 2];\nchar s[MAXN];\nint a[MAXN], n, q;\n\n#define lson (rt<<1)\n#define rson (rt<<1|1)\n#define mid ((l+r)>>1)\n\nvoid build(int rt, int l, int r) {\n  T[rt].ps = 0;\n  if (l + 1 == r) {\n    T[rt].mx = a[l];\n    return;\n  }\n  build(lson, l, mid); build(rson, mid, r);\n  T[rt].mx = min(T[lson].mx, T[rson].mx);\n}\n\nvoid psd(int rt) {\n  T[lson].set(T[rt].ps);\n  T[rson].set(T[rt].ps);\n  T[rt].ps = 0;\n}\n\nvoid ins(int rt, int l, int r, int L, int R, int v) {\n  if (L <= l && R >= r) {T[rt].set(v); return;}\n  psd(rt);\n  if (L < mid) ins(lson, l, mid, L, R, v);\n  if (R > mid) ins(rson, mid, r, L, R, v);\n  T[rt].mx = min(T[lson].mx, T[rson].mx);\n}\n\nvector<int> can;\nvoid get(int rt, int l, int r, int L, int R) {\n  if (L <= l && R >= r) {\n    can.push_back(rt);\n    return;\n  }\n  psd(rt);\n  if (L < mid) get(lson, l, mid, L, R);\n  if (R > mid) get(rson, mid, r, L, R);\n}\n\nint ask(int rt, int l, int r) {\n  if (l + 1 == r) {\n    if (T[rt].mx >= 2) return l;\n    else return r;\n  }\n  psd(rt);\n  if (T[rson].mx >= 2) return ask(lson, l, mid);\n  else return ask(rson, mid, r);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &n, &q) == 2) {\n    scanf(\"%s\", s);\n    int n = strlen(s);\n    set<int> rhs;\n    for (int i = 0; i < n; ++ i) {\n      if (i) a[i] = a[i - 1];\n      else a[i] = 0;\n      if (s[i] == '(') a[i] ++;\n      else a[i] --;\n      if (s[i] == ')') rhs.insert(i);\n    }\n    build(1, 0, n);\n    for (int i = 0; i < q; ++ i) {\n      int x; scanf(\"%d\", &x); -- x;\n      if (s[x] == '(') {\n        s[x] = ')'; rhs.insert(x);\n        ins(1, 0, n, x, n, -2);\n        x = *rhs.begin(); rhs.erase(x);\n        s[x] = '(';\n        ins(1, 0, n, x, n, 2);\n      }\n      else {\n        s[x] = '('; rhs.erase(x);\n        ins(1, 0, n, x, n, 2);\n        can.clear();\n        get(1, 0, n, 0, x + 1);\n        int rt(-1);\n        for (auto &p: can) if (T[p].mx < 2) rt = p;\n        if (rt == -1) x = 0;\n        else {\n          int l(0), r(n);\n          vector<int> bit;\n          for (int p = rt; p > 1; p >>= 1) {\n            bit.push_back(p & 1);\n          }\n          reverse(bit.begin(), bit.end());\n          for (auto &p: bit) {\n            if (p) l = (l + r) >> 1;\n            else r = (l + r) >> 1;\n          }\n          x = ask(rt, l, r);\n        }\n        s[x] = ')'; rhs.insert(x);\n        ins(1, 0, n, x, n, -2);\n      }\n      printf(\"%d\\n\", x + 1);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 700;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray1 {\n  const int B;\n  SegmentArray1(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = en - 1; i >= st; --i) {\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray1 seg1(N);\n  set<int> seg2;\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.insert(i);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.insert(p);\n      seg1.update(p, N, -2);\n      int np = *seg2.begin();\n      S[np] = '(';\n      seg2.erase(np);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      S[p] = '(';\n      seg2.erase(p);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      S[np] = ')';\n      seg2.insert(np);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define pb push_back\n#define N 300007\nvector<int> rp,lp;\nvector<int>::iterator it;\nint n,m,len;\nint a[N];\nchar str[N];\nstruct Tree{\n\tint l,r,ls,rs;\n\tint cnt[2];\n}\ttree[N<<1];\nint tot;\nvoid up(int t){\n\tfor(int i=0;i<2;++i){\n\t\ttree[t].cnt[i]=tree[tree[t].ls].cnt[i]+tree[tree[t].rs].cnt[i];\n\t}\n}\nvoid build(int l,int r){\n\tint t=++tot;\n\ttree[t].l=l,tree[t].r=r;\n\ttree[t].ls=tree[t].rs=0;\n\tif(l==r){\n\t\ttree[t].cnt[0]=tree[t].cnt[1]=0;\n\t\t++tree[t].cnt[a[l]];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(l<=mid){\n\t\ttree[t].ls=1+tot;\n\t\tbuild(l,mid);\n\t}\n\t++mid;\n\tif(mid<=r){\n\t\ttree[t].rs=1+tot;\n\t\tbuild(mid,r);\n\t}\n\tup(t);\n}\nvoid update(int t,int l,int r,int x){\n\tif(t<=0) return ;\n\tif(l==tree[t].l && r==tree[t].r){\n\t\ta[l]=x;\n\t\ttree[t].cnt[0]=tree[t].cnt[1]=0;\n\t\t++tree[t].cnt[x];\n\t\treturn ;\n\t}\n\tint mid=(tree[t].l+tree[t].r)>>1;\n\tif(r<=mid) update(tree[t].ls,l,r,x);\n\tif(l> mid) update(tree[t].rs,l,r,x);\n\tup(t);\n}\nint query(int t,int l,int r,int x){\n\tif(t<=0) return 0;\n\tif(l==tree[t].l && r==tree[t].r) return tree[t].cnt[x]-tree[t].cnt[x^1];\n\tint mid=(tree[t].l+tree[t].r)>>1;\n\tif(r<=mid) return query(tree[t].ls,l,r,x);\n\tif(l> mid) return query(tree[t].rs,l,r,x);\n\treturn query(tree[t].ls,l,mid,x)+query(tree[t].rs,mid+1,r,x);\n}\nint main(){\n\tint i,x,l,r,mid;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\" %s\",str);len=strlen(str);\n\tlp.clear();rp.clear();\n\tfor(i=0;i<len;++i)\n\tif(str[i]=='('){\n\t\ta[i+1]=0;lp.pb(i+1);\n\t}\n\telse{\n\t\ta[i+1]=1;rp.pb(i+1);\n\t}\n\ttot=0;build(1,n);\n\n\twhile(m--){\n\t\tscanf(\"%d\",&x);\n\t\t// ( -> )\n\t\tif(a[x]==0){\n\t\t\tif(rp.size()>0 && rp[0]<x){\n\t\t\t\tprintf(\"%d\\n\",rp[0]);\n\t\t\t\tupdate(1,x,x,1);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.erase(it);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.insert(it,x);\n\t\t\t\tx=rp[0];\n\t\t\t\tupdate(1,x,x,0);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.erase(it);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.insert(it,x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t}\n\t\t// ) -> (\n\t\telse{\n\t\t\tif(x==n || query(1,x+1,n,0)>=0){\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupdate(1,x,x,0);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.erase(it);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.insert(it,x);\n\t\t\t\tl=0;\n\t\t\t\tr=lower_bound(lp.begin(),lp.end(),x)-lp.begin();\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tmid=(l+r)>>1;\n\t\t\t\t\tint tmp=query(1,lp[mid],n,0);\n\t\t\t\t\tif(tmp>0){\n\t\t\t\t\t\tl=mid;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tr=mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=query(1,lp[r],n,0)>0?lp[r]:lp[l];\n\t\t\t\tupdate(1,x,x,1);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.erase(it);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.insert(it,x);\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t}\n//\t\tfor(i=1;i<=n;++i) printf(\"%c\",a[i]?')':'(');printf(\"\\n\");\n//\t\tprintf(\"( :\");for(i=0;i<(int)lp.size();++i) printf(\" %d\",lp[i]);printf(\"\\n\");\n//\t\tprintf(\") :\");for(i=0;i<(int)rp.size();++i) printf(\" %d\",rp[i]);printf(\"\\n\");\n\t}\n\treturn 0;\n}\n/*\n8 3\n()((()))\n6\n3\n1\n\n20 9\n()((((()))))()()()()\n15\n20\n13\n5\n3\n10\n3\n17\n18\n */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat1, dat2, lazy;\n\npublic:\n  SegmentTree() {}\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat1 = dat2 = lazy = vector<int>(n*2-1, 0);\n  }\n\n  inline void evaluation(int k, int l, int r) {\n    dat1[k] += (r - l) * lazy[k];\n    dat2[k] += lazy[k];\n    if (k < n-1) {\n      lazy[k*2+1] += lazy[k];\n      lazy[k*2+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      evaluation(k, l, r);\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat1[k] += dat1[k*2+1] + dat1[k*2+2];\n    dat2[k] = min(dat2[k*2+1], dat2[k*2+2]);\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat1[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        vector<int> pos;\n        for (int i = 0; i < s.size(); ++i) {\n          if (s[i] == '(') pos.push_back(i);\n        }\n        int l = 0, r = pos.size();\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(pos[m], N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << pos[r] + 1 << endl;\n        change(pos[r]);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tinline int query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tinline void update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tinline int query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - b1.query(0, r) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0);\n\t\t\td[l] = -1; b1.update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1);\n\t\t\td[pr] = 1; b1.update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#include<climits>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\n\nstruct StarrySkyTree{\n\tint n;\n\tstd::vector<long long> segv,segAdd;\n\tvoid add(int a,int b,int x,int k,int l,int r){\n\t\tif(r<=a || b<=l)return;\n\t\tif(a<=l && r<=b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tint m=(l+r)/2;\n\t\tadd(a,b,x,2*k+1,l,m);\n\t\tadd(a,b,x,2*k+2,m,r);\n\t\tsegv[k]=std::min(segAdd[2*k+1]+segv[2*k+1] ,segAdd[2*k+2]+segv[2*k+2]);\n\t}\n\tlong long min(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a || b<=l)return LLONG_MAX;\n\t\tif(a<=l && r<=b){\n\t\t\treturn segv[k]+segAdd[k];\n\t\t}\n\t\tint m=(l+r)/2;\n\t\treturn segAdd[k]+std::min(min(a,b,2*k+1,l,m),min(a,b,2*k+2,m,r));\n\t}\npublic:\n\tStarrySkyTree(int n=1<<19){\n\t\tinit(n);\n\t}\n\tvoid init(int n){\n\t\tthis->n=n;\n\t\tsegv.assign(2*n-1,0);\n\t\tsegAdd.assign(2*n-1,0);\n\t}\n\tvoid add(int a,int b,int x){//[a,b)にxを加算\n\t\tadd(a,b,x,0,0,n);\n\t}\n\tlong long min(int a,int b)const{//[a,b)の最小値\n\t\treturn min(a,b,0,0,n);\n\t}\n};\n\n\n\nint main(){\n\tStarrySkyTree sst;\n\tset<int> s;\n\tstring str;\n\tint n,q;\n\tcin>>n>>q>>str;\n\trep(i,n){\n\t\tif(str[i]=='(')sst.add(i,n,1);\n\t\telse{\n\t\t\tsst.add(i,n,-1);\n\t\t\ts.insert(i);\n\t\t}\n\t}\n\trep(i,q){\n\t\tint p;\n\t\tcin>>p;\n\t\tp--;\n\t\tint lb,ub,ans;\n\t\tif(str[p]=='('){\n\t\t\tstr[p]=')';\n\t\t\tsst.add(p,n,-2);\n\t\t\ts.insert(p);\n\t\t\tans=*s.begin();\n\t\t\tstr[ans]='(';\n\t\t\tsst.add(ans,n,2);\n\t\t\ts.erase(ans);\n\t\t\tans++;\n\t\t}else{\n\t\t\tstr[p]='(';\n\t\t\tsst.add(p,n,2);\n\t\t\ts.erase(p);\n\t\t\tlb=-1;ub=n-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(sst.min(m,n)>=2)ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tstr[ub]=')';\n\t\t\tsst.add(ub,n,-2);\n\t\t\ts.insert(ub);\n\t\t\tans=ub+1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> lp,rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,0));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                assert(s[l+1]=='(');\n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n  };\n  \n  const D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D &a,D &b){\n    if(a.value < b.value) return a;\n    return b;\n  }\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  Int a, b, x, flg;  \n  D add2(Int k,Int l,Int r){\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add2(k*2+1,l,(l+r)/2);\n    D vr = add2(k*2+2,(l+r)/2,r);\n    if(flg) return dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n\n  void add(Int a,Int b,Int x){\n    assert(a <= n && b <= n);\n    if(toMax) x*= -1;\n    this->a = a;\n    this->b = b;\n    this->x = x;\n    this->flg = true;\n    add2(0, 0, n);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    this->a = a;\n    this->b = b;\n    this->flg = false;\n    D res = add2(0, 0, n);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nsigned main(){\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    Int val = s[x] == '('? -2:2;\n    A.add(x, n, val);\n    Int res = A.find(0, n) >= 0 && A.find(n-1, n) == 0;\n    A.add(x, n, -val);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    return *par.lower_bound(R);\n  };\n\nfor(Int i=0;i<q;i++){\n  Int x;\n  scanf(\"%lld\", &x); x--;\n  rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    printf(\"%lld\\n\",y+1);\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\n\nint  main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(n);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='(')\n\tST.add(i,n,1);\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  int p=0;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{\n\t      p=str.find('(',p+1);\n\t    }while(ST.get_min(p,n)<2);\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fto(i, l, r) for(int i = l; i <= r; ++i)\n#define fdto(i, r, l) for(int i = r; i >= l; --i)\n#define debug(a) cout << #a << \": \" << a << endl\n\nusing namespace std;\nconst int oo = 1000000007;\nconst int MAXN = 300005; \n\nint n, q;\nchar s[MAXN];\nset<int> pos;\n\nstruct Node {\n  int m, val;\n};\n\nNode t[4*MAXN];\n\nvoid propagate(const int &id, const int &l, const int &r) {\n  int &x = t[id].val;\n  if (x != 0) {\n    fto(i, 0, 1) {\n      t[2*id + i].m += x;\n      t[2*id + i].val += x;\n    }\n    x = 0;\n  }\n}\n\nvoid update(int id, int l, int r, const int &i, const int &j, const int &x) {\n  if (j < l || i > r) return;\n  if (i <= l && r <= j) {\n    t[id].val += x;\n    t[id].m += x;\n    return;\n  }\n  // printf(\"%d %d %d %d\\n\", id, l, r, t[id].m);\n  propagate(id, l, r);\n  int m = (l + r)/2;\n  update(2*id, l, m, i, j, x); update(2*id+1, m+1, r, i, j, x);\n  t[id].m = min(t[2*id].m, t[2*id+1].m);\n}\n\nvoid check(int id, int l, int r) {\n  // printf(\"%d %d %d %d %d\\n\", id, l, r, t[id].m, t[id].val);\n  if (l < r) {\n    int m = (l+r)/2;\n    check(2*id, l, m);\n    check(2*id+1, m+1, r);\n  }  \n}\n\nint query(int id, int l, int r, const int x) {\n  // printf(\"%d %d %d %d %d\\n\", id, l, r, x, t[id].m);\n  if (t[id].m >= x)\n    return l;\n  if (l == r)\n    return l+1;\n  propagate(id, l, r);\n  int m = (l+r)/2;\n  int ans = query(2*id+1, m+1, r, x);\n  if (ans == m+1)\n    ans = query(2*id, l, m, x);\n  return ans;\n}\n\nvoid flip(int i) {\n  if (s[i] == '(') {\n    s[i] = ')';\n    update(1, 0, n-1, i, n-1, -2);\n    pos.insert(i);\n  } else {\n    s[i] = '(';\n    update(1, 0, n-1, i, n-1, 2);\n    pos.erase(i);\n  }\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  scanf(\"%s\", s);\n\n  fto(i, 0, n-1) {\n    // debug(i);\n    if (s[i] == ')') {\n      pos.insert(i);\n      update(1, 0, n-1, i, n-1, -1);\n    } else \n      update(1, 0, n-1, i, n-1, 1);\n  }\n\n  // check(1, 0, n-1);\n\n  fto(i, 1, q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n\n    // debug(i);\n    int ans;\n    if (s[p] == '(') {\n      flip(p);\n      ans = *pos.begin();\n    } else {\n      flip(p);\n      // if (i == 2)\n      //   check(1, 0, n-1);\n      ans = query(1, 0, n-1, 2);\n    }\n    \n    flip(ans);\n    // printf(\"%s\\n\", s);\n    // for(int x: pos)\n    //   printf(\"%d \", x);\n    // puts(\"\");\n    printf(\"%d\\n\", ans+1);\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1 << 19;\nconst ll INF = 1LL << 50;\n\nstruct MinSegTree2{\n\tstatic const ll def = INF;\n\tint n;\n\tll segMin[2 * MAX_N - 1], segAdd[2 * MAX_N - 1];\n\tvoid init(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) segMin[i] = def, segAdd[i] = 0;\n\t}\n\n\tvoid add(int a, int b, ll x){ add(a, b, x, 0, 0, n); }\n\n\tvoid add(int a, int b, ll x, int k, int l, int r){\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tsegMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n\t}\n\n\tvoid set(int i, ll x){\n\t\tll y = query(i, i + 1);\n\t\tadd(i, i + 1, -y + x);\n\t}\n\n\tll query(int a, int b){ return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return def;\n\t\tif(a <= l && r <= b) return segMin[k] + segAdd[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr) + segAdd[k];\n\t}\n};\n\nMinSegTree2 minst;\n\nint N;\nstring s;\n\nset<int> O, C;\n\nvoid flip(int i){\n\tif(s[i] == '('){\n\t\ts[i] = ')';\n\t\tO.erase(i);\n\t\tC.insert(i);\n\t\tminst.add(i, N, -2);\n\t}\n\telse{\n\t\ts[i] = '(';\n\t\tC.erase(i);\n\t\tO.insert(i);\n\t\tminst.add(i, N, +2);\n\t}\n}\n\nvoid debug(){\n\tcout << s << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tcout << minst.query(i, i + 1) << \" \";\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint Q;\n\tcin >> N >> Q >> s;\n\n\tminst.init(N);\n\tint cnt = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '('){\n\t\t\tO.insert(i);\n\t\t\tcnt++;\n\t\t\tminst.set(i, cnt);\n\t\t}\n\t\telse{\n\t\t\tC.insert(i);\n\t\t\tcnt--;\n\t\t\tminst.set(i, cnt);\n\t\t}\n\t}\n\n\t//debug();\n\n\twhile(Q--){\n\t\tint k;\n\t\tcin >> k;\n\t\tk--;\n\t\tchar c = s[k];\n\t\tflip(k);\n\t\t//debug();\n\t\tint ans = k;\n\n\t\tif(c == '('){\n\t\t\t// CLOSE -> OPEN\n\t\t\t// ????????????CLOSE\n\t\t\tans = *C.begin();\n\t\t}\n\t\telse{\n\t\t\t// OPEN -> CLOSE\n\t\t\t// [i, n) >= 2 ????????????????°????i\n\t\t\tint ng = 0, ok = k;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tauto it = O.lower_bound(mid);\n\t\t\t\tif(it == O.end()){\n\t\t\t\t\tng = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint a = *it;\n\t\t\t\tif(minst.query(a, N) >= 2) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tans = *O.lower_bound(ok);\n\t\t}\n\n\t\tcout << ans + 1 << endl;\n\t\tflip(ans);\n\t\t//debug();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MAX 2000100\n#define N 600100\n\nint n, m, qidx;\nchar str[N];\nint minval[MAX], flag[MAX], prefix[MAX];\nmap<int, int> ridxs;\n\ninline void push_down(int left, int right, int idx){\n  if(left == right){\n    minval[idx] += flag[idx];\n    flag[idx] = 0;\n    return;\n  }\n  \n  minval[idx] += flag[idx];\n  flag[idx << 1] += flag[idx];\n  flag[idx << 1 | 1] += flag[idx];\n  flag[idx] = 0;\n}\n\ninline void push_up(int left, int right, int idx){\n  if(left == right){ push_down(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  push_down(left, right, idx);\n  push_down(left, mid, idx << 1);\n  push_down(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\ninline int query(int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end) return minval[idx];\n  \n  int mid = (left + right) >> 1, res;\n  if(end <= mid) res = query(start, end, left, mid, idx << 1);\n  else if(mid < start) res = query(start, end, mid + 1, right, idx << 1 | 1);\n  else res = min(query(start, end, left, mid, idx << 1), query(start, end, mid + 1, right, idx << 1 | 1));\n  return res;\n}\n\ninline void update(int val, int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end){ flag[idx] += val; push_up(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  if(end <= mid) update(val, start, end, left, mid, idx << 1);\n  else if(mid < start) update(val, start, end, mid + 1, right, idx << 1 | 1);\n  else{\n    update(val, start, end, left, mid, idx << 1);\n    update(val, start, end, mid + 1, right, idx << 1 | 1);\n  }\n  push_up(left, right, idx);\n}\n\ninline void build(int left, int right, int idx){\n  if(left == right){ minval[idx] = prefix[left]; return; }\n\n  int mid = (left + right) >> 1;\n  build(left, mid, idx << 1);\n  build(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\nint main(){\n  while(scanf(\"%d%d\", &n, &m) == 2){\n    ridxs.clear();\n    memset(flag, 0, sizeof(flag));\n    \n    scanf(\"%s\", str + 1);\n    \n    prefix[0] = 0;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + (str[i] == '(' ? 1 : -1);\n    for(int i = 1; i <= n; i++) if(str[i] == ')') ridxs[i] = 1;\n    \n    build(1, n, 1);\n    \n    int ans;\n    for(int i = 1; i <= m; i++){\n      scanf(\"%d\", &qidx);\n      \n      if(str[qidx] == '('){\n        ridxs[qidx] = 1;\n        ans = ridxs.begin()->first;\n        ridxs.erase(ridxs.find(ans));\n        str[qidx] = ')'; str[ans] = '(';\n        if(ans != qidx) update(2, ans, qidx - 1, 1, n, 1);\n      }\n      else{\n        if(query(qidx - 1, qidx - 1, 1, n, 1) < 2) ans = qidx;\n        else{\n          int lidx = 1, ridx = qidx - 1;\n          while(ridx - lidx > 1){\n            int mid = (lidx + ridx) >> 1;\n            if(query(mid, ridx, 1, n, 1) < 2) lidx = mid;\n            else ridx = mid;\n          }\n          ans = ridx;\n          \n          update(-2, ans, qidx - 1, 1, n, 1);\n          ridxs.erase(ridxs.find(qidx));\n          ridxs[ans] = 1;\n          str[qidx] = '('; str[ans] = ')';\n        }\n      }\n         \n      printf(\"%d\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int INF = 1e9+9;\n\n// ????????????????????±\ntemplate <typename T, T INIT>\nstruct node {\n\tT v, lazy;\n\tnode(){\n\t\tv = INIT;\n\t\tlazy = 0;\n\t}\n\t// ?????????????????´??°\n\tvoid update(T _v){\n\t\tv = _v;\n\t}\n\t// ??????????????´??°\n\tvoid merge(T vl, T vr){\n\t\tv = min(vl, vr);\n\t}\n\t// ????????????????????????\n\tT get(){\n\t\treturn v;\n\t}\n\t// ??????????????´??°(lazy?????¨)\n\tT add(int l, int r, T _v=0){\n\t\tT sum = lazy + _v;\n\t\tv += sum;\n\t\tlazy = 0;\n\t\treturn sum;\n\t}\n\t// ?????????????????¶???????????????\n\tvoid addLazy(T v){\n\t\tlazy += v;\n\t}\n};\n\ntemplate <typename T, typename NODE=node<T,INF> >\nclass SegTree{\n\t// ?????¶??????????????¨??????\n\tvoid propLazy(int a, int b, int k, T v=0){\n\t\tT lazy = data[k].add(a, b, v);\n\t\tif( k < N ){\n\t\t\tdata[k*2+0].addLazy(lazy);\n\t\t\tdata[k*2+1].addLazy(lazy);\n\t\t}\n\t}\n\t// ?????°??????????????????????????????\n\tT prop(int l, int r, T v, int a, int b, int k=1){\n\t\t// ??????\n\t\tpropLazy(a, b, k);\n\t\t// ?????????\n\t\tNODE nd;\t// ??????????????¨(??????????????´????????????????????????)\n\t\tif( l <= a && b <= r ){\n\t\t\t// ?????¨?????????????????´???\n\t\t\tpropLazy(a, b, k, v);\n\t\t\treturn data[k].get();\n\t\t}else if( l < b && a < r ){\n\t\t\t// ?????????????????????????????´???\n\t\t\tint m = (a+b) / 2;\n\t\t\tT vl = prop(l,r,v, a, m, k*2);\n\t\t\tT vr = prop(l,r,v, m, b, k*2+1);\n\t\t\tdata[k].merge( data[k*2].get(), data[k*2+1].get() );\n\t\t\tnd.merge( vl, vr );\n\t\t}\n\t\treturn nd.get();\n\t}\n\npublic:\n\tvector<NODE> data;\n\tint N;\n\tSegTree(int _N){\n\t\t// _N <= (N = 2^k) ???????????????\n\t\tN = 1;\n\t\twhile( N < _N ) N<<=1;\n\t\tdata.resize(N*2);\n\t}\n\t// ?????°???????????????????????´??°\n\tvoid update(int l, T v){\n\t\tprop(l, l+1, v-get(l), 0, N);\n\t}\n\t// ?????°???????????????????????´??°(???????????????)\n\tT add(int l, int r, T v){\n\t\treturn prop(l,r,v,0,N);\n\t}\n\t// ???????????? [l,r)\n\tT get(int l, int r=-1){\n\t\tif( r == -1 ) r = l+1;\n\t\treturn prop(l,r,0,0,N);\n\t}\n};\n\n\n\n// ?¢????\n\n#include <algorithm>\n#include <set>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\ntypedef pair<int,int> pii;\n\n\n// AOJ DSL_2_A\n/*\nconst ll INF2 = ((ll)1<<31) - (ll)1;\nSegTree<ll,node<ll,INF2> > sg(100005);\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\trep(i,q){\n\t\tint c, x, y;\n\t\tcin >> c >> x >> y;\n\t\tif( c == 0 ){\n\t\t\tsg.update(x, y);\n\t\t}else{\n\t\t\ty++;\n\t\t\tcout << sg.get(x, y) << endl;\n\t\t}\n\t\t//rep(j,18) cout << sg.data[j].get() << \" \"; cout << endl;\n\t}\n\treturn 0;\n}\n*/\n\n\n// arc026_C\n/*\nSegTree<ll,node<ll,(ll)1e12> > sg(100005);\nint main(){\n\tint N, L;\n\tint l[100005], r[100005], c[100005];\n\tvector<pii> v;\n\n\tcin >> N >> L;\n\trep(i,N){\n\t\tcin >> l[i] >> r[i] >> c[i];\n\t\tv.emplace_back( r[i], i );\n\t}\n\tsort( all(v) );\n\n\tsg.update(0,0);\n\tfor(auto p: v){\n\t\tint i = p.second;\n\t\tll tmp = min( sg.get(r[i]), sg.get(l[i], r[i]) + (ll)c[i] );\n\t\tsg.update( r[i], tmp );\n\t}\n\n\tcout << sg.get(L) << endl;\n\n\treturn 0;\n}\n*/\n\n\n// ????????§?¢????\n/*\nSegTree<int,node<int,99> > sg(8);\nint main(){\n\tint q, x, y, v;\n\tsg.add(0,8,-99);\n\twhile(cin>>q>>x>>y){\n\t\tif( q == 0 ){\n\t\t\tcin >> v;\n\t\t\tsg.add(x,y,v);\n\t\t}else{\n\t\t\tcout << \"get : \" << sg.get(x,y) << endl;\n\t\t}\n\t\t// ?????°??????????????¶????????¨???\n\t\trep(i,sg.data.size()){\n\t\t\tif( __builtin_popcount(i) == 1 ) cout << endl;\n\t\t\tcout << sg.data[i].v << \"(\" << sg.data[i].lazy << \")\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n*/\n\n\n// ICPC 2014 Tokyo Regional G\nSegTree<int> sg(300005);\nint N, Q;\nstring s;\nint q[200005];\nset<int> op, cl;\nvoid flip(int i){\n\tif(s[i] == '('){\n\t\ts[i] = ')';\n\t\tcl.insert( i );\n\t\tif(op.find(i) != op.end() ) op.erase( op.find(i) );\n\t\tsg.add(i+1, N+2, -2);\n\t}else{\n\t\ts[i] = '(';\n\t\top.insert( i );\n\t\tif(cl.find(i) != cl.end() ) cl.erase( cl.find(i) );\n\t\tsg.add(i+1, N+2, 2);\n\t}\n}\nint main(){\n\tcin >> N >> Q >> s;\n\trep(i,Q){\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t}\n\t\n\tint sum = 0;\n\trep(i,N+1){\n\t\tsg.update(i, sum);\n\t\tif( s[i] == ')' ){\n\t\t\tcl.insert(i);\n\t\t\tsum--;\n\t\t}else{\n\t\t\top.insert(i);\n\t\t\tsum++;\n\t\t}\n\t}\n\n\trep(i,Q){\n\t\tint ans;\n\t\tflip(q[i]);\n\t\tif( s[q[i]] == ')' ){\n\t\t\tans = *cl.begin();\n\t\t}else{\n\t\t\tint l=1, r=N+2;\n\t\t\twhile( r-l > 1 ){\n\t\t\t\tint m = (l+r) / 2;\n\t\t\t\tsg.add(m, N+2, -2);\n\t\t\t\tif( sg.get(m, N+2) >= 0 ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t\tsg.add(m, N+2, 2);\n\t\t\t}\n\t\t\tans = *op.upper_bound( l-1 );\n\t\t}\n\t\tflip(ans);\n\t\tcout << (ans+1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*aoj2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;\n    process_lazy(k);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k) {\n    if (k < n - 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k) {\n    if (k >= n - 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,b)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int b, int k, int l, int r, int val) {\n    if (b <= l) return -2;\n    process_lazy(k);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    int ret_r = getLeftGt(b, RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2 || ret_r == -1) return ret_r;\n    int ret_l = getLeftGt(b, LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(n, 0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define lson rt<<1\n#define rson rt<<1|1\n#define mid ((l+r)>>1)\n#define clr(a, b) memset(a, b, sizeof(a))\ninline int min(int a, int b){return a<b?a:b;}\nconst int MAX_N = 300010;\nstruct SegTree{\n\tint f, a, lazy;\n}node[MAX_N << 2];\nchar s[MAX_N];\nint N, Q, k;\n\nvoid pushup(int rt){\n\tnode[rt].a = min(node[lson].a, node[rson].a);\n\tnode[rt].f = min(node[lson].f, node[rson].f);\n}\n\nvoid pushdown(int rt){\n\tif (node[rt].lazy){\n\t\tnode[lson].lazy += node[rt].lazy;\n\t\tnode[rson].lazy += node[rt].lazy;\n\t\tnode[lson].a += node[rt].lazy;\n\t\tnode[rson].a += node[rt].lazy;\n\t\tnode[lson].f += node[rt].lazy;\n\t\tnode[rson].f += node[rt].lazy;\n\t\tnode[rt].lazy = 0;\n\t}\n}\n\nvoid build(int l, int r, int rt, int a, int p){\n\tnode[rt].lazy = 0;\n\tif(l == r){\n\t\tnode[rt].f = a - l;\n\t\tnode[rt].a = a;\n\t\treturn ;\n\t}\n\tif (p <= mid) build(l, mid, lson, a, p);\n\telse build(mid+1, r, rson, a, p);\n\tpushup(rt);\n}\n\nvoid init(){\n\tclr(node, 0);\n\tint sum = 0;\n\tfor (int i = 1;i <= N;++i){\n\t\tsum += (s[i] == '(' ? 1 : -1);\n\t\tbuild(1, N, 1, sum, i);\n\t}\n}\n\nvoid update(int L, int R, int val, int l, int r, int rt){\n\tif (L <= l && r <= R){\n\t\tnode[rt].lazy += val;\n\t\tnode[rt].f += val;\n\t\tnode[rt].a += val;\n\t\treturn ;\n\t}\n\tpushdown(rt);\n\tif (L <= mid)\tupdate(L, R, val, l, mid, lson);\n\tif (R > mid)\tupdate(L, R, val, mid+1, r, rson);\n\tpushup(rt);\n}\n\nint query1(int l, int r, int rt){\n\tif (l == r)\treturn l;\n\tpushdown(rt);\n\tif (node[lson].f < 0)\treturn query1(l ,mid, lson);\n\treturn query1(mid+1, r, rson);\n}\n\nint query2(int l, int r, int rt){\n\tif (l == r)\treturn l+1;\n\tpushdown(rt);\n\tif (node[rson].a < 2)\treturn query2(mid+1, r, rson);\n\treturn query2(l, mid, lson);\t\n}\n\nint main(){\n\twhile (~scanf(\"%d %d\", &N, &Q)){\n\t\tscanf(\"%s\", s+1);\n\t\tinit();\n\t\twhile (Q--){\n\t\t\tscanf(\"%d\", &k);\n\t\t\tbool flag = (s[k] == '(');\n\t\t\ts[k] = flag ? ')' : '(';\n\t\t\tupdate(k, N, flag ? -2 : 2, 1, N, 1);\n\t\t\tk = (flag ? query1(1, N, 1) : query2(1, N, 1));\n\t\t\tflag = (s[k] == '(');\n\t\t\ts[k] = flag ? ')' : '(';\n\t\t\tupdate(k, N, flag ? -2 : 2, 1, N, 1);\n\t\t\tprintf(\"%d\\n\", k);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 550;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      //DEBUG(S);\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      //DEBUG(S);\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n    //DEBUG(S);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nconst int p2=1<<19;\nint N,Q;\nstring s;\nint segm[p2*2],sega[p2*2],inf=1e8;\nset<int> st;\nvoid add(int a,int b,int l,int r,int k,int x){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tsega[k]+=x;\n\t\treturn;\n\t}\n\tadd(a,b,l,(l+r)/2,k*2+1,x);\n\tadd(a,b,(l+r)/2,r,k*2+2,x);\n\tsegm[k]=min(segm[k*2+1]+sega[k*2+1],segm[k*2+2]+sega[k*2+2]);\n}\nvoid change(int x){\n\tif(s[x]=='('){\n\t\ts[x]=')';\n\t\tst.insert(x);\n\t\tadd(x,p2,0,p2,0,-2);\n\t}else{\n\t\ts[x]='(';\n\t\tst.erase(x);\n\t\tadd(x,p2,0,p2,0,2);\n\t}\n}\nint getmin(int a,int b,int l,int r,int k){\n\tif(b<=l||r<=a) return inf;\n\tif(a<=l&&r<=b) return segm[k]+sega[k];\n\treturn min(getmin(a,b,l,(l+r)/2,k*2+1),getmin(a,b,(l+r)/2,r,2*k+2))+sega[k];\n}\nint main(){\n\tcin>>N>>Q;\n\tcin>>s;\n\trep(i,N) if(s[i]==')') st.insert(i);\n\trep(i,p2) segm[p2-1+i]=inf;\n\trep(i,N) segm[p2-1+i]=segm[p2-2+i]+(s[i]=='('?1:-1);\n\tfor(int i=p2-2;i>=0;i--){\n\t\tsegm[i]=min(segm[i*2+1],segm[i*2+2]);\n\t}\n\trep(i,Q){\n\t\tint q;\n\t\tcin>>q;\n\t\tq--;\n\t\tif(s[q]=='('){\n\t\t\tchange(q);\n\t\t\tint a=*st.begin();\n\t\t\tcout<<a+1<<endl;\n\t\t\tchange(a);\n\t\t}else{\n\t\t\tchange(q);\n\t\t\tint ub=q,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tif(getmin(m,q+1,0,p2,0)>=2) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tcout<<ub+1<<endl;\n\t\t\tchange(ub);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = (n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (n) - 1; (i) >= int(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\n\nconst int inf = 1e9+7;\nstruct starry_sky_tree {\n    int n;\n    vector<int> a, b; // add, min\n    explicit starry_sky_tree(int a_n) {\n        n = pow(2, ceil(log2(a_n)));\n        a.resize(2 * n - 1); // fill 0, unit of add\n        b.resize(2 * n - 1); // fill 0, unit of add\n    }\n    void range_add(int l, int r, int z) {\n        range_add(0, 0, n, l, r, z);\n    }\n    void range_add(int i, int il, int ir, int l, int r, int z) {\n        if (l <= il and ir <= r) {\n            a[i] += z;\n            b[i] += z;\n        } else if (ir <= l or r <= il) {\n            // nop\n        } else {\n            range_add(2 * i + 1, il, (il + ir) / 2, l, r, z);\n            range_add(2 * i + 2, (il + ir) / 2, ir, l, r, z);\n            b[i] = a[i] + min(b[2 * i + 1], b[2 * i + 2]); // min\n        }\n    }\n    int range_min(int l, int r) {\n        return range_min(0, 0, n, l, r);\n    }\n    int range_min(int i, int il, int ir, int l, int r) {\n        if (l <= il and ir <= r) {\n            return b[i];\n        } else if (ir <= l or r <= il) {\n            return inf; // unit of min\n        } else {\n            return a[i] + min( // min\n                    range_min(2 * i + 1, il, (il + ir) / 2, l, r),\n                    range_min(2 * i + 2, (il + ir) / 2, ir, l, r));\n        }\n    }\n};\n\ntemplate <typename UnaryPredicate>\nll binsearch(ll l, ll r, UnaryPredicate p) { // [l, r), p is monotone\n    assert (l < r);\n    -- l;\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        (p(m) ? r : l) = m;\n    }\n    return r; // = min { x in [l, r) | p(x) }, or r\n}\n\nint parentoi(char c) { return c == '(' ? + 1 : - 1; }\nint main() {\n    int n, queries; cin >> n >> queries;\n    string s; cin >> s;\n    starry_sky_tree nest(n);\n    starry_sky_tree lparen(n);\n    REP (i, n) {\n        nest.range_add(i, n, parentoi(s[i]));\n        if (s[i] == '(') lparen.range_add(i, i + 1, 1);\n    }\n    auto flip = [&](int i) {\n        nest.range_add(i, n, - parentoi(s[i]));\n        if (s[i] == '(') lparen.range_add(i, i + 1, -1);\n        s[i] = (s[i] == '(' ? ')' : '(');\n        nest.range_add(i, n,   parentoi(s[i]));\n        if (s[i] == '(') lparen.range_add(i, i + 1,  1);\n    };\n    while (queries --) {\n        int q; cin >> q; -- q;\n        flip(q);\n        int result = -1;\n        if (s[q] == '(') {\n            result = binsearch(0, n, [&](int i) {\n                return nest.range_min(i, n) >= 2;\n            });\n        } else {\n            result = binsearch(0, n, [&](int i) {\n                return lparen.range_min(0, i + 1) == 0;\n            });\n        }\n        cout << result + 1 << endl;\n        flip(result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// Computational cost: O( N + Q log N )\n// using segment trees for paren depths and # of close parens + 1-pass search\n\nint ge_pow2(int n)\n{\n  int N = 1;\n  for(int i = n; i > 0; i >>= 1, N<<=1 );\n  if(2*n == N) N = n;\n  return N;\n}\n\n// segment tree (min, max, sum)?\n// lazy updates for (min,max) only\nstruct tree {\n  static const int BIG = 2*512*1024;\n  vector<int> ds;  // min. depth of open parens\n  vector<int> ds2; // max. depth of open parens\n  vector<int> ods;\n  vector<int> ss;  // close paren -> 1: sum of close parens\n  vector<int> us;\n  const int n;\n  const int N;\n  tree(const vector<char> &ps) : n(ps.size()), N(ge_pow2(n)) {\n    ds.resize(2*N);\n    ds2.resize(2*N);\n    ss.resize(2*N);\n    us.resize(2*N);\n    ods.resize(2*N);\n    for(int i = 0; i < 2*N; i++) {\n      us[i] = 0;\n      ds[i] = BIG;\n      ds2[i] = -BIG;\n      ods[i] = BIG;\n      ss[i] = 0;\n    }\n    int d = 0;\n    for(int i = 0; i < n; i++) {\n      if(ps[i] == ')') {\n        ods[i+N] = d;\n        ds[i+N] = BIG;\n        ds2[i+N] = -BIG;\n        d--;\n        ss[i+N] = 1;\n      } else {\n        ods[i+N] = d;\n        ds[i+N] = d;\n        ds2[i+N] = d;\n        d++;\n      }\n    }\n    // initialize the internal nodes\n    for(int i = N-1; i > 0; i--) {\n      ds[i] = min(ds[i*2], ds[i*2+1]);\n      ds2[i] = max(ds2[i*2], ds2[i*2+1]);\n      ss[i] = ss[i*2] + ss[i*2+1];\n    }\n  }\n  int rightmost_open_2nd() {\n    return rightmost_open_2nd_rec(1, 0, N);\n  }\n  int rightmost_open_2nd_rec(int k, int l, int r) {\n    if(r - l == 1) return k - N;\n    if(us[k] != 0) {\n      push(2*k  , us[k], l, (l+r)/2);\n      push(2*k+1, us[k], (l+r)/2, r);\n      us[k] = 0;\n    }\n    if( ds[2*k+1] <= 1 && 1 <= ds2[2*k+1] ) {\n      return rightmost_open_2nd_rec(2*k+1, (l+r)/2, r);\n    } else {\n      return rightmost_open_2nd_rec(2*k, l, (l+r)/2);\n    }\n  }\n  int leftmost_close() {\n    return leftmost_close_rec(1, 0, N);\n  }\n  int leftmost_close_rec(int k, int l, int r) {\n    if(r - l == 1) return k - N;\n    if( ss[2*k] >= 1 ) {\n      return leftmost_close_rec(2*k, l, (l+r)/2);\n    } else {\n      return leftmost_close_rec(2*k+1, (l+r)/2, r);\n    }\n  }\n  void open(int j) {\n    write_s(j, 0);\n    clear(j, 1, 0, N); // path clear (to make ods[N+j] valid);\n    write_d(j, ods[N+j]); // put the depth ods[N+j]\n    update_region(j+1, n, 1, 2, 0, N);  // update the depths by +2\n  }\n  void close(int j) {\n    write_s(j, 1);\n    write_d(j, BIG); // remove the depth \n    update_region(j+1, n, 1, -2, 0, N);  // update the depths by -2\n  }\n  void write_s(int i, int v) {\n    i += N;\n    ss[i] = v;\n    for(i >>=1; i > 0; i >>=1) ss[i] = ss[i*2] + ss[i*2+1];\n  }\n  void clear(int i, int k, int l, int r) {\n    min_max_d2(i, i+1, k, l, r);\n  }\n  void write_d(int i, int v) {\n    clear(i, 1, 0, N); // clear the path\n    i += N;\n    ds[i] = v;\n    ds2[i] = v > n ? -v : v;\n    for(i >>=1; i > 0; i >>=1) {\n      ds[i]  = min(ds[i*2] , ds[i*2+1] );\n      ds2[i] = max(ds2[i*2], ds2[i*2+1]);\n    }\n  }\n  void push(int k, int u, int l, int r) {\n    us[k] += u;\n    ds[k] += u;\n    ds2[k] += u;\n    if(l - r == -1) { ods[k] += u; us[k] = 0; }\n  }\n  void min_max_d2(int i, int j, int k, int l, int r) {\n    if(r <= i || j <= l) return;\n    if(us[k] != 0) {\n      push(2*k  , us[k], l, (l+r)/2);\n      push(2*k+1, us[k], (l+r)/2, r);\n      us[k] = 0;\n    }\n    if(i <= l && r <= j) {\n      // usually, returns the values here.\n      return;\n    }\n    min_max_d2(i, j, k*2    , l, (l+r)/2);\n    min_max_d2(i, j, k*2 + 1, (l+r)/2, r);\n  }\n  void update_region(int i, int j, int k, int v, int l, int r) {\n    if(r <= i || j <= l) return;\n    if(i <= l && r <= j) {\n      push(k, v, l, r);\n    } else {\n      update_region(i, j, k*2    , v, l, (l+r)/2);\n      update_region(i, j, k*2 + 1, v, (l+r)/2, r);\n      ds[k]  = min(ds[k*2] , ds[k*2+1] );\n      ds2[k] = max(ds2[k*2], ds2[k*2+1]);\n    }\n  }\n  bool is_close(int j) {\n    return ss[j+N] == 1;\n  }\n};\n  \nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  int q;\n  cin >> q;\n  vector<char> ps;\n  for(int i = 0; i < n; i++) {\n    char p;\n    cin >> p;\n    ps.push_back(p);\n  }\n  tree t(ps);\n  for(int i = 0; i < q; i++) {\n    int j;\n    cin >> j;\n    j--;\n    if(t.is_close(j)) {\n      t.open(j);\n      int k = t.rightmost_open_2nd();\n      cout << (k+1) << endl;\n      t.close(k);\n    } else {\n      t.close(j);\n      int k = t.leftmost_close();\n      cout << (k+1) << endl;\n      t.open(k);\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef long long ll;\n\nstruct T {\n  ll v;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\nint n,m;\nchar s[333333];\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      root = add(root,l,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct StarrySky {\n  vector<int> data, plus;\n  int sz;\n  StarrySky(int n) {\n    sz = 1; while(sz < n) sz <<= 1;\n    data.resize(2*sz-1, 0);\n    plus.resize(2*sz-1, 0);\n  }\n  void add(int a, int b, int x, int k, int l, int r) {\n    if(r <= a || b <= l) return;\n    if(a <= l && r <= b) {\n      plus[k] += x;\n      return;\n    }\n    add(a, b, x, 2*k+1, l, (l+r)/2);\n    add(a, b, x, 2*k+2, (l+r)/2, r);\n    data[k] = min(data[2*k+1]+plus[2*k+1], data[2*k+2]+plus[2*k+2]);\n  }\n  void add(int a, int b, int x) {\n    add(a, b, x, 0, 0, sz);\n  }\n  int query(int a, int b, int k, int l, int r) {\n    if(r <= a || b <= l) return inf;\n    if(a <= l && r <= b) return data[k]+plus[k];\n    return min(query(a, b, 2*k+1, l, (l+r)/2),\n\t       query(a, b, 2*k+2, (l+r)/2, r)) + plus[k];\n  }\n  int query(int a, int b) {\n    return query(a, b, 0, 0, sz);\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, Q;\n  string s;\n  cin >> N >> Q >> s;\n  StarrySky ss(N);\n  set<int> st;\n  rep(i, N) {\n    if(s[i] == '(') {\n      ss.add(i, N, 1);\n    } else {\n      ss.add(i, N, -1);\n      st.insert(i);\n    }\n  }\n  while(Q--) {\n    int q; cin >> q; q--;\n    //cout<<s[q]<<endl;\n    if(s[q] == '(') {\n      s[q] = ')';\n      st.insert(q);\n      ss.add(q, N, -2);\n      int idx = *st.begin();\n      s[idx] = '(';\n      st.erase(idx);\n      ss.add(idx, N, 2);\n      cout << idx+1 << endl;\n    } else {\n      s[q] = '(';\n      st.erase(q);\n      ss.add(q, N, 2);\n      int lb = 0, ub = q;\n      while(lb+1 < ub) {\n\tint mb = (lb+ub)/2;\n\tif(ss.query(mb, N) > 1) ub = mb;\n\telse lb = mb;\n      }\n      //cout<<ss.query(ub, N)<<endl;\n      s[ub] = ')';\n      st.insert(ub);\n      ss.add(ub, N, -2);\n      cout << ub+1 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n  };\n  \n  D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D &a,D &b){\n    if(a.value < b.value) return a;\n    return b;\n  }\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D add(Int a,Int b,Int x,bool flg=true,Int k=0,Int l=0,Int r=-1){\n    if(r==-1 && toMax) x *= -1; \n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = add(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    D res = add(a,b,0,false);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    rev(x);\n    Int res = 1;\n    if(A.find(0, n) < 0) res = 0;\n    if(A.find(n-1, n) != 0) res = 0;\n    rev(x);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(it == par.end()) {R = M;continue;}\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    \n    return *par.lower_bound(R);\n  };\n\n  srand((unsigned)time(NULL));\n  for(Int i=0;i<q;i++){\n    Int x;\n    cin>>x; x--;\n    rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    cout<<y+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n \nstruct segtree{\n  vector<int> datasum;\n  vector<int> delay;\n   \n  int n;\n   \n  void init(int _n){\n    n = 1;\n    while( n < _n ) n *= 2;\n    datasum.resize( 2 * n );\n    delay.resize( 2 * n );\n  }\n \n  void delaycalc(int k){\n    datasum[k] = datasum[k] + delay[k];\n    if( k + 1 < n ){\n      for(int i=1;i<=2;i++){\n        delay[2 * k + i] = delay[ 2 * k + i] + delay[k];\n      }\n    }\n    delay[k] = 0;\n  }\n \n  void add(int a,int b,int x,int k,int l,int r){\n    delaycalc(k);\n    if( r <= a || b <= l ) return;\n    else if( a<= l && r <= b ) {\n      delay[k] = x;\n      delaycalc(k);\n    } else {\n      add( a, b, x, 2*k + 1, l, (l+r)/2 );\n      add( a, b, x, 2*k + 2, (l+r)/2, r );\n      datasum[k] = min(datasum[ 2 * k + 1] , datasum[ 2 * k + 2]);\n    }\n  }\n \n  int query(int a,int b,int k,int l,int r){\n    delaycalc(k);\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) {\n      return datasum[k] + delay[k];\n    } else {\n      int vl = query( a, b, 2*k+1, l, (l+r)/2 );\n      int vr = query( a, b, 2*k+2, (l+r)/2, r );\n      return min( vl , vr );\n    }\n  }\n \n  void add( int a,int b,int x) {//[a,b) add x\n    add( a, b, x, 0,0, n );\n  }\n  int query(int a,int b){//[a,b) 's sum\n    return query(a,b,0,0,n);\n  }\n};\n \nsegtree T;\nint N,Q;\nchar str[300005];\nset< int > U;\n \nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  scanf(\"%s\",str);\n  T.init(N+2);\n \n \n  for(int i=0;i<N;i++){\n    if(str[i]=='('){\n      T.add(i,N,1);\n    }else{\n      T.add(i,N,-1);\n      U.insert(i);\n    }\n  }\n \n \n  set<int> :: iterator it;\n  int p,a;\n  while(Q--){\n \n \n    scanf(\"%d\",&p);\n    p--;\n    if(str[p]=='('){\n      U.insert(p);\n      str[p]=')';\n      T.add(p,N,-2);\n \n      it=U.begin();\n      a= *it;\n      printf(\"%d\\n\",a+1);\n      U.erase(it);\n      str[a]='(';\n      T.add(a,N,2);\n    }else if(str[p]==')'){\n      it=U.find(p);\n      U.erase(it);\n      str[p]='(';\n      T.add(p,N,2);\n \n \n \n       \n      int l=0,r=N-1,m,k;\n      while(l<r){\n        m=(l+r)/2;\n        k=T.query(m,N);\n         \n        if(k<2){\n          l=m+1;\n        }else{\n          r=m;\n        }\n      }\n      printf(\"%d\\n\",l+1);\n      str[l]=')';\n      T.add(l,N,-2);\n      U.insert(l);\n    }\n \n \n \n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n  \nstruct segtree{\n  vector<int> t,u;\n  int n;\n  \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)\n      t[i]=u[i]=0;\n  }\n  \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    \n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    \n    t[k*2+2]+=u[k];\n    u[k*2+2]+=u[k];\n    \n    u[k]=0;\n  }\n  \n  void add(int a,int b,int x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]+=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n  \n  int query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      int lc=query(a,b,k*2+1,l,m);\n      int rc=query(a,b,k*2+2,m,r);\n      return min(lc,rc);\n    }\n  }\n  \n  void add(int a,int b,int x) {\n    add(a,b,x,0,0,n);\n  }\n  \n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n  \nsegtree T;\nint N,Q;\nchar str[300005];\nset< int > U;\n  \nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  scanf(\"%s\",str);\n  T.init(N+2);\n  \n  \n  for(int i=0;i<N;i++){\n    if(str[i]=='('){\n      T.add(i,N,1);\n    }else{\n      T.add(i,N,-1);\n      U.insert(i);\n    }\n  }\n  \n  \n  set<int> :: iterator it;\n  int p,a;\n  while(Q--){\n  \n  \n    scanf(\"%d\",&p);\n    p--;\n    if(str[p]=='('){\n      U.insert(p);\n      str[p]=')';\n      T.add(p,N,-2);\n  \n      it=U.begin();\n      a= *it;\n      printf(\"%d\\n\",a+1);\n      U.erase(it);\n      str[a]='(';\n      T.add(a,N,2);\n    }else if(str[p]==')'){\n      it=U.find(p);\n      U.erase(it);\n      str[p]='(';\n      T.add(p,N,2);\n  \n  \n  \n        \n      int l=0,r=N-1,m,k;\n      while(l<r){\n        m=(l+r)/2;\n        k=T.query(m,N);\n          \n        if(k<2){\n          l=m+1;\n        }else{\n          r=m;\n        }\n      }\n      printf(\"%d\\n\",l+1);\n      str[l]=')';\n      T.add(l,N,-2);\n      U.insert(l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (????±?????±?????????¶?????°???????????¨)\n// Verified: AOJ ????????°??¨ verify ?????¨??¨\n\nconst int SIZE = 1 << 19;\ntemplate<typename T>\nstruct lazysegtree {\n    // ?????????????????????\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // ????????¬????????§??? (update, query ??? 2 ???????????????)\n    // update function ??????????????????????????¢????????????\n    // upd_f(X, Y, l, r) -> ????????? [l, r) ??§???????????????????????? X ??? Y ????????????\n    // lazy ???????????? update ????????¨??????????????? 1 ??????????????¨?????°?????????\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // ???????????¨?????????????????????????????¨?????? node ??¨ lazy ??????????????§?????????\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n    }\n\n    // ?????? vec ????????§?????????\n    void init(vector<T> vec) {\n        int N = (int)vec.size();\n        for(int i=0; i<N; i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // ???????????? [a, b) ??????????????? val ??????????????????\n    // (upd_f ?????¨????????????)\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // ???????????? [a, b) ?????????????????¨???????????????\n    // (qry_f ?????¨????????????)\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    if(a == INT_MAX) return b;\n    return a + b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nlazysegtree<int> seg(add, qry, INT_MAX);\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    seg.init(array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // ?????? idx ????????? ')' ??? '(' ???\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                // printf(\"mid = %d, val = %d\\n\", mid, val);\n                if(val > 1) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(ub));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int N = 3e5+9;\nint n,Q,sum[N];\nchar S[N];\npriority_queue<int, vector<int>, greater<int> > que;\nint flag[N*4],a[N*4];\nint x,al,ar,add;\nvoid build(int root,int l,int r) {\n    flag[root] = 0;\n    if(l==r) {\n        a[root] = sum[l];\n    }else{\n        int mid=(l+r)>>1;\n        build(root*2,l,mid);\n        build(root*2+1,mid+1,r);\n        a[root]=min(a[root*2],a[root*2+1]);\n    }\n}\nvoid pushdown(int t) {\n    if(t<<1 >= N*4)return;\n    flag[t<<1]+=flag[t];flag[t<<1|1]+=flag[t];\n    a[t<<1]+=flag[t];a[t<<1|1]+=flag[t];\n    flag[t]=0;\n}\nvoid update(int root,int l,int r) {\n    if(flag[root]!=0)pushdown(root);\n    if(al <= l && r <= ar ) {\n        a[root]+=add;flag[root]+=add;\n    }else{\n        int mid=(l+r)>>1;\n        if(al<=mid)   update(root<<1,l,mid);\n        if(ar>=mid+1) update(root<<1|1,mid+1,r);\n        a[root]=min(a[root*2],a[root*2+1]);\n    }\n}\nint ask(int root,int l,int r) {\n    if(flag[root])pushdown(root);\n    if(al<=l&&r<=ar) return a[root];\n    int mid=(l+r)>>1;\n    int ans=1e9;\n    if (al<=mid) ans = min(ans,ask(root<<1,l,mid));\n    if (ar>mid) ans = min(ans,ask(root<<1|1,mid+1,r));\n    return ans;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin>>n>>Q) {\n        cin>>(S+1);\n        while(!que.empty())que.pop();\n        for(int i=1;i<=n;i++){\n            if(S[i]=='(')sum[i]=sum[i-1]+1;\n            else sum[i]=sum[i-1]-1;\n            if(S[i]==')') que.push(i);\n        }\n        build(1,1,n);\n        while(Q--){\n            cin>>x;\n            if(S[x] == '(' ) {\n                que.push(x);\n                S[x] = ')';al=x;ar=n;add=-2;\n                update(1,1,n);\n                while(!que.empty()){\n                    x = que.top();que.pop();\n                    if(S[x]==')') break;\n                }\n                S[x]='(';al=x;ar=n;add=2;\n                update(1,1,n);\n            }else{\n                int l=1,r=x;\n                S[x]='(';al=x;ar=n;add=2;\n                update(1,1,n);\n                while(l<r){\n                    int mid=(l+r) >> 1;\n                    al=mid;ar=x;\n                    if(ask(1,1,n)>=2)r=mid;\n                    else l=mid+1;\n                }\n                S[l] = ')';que.push(l);\n                al=l;ar=n;add=-2;\n                update(1,1,n);\n                x=l;\n            }\n            cout<<x<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        assert(l<=q && q<r);\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                //assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                // assert(s[l]=='(');                \n                // assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v)\n{\n    for (auto& e : v) {\n        is >> e;\n    }\n    return is;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = (ll)1e9 + 7LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nstruct Min_Plus {\n    using T = ll;\n\n    struct AccMonoid {\n        T operator()(const T& a, const T& b) const { return min(a, b); }\n        static constexpr T identity() { return INF<T>; }\n    };\n\n    struct OpMonoid {\n        using T = ll;\n        T operator()(const T& f1, const T& f2) const { return f1 + f2; }\n        static constexpr T identity() { return 0; }\n    };\n\n    T operator()(const OpMonoid::T& f, const T& x) const { return f + x; }\n};\ntemplate <typename Base>\nclass SegmentTree\n{\npublic:\n    using BaseAlgebra = Base;\n    using AccMonoid = typename BaseAlgebra::AccMonoid;\n    using OpMonoid = typename BaseAlgebra::OpMonoid;\n    using T = typename BaseAlgebra::T;\n    using F = typename BaseAlgebra::OpMonoid::T;\n\n    SegmentTree(const int n) : data_num(n), height(__lg(2 * data_num - 1)), size(1 << (1 + height)), half(size >> 1), value(size, AccMonoid::identity()), action(size, OpMonoid::identity()) { assert(n > 0); }\n    SegmentTree(const std::vector<T>& val) : data_num(val.size()), height(__lg(2 * data_num - 1)), size(1 << (1 + height)), half(size >> 1), value(size), action(size, OpMonoid::identity())\n    {\n        for (int data = 0; data < half; data++) {\n            if (data < data_num) {\n                value[data + half] = val[data];\n            } else {\n                value[data + half] = AccMonoid::identity();\n            }\n        }\n        for (int node = half - 1; node >= 1; node--) {\n            value[node] = acc(value[2 * node], value[2 * node + 1]);\n        }\n    }\n\n    T get(const int a) const\n    {\n        assert(0 <= a and a < data_num);\n        return accumulate(a, a + 1);\n    }\n\n    void set(const int a, const T& val)\n    {\n        assert(0 <= a and a < data_num);\n        const int node = a + half;\n        value[node] = val;\n        for (int i = node / 2; i > 0; i /= 2) {\n            value[i] = acc(value[2 * i], value[2 * i + 1]);\n        }\n    }\n\n    T accumulate(const int a, const int b) const  // Accumulate (a,b]\n    {\n        assert(0 <= a and a < b and b <= data_num);\n        return accumulateRec(1, 0, half, a, b);\n    }\n\n    void modify(const int a, const int b, const F& f)  // Apply f on (a,b]\n    {\n        assert(0 <= a and a < b and b <= data_num);\n        if (f == OpMonoid::identity()) {\n            return;\n        }\n        modifyRec(1, 0, half, a, b, f);\n    }\n\n    void print() const\n    {\n        // cout << \"#VALUE\" << endl;\n        // for (int i = half; i < size; i++) {\n        //     cout << value[i] << \" \";\n        // }\n        // cout << endl;\n        // cout << \"#ACTION\" << endl;\n        // for (int i = 1; i < half; i++) {\n        //     cout << action[i] << \" \";\n        // }\n        // cout << endl;\n    }\n\nprivate:\n    void modifyRec(const int int_index, const int int_left, const int int_right, const int mod_left, const int mod_right, const F& f)\n    {\n        if (mod_left <= int_left and int_right <= mod_right) {\n            value[int_index] = act(f, value[int_index]);\n            action[int_index] = compose(f, action[int_index]);\n        } else if (int_right <= mod_left or mod_right <= int_left) {\n            // Do nothing\n        } else {\n            modifyRec(2 * int_index, int_left, (int_left + int_right) / 2, 0, half, action[int_index]);\n            modifyRec(2 * int_index, int_left, (int_left + int_right) / 2, mod_left, mod_right, f);\n            modifyRec(2 * int_index + 1, (int_left + int_right) / 2, int_right, 0, half, action[int_index]);\n            modifyRec(2 * int_index + 1, (int_left + int_right) / 2, int_right, mod_left, mod_right, f);\n            value[int_index] = acc(value[2 * int_index], value[2 * int_index + 1]);\n            action[int_index] = OpMonoid::identity();\n        }\n    }\n\n    T accumulateRec(const int int_index, const int int_left, const int int_right, const int mod_left, const int mod_right) const\n    {\n        if (mod_left <= int_left and int_right <= mod_right) {\n            return value[int_index];\n        } else if (int_right <= mod_left or mod_right <= int_left) {\n            return AccMonoid::identity();\n        } else {\n            return act(action[int_index], acc(accumulateRec(2 * int_index, int_left, (int_left + int_right) / 2, mod_left, mod_right),\n                                              accumulateRec(2 * int_index + 1, (int_left + int_right) / 2, int_right, mod_left, mod_right)));\n        }\n    }\n\n    const int data_num;  // Num of valid data on leaves.\n    const int height;\n    const int size;\n    const int half;\n    vector<T> value;   // Tree for value(length: size)\n    vector<F> action;  // Tree for action(length: half)\n    bool has_lazy;\n\n    const AccMonoid acc{};\n    const OpMonoid compose{};\n    const BaseAlgebra act{};\n};\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n    string s;\n    cin >> s;\n    set<int> st;\n    for (int i = 0; i < N; i++) {\n        if (s[i] == ')') {\n            st.insert(i);\n        }\n    }\n    vector<ll> value(N, 0);\n    for (int i = 0; i < N; i++) {\n        value[i] = ((i == 0) ? 0 : value[i - 1]) + ((s[i] == '(') ? 1 : -1);\n    }\n    SegmentTree<Min_Plus> seg(value);\n    for (int i = 0; i < Q; i++) {\n        int q;\n        cin >> q;\n        q--;\n        if (s[q] == '(') {\n            seg.modify(q, N, -2);\n            st.insert(q);\n            s[q] = ')';\n            s[*st.begin()] = '(';\n            seg.modify(*st.begin(), N, 2);\n            cout << *st.begin() + 1 << endl;\n            st.erase(st.begin());\n        } else {\n            s[q] = '(';\n            st.erase(q);\n            int inf = 0;\n            int sup = N;\n            seg.modify(q, N, 2);\n            while (inf < sup - 1) {\n                const int mid = (inf + sup) / 2;\n                const ll mini = seg.accumulate(mid, N);\n                if (mini >= 2) {\n                    sup = mid;\n                } else {\n                    inf = mid;\n                }\n            }\n            s[sup] = ')';\n            cout << sup + 1 << endl;\n            st.insert(sup);\n            seg.modify(sup, N, -2);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s < t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s < t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s < t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    vector<bool> is_open(N);\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            is_open[i] = c == '(';\n            if (is_open[i]) {\n                segtree.add_at(i,nest);\n                nest ++;\n            } else {\n                nest --;\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        repeat (j,N) {\n            if (i == j) {\n                cout << i+1 << endl;\n                break;\n            } else if (is_open[j] != is_open[i]) {\n                if (is_open[i] or 0 < segtree.min_query(j, i+1)) {\n                    segtree.add_range(j, i+1, is_open[i] ? 1 : -1);\n                    swap(is_open[i], is_open[j]);\n                    cout << j+1 << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct starrysky{\n  int n;\n  starrysky(){}\n  starrysky(int n_){init(n_);};\n  vector<int> data,datm;\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data.clear();\n    datm.clear();\n    data.resize(2*n-1,0);\n    datm.resize(2*n-1,0);\n  }\n  void add(int a,int b,int x,int l,int r,int k){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      data[k]+=x;\n      return;\n    }\n    add(a,b,x,l,(l+r)/2,k*2+1);\n    add(a,b,x,(l+r)/2,r,k*2+2);\n    datm[k]=min(datm[k*2+1]+data[k*2+1],datm[k*2+2]+data[k*2+2]);\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,n,0);\n  }\n  int query(int a,int b,int l,int r,int k){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b){\n      return data[k]+datm[k];\n    }\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2))+data[k];\n  }\n  int query(int a,int b){\n    return query(a,b,0,n,0);\n  }\n};\n#define MAX (1<<18)\nstring buf;\nint dp[MAX],imos[MAX];\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  cin>>buf;\n  set<int> s;\n  for(int i=0;i<n;i++) {\n    if(buf[i]=='(') dp[i]=1;\n    else dp[i]=-1;\n    if(buf[i]==')') s.insert(i);\n  }\n  imos[0]=dp[0];\n  for(int i=1;i<n;i++) imos[i]=imos[i-1]+dp[i];\n  starrysky ss(n);\n  for(int i=0;i<n;i++) ss.add(i,i+1,imos[i]);\n  for(int i=0;i<q;i++){\n    int p;cin>>p;p--;\n    if(dp[p]==1){\n      dp[p]*=-1;\n      s.insert(p);\n      ss.add(p,n,-2);\n      int k=*s.begin();\n      s.erase(k);\n      dp[k]*=-1;\n      ss.add(k,n,2);\n      cout<<k+1<<endl;\n    }else{\n      //cout<<p<<endl;\n      dp[p]*=-1;\n      s.erase(p);\n      ss.add(p,n,2);\n      int l=0,r=p;\n      while(l+1<r){\n\tint m=(l+r)/2;\n\t//cout<<m<<\":\"<<ss.query(m,n)<<endl;\n\tif(ss.query(m,n)>=2) r=m;\n\telse l=m;\n      }\n      cout<<r+1<<endl;\n      dp[r]*=-1;\n      s.insert(r);\n      ss.add(r,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N=(1<<20);\n\nll bit0[2][MAX_N+1],bit1[2][MAX_N+1];\n\nclass BIT{\n\npublic:\n  \n  int n,idx;\n  \n  BIT(){\n    n=MAX_N;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n  }\n\n  BIT(int n,int I){\n    this->n=n;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n    idx=I;\n  }\n  \n  ll sum(ll *b,int i){\n\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n  \n  // [a,b]テ」ツ?ォ xテ」ツつ津・ツ環?」ツ?暗」ツつ?\n  \n  void add(int a,int b,ll x){\n    add(bit0[idx],a,-x*(a-1));\n    add(bit1[idx],a,x);\n    add(bit0[idx],b+1,x*b);\n    add(bit1[idx],b+1,-x);\n  }\n  \n  // [a,b]テ」ツ?ョsumテ」ツつ津・ツセツ療」ツつ?\n  \n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0[idx],b)+sum(bit1[idx],b)*b;\n    res-=sum(bit0[idx],a-1)+sum(bit1[idx],a-1)*(a-1);\n    return res;\n  }\n  \n};\n\n\n\nstring s;\nint n,q;\n\n\nint main(){\n  \n  cin>>n>>q;\n  \n  cin>>s;\n  \n  int x;\n\n  BIT L(n,0), R(n,1);\n\n  for(int i=1;i<=n;i++){\n\n    if(s[i-1]=='(') L.add(i,i,1);\n    else R.add(i,i,1);\n    \n  }\n  \n  for(int i=0;i<q;i++){\n    \n    scanf(\"%d\",&x);\n    \n    if(L.sum(x,x)){ // s[x]='('\n      \n      L.add(x,x,-1);\n      R.add(x,x,1);\n      \n      int l=1, r=n+1;\n      \n      while(l<r){\n\t\n\tint m=(l+r)/2;\n\n\tif(R.sum(1,m)>=1) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,1);\n      R.add(l,l,-1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    else{ // s[x]=')'\n\n      L.add(x,x,1);\n      R.add(x,x,-1);\n      \n      if(L.sum(x,n)>R.sum(x,n)){\n\t\n\tL.add(x,x,-1);\n\tR.add(x,x,1);\n      \n\tprintf(\"%d\\n\",x);\n\tcontinue;\n      }\n      \n      int l=1, r=n+1;\n\n      while(l<r){\n\n\tint m=(l+r)/2;\n\t\n\tif(L.sum(0,m-1>=R.sum(0,m-1)+1)) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,-1);\n      R.add(l,l,1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l  && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nint fix(set<int> &a, set<int> &b, char *s, char before, int x)\n{\n    a.erase(x);\n    b.insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    \n    while (l != r){\n        int mid = (l + r) / 2;\n        int p = *b.lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        bool cond1 = (p ? getMin(p - 1, p) == getMin(p, p + 1) + 1 : 1);\n        bool cond2 = (p != n - 1 ? getMin(p, p + 1) == getMin(p + 1, p + 2) + 1 : 1);\n        \n        if (segMin[0] + segAdd[0] >= 0) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    int p = *b.lower_bound(l);\n    add(p, n, -2 * base);\n    b.erase(p);\n    a.insert(p);\n    s[p] = before;\n    \n    return (p);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '('){\n            printf(\"%d\\n\", fix(lf, rg, s, '(', x) + 1);\n        }\n        else {\n            printf(\"%d\\n\", fix(rg, lf, s, ')', x)  + 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 1 << 17;\nconst ll INF = 1LL << 50;\n\nstruct MinSegTree2{\n\tstatic const ll def = INF;\n\tint n;\n\tll segMin[2 * MAX_N - 1], segAdd[2 * MAX_N - 1];\n\tvoid init(int n_){\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tfor(int i = 0; i < 2 * n - 1; i++) segMin[i] = def, segAdd[i] = 0;\n\t}\n\n\tvoid add(int a, int b, ll x){ add(a, b, x, 0, 0, n); }\n\n\tvoid add(int a, int b, ll x, int k, int l, int r){\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\t\tsegMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n\t}\n\n\tvoid set(int i, ll x){\n\t\tll y = query(i, i + 1);\n\t\tadd(i, i + 1, -y + x);\n\t}\n\n\tll query(int a, int b){ return query(a, b, 0, 0, n); }\n\n\tll query(int a, int b, int k, int l, int r){\n\t\tif(r <= a || b <= l) return def;\n\t\tif(a <= l && r <= b) return segMin[k] + segAdd[k];\n\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr) + segAdd[k];\n\t}\n};\n\nMinSegTree2 minst;\n\nint N;\nstring s;\n\nset<int> O, C;\n\nvoid flip(int i){\n\tif(s[i] == '('){\n\t\ts[i] = ')';\n\t\tO.erase(i);\n\t\tC.insert(i);\n\t\tminst.add(i, N, -2);\n\t}\n\telse{\n\t\ts[i] = '(';\n\t\tC.erase(i);\n\t\tO.insert(i);\n\t\tminst.add(i, N, +2);\n\t}\n}\n\nvoid debug(){\n\tcout << s << endl;\n\tfor(int i = 0; i < N; i++){\n\t\tcout << minst.query(i, i + 1) << \" \";\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint Q;\n\tcin >> N >> Q >> s;\n\n\tminst.init(N);\n\tint cnt = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '('){\n\t\t\tO.insert(i);\n\t\t\tcnt++;\n\t\t\tminst.set(i, cnt);\n\t\t}\n\t\telse{\n\t\t\tC.insert(i);\n\t\t\tcnt--;\n\t\t\tminst.set(i, cnt);\n\t\t}\n\t}\n\n\t//debug();\n\n\twhile(Q--){\n\t\tint k;\n\t\tcin >> k;\n\t\tk--;\n\t\tchar c = s[k];\n\t\tflip(k);\n\t\t//debug();\n\t\tint ans = k;\n\n\t\tif(c == '('){\n\t\t\t// CLOSE -> OPEN\n\t\t\t// ????????????CLOSE\n\t\t\tans = *C.begin();\n\t\t}\n\t\telse{\n\t\t\t// OPEN -> CLOSE\n\t\t\t// [i, n) >= 2 ????????????????°????i\n\t\t\tint ng = 0, ok = k;\n\t\t\twhile(abs(ng - ok) > 1){\n\t\t\t\tint mid = (ng + ok) / 2;\n\t\t\t\tauto it = O.lower_bound(mid);\n\t\t\t\tif(it == O.end()){\n\t\t\t\t\tng = mid;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint a = *it;\n\t\t\t\tif(minst.query(a, N) >= 2) ok = mid;\n\t\t\t\telse ng = mid;\n\t\t\t}\n\t\t\tans = *O.lower_bound(ok);\n\t\t}\n\n\t\tcout << ans + 1 << endl;\n\t\tflip(ans);\n\t\t//debug();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tint query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tint query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0, pl = 0, pr = r, l = r;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tsum += d[i];\n\t\t\t\tif (sum < 2) l = r;\n\t\t\t\telse if (l == r) l = i;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0);\n\t\t\td[l] = -1; b1.update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1);\n\t\t\td[pr] = 1; b1.update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef long long ll;\n\nstruct T {\n  ll v;\n  ll s;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),s(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->s += t->lazy*count(t);\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll sum(T* t){ push(t); return t?t->s:0; }\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->s = t->v+sum(t->l)+sum(t->r);\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* erase(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> v = split(t,k);\n  k -= (k-1);\n  pair<T*,T*> u = split(v.second,k);\n  return merge(v.first,u.second);\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\ninline T* add(T* t,int k)\n{\n  push(t);\n  t->lz |= true;\n  t->lazy += k;\n  return update(t);\n}\n\nint n,m;\nchar s[333333];\ninline T* flip(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  pair<T*,T*> b=split(a.second,1);\n  //b.first->v = -b.first->v;\n  //b.first = add(b.first,k,n);\n  return merge(a.first,merge(b.first,b.second));\n}\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\ninline int gsum(T* t)\n{\n  /*\n  if( !t->r ) return t->v;\n  return gsum(t->r);\n  */\n  return 0;\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q,m;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  //print(root); puts(\"\");\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    //printf(\"%d %d\\n\",mini(t),gsum(t));\n    //print(t); puts(\"\");\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        //printf(\"%d %d\\n\",l,r);\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      //printf(\":%d %d\\n\",l,r);\n      root = add(root,l,n,-2);\n    }\n    //puts(s);\n    //printf(\"%d\\n\",kakko);\n    //print(root); puts(\"\");\n    /*\n      printf(\"sum:%d min:%d\\n\",gsum(t),mini(t));\n    //*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef long long ll;\n\nstruct T {\n  ll v;\n  ll s;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),s(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->s += t->lazy*count(t);\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll sum(T* t){ push(t); return t?t->s:0; }\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->s = t->v+sum(t->l)+sum(t->r);\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* erase(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> v = split(t,k);\n  k -= (k-1);\n  pair<T*,T*> u = split(v.second,k);\n  return merge(v.first,u.second);\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\ninline T* add(T* t,int k)\n{\n  push(t);\n  t->lz |= true;\n  t->lazy += k;\n  return update(t);\n}\n\nint n,m;\nchar s[33333];\ninline T* flip(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  pair<T*,T*> b=split(a.second,1);\n  //b.first->v = -b.first->v;\n  //b.first = add(b.first,k,n);\n  return merge(a.first,merge(b.first,b.second));\n}\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\ninline int gsum(T* t)\n{\n  /*\n  if( !t->r ) return t->v;\n  return gsum(t->r);\n  */\n  return 0;\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q,m;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  //print(root); puts(\"\");\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    //printf(\"%d %d\\n\",mini(t),gsum(t));\n    //print(t); puts(\"\");\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        //printf(\"%d %d\\n\",l,r);\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      //printf(\":%d %d\\n\",l,r);\n      root = add(root,l,n,-2);\n    }\n    //puts(s);\n    //printf(\"%d\\n\",kakko);\n    //print(root); puts(\"\");\n    /*\n      printf(\"sum:%d min:%d\\n\",gsum(t),mini(t));\n    //*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// 区間add, 区間min\nstruct LazySegTree{\n    int n; vector<ll> dat,lazy;\n    //初期化\n    LazySegTree(int _n){\n        n=1;\n        while(n<_n) n*=2;\n        dat=vector<ll>(2*n-1,0);\n        lazy=vector<ll>(2*n-1,0);\n    }\n\n    void setLazy(int k, ll v){\n        lazy[k] += v;\n        dat[k] += v;\n    }\n\n    void push(int k, int l, int r){\n        if(lazy[k]!=0){\n            setLazy(2*k+1,lazy[k]);\n            setLazy(2*k+2,lazy[k]);\n        }\n        lazy[k]=0;\n    }\n\n    void fix(int k, int l, int r){\n        dat[k]=min(dat[2*k+1],dat[2*k+2]);\n    }\n\n    ll merge(ll x, ll y){\n        return min(x,y);\n    }\n\n    //内部的に投げられるクエリ\n    void _add(int a, int b, ll x, int k, int l, int r){\n        if(r<=a || b<=l) return;\n        if(a<=l && r<=b){\n            setLazy(k,x);\n            return;\n        }\n\n        push(k,l,r);\n        _add(a,b,x,2*k+1,l,(l+r)/2);\n        _add(a,b,x,2*k+2,(l+r)/2,r);\n\n        fix(k,l,r);\n    }\n    //[a,b)に+x\n    void add(int a, int b, ll x){\n        return _add(a,b,x,0,0,n);\n    }\n\n    //内部的に投げられるクエリ\n    ll _query(int a, int b, int k, int l, int r){\n        if(r<=a || b<=l) return LLONG_MAX/2;\n        if(a<=l && r<=b) return dat[k];\n\n        push(k,l,r);\n        ll vl=_query(a,b,2*k+1,l,(l+r)/2);\n        ll vr=_query(a,b,2*k+2,(l+r)/2,r);\n        return merge(vl,vr);\n    }\n    //[a,b)の最小値\n    ll query(int a, int b){\n        return _query(a,b,0,0,n);\n    }\n};\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n\n    int n,Q;\n    string s;\n    cin >>n >>Q >>s;\n\n    LazySegTree st(n);\n\n    vector<int> a(n);\n    set<int> r;\n    rep(i,n){\n        if(s[i] == '(') a[i] = 1;\n        else{\n            a[i] = -1;\n            r.insert(i);\n        }\n        st.add(i,n+1,a[i]);\n    }\n\n    rep(i,Q){\n        int q;\n        cin >>q;\n        --q;\n\n        int ans = -1;\n        if(a[q] == 1){\n            st.add(q,n+1,-2);\n\n            r.insert(q);\n            ans = *r.begin();\n            r.erase(ans);\n\n            st.add(ans,n+1,2);\n        }\n        else{\n            st.add(q,n+1,2);\n\n            int ok=n-1, ng=0;\n            while(ok-ng>1){\n                int mid = (ok+ng)/2;\n                if(st.query(mid,n+1)>=2) ok = mid;\n                else ng = mid;\n            }\n            ans = ok;\n\n            r.erase(q);\n            r.insert(ans);\n            st.add(ans,n+1,-2);\n        }\n\n        a[q] *= -1;\n        a[ans] *= -1;\n        printf(\"%d\\n\", ans+1);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        // assert(q > 0);\n        close_parens.erase(q);\n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        \n        assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        \n        \n        \n        cout << pos_pos + 1 << endl;\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<map>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\nvoid debug_show(string str,Segment_Tree *ST,int n)\n{\n  int j;\n  cout<<str<<endl;\n  cout<<\"Sum \";\n  rep(j,n)\n    cout<<ST->get_min(j,j+1)<<\" \";\n  cout<<endl;\n  cout<<\"Min \" ;\n  rep(j,n)\n    cout<<ST->get_min(j,n)<<\" \";\n  cout<<endl;\n}\n\nint  main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(n);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='('){\n\tST.add(i,n,1);\n      }\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  /* \n\t  int p=-1;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{p=str.find('(',p+1);}\n\t    while(ST.get_min(p,n)<2);\n\t  \n\t  */\n\t  //cout<<\"bf \"<<flip+1<<\"changed\"<<endl;\n\t  //debug_show(str,&ST,n);\n\t  \n\t  int p=0,e=n;\n\t  if(flip==n-1)p=flip;\n\t  else{\n\t    while(e>p+1){\n\t      if(ST.get_min((p+e)/2,n)<2)p=(p+e)/2;\n\t      else e=(p+e)/2;\n\t    }\n\t    p=str.find('(',p+1);\n\t  }\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t  //puts(\"af\");\n\t  //debug_show(str,&ST,n);\n\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (テヲツ環スティツアツ。テ」ツδサテヲツアツ偲・ツ個姪ゥツ??・ツサツカテ」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗ヲツ慊ィ)\n// Verified: AOJ テ」ツ?ョテ」ツつサテ」ツつーテヲツ慊ィ verify テ・ツ閉湘・ツ?ィテゥツδィ\n\nconst int SIZE = 1 << 17; // 2^17 = 131072\ntemplate<typename T>\nstruct lazysegtree {\n    // テ」ツδ偲」ツδシテ」ツδ嘉」ツ??・ツ債佚、ツスツ催・ツ??\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // テ」ツつェテ」ツδ堙」ツδャテ」ツδシテ」ツつキテ」ツδァテ」ツδウ (update, query テ」ツ?ョ 2 テ」ツ?、テ」ツ?古・ツソツ?ィツヲツ?ッツシツ?\n    // update function テ」ツ?ッテァツッツ?・ツ崢イテ」ツつ津ヲツ個?・ツョツ堙」ツ?凖」ツつ凝・ツスツ「テ」ツ?ォテ」ツ?療」ツつ暗」ツ??\n    // upd_f(X, Y, l, r) -> テァツッツ?・ツ崢イテ」ツ??[l, r) テ」ツ?ァテ」ツ?づ」ツつ凝」ツつ暗」ツ??」ツ?ェテ」ツδ偲」ツδシテ」ツδ?X テ」ツ?ォ Y テ」ツつ津・ツ渉催ヲツ伉?ッツシツ?\n    // lazy テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ update テ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテァツッツ?・ツ崢イテ」ツつ?1 テ」ツ?ォテ」ツ?療」ツ?ェテ」ツ??」ツ?ィテ」ツδ静」ツつーテ」ツつ甘」ツ?セテ」ツ??\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // テヲツシツ氾ァツョツ療・ツュツ静」ツ?ィテ・ツ債佚、ツスツ催・ツ?ε」ツつ津」ツつサテ」ツδε」ツδ暗」ツ?療」ツ??・ツ?ィテ」ツ?ヲテ」ツ?ョ node テ」ツ?ィ lazy テ」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X, vector<T> vec) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n\n        // vec テ」ツ?ョテ・ツ?、テ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n        for(size_t i=0; i<vec.size(); i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ・ツ?、 val テ」ツつ津・ツ渉催ヲツ伉?」ツ?陛」ツ?崚」ツつ?\n    // (upd_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツつッテ」ツつィテ」ツδェテ」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // (qry_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    if(a == INT_MAX) return b;\n    return a + b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    lazysegtree<int> seg(add, qry, INT_MAX, array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // テ、ツスツ催ァツスツョ idx テ」ツ?ォテ」ツ?づ」ツつ?')' テ」ツつ?'(' テ」ツ?ォ\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                if(val > 1) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(ub));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define lch (id<<1)\n#define rch ((id<<1)|1)\nconst int maxn=300000+100;\nconst int INF=1e9+10;\nchar kuo[maxn];\nint sum[maxn];\nint minv[maxn<<2],maxv[maxn<<2],lazy[maxn<<2];\nvoid build(int id,int l,int r)\n{\n\tlazy[id]=0;\n\tif(l==r)\n\t\tminv[id]=maxv[id]=sum[l];\n\telse\n\t{\n\t\tint mid=l+r>>1;\n\t\tbuild(lch,l,mid);\n\t\tbuild(rch,mid+1,r);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nvoid pushdown(int id)\n{\n\tminv[lch]+=lazy[id];maxv[lch]+=lazy[id];lazy[lch]+=lazy[id];\n\tminv[rch]+=lazy[id];maxv[rch]+=lazy[id];lazy[rch]+=lazy[id];\n\tlazy[id]=0;\n}\nvoid update(int id,int l,int r,int L,int R,int v)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tminv[id]+=v;\n\t\tmaxv[id]+=v;\n\t\tlazy[id]+=v;\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid)update(lch,l,mid,L,R,v);\n\t\tif(R>mid)update(rch,mid+1,r,L,R,v);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_minv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tif(minv[l]==0)return l;\n\t\telse return -1;\n\t}\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(l==r)return l;\n\t\telse if(minv[rch]==0)return query_minv(rch,mid+1,r,L,R);\n\t\telse return query_minv(lch,l,mid,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(R<=mid)return query_minv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_minv(rch,mid+1,r,L,R);\n\t\telse\n\t\t{\n\t\t\treturn max(query_minv(lch,l,mid,L,R),query_minv(rch,mid+1,r,L,R));\n\t\t}\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_maxv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tif(maxv[id]==2)return l;\n\t\telse return INF;\n\t}\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(l==r)return l;\n\t\telse if(maxv[lch]>=2&&minv[lch]<=2)return query_maxv(lch,l,mid,L,R);\n\t\telse return query_maxv(rch,mid+1,r,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(R<=mid)return query_maxv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_maxv(rch,mid+1,r,L,R);\n\t\telse \n\t\t{\n\t\t\treturn min(query_maxv(lch,l,mid,L,R),query_maxv(rch,mid+1,r,L,R));\n\t\t}\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query(int id,int l,int r,int pos)\n{\n\tif(l==r)return minv[id];\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(pos<=mid)return query(lch,l,mid,pos);\n\t\telse return query(rch,mid+1,r,pos);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nset<int> qn;\nint main()\n{\n\tint i,pos,n,q,l,r;\n\tscanf(\"%d %d\",&n,&q);\n\tscanf(\"%s\",kuo+1);\n\tmemset(sum,0,sizeof(sum));\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(kuo[i]=='(')sum[i]=sum[i-1]+1;\n\t\telse \n\t\t{\n\t\t\tsum[i]=sum[i-1]-1;\n\t\t\tqn.insert(i);\n\t\t}\n\t}\n\tbuild(1,0,n);\n\t//for(int j=0;j<=n;j++)cout <<sum[j]<<\" \";cout <<endl;\n\t//for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\tfor(i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&pos);\n\t\tif(kuo[pos]=='(')\t\t\n\t\t{\n\t\t\tkuo[pos]=')';\n\t\t\tupdate(1,0,n,pos,n,-2);\n\t\t\tqn.insert(pos);\n\t\t\tpos=*qn.lower_bound(0);\n\t\t\tqn.erase(pos);\n\t\t\tkuo[pos]='(';\n\t\t\tupdate(1,0,n,pos,n,2);\n\t\t\tprintf(\"%d\\n\",pos);\n\t\t}\n\t\telse if(kuo[pos]==')')\n\t\t{\n\t\t\tif(query(1,0,n,pos)==0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkuo[pos]='(';\n\t\t\t\tqn.erase(pos);\n\t\t\t\tupdate(1,0,n,pos,n,2);\t\n\t\t\t\tl=query_minv(1,0,n,0,pos);\n\t\t\t\tr=query_maxv(1,0,n,l+1,pos);\n\t\t\t\tupdate(1,0,n,r,n,-2);\n\t\t\t\tqn.insert(r);\n\t\t\t\t//cout <<kuo[r]<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\t\tkuo[r]=')';\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%s\\n\",kuo+1);for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;  // 対象区間とノードの区間が交わらないなら処理をしない\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k, r-l);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k, int size) {\n    if (size > 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k, int size) {\n    if (size == 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,b)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int b, int k, int l, int r, int val) {\n    if (b <= l) return -1;\n    process_lazy(k, r-l);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    if (b <= (l + r) / 2) return getLeftGt(b, LC(k), l, (l + r) / 2, val);\n    int ret_r = getLeftGt(b, RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2 || ret_r == -1) return ret_r;\n    int ret_l = getLeftGt(b, LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(n, 0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\n#define  MAXN    600010\nusing namespace std;\nstruct SegTree {\n       int left, right, mid, val, add;\n       SegTree () {}\n} tree[MAXN<<1];\nchar str[MAXN];\nint n, q, prefix[MAXN];\ninline int LC(int x) { return x<<1; }\ninline int RC(int x) { return x<<1|1; }\ninline void push_down (int rt) {\n     if (tree[rt].add == 0) \n        return;  \n     tree[rt].val += tree[rt].add;\n     if (tree[rt].left != tree[rt].right) {\n        tree[LC(rt)].add += tree[rt].add;\n        tree[RC(rt)].add += tree[rt].add;\n     }\n     tree[rt].add = 0;  \n}\ninline void push_up (int rt) {  \n     tree[rt].val = min((tree[LC(rt)].val+tree[LC(rt)].add),\n     (tree[RC(rt)].val+tree[RC(rt)].add))+tree[rt].add;\n}\nvoid makeTree (int L,int R,int rt) {\n     tree[rt].left = L;\n     tree[rt].right = R;\n     tree[rt].mid = (L+R)>>1;\n     tree[rt].add = 0;     \n     if (L == R) {\n        tree[rt].val = prefix[L+1];\n        return ;\n     } \n     int mid = tree[rt].mid;\n     makeTree (L,mid,LC(rt));\n     makeTree (mid+1,R,RC(rt));\n     push_up (rt);    \n}\nvoid update (int L,int R,int rt,int x) {\n     push_down (rt);\n     if (L<= tree[rt].left && tree[rt].right<=R) {\n        tree[rt].add += x;\n        return ;\n     }\n     int mid = tree[rt].mid;\n     if (R <= mid) \n        update (L,R,LC(rt),x);\n     else if (L > mid)\n        update (L,R,RC(rt),x);\n     else {\n        update (L,R,LC(rt),x);       \n        update (L,R,RC(rt),x);  \n     }\n     push_up (rt);\n}\nint query (int L,int R,int rt) {\n     push_down (rt);\n     if (L<= tree[rt].left && tree[rt].right<=R) \n        return tree[rt].val;\n     int mid = tree[rt].mid, tmp;\n     if (R <= mid)\n        tmp = query(L,R,LC(rt));\n     else if (L > mid)\n        tmp = query(L,R,RC(rt));\n     else\n        tmp = min( query(L,R,LC(rt)), query(L,R,RC(rt)) );\n     return tmp;   \n}\nvoid fix (set<int> &prev,set<int> &next,char before,int x) {\n     prev.erase(x);\n     next.insert(x);\n     int p, b = ( before == '(' ? -1 : 1 );\n     str[x] = ( before == '(' ? ')': '(' );\n     update (x,n-1,1,2*b);\n     int l = 0, r = x;\n     while (l < r) {\n           int mid = (l+r)>>1;\n           p = *next.lower_bound(mid);\n           if (query(p,n-1,1) >= 2*b)\n              r = mid;\n           else\n              l = mid+1;    \n     }     \n     p = *next.lower_bound(l);\n     update (p,n-1,1,-2*b);\n     next.erase (p);\n     prev.insert (p);\n     str[p] = before;\n     printf (\"%d\\n\",p+1);\n}\nint main(void) {\n    while ( scanf(\"%d%d\",&n,&q)==2 ) {\n          scanf (\"%s\",str);\n          int x;\n          set <int> left, right;\n          prefix[0] = 0;\n          for (int i=0;i<n;++i)\n              if (str[i] == '(') {\n                 prefix[i+1] = prefix[i]+1;\n                 left.insert (i);        \n              }\n              else {\n                 prefix[i+1] = prefix[i]-1;\n                 right.insert (i);  \n              }  \n          makeTree (0,n-1,1);              \n          for (int i=0;i<q;++i) {\n              scanf (\"%d\",&x);\n              x--;\n              if (str[x] == '(') \n                 fix(left,right,str[x],x);\n              else if (str[x] == ')')\n                 fix(right,left,str[x],x); \n          }\n    }\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nconst int p2=1<<19;\nint N,Q;\nstring s;\nint segm[p2*2],sega[p2*2],inf=1e8;\nset<int> st;\nvoid add(int a,int b,int l,int r,int k,int x){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tsega[k]+=x;\n\t\treturn;\n\t}\n\tadd(a,b,l,(l+r)/2,k*2+1,x);\n\tadd(a,b,(l+r)/2,r,k*2+2,x);\n}\nvoid change(int x){\n\tif(s[x]=='('){\n\t\ts[x]=')';\n\t\tst.insert(x);\n\t\tadd(x,p2,0,p2,0,-2);\n\t}else{\n\t\ts[x]='(';\n\t\tst.erase(x);\n\t\tadd(x,p2,0,p2,0,2);\n\t}\n}\nint getmin(int a,int b,int l,int r,int k){\n\tif(b<=l||r<=a) return inf;\n\tif(a<=l&&r<=b) return segm[k]+sega[k];\n\treturn min(getmin(a,b,l,(l+r)/2,k*2+1),getmin(a,b,(l+r)/2,r,2*k+2))+sega[k];\n}\nint main(){\n\tcin>>N>>Q;\n\tcin>>s;\n\trep(i,N) if(s[i]==')') st.insert(i);\n\trep(i,N) segm[p2-1+i]=segm[p2-2+i]+(s[i]=='('?1:-1);\n\tfor(int i=p2-2;i>=0;i--){\n\t\tsegm[i]=min(segm[i*2+1],segm[i*2+2]);\n\t}\n\trep(i,Q){\n\t\tint q;\n\t\tcin>>q;\n\t\tq--;\n\t\tif(s[q]=='('){\n\t\t\tchange(q);\n\t\t\tint a=*st.begin();\n\t\t\tcout<<a+1<<endl;\n\t\t\tchange(a);\n\t\t}else{\n\t\t\tint ub=q,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tif(getmin(m,q+1,0,p2,0)>=2) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tcout<<ub+1<<endl;\n\t\t\tchange(ub);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\n\nint main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(80);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='(')\n\tST.add(i,n,1);\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  int p=0;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{\n\t      p=str.find('(',p+1);\n\t    }while(ST.get_min(p,n)<2);\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int INF = 1<<28;\n\nclass SegTree{\n\ttypedef int SegT;\n\tstatic const SegT defvalue = INF;\n\tprivate:\n\t\tvector<SegT> val, lazy;\n\t\tvector<int> lazyf;\n\t\tint n;\n\t\t\n\t\tSegT combine(SegT a, SegT b){\n\t\t\treturn min(a, b);\n\t\t}\n\t\tSegT merge(SegT a, SegT b){\n\t\t\treturn a+b;\n\t\t}\n\t\t\n\t\tvoid applyLazy(SegT k){\n\t\t\tif(lazyf[k]){\n\t\t\t\tlazyf[k] = 0;\n\t\t\t\tval[k] = merge(val[k], lazy[k]);\n\t\t\t\tif(k*2+2 < lazy.size()){\n\t\t\t\t\tlazy[k*2+1] = lazyf[k*2+1] ? merge(lazy[k*2+1], lazy[k]) : lazy[k];\n\t\t\t\t\tlazy[k*2+2] = lazyf[k*2+2] ? merge(lazy[k*2+2], lazy[k]) : lazy[k];\n\t\t\t\t\tlazyf[k*2+1] = lazyf[k*2+2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tSegTree(int size){\n\t\t\tn=1;\n\t\t\twhile(n<size)n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, 0);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t}\n\t\tSegTree(const vector<SegT> &in){\n\t\t\tn=1;\n\t\t\twhile(n<in.size())n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, -1);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t\tfor(int i=n-1 + in.size()-1;i>=0;i--){\n\t\t\t\tif(n-1 <= i) val[i] = in[i - (n-1)];\n\t\t\t\telse val[i] = combine(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値をaに更新する\n\t\tvoid update(int a,int b,SegT x,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tapplyLazy(k);\n\t\t\tif(r<=a||b<=l) return;\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\tlazy[k] = x;\n\t\t\t\tlazyf[k] = 1;\n\t\t\t\tapplyLazy(k);\n\t\t\t}else{\n\t\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t\t\tval[k] = combine(val[k*2+1], val[k*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値を取ってくる\n\t\tSegT query(int a,int b,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l) return defvalue;\n\t\t\tapplyLazy(k);\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\treturn val[k];\n\t\t\t}else{\n\t\t\t\treturn combine(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tcout << val << endl;\n\t\t\tcout << lazy << endl;\n\t\t\tcout << lazyf << endl;\n\t\t}\n};\n\n\nint n, m;\nstring s;\nmain(){\n\tios::sync_with_stdio(false);\n\tset<int> close;\n\tcin >> n >> m >> s;\n\tvi d(s.size());\n\tREP(i, s.size()){\n\t\td[i] = (i?d[i-1]:0) + (s[i]=='(' ? 1 : -1);\n\t\tif(s[i]==')') close.insert(i);\n\t}\n\t\n\tSegTree seg(d);\n\t\n\tREP(q, m){\n\t\tint t;\n\t\tcin >> t;t--;\n\t\tif(s[t] == '('){\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tint t = *close.begin();\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\tcout << t+1 << endl;\n\t\t}else if(s[t] == ')'){\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\t\n\t\t\tint l=0, r=t;\n\t\t\twhile(l<r-1){\n\t\t\t\tint med=(l+r)/2;\n\t\t\t\tif(seg.query(med, t) <= 1) l = med;\n\t\t\t\telse r = med;\n\t\t\t}\n\t\t\tint t = r;\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tcout << t+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s < t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s < t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s < t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\n// to avoid compile error at aoj\ntemplate <typename T>\nvoid swap_vector(vector<T> & v, int i, int j) {\n    T t = v[i];\n    v[i] = v[j];\n    v[j] = t;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    vector<bool> is_open(N);\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            is_open[i] = c == '(';\n            if (is_open[i]) {\n                segtree.add_at(i,nest);\n                nest ++;\n            } else {\n                nest --;\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        repeat (j,N) {\n            if (i == j) {\n                cout << i+1 << endl;\n                break;\n            } else if (is_open[j] != is_open[i]) {\n                if (is_open[i] or 0 < segtree.min_query(j, i+1)) {\n                    segtree.add_range(j, i+1, is_open[i] ? 1 : -1);\n                    swap_vector(is_open, i, j);\n                    cout << j+1 << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0; bool flag = false;\n\t\t\tfor (int j = r + 1; j < n; j++) sum += d[j];\n\t\t\tif (sum != 0) {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\t\tsum += d[j];\n\t\t\t\t\tif (sum >= 2) {\n\t\t\t\t\t\td[j] = -1, d[r] = 1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t\telse {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (d[j] == -1) {\n\t\t\t\t\td[j] = 1, d[r] = -1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <string>\nusing namespace std;\n\nconst int kMax = 1048600;\nconst int kInf = 1000000000;\n\nstring S;\nint N, Q;\nint Qk[150010];\n\nset< int > L, R;\nint Tm[kMax], Td[kMax];\n\nvoid read();\nvoid solve();\n\nvoid update(int, int, int, int, int, int);\nint query(int, int, int, int, int);\n\nint main() {\n  read();\n  solve();\n  return 0;\n}\n\nvoid read() {\n  ios::sync_with_stdio(false);\n\n  cin >> N >> Q >> S, S = \"#\" + S;\n  for (int i = 0; i < Q; ++i)\n    cin >> Qk[i];\n}\n\nvoid solve() {\n  fill(&Tm[0], &Tm[kMax], 0);\n\n  for (int i = 1, s = 0; i <= N; ++i) {\n    if (S[i] == '(')\n      ++s, L.insert(i);\n    else\n      --s, R.insert(i);\n    update(1, 0, N, i - 1, i, s);\n  }\n\n  for (int qi = 0; qi < Q; ++qi) {\n    int p = Qk[qi], t;\n\n    if (S[p] == '(') {\n      // flip query\n      S[p] = ')';\n      update(1, 0, N, p - 1, N, -2);\n      L.erase(p), R.insert(p);\n\n      // find answer\n      t = *R.begin();\n      cout << t << \"\\n\";\n\n      // flip answer\n      S[t] = '(';\n      update(1, 0, N, t - 1, N, 2);\n      R.erase(t), L.insert(t);\n    }\n    else {\n      // flip query\n      S[p] = '(';\n      update(1, 0, N, p - 1, N, 2);\n      R.erase(p), L.insert(p);\n\n      // find answer\n      int low = 1, up = N, mid;\n      while (low < up) {\n        mid = (low + up) / 2;\n        if (query(1, 0, N, mid - 1, N) >= 2)\n          up = mid;\n        else\n          low = mid + 1;\n      }\n      t = *L.lower_bound(up);\n      cout << t << \"\\n\";\n\n      // flip answer\n      S[t] = ')';\n      update(1, 0, N, t - 1, N, -2);\n      L.erase(t), R.insert(t);\n    }\n  }\n}\n\nvoid update(int u, int l, int r, int ql, int qr, int qd) {\n  if (ql <= l && r <= qr)\n    Tm[u] += qd, Td[u] += qd;\n  else {\n    int mid = (l + r) / 2;\n\n    if (Td[u] != 0) {\n      update(2 * u,     l, mid, l, mid, Td[u]);\n      update(2 * u + 1, mid, r, mid, r, Td[u]);\n      Td[u] = 0;\n    }\n\n    if (ql < mid) update(2 * u,     l, mid, ql, qr < mid ? qr : mid, qd);\n    if (qr > mid) update(2 * u + 1, mid, r, ql > mid ? ql : mid, qr, qd);\n\n    Tm[u] = min(Tm[2 * u], Tm[2 * u + 1]);\n  }\n}\n\nint query(int u, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr)\n    return Tm[u];\n  else {\n    int mid = (l + r) / 2;\n\n    if (Td[u] != 0) {\n      update(2 * u,     l, mid, l, mid, Td[u]);\n      update(2 * u + 1, mid, r, mid, r, Td[u]);\n      Td[u] = 0;\n    }\n\n    int ret = kInf;\n\n    if (ql < mid) ret = min(ret, query(2 * u,     l, mid, ql, qr < mid ? qr : mid));\n    if (qr > mid) ret = min(ret, query(2 * u + 1, mid, r, ql > mid ? ql : mid, qr));\n\n    return ret;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,s,e) for(int i = (s); i < (e); i++)\n#define FOE(i,s,e) for(int i = (s); i <= (e); i++)\n#define FOD(i,s,e) for(int i = (s); i >= (e); i--)\n#define ll long long\n#define pb push_back\n\nint n, m, x, y, z, k, w;\nchar s[300005];\nint A[300005];\nint T[1200005], label[1200005], close[1200005], open[1200005];\n\nvoid bd(int x, int l, int r)\n{\n\tif (l == r) \n\t{ \n\t\tT[x] = A[l - 1]; \n\t\tif (s[l - 1] == '(') open[x] = l; else close[x] = 1;\n\t\treturn; \n\t}\n\tint mid = (l + r) / 2;\n\tbd(x * 2, l, mid);\n\tbd(x * 2 + 1, mid + 1, r);\n\tT[x] = min(T[x * 2], T[x * 2 + 1]);\n\topen[x] = max(open[x * 2], open[x * 2 + 1]);\n\tclose[x] = close[x * 2] + close[x * 2 + 1];\n}\n\nvoid push(int x)\n{\n\tT[x * 2] += label[x];\n\tT[x * 2 + 1] += label[x];\n\tlabel[x * 2] += label[x];\n\tlabel[x * 2 + 1] += label[x];\n\tlabel[x] = 0;\n}\n\nvoid update(int x, int l, int r, int tl, int tr, int val)\n{\n\tif (tl > r || l > tr) return;\n\tif (tl <= l && r <= tr) \n\t{ \n\t\tT[x] += val; \n\t\tlabel[x] += val; \n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tpush(x);\n\tupdate(x * 2, l, mid, tl, tr, val);\n\tupdate(x * 2 + 1, mid + 1, r, tl, tr, val); \n\tT[x] = min(T[x * 2], T[x * 2 + 1]);\n}\n\nint query_min(int x, int l, int r, int tl, int tr)\n{\n\tif (tl > r || l > tr) return n + 10;\n\tif (tl <= l && r <= tr) return T[x];\n\tint mid = (l + r) / 2;\n\tpush(x);\n\tint a = query_min(x * 2, l, mid, tl, tr);\n\tint b = query_min(x * 2 + 1, mid + 1, r, tl, tr);\n\treturn min(a, b);\n}\n\nvoid bracket(int x, int l, int r, int pos)\n{\n\tif (l == r)\n\t{\n\t\tif (s[l - 1] == '(') s[l - 1] = ')'; else s[l - 1] = '(';\n\t\tclose[x] = 1 - close[x];\n\t\tif (open[x] == 0) open[x] = l; else open[x] = 0;\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\t\n\tif (pos <= mid) bracket(x * 2, l, mid, pos);\n\telse bracket(x * 2 + 1, mid + 1, r, pos);\n\t\n\topen[x] = max(open[x * 2], open[x * 2 + 1]);\n\tclose[x] = close[x * 2] + close[x * 2 + 1];\n}\n\nint q_first_close(int x, int l, int r)\n{\n\tif (l == r) return l;\n\tint mid = (l + r) / 2;\n\tif (close[x * 2] > 0) return q_first_close(x * 2, l, mid);\n\telse return q_first_close(x * 2 + 1, mid + 1, r);\n}\n\nint q_last_one(int l, int r)\n{\n\tint high, low, mid;\n\thigh = r; low = l;\n\t\n\twhile (high - low > 1)\n\t{\n\t\tmid = (high + low) / 2;\n\t\tint x = query_min(1, 1, n, mid, n);\n\t\tif (x >= 2) high = mid;\n\t\telse low = mid;\n\t}\n\treturn high;\n}\n\nint q_first_open(int x, int l, int r, int tl, int tr)\n{\n\tif (l == r) return open[x];\n\tint mid = (l + r) / 2;\n\t\n\tif (tr <= mid) return q_first_open(x * 2, l, mid, tl, tr);\n\tif (tl > mid) return q_first_open(x * 2 + 1, mid + 1, r, tl, tr);\n\t\n\tif (open[x * 2] >= tl) return q_first_open(x * 2, l, mid, tl, tr);\n\telse return q_first_open(x * 2 + 1, mid + 1, r, tl, tr);\n}\n\nint main ()\n{\n\twhile (~scanf(\"%d\", &n))\n\t{\n\t\tscanf(\"%d\", &m);\n\t\tmemset(A, 0, sizeof(A));\n\t\tmemset(T, 0, sizeof(T));\n\t\tmemset(open, 0, sizeof(open));\n\t\tmemset(close, 0, sizeof(close));\n\t\tmemset(label, 0, sizeof(label));\n\t\tx = y = z = k = w = 0;\n\t\t\n\t\tscanf(\"%s\", s);\n\t\tFOR(i, 0, n) if (s[i] == '(') A[i] = 1; else A[i] = -1;\n\t\tFOR(i, 1, n) A[i] += A[i - 1];\n\t\t\n\t\tbd(1, 1, n);\n\t\t\n\t\twhile (m--)\n\t\t{\n\t\t//\tp();\n\t\t\t\n\t\t\tscanf(\"%d\", &x);\n\t\t\t\n\t\t\tif (s[x - 1] == '(') update(1, 1, n, x, n, -2);\n\t\t\telse update(1, 1, n, x, n, 2);\n\t\t\tbracket(1, 1, n, x);\n\n\t\t//\tp();\n\n\t\t\tif (s[x - 1] == ')')\n\t\t\t{\n\t\t\t\ty = q_first_close(1, 1, n);\n\t\t\t\tupdate(1, 1, n, y, n, 2);\n\t\t\t\tbracket(1, 1, n, y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty = q_last_one(1, x);\n\t\t\t\ty = q_first_open(1, 1, n, y, x);\n\t\t\t\tupdate(1, 1, n, y, n, -2);\n\t\t\t\tbracket(1, 1, n, y);\n\t\t\t}\n\t\t\t\n\t\t\tprintf(\"%d\\n\", y);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\n//Segment Tree\nclass SegmentTree{\npublic:\n  int n;\n  vi node;\n  vi ofset;\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n=1;\n    while(n<n_)n*=2;\n\n    node = vi(2*n-1, INF);\n    for(int i=0;i<n_;i++)node[i+n-1] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n\n    ofset = vi(2*n-1,0);\n  }\n\n  //return minimum value in [a,b). ( [l,r) is interval in which k is.)\n  int rmq(int a,int b,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b)return node[k]+ofset[k];\n    int pl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int pr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(pl,pr) + ofset[k];\n  }\n\n  int search(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b && node[k]+ofset[k] >= v)return l;\n    if(r-l<=1)return INF;\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    if(vr + ofset[k] >= v){\n      int res = search(a,b,v,2*k+1,l,(l+r)/2);\n      return min(res, (l+r)/2);\n    }else{\n      int res = search(a,b,v,2*k+2,(l+r)/2,r);\n      return res;\n    }\n  }\n \n  int update_range(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return node[k];\n    if(a<=l && r<=b){\n      ofset[k] += v;\n      return node[k]+ofset[k];\n    }\n\n    int vl = update_range(a,b,v,2*k+1,l,(l+r)/2);\n    int vr = update_range(a,b,v,2*k+2,(l+r)/2,r);\n    node[k] = min(vl,vr);\n    return node[k]+ofset[k];\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n\n  set<int> minus;\n  vi h(n,1);\n  rep(i,n-1){\n    if(s[i+1] == '(')h[i+1] = h[i] + 1;\n    else{\n      h[i+1] = h[i] - 1;\n      minus.insert(i+1);\n    }\n  }\n  SegmentTree st(h);\n\n  while(q--){\n    int p;\n    cin >> p; p--;\n    if(s[p] == '('){\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n\n      p = *minus.begin();\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n    }else{\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n\n      p = st.search(0,p+1,2);\n      assert(p<INF);\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n    }\n    /*\n    for(int i=0;i<2*st.n-1;i++){\n      cerr << st.node[i] << \" \" << st.ofset[i] << endl;\n      }*/\n\n    cout << p+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconstexpr type INIT = (1 << 28);\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> value;\n\tvector<type> lazy;\n\n\ttype function(type a, type b) {\n\t\treturn min(a, b);\n\t}\n\n\tvoid evaluate(int k, int number_of_children) {\n\t\tif(lazy[k] == 0) return;\n\t\tif(number_of_children > 1) {\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t}\n\n\t\tvalue[k] += lazy[k];\n\t\tlazy[k] = 0;\n\t}\n\n\t// [a, b)にvを加える\n\tvoid add(int a, int b, type v, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tlazy[k] += v;\n\t\t}\n\t\telse {\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tevaluate(k, r - l);\n\t\t\tadd(a, b, v, k * 2 + 1, l, m);\n\t\t\tadd(a, b, v, k * 2 + 2, m, r);\n\t\t\tvalue[k] = function(value[k * 2 + 1], value[k * 2 + 2]);\n\t\t}\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INIT;\n\t\tevaluate(k, r - l);\n\t\tif(a <= l && r <= b) return value[k];\n\n\t\tconst int m = (l + r) / 2;\n\t\tconst type vl = query(a, b, k * 2 + 1, l, m);\n\t\tconst type vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn function(vl, vr);\n\t}\n\npublic:\n\tsegment_tree(int n_):n(1) {\n\t\twhile(n < n_) n *= 2;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\n\tsegment_tree(const vector<int> &a):n(1) {\n\t\tconst int n_ = a.size();\n\t\twhile(n < n_) n *= 2;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\n\t\tfor(int i = 0; i < n_; ++i) {\n\t\t\tvalue[i + n - 1] = a[i];\n\t\t}\n\n\t\tfor(int i = n - 2; i >= 0; --i) {\n\t\t\tvalue[i] = function(value[2 * i + 1], value[2 * i + 2]);\n\t\t}\n\t}\n\n\tvoid add(int a, int b, type v) {\n\t\tadd(a, b, v, 0, 0, n);\n\t}\n\n\ttype query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tstring s;\n\tcin >> s;\n\n\tset<int> S;\n\n\tint sum = 0;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(s[i] == '(') {\n\t\t\t++sum;\n\t\t}\n\t\telse {\n\t\t\t--sum;\n\t\t\tS.insert(i);\n\t\t}\n\n\t\ta[i] = sum;\n\t}\n\n\tsegment_tree seg(a);\n\n\twhile(q--) {\n\t\tint p;\n\t\tcin >> p;\n\t\t--p;\n\n\t\tif(s[p] == '(') {\n\t\t\ts[p] = ')';\n\t\t\tS.insert(p);\n\t\t\tseg.add(p, n, -2);\n\n \t\t\tconst int res = *S.begin();\n\n\t\t\ts[res] = '(';\n\t\t\tS.erase(res);\n\t\t\tseg.add(res, n, 2);\n\n\t\t\tcout << res + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\ts[p] = '(';\n\t\t\tS.erase(p);\n\t\t\tseg.add(p, n, 2);\n\n\t\t\tint L = 0, R = p;\n\t\t\twhile(L + 1 < R) {\n\t\t\t\tconst int M = (L + R) / 2;\n\n\t\t\t\tif(seg.query(M, p) <= 1) {\n\t\t\t\t\tL = M;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tR = M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(s[R] == '(');;\n\n\t\t\ts[R] = ')';\n\t\t\tS.insert(R);\n\t\t\tseg.add(R, n, -2);\n\n\t\t\tcout << R + 1 << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nint main()\n{\n  string cline;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>cline;\n\n  //solve\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(cline[flip]=='(')\n\t{\n\t  cline[flip]=')';\n\t  int ans=cline.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  cline[ans]='(';\n\n\t}\n      else\n\t{\n\t  cline[flip]='(';\n\t  int cnt=0;\n\t  rep_a_to(flip,j,n-1)\n\t    {\n\t      if(cline[j]=='(')cnt++;\n\t      else cnt--;\n\t    }\n\t  int ans;\n\t  if(cnt>=0)\n\t    ans=flip;\n\t  else\n\t    ans=cline.find('(',1);\n\t  cout<<ans+1<<endl;\n\t  cline[ans]=')';\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate <typename T>\nclass StarrySkyTree {\n\tconst int n;\n\tvector<T> data, lazy;\n\tvoid add_sub(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) { lazy[node] += val; return; }\n\t\tint left = node * 2, right = left + 1;\n\t\tadd_sub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tadd_sub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata[node] = min(data[left] + lazy[left], data[right] + lazy[right]);\n\t}\n\tT min_sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return INF;\n\t\tif (l <= lb && ub <= r) return data[node] + lazy[node];\n\t\tT vl = min_sub(l, r, node * 2 + 0, lb, (lb + ub) / 2);\n\t\tT vr = min_sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t\treturn lazy[node] + min(vl, vr);\n\t}\n\tint size(int n) {\n\t\treturn n == 1 ? n : size((n + 1) / 2) * 2;\n\t}\npublic:\n\tStarrySkyTree(int m) : n(size(m)), data(n * 2, 0), lazy(n * 2, 0) {}\n\tvoid add(int l, int r, T val) { add_sub(l, r, 1, 0, n, val); }\n\tT minimum(int l, int r) { return min_sub(l, r, 1, 0, n); }\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s; cin >> s;\n\tStarrySkyTree<int> seg(N+1);\n\tvi sum(N + 1);\n\tREP(i, N)\n\t{\n\t\tsum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n\t\tseg.add(i + 1, i + 2, sum[i + 1]);\n\t}\n\tset<int> st;\n\tREP(i, N)\n\t{\n\t\tif (s[i] == ')') st.insert(i);\n\t}\n\twhile (Q--)\n\t{\n\t\tint t; cin >> t;\n\t\tt--;\n\t\tif (s[t] == '(')\n\t\t{\n\t\t\ts[t] = ')';\n\t\t\tst.insert(t);\n\t\t\tseg.add(t, N + 1, -2);\n\t\t\tint flip = *st.begin();\n\t\t\ts[flip] = '(';\n\t\t\tseg.add(flip, N + 1, 2);\n\t\t\tst.erase(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t\telse if(s[t] == ')')\n\t\t{\n\t\t\ts[t] = '(';\n\t\t\tst.erase(t);\n\t\t\tseg.add(t, N + 1, 2);\n\t\t\tint l = 0, r = t;\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tif (seg.minimum((l + r) / 2, r) == 0)\n\t\t\t\t{\n\t\t\t\t\tl = (l + r) / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tr = (l + r) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flip = r;\n\t\t\ts[flip] = ')';\n\t\t\tseg.add(flip, N + 1, -2);\n\t\t\tst.insert(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i&#8212;-)\n\nint main()\n{\n  string cline;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>cline;\n\n  //solve\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(cline[flip]=='(')\n\t{\n\t  cline[flip]=')';\n\t  int ans=cline.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  cline[ans]='(';\n\n\t}\n      else\n\t{\n\t  cline[flip]='(';\n\t  int cnt=0;\n\t  rep_a_to(flip,j,n-1)\n\t    {\n\t      if(cline[j]=='(')cnt++;\n\t      else cnt--;\n\t    }\n\t  int ans;\n\t  if(cnt>=0)\n\t    ans=flip;\n\t  else\n\t    ans=cline.find('(',1);\n\t  cout<<ans+1<<endl;\n\t  cline[ans]=')';\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat, dat2, lazy;\n\npublic:\n  SegmentTree() {\n  }\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = lazy = vector<int>(n*2-1, 0);\n    dat2 = vector<int>(n*2-1, 0);\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += dat[k*2+1] + dat[k*2+2];\n    dat2[k] = min(dat2[k], min(dat2[k*2+1], dat2[k*2+2]));\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        int l = 0, r = N;\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(m, N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << r + 1 << endl;\n        change(r);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> lp,rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        assert(s[lhs]=='(');\n        assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                //assert(s[l+1]=='(');\n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#include<climits>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\n\nstruct StarrySkyTree{\n\tint n;\n\tstd::vector<long long> segv,segAdd;\n\tvoid add(int a,int b,int x,int k,int l,int r){\n\t\tif(r<=a || b<=l)return;\n\t\tif(a<=l && r<=b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tint m=(l+r)/2;\n\t\tadd(a,b,x,2*k+1,l,m);\n\t\tadd(a,b,x,2*k+2,m,r);\n\t\tsegv[k]=std::min(segAdd[2*k+1]+segv[2*k+1] ,segAdd[2*k+2]+segv[2*k+2]);\n\t}\n\tlong long min(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a || b<=l)return LLONG_MAX;\n\t\tif(a<=l && r<=b){\n\t\t\treturn segv[k]+segAdd[k];\n\t\t}\n\t\tint m=(l+r)/2;\n\t\treturn segAdd[k]+std::min(min(a,b,2*k+1,l,m),min(a,b,2*k+2,m,r));\n\t}\npublic:\n\tStarrySkyTree(int n=1<<19){\n\t\tinit(n);\n\t}\n\tvoid init(int n){\n\t\tthis->n=n;\n\t\tsegv.assign(2*n-1,0);\n\t\tsegAdd.assign(2*n-1,0);\n\t}\n\tvoid add(int a,int b,int x){//[a,b)にxを加算\n\t\tadd(a,b,x,0,0,n);\n\t}\n\tlong long min(int a,int b)const{//[a,b)の最小値\n\t\treturn min(a,b,0,0,n);\n\t}\n};\n\n\n\nint main(){\n\tStarrySkyTree sst;\n\tset<int> s;\n\tstring str;\n\tint n,q;\n\tcin>>n>>q>>str;\n\trep(i,n){\n\t\tif(str[i]=='(')sst.add(i,n,1);\n\t\telse{\n\t\t\tsst.add(i,n,-1);\n\t\t\ts.insert(i);\n\t\t}\n\t}\n\trep(i,q){\n\t\tint p;\n\t\tcin>>p;\n\t\tp--;\n\t\tint lb,ub,ans;\n\t\tif(str[p]=='('){\n\t\t\tstr[p]=')';\n\t\t\tsst.add(p,n,-2);\n\t\t\ts.insert(p);\n\t\t\tans=*s.begin();\n\t\t\tstr[ans]='(';\n\t\t\tsst.add(ans,n,2);\n\t\t\ts.erase(ans);\n\t\t\tans++;\n\t\t}else{\n\t\t\tstr[p]='(';\n\t\t\tsst.add(p,n,2);\n\t\t\ts.erase(p);\n\t\t\tlb=-1;ub=n-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(sst.min(m,n)>=2)ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tstr[ub]=')';\n\t\t\tsst.add(ub,n,-2);\n\t\t\ts.insert(ub);\n\t\t\tans=ub+1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tint query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tint query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tbit b2(n); for (int i = 0; i < n; i++) b2.update(i, d[i]);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = b2.query(0, r), pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0); b2.update(r, 1);\n\t\t\td[l] = -1; b1.update(l, 1); b2.update(l, -1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1); b2.update(r, -1);\n\t\t\td[pr] = 1; b1.update(pr, 0); b2.update(pr, 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 28;\n\nstruct SegmentTree\n{\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n  inline int BinarySearch(int k, int l, int r, int upd)\n  {\n    if(k >= sz - 1) return(r);\n    const int right = small[2 * k + 2] + add[2 * k + 2] + add[k] + upd;\n    if(right >= 2) return(BinarySearch(2 * k + 1, l, (l + r) >> 1, upd + add[k]));\n    return(BinarySearch(2 * k + 2, (l + r) >> 1, r, upd + add[k]));\n  }\n  int BinarySearch()\n  {\n    return(BinarySearch(0, 0, sz, 0));\n  }\n};\n\nint main()\n{\n  int N, Q;\n\n  scanf(\"%d %d\", &N, &Q);\n  char S[300001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > open, close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, i + 1, -INF);\n  }\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n    else open.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      open.erase(q);\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      open.insert(*close.begin());\n      close.erase(close.begin());\n      \n    } else {\n      close.erase(q);\n      open.insert(q);\n      S[q] = '(';\n      int pos = *open.lower_bound(tree.BinarySearch());\n      printf(\"%d\\n\", pos + 1);\n      tree.RangeAdd(pos, N, -2);\n      S[pos] = ')';\n      open.erase(pos);\n      close.insert(pos);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<19;\n\tint dp[1<<20];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\tvoid update(int k,int v){\n\t\tk+=N-1;\n\t\tdp[k]=v;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t\t}\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\treturn min(vl,vr);\n\t}\n};\n\nclass rsegtree{\npublic:\n\tstatic const int N=1<<19;\n\tint dp[1<<20];\n\tint lazy[1<<20];\n\trsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\n\tvoid lazy_eval(int k){\n\t\tdp[k]+=lazy[k];\n\t\tif(k<N-1){\n\t\t\tlazy[k*2+1]+=lazy[k];\n\t\t\tlazy[k*2+2]+=lazy[k];\n\t\t}\n\t\tlazy[k]=0;\n\t}\n\tvoid lazy_upd(int k){\n\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t}\n\n\tvoid update(int a,int b,int v,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return;\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]+=v;\n\t\t\tlazy_eval(k);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tupdate(a,b,v,k*2+1,l,mid);\n\t\tupdate(a,b,v,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t\treturn min(vl,vr);\n\t}\n};\n\nsegtree seg;\nrsegtree rseg;\nint n,q;\nstring str;\nint type[300005];\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tcin >> str;\n\tfor(int i=0;i<n;i++){\n\t\tif(str[i]=='('){\n\t\t\ttype[i]=1;\n\t\t\tseg.update(i,INF);\n\t\t\trseg.update(i+1,n+1,1);\n\t\t}else{\n\t\t\ttype[i]=-1;\n\t\t\tseg.update(i,i);\n\t\t\trseg.update(i+1,n+1,-1);\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\ttype[a]=-type[a];\n\t\tif(type[a]==-1){\n\t\t\tseg.update(a,a);\n\t\t\trseg.update(a+1,n+1,-2);\n\t\t\tint v=seg.query(0,n);\n\t\t\tprintf(\"%d\\n\",v+1);\n\t\t\tseg.update(v,INF);\n\t\t\trseg.update(v+1,n+1,2);\n\t\t\ttype[v]=-type[v];\n\t\t}else{\n\t\t\tseg.update(a,INF);\n\t\t\trseg.update(a+1,n+1,2);\n\t\t\tint l=0,r=a+1;\n\t\t\twhile(l+1<r){\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\trseg.update(mid,n+1,-2);\n\t\t\t\tif(rseg.query(mid,n+1)>=0)r=mid;\n\t\t\t\telse l=mid;\n\t\t\t\trseg.update(mid,n+1,2);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",r);\n\t\t\tseg.update(r-1,r-1);\n\t\t\trseg.update(r,n+1,-2);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  set<int> open_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  REP(i, N) if(S[i] == '(') open_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      open_parens.erase(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      open_parens.insert(min_idx);\n      \n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        // pos_seg.add(min_idx, min_idx + 1, -1);\n        // pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val;// = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        pos_pos = *open_parens.lower_bound(sum_pos+1);\n        \n        assert(S[pos_pos] == '(');\n        // assert(sum_seg.min(pos_pos + 1, q + 1) >= 0);\n        // assert(sum_seg.min(0, N + 1) >= 0);\n        // assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        cout << pos_pos + 1 << endl;\n        \n        close_parens.erase(q);\n        close_parens.insert(pos_pos);\n\n        open_parens.insert(q);\n        open_parens.erase(pos_pos);\n        \n        sum_seg.add(q + 1, N + 1, 2);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        \n        // pos_seg.add(q, q + 1, -1);\n        // pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTreeSum {\nprivate:\n  int n;\n  vector<int> dat, lazy;\n\npublic:\n  SegmentTreeSum(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = lazy = vector<int>(n*2-1);\n  }\n\n  int update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      return 0;\n    }\n    int v1 = update(a, b, x, k*2+1, l, (l+r)/2);\n    int v2 = update(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += v1 + v2;\n    return v1 + v2;\n  }\n\n  int query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = query(a, b, k*2+1, l, (l+r)/2);\n    int v2 = query(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n};\n\nclass SegmentTreeMin {\nprivate:\n  int n;\n  vector<int> dat, dat2, lazy;\n\npublic:\n  SegmentTreeMin(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = lazy = vector<int>(n*2-1, 0);\n    dat2 = vector<int>(n*2-1, 0);\n  }\n\n  int update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      return 0;\n    }\n    int v1 = update(a, b, x, k*2+1, l, (l+r)/2);\n    int v2 = update(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += v1 + v2;\n    dat2[k] = min(dat2[k], min(dat2[k*2+1], dat2[k*2+2]));\n    return v1 + v2;\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint main() {\n  for (int N, Q; cin >> N >> Q; ) {\n    string s; cin >> s;\n    SegmentTreeMin seg(N);\n    set<int> cs;\n    for (int i = 0; i < s.size(); ++i) {\n      if (s[i] == ')') cs.insert(i);\n      seg.update(i, N, s[i] == '(' ? +1 : -1);\n    }\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        s[q] = ')';\n        seg.update(q, N, -2);\n        cs.insert(q);\n        int p = *cs.begin();\n\n        cout << p + 1 << endl;\n        s[p] = '(';\n        seg.update(p, N, +2);\n        cs.erase(p);\n\n      } else { // ')' => '('\n        s[q] = '(';\n        seg.update(q, N, +2);\n        cs.erase(q);\n        int l = 0, r = N;\n        while (r-l) {\n          int m = (l + r) / 2;\n          //cout << m << \" \" << seg.mini(m, N) << endl;\n          if (seg.mini(m, N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n\n        cout << r + 1 << endl;\n        s[r] = ')';\n        seg.update(r, N, -2);\n        cs.insert(r);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n  };\n  \n  D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D &a,D &b){\n    if(a.value < b.value) return a;\n    return b;\n  }\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D add(Int a,Int b,Int x,bool flg=true,Int k=0,Int l=0,Int r=-1){\n    if(r==-1 && toMax) x *= -1; \n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = add(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    D res = add(a,b,0,false);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    int val = s[x] == '('? -2:2;\n    A.add(0, n, val);\n    Int res = 1;\n    if(A.find(0, n) < 0) res = 0;\n    if(A.find(n-1, n) != 0) res = 0;\n    A.add(0, n, -val);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(it == par.end()) {R = M;continue;}\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    return *par.lower_bound(R);\n  };\n\n  for(Int i=0;i<q;i++){\n    Int x;\n    scanf(\"%lld\",&x);\n    rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    printf(\"%lld\\n\",y+1);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n\n#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef int type;\nconstexpr type INIT = (1 << 28);\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> value;\n\tvector<type> lazy;\n\n\tstatic inline type function(type a, type b) {\n\t\treturn min(a, b);\n\t}\n\n\tvoid evaluate(int k, int number_of_children) {\n\t\tif(lazy[k] == 0) return;\n\t\tif(number_of_children > 1) {\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t}\n\n\t\tvalue[k] += lazy[k];\n\t\tlazy[k] = 0;\n\t}\n\n\tvoid add(int a, int b, type v, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tlazy[k] += v;\n\t\t}\n\t\telse {\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tevaluate(k, r - l);\n\t\t\tadd(a, b, v, k * 2 + 1, l, m);\n\t\t\tadd(a, b, v, k * 2 + 2, m, r);\n\t\t\tvalue[k] = function(query(l, m, k * 2 + 1, l, m), query(m, r, k * 2 + 2, m, r));\n\t\t}\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INIT;\n\t\tevaluate(k, r - l);\n\t\tif(a <= l && r <= b) return value[k];\n\n\t\tconst int m = (l + r) / 2;\n\t\tconst type vl = query(a, b, k * 2 + 1, l, m);\n\t\tconst type vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn function(vl, vr);\n\t}\n\n\tint search(int a, int b, type v, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return -1;\n\t\tevaluate(k, r - l);\n\n\t\tif(v < value[k]) return max(a, l);\n\t\tif(r - l == 1) return r;\n\n\t\tconst int m = (l + r) / 2;\n\t\tconst int r_idx = search(a, b, v, k * 2 + 2, m, r);\n\t\tif(r_idx != -1 && r_idx != m) return r_idx;\n\t\tconst int l_idx = search(a, b, v, k * 2 + 1, l, m);\n\t\treturn l_idx != -1 ? l_idx : m;\n\t}\n\npublic:\n\tsegment_tree(int n_):n(1) {\n\t\twhile(n < n_) n <<= 1;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\n\tsegment_tree(const vector<int> &a):n(1) {\n\t\tconst int n_ = a.size();\n\t\twhile(n < n_) n <<= 1;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\n\t\tfor(int i = 0; i < n_; ++i) {\n\t\t\tvalue[i + n - 1] = a[i];\n\t\t}\n\n\t\tfor(int i = n - 2; i >= 0; --i) {\n\t\t\tvalue[i] = function(value[2 * i + 1], value[2 * i + 2]);\n\t\t}\n\t}\n\n\tvoid add(int a, int b, type v) {\n\t\tadd(a, b, v, 0, 0, n);\n\t}\n\n\ttype query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tint search(int a, int b, type v) {\n\t\treturn search(a, b, v, 0, 0, n);\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tstring s;\n\tcin >> s;\n\n\tset<int> S;\n\n\tint sum = 0;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(s[i] == '(') {\n\t\t\t++sum;\n\t\t}\n\t\telse {\n\t\t\t--sum;\n\t\t\tS.insert(i);\n\t\t}\n\n\t\ta[i] = sum;\n\t}\n\n\tsegment_tree seg(a);\n\n\twhile(q--) {\n\t\tint p;\n\t\tcin >> p;\n\t\t--p;\n\n\t\tif(s[p] == '(') {\n\t\t\ts[p] = ')';\n\t\t\tS.insert(p);\n\t\t\tseg.add(p, n, -2);\n\n \t\t\tconst int res = *S.begin();\n\t\t\tassert(s[res] == ')');\n\n\t\t\ts[res] = '(';\n\t\t\tS.erase(res);\n\t\t\tseg.add(res, n, 2);\n\n\t\t\tcout << res + 1 << '\\n';\n\t\t}\n\t\telse {\n\t\t\ts[p] = '(';\n\t\t\tS.erase(p);\n\t\t\tseg.add(p, n, 2);\n\n\t\t\tconst int res = seg.search(0, p + 1, 1);\n\t\t\tassert(s[res] == '(');\n\n\t\t\ts[res] = ')';\n\t\t\tS.insert(res);\n\t\t\tseg.add(res, n, -2);\n\n\t\t\tcout << res + 1 << '\\n';\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n,height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){init(n_);}\n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n  inline T reflect(int k){\n    return g(dat[k],laz[k]);\n  }\n  inline void eval(int k){\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    dat[k]=reflect(k);\n    laz[k]=ei;\n  }\n  inline void thrust(int k){\n    for(int i=height;i;i--) eval(k>>i);    \n  }\n  inline void recalc(int k){    \n    while(k>>=1)\n      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n  }\n  void update(int a,int b,E x){\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n  void set_val(int a,T x){\n    thrust(a+=n);\n    dat[a]=x;laz[a]=ei;\n    recalc(a);\n  }\n  T query(int a,int b){\n    thrust(a+=n);\n    thrust(b+=n-1);\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }\n};\n\n//INSERT ABOVE HERE\nchar buf[314514];\nsigned main(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  scanf(\"%s\",buf);\n  string s(buf);\n  \n  set<int> pos;\n  for(int i=0;i<n;i++)\n    if(s[i]==')') pos.emplace(i);\n\n  auto f=[](int a,int b){return min(a,b);};\n  auto g=[](int a,int b){return a+b;};\n  const int INF = 1e7;\n  SegmentTree<int, int> seg(n,f,g,g,INF,0);\n\n  int h=0;\n  vector<int> v(n);\n  for(int i=0;i<n;i++){\n    if(s[i]=='(') h++;\n    if(s[i]==')') h--;\n    v[i]=h;\n  }\n  seg.build(n,v);\n  \n  for(int i=0;i<q;i++){\n    int p;\n    scanf(\"%d\",&p);\n    p--;\n    if(s[p]=='('){\n      s[p]=')';      \n      pos.emplace(p);\n      seg.update(p,n,-2);\n      int a=*pos.begin();\n      s[a]='(';\n      pos.erase(a);\n      seg.update(a,n,2);\n      printf(\"%d\\n\",a+1);\n    }else{\n      s[p]='(';\n      pos.erase(p);\n      seg.update(p,n,2);\n      int l=0,r=p;\n      while(l+1<r){\n\tint m=(l+r)>>1;\n\tif(seg.query(m,n)>=2) r=m;\n\telse l=m;       \n      }      \n      s[r]=')';\n      pos.emplace(r);\n      seg.update(r,n,-2);\n      printf(\"%d\\n\",r+1);\n    }    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                // assert(s[l]=='(');                \n                // assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \nint segMin[1 << 20], segAdd[1 << 20];\nint n, q;\nchar s[300001];\n  \nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return;\n      \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        return;\n    }\n      \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n}\n  \nint getMin(int a, int b, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return (INT_MAX);\n      \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n      \n    int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2);\n    int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r);\n      \n    return (min(left, right) + segAdd[k]);\n      \n}\n  \nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n      \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n      \n    add(x, n, 2 * base);\n      \n    int l = 0, r = x;\n    int p;\n      \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        if (getMin(p, n) >= 2 * base) r = mid;\n        else l = mid + 1;\n    }\n      \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n      \n    printf(\"%d\\n\", p + 1);\n}\n  \nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n      \n    set<int> lf, rg;\n      \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n      \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n          \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n      \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        assert(l<=q && q<r);\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                assert(s[l]=='(');                \n                // assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 500;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray {\n  const int B;\n  SegmentArray(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      else {\n        int st = std::max(a, l), en = std::min(b, r);\n        for(int i = en - 1; i >= st; --i) {\n          if(add[k] + data[i] < 2) {\n            return i + 1;\n          }\n        }\n      }\n    }\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray seg1(N);\n  set<int> seg2;\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.insert(i);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.insert(p);\n      seg1.update(p, N, -2);\n      int np = *seg2.begin();\n      S[np] = '(';\n      seg2.erase(np);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      S[p] = '(';\n      seg2.erase(p);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      S[np] = ')';\n      seg2.insert(np);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\n\nbool check(string& S){\n  int p=0;\n  for(auto ch : S){\n    if(ch == '(') ++p;\n    else --p;\n    if( p < 0) return false;\n  }\n  return p == 0;\n}\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  set<int> open_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  REP(i, N) if(S[i] == '(') open_parens.insert(i);\n\n  string naive_S = S;\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n\n    // cout << \"before \" << endl;\n    // cout << naive_S << endl;\n    \n    if(naive_S[q] == '(') naive_S[q] = ')';\n    else naive_S[q] = '(';\n\n    // for(int i = 0; i < N; ++i){\n    //   char ch = naive_S[i];\n    //   if(naive_S[i] == '(') naive_S[i] = ')';\n    //   else naive_S[i] = '(';\n    //   if(check(naive_S)) break;\n    //   naive_S[i] = ch;\n    // }\n\n    \n    \n    // for(int i = 0; i < N; ++i)\n    //   cout << sum_seg.sum(i,i+1) << \" \";\n    // cout << endl;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      open_parens.erase(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      open_parens.insert(min_idx);\n      \n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        // pos_seg.add(min_idx, min_idx + 1, -1);\n        // pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        {\n          int low = 0;\n          int up = q+1;\n          while(low+1 < up){\n            int mid = (low+up)/2;\n            if(sum_seg.min(mid,q+1) >= 2)\n              up = mid;\n            else\n              low = mid;\n          }\n          sum_pos = up-2;\n        }\n        int pos_val;// = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        //cout << sum_pos << endl;\n        pos_pos = *open_parens.lower_bound(sum_pos+1);\n        \n        assert(S[pos_pos] == '(');\n        cout << pos_pos + 1 << endl;\n        \n\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        \n        // pos_seg.add(q, q + 1, -1);\n        // pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          \n          close_parens.erase(q);\n          close_parens.insert(pos_pos);\n        \n          open_parens.insert(q);\n          open_parens.erase(pos_pos);\n\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n    // cout << naive_S << endl;\n    // cout << S << endl;\n    // assert(naive_S == S);\n    \n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\n\nstruct BIT\n{\n  int n;\n  vector<int> tree;\n  BIT(int n_)\n  {\n    tree = vector<int>(n_ + 1, 0);\n    n = n_;\n  }\n  int sum(int i)\n  {\n    int ret = 0;\n    while( i > 0 ) {\n      ret += tree[i];\n      i -= i & -i;\n    }\n    return ret;\n  }\n  void add(int i, int x)\n  {\n    while( i <= n ) {\n      tree[i] += x;\n      i += i & -i;\n    }\n  }\n};\n\n\nmain()\n{\n  int N, Q;\n  string s;\n  BIT L(N+1), R(N+1); //L:(  R:)\n\n  cin >> N >> Q >> s;\n\n  Rep(i, N) {\n    if( s[i] == '(' ) L.add( i+1, 1 );\n    else R.add( i+1, 1 );\n  }\n\n  while( Q-- ) {\n    //cout << L.sum( N ) << \" \" << R.sum( N ) << endl;\n    int q;\n    cin >> q;\n\n    if( L.sum( q ) - L.sum( q-1 ) == 1 ) { // ( -> )\n      L.add( q, -1 );\n      R.add( q, 1 );\n      int l = 1, r = q;\n      while( r - l > 1 ) {\n\tint mod = (l + r) / 2;\n\tif( R.sum( mod ) ) r = mod;\n\t  else l = mod;\n      }\n      \n      if( R.sum( l ) ) {\n\tcout << l << endl;\n\tR.add( l, -1 );\n\tL.add( l, 1 );\n      }\n      else {\n\tcout << r << endl;\n\tR.add( r, -1 );\n\tL.add( r, 1 );\n      }\n    }\n\n    else { // ) -> (\n      //cout << 'R' << endl;\n      L.add( q, 1 );\n      R.add( q, -1 );\n      if( q != N && L.sum( N ) - L.sum( q-1 ) <= R.sum( N ) - R.sum( q-1 ) ) {\n\n\tint l = 2, r = q;\n\twhile( r - l > 1 ) {\n\t  int mod = (l + r) / 2;\n\t  if( L.sum( mod ) > R.sum( mod ) ) r = mod;\n\t  else l = mod;\n\t}\n\t\n\tif( L.sum( l ) > R.sum( l ) ) {\n\t  cout << l << endl;\n\t  L.add( l, -1 );\n\t  R.add( l, 1 );\n\t}\n\telse {\n\t  cout << r << endl;\n\t  L.add( r, -1 );\n\t  R.add( r, 1 );\n\t}\n      } else {\n\tL.add( q, -1 );\n\tR.add( q, 1 );\n\tcout << q << endl;\n      }\n    }\n  }\n  \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T> struct range_add {\n  static constexpr T inf = numeric_limits<T>::max() / 2;\n  struct node { T delta = 0, min = inf, max = -inf, len = 0, sum = 0; };\n  static node op(const node& l, const node& r) {\n    return {\n      l.delta + r.delta,\n      std::min(l.min, l.delta + r.min), std::max(l.max, l.delta + r.max),\n      l.len + r.len, l.sum + l.delta * r.len + r.sum\n    };\n  }\n  static node make_node(T a) { return {a, a, a, 1, a}; }\n  const int n;\n  vector<node> t;\n  range_add(const vector<T>& v) : n(v.size() + 1), t(2 * n) {\n    for (int i = n - 1; i--; ) t[n + i] = make_node(v[i] - (i ? v[i - 1] : 0));\n    for (int i = n; i-- > 1; ) t[i] = op(t[2 * i], t[2 * i + 1]);\n  }\n  node fold(int l, int r) const {\n    node a, b;\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) a = op(a, t[l++]);\n      if (r & 1) b = op(t[--r], b);\n    }\n    return op(a, b);\n  }\n  T get(int i) const { return fold(0, i + 1).delta; }\n  T min(int l, int r) const { return get(l - 1) + fold(l, r).min; }\n  T max(int l, int r) const { return get(l - 1) + fold(l, r).max; }\n  T sum(int l, int r) const { return get(l - 1) * (r - l) + fold(l, r).sum; }\n  void set(int i, const node& a) {\n    t[i += n] = a;\n    while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n  }\n  void add(int l, int r, T a) {\n    set(l, make_node(t[n + l].delta + a));\n    set(r, make_node(t[n + r].delta - a));\n  }\n};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n  vector<int> h(n + 1);\n  set<int> se;\n  for (int i = 0; i < n; ++i) {\n    h[i + 1] = h[i];\n    if (s[i] == '(') {\n      ++h[i + 1];\n    } else {\n      --h[i + 1];\n      se.insert(i);\n    }\n  }\n  range_add<int> ra(h);\n  while (q--) {\n    int i;\n    cin >> i;\n    --i;\n    if (s[i] == '(') {\n      s[i] = ')';\n      se.insert(i);\n      int j = *begin(se);\n      cout << j + 1 << '\\n';\n      se.erase(j);\n      s[j] = '(';\n      ra.add(j + 1, i + 1, 2);\n    } else {\n      if (ra.get(i) == 1) {\n        cout << i + 1 << '\\n';\n        continue;\n      }\n      se.erase(i);\n      s[i] = '(';\n      int ng = 0, ok = i;\n      while (ok - ng > 1) {\n        int mid = (ng + ok) / 2;\n        (ra.min(mid, i) > 1 ? ok : ng) = mid;\n      }\n      int j = ng;\n      cout << j + 1 << '\\n';\n      s[j] = ')';\n      se.insert(j);\n      ra.add(j + 1, i + 1, -2);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < Q; ++i)\n\t{\n\t\tint q;\n\t\tcin >> q;\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < q; ++j)\n\t\t{\n\t\t\tif (s[j] == '(')\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--cnt;\n\t\t\t}\n\t\t}\n\t\t--q;\n\t\tbool left;\n\t\tif (s[q] == '(')\n\t\t{\n\t\t\tleft = true;\n\t\t\ts[q] = ')';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tleft = false;\n\t\t\ts[q] = '(';\n\t\t}\n\n\t\tfor (int j = 0; j <= q; ++j)\n\t\t{\n\t\t\tchar buf = s[j];\n\t\t\tint cnt2 = 0;\n\t\t\tif (left == false && s[j] == '(')\n\t\t\t{\n\t\t\t\ts[j] = ')';\n\t\t\t}\n\t\t\telse if (left == true && s[j] == ')')\n\t\t\t{\n\t\t\t\ts[j] = '(';\n\t\t\t}\n\t\t\tfor (int k = 0; k <= q; ++k)\n\t\t\t{\n\t\t\t\tif (s[k] == '(')\n\t\t\t\t{\n\t\t\t\t\t++cnt2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t--cnt2;\n\t\t\t\t}\n\t\t\t\tif (cnt2 < 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt  == cnt2)\n\t\t\t{\n\t\t\t\tcout << j + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[j] = buf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define MAX 300010\n// #define DEBUG\n\nint N, Q;\nchar str[MAX];\nint nextopen;\nint nextclose;\nint openlimit;\nint closelimit;\nbool hasnextopen;\nbool hasnextclose;\n\nvoid findopenlimit() {\n\n\tif (str[1] == '(' && str[2] == '(') {\n\t\topenlimit = 2;\n\t} else {\n\t\topenlimit = 3;\n\t}\n}\n\nvoid findcloselimit() {\n\n\tif (str[N] == ')' && str[N-1] == ')') {\n\t\tcloselimit = N-1;\n\t} else {\n\t\tcloselimit = N-2;\n\t}\n}\n\n\nvoid findnextopen() {\n\tfor (int i = nextopen; i < N; i++) {\n\t\tif (str[i] == '(' && str[i+1] == '(') {\n\t\t\tnextopen = i;\n\t\t\treturn;\n\t\t}\n\t}\n\thasnextopen = false;\n}\n\nvoid findnextclose() {\n\tfor (int i = nextclose; i < N; i++) {\n\t\tif (str[i] == '(' && str[i+1] == ')') {\n\t\t\tnextclose = i+1;\n\t\t\treturn;\n\t\t}\n\t}\n\thasnextclose = false;\n}\n\nint main() {\n\n\twhile (scanf(\"%d%d\\n\", &N, &Q) == 2) {\n\t\tnextopen = 2;\n\t\tnextclose = 1;\n\t\thasnextopen = true;\n\t\thasnextclose = true;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%c\", &str[i]);\n\t\t}\n\n\t\tfindopenlimit();\n\t\tfindcloselimit();\n\t\tfindnextopen();\n\t\tfindnextclose();\n#ifdef DEBUG\n\t\tprintf(\"openlimit %d\\n\", openlimit);\n\t\tprintf(\"closelimit %d\\n\", closelimit);\n\t\tprintf(\"nextopen %d\\n\", nextopen);\n\t\tprintf(\"nextclose %d\\n\", nextclose);\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tprintf(\"%c\", str[j]);\n\t\t\t}\n\t\tprintf(\"\\n\");\n#endif \n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n#ifdef DEBUG\n\t\t\tprintf(\"Flipping %d\\n\", w);\n#endif \n\t\t\tif (w == 1 || w == N) {\n\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t} else {\n\t\t\t\tif (str[w] == '(') {\n\t\t\t\t\tif (hasnextclose && nextclose < w && w > openlimit) {\n\t\t\t\t\t\tprintf(\"%d\\n\", nextclose);\n\t\t\t\t\t\tstr[w] = ')';\n\t\t\t\t\t\tstr[nextclose] = '(';\n\t\t\t\t\t\tif (nextclose < openlimit) {\n\t\t\t\t\t\t\topenlimit = nextclose;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextclose < nextopen || !hasnextopen) {\n\t\t\t\t\t\t\tnextopen = nextclose;\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"nextopen = %d\\n\", nextopen);\n#endif \t\t\t\t\t\n\t\t\t\t\t\t\thasnextopen = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfindnextclose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasnextopen && nextopen < w && w < closelimit) {\n\t\t\t\t\t\tprintf(\"%d\\n\", nextopen);\n\t\t\t\t\t\tstr[w] = '(';\n\t\t\t\t\t\tstr[nextopen] = ')';\n\t\t\t\t\t\tif (nextopen > closelimit) {\n\t\t\t\t\t\t\tcloselimit = nextopen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextopen < nextclose || !hasnextclose) {\n\t\t\t\t\t\t\tnextclose = nextopen;\t\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"nextclose = %d\\n\", nextclose);\n#endif\n\t\t\t\t\t\t\thasnextclose = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfindnextopen();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef DEBUG\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tprintf(\"%c\", str[j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define LL long long\n#define u32  unsigned int\n#define AA first\n#define BB second\ntypedef pair<int, int> PII;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define PB(x) push_back(x)\n#define SZ size()\n#define MP(a, b) make_pair(a, b)\n#define OP begin()\n#define ED end()\n#define CLR clear()\n#define INS(x) insert(x)\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FORR(i, n) for(int i = 1; i <= n; i++)\n#define MEM(a) memset(a, 0, sizeof a)\n#define ECH(x) for(__typeof x.OP it = x.OP; it != x.ED; it++)\n#define ONES(x) __builtin_popcount(x)\n/*===========================================================*/\n#define N 3000010\n\nint n, Q;\nchar s[3000010];\n\nstruct node\n{\n    int L, R;\n    int a, b;\n    int Max;\n    int Min;\n    int Lazy;\n}f[2 * N];\nint c[N];\nint cnt;\nint rt;\nset<int>S;\n\nvoid update(int x)\n{\n    f[x].Max = max(f[f[x].L].Max, f[f[x].R].Max);\n    f[x].Min = min(f[f[x].L].Min, f[f[x].R].Min);\n}\n\nvoid deal(int x, int c)\n{\n    f[x].Max += c;\n    f[x].Min += c;\n    f[x].Lazy += c;\n}\n\nvoid down(int x)\n{\n    if(f[x].Lazy == 0) return;\n    deal(f[x].L, f[x].Lazy);\n    deal(f[x].R, f[x].Lazy);\n    f[x].Lazy = 0;\n}\n\n\nint build(int a, int b)\n{\n    int x = cnt++;\n    f[x].a = a; f[x].b = b; f[x].Lazy = 0; f[x].Min = f[x].Max = 0;\n    if(a < b)\n    {\n        int mid = (a + b) / 2;\n        f[x].L = build(a, mid);\n        f[x].R = build(mid + 1, b);\n        update(x);\n    }\n    else f[x].Max = f[x].Min = c[a];\n    return x;\n}\n\nvoid insert(int x, int a, int b, int c)\n{\n    if(a <= f[x].a && f[x].b <= b) deal(x, c);\n    else\n    {\n        down(x);\n        int mid = (f[x].a + f[x].b) / 2;\n        if(b <= mid) insert(f[x].L, a, b, c);\n        else if(a > mid) insert(f[x].R, a, b, c);\n        else { insert(f[x].L, a, b, c); insert(f[x].R, a, b, c); }\n        update(x);\n    }\n}\n\nint query(int x, int p)\n{\n    if(f[x].a == f[x].b) return f[x].Min;\n    else\n    {\n        down(x);\n        int mid = (f[x].a + f[x].b) / 2;\n        if(p <= mid) return query(f[x].L, p);\n        return query(f[x].R, p);\n    }\n}\n\nint query(int x, int a, int b)\n{\n    if(a <= f[x].a && f[x].b <= b) return f[x].Min;\n    else\n    {\n        down(x);\n        int mid = (f[x].a + f[x].b) / 2;\n        if(b <= mid) return query(f[x].L, a, b);\n        else if(a > mid) return query(f[x].R, a, b);\n        return min(query(f[x].L, a, b), query(f[x].R, a, b));\n    }\n}\n\nint cal(int p, int c)\n{\n    int L = 1, R = p;\n    while(L < R)\n    {\n        int mid = (L + R) / 2;\n        if(query(rt, mid, p) >= 2) R = mid;\n        else L = mid + 1;\n    }\n    return L;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    while(~scanf(\"%d%d\", &n, &Q))\n    {\n        s[0] = 'a';\n        scanf(\"%s\", s + 1);\n        MEM(c);\n        S.CLR;\n        c[0] = 0;\n        FORR(i, n) { c[i] = c[i - 1]; if(s[i] == '(') c[i]++; else c[i]--; }\n\n        FORR(i, n) if(s[i] == ')') S.insert(i);\n\n        cnt = 0;\n        rt = build(1, n);\n        FOR(i, Q)\n        {\n            int x; scanf(\"%d\", &x); int T;\n            if(s[x] == '(')\n            {\n                if(S.SZ && *S.OP <= x)\n                {\n                    printf(\"%d\\n\", *S.OP);\n                    T = *S.OP;\n                }\n                else\n                {\n                    printf(\"%d\\n\", x);\n                    T = x;\n                }\n                s[x] = ')';\n                s[T] = '(';\n                if(S.find(T) != S.ED) S.erase(S.find(T));\n                S.insert(x);\n                insert(rt, x, n, -2);\n                insert(rt, T, n, 2);\n            }\n            else\n            {\n                int p;\n                if(x - 1 > 0 && query(rt, x - 1) >= 2) p = cal(x - 1, query(rt, x));\n                else p = x;\n                printf(\"%d\\n\", p);\n                T = p;\n                s[x] = '(';\n                s[T] = ')';\n                if(S.find(x) != S.ED)S.erase(S.find(x));\n                S.insert(T);\n                insert(rt, x, n, 2);\n                insert(rt, T, n, -2);\n            }\n            //cout <<\"S \";  FORR(i, n) cout << query(rt, i, i) << \" \"; cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main(void)\n{\n  int  N,Q;\n  cin >> N;\n  cin >> Q;\n  int log2N=((int)log2(N))+1;\n  int nodenum=(1<<log2N)*2-1;\n  int segt[nodenum];\n  char s[N];\n  for(int i=0;i<N;i++){cin>>s[i];}\n  int q[Q];\n  for(int i=0;i<Q;i++){cin>>q[i];}\n  // construct reafs of segment tree\n  for(int i=0;i<N;i++)\n    {\n      segt[(1<<log2N)-1+i]=(s[i]=='(')?(1):(-1);\n    }\n  for(int i=(1<<log2N)-1+N;i<nodenum;i++)\n    {\n      segt[i]=0;\n    }\n  // construct segment tree\n  for(int i=log2N-1;i>=0;i--){\n    for(int j=(1<<i)-1;j<(1<<(i+1))-1;j++)\n      {\n\tsegt[j]=segt[2*j+1]+segt[2*j+2];\n      }\n  }\n  // reculculation\n  for(int k=0;k<Q;k++)\n    {\n      // segt の更新\n      int ptr=(1<<log2N)-1+q[k]-1;\n      segt[ptr]=-segt[ptr];\n      ptr=(int)((ptr-1)/2);\n      while(ptr!=0)\n\t{\n\t  segt[ptr]=segt[2*ptr+1]+segt[2*ptr+2];\n\t  ptr=(int)((ptr-1)/2);\n\t}\n      segt[ptr]=segt[2*ptr+1]+segt[2*ptr+2];\n      /*cout << \" Before done: \" << endl;\n      for(int i=0;i<=log2N;i++)\n\t{\n\t  for(int j=(1<<i)-1;j<(1<<(i+1))-1;j++)\n\t    {\n\t      cout<<\" \"<<segt[j];\n\t    }\n\t  cout<<endl;\n\t  }*/\n      int diff =segt[0];\n      //      cout<<\"diff=\"<<diff<<endl;\n      int stage=log2N;\n      if(diff>0) // どっかの '(' が多い: それを ')' に change\n\t{\n\t  bool rightmost=true;\n\t  bool leftmost =true;\n\t  while(stage>0)\n\t    {\n\t      segt[ptr]-=diff;\n\t      if(segt[2*ptr+1]<=-(1<<(stage-1))||(leftmost&&(segt[2*ptr+1]<=1))||(rightmost&&(segt[2*ptr+2]>0)))\n\t\t{\n\t\t  leftmost=false;\n\t\t  ptr=2*ptr+2;\n\t\t}\n\t      else\n\t\t{\n\t\t  if(segt[2*ptr+2]!=0){rightmost=false;} \n\t\t  ptr=2*ptr+1;\n\t\t}\n\t      stage--;\n\t    }\n\t}\n      else\n\t{\n\t  bool leftmost=true;\n\t  while(stage>0)\n\t    {\n\t      segt[ptr]-=diff;\n\t      if(segt[2*ptr+1]>=(1<<(stage-1)))\n\t\t{\n\t\t  ptr=2*ptr+2;\n\t\t  leftmost=false;\n\t\t}\n\t      else\n\t\t{\n\t\t  ptr=2*ptr+1;\n\t\t}\n\t      stage--;\n\t    }\n\t}\n      segt[ptr]-=diff;\n      cout /*<< \"answer=\"*/ << ptr-(1<<(log2N))+2 << endl;\n      /* print check\n      cout << \" After done: \" << endl;\n      for(int i=0;i<=log2N;i++)\n\t{\n\t  for(int j=(1<<i)-1;j<(1<<(i+1))-1;j++)\n\t    {\n\t      cout<<\" \"<<segt[j];\n\t    }\n\t  cout<<endl;\n\t}\n      */\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; int i; bool used; };\n \nint MOD = 1000000007;\n\nstruct bit {\n\tvector<ll> v;\n\tbit(int n) : v(n + 1) {}\n\tll sum(int i) {\n\t\tll res = 0;\n\t\tfor (; i > 0; i -= i & -i) res += v[i];\n\t\treturn res;\n\t}\n\tvoid add(int i, ll x) {\n\t\tfor (i++; i < v.size(); i += i & -i) v[i] += x;\n\t}\n\tint lower_bound(ll x) {\n\t\tif (x <= 0) return 0;\n\t\tint res = 0;\n\t\tfor (int i = 1 << 24; i > 0; i >>= 1)\n\t\t\tif (res + i < v.size() && v[res + i] < x) {\n\t\t\t\tres += i; x -= v[res];\n\t\t\t}\n\t\treturn res + 1;\n\t}\n};\n\nint N, Q;\nstring s;\n\nvoid flip(int i, bit& a, bit& b, bit& c) {\n\tif (s[i] == '(') {\n\t\ts[i] = ')';\n\t\ta.add(i, -2);\n\t\tb.add(i, 1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(') c.add(i - 1, -1);\n\t\tif (i + 1 < N && s[i + 1] == '(') c.add(i, -1);\n\t}\n\telse {\n\t\ts[i] = '(';\n\t\ta.add(i, 2);\n\t\tb.add(i, -1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(') c.add(i - 1, 1);\n\t\tif (i + 1 < N && s[i + 1] == '(') c.add(i, 1);\n\t}\n}\n\nint main() {\n\tcin >> N >> Q >> s;\n\tbit a(N), b(N), c(N);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == '(') a.add(i, 1);\n\t\telse a.add(i, -1);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == ')') b.add(i, 1);\n\tfor (int i = 0; i < N - 1; i++)\n\t\tif (s[i] == '(' && s[i + 1] == '(') c.add(i, 1);\n\twhile (Q--) {\n\t\tint i; cin >> i; i--;\n\t\tif (s[i] == '(') {\n\t\t\tflip(i, a, b, c);\n\t\t\tint j = b.lower_bound(1) - 1;\n\t\t\tflip(j, a, b, c);\n\t\t\tcout << j + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tif (a.sum(i + 1) == 0) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tint j = c.lower_bound(1) - 1;\n\t\t\t\tflip(j + 1, a, b, c);\n\t\t\t\tcout << j + 2 << endl;\n\t\t\t}\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 28;\n\nstruct SegmentTree\n{\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n  inline int BinarySearch(int k, int l, int r, int upd)\n  {\n    if(k >= sz - 1) return(r);\n    const int right = small[2 * k + 2] + add[2 * k + 2] + add[k] + upd;\n    if(right >= 2) return(BinarySearch(2 * k + 1, l, (l + r) >> 1, upd + add[k]));\n    return(BinarySearch(2 * k + 2, (l + r) >> 1, r, upd + add[k]));\n  }\n  int BinarySearch()\n  {\n    return(BinarySearch(0, 0, sz, 0));\n  }\n};\n\nint main()\n{\n  int N, Q;\n \n  scanf(\"%d %d\", &N, &Q);\n  char S[300001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      close.erase(close.begin());\n    } else {\n      close.erase(q);\n      S[q] = '(';\n      int high = tree.BinarySearch();\n      while(S[high] == ')') ++high;\n      printf(\"%d\\n\", high + 1);\n      tree.RangeAdd(high, N, -2);\n      S[high] = ')';\n      close.insert(high);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tusing F=function<T(T,T)>;\n\tusing G=function<T(T,T,int,int)>;\n\tconst F calcfn,lazycalcfn;\n\tconst G updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tconst F calcfn_=[](T a,T b){return a+b;},\n\t\tconst F lazycalcfn_=[](T a,T b){return a+b;},\n\t\tconst G updatefn_=[](T a,T b,int l,int r){return a+b*(r-l);},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],l,r);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nstring s;\nint N,Q;\nmain()\n{\n\tcin>>N>>Q>>s;\n\tpriority_queue<int>X;\n\tlazysegtree<pair<int,int> >P(N+1,make_pair(2*N,2*N),\n\t[](pair<int,int>a,pair<int,int>b){return a<b?a:b;},\n\t[](pair<int,int>a,pair<int,int>b){return make_pair(a.first+b.first,0);},\n\t[](pair<int,int>a,pair<int,int>b,int l,int r){return make_pair(a.first+b.first,a.second);},\n\tmake_pair(0,0));\n\tvector<pair<int,int> >init(N+1);\n\tinit[0]=make_pair(0,1);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tinit[i+1].first=init[i].first;\n\t\tinit[i+1].second=-i;\n\t\tif(s[i]=='(')init[i+1].first++;\n\t\telse\n\t\t{\n\t\t\tinit[i+1].first--;\n\t\t\tX.push(-i);\n\t\t}\n\t}\n\tP.copy(init);\n\tfor(;Q--;)\n\t{\n\t\tint id;cin>>id;\n\t\tid--;\n\t\tif(s[id]=='(')\n\t\t{\n\t\t\ts[id]=')';\n\t\t\tX.push(-id);\n\t\t\twhile(s[-X.top()]=='(')X.pop();\n\t\t\tint jd=-X.top();\n\t\t\tcout<<jd+1<<endl;\n\t\t\ts[jd]='(';\n\t\t\tP.update(jd+1,id+1,make_pair(2,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts[id]='(';\n\t\t\tint jjd=1-P.query(0,id+1).second;\n\t\t\tint jd=1-P.query(jjd+1,id+1).second;\n\t\t\tcout<<jd+1<<endl;\n\t\t\ts[jd]=')';\n\t\t\tX.push(-jd);\n\t\t\tP.update(jd+1,id+1,make_pair(-2,0));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i=0; i<n; i++)\n#define repl(i,n) for(i=1; i<=n; i++)\n\n#define sz(x) (int) x.size()\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define uu first\n#define vv second\n#define mem(x, y) memset(x, y, sizeof(x))\n#define un(x) x.erase(unique(all(x)), x.end())\n\n#define sdi(x) scanf(\"%d\", &x)\n#define sdii(x, y) scanf(\"%d %d\", &x, &y)\n#define sdiii(x, y, z) scanf(\"%d %d %d\", &x, &y, &z)\n#define sdl(x) scanf(\"%lld\", &x)\n#define sdll(x, y) scanf(\"%lld %lld\", &x, &y)\n#define sdlll(x, y, z) scanf(\"%lld %lld %lld\", &x, &y, &z)\n#define sds(x) scanf(\"%s\", x)\n#define pfi(x) printf(\"%d\\n\", x)\n#define pfii(x, y) printf(\"%d %d\\n\", x, y)\n#define pfiii(x, y, z) printf(\"%d %d %d\\n\", x, y, z)\n#define pfl(x) printf(\"%lld\\n\", x)\n#define pfll(x, y) printf(\"%lld %lld\\n\", x, y)\n#define pflll(x, y, z) printf(\"%lld %lld %lld\\n\", x, y, z)\n\n#define eps 1e-9\n#define OK cerr << \"ok\\n\"\n#define DB(x) cerr << #x << \" = \" << x << endl\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair <int, int> pii;\n\ninline int setBit(int N, int pos) { return N=N | (1<<pos); }\ninline int resetBit(int N, int pos) { return N= N & ~(1<<pos); }\ninline bool checkBit(int N, int pos) { return (bool)(N & (1<<pos)); }\n\n//int kx[] = {+2, +1, -1, -2, -2, -1, +1, +2};\n//int ky[] = {+1, +2, +2, +1, -1, -2, -2, -1}; //Knight Direction\n//int fx[] = {+0, +0, +1, -1, -1, +1, -1, +1};\n//int fy[] = {-1, +1, +0, +0, +1, +1, -1, -1}; //Four & Eight Direction\n\n\nconst int MAX = 300005, INF = 100000000;\nint n, q, cum[MAX];\nchar str[MAX];\nset <int> closeList;\nstruct data {\n    int mn, prop;\n} tree[MAX*4];\n\nvoid init(int node, int beg, int endd) {\n    if(beg == endd) {\n        tree[node] = { cum[beg], 0 };\n        return;\n    }\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    init(left, beg, mid);\n    init(right, mid+1, endd);\n\n    tree[node].mn = min(tree[left].mn, tree[right].mn);\n}\n\ninline void pushDown(int node, int left, int right) {\n    tree[left].mn += tree[node].prop;\n    tree[right].mn += tree[node].prop;\n    tree[left].prop += tree[node].prop;\n    tree[right].prop += tree[node].prop;\n    tree[node].prop = 0;\n}\n\nvoid update(int node, int beg, int endd, int x, int y, int val) {\n    if(x > y) return;\n    if(beg == x && endd == y) {\n        tree[node].mn += val;\n        tree[node].prop += val;\n        return;\n    }\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    if(tree[node].prop) pushDown(node, left, right);\n\n    if(x <= min(y, mid)) update(left, beg, mid, x, min(y, mid), val);\n    if(max(x, mid+1) <= y) update(right, mid+1, endd, max(x, mid+1), y, val);\n\n    tree[node].mn = min(tree[left].mn, tree[right].mn);\n}\n\nint query(int node, int beg, int endd, int x, int y) {\n    if(x > y) return INF;\n    if(beg == x && endd == y) return tree[node].mn;\n\n    int left = node << 1;\n    int right = left + 1;\n    int mid = (beg+endd) >> 1;\n\n    if(tree[node].prop) pushDown(node, left, right);\n\n    int l = (x <= min(y, mid))? query(left, beg, mid, x, min(y, mid)) : INF;\n    int r = (max(x, mid+1) <= y)? query(right, mid+1, endd, max(x, mid+1), y) : INF;\n\n    return min(l, r);\n}\n\ninline int bs(int high) {\n    int low=1, mid, ret=high, ub=high;\n    while(low <= high) {\n        mid = (low+high) >> 1;\n        if(query(1, 1, n, mid, ub) >= 2) {\n            ret = min(ret, mid);\n            high = mid-1;\n        }\n        else low = mid+1;\n    }\n    return ret;\n}\n\ninline int query(int idx) {\n    int ret = idx;\n    if(str[idx] == '(') { /// open to close\n        str[idx] = ')';\n        closeList.insert(idx);\n        update(1, 1, n, idx, n, -2);\n        ret = *closeList.begin();\n        str[ret] = '(';\n        closeList.erase(ret);\n        update(1, 1, n, ret, n, +2);\n        return ret;\n    }\n    else { /// close to open\n        str[idx] = '(';\n        closeList.erase(idx);\n        update(1, 1, n, idx, n, +2);\n        ret = bs(idx);\n        str[ret] = ')';\n        closeList.insert(ret);\n        update(1, 1, n, ret, n, -2);\n        return ret;\n    }\n}\n\nint main() {\n//    assert(freopen(\"in.txt\",\"r\",stdin));\n//    assert(freopen(\"out.txt\",\"w\",stdout));\n\n    int i, idx;\n\n    sdii(n, q);\n    sds(str+1);\n    repl(i, n) {\n        if(str[i] == '(') cum[i] = 1;\n        else {\n            cum[i] = -1;\n            closeList.insert(i);\n        }\n        cum[i] += cum[i-1];\n    }\n    init(1, 1, n);\n    while(q--) {\n        sdi(idx);\n        pfi(query(idx));\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3e5 + 5;\n\nint n, q, it[N * 4], lazy[N * 4];\nstring s;\n\nvoid dolazy(int node, int l, int r) {\n\tif(!lazy[node]) return;\n\tit[node] += lazy[node];\n\tif(l != r) {\n\t\tlazy[node << 1] += lazy[node];\n\t\tlazy[node << 1 | 1] += lazy[node];\n\t}\n\tlazy[node] = 0;\n}\n\nvoid update(int node, int l, int r, int p, int q, int val) {\n\tdolazy(node, l, r);\n\tif(l > q || r < p) return;\n\tif(p <= l && r <= q) {\n\t\tlazy[node] += val;\n\t\tdolazy(node, l, r);\n\t\treturn;\n\t}\n\tint mid = (l + r) / 2;\n\tupdate(node << 1, l, mid, p, q, val);\n\tupdate(node << 1 | 1, mid + 1, r, p, q, val);\n\tit[node] = min(it[node << 1], it[node << 1 | 1]);\n}\n\nint find2(int node, int l, int r) {\n\tdolazy(node, l, r);\n\tif(l == r) return l;\n\tint mid = (l + r) / 2;\n\tif(it[node << 1 | 1] < 2) return find2(node << 1 | 1, mid + 1, r);\n\treturn find2(node << 1, l, mid);\n}\n\nset<int> pos;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> q;\n\tcin >> s; s = '!' + s;\n\tfor(int i = 1; i < s.size(); ++i) {\n\t\tif(s[i] == ')') update(1, 1, n, i, n, -1), pos.insert(i);\n\t\telse update(1, 1, n, i, n, 1);\n\t}\n\twhile(q--) {\n\t\tint p;\n\t\tcin >> p;\n\t\tif(s[p] == ')') {\n\t\t\tpos.erase(p);\n\t\t\ts[p] = '(';\n\t\t\tupdate(1, 1, n, p, n, 2);\n\t\t\tint nxt_pos = find2(1, 1, n) + 1;\n\t\t\ts[nxt_pos] = ')';\n\t\t\tupdate(1, 1, n, nxt_pos, n, -2);\n\t\t\tpos.insert(nxt_pos);\n\t\t\tcout << nxt_pos << '\\n';\n\t\t}\n\t\telse {\n\t\t\ts[p] = ')';\n\t\t\tpos.insert(p);\n\t\t\tupdate(1, 1, n, p, n, -2);\n\t\t\tupdate(1, 1, n, *pos.begin(), n, 2);\n\t\t\tcout << *pos.begin() << '\\n';\n\t\t\ts[*pos.begin()] = '(';\n\t\t\tpos.erase(pos.begin());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int INF = 1e9;\nconst int sqrtN = 300;\n\nstruct SegmentArray1 {\n  int B;\n  vector<int> data;\n  vector<int> add;\n  vector<int> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min[k] > data[i]) min[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = en - 1; i >= st; --i) {\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n  }\n  bool get(int p) {\n    return data[p];\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(seg2.get(p) == false) {\n      // S[p] = ')';\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      // S[p] = '(';\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      // S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000]; string s;\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0, l = r;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tsum += d[i];\n\t\t\t\tif (sum < 2) l = r;\n\t\t\t\telse if (l == r) l = i;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1); d[l] = -1, d[r] = 1;\n\t\t}\n\t\telse {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (d[j] == -1) {\n\t\t\t\t\td[j] = 1, d[r] = -1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                //assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                // assert(s[l]=='(');                \n                // assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar s[300005];\nint main()\n{\n\tint q,n,x,i,j,cnt,num1,num2;\n\twhile(scanf(\"%d%d\",&n,&q)!=EOF)\n\t{\n\t\tscanf(\"%s\",s);\n\t\twhile(q--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tx--;\n\t\t\tif(s[x]=='(')\n\t\t\t{\n\t\t\t\ts[x]=')';\n\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tif(s[i]==')')\n\t\t\t\t\t{\n\t\t\t\t\t\ts[i]='(';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(s[x]==')')\n\t\t\t{\n\t\t\t\ts[x]='(';\n\t\t\t\tcnt=0;\n\t\t\t\tnum1=0;\n\t\t\t\tnum2=0;\n\t\t\t\tfor(i=n-1;i>=x;i--)\n\t\t\t\t{\n\t\t\t\t\tif(s[i]=='(')\n\t\t\t\t\t\tnum1++;\n\t\t\t\t\telse\n\t\t\t\t\t\tnum2++;\n\t\t\t\t}\n\t\t\t\tif(num2>num1)\n\t\t\t\t{\n\t\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='(')\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tif(i%2!=0&&cnt==(i+1)/2+1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ts[i]=')';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",x+1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<map>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\nvoid debug_show(string str,Segment_Tree *ST,int n)\n{\n  int j;\n  cout<<str<<endl;\n  cout<<\"Sum \";\n  rep(j,n)\n    cout<<ST->get_min(j,j+1)<<\" \";\n  cout<<endl;\n  cout<<\"Min \" ;\n  rep(j,n)\n    cout<<ST->get_min(j,n)<<\" \";\n  cout<<endl;\n}\n\nint  main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(n);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='('){\n\tST.add(i,n,1);\n      }\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  /* \n\t  int p=-1;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{p=str.find('(',p+1);}\n\t    while(ST.get_min(p,n)<2);\n\t  \n\t  */\n\t  //cout<<\"bf \"<<flip+1<<\"changed\"<<endl;\n\t  //debug_show(str,&ST,n);\n\t  \n\t  int p=0,e=n;\n\t  if(flip==n-1)p=flip;\n\t  else{\n\t    while(e>p+1){\n\t      if(ST.get_min((p+e)/2,n)<2)p=(p+e)/2;\n\t      else e=(p+e)/2;\n\t    }\n\t    p=str.find('(',p+1);\n\t  }\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t  //puts(\"af\");\n\t  //debug_show(str,&ST,n);\n\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int maxn= 4e5,maxm= 7e6;\nstruct node{\n\tint o,l,r;\n};\nnode sta[10];\nchar s[maxn];\nint c[maxn],f[maxn];\nint left[maxm],right[maxm],S[maxm],Z[maxm],Min[maxm];\nint n,m,i,x,y,z,tot,root,L,R,now,la;\n//S[]当前子?是否有-1,Z[]区???,Min[]区?最小?\nvoid init(){\n\tmemset(s,0,sizeof(s));          \n\tmemset(c,0,sizeof(c));\n\tmemset(f,0,sizeof(f));\n\tmemset(left,0,sizeof(left));\n\tmemset(right,0,sizeof(right));\n\tmemset(S,0,sizeof(S));\n\tmemset(Z,0,sizeof(Z));\n\tmemset(Min,0,sizeof(Min));\n\tL= 1;R= n+1;tot= root= 0;\n}\nvoid pushdown(int o){\n\tZ[left[o]]+= Z[o];\n\tZ[right[o]]+= Z[o];\n\tZ[o]= 0;\n}\nvoid update(int o){\n\tint l= left[o],r= right[o];\n\tS[o]= S[l]||S[r];\n\tMin[o]= min(Min[l]+Z[l],Min[r]+Z[r]);\n}\nvoid build(int &o,int l,int r){\n\tif (!o) o= ++tot;\n\tif (l+1==r){\n\t\tS[o]= c[l]==-1?1:0;\n\t\tMin[o]= f[l];\n\t\treturn;\n\t}\n\tint mid= (l+r)>>1;\n\tbuild(left[o],l,mid);\n\tbuild(right[o],mid,r);\t\n\tupdate(o);\n}\nvoid find(int o,int l,int r,int L,int R){\n\tif (l==r) return;\n\tif (l>=R) return;\n\tif (l+1==r){\n\t\tnow= l;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tint mid= (l+r)>>1;\n\tif (S[left[o]]) find(left[o],l,mid,L,R);\n\telse find(right[o],mid,r,L,R);\n\tupdate(o);\n}\nvoid change(int o,int l,int r,int v,int x){\n\tif (l==r) return;\n\tif (l+1==r){\n\t\tS[o]= c[l]==-1?1:0;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tint mid= (l+r)>>1;\n\tif (v<mid) change(left[o],l,mid,v,x);\n\telse change(right[o],mid,r,v,x);\n\tupdate(o);\n}\nvoid modify(int o,int l,int r,int L,int R,int x){\n\tif (l==r) return;\t\n\tif (L<=l&&r<=R){\n\t\tZ[o]+= x;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tint mid= (l+r)>>1;\n\tif (L<mid) modify(left[o],l,mid,L,R,x);\n\tif (mid<R) modify(right[o],mid,r,L,R,x);\n\tupdate(o);\n}\nvoid ask(int o,int l,int r,int L,int R){\n\tif (l==r) return;\t\n\tif (L<=l&&r<=R){\n\t\tsta[++la]= (node){o,l,r};\n\t\treturn;\n\t}\n\tpushdown(o);\n\tint mid= (l+r)>>1;\n\tif (L<mid) ask(left[o],l,mid,L,R);\n\tif (mid<R) ask(right[o],mid,r,L,R);\n\tupdate(o);\n}\nvoid go(int o,int l,int r){\n\tif (l==r) return;\t\n\tif (l+1==r){\n\t\tif (Min[o]+Z[o]>=2)\n\t\t\tnow= l;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tint mid= (l+r)>>1;\n\tif (Min[right[o]]+Z[right[o]]>=2){\n\t\tnow= mid;\n\t\tgo(left[o],l,mid);\n\t}else {\n\t\tgo(right[o],mid,r);\n\t}update(o);\n}\nvoid Ask(int x){\t\n\tla= 0;now= x;\n\task(root,L,R,1,x);\n\twhile (la){\n\t\tint o= sta[la].o;\n\t\tif (Min[o]+Z[o]>=2){\n\t\t\tnow= sta[la].l;\n\t\t\tla--;\n\t\t}else break;\n\t}\n\tgo(sta[la].o,sta[la].l,sta[la].r);\n}\nint main()\n{\n\twhile (scanf(\"%d%d\",&n, &m)>0){\n\t\tinit();\n\t\tscanf(\"%s\",s+1);\n\t\tfor (i= 1;i<=n;i++){\n\t\t\tc[i]= s[i]=='(' ? 1:-1;\n\t\t\tf[i]= f[i-1]+c[i];\n\t\t}\n\t\tbuild(root,L,R);\n\t\tfor (int MM= 1;MM<=m;MM++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tnow= x;\n\t\t\tif (c[x]==1){\n\t\t\t\tc[x]= -1;\n\t\t\t\tfind(root,L,R,1,x);\n\t\t\t\tc[now]= 1;\n\t\t\t\tchange(root,L,R,x,-1);\n\t\t\t\tchange(root,L,R,now,1);\n\t\t\t\tmodify(root,L,R,now,x,2);\n\t\t\t}else {\n\t\t\t\tc[x]= 1;\n\t\t\t\tAsk(x);\n\t\t\t\tc[now]= -1;\n\t\t\t\tchange(root,L,R,x,1);\n\t\t\t\tchange(root,L,R,now,-1);\n\t\t\t\tmodify(root,L,R,now,x,-2);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",now);\n\t\t}\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l  && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nint fix(set<int> &a, set<int> &b, char *s, char before, int x)\n{\n    a.erase(x);\n    b.insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    \n    while (l != r){\n        int mid = (l + r) / 2;\n        int p = *b.lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        bool cond1 = (p ? abs(getMin(p - 1, p) - getMin(p, p + 1)) == 1 : 1);\n        bool cond2 = (p != n - 1 ? abs(getMin(p, p + 1) - getMin(p + 1, p + 2)) == 1 : 1);\n        \n        if (segMin[0] + segAdd[0] >= 0 && cond1 && cond2) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    int p = *b.lower_bound(l);\n    add(p, n, -2 * base);\n    b.erase(p);\n    a.insert(p);\n    s[p] = before;\n    \n    return (p);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '('){\n            printf(\"%d\\n\", fix(lf, rg, s, '(', x) + 1);\n        }\n        else {\n            printf(\"%d\\n\", fix(rg, lf, s, ')', x) + 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nuint64_t ary[5000]__attribute__((aligned(32)));\nint diff[5000]__attribute__((aligned(32)));\nint inf[5000]__attribute__((aligned(32)));\nint l1,l2,n;\n\nint _mm_popcnt_u64(uint64_t x) {\n  return __builtin_popcountll(x);\n}\n\nvoid update(int i) {\n  if (i != l1) {\n    diff[i] = 2 * _mm_popcnt_u64(ary[i]) - 64;\n    int cnt = 0;\n    REP(j,64) {\n      cnt += ((ary[i] >> j) & 1) ? 1 : -1;\n      inf[i] = min(inf[i], cnt);\n    }\n  } else {\n    diff[l1] = 2 * _mm_popcnt_u64(ary[l1]) - (n % 64);\n    int cnt = 0;\n    REP(j,n % 64) {\n      cnt += ((ary[l1] >> j) & 1) ? 1 : -1;\n      inf[l1] = min(inf[l1], cnt);\n    }\n  }\n}\n\nint main() {\n  int q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n  REP(i,n){\n    if(s[i]=='(')\n      ary[i/64] |= UINT64_C(1) << (i % 64);\n  }\n  l1 = n/64;\n  l2 = (n+63)/64;\n  REP(i,l1){\n    diff[i] = 2 * _mm_popcnt_u64(ary[i]) - 64;\n  }\n  if (l1 != l2) diff[l1] = 2 * _mm_popcnt_u64(ary[l1]) - (n % 64);\n  REP(i,l1) {\n    int cnt = 0;\n    REP(j,64) {\n      cnt += ((ary[i] >> j) & 1) ? 1 : -1;\n      inf[i] = min(inf[i], cnt);\n    }\n  }\n  if (l1 != l2) {\n    int cnt = 0;\n    REP(j,n % 64) {\n      cnt += ((ary[l1] >> j) & 1) ? 1 : -1;\n      inf[l1] = min(inf[l1], cnt);\n    }\n  }\n  REP(cnt1,q){\n    int p;\n    cin>>p;\n    --p;\n    if ((ary[p/64] >> (p % 64)) & 1) {\n      ary[p/64] ^= UINT64_C(1) << (p % 64);\n      update(p/64);\n      int pos = -1;\n      REP(j,l1) {\n        if (diff[j] != 64) {\n          pos = j * 64;\n          REP(k,64) {\n            if (!((ary[j] >> k) & 1)) {\n              pos += k;\n              break;\n            }\n          }\n          break;\n        }\n      }\n      if (pos < 0) {\n        pos = l1 * 64;\n        REP(j,n%64) {\n          if (!((ary[l1] >> j) & 1)) {\n            pos += j;\n            break;\n          }\n        }\n      }\n      cout << pos+1 << endl;\n      ary[pos/64] ^= UINT64_C(1) << (pos % 64);\n      update(pos/64);\n    } else {\n      ary[p/64] ^= UINT64_C(1) << (p % 64);\n      update(p/64);\n      int last1 = 0;\n      int last1sum = 0;\n      int sum = 0;\n      REP(i,l1) {\n        if (sum + inf[i] <= 1) {\n          last1 = i;\n          last1sum = sum;\n        }\n        sum += diff[i];\n      }\n      if (l1 != l2) {\n        if (sum + inf[l1] <= 1) {\n          last1 = l1;\n          last1sum = sum;\n        }\n      }\n      int pos = 0;\n      if (last1 != l1) {\n        int last1_s = 0;\n        REP(i,64) {\n          last1sum += ((ary[last1] >> i) & 1) ? 1 : -1;\n          if (last1sum <= 1) last1_s = i;\n        }\n        pos = last1 * 64 + last1_s + 1;\n      } else {\n        int last1_s = 0;\n        REP(i,n%64) {\n          last1sum += ((ary[last1] >> i) & 1) ? 1 : -1;\n          if (last1sum <= 1) last1_s = i;\n        }\n        pos = last1 * 64 + last1_s + 1;\n      }\n      cout << pos+1 << endl;\n      ary[pos/64] ^= UINT64_C(1) << (pos % 64);\n      update(pos/64);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nstruct SegmentTree\n{\n  const int INF = 1 << 30;\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n};\n\nint main()\n{\n  int N, Q;\n\n  scanf(\"%d %d\", &N, &Q);\n  char S[100001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      close.erase(close.begin());\n    } else {\n      close.erase(q);\n      S[q] = '(';\n      int low = -1, high = N - 1;\n      while(high - low > 1) {\n        int mid = (low + high) >> 1;\n        if(tree.RangeMinimumQuery(mid, N) >= 2) high = mid;\n        else low = mid;\n      }\n      while(S[q] == ')') ++high;\n      printf(\"%d\\n\", high + 1);\n      tree.RangeAdd(high, N, -2);\n      S[high] = ')';\n      close.insert(high);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct starrysky{\n  int n;\n  starrysky(){}\n  starrysky(int n_){init(n_);};\n  vector<int> data,datm;\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data.clear();\n    datm.clear();\n    data.resize(2*n-1,0);\n    datm.resize(2*n-1,0);\n  }\n  void add(int a,int b,int x,int l,int r,int k){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      data[k]+=x;\n      return;\n    }\n    add(a,b,x,l,(l+r)/2,k*2+1);\n    add(a,b,x,(l+r)/2,r,k*2+2);\n    datm[k]=min(datm[k*2+1]+data[k*2+1],datm[k*2+2]+data[k*2+2]);\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,n,0);\n  }\n  int query(int a,int b,int l,int r,int k){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b){\n      return data[k]+datm[k];\n    }\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2))+data[k];\n  }\n  int query(int a,int b){\n    return query(a,b,0,n,0);\n  }\n};\n#define MAX 333333\nstring buf;\nint dp[MAX],imos[MAX];\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  cin>>buf;\n  set<int> s;\n  for(int i=0;i<n;i++) {\n    if(buf[i]=='(') dp[i]=1;\n    else dp[i]=-1;\n    if(buf[i]==')') s.insert(i);\n  }\n  imos[0]=dp[0];\n  for(int i=1;i<n;i++) imos[i]=imos[i-1]+dp[i];\n  starrysky ss(n);\n  for(int i=0;i<n;i++) ss.add(i,i+1,imos[i]);\n  for(int i=0;i<q;i++){\n    int p;cin>>p;p--;\n    if(dp[p]==1){\n      dp[p]*=-1;\n      s.insert(p);\n      ss.add(p,n,-2);\n      int k=*s.begin();\n      s.erase(k);\n      dp[k]*=-1;\n      ss.add(k,n,2);\n      cout<<k+1<<endl;\n    }else{\n      //cout<<p<<endl;\n      dp[p]*=-1;\n      s.erase(p);\n      ss.add(p,n,2);\n      int l=0,r=p;\n      while(l+1<r){\n\tint m=(l+r)/2;\n\t//cout<<m<<\":\"<<ss.query(m,n)<<endl;\n\tif(ss.query(m,n)>=2) r=m;\n\telse l=m;\n      }\n      cout<<r+1<<endl;\n      dp[r]*=-1;\n      s.insert(r);\n      ss.add(r,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef long long ll;\n\nstruct T {\n  ll v;\n  ll s;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),s(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->s += t->lazy*count(t);\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll sum(T* t){ push(t); return t?t->s:0; }\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->s = t->v+sum(t->l)+sum(t->r);\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* erase(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> v = split(t,k);\n  k -= (k-1);\n  pair<T*,T*> u = split(v.second,k);\n  return merge(v.first,u.second);\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\ninline T* add(T* t,int k)\n{\n  push(t);\n  t->lz |= true;\n  t->lazy += k;\n  return update(t);\n}\n\nint n,m;\nchar s[33333];\ninline T* flip(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  pair<T*,T*> b=split(a.second,1);\n  //b.first->v = -b.first->v;\n  //b.first = add(b.first,k,n);\n  return merge(a.first,merge(b.first,b.second));\n}\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\ninline int gsum(T* t)\n{\n  /*\n  if( !t->r ) return t->v;\n  return gsum(t->r);\n  */\n  return 0;\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q,m;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  //print(root); puts(\"\");\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    //printf(\"%d %d\\n\",mini(t),gsum(t));\n    //print(t); puts(\"\");\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        //printf(\"%d %d\\n\",l,r);\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      //printf(\":%d %d\\n\",l,r);\n      root = add(root,l,n,-2);\n    }\n    //puts(s);\n    //printf(\"%d\\n\",kakko);\n    //print(root); puts(\"\");\n    /*\n      printf(\"sum:%d min:%d\\n\",gsum(t),mini(t));\n    //*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s <= t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s <= t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s <= t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    set<int> opening;\n    set<int> closing;\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            if (c == '(') {\n                nest ++;\n                opening.insert(i);\n                segtree.add_at(i,nest);\n            } else {\n                nest --;\n                closing.insert(i);\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        if (closing.find(i) != closing.end()) {\n            ll low = 0, high = i;\n            ll mid;\n            while (low < high) {\n                ll mid = (low + high + 1) / 2;\n                if (2 <= segtree.min_query(mid,i)) {\n                    if (high == mid) break;\n                    high = mid;\n                } else {\n                    if (low == mid) break;\n                    low = mid;\n                }\n            }\n            ll j = (high + low + 1) / 2;\n            while (0 <= j-1 and 2 <= segtree.min_query(j-1,i)) j -= 1;\n            opening.insert(i); closing.erase(i);\n            j = *opening.lower_bound(j);\n            closing.insert(j); opening.erase(j);\n            segtree.add_range(j, i, -2);\n            cout << j+1 << endl;\n        } else {\n            closing.insert(i); opening.erase(i);\n            ll j = *closing.lower_bound(0);\n            opening.insert(j); closing.erase(j);\n            segtree.add_range(j, i, 2);\n            cout << j+1 << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nconst int INF = 1 << 28;\n\nstruct SegmentTree\n{\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n  inline int BinarySearch(int k, int l, int r, int upd)\n  {\n    if(k >= sz - 1) return(r);\n    const int right = small[2 * k + 2] + add[2 * k + 2] + add[k] + upd;\n    if(right >= 2) return(BinarySearch(2 * k + 1, l, (l + r) >> 1, upd + add[k]));\n    return(BinarySearch(2 * k + 2, (l + r) >> 1, r, upd + add[k]));\n  }\n  int BinarySearch()\n  {\n    return(BinarySearch(0, 0, sz, 0));\n  }\n};\n\nint main()\n{\n  int N, Q;\n \n  scanf(\"%d %d\", &N, &Q);\n  char S[300001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      close.erase(close.begin());\n    } else {\n      close.erase(q);\n      S[q] = '(';\n      int high = tree.BinarySearch();\n      while(S[q] == ')') ++high;\n      printf(\"%d\\n\", high + 1);\n      tree.RangeAdd(high, N, -2);\n      S[high] = ')';\n      close.insert(high);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                assert(s[l]=='(');                \n                assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        assert(q > 0);\n        close_parens.erase(q);\n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        \n        assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        \n        \n        \n        cout << pos_pos + 1 << endl;\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\n//Segment Tree\nclass SegmentTree{\npublic:\n  int n;\n  vi node;\n  vi ofset;\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n=1;\n    while(n<n_)n*=2;\n\n    node = vi(2*n-1, INF);\n    for(int i=0;i<n_;i++)node[i+n-1] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n\n    ofset = vi(2*n-1,0);\n  }\n\n  //return minimum value in [a,b). ( [l,r) is interval in which k is.)\n  int rmq(int a,int b,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b)return node[k]+ofset[k];\n    int pl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int pr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(pl,pr) + ofset[k];\n  }\n\n  int search(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b && node[k]+ofset[k] >= v)return l;\n    if(r-l<=1)return INF;\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    if(vr + ofset[k] >= v){\n      int res = search(a,b,v-ofset[k],2*k+1,l,(l+r)/2);\n      return min(res, (l+r)/2);\n    }else{\n      int res = search(a,b,v-ofset[k],2*k+2,(l+r)/2,r);\n      return res;\n    }\n  }\n \n  int update_range(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return node[k];\n    if(a<=l && r<=b){\n      ofset[k] += v;\n      return node[k]+ofset[k];\n    }\n\n    int vl = update_range(a,b,v,2*k+1,l,(l+r)/2);\n    int vr = update_range(a,b,v,2*k+2,(l+r)/2,r);\n    node[k] = min(vl,vr);\n    return node[k]+ofset[k];\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n\n  set<int> minus;\n  vi h(n,1);\n  rep(i,n-1){\n    if(s[i+1] == '(')h[i+1] = h[i] + 1;\n    else{\n      h[i+1] = h[i] - 1;\n      minus.insert(i+1);\n    }\n  }\n  SegmentTree st(h);\n\n  while(q--){\n    int p;\n    cin >> p; p--;\n    if(s[p] == '('){\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n\n      p = *minus.begin();\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n    }else{\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n\n      p = st.search(0,p+1,2);\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n    }\n    cout << p+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define in1(a) scanf(\"%lld\", &a)\n#define in2(a, b) scanf(\"%lld%lld\", &a, &b)\nusing namespace std;\nll n, m, tree[2000000],x;\nstring s;\nset<ll>sto;\nset<ll>stc;\nvoid update(ll l, ll r, ll pos, ll indx, ll val)\n{\n    if(l==r)\n    {\n        tree[pos]=val;\n        return;\n    }\n    ll mid =(l+r)/2;\n    if(indx>mid)\n        update(mid+1, r, 2*pos+1, indx, val);\n    else\n        update(l, mid, 2*pos, indx, val);\n    tree[pos]= tree[2*pos]+tree[2*pos+1];\n}\nll query(ll l, ll r, ll pos, ll L, ll R)\n{\n    if(r<L || l>R)\n        return 0;\n    if(l>=L && r<=R)\n        return tree[pos];\n    ll mid=(l+r)/2;\n    return query(l, mid, 2*pos, L, R)+query(mid+1,r, 2*pos+1, L, R);\n}\nint main()\n{\n    in2(n, m);\n    cin>>s;\n    for(int i=0; i<n; i++)\n    {\n        if(s[i]=='(')\n        {\n            update(1, n, 1, i+1, 1);\n            if(i>0)\n            sto.insert(i+1);\n        }\n        else\n        {\n            update(1, n, 1, i+1, -1);\n            if(i<n-1)\n            stc.insert(i+1);\n        }\n    }\n    while(m--)\n    {\n        in1(x);\n        if(x==n || x==1)\n        {\n            printf(\"%lld\\n\", x);\n            continue;\n        }\n//        cout<<\"end\"<<endl;\n        ll y = query(1, n, 1, x+1, n);\n        if(y==0)\n        {\n            printf(\"%lld\\n\", x);\n            continue;\n        }\n        if(s[x-1]=='(')\n        {\n            ll y = x;\n            if(!stc.empty())\n                y = *(stc.begin());\n            if(y>=x)\n            {\n                printf(\"%lld\\n\", x);\n                continue;\n            }\n            else\n            {\n                printf(\"%lld\\n\", y);\n                s[x-1]=')';\n                update(1,n,1,x,-1);\n                sto.erase(x);\n                stc.insert(x);\n                s[y-1]='(';\n                update(1, n, 1, y, 1);\n                stc.erase(y);\n                sto.insert(y);\n            }\n        }\n        else///when closing\n        {\n            ll y = x;\n            if(!sto.empty())\n                y = *(sto.begin());\n            if(y>=x)\n            {\n                printf(\"%lld\\n\", x);\n                continue;\n            }\n            else\n            {\n                printf(\"%lld\\n\", y);\n                s[x-1]='(';\n                update(1,n,1,x,1);\n                stc.erase(x);\n                sto.insert(x);\n                s[y-1]=')';\n                update(1, n, 1, y, -1);\n                sto.erase(y);\n                stc.insert(y);\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 1100;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      //DEBUG(S);\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      //DEBUG(S);\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n    //DEBUG(S);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n  };\n  \n  D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D &a,D &b){\n    if(a.value < b.value) return a;\n    return b;\n  }\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D add(Int a,Int b,Int x,bool flg=true,Int k=0,Int l=0,Int r=-1){\n    if(r==-1 && toMax) x *= -1; \n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = add(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    D res = add(a,b,0,false);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    int val = s[x] == '('? -2:2;\n    A.add(0, n, val);\n    Int res = 1;\n    if(A.find(0, n) < 0) res = 0;\n    if(A.find(n-1, n) != 0) res = 0;\n    A.add(0, n, val);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(it == par.end()) {R = M;continue;}\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    return *par.lower_bound(R);\n  };\n\n  for(Int i=0;i<q;i++){\n    Int x;\n    scanf(\"%lld\",&x);\n    rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    printf(\"%lld\\n\",y+1);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;  // 対象区間とノードの区間が交わらないなら処理をしない\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k, r-l);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k, int size) {\n    if (size > 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k, int size) {\n    if (size == 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,n)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int k, int l, int r, int val) {\n    process_lazy(k, r-l);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    int ret_r = getLeftGt(RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2 || ret_r == -1) return ret_r;\n    int ret_l = getLeftGt(LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  tree.addRange(n, nPow2, 2);  // getLeftGt関数の簡単化のため\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n//0-index\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass late_seg_tree{\nprivate:\n    typedef pair<T,U> node;\n    vector<vector<node>> tree;\n    ll high;\n    T err_T;\n    U err_U;\n    ll err;\n    \n    T F(T,T); //要素のマージ (要素,要素)\n    T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n    U H(U,U); //作用素のマージ (作用素,作用素)\n    T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n    \n    ll bit_size(ll a){\n        for(int i=1;i<63;i++){\n            if(1<<i >= a){return i;}\n        }\n        return err;\n    }\n    \n    //[l,r)\n    void update(ll h,ll where,ll l,ll r,U u){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return;}\n        if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n        if(l<=L && R<=r){\n            tree[h][where].S=H(tree[h][where].S,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n        else{\n            update(h+1,where*2,l,r,u);\n            update(h+1,where*2+1,l,r,u);\n            tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n            tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n        }\n    }\n    \n    T search(ll h,ll where,ll l,ll r){\n        ll L=where<<(high-h-1);\n        ll R=(where+1)<<(high-h-1);\n        if(r<=L || R<=l){return err_T;}\n        if(h==high-1){return tree[h][where].F;}\n        if(l<=L && R<=r){return tree[h][where].F;}\n        else{\n            update(h+1,where*2,L,R,tree[h][where].S);\n            update(h+1,where*2+1,L,R,tree[h][where].S);\n            tree[h][where].S=err_U;\n            T ret=err_T;\n            ret=F(ret,search(h+1,where*2,l,r));\n            ret=F(ret,search(h+1,where*2+1,l,r));\n            return ret;\n        }\n        return err_T;\n    }\n    \npublic:\n    late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(size)+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n    }\n    \n    late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n        err=1e18+7;\n        high=bit_size(t.size())+1;\n        tree.resize(high);\n        for(int i=0;i<high;i++){\n            tree[i].resize(1<<i,{err_T,err_U});\n        }\n        for(int i=0;i<t.size();i++){\n            tree[high-1][i]={t[i],err_U};\n        }\n        for(ll h=high-2;h>=0;h--){\n            for(int i=0;i<tree[h].size();i++){\n                tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n            }\n        }\n    }\n    \n    void update(ll l,ll r,U u){\n        update(0,0,l,r,u);\n    }\n    \n    T search(ll l,ll r){\n        return search(0,0,l,r);\n    }\n};\n\n\n\n\nint main(){\n    ll n,q;\n    cin>>n>>q;\n    string s;\n    cin>>s;\n    vector<pll> S(n,{E,E});\n    vector<bool> str(n,false);\n    for(int i=0;i<n;i++){\n        if(s[i]==')'){S[i].F=i;}\n    }\n    for(int i=0;i<n;i++){\n        str[i]= s[i]=='(';\n        S[i].S= s[i]=='('?1:-1;\n        if(i!=0){S[i].S+=S[i-1].S;}\n    }\n    late_seg_tree<pll,pair<bool,ll>> tree(S,{E,E},{false,0});\n    while(q--){\n        ll x;\n        cin>>x;\n        x--;\n        if(str[x]){\n            tree.update(x,x+1,{true,0});\n            pll w=tree.search(0,x+1);\n            cout<<w.F+1<<endl;\n            tree.update(w.F,w.F+1,{true,0});\n            if(w.F!=x){\n                tree.update(w.F,x,{false,2});\n            }\n            str[x]=!str[x];\n            str[w.F]=!str[w.F];\n        }\n        else{\n            if(x==0){cout<<1<<endl; continue;}\n            ll l=0,r=x-1;\n            while(r-l>3){\n                ll m=l+(r-l)/2;\n                if(tree.search(m,x).S>=2){r=m;}\n                else{l=m+1;}\n            }\n            bool done=false;\n            for(ll i=l;i<=r && !done;i++){\n                if(tree.search(i,x).S>=2){\n                    cout<<i+1<<endl;\n                    str[i]=!str[i];\n                    str[x]=!str[x];\n                    tree.update(x,x+1,{true,0});\n                    tree.update(i,i+1,{true,0});\n                    tree.update(i,x,{false,-2});\n                    done=true;\n                }\n            }\n            if(!done){\n                cout<<x+1<<endl; continue;\n            }\n        }\n    }\n    \n    \n    \n    return 0;\n}\n\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::F(T a,T b){\n    return {min(a.F,b.F),min(a.S,b.S)};\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::G(T a,U b,ll where){\n    if(b.F){\n        if(a.F==E){a.F=where;}\n        else{a.F=E;}\n    }\n    a.S+=b.S;\n    return a;\n}\n\ntemplate<typename T,typename U>\nU late_seg_tree<T,U>::H(U a,U b){\n    a.F|=b.F;\n    a.S+=b.S;\n    return a;\n}\n\ntemplate<typename T,typename U>\nT late_seg_tree<T,U>::I(T a,U b,ll l,ll r){\n    a.S+=b.S;\n    return a;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nstruct SegT {\nprivate:\n\tint n; vector<int> node, lazy;\n\tconst int init_c = mod;\npublic:\n\tSegT(int sz) {\n\t\tn = 1;\n\t\twhile (n < sz)n <<= 1;\n\t\tnode.resize(2 * n - 1, 0);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\tSegT(vector<int> v) {\n\t\tint sz = v.size();\n\t\tn = 1;\n\t\twhile (n < sz)n <<= 1;\n\t\tnode.resize(2 * n - 1, mod);\n\t\tlazy.resize(2 * n - 1, 0);\n\t\trep(i, sz) {\n\t\t\tnode[i + n - 1] = v[i];\n\t\t}\n\t\tper(i, n - 1) {\n\t\t\tnode[i] = f(node[2 * i + 1], node[2 * i + 2]);\n\t\t}\n\t}\n\tll f(ll a, ll b) {\n\t\treturn min(a, b);\n\t}\n\tvoid eval(int k, int l, int r) {\n\t\tnode[k] += lazy[k];\n\t\tif (r - l > 1) {\n\t\t\tlazy[2 * k + 1] += lazy[k];\n\t\t\tlazy[2 * k + 2] += lazy[k];\n\t\t}\n\t\tlazy[k] = 0;\n\t}\n\tvoid add(int x, int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x; eval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tadd(x, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(x, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tint query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return init_c;\n\t\tif (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n\tint search_id() {\n\t\tint k = 0, l = 0, r = n;\n\t\twhile (k < n - 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\teval(2 * k + 1, l, mid);\n\t\t\teval(2 * k + 2, mid, r);\n\t\t\tif (node[2 * k + 2] < 2) {\n\t\t\t\tk = 2 * k + 2; l = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk = 2 * k + 1, r = mid;\n\t\t\t}\n\t\t}\n\t\treturn k - (n - 1) + 1;\n\t}\n};\n\nvoid solve() {\n\tint n, q; cin >> n >> q;\n\tstring s; cin >> s;\n\tvector<int> c;\n\tint tmp = 0;\n\tset<int> sr;\n\trep(i, s.length()) {\n\t\tif (s[i] == '(')tmp++;\n\t\telse {\n\t\t\ttmp--; sr.insert(i);\n\t\t}\n\t\tc.push_back(tmp);\n\t}\n\tSegT st(c);\n\trep(i, q) {\n\t\tint x; cin >> x; x--;\n\t\tif (s[x] == '(') {\n\t\t\ts[x] = ')';\n\t\t\tst.add(-2, x, n); sr.insert(x);\n\t\t\tint z = *sr.begin();\n\t\t\tcout << z + 1 << endl;\n\t\t\ts[z] = '(';\n\t\t\tst.add(2, z, n);\n\t\t\tsr.erase(z);\n\t\t}\n\t\telse {\n\t\t\ts[x] = '(';\n\t\t\tsr.erase(x);\n\t\t\tst.add(2, x, n);\n\t\t\tint z = st.search_id();\n\t\t\tcout << z + 1 << endl;\n\t\t\ts[z] = ')';\n\t\t\tsr.insert(z);\n\t\t\tst.add(-2, z, n);\n\t\t}\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 550;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray {\n  const int B;\n  SegmentArray(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      else {\n        int st = std::max(a, l), en = std::min(b, r);\n        for(int i = en - 1; i >= st; --i) {\n          if(add[k] + data[i] < 2) {\n            return i + 1;\n          }\n        }\n      }\n    }\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray seg1(N);\n  set<int> seg2;\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.insert(i);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.insert(p);\n      seg1.update(p, N, -2);\n      int np = *seg2.begin();\n      S[np] = '(';\n      seg2.erase(np);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      S[p] = '(';\n      seg2.erase(p);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      S[np] = ')';\n      seg2.insert(np);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, Q;\nstring s;\n\nstruct SegmentTree{\n\tint n;\n\tvector<int> data;\n\tvector<int> sum;\n\tint MAX = 100000000;\n\n\tSegmentTree(int nn){\n\t\tn = 1;\n\t\twhile(n < nn) n *= 2;\n\t\tdata.resize(2 * n - 1, 0);\n\t\tsum.resize(2 * n - 1, 0);\n\t}\n\n\tvoid add(int a, int b, int val){\n\t\tadd(a, b, val, 0, 0, n);\n\t}\n\n\tvoid add(int a, int b, int val, int k, int l, int r){\n\t\t//cout << k << \" \" << l << \" \" << r << endl;\n\t\tif(r <= a || b <= l) return;\n\t\t//cout << \"a\";\n\t\tif(a <= l && r <= b){\n\t\t\tsum[k] += val;\n\t\t\treturn;\n\t\t}\n\t\t//cout << \"b\";\n\t\tadd(a, b, val, k * 2 + 1, l, (l + r) / 2);\n\t\tadd(a, b, val, k * 2 + 2, (l + r) / 2, r);\n\t\tdata[k] = min(data[k * 2 + 1] + sum[k * 2 + 1], data[k * 2 + 2] + sum[k * 2 + 2]);\n\t}\n\n\tint query(int a, int b){\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tint query(int a, int b, int k, int l, int r){\n\t\t//cout << k << \" \" << l << \" \" << r << endl;\n\t\tif(r <= a || b <= l) return MAX;\n\t\tif(a <= l && r <= b) return data[k] + sum[k];\n\t\t\n\t\tint vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tint vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn min(vl, vr) + sum[k];\n\t}\n};\n\nint main(){\n\tcin >> N >> Q;\n\tcin >> s;\n\tSegmentTree tree(N);\n\tset<int> pset;\n\tfor(int i = 0; i < s.size(); i++){\n\t\tif(s[i] == '(') tree.add(i, s.size(), 1);\n\t\telse{\n\t\t\ttree.add(i, s.size(), -1);\n\t\t\tpset.insert(i);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tcout << tree.query(i, i + 1) << \" \" ;\n\t\t}\n\n\t\tcout << endl;\n\t\t*/\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tint idx;\n\t\tcin >> idx;\n\t\tidx--;\n\t\tif(s[idx] == '('){\n\t\t\ts[idx] = ')';\n\t\t\tpset.insert(idx);\n\t\t\ttree.add(idx, N, -2);\n\t\t\tint vv = *begin(pset);\n\t\t\ts[vv] = '(';\n\t\t\tpset.erase(vv);\n\t\t\ttree.add(vv, N, 2);\n\t\t\tcout << (vv + 1) << endl;\n\n\t\t}else{\n\t\t\tpset.erase(idx);\n\t\t\ts[idx] = '(';\n\t\t\ttree.add(idx, N, 2);\n\t\t\tint l = -1;\n\t\t\tint r = N - 1;\n\t\t\twhile(r - l > 1){\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif(tree.query(m, N) >= 2){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(s[r] != '(') r++;\n\t\t\ttree.add(r, N, -2);\n\t\t\ts[r] = ')';\n\t\t\tpset.insert(r);\n\t\t\tcout << (r + 1) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        \n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        assert(S[pos_pos] == '(');\n        // assert(sum_seg.min(pos_pos + 1, q + 1) >= 0);\n        // assert(sum_seg.min(0, N + 1) >= 0);\n        // assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        cout << pos_pos + 1 << endl;\n        close_parens.erase(q);\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tif(l < r){\n\t\t\t\tdelay[k*2] += delay[k];\n\t\t\t\tdelay[k*2+1] += delay[k];\n\t\t\t\tdelay[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tif(cand.count(p)) cand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nclass starry_sky_tree {\npublic:\n    starry_sky_tree(int n_)\n    : n(expand(n_)), data(n * 2, 0), lazy(n * 2, 0)\n    {}\n\n    void add(int l, int r, int val) {\n        l += n, r += n;\n        const int left = l, right = r;\n        while(l != r) {\n            if(l & 1) {\n                lazy[l] += val;\n                data[l++] += val;\n            }\n            if(r & 1) {\n                lazy[--r] += val;\n                data[r] += val;\n            }\n            l /= 2, r /= 2;\n        }\n        l = left, r = right - 1;\n        while(l /= 2, r /= 2) {\n            data[l] = min(data[l * 2], data[l * 2 + 1]) + lazy[l];\n            data[r] = min(data[r * 2], data[r * 2 + 1]) + lazy[r];\n        }\n    }\n\n    // min\n    int query(int l, int r) const {\n        l += n, r += n;\n        int res1 = inf, res2 = inf;\n        while(l != r) {\n            if(l & 1) res1 = min(res1, data[l++]);\n            if(r & 1) res2 = min(res2, data[--r]);\n            l /= 2, r /= 2;\n            res1 += lazy[l - 1];\n            res2 += lazy[r];\n        }\n        --l;\n        while(l /= 2, r /= 2) {\n            res1 += lazy[l];\n            res2 += lazy[r];\n        }\n        return min(res1, res2);\n    }\n\nprivate:\n    int expand(int n) {\n        return n == 1 ? n : expand((n + 1) / 2) * 2;\n    }\n\nprivate:\n    const int n;\n    vector<int> data, lazy;\n};\n\nint main() {\n    int N, Q;\n    string s;\n    cin >> N >> Q >> s;\n\n    starry_sky_tree sum(N);\n    set<int> right_paren;\n    for(int i = 0; i < N; ++i) {\n        if(s[i] == '(') {\n            sum.add(i, N, 1);\n        } else {\n            sum.add(i, N, -1);\n            right_paren.insert(i);\n        }\n    }\n\n    while(Q--) {\n        int q;\n        cin >> q;\n        q--;\n\n        int ans = q;\n        if(s[q] == '(') {\n            sum.add(q, N, -2);\n            right_paren.insert(q);\n            ans = *right_paren.begin();\n            right_paren.erase(ans);\n            sum.add(ans, N, 2);\n        } else {\n            sum.add(q, N, 2);\n            int lb = 0, ub = N - 1;\n            while(ub - lb > 1) {\n                const int mid = (lb + ub) / 2;\n                if(sum.query(mid, N) >= 2) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = ub;\n            sum.add(ans, N, -2);\n            right_paren.erase(q);\n            right_paren.insert(ans);\n        }\n        swap(s[q], s[ans]);\n\n        cout << ans + 1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar s[300005];\nint main()\n{\n\tint q,n,x,i,j,cnt,num1,num2,n1,n2,tar;\n\twhile(scanf(\"%d%d\",&n,&q)!=EOF)\n\t{\n\t\tscanf(\"%s\",s);\n\t\twhile(q--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tx--;\n\t\t\tif(s[x]=='(')\n\t\t\t{\n\t\t\t\ts[x]=')';\n\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t{\n\t\t\t\t\tif(s[i]==')')\n\t\t\t\t\t{\n\t\t\t\t\t\ts[i]='(';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",i+1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(s[x]==')')\n\t\t\t{\n\t\t\t\ts[x]='(';\n\t\t\t\tnum1=0;\n\t\t\t\tnum2=0;\n\t\t\t\tfor(i=n-1;i>=x;i--)\n\t\t\t\t{\n\t\t\t\t\tif(s[i]=='(')\n\t\t\t\t\t\tnum1++;\n\t\t\t\t\telse\n\t\t\t\t\t\tnum2++;\n\t\t\t\t}\n\t\t\t\tn1=num1;\n\t\t\t\tn2=num2;\n\t\t\t\tif(num2>num1)\n\t\t\t\t{\n\t\t\t\t\tfor(i=x-1;i>=0;i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s[i]=='('&&n2>n1)\n\t\t\t\t\t\t\ttar=i;\n\t\t\t\t\t\tif(s[i]=='(')\n\t\t\t\t\t\t\tnum1++;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnum2++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(num1>num2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttar=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts[tar]=')';\n\t\t\t\t\tprintf(\"%d\\n\",tar+1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts[x]=')';\n\t\t\t\t\tprintf(\"%d\\n\",x+1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat, dat2, lazy;\n\npublic:\n  SegmentTree() {\n  }\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = lazy = vector<int>(n*2-1, 0);\n    dat2 = vector<int>(n*2-1, 0);\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += dat[k*2+1] + dat[k*2+2];\n    dat2[k] = min(dat2[k], min(dat2[k*2+1], dat2[k*2+2]));\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        vector<int> pos;\n        for (int i = 0; i < s.size(); ++i) {\n          if (s[i] == '(') pos.push_back(i);\n        }\n        int l = 0, r = pos.size();\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(pos[m], N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << pos[r] + 1 << endl;\n        change(pos[r]);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n  };\n  \n  D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D &a,D &b){\n    if(a.value < b.value) return a;\n    return b;\n  }\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D add(Int a,Int b,Int x,bool flg=true,Int k=0,Int l=0,Int r=-1){\n    if(r==-1 && toMax) x *= -1; \n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = add(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    D res = add(a,b,0,false);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nsigned main(){\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    Int val = s[x] == '('? -2:2;\n    A.add(x, n, val);\n    Int res = A.find(0, n) >= 0 && A.find(n-1, n) == 0;\n    A.add(x, n, -val);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    return *par.lower_bound(R);\n  };\n\nfor(Int i=0;i<q;i++){\n  Int x;\n  scanf(\"%lld\", &x); x--;\n  rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    printf(\"%lld\\n\",y+1);\n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tinline int query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tinline void update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tinline int query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - b1.query(0, r) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0);\n\t\t\td[l] = -1; b1.update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1);\n\t\t\td[pr] = 1; b1.update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct SegTree {\n    int n;\n    vi lazy, d_min;\n\n    int c1(int k) { return 2 * k + 1; }\n    int c2(int k) { return 2 * k + 2; }\n\n    SegTree(int sz){\n        n = 1;\n        while(n < sz) n *= 2;\n        d_min = vi(2 * n, inf);\n        lazy = vi(2 * n, 0);\n    }\n    SegTree(){}\n\n    void update(int k, int l, int r){\n        int& cur = lazy[k];\n        if(cur == 0) return;\n\n        if(d_min[k] == inf) d_min[k] = 0;\n        d_min[k] += cur;\n\n        if(r - l > 1){\n            lazy[c1(k)] += cur;\n            lazy[c2(k)] += cur;\n        }\n        cur = 0;\n    }\n\n    void add(int a, int b, int x, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return;\n        if(a <= l and r <= b){\n            lazy[k] += x;\n            update(k, l, r);\n            return;\n        }\n        \n        add(a, b, x, c1(k), l, (l + r) / 2);\n        add(a, b, x, c2(k), (l + r) / 2, r);\n        \n        if(r - l > 1){\n            d_min[k] = min(d_min[c1(k)], d_min[c2(k)]);\n        }\n    }\n\n    int get_min(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return inf;\n        if(a <= l and r <= b){\n            return d_min[k];\n        }\n        \n        return min(get_min(a, b, c1(k), l, (l + r) / 2),\n                   get_min(a, b, c2(k), (l + r) / 2, r));\n    }\n};\n\nint n;\nSegTree seg;\n\nbool check(int l, int r){\n    return seg.get_min(l, r) >= 2;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int Q; cin >> n >> Q;\n    string in; cin >> in;\n    set<int> s;\n    vi a(n); rep(i, n) a[i] = (in[i] == '(' ? +1:-1);\n    rep(i, n) if(a[i] < 0) s.insert(i);\n\n    seg = SegTree(n);\n    rep(i, n) seg.add(i, n, a[i]);\n\n    rep(loop, Q){\n        int x; cin >> x; x--;\n        int idx;\n        int cur = a[x];\n        // rep(i, n) cerr << seg.get_min(i, i + 1) << \" \"; cerr << endl;\n        if(cur > 0){\n            s.insert(x);\n            idx = *begin(s);\n            s.erase(idx);\n        }\n        else {\n            int lb = -1, ub = x;\n            while(ub - lb > 1){\n                int mid = (lb + ub) / 2;\n                if(check(mid, x + 1)){\n                    ub = mid;\n                }\n                else {\n                    lb = mid;\n                }\n            }\n            idx = ub;\n            s.erase(x);\n            s.insert(idx);\n        }\n        a[idx] *= -1;\n        a[x] *= -1;\n        seg.add(idx, n, cur * 2);\n        seg.add(  x, n, cur * -2);\n        cout << idx+1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (テヲツ環スティツアツ。テ」ツδサテヲツアツ偲・ツ個姪ゥツ??・ツサツカテ」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗ヲツ慊ィ)\n// Verified: AOJ テ」ツ?ョテ」ツつサテ」ツつーテヲツ慊ィ verify テ・ツ閉湘・ツ?ィテゥツδィ\n\nconst int SIZE = 1 << 19;\ntemplate<typename T>\nstruct lazysegtree {\n    // テ」ツδ偲」ツδシテ」ツδ嘉」ツ??・ツ債佚、ツスツ催・ツ??\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // テ」ツつェテ」ツδ堙」ツδャテ」ツδシテ」ツつキテ」ツδァテ」ツδウ (update, query テ」ツ?ョ 2 テ」ツ?、テ」ツ?古・ツソツ?ィツヲツ?ッツシツ?\n    // update function テ」ツ?ッテァツッツ?・ツ崢イテ」ツつ津ヲツ個?・ツョツ堙」ツ?凖」ツつ凝・ツスツ「テ」ツ?ォテ」ツ?療」ツつ暗」ツ??\n    // upd_f(X, Y, l, r) -> テァツッツ?・ツ崢イテ」ツ??[l, r) テ」ツ?ァテ」ツ?づ」ツつ凝」ツつ暗」ツ??」ツ?ェテ」ツδ偲」ツδシテ」ツδ?X テ」ツ?ォ Y テ」ツつ津・ツ渉催ヲツ伉?ッツシツ?\n    // lazy テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ update テ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテァツッツ?・ツ崢イテ」ツつ?1 テ」ツ?ォテ」ツ?療」ツ?ェテ」ツ??」ツ?ィテ」ツδ静」ツつーテ」ツつ甘」ツ?セテ」ツ??\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // テヲツシツ氾ァツョツ療・ツュツ静」ツ?ィテ・ツ債佚、ツスツ催・ツ?ε」ツつ津」ツつサテ」ツδε」ツδ暗」ツ?療」ツ??・ツ?ィテ」ツ?ヲテ」ツ?ョ node テ」ツ?ィ lazy テ」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X, vector<T> vec) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n\n        // vec テ」ツ?ョテ・ツ?、テ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n        for(size_t i=0; i<vec.size(); i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ・ツ?、 val テ」ツつ津・ツ渉催ヲツ伉?」ツ?陛」ツ?崚」ツつ?\n    // (upd_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツつッテ」ツつィテ」ツδェテ」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // (qry_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    if(a == INT_MAX) return b;\n    return a + b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    lazysegtree<int> seg(add, qry, INT_MAX, array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // テ、ツスツ催ァツスツョ idx テ」ツ?ォテ」ツ?づ」ツつ?')' テ」ツつ?'(' テ」ツ?ォ\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                // printf(\"mid = %d, val = %d\\n\", mid, val);\n                if(val > 1) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(ub));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\n//Segment Tree\nclass SegmentTree{\npublic:\n  int n;\n  vi node;\n  vi ofset;\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n=1;\n    while(n<n_)n*=2;\n\n    node = vi(2*n-1, INF);\n    for(int i=0;i<n_;i++)node[i+n-1] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n\n    ofset = vi(2*n-1,0);\n  }\n\n  //return minimum value in [a,b). ( [l,r) is interval in which k is.)\n  int rmq(int a,int b,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b)return node[k]+ofset[k];\n    int pl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int pr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(pl,pr) + ofset[k];\n  }\n\n  int search(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(r-l<=1)return (node[k]+ofset[k] >= v)?l:INF;\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    if(vr + ofset[k] >= v){\n      int res = search(a,b,v,2*k+1,l,(l+r)/2);\n      if(res != INF)return res;\n      return (l+r)/2;\n    }else{\n      int res = search(a,b,v,2*k+2,(l+r)/2,r);\n      if(res != INF)return res;\n      return INF;\n    }\n  }\n \n  int update_range(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return node[k];\n    if(a<=l && r<=b){\n      ofset[k] += v;\n      return node[k]+ofset[k];\n    }\n\n    int vl = update_range(a,b,v,2*k+1,l,(l+r)/2);\n    int vr = update_range(a,b,v,2*k+2,(l+r)/2,r);\n    node[k] = min(vl,vr);\n    return node[k] + ofset[k];\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n\n  set<int> minus;\n  vi h(n,1);\n  rep(i,n-1){\n    if(s[i+1] == '(')h[i+1] = h[i] + 1;\n    else{\n      h[i+1] = h[i] - 1;\n      minus.insert(i+1);\n    }\n  }\n  SegmentTree st(h);\n\n  while(q--){\n    int p;\n    cin >> p; p--;\n    if(s[p] == '('){\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n\n      p = *minus.begin();\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n    }else{\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n\n      p = st.search(0,p+1,2);\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n    }\n    cout << p+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tdelay[k*2] += delay[k];\n\t\t\tdelay[k*2+1] += delay[k];\n\t\t\tdelay[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tif(cand.count(p)) cand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s < t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s < t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s < t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\n// to avoid compile error at aoj\ntemplate <typename T, typename... Args>\nvoid swap_vector(vector<T, Args...> & v, int i, int j) {\n    T t = v[i];\n    v[i] = v[j];\n    v[j] = t;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    vector<bool> is_open(N);\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            is_open[i] = c == '(';\n            if (is_open[i]) {\n                segtree.add_at(i,nest);\n                nest ++;\n            } else {\n                nest --;\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        repeat (j,N) {\n            if (i == j) {\n                cout << i+1 << endl;\n                break;\n            } else if (is_open[j] != is_open[i]) {\n                if (is_open[i] or 0 < segtree.min_query(j, i+1)) {\n                    segtree.add_range(j, i+1, is_open[i] ? 1 : -1);\n                    swap_vector(is_open, i, j);\n                    cout << j+1 << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0;\n\t\t\tfor (int j = r + 1; j < n; j++) sum += d[j];\n\t\t\tif (sum == 0) {\n\t\t\t\tprintf(\"%d\\n\", r + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\t\tsum += d[j];\n\t\t\t\t\tif (sum >= 2) {\n\t\t\t\t\t\td[j] = -1, d[r] = 1; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (d[j] == -1) {\n\t\t\t\t\td[j] = 1, d[r] = -1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nint fix(set<int> &a, set<int> &b, char *s, char before, int x)\n{\n    a.erase(x);\n    b.insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    \n    while (l != r){\n        int mid = (l + r) / 2;\n        int p = *b.lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        //bool cond1 = (p ? abs(getMin(p - 1, p) - getMin(p, p + 1)) == 1 : getMin(0, 1) == 1);\n        //bool cond2 = (p != n - 1 ? abs(getMin(p, p + 1) - getMin(p + 1, p + 2)) == 1 : getMin(0, n - 1) == 0);\n        bool cond1 = true, cond2 = true;\n        \n        if (segMin[0] + segAdd[0] >= 0 && cond1 && cond2) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    int p = *b.lower_bound(l);\n    add(p, n, -2 * base);\n    b.erase(p);\n    a.insert(p);\n    s[p] = before;\n    \n    return (p);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '('){\n            printf(\"%d\\n\", fix(lf, rg, s, '(', x) + 1);\n        }\n        else {\n            printf(\"%d\\n\", fix(rg, lf, s, ')', x) + 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct LazySegTree {\n  vector<ll> seg, lazy;\n  int size;\n  LazySegTree() {}\n  LazySegTree(int n) {\n    init(n);\n  }\n  void init(int n) {\n    size = 1;\n    while (size < n) size *= 2;\n    seg.resize(size * 2);\n    lazy.resize(size * 2);\n    for(int i = 0; i < size*2; i++)seg[i]=INF;\n  }\n  void update(int k,ll v){\n    k += size-1;\n    seg[k] = v;\n    while(k > 0){\n      k = (k - 1)/2;\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void push(int k, int l, int r) {\n    seg[k] += lazy[k];\n    if (r - l > 1) {\n      lazy[k * 2 + 1] += lazy[k];\n      lazy[k * 2 + 2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n  void add(int a, int b, ll v, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += v;\n      push(k, l, r);\n    } else {\n      add(a, b, v, k * 2 + 1, l, (l + r) / 2);\n      add(a, b, v, k * 2 + 2, (l + r) / 2, r);\n      seg[k] = min(seg[k * 2 + 1], seg[k * 2 + 2]);\n    }\n  }\n  void add(int a, int b, ll v) {\n    add(a, b, v, 0, 0, size);\n  }\n  ll query(int a, int b, int k, int l, int r) {\n    push(k, l, r);\n    if (r <= a || b <= l) return INF*100; // caution\n    if (a <= l && r <= b) return seg[k];\n    ll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    ll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return min(vl,vr);\n  }\n  ll query(int a, int b) {\n    return query(a, b, 0, 0, size);\n  }\n};\n\nint N,Q;\nstring s;\nset<int> ngidx;\nint a[300010],sum[300010];\nLazySegTree sgt;\n\nint main(){\n  cin>>N>>Q;\n  cin>>s;\n  rep(i,N){\n    if(s[i]=='('){\n      sum[i+1]=sum[i]+1;\n      a[i]=1;\n    }\n    if(s[i]==')'){\n      ngidx.insert(i);\n      sum[i+1]=sum[i]-1;\n      a[i]=-1;\n    }\n  }\n  sgt.init(N+1);\n  rep(i,N+1)sgt.update(i,sum[i]);\n\n  while(Q--){\n    int q;\n    cin>>q;\n    q--;\n    if(a[q]==1){\n      a[q]=-1;\n      ngidx.insert(q);\n      sgt.add(q+1,N+1,-2);\n      int res=*ngidx.begin();\n      ngidx.erase(ngidx.begin());\n      a[res]=1;\n      sgt.add(res+1,N+1,+2);\n      cout<<res+1<<endl;\n    }else if(a[q]==-1){\n      a[q]=1;\n      ngidx.erase(q);\n      sgt.add(q+1,N+1,+2);\n      int lb=-1,ub=q+1;\n      while(ub-lb>1){\n        int mid=(lb+ub)/2;\n        if(sgt.query(mid,q+1)>=2)ub=mid;\n        else lb=mid;\n      }\n      int res=ub-1;\n      a[res]=-1;\n      ngidx.insert(res);\n      sgt.add(res+1,N+1,-2);\n      cout<<res+1<<endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\n\nstruct BIT\n{\n  int n;\n  vector<int> tree;\n  BIT(int n_)\n  {\n    tree = vector<int>(n_ + 1, 0);\n    n = n_;\n  }\n  int sum(int i)\n  {\n    int ret = 0;\n    while( i > 0 ) {\n      ret += tree[i];\n      i -= i & -i;\n    }\n    return ret;\n  }\n  void add(int i, int x)\n  {\n    while( i <= n ) {\n      tree[i] += x;\n      i += i & -i;\n    }\n  }\n};\n\n\nmain()\n{\n  int N, Q;\n  string s;\n  BIT L(N+1), R(N+1); //L:(  R:)\n\n  cin >> N >> Q >> s;\n\n  Rep(i, N) {\n    if( s[i] == '(' ) L.add( i+1, 1 );\n    else R.add( i+1, 1 );\n  }\n  \n  while( Q-- ) {\n    //cout << L.sum( N ) << \" \" << R.sum( N ) << endl;\n    int q;\n    cin >> q;\n\n    if( L.sum( q ) - L.sum( q-1 ) == 1 ) { // ( -> )\n      L.add( q, -1 );\n      R.add( q, 1 );\n      int l = 1, r = q;\n      while( r - l > 1 ) {\n\tint mod = (l + r) / 2;\n\tif( R.sum( mod ) ) r = mod;\n\t  else l = mod;\n      }\n      \n      if( R.sum( l ) ) {\n\tcout << l << endl;\n\tR.add( l, -1 );\n\tL.add( l, 1 );\n      }\n      else {\n\tcout << r << endl;\n\tR.add( r, -1 );\n\tL.add( r, 1 );\n      }\n    }\n\n    else { // ) -> (\n      //cout << 'R' << endl;\n      L.add( q, 1 );\n      R.add( q, -1 );\n      if( L.sum( N ) - L.sum( q-1 ) < R.sum( N ) - R.sum( q-1 ) ) {\n\n\tint l = 2, r = q;\n\twhile( r - l > 1 ) {\n\t  int mod = (l + r) / 2;\n\t  if( L.sum( mod ) > R.sum( mod ) ) r = mod;\n\t  else l = mod;\n\t}\n\t\n\tif( L.sum( l ) > R.sum( l ) ) {\n\t  cout << l << endl;\n\t  L.add( l, -1 );\n\t  R.add( l, 1 );\n\t}\n\telse {\n\t  cout << r << endl;\n\t  L.add( r, -1 );\n\t  R.add( r, 1 );\n\t}\n      } else {\n\tL.add( q, -1 );\n\tR.add( q, 1 );\n\tcout << q << endl;\n      }\n    }\n  }\n  \n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\n//Segment Tree\nclass SegmentTree{\npublic:\n  int n;\n  vi node;\n  vi ofset;\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n=1;\n    while(n<n_)n*=2;\n\n    node = vi(2*n-1, INF);\n    for(int i=0;i<n_;i++)node[i+n-1] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n\n    ofset = vi(2*n-1,0);\n  }\n\n  //return minimum value in [a,b). ( [l,r) is interval in which k is.)\n  int rmq(int a,int b,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b)return node[k]+ofset[k];\n    int pl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int pr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(pl,pr) + ofset[k];\n  }\n\n  int search(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b && node[k]+ofset[k] >= v)return l;\n    if(r-l<=1)return INF;\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    if(vr + ofset[k] >= v){\n      int res = search(a,b,v-ofset[k],2*k+1,l,(l+r)/2);\n      return min(res, (l+r)/2);\n    }else{\n      int res = search(a,b,v-ofset[k],2*k+2,(l+r)/2,r);\n      return res;\n    }\n  }\n \n  int update_range(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return node[k];\n    if(a<=l && r<=b){\n      ofset[k] += v;\n      return node[k]+ofset[k];\n    }\n\n    int vl = update_range(a,b,v,2*k+1,l,(l+r)/2);\n    int vr = update_range(a,b,v,2*k+2,(l+r)/2,r);\n    node[k] = min(vl,vr);\n    return node[k]+ofset[k];\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n\n  set<int> minus;\n  vi h(n,1);\n  rep(i,n-1){\n    if(s[i+1] == '(')h[i+1] = h[i] + 1;\n    else{\n      h[i+1] = h[i] - 1;\n      minus.insert(i+1);\n    }\n  }\n  SegmentTree st(h);\n\n  while(q--){\n    int p;\n    cin >> p; p--;\n    if(s[p] == '('){\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n\n      p = *minus.begin();\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n    }else{\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n\n      p = st.search(0,p+1,2);\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n    }\n    /*\n    for(int i=0;i<2*st.n-1;i++){\n      cerr << st.node[i] << \" \" << st.ofset[i] << endl;\n      }*/\n\n    cout << p+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn = 500000;\nstruct node {\n    int lt,rt,theFirst,theMin,lazy,dir;\n} tree[maxn<<2];\nint sum,n,m;\nchar str[maxn];\nvoid build(int lt,int rt,int v) {\n    tree[v].lt = lt;\n    tree[v].rt = rt;\n    tree[v].lazy = 0;\n    if(lt == rt) {\n        tree[v].dir = str[lt] == '('?1:-1;\n        sum += tree[v].dir;\n        tree[v].theMin = sum;\n        tree[v].theFirst = tree[v].dir == 1?INF:lt;\n        return;\n    }\n    int mid = (lt + rt)>>1;\n    build(lt,mid,v<<1);\n    build(mid+1,rt,v<<1|1);\n    tree[v].theFirst = min(tree[v<<1].theFirst,tree[v<<1|1].theFirst);\n    tree[v].theMin = min(tree[v<<1].theMin,tree[v<<1|1].theMin);\n}\nint update(int p,int v) {\n    if(tree[v].lt >= p && tree[v].rt <= p) {\n        int tmp = tree[v].dir;\n        tree[v].dir *= -1;\n        tree[v].theFirst = tmp == 1?p:INF;\n        return tmp;\n    }\n    int mid = (tree[v].lt + tree[v].rt)>>1,ret;\n    if(p <= mid) ret = update(p,v<<1);\n    if(p > mid) ret = update(p,v<<1|1);\n    tree[v].theFirst = min(tree[v<<1].theFirst,tree[v<<1|1].theFirst);\n    return ret;\n}\nvoid pushdown(int v) {\n    if(tree[v].lazy) {\n        tree[v<<1].lazy += tree[v].lazy;\n        tree[v<<1|1].lazy += tree[v].lazy;\n        tree[v].lazy = 0;\n    }\n}\nvoid pushup(int v) {\n    tree[v].theMin = min(tree[v<<1].theMin+tree[v<<1].lazy,tree[v<<1|1].theMin+tree[v<<1|1].lazy);\n}\nvoid update(int lt,int rt,int v,int value) {\n    if(tree[v].lt >= lt && tree[v].rt <= rt) {\n        tree[v].lazy += value;\n        return;\n    }\n    pushdown(v);\n    int mid = (tree[v].lt + tree[v].rt)>>1;\n    if(lt <= mid) update(lt,rt,v<<1,value);\n    if(rt > mid) update(lt,rt,v<<1|1,value);\n    pushup(v);\n}\nint query(int v,int o) {\n    if(tree[v].theMin+tree[v].lazy >= 2) return tree[v].lt;\n    if(tree[v].lt == tree[v].rt)return o;\n    pushdown(v);\n    int ret;\n    //cout<<tree[v].lt<<\" \"<<tree[v].rt<<\" \"<<tree[v].theMin<<endl;\n    if(tree[v<<1|1].theMin+tree[v<<1|1].lazy >= 2)\n        ret = query(v<<1,tree[v<<1|1].lt);\n    else ret = query(v<<1|1,o);\n    pushup(v);\n    return ret;\n}\nint main() {\n    int p;\n    while(~scanf(\"%d %d\",&n,&m)) {\n        scanf(\"%s\",str+1);\n        sum = 0;\n        build(1,n,1);\n        while(m--) {\n            scanf(\"%d\",&p);\n            int tmp = update(p,1);\n            if(tmp == 1) {\n                update(p,n,1,-2);\n                printf(\"%d\\n\",p = tree[1].theFirst);\n                tmp = update(p,1);\n                update(p,n,1,2);\n            } else if(tmp == -1) {\n                update(p,n,1,2);\n                printf(\"%d\\n\",p = query(1,n));\n                tmp = update(p,1);\n                update(p,n,1,-1);\n            }\n        }\n    }\n    return 0;\n}\n/*\n6 1\n((()))\n6\n6 3\n((()))\n4\n3\n1\n*/"
  },
  {
    "language": "C++",
    "code": "/**\nZubayet Zaman Zico\n\ncodeforces : I_See_You\nhackerrank : I_See_You\ncodechef   : xico\nspoj       : xico\nemail      : hhoho07@gmail.com\n**/\n\n//#include <stdio.h>\n//#include <iostream>\n//#include <cstring>\n//#include <cmath>\n//#include <algorithm>\n//#include <string>\n//#include <vector>\n//#include <map>\n//#include <set>\n//#include <queue>\n//#include <cstdlib>\n//#include <limits>\n//#include <iostream>\n//#include <sstream>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <random>\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//using namespace __gnu_pbds;\nusing namespace std;\n\n\n//#define gc getchar unlocked\n//#ifndef ONLINE JUDGE\n#define gc getchar\n//#endif // ONLINE JUDGE\n\n//#define pc putchar_unlocked\n//#ifndef ONLINE JUDGE\n#define pc putchar\n//#endif // ONLINE JUDGE\n\n#define fRead           freopen(\"input.txt\",\"r\",stdin)\n#define fWrite          freopen(\"output.txt\",\"w\",stdout)\n\n#define eps             1e-9\n#define inf             0x3f3f3f3f\n#define INF             2e18\n#define LL              long long\n#define ULL             unsigned long long\n#define PI              acos(-1.0)\n#define pb              push_back\n#define mk              make_pair\n#define pii             pair<int,int>\n#define pLL             pair<LL,LL>\n#define ff              first\n#define ss              second\n#define all(a)          a.begin(),a.end()\n#define rall(a)         a.rbegin(),a.rend()\n#define SQR(a)          ((a)*(a))\n#define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\n#define min3(a,b,c)     min(a,min(b,c))\n#define max3(a,b,c)     max(a,max(b,c))\n#define min4(a,b,c,d)   min(min(a,b),min(c,d))\n#define max4(a,b,c,d)   max(max(a,b),max(c,d))\n#define max5(a,b,c,d,e) max(max3(a,b,c),max(d,e))\n#define min5(a,b,c,d,e) min(min3(a,b,c),min(d,e))\n#define Iterator(a)     __typeof__(a.begin())\n#define rIterator(a)    __typeof__(a.rbegin())\n#define FOR(a,it)       for(Iterator(a) it = a.begin();it != a.end(); it++)\n#define rFOR(a,it)      for(rIterator(a) it = a.rbegin();it != a.rend(); it++)\n#define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\n#define CasePrint       pc('C'); pc('a'); pc('s'); pc('e'); pc(' '); write(qq++,false); pc(':'); pc(' ')\n#define vi              vector <int>\n#define vL              vector <LL>\n#define For(I,A,B)      for(int I = (A); I  < (B); ++I)\n#define rFor(I,A,B)     for(int I = (A); I >= (B); --I)\n#define Rep(I,N)        For(I,0,N)\n#define REP(I,N)        For(I, 1, N + 1)\n#define gti             int, vi, greater<int>\n#define gtL             LL, vL, greater<LL>\n#define Found(a, b)     a.find(b) != a.end()\n#define y0              y00\n\nconst int MOD = 1e9 + 7;\nint fx[] = {-1,+0,+1,+0,+1,+1,-1,-1,+0};\nint fy[] = {+0,-1,+0,+1,+1,-1,+1,-1,+0};\nint day[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n//template <typename T> using orderset = tree <T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>; // find_by_order, order_of_key\ntemplate <typename T> inline bool isLeap(T y) {return (y % 400 == 0) || (y % 100 ? y % 4 == 0 : false); }\ntemplate <typename T> inline T GCD (T a,T b ) {a = abs(a);b = abs(b); if(a < b) swap(a, b); while ( b ) { a = a % b; swap ( a, b ); } return a;}\ntemplate <typename T> inline T EGCD(T a,T b,T &x,T &y){if(a == 0) {x = 0;y = 1;return b;}T x1, y1;T d = EGCD(b % a, a, x1, y1);x = y1 - (b / a) * x1;y = x1;return d;}\ntemplate <typename T> inline T LCM(T x,T y){T tp = GCD(x,y);if( (x / tp) * 1. * y > 9e18) return 9e18;return (x / tp) * y;}\ntemplate <typename T> inline T BigMod(T A,T B,T M = MOD){A %= M;T ret = 1;while(B){if(B & 1) ret = (ret * A) % M;A = (A * A) % M;B = B >> 1;}return ret;}\ntemplate <typename T> inline T InvMod (T A,T M = MOD){return BigMod(A,M-2,M);}\ntemplate <typename T> void Compress(T * in, int n, int f = 0){vector <T> vv;for(int i = f; i < n + f; i++) vv.pb(in[i]);Unique(vv);for(int i = f; i < n + f; i++) in[i] = lower_bound(all(vv), in[i]) - vv.begin();}\n//template <typename T> void Compress(vector <T> &in){vector <T> vv;for(T x : in) vv.pb(x);Unique(vv);for(int i = 0; i < in.size(); i++) in[i] = lower_bound(all(vv), in[i]) - vv.begin();}\n/*---------------------------fast I/O------------------------------------*/\n#define scani2(a,b) scani(a) , scani(b)\n#define scani3(a,b,c) scani(a), scani(b), scani(c)\n#define scani4(a,b,c,d) scani(a), scani(b), scani(c), scani(d)\n#define scani5(a,b,c,d,e) scani(a), scani(b), scani(c), scani(d) , scani(e)\ntemplate <typename T> T scani(T &n){n = 0;bool negative = false;char c = gc();while( c < '0' || c > '9'){if(c == '-') negative = true;c = gc();}while(c >= '0' && c <= '9'){n = n*10 + c-48;c = gc();}if(negative) n = ~(n-1);return n;}\ntemplate <typename T> void write(T n,int type = true){if(n<0) {pc('-');n = -n;}if(!n) {pc('0');if(type==32) pc(' '); else if(type) pc('\\n'); return;}char buff[22];int len = 0;while(n) buff[len++] = n%10+48,n/=10;for(int i=len-1;i>=0;i--) pc(buff[i]);if(type==32) pc(' '); else if(type) pc('\\n');}\nint scans(char *a){int i=0;char c = 0;while(c < 33) c = gc();while(c > 33){a[i++] = c;c = gc();}a[i] = 0;return i;}\n/*********************************************** End of template *********************************************/\n\n\n#ifdef Sieve\nconst int pSz = 2000006;\nbool np[pSz + 10]; vi prime; int prime_size;void sieve(){np[0] = np[1] = 1;prime.pb(2);for(LL i = 4; i <= pSz; i+=2) np[i] = 1;for(LL i = 3; i <= pSz; i+=2){if(!np[i]){prime.pb(i);for(LL j = i * i; j <= pSz; j += (i << 1)) np[j] = 1;}}prime_size = prime.size();}\n#endif\n\n#ifdef Combi\nconst int nSz = 2000006;\nLL F[nSz + 1], tMod = MOD;\nvoid Factorial(){ F[0] = 1; for(int i = 1; i <= nSz; i++) F[i] = (F[i - 1] * i) % tMod; }\ninline LL nCr(int n, int r) { if(n < r) return 0; return (F[n] * InvMod((F[n - r] * F[r]) % tMod, tMod)) % tMod; }\n\n#endif\n\n#ifdef Z_Algo\nvoid zAlgo(char *s, int *z){\n    int L, R, sz; sz = strlen(s); z[0] = L = R = 0;\n    For(i, 1, sz) { z[i] = 0; if(i <= R) z[i] = min(z[i - L], R - i + 1); while(i + z[i] < sz && s[i + z[i]] == s[z[i]]) z[i]++; if(i + z[i] - 1 > R) L = i, R = i + z[i] - 1; }\n}void zAlgo(string &s, int *z){\n    int L, R, sz; sz = s.size(); z[0] = L = R = 0;\n    For(i, 1, sz) { z[i] = 0; if(i <= R) z[i] = min(z[i - L], R - i + 1); while(i + z[i] < sz && s[i + z[i]] == s[z[i]]) z[i]++; if(i + z[i] - 1 > R) L = i, R = i + z[i] - 1; }\n}void zAlgo(int *s, int *z, int n){\n    int L, R, sz; sz = n; z[0] = L = R = 0;\n    For(i, 1, sz) { z[i] = 0; if(i <= R) z[i] = min(z[i - L], R - i + 1); while(i + z[i] < sz && s[i + z[i]] == s[z[i]]) z[i]++; if(i + z[i] - 1 > R) L = i, R = i + z[i] - 1; }\n}\n#endif // Z_Algo\n\n\n/********************************************* define Template *************************************************/\n\ntemplate <typename T> inline T SqrDis(T x1, T y1, T x2, T y2){return SQR(x1 - x2) + SQR(y1 - y2);}\ntemplate <typename T> inline T Area2(T Ax, T Ay, T Bx, T By, T Cx, T Cy){T ret = Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By);\n    if(ret < 0) return ret = -ret;\n    return ret;\n}\n/**************************************************** GEO ******************************************************/\nconst int N = 2000006; /** need to update this **/\nconst int M = 2097152 + 10;\nconst ULL hs = 3797;\n/** use data types carefully try to take 'long long' **/\nconst int base = 555;\n\nset <int> close;\nint Tree[N << 2], Pr[N << 2], cum[N];\nint n, qr;\nchar ch[N];\n\nvoid push_down(int node, int b, int e){\n    if(Pr[node] == 0 || b == e) return ;\n    int mid = b + e >> 1;\n    int lf = node << 1;\n    int rt = lf | 1;\n\n    Pr[lf] += Pr[node];\n    Pr[rt] += Pr[node];\n    Tree[lf] += Pr[node];\n    Tree[rt] += Pr[node];\n\n    Pr[node] = 0;\n}\n\nvoid built(int node, int b, int e) {\n    if(b == e) {\n        Tree[node] = cum[b];\n        return ;\n    }\n    int mid = b + e >> 1;\n    int lf = node << 1;\n    int rt = lf | 1;\n    built(lf, b, mid);\n    built(rt, mid + 1, e);\n    Tree[node] = min(Tree[lf], Tree[rt]);\n}\n\nvoid update(int node, int b, int e, int i, int j, int v) {\n    push_down(node, b, e);\n    if(b > j || e < i) return ;\n    if(b >= i && e <= j){\n        Tree[node] += v;\n        Pr[node] += v;\n        return ;\n    }\n    int mid = b + e >> 1;\n    int lf = node << 1;\n    int rt = lf | 1;\n    update(lf, b, mid, i, j, v);\n    update(rt, mid + 1, e, i, j, v);\n    Tree[node] = min(Tree[lf], Tree[rt]);\n}\n\nint query(int node, int b, int e){\n    push_down(node, b, e);\n    if(b == e) return b;\n    int mid = b + e >> 1;\n    int lf = node << 1;\n    int rt = lf | 1;\n//    cout << node << ' ' << b << ' ' << e << ' ' << Tree[lf] << ' ' << Tree[rt] << '\\n';\n    if(Tree[rt] >= 2) return query(lf, b, mid);\n    return query(rt, mid + 1, e);\n}\n\nint res[N];\n\nint main()\n{\n    scanf(\"%d %d\", &n, &qr);\n    scanf(\"%s\", ch + 1);\n    For(i, 1, n + 1) {\n        cum[i] += cum[i - 1];\n        if(ch[i] == '(') {\n            cum[i]++;\n        }\n        else {\n            cum[i]--;\n            close.insert(i);\n        }\n    }\n\n    built(1, 1, n);\n    Rep(i, qr) {\n        int x; scanf(\"%d\", &x);\n        if(ch[x] == '(') {\n            update(1, 1, n, x, n, -2);\n            ch[x] = ')';\n            close.insert(x);\n            x = *close.begin();\n            res[i] = x;\n            ch[x] = '(';\n            update(1, 1, n, x, n, +2);\n            close.erase(x);\n        }\n        else {\n            update(1, 1, n, x, n, +2);\n            close.erase(x);\n            ch[x] = '(';\n            x = query(1, 1, n) + 1;\n            ch[x] = ')';\n            update(1, 1, n, x, n, -2);\n            close.insert(x);\n            res[i] = x;\n        }\n    }\n    Rep(i, qr) printf(\"%d\\n\", res[i]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\n\nint main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(80);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='(')\n\tST.add(i,n,1);\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  int p=0;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{\n\t      p=str.find('(',p+1);\n\t    }while(ST.get_min(p,n)<2);\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tdelay[k*2] += delay[k];\n\t\t\tdelay[k*2+1] += delay[k];\n\t\t\tdelay[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tif(cand.count(p)) cand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <ctype.h>\n#include <limits.h>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#define CLR(a) memset(a, 0, sizeof(a))\n#define REP(i, a, b) for(int i = a;i < b;i++)\n#define REP_D(i, a, b) for(int i = a;i <= b;i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int maxn = 300000 + 100;\nconst int INF = 0;\nconst int MAX_NODE = maxn*4 + 10;\n\nint tree[MAX_NODE], late[MAX_NODE];\nchar s[maxn], a[maxn];\nint n, rtn, q;\nset<int> you;\n\nvoid pushUp(int rt)\n{\n    int lRt = (rt<<1), rRt = ((rt<<1)|1);\n    tree[rt] = min(tree[lRt], tree[rRt]);\n}\n\nvoid initail()\n{\n    CLR(late);\n    rtn = 1;\n    while(rtn < n)\n    {\n        rtn <<= 1;\n    }\n    for(int i = 1;i<=n;i++)\n    {\n        tree[i+rtn-1] = a[i];\n    }\n    for(int i = rtn+n;i<rtn*2;i++)\n    {\n        tree[i] = 1e9;\n    }\n    for(int i = rtn-1;i>=1;i--)\n    {\n        pushUp(i);\n    }\n}\n\nvoid pushDown(int rt)\n{\n    if(late[rt] == INF)\n        return;\n    int lRt = (rt<<1), rRt = ((rt<<1)|1);\n    int key = late[rt];\n    late[rt] = INF;\n    late[lRt] += key;\n    tree[lRt] += key;\n    late[rRt] += key;\n    tree[rRt] += key;\n}\n\n\nvoid change(int L, int R, int key, int rt, int l, int r)\n{\n    if(L <= l && R >= r)\n    {\n        late[rt] += key;\n        tree[rt] += key;\n        return;\n    }\n    pushDown(rt);\n    int mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(L <= mid)\n    {\n        change(L, R, key, lRt, l, mid);\n    }\n    if(R >= mid + 1)\n    {\n        change(L, R, key, rRt, mid + 1, r);\n    }\n    pushUp(rt);\n}\nint query(int rt, int l, int r)\n{\n    if(l==r)\n    {\n        return l;\n    }\n    pushDown(rt);\n    int mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(tree[rRt] >= 2)\n    {\n        return query(lRt, l, mid);\n    }\n    else\n    {\n        return query(rRt, mid+1, r);\n    }\n}\n\n\n\nint query(int L, int R, int rt, int l, int r)\n{\n    if(L <= l && R >= r)//全包括\n    {\n        return tree[rt];\n    }\n    pushDown(rt);//下一次?延?\n    int ans = INF, mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(L <= mid)\n    {\n        ans = min(ans, query(L, R, lRt, l, mid));\n    }\n    if(R >= mid + 1)\n    {\n        ans = min(ans, query(L, R, rRt, mid + 1, r));\n    }\n    return ans;\n}\n\nvoid solve()\n{\n    you.clear();\n    a[0] = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        a[i] = a[i-1];\n        if(s[i]=='(')\n        {\n            a[i]++;\n        }\n        else\n        {\n            you.insert(i);\n            a[i]--;\n        }\n    }\n    initail();\n    int ans;\n    while(q--)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        if(s[x] == '(')\n        {\n            s[x] = ')';\n            change(x, n, -2, 1, 1, rtn);\n            you.insert(x);\n            ans = (*you.begin());\n            printf(\"%d\\n\", ans);\n            s[ans] = '(';\n            change(ans, n, 2, 1, 1, rtn);\n            you.erase(you.begin());\n        }\n        else\n        {\n            s[x] = '(';\n            change(x, n, 2, 1, 1, rtn);\n            you.erase(x);\n            ans = query(1, 1, rtn);\n            ans++;\n            printf(\"%d\\n\", ans);\n            s[ans] = ')';\n            change(ans, n, -2, 1, 1, rtn);\n            you.insert(ans);\n        }\n    }\n}\n\nint main()\n{\n   // freopen(\"7Gin.txt\", \"r\", stdin);\n    //freopen(\"7Gout.txt\", \"w\", stdout);\n    while(scanf(\"%d%d\", &n, &q)!=EOF)\n    {\n        scanf(\"%s\", s+1);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> lp,rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,0));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                //assert(s[l+1]=='(');\n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tif(l < r){\n\t\t\t\tdelay[k*2] += delay[k];\n\t\t\t\tdelay[k*2+1] += delay[k];\n\t\t\t}\n\t\t\tdelay[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tif(cand.count(p)) cand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s < t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s < t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s < t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\n// to avoid compile error at aoj\ntemplate <typename T, typename... Args>\nvoid swap_vector(vector<T, Args...> & v, int i, int j) {\n    T t = v[i];\n    v[i] = v[j];\n    v[j] = t;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    vector<bool> is_open(N);\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            is_open[i] = c == '(';\n            if (is_open[i]) {\n                segtree.add_at(i,nest);\n                nest ++;\n            } else {\n                nest --;\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        repeat (j,N) {\n            if (i == j) {\n                cout << i+1 << endl;\n                break;\n            } else if (is_open[j] != is_open[i]) {\n                if (is_open[i] or 0 < segtree.min_query(j, i+1)) {\n                    segtree.add_range(j, i+1, is_open[i] ? 1 : -1);\n                    swap_vector(is_open, i, j);\n                    cout << j+1 << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 300005\n#define L (cur*2)\n#define R (L+1)\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\nint n,q;\nint mnr[M*4], sum[M*4], posl[M*4];\nchar buf[M];\n\nvoid up(int cur,int ll,int rr)\n{\n\tsum[cur] = sum[L] + sum[R];\n\tposl[cur] = min(posl[L], posl[R]);\n\tmnr[cur] = min(mnr[R], sum[R]+mnr[L]);\n}\nvoid init(int cur,int ll,int rr)\n{\n\tif(ll==rr)\n\t{\n\t\tif(buf[ll]=='(')\n\t\t{\n\t\t\tsum[cur] = mnr[cur] = -1;\n\t\t\tposl[cur] = M;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum[cur] = mnr[cur] = 1;\n\t\t\tposl[cur] = ll;\n\t\t}\n\t\treturn;\n\t}\n\n\tint mid = (ll+rr)/2;\n\tinit(L,ll,mid);\n\tinit(R,mid+1,rr);\n\tup(cur,ll,rr);\n}\nvoid upd(int cur,int ll,int rr,int x,int v)\n{\n\tif(ll==rr)\n\t{\n\t\tsum[cur] = mnr[cur] = v;\n\t\t\n\t\tif(v==-1) posl[cur]=M;\n\t\telse posl[cur]=ll;\n\t\treturn;\n\t}\n\n\tint mid = (ll+rr)/2;\n\tif(x<=mid) upd(L,ll,mid,x,v);\n\telse upd(R,mid+1,rr,x,v);\n\tup(cur,ll,rr);\n}\nint ask(int cur,int ll,int rr,int s)\n{\n\tif(ll==rr)\n\t{\n\t\tif(s!=mnr[cur]) return -1;\n\t\treturn ll;\n\t}\n\n\tint mid = (ll+rr)/2;\n\t\n\tif(mnr[R] > s)\n\t{\n\t\tint re = ask(L,ll,mid,s-sum[R]);\n\t\tif(re!=-1) return re;\n\t\treturn mid+1;\n\t}\n\treturn ask(R,mid+1,rr,s);\n}\n\nint main()\n{\n\tint x;\n\tRI(n,q);\n\tscanf(\"%s\", buf+1);\n\tinit(1,1,n);\n\n\twhile(q--)\n\t{\n\t\tscanf(\"%d\",&x);\n\t\tif(buf[x]=='(')\n\t\t{\n\t\t\tbuf[x] = ')';\n\t\t\tupd(1,1,n,x,1);\n\t\t\t\n\t\t\tx = posl[1];\n\t\t\tbuf[x] = '(';\n\t\t\tupd(1,1,n,x,-1);\n\t\t\tprintf(\"%d\\n\",x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuf[x] = '(';\n\t\t\tupd(1,1,n,x,-1);\n\n\t\t\tx = ask(1,1,n,-1);\n\t\t\tbuf[x] = ')';\n\t\t\tupd(1,1,n,x,1);\n\t\t\tprintf(\"%d\\n\", x);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar str[310000];\nset<int>S;\nint segtree[1048576];\nint getmin(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c||c>d)return 1000000007;\n\tif(c<=a&&b<=d)return f+segtree[e];\n\treturn min(getmin(a,(a+b)/2,c,d,e*2,f+segtree[e]),getmin((a+b)/2+1,b,c,d,e*2+1,f+segtree[e]));\n}\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(c>d)return;\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]+=f;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n\tif(segtree[e*2]>0&&segtree[e*2+1]>0){\n\t\tint val=min(segtree[e*2],segtree[e*2+1]);\n\t\tsegtree[e]+=val;\n\t\tsegtree[e*2]-=val;\n\t\tsegtree[e*2+1]-=val;\n\t}\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",str);\n\tfor(int i=0;i<a;i++)if(str[i]==')')S.insert(i);\n\tint now=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(str[i]=='(')now++;\n\t\telse now--;\n\t\tadd(0,524287,i+1,i+1,1,now);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint c;scanf(\"%d\",&c);c--;\n\t\tif(str[c]=='('){\n\t\t\tS.insert(c);\n\t\t\tstr[c]=')';\n\t\t\tint at=*(S.begin());\n\t\t\tprintf(\"%d\\n\",at+1);\n\t\t\tstr[at]='(';\n\t\t\tS.erase(at);\n\t\t\tadd(0,524287,at+1,c,1,2);\n\t\t}else{\n\t\t\tS.erase(c);\n\t\t\tstr[c]='(';\n\t\t\tadd(0,524287,c+1,a,1,2);\n\t\t\tint L=-1;\n\t\t\tint R=c;\n\t\t\twhile(L+1<R){\n\t\t\t\tint M=(L+R)/2;\n\t\t\t\tint val=getmin(0,524287,M+1,c+1,1,0);\n\t\t\t\tif(val>=2)R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",R+1);\n\t\t\tstr[R]=')';\n\t\t\tS.insert(R);\n\t\t\tadd(0,524287,R+1,a,1,-2);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define nl n<<1|1\n#define nr n+1<<1\nchar s[300005];\nint a1[300005],st[2400005][2],mk[2400005];\nvoid pu(int n)\n{\n    if(~st[nl][0])st[n][0]=st[nl][0];\n    else st[n][0]=st[nr][0];\n    st[n][1]=min(st[nl][1],st[nr][1]);\n}\nvoid bd(int l,int r,int n)\n{\n    if(l==r)\n    {\n        st[n][0]=s[l]==')'?l:-1;\n        st[n][1]=a1[l];\n        return;\n    }\n    int md=l+r>>1;\n    bd(l,md,nl);bd(md+1,r,nr);\n    pu(n);\n//printf(\"Q%d %d %d %d\\n\",l,r,st[n][0],st[n][1]);\n}\nvoid pd(int n)\n{\n    if(!mk[n])return;\n    mk[nl]+=mk[n];st[nl][1]+=mk[n];\n    mk[nr]+=mk[n];st[nr][1]+=mk[n];\n    mk[n]=0;\n}\nint qy1(int a,int b,int l,int r,int n)\n{\n    if(a<=l&&b>=r)return st[n][0];\n    pd(n);\n    int md=l+r>>1;\n    if(b<=md)return qy1(a,b,l,md,nl);\n    if(a>md)return qy1(a,b,md+1,r,nr);\n    int t=qy1(a,md,l,md,nl);\n    return ~t?t:qy1(md+1,b,md+1,r,nr);\n}\nint qy2(int l,int r,int n)\n{\n    if(l==r)return l;\n    pd(n);\n    int md=l+r>>1;\n    if(st[nr][1]<0)return qy2(md+1,r,nr);\n    else return qy2(l,md,nl);\n}\nvoid ud1(int a,int b,int c,int l,int r,int n)\n{\n    if(a<=l&&b>=r){st[n][1]+=c;mk[n]+=c;return;}\n    pd(n);\n    int md=l+r>>1;\n    if(a<=md)ud1(a,b,c,l,md,nl);\n    if(b>md)ud1(a,b,c,md+1,r,nr);\n    pu(n);\n}\nvoid ud2(int a,int l,int r,int n)\n{\n    if(l==r)\n    {\n        s[a]^=1;\n        if(~st[n][0])st[n][0]=l;else st[n][0]=-1;\n        st[n][0]=s[l]==')'?l:-1;\n        return;\n    }\n    pd(n);\n    int md=l+r>>1;\n    if(a<=md)ud2(a,l,md,nl);\n    else ud2(a,md+1,r,nr);\n    pu(n);\n}\nvoid debug(int l,int r,int n)\n{\n    printf(\"!!!%d %d %d %d %d\\n\",l,r,n,st[n][0],st[n][1]);\n    if(l==r)return;\n    int md=l+r>>1;\n    debug(l,md,nl);debug(md+1,r,nr);\n}\nint main()\n{\n    int n,q,a,b;\n    scanf(\"%d%d%s\",&n,&q,s);\n    for(int i=n-1;~i;--i)\n        a1[i]=a1[i+1]+(s[i]==')')*2-1;\n    bd(0,n-1,0);\n    while(q--)\n    {\n        scanf(\"%d\",&a);--a;\n        if(s[a]=='(')\n        {\n            b=qy1(0,a,0,n-1,0);\n            if(!~b){printf(\"%d\\n\",a+1);continue;}\n            printf(\"%d\\n\",b+1);\n            ud1(b+1,a,2,0,n-1,0);\n            ud2(a,0,n-1,0);ud2(b,0,n-1,0);\n        }\n        else\n        {\n            ud1(0,a,-2,0,n-1,0);\n            b=qy2(0,n-1,0);\n            printf(\"%d\\n\",b+1);\n            ud1(0,b,2,0,n-1,0);\n            ud2(a,0,n-1,0);ud2(b,0,n-1,0);\n        }\n        puts(s);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define MAXN 301000\nstruct Node {\n\tint start, end;\n\tint minv, flag, add;\n\tvoid operator += (const int& val) {\n\t\tminv += val;\n\t\tflag += val;\n\t\tadd += val;\n\t}\n} tree[MAXN<<2];\nint n;\nchar str[MAXN];\nint diff[MAXN];\nvoid pushdown (int o) {\n\tif (tree[o].add) {\n\t\ttree[o<<1] += tree[o].add;\n\t\ttree[o<<1|1] += tree[o].add;\n\t\ttree[o].add = 0;\n\t}\n}\nvoid pushup (int o) {\n\ttree[o].minv = min(tree[o<<1].minv, tree[o<<1|1].minv);\n\ttree[o].flag = min(tree[o<<1].flag, tree[o<<1|1].flag);\n}\nvoid build (int o, int start, int end) {\n\ttree[o].start = start;\n\ttree[o].end = end;\n\ttree[o].add = 0;\n\tif (start == end) {\n\t\ttree[o].flag = start - diff[start];\n\t\ttree[o].minv = diff[start];\n\t\treturn;\n\t}\n\tint mid = (start + end) >> 1;\n\tbuild(o<<1, start, mid);\n\tbuild(o<<1|1, mid + 1, end);\n\tpushup(o);\n}\nvoid update (int o, int pos, int val) {\n\t//printf (\"%d %d %d\\n\", tree[o<<1].start, tree[o].end, pos);\n\tif (pos <= tree[o].start) {\n\t\ttree[o] += val;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tif (pos <= tree[o<<1].end)\n\t\tupdate(o<<1, pos, val);\n\tupdate(o<<1|1, pos, val);\n\tpushup (o);\n}\nint query1 (int o) {\n\t//printf (\"%d: %d %d %d\\n\", 1, tree[o].start, tree[o].end, tree[o<<1].flag);\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].start;\n\tpushdown(o);\n\tint r;\n\tif (tree[o<<1].flag < 0)\n\t\tr = query1(o<<1);\n\telse\n\t\tr = query1(o<<1|1);\n\tpushup(o);\n\treturn r;\n}\nint query2(int o) {\n\t//printf (\"%d: %d %d %d\\n\", 2, tree[o].start, tree[o].end, tree[o<<1].minv);\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].minv < 2 ? INF : tree[o].start;\n\tpushdown(o);\n\tint r;\n\tif (tree[o<<1|1].minv < 2)\n\t\tr = query2(o<<1|1);\n\telse\n\t\tr = min(query2(o<<1), tree[o<<1|1].start);\n\tpushup(o);\n\treturn r;\n}\nint main () {\n#ifdef TXT\n\tfreopen (\"in.txt\", \"r\", stdin);\n#endif\n\tint q, pos;\n\twhile (~scanf (\"%d%d\", &n, &q)) {\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tdiff[i] = diff[i - 1] + (str[i] == '(' ? 1 : -1);\n\t\tbuild(1, 1, n);\n\t\twhile (q --) {\n\t\t\tscanf (\"%d\", &pos);\n\t\t\tupdate(1, pos, str[pos] == '(' ? -2 : 2);\n\t\t\tstr[pos] = str[pos] == ')' ? '(' : ')';\n\t\t\tpos = str[pos] == ')' ? query1(1) : query2(1);\n\t\t\t//printf (\"%d %s\\n\", pos, str + 1);\n\t\t\tupdate(1, pos, str[pos] == '(' ? -2 : 2);\n\t\t\tstr[pos] = str[pos] == ')' ? '(' : ')';\n\t\t\tprintf (\"%d\\n\", pos);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct {\n\tint val;\n\tint add;\n} Node;\n\nNode seg[1 << 20];\nint n, q;\nchar s[300001];\n\ninline void evaluate(int idx)\n{\n\tseg[idx].val += seg[idx].add;\n\tif (idx < (1 << 19) - 1){\n\t\tseg[idx * 2 + 1].add += seg[idx].add;\n\t\tseg[idx * 2 + 2].add += seg[idx].add;\n\t}\n\t\n\tseg[idx].add = 0;\n}\n\nvoid update(int k)\n{\n\tseg[k].val = min(seg[k * 2 + 1].val, seg[k * 2 + 2].val);\n}\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n\tevaluate(k);\n\tif (r <= a || b <= l) return;\n\t\n\tif (a <= l && r <= b){\n\t\tseg[k].add += x;\n\t\tevaluate(k);\n\t\treturn;\n\t}\n\t\n\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\tupdate(k);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = n)\n{\n\tevaluate(k);\n\tif (r <= a || b <= l) return (INT_MAX);\n\t\n\tif (a <= l && r <= b){\n\t\tevaluate(k);\n\t\treturn (seg[k].val);\n\t}\n\t\n\tint left = getMin(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint right = getMin(a, b, k * 2 + 2, (l + r) / 2, r);\n\tupdate(k);\n\t\n\treturn (min(left, right));\n\t\n}\n\nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    int p;\n    \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        if (getMin(p, n) >= 2 * base) r = mid;\n        else l = mid + 1;\n    }\n    \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n    \n    printf(\"%d\\n\", p + 1);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000], dat[1048576], size_; string s;\ninline void update(int i, int x) {\n\ti += size_; dat[i] = x;\n\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\tint lc = query(a, b, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < n; i++) update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - query(0, r, 1, 0, size_) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (l = r - 1; l >= 0 && sum < 2; l--) {\n\t\t\t\tsum -= d[l];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 2);\n\t\t\td[r] = 1; update(r, 0);\n\t\t\td[l] = -1; update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = query(0, pm + 1, 1, 0, size_);\n\t\t\t\tif (query(0, pm + 1, 1, 0, size_)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; update(r, 1);\n\t\t\td[pr] = 1; update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define lc(x) ((x)*2)\n#define rc(x) ((x)*2+1)\nusing std::min;\n\nconst int INF = 10000000;\nconst int MAXN = 300000+10;\n\nint N, Q;\nchar S[MAXN];\n//Tree\nint SIZE=1, Root=1;\nint tag[8*MAXN];\nint Min[8*MAXN]; //????¶´???\nbool HaveR[8*MAXN]; //????????¬???\n\nint change(int no, int l, int r, int pos){\n    if(l==r){\n        HaveR[no] = 1-HaveR[no];\n        if(HaveR[no]) return 1;\n        else return 2;\n    }\n    int mid = (l+r)/2;\n    int tmp;\n    if(pos <= mid) tmp = change(lc(no), l, mid, pos);\n    if(mid < pos)  tmp = change(rc(no), mid+1, r, pos);\n    HaveR[no] = HaveR[lc(no)] + HaveR[rc(no)];\n    return tmp;\n}\n\nvoid maintain(int no){\n    if(tag[no] != 0){\n        Min[lc(no)] += tag[no];\n        Min[rc(no)] += tag[no];\n        tag[lc(no)] += tag[no];\n        tag[rc(no)] += tag[no];\n        tag[no] = 0;\n    }\n    if(no<SIZE) Min[no] = min(Min[lc(no)], Min[rc(no)]);\n    return;\n}\n\nvoid puttag(int no, int l, int r, int ql, int qr, int k){\n    if(r < ql || qr < l) return;\n    if(ql<=l && r<=qr){\n        Min[no] += k;\n        tag[no] += k;\n        return;\n    }\n    maintain(no);\n    int mid = (l+r)/2;\n    puttag(lc(no), l, mid, ql, qr, k);\n    puttag(rc(no), mid+1, r, ql, qr, k);\n    maintain(no);\n    return;\n}\n\nint find_r(int no, int l, int r){\n    if(l==r) return l;\n    int mid = (l+r)/2;\n    if(HaveR[lc(no)])\n        return find_r(lc(no), l, mid);\n    return find_r(rc(no), mid+1, r);\n}\nint find_min(int no, int l, int r){\n    if(l==r) return l;\n    maintain(no);\n    int mid = (l+r)/2;\n    if(Min[rc(no)] < 0)\n        return find_min(rc(no), mid+1, r);\n    return find_min(lc(no), l, mid);\n}\n\nvoid build_tree(){\n    SIZE=1;\n    while(SIZE < N) SIZE*=2; //1-Root\n    int sum=0;\n    for(int i=N ; i<=SIZE; i++){\n        Min[SIZE+i] = INF;\n    }\n    for(int i=N-1 ; i>=0 ; i--){ //size,size+1..?????????\n        if(S[i] == ')'){\n            HaveR[SIZE+i] = true;\n            sum++;\n        }\n        else{\n            HaveR[SIZE+i] = false;\n            sum--;\n        }\n        Min[SIZE+i] = sum;\n    }\n    for(int i=SIZE-1;i>=1;i--){\n        HaveR[i] = HaveR[lc(i)] + HaveR[rc(i)];\n        Min[i] = min( Min[lc(i)], Min[rc(i)] );\n    }\n}\n\nint main(){\n    scanf(\"%d %d\", &N, &Q);\n    scanf(\"%s\", S);\n    build_tree();\n    while(Q--){\n        int pos;\n        scanf(\"%d\", &pos);\n        int x = change(Root, 1, SIZE, pos);\n        if(x==1){ // '(' --> ')'\n            puttag(Root, 1, SIZE, 1, pos, 2);\n            pos = find_r(Root, 1, SIZE);\n            change(Root, 1, SIZE, pos);\n            puttag(Root, 1, SIZE, 1, pos, -2);\n        }else{ // ')' --> '('\n            puttag(Root, 1, SIZE, 1, pos, -2);\n            pos = find_min(Root, 1, SIZE);\n            change(Root, 1, SIZE, pos);\n            puttag(Root, 1, SIZE, 1, pos, 2);\n        }\n        printf(\"%d\\n\", pos);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate <typename T>\nclass StarrySkyTree {\n\tconst int n;\n\tvector<T> data, lazy;\n\tvoid add_sub(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) { lazy[node] += val; return; }\n\t\tint left = node * 2, right = left + 1;\n\t\tadd_sub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tadd_sub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata[node] = min(data[left] + lazy[left], data[right] + lazy[right]);\n\t}\n\tT min_sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return INF;\n\t\tif (l <= lb && ub <= r) return data[node] + lazy[node];\n\t\tT vl = min_sub(l, r, node * 2 + 0, lb, (lb + ub) / 2);\n\t\tT vr = min_sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t\treturn lazy[node] + min(vl, vr);\n\t}\n\tint size(int n) {\n\t\treturn n == 1 ? n : size((n + 1) / 2) * 2;\n\t}\npublic:\n\tStarrySkyTree(int m) : n(size(m)), data(n * 2, 0), lazy(n * 2, 0) {}\n\tvoid add(int l, int r, T val) { add_sub(l, r, 1, 0, n, val); }\n\tT minimum(int l, int r) { return min_sub(l, r, 1, 0, n); }\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s; cin >> s;\n\tStarrySkyTree<int> seg(N+1);\n\tvi sum(N + 1);\n\tREP(i, N)\n\t{\n\t\tsum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n\t\tseg.add(i + 1, i + 2, sum[i + 1]);\n\t}\n\tset<int> st;\n\tREP(i, N)\n\t{\n\t\tif (s[i] == ')') st.insert(i);\n\t}\n\twhile (Q--)\n\t{\n\t\tint t; cin >> t;\n\t\tt--;\n\t\tif (s[t] == '(')\n\t\t{\n\t\t\ts[t] = ')';\n\t\t\tst.insert(t);\n\t\t\tseg.add(t, N + 1, -2);\n\t\t\tint flip = *st.begin();\n\t\t\ts[flip] = '(';\n\t\t\tseg.add(flip, N + 1, 2);\n\t\t\tst.erase(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t\telse if(s[t] == ')')\n\t\t{\n\t\t\ts[t] = '(';\n\t\t\tst.erase(t);\n\t\t\tseg.add(t, N + 1, 2);\n\t\t\tint l = 0, r = t;\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tif (seg.minimum((l + r) / 2, r) == 0)\n\t\t\t\t{\n\t\t\t\t\tl = (l + r) / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tr = (l + r) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint flip = r + 1;\n\t\t\ts[flip] = ')';\n\t\t\tseg.add(flip, N + 1, -2);\n\t\t\tst.insert(flip);\n\t\t\tcout << flip << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCアジア地区予選2014 G. Flipping Parentheses\n\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 1<<19;\nint segMin[2*N-1];\nint segAdd[2*N-1];\nint segSum[2*N-1];\n\nvoid add(int l, int r, int val, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return;\n\tif(l <= rangeL && rangeR <= r){\n\t\tsegAdd[idx] += val;\n\t\twhile(idx){\n\t\t\tidx = (idx-1)/2;\n\t\t\tsegMin[idx] = min(segMin[2*idx+1]+segAdd[2*idx+1], segMin[2*idx+2]+segAdd[2*idx+2]);\n\t\t}\n\t} else {\n\t\tint rangeM = (rangeL+rangeR)/2;\n\t\tadd(l, r, val, 2*idx+1, rangeL, rangeM);\n\t\tadd(l, r, val, 2*idx+2, rangeM, rangeR);\n\t}\n}\n\nint getMin(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 1000000007;\n\tif(l <= rangeL && rangeR <= r) return segMin[idx]+segAdd[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn min(getMin(l, r, 2*idx+1, rangeL, rangeM), getMin(l, r, 2*idx+2, rangeM, rangeR)) + segAdd[idx];\n}\n\nvoid change(int pos, int val){\n\tint idx = pos+N-1;\n\tint add = val-segSum[idx];\n\tsegSum[idx] = val;\n\twhile(idx){\n\t\tidx = (idx-1)/2;\n\t\tsegSum[idx] += add;\n\t}\n}\n\nint getSum(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 0;\n\tif(l <= rangeL && rangeR <= r) return segSum[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn getSum(l, r, 2*idx+1, rangeL, rangeM)+getSum(l, r, 2*idx+2, rangeM, rangeR);\n}\n\nint main(){\n\tint n, q; cin >> n >> q;\n\t{\n\t\tmemset(segMin, 0, sizeof(segMin));\n\t\tmemset(segAdd, 0, sizeof(segAdd));\n\t\tmemset(segSum, 0, sizeof(segSum));\n\t\tstring str; cin >> str;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tadd(i, n, 1);\n\t\t\t} else {\n\t\t\t\tadd(i, n, -1);\n\t\t\t\tchange(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint idx; cin >> idx; --idx;\n\t\t\tif(idx == 0 || idx == n-1){\n\t\t\t\tcout << idx+1 << endl;\n\t\t\t} else if(str[idx] == '('){\n\t\t\t\tchange(idx, 1);\n\t\t\t\tadd(0, idx, 2);\n\t\t\t\tstr[idx] = ')';\n\t\t\t\tint L = 0, R = n-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getSum(0, mid) > 0) R = mid;\n\t\t\t\t\telse                   L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 0);\n\t\t\t\tadd(0, L, -2);\n\t\t\t\tstr[L] = '(';\n\t\t\t\tcout << L+1 << endl;\n\t\t\t} else {\n\t\t\t\tchange(idx, 0);\n\t\t\t\tadd(0, idx, -2);\n\t\t\t\tstr[idx] = '(';\n\t\t\t\tint L = 0, R = idx+1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getMin(mid, idx+1) > 0) R = mid;\n\t\t\t\t\telse                     L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 1);\n\t\t\t\tadd(0, L, 2);\n\t\t\t\tstr[L] = ')';\n\t\t\t\tcout << L+1 << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCアジア地区予選2014 G. Flipping Parentheses\n\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 1<<19;\nint segMin[2*N-1];\nint segAdd[2*N-1];\nint segSum[2*N-1];\n\nvoid add(int l, int r, int val, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return;\n\tif(l <= rangeL && rangeR <= r){\n\t\tsegAdd[idx] += val;\n\t\twhile(idx){\n\t\t\tidx = (idx-1)/2;\n\t\t\tsegMin[idx] = min(segMin[2*idx+1]+segAdd[2*idx+1], segMin[2*idx+2]+segAdd[2*idx+2]);\n\t\t}\n\t} else {\n\t\tint rangeM = (rangeL+rangeR)/2;\n\t\tadd(l, r, val, 2*idx+1, rangeL, rangeM);\n\t\tadd(l, r, val, 2*idx+2, rangeM, rangeR);\n\t}\n}\n\nint getMin(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 1000000007;\n\tif(l <= rangeL && rangeR <= r) return segMin[idx]+segAdd[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn min(getMin(l, r, 2*idx+1, rangeL, rangeM), getMin(l, r, 2*idx+2, rangeM, rangeR)) + segAdd[idx];\n}\n\nvoid change(int pos, int val){\n\tint idx = pos+N-1;\n\tint add = val-segSum[idx];\n\tsegSum[idx] = val;\n\twhile(idx){\n\t\tidx = (idx-1)/2;\n\t\tsegSum[idx] += add;\n\t}\n}\n\nint getSum(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 0;\n\tif(l <= rangeL && rangeR <= r) return segSum[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn getSum(l, r, 2*idx+1, rangeL, rangeM)+getSum(l, r, 2*idx+2, rangeM, rangeR);\n}\n\n//  ( ( ( ) ) )\n//  1 2 3 2 1 0\n//  ( ( ( ) ) )\n//   1 2 3 2 1 0\n\n// ( ( ) )\n// ( ( ( )\n\nint main(){\n\tint n, q;\n\twhile(cin >> n >> q){\n\t\tmemset(segMin, 0, sizeof(segMin));\n\t\tmemset(segAdd, 0, sizeof(segAdd));\n\t\tmemset(segSum, 0, sizeof(segSum));\n\t\tstring str; cin >> str;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tadd(i, n, 1);\n\t\t\t} else {\n\t\t\t\tadd(i, n, -1);\n\t\t\t\tchange(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint idx; cin >> idx; --idx;\n\t\t\tif(idx == 0 || idx == n-1){\n\t\t\t\tcout << idx+1 << endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(str[idx] == '('){\n\t\t\t\tchange(idx, 1);\n\t\t\t\tadd(0, idx, 2);\n\t\t\t\tstr[idx] = ')';\n\t\t\t\tint L = 0, R = n-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getSum(0, mid) > 0) R = mid;\n\t\t\t\t\telse                   L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 0);\n\t\t\t\tadd(0, L, -2);\n\t\t\t\tstr[L] = '(';\n\t\t\t\tcout << L+1 << endl;\n\t\t\t} else {\n\t\t\t\tchange(idx, 0);\n\t\t\t\tadd(0, idx, -2);\n\t\t\t\tstr[idx] = '(';\n\t\t\t\tint L = 0, R = idx+1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getMin(mid, idx+1) > 0) R = mid;\n\t\t\t\t\telse                     L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 1);\n\t\t\t\tadd(0, L, 2);\n\t\t\t\tstr[L] = ')';\n\t\t\t\tcout << L+1 << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate<typename Type> class StarrySkyTree {\npublic:\n\tunsigned size_; std::vector<Type> dat1, dat2, dat;\n\tinline void update_(unsigned a, unsigned b, Type x, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat2[k] += x; return;\n\t\t}\n\t\tupdate_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tupdate_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\tdat1[k] = std::min(dat1[k << 1] + dat2[k << 1], dat1[(k << 1) + 1] + dat2[(k << 1) + 1]);\n\t}\n\tinline Type query_(unsigned a, unsigned b, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return std::numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat1[k] + dat2[k];\n\t\tType lc = query_(a, b, (k << 1), l, (l + r) >> 1);\n\t\tType rc = query_(a, b, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn std::min(lc, rc) + dat2[k];\n\t}\n\t//StarrySkyTree() : size_(0), dat(std::vector<Type>()) {};\n\tStarrySkyTree(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat1.resize(size_ << 1, 0);\n\t\tdat2.resize(size_ << 1, 0);\n\t\tdat.resize(size_ << 1, 0);\n\t}\n\ttemplate<class T>\n\tStarrySkyTree(T begin_, T end_) {\n\t\tunsigned n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::numeric_limits<Type>::max());\n\t\tfor (unsigned i = 0; i < n; i++) dat[i + size_] = *(begin_ + i);\n\t\tfor (unsigned i = size_ - 1; i > 0; i--) dat[i] = std::min(dat[i << 1], dat[(i << 1) + 1]);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void add(unsigned i, Type x) {\n\t\tupdate_(i, i + 1, x, 1, 0, size_);\n\t}\n\tinline void add(unsigned l, unsigned r, Type x) {\n\t\tupdate_(l, r, x, 1, 0, size_);\n\t}\n\tinline Type query(unsigned l, unsigned r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\n\nstring S; int N, Q, P;\nStarrySkyTree<int> X(1);\n\nint solve(int pos) {\n\tint I1 = X.query(pos, pos + 1); // pos の depth\n\tint I2 = X.query(pos + 1, pos + 2); // pos + 1 の depth\n\n\tif (I1 > I2) {\n\t\t// もともと ')' だった : ')' -> '('\n\t\tX.add(pos + 1, N + 1, 2);\n\t\tint L = 0, R = N, M, minx = N + 1;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tint B = X.query(M, N);\n\t\t\tif (B >= 2) { minx = min(minx, M); R = M; }\n\t\t\telse { L = M; }\n\t\t}\n\t\tX.add(minx, N + 1, -2);\n\t\treturn minx - 1;\n\t}\n\telse {\n\t\t// もともと '(' だった : '(' -> ')'\n\t\tX.add(pos + 1, N + 1, -2);\n\t\tint L = 0, R = N + 1, M, minx = N + 1;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tint B = X.query(M, M + 1);\n\t\t\tif (M != B) { minx = min(minx, M); R = M; }\n\t\t\telse { L = M; }\n\t\t}\n\t\tX.add(minx, N + 1, 2);\n\t\treturn minx - 1;\n\t}\n}\n\nint main() {\n\tcin >> N >> Q >> S;\n\tX = StarrySkyTree<int>(N + 1);\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(') X.add(i + 1, N + 1, 1);\n\t\tif (S[i] == ')') X.add(i + 1, N + 1, -1);\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcin >> P; P--;\n\t\tcout << solve(P) + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll *min_data,*max_data,*add_data;\nchar buf[300001];\nint N = 1;\n\nvoid init(ll first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid add(int left,int right,ll value,int node_id,int node_left,int node_right){\n\n\tif(right < node_left || left > node_right){\n\t\treturn;\n\t}\n\telse if(left <= node_left && right >= node_right){\n\n\t\tadd_data[node_id] += value;\n\n\t\twhile(node_id != 0){\n\n\t\t\tnode_id = (node_id-1)/2;a[2*node_id+2]+add_data[2*node_id+2]);\n\t\t\tmax_data[node_id] = max(max_data[2*node_id+1]+add_data[2*node_id+1],max_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t}\n\t}else{\n\n\t\tadd(left,right,value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tadd(left,right,value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nll getMin(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn min_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_min  = getMin(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_min = getMin(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn min(left_min,right_min)+add_data[node_id];\n\t}\n}\n\n\nint main(){\n\n\tint first_N,Q;\n\tscanf(\"%d %d\",&first_N,&Q);\n\n\tinit(first_N);\n\n\tmin_data = new ll[2*N-1];\n\tmax_data = new ll[2*N-1];\n\tadd_data = new ll[2*N-1];\n\n\tfor(ll i = 0; i <= 2*N-2; i++){\n\t\tmin_data[i] = 0;\n\t\tmax_data[i] = 0;\n\t\tadd_data[i] = 0;\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tset<int> CLOSE;\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tif(buf[i] == '('){\n\t\t\tadd(i,N-1,1,0,0,N-1);\n\t\t}else{\n\t\t\tCLOSE.insert(i);\n\t\t\tadd(i,N-1,-1,0,0,N-1);\n\t\t}\n\t}\n\n\tint loc,calc_loc;\n\tint left,right,m;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&loc);\n\t\tloc--;\n\n\t\tif(buf[loc] == '('){\n\n\t\t\tbuf[loc] = ')';\n\t\t\tadd(loc,N-1,-2,0,0,N-1);\n\t\t\tCLOSE.insert(loc);\n\n\t\t\tcalc_loc = *begin(CLOSE);\n\t\t\tCLOSE.erase(begin(CLOSE));\n\n\t\t\tadd(calc_loc,N-1,2,0,0,N-1);\n\t\t\tbuf[calc_loc] = '(';\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\n\t\t}else{ //buf[loc] == ')'\n\n\t\t\tCLOSE.erase(loc);\n\t\t\tbuf[loc] = '(';\n\t\t\tadd(loc,N-1,2,0,0,N-1);\n\n\t\t\tleft = 0,right = first_N-1, m = (left+right)/2;\n\n\t\t\twhile(left <= right){\n\t\t\t\tif(getMin(m,N-1,0,0,N-1) >= 2){\n\t\t\t\t\tcalc_loc = m;\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\twhile(buf[calc_loc] != '(')calc_loc++;\n\n\t\t\tbuf[calc_loc] = ')';\n\t\t\tadd(calc_loc,N-1,-2,0,0,N-1);\n\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\t\t\tCLOSE.insert(calc_loc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef int Type;\n  int segn2;\n  vector<Type> data,s_data;\n  \n  StarrySkyTree(int n){\n    for(segn2=1;segn2<n;segn2*=2);\n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get minimum value of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    if(r<a || b<l) return INF;\n    if(a<=l && r<=b) return data[k] + s_data[k];\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2+1,r,k*2+2))+s_data[k];\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = min(add(a,b,x,l,(l+r)/2,k*2+1),add(a,b,x,(l+r)/2+1,r,k*2+2));\n    }\n    return data[k] + s_data[k];\n  }\n  \n};\n\n\n\nint main(){\n  int n,q;\n  char s[SIZE];\n  int sum[SIZE];\n  priority_queue<int> right;\n  scanf(\"%d%d%s\",&n,&q,s);\n\n  StarrySkyTree seg(n);\n  \n  for(int i=0;i<n;i++){\n    if(s[i] == '('){\n      sum[i] = 1;\n    }else{\n      sum[i] = -1;\n      right.push(-i);\n    }\n\n    if(i > 0){\n      sum[i] += sum[i-1];\n    }\n\n    seg.add(i,i,sum[i]);\n  }\n  \n  for(int i=0;i<q;i++){\n    int p, ans;\n    scanf(\"%d\",&p);\n    p--;\n    \n    if(s[p] == '('){\n      s[p] = ')';\n      right.push(-p);\n      seg.add(p,n-1,-2);\n\n      while(right.size() && s[-right.top()] == '(') right.pop();\n\n      ans = -right.top();\n      s[ans] = '(';\n      seg.add(ans,n-1,2);\n      \n    }else{\n      s[p] = '(';\n      seg.add(p,n-1,2);\n\n      int l=0, r=p;\n\n      while(l<r){\n        int mid = (l+r)/2;\n        if(seg.query(mid,n-1) >= 2){\n          r = mid;\n        }else{\n          l = mid+1;\n        }\n      }\n\n      ans = l;\n      s[ans] = ')';\n      right.push(-ans);\n      seg.add(ans,n-1,-2);\n    }\n\n    printf(\"%d\\n\",ans+1);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nclass RangeAddRangeMinTree {\npublic:\n\tvector<ll> node;\n\tvector<ll> add;\n\tll sz;\n\tRangeAddRangeMinTree(vector<ll> v) {\n\t\tsz = 1;\n\t\twhile(sz < v.size())sz *= 2;\n\t\tnode = vector<ll>(2*sz,LLINF);\n\t\tadd = vector<ll>(2*sz,0);\n\t\tfor(int i = 0;i < v.size();i++){\n\t\t\tnode[sz + i - 1] = v[i];\n\t\t}\n\t\tfor(int i = node.size() - 1;i > 0;i--){\n\t\t\tnode[(i - 1) / 2] = min(node[(i - 1) / 2],node[i]);\n\t\t}\n\t}\n\n\tvoid rangeAdd(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1)r = sz;\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b){\n\t\t\tadd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\trangeAdd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\t\trangeAdd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\n\t\tnode[k] = min(node[k * 2 + 1] + add[k * 2 + 1], node[k * 2 + 2] + add[k * 2 + 2]);\n\t}\n\n\tll getMin(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif(r == -1)r = sz;\n\t\tif (r <= a || b <= l) return (LLINF);\n\t\tif (a <= l && r <= b) return (node[k] + add[k]);\n\n\t\tll left = getMin(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tll right = getMin(a, b, k * 2 + 2, (l + r) / 2, r);\n\n\t\treturn (min(left, right) + add[k]);\n\t}\n};\n\nint main(){\n\n\tint n,q;cin >> n >> q;\n\tstring str;cin >> str;\n\tset<int> s;\n\tvector<ll> v(str.size());\n\tint now = 0;\n\tfor(int i = str.size()-1;i >= 0;i--){\n\t\tif(str[i] == '('){\n\t\t\tnow--;\n\t\t}\n\t\telse{\n\t\t\tnow++;\n\t\t\ts.insert(i);\n\t\t}\n\t\tv[i] = now;\n\t}\n\tRangeAddRangeMinTree seg(v);\n\n\tREP(seica,q){\n\t\tint t;cin >> t;t--;\n\t\tif(str[t] == '(') {\n\t\t\tstr[t] = ')';\n\t\t\tseg.rangeAdd(0,t+1,2);\n\t\t\ts.insert(t);\n\t\t\tint ans = *s.begin();\n\t\t\tstr[ans] = '(';\n\t\t\tseg.rangeAdd(0,ans+1,-2);\n\t\t\tcout << ans + 1 << endl;\n\t\t\ts.erase(s.begin());\n\t\t}\n\t\telse{\n\t\t\tstr[t] = '(';\n\t\t\tauto it = s.lower_bound(t);\n\t\t\ts.erase(it);\n\t\t\tseg.rangeAdd(0,t+1,-2);\n\t\t\tint l = 0;\n\t\t\tint r = n;\n\t\t\twhile(r - l > 1){\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tif(seg.getMin(mid, n+1) < 0) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tcout << l + 1 << endl;\n\t\t\tseg.rangeAdd(0,l+1,2);\n\t\t\tstr[l] = ')';\n\t\t\ts.insert(l);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 550;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] <= 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] <= 2) {\n              return k * sqrtN + j;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] <= 2) {\n          return i;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n  void show() {\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define MAX 300010\n// #define DEBUG\n\nint N, Q;\nchar str[MAX];\nint nextopen;\nint nextclose;\nint openlimit;\nint closelimit;\nbool hasnextopen;\nbool hasnextclose;\n\nvoid findopenlimit() {\n\n\tif (str[1] == '(' && str[2] == '(') {\n\t\topenlimit = 2;\n\t} else {\n\t\topenlimit = 3;\n\t}\n}\n\nvoid findcloselimit() {\n\n\tif (str[N] == ')' && str[N-1] == ')') {\n\t\tcloselimit = N-1;\n\t} else {\n\t\tcloselimit = N-2;\n\t}\n}\n\n\nvoid findnextopen() {\n\tfor (int i = nextopen; i < N; i++) {\n\t\tif (str[i] == '(' && str[i+1] == '(') {\n\t\t\tnextopen = i;\n\t\t\treturn;\n\t\t}\n\t}\n\thasnextopen = false;\n}\n\nvoid findnextclose() {\n\tfor (int i = nextclose; i < N; i++) {\n\t\tif (str[i] == '(' && str[i+1] == ')') {\n\t\t\tnextclose = i+1;\n\t\t\treturn;\n\t\t}\n\t}\n\thasnextclose = false;\n}\n\nint main() {\n\n\twhile (scanf(\"%d%d\\n\", &N, &Q) == 2) {\n\t\tnextopen = 2;\n\t\tnextclose = 1;\n\t\thasnextopen = true;\n\t\thasnextclose = true;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tscanf(\"%c\", &str[i]);\n\t\t}\n\n\t\tfindopenlimit();\n\t\tfindcloselimit();\n\t\tif (N == 4) {\n\t\t\topenlimit = 1;\n\t\t\tcloselimit = 4;\n\t\t}\n\t\tfindnextopen();\n\t\tfindnextclose();\n#ifdef DEBUG\n\t\tprintf(\"openlimit %d\\n\", openlimit);\n\t\tprintf(\"closelimit %d\\n\", closelimit);\n\t\tprintf(\"nextopen %d\\n\", nextopen);\n\t\tprintf(\"nextclose %d\\n\", nextclose);\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tprintf(\"%c\", str[j]);\n\t\t\t}\n\t\tprintf(\"\\n\");\n#endif \n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint w;\n\t\t\tscanf(\"%d\", &w);\n#ifdef DEBUG\n\t\t\tprintf(\"Flipping %d\\n\", w);\n#endif \n\t\t\tif (w == 1 || w == N) {\n\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t} else {\n\t\t\t\tif (str[w] == '(') {\n\t\t\t\t\tif (hasnextclose && nextclose < w && w > openlimit) {\n\t\t\t\t\t\tprintf(\"%d\\n\", nextclose);\n\t\t\t\t\t\tstr[w] = ')';\n\t\t\t\t\t\tstr[nextclose] = '(';\n\t\t\t\t\t\tif (nextclose < openlimit) {\n\t\t\t\t\t\t\topenlimit = nextclose;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextclose < nextopen || !hasnextopen) {\n\t\t\t\t\t\t\tnextopen = nextclose;\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"nextopen = %d\\n\", nextopen);\n#endif \t\t\t\t\t\n\t\t\t\t\t\t\thasnextopen = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfindnextclose();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasnextopen && nextopen < w && w < closelimit) {\n\t\t\t\t\t\tprintf(\"%d\\n\", nextopen);\n\t\t\t\t\t\tstr[w] = '(';\n\t\t\t\t\t\tstr[nextopen] = ')';\n\t\t\t\t\t\tif (nextopen > closelimit) {\n\t\t\t\t\t\t\tcloselimit = nextopen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nextopen < nextclose || !hasnextclose) {\n\t\t\t\t\t\t\tnextclose = nextopen;\t\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"nextclose = %d\\n\", nextclose);\n#endif\n\t\t\t\t\t\t\thasnextclose = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfindnextopen();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"%d\\n\", w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef DEBUG\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tprintf(\"%c\", str[j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef int ll;\n\nstruct T {\n  ll v;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\nint n,m;\nchar s[333333];\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      root = add(root,l,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 300;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      //DEBUG(S);\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      //DEBUG(S);\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n    //DEBUG(S);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LIM 300010\n#define left st,(st+en)/2,n+n\n#define right (st+en)/2+1,en,n+n+1\n#define ll long long\n#define OUTSIDE en<l || st>r\n#define INSIDE st>=l && en<=r\n#define INF 1<<19\n\nstruct info\n{\n    int mn,lazy;\n    info() {}\n    info(int a,int b){mn = a;lazy = b;}\n};\n\ninfo tree[4*LIM+5];\nset<int>L,R;\nchar str[LIM+5];\nint n,sum[LIM+5];\n\nvoid relax(int n)\n{\n    tree[n+n].mn+=tree[n].lazy;\n    tree[n+n].lazy+=tree[n].lazy;\n    tree[n+n+1].mn+=tree[n].lazy;\n    tree[n+n+1].lazy+=tree[n].lazy;\n    tree[n].lazy = 0;\n}\n\nvoid build(int st,int en,int n)\n{\n    if(st==en){tree[n] = info(sum[st],0);return;}\n    build(left);\n    build(right);\n    tree[n].mn = min(tree[n+n].mn,tree[n+n+1].mn);\n}\n\nvoid update(int st,int en,int n,int l,int r,int x)\n{\n    if(INSIDE){tree[n].mn+=x;tree[n].lazy+=x;return;}\n    if(OUTSIDE)return;\n    relax(n);\n    update(left,l,r,x);\n    update(right,l,r,x);\n    tree[n].mn = min(tree[n+n].mn,tree[n+n+1].mn);\n}\n\nint query(int st,int en,int n,int l,int r)\n{\n    if(OUTSIDE)return INF;\n    if(INSIDE)return tree[n].mn;\n    relax(n);\n    return min(query(left,l,r),query(right,l,r));\n}\n\nvoid flip(int pos)\n{\n    if(str[pos]=='(')\n    {\n        str[pos]=')';\n        L.erase(pos);\n        R.insert(pos);\n        update(0,n-1,1,pos,n-1,-2);\n    }\n    else\n    {\n        str[pos]='(';\n        R.erase(pos);\n        L.insert(pos);\n        update(0,n-1,1,pos,n-1,2);\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int q,pos;\n    cin >> n >> q >> str;\n    for(int i=0; i<n; i++)\n    {\n        if(!i)sum[i] = (str[i]=='('?1:-1);\n        else sum[i]=sum[i-1]+(str[i]=='('?1:-1);\n        if(str[i]=='(') L.insert(i);\n        else R.insert(i);\n    }\n    build(0,n-1,1);\n    for(int i=0; i<q; i++)\n    {\n        cin >> pos;--pos;\n        if(str[pos]=='(')\n        {\n            flip(pos);\n            int ans = *(R.begin());\n            cout << ans+1 << \"\\n\";\n            flip(ans);\n        }\n        else\n        {\n            flip(pos);\n            int l,r,mid;\n            l = 0;\n            r = n;\n            while(l<r)\n            {\n                mid=(l+r)/2;\n                if(query(0,n-1,1,mid,pos)>=2)r = mid;\n                else l = mid+1;\n            }\n            int res = *(L.lower_bound(l));\n            flip(res);\n            cout << res+1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int INF = 1e9+9;\n\n// ????????????????????±\ntemplate <typename T, T INIT>\nstruct node {\n\tT v, lazy;\n\tnode(){\n\t\tv = INIT;\n\t\tlazy = 0;\n\t}\n\t// ????????????????????´??°\n\tvoid merge(T vl, T vr){\n\t\tv = min(vl, vr);\n\t}\n\t// ????????????????????´??°(lazy?????¨)\n\tT add(int l, int r, T _v=0){\n\t\tT sum = lazy + _v;\n\t\tv += sum;\n\t\tlazy = 0;\n\t\treturn sum;\n\t}\n\t// ?????¶???????????´(??????)\n\tvoid addLazy(T v){\n\t\tlazy += v;\n\t}\n};\n\ntemplate <typename T, typename NODE=node<T,INF> >\nclass SegTree{\n\t// ?????¶??????????????¨??????(?????¨??????????????????????¢?????????????Lazy????????¬?????????)\n\tvoid propLazy(int a, int b, int k, T v=0){\n\t\tT lazy = data[k].add(a, b, v);\n\t\tif( k < N ){\n\t\t\tdata[k*2+0].addLazy(lazy);\n\t\t\tdata[k*2+1].addLazy(lazy);\n\t\t}\n\t}\n\t// ?????°??????????????????????????????\n\tT prop(int l, int r, T v, int a, int b, int k=1){\n\t\t// ????????????????????????????¢?????????????\n\t\tpropLazy(a, b, k);\n\t\t// ?????????\n\t\tNODE nd;\t// ??????????????¨(??????????????´????????????????????????)\n\t\tif( l <= a && b <= r ){\n\t\t\t// ?????¨?????????????????´???\n\t\t\tpropLazy(a, b, k, v);\n\t\t\treturn data[k].v;\n\t\t}else if( l < b && a < r ){\n\t\t\t// ?????????????????????????????´???\n\t\t\tint m = (a+b) / 2;\n\t\t\tT vl = prop(l,r,v, a, m, k*2);\n\t\t\tT vr = prop(l,r,v, m, b, k*2+1);\n\t\t\tdata[k].merge( data[k*2].v, data[k*2+1].v );\n\t\t\tnd.merge( vl, vr );\n\t\t}\n\t\treturn nd.v;\n\t}\n\npublic:\n\tvector<NODE> data;\n\tint N;\n\tSegTree(int _N){\n\t\t// _N <= (N = 2^k) ????????????N???????????????\n\t\tN = 1;\n\t\twhile( N < _N ) N<<=1;\n\t\tdata.resize(N*2);\n\t}\n\t// ?????°???????????????????????´??°(??????????????´????????????v????????´)\n\tvoid update(int l, T v){\n\t\tprop(l, l+1, v-get(l), 0, N);\n\t}\n\t// ?????°???????????????????????´??°(???????????????)\n\tT add(int l, int r, T v){\n\t\treturn prop(l,r,v,0,N);\n\t}\n\t// ???????????? [l,r)\n\tT get(int l, int r){\n\t\treturn prop(l,r,0,0,N);\n\t}\n\t// ???????????? [l,l+1)\n\tT get(int l){\n\t\treturn prop(l,l+1,0,0,N);\n\t}\n};\n\n\n\n// ?¢????\n\n#include <algorithm>\n#include <set>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\ntypedef pair<int,int> pii;\n\n\n// AOJ DSL_2_A\n/*\nconst ll INF2 = ((ll)1<<31) - (ll)1;\nSegTree<ll,node<ll,INF2> > sg(100005);\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\trep(i,q){\n\t\tint c, x, y;\n\t\tcin >> c >> x >> y;\n\t\tif( c == 0 ){\n\t\t\tsg.update(x, y);\n\t\t}else{\n\t\t\ty++;\n\t\t\tcout << sg.get(x, y) << endl;\n\t\t}\n\t\t//rep(j,18) cout << sg.data[j].get() << \" \"; cout << endl;\n\t}\n\treturn 0;\n}\n*/\n\n\n// arc026_C\n/*\nSegTree<ll,node<ll,(ll)1e12> > sg(100005);\nint main(){\n\tint N, L;\n\tint l[100005], r[100005], c[100005];\n\tvector<pii> v;\n\n\tcin >> N >> L;\n\trep(i,N){\n\t\tcin >> l[i] >> r[i] >> c[i];\n\t\tv.emplace_back( r[i], i );\n\t}\n\tsort( all(v) );\n\n\tsg.update(0,0);\n\tfor(auto p: v){\n\t\tint i = p.second;\n\t\tll tmp = min( sg.get(r[i]), sg.get(l[i], r[i]) + (ll)c[i] );\n\t\tsg.update( r[i], tmp );\n\t}\n\n\tcout << sg.get(L) << endl;\n\n\treturn 0;\n}\n*/\n\n\n// ????????§?¢????\n/*\nSegTree<int,node<int,99> > sg(8);\nint main(){\n\tint q, x, y, v;\n\tsg.add(0,8,-99);\n\twhile(cin>>q>>x>>y){\n\t\tif( q == 0 ){\n\t\t\tcin >> v;\n\t\t\tsg.add(x,y,v);\n\t\t}else{\n\t\t\tcout << \"get : \" << sg.get(x,y) << endl;\n\t\t}\n\t\t// ?????°??????????????¶????????¨???\n\t\trep(i,sg.data.size()){\n\t\t\tif( __builtin_popcount(i) == 1 ) cout << endl;\n\t\t\tcout << sg.data[i].v << \"(\" << sg.data[i].lazy << \")\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n*/\n\n\n// ICPC 2014 Tokyo Regional G\nSegTree<int> sg(300005);\nint N, Q;\nstring s;\nint q[200005];\nset<int> op, cl;\nvoid flip(int i){\n\tif(s[i] == '('){\n\t\ts[i] = ')';\n\t\tcl.insert( i );\n\t\tif(op.find(i) != op.end() ) op.erase( op.find(i) );\n\t\tsg.add(i+1, N+2, -2);\n\t}else{\n\t\ts[i] = '(';\n\t\top.insert( i );\n\t\tif(cl.find(i) != cl.end() ) cl.erase( cl.find(i) );\n\t\tsg.add(i+1, N+2, 2);\n\t}\n}\nint main(){\n\tcin >> N >> Q >> s;\n\trep(i,Q){\n\t\tcin >> q[i];\n\t\tq[i]--;\n\t}\n\n\tint sum = 0;\n\trep(i,N+1){\n\t\tsg.update(i, sum);\n\t\tif( s[i] == ')' ){\n\t\t\tcl.insert(i);\n\t\t\tsum--;\n\t\t}else{\n\t\t\top.insert(i);\n\t\t\tsum++;\n\t\t}\n\t}\n\n\trep(i,Q){\n\t\tint ans;\n\t\tflip(q[i]);\n\t\tif( s[q[i]] == ')' ){\n\t\t\tans = *cl.begin();\n\t\t}else{\n\t\t\tint l=1, r=N+2;\n\t\t\twhile( r-l > 1 ){\n\t\t\t\tint m = (l+r) / 2;\n\t\t\t\tsg.add(m, N+2, -2);\n\t\t\t\tif( sg.get(m, N+2) >= 0 ){\n\t\t\t\t\tr = m;\n\t\t\t\t}else{\n\t\t\t\t\tl = m;\n\t\t\t\t}\n\t\t\t\tsg.add(m, N+2, 2);\n\t\t\t}\n\t\t\tans = *op.upper_bound( l-1 );\n\t\t}\n\t\tflip(ans);\n\t\tcout << (ans+1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 300005;\n\nint t[maxn << 2], lz[maxn << 2];\nchar s[maxn];\nint n, m;\nint S = 0;\nset<int> C;\n\nvoid build(int u, int b, int e) {\n\tif(b == e) {\n\t\tif(s[b] == '(') S++;\n\t\telse S--;\n\t\tt[u] = S;\n\t\treturn;\n\t}\n\tint mid = b + e >> 1;\n\tbuild(u << 1, b, mid);\n\tbuild(u << 1 | 1, mid + 1, e);\n\tt[u] = min(t[u << 1], t[u << 1 | 1]);\n}\n\nvoid push(int u, int b, int e) {\n\tt[u] += lz[u];\n\tif(b < e) {\n\t\tlz[u << 1] += lz[u];\n\t\tlz[u << 1 | 1] += lz[u];\n\t}\n\tlz[u] = 0;\n}\n\nvoid update(int u, int b, int e, int l, int r, int val) {\n\tif(b > r or e < l) return;\n\tif(l <= b and e <= r) {\n\t\tlz[u] += val;\n\t\tpush(u, b, e);\n\t\treturn;\n\t}\n\tif(lz[u]) push(u, b, e);\n\tint mid = b + e >> 1;\n\tupdate(u << 1, b, mid, l, r, val);\n\tupdate(u << 1 | 1, mid + 1, e, l, r, val);\n\tt[u] = min(t[u << 1], t[u << 1 | 1]);\n}\n\nint query(int u, int b, int e, int l, int r) {\n\tif(b > r or e < l) return INT_MAX;\n\tif(lz[u]) push(u, b, e);\n\tif(l <= b and e <= r) return t[u];\n\tint mid = b + e >> 1;\n\treturn min(query(u << 1, b, mid, l, r), query(u << 1 | 1, mid + 1, e, l, r));\n}\n\nint main(int argc, char const *argv[])\n{\n\t// freopen(\"in\", \"r\", stdin);\n\tscanf(\"%d %d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(s[i] == ')') {\n\t\t\tC.insert(i);\n\t\t}\n\t}\n\tbuild(1, 1, n);\n\twhile(m--) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\t\tif(s[p] == ')') {\n\t\t\tC.erase(p);\n\t\t\ts[p] = '(';\n\t\t\tupdate(1, 1, n, p, n, 2);\n\t\t\tint lo = 1, hi = p, mid, opt;\n\t\t\twhile(lo <= hi) {\n\t\t\t\tmid = lo + hi >> 1;\n\t\t\t\tif(query(1, 1, n, mid, n) >= 2) {\n\t\t\t\t\topt = mid;\n\t\t\t\t\thi = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts[opt] = ')';\n\t\t\tupdate(1, 1, n, opt, n, -2);\n\t\t\tC.insert(opt);\n\t\t\tprintf(\"%d\\n\", opt);\n\t\t} else {\n\t\t\tC.insert(p);\n\t\t\ts[p] = ')';\n\t\t\tupdate(1, 1, n, p, n, -2);\n\t\t\tint opt = *C.begin();\n\t\t\ts[opt] = '(';\n\t\t\tupdate(1, 1, n, opt, n, 2);\n\t\t\tC.erase(opt);\n\t\t\tprintf(\"%d\\n\", opt);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 550;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray1 {\n  const int B;\n  SegmentArray1(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = en - 1; i >= st; --i) {\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray1 seg1(N);\n  set<int> seg2;\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.insert(i);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.insert(p);\n      seg1.update(p, N, -2);\n      int np = *seg2.begin();\n      S[np] = '(';\n      seg2.erase(np);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      S[p] = '(';\n      seg2.erase(p);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      S[np] = ')';\n      seg2.insert(np);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define lch (id<<1)\n#define rch ((id<<1)|1)\nconst int maxn=300000+100;\nconst int INF=1e9+10;\nchar kuo[maxn];\nint sum[maxn];\nint minv[maxn<<2],maxv[maxn<<2],lazy[maxn<<2];\nvoid build(int id,int l,int r)\n{\n\tlazy[id]=0;\n\tif(l==r)\n\t\tminv[id]=maxv[id]=sum[l];\n\telse\n\t{\n\t\tint mid=l+r>>1;\n\t\tbuild(lch,l,mid);\n\t\tbuild(rch,mid+1,r);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nvoid pushdown(int id)\n{\n\tminv[lch]+=lazy[id];maxv[lch]+=lazy[id];lazy[lch]+=lazy[id];\n\tminv[rch]+=lazy[id];maxv[rch]+=lazy[id];lazy[rch]+=lazy[id];\n\tlazy[id]=0;\n}\nvoid update(int id,int l,int r,int L,int R,int v)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tminv[id]+=v;\n\t\tmaxv[id]+=v;\n\t\tlazy[id]+=v;\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid)update(lch,l,mid,L,R,v);\n\t\tif(R>mid)update(rch,mid+1,r,L,R,v);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_minv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tif(minv[l]==0)return l;\n\t\telse return -1;\n\t}\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(l==r)\n\t\t{\n\t\t\tif(minv[l]==0)return l;\n\t\t\telse return -1;\n\t\t}\n\t\telse if(minv[rch]==0)return query_minv(rch,mid+1,r,L,R);\n\t\telse return query_minv(lch,l,mid,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(R<=mid)return query_minv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_minv(rch,mid+1,r,L,R);\n\t\telse\n\t\t{\n\t\t\treturn max(query_minv(lch,l,mid,L,R),query_minv(rch,mid+1,r,L,R));\n\t\t}\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_maxv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tif(maxv[id]==2)return l;\n\t\telse return INF;\n\t}\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(l==r)\n\t\t{\n\t\t\tif(maxv[id]==2)return l;\n\t\t\telse return INF;\n\t\t}\n\t\telse if(maxv[lch]>=2&&minv[lch]<=2)return query_maxv(lch,l,mid,L,R);\n\t\telse return query_maxv(rch,mid+1,r,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(R<=mid)return query_maxv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_maxv(rch,mid+1,r,L,R);\n\t\telse \n\t\t{\n\t\t\treturn min(query_maxv(lch,l,mid,L,R),query_maxv(rch,mid+1,r,L,R));\n\t\t}\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query(int id,int l,int r,int pos)\n{\n\tif(l==r)return minv[id];\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(pos<=mid)return query(lch,l,mid,pos);\n\t\telse return query(rch,mid+1,r,pos);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nset<int> qn;\nint main()\n{\n\tint i,pos,n,q,l,r;\n\tscanf(\"%d %d\",&n,&q);\n\tscanf(\"%s\",kuo+1);\n\tmemset(sum,0,sizeof(sum));\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(kuo[i]=='(')sum[i]=sum[i-1]+1;\n\t\telse \n\t\t{\n\t\t\tsum[i]=sum[i-1]-1;\n\t\t\tqn.insert(i);\n\t\t}\n\t}\n\tbuild(1,0,n);\n\t//for(int j=0;j<=n;j++)cout <<sum[j]<<\" \";cout <<endl;\n\t//for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\tfor(i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&pos);\n\t\tif(kuo[pos]=='(')\t\t\n\t\t{\n\t\t\tkuo[pos]=')';\n\t\t\tupdate(1,0,n,pos,n,-2);\n\t\t\tqn.insert(pos);\n\t\t\tpos=*qn.lower_bound(0);\n\t\t\tqn.erase(pos);\n\t\t\tkuo[pos]='(';\n\t\t\tupdate(1,0,n,pos,n,2);\n\t\t\tprintf(\"%d\\n\",pos);\n\t\t}\n\t\telse if(kuo[pos]==')')\n\t\t{\n\t\t\tif(query(1,0,n,pos)==0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkuo[pos]='(';\n\t\t\t\tqn.erase(pos);\n\t\t\t\tupdate(1,0,n,pos,n,2);\t\n\t\t\t\tl=query_minv(1,0,n,0,pos);\n\t\t\t\tr=query_maxv(1,0,n,l+1,pos);\n\t\t\t\tupdate(1,0,n,r,n,-2);\n\t\t\t\tqn.insert(r);\n\t\t\t\t//cout <<kuo[r]<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\t\tkuo[r]=')';\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%s\\n\",kuo+1);for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat, dat2, lazy;\n\npublic:\n  SegmentTree() {\n  }\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = dat2 = lazy = vector<int>(n*2-1, 0);\n  }\n\n  inline void evaluation(int k, int l, int r) {\n    dat[k] += (r - l) * lazy[k];\n    dat2[k] += lazy[k];\n    if (k < n-1) {\n      lazy[k*2+1] += lazy[k];\n      lazy[k*2+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      evaluation(k, l, r);\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += dat[k*2+1] + dat[k*2+2];\n    dat2[k] = min(dat2[k*2+1], dat2[k*2+2]);\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n    string prev;\n    while (Q--) {\n      prev = s;\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        vector<int> pos;\n        for (int i = 0; i < s.size(); ++i) {\n          if (s[i] == '(') pos.push_back(i);\n        }\n        int l = 0, r = pos.size();\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(pos[m], N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << pos[r] + 1 << endl;\n        change(pos[r]);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <string>\nusing namespace std;\n\nconst int kMax = 1048600;\nconst int kInf = 1000000000;\n\nstring S;\nint N, Q;\nint Qk[150010];\n\nset< int > L, R;\nint Tm[kMax], Td[kMax];\n\nvoid read();\nvoid solve();\n\nvoid update(int, int, int, int, int, int);\nint query(int, int, int, int, int);\n\nint main() {\n  read();\n  solve();\n  return 0;\n}\n\nvoid read() {\n  ios::sync_with_stdio(false);\n\n  cin >> N >> Q >> S, S = \"#\" + S;\n  for (int i = 0; i < Q; ++i)\n    cin >> Qk[i];\n}\n\nvoid solve() {\n  fill(&Tm[0], &Tm[kMax], 0);\n\n  for (int i = 1, s = 0; i <= N; ++i) {\n    if (S[i] == '(')\n      ++s, L.insert(i);\n    else\n      --s, R.insert(i);\n    update(1, 0, N, i - 1, i, s);\n  }\n\n  for (int qi = 0; qi < Q; ++qi) {\n    int p = Qk[qi], t;\n\n    if (S[p] == '(') {\n      // flip query\n      S[p] = ')';\n      update(1, 0, N, p - 1, N, -2);\n      L.erase(p), R.insert(p);\n\n      // find answer\n      t = *R.begin();\n      cout << t << \"\\n\";\n\n      // flip answer\n      S[t] = '(';\n      update(1, 0, N, t - 1, N, 2);\n      R.erase(t), L.insert(t);\n    }\n    else {\n      // flip query\n      S[p] = '(';\n      update(1, 0, N, p - 1, N, 2);\n      R.erase(p), L.insert(p);\n\n      // find answer\n      int low = 1, up = N, mid;\n      while (low < up) {\n        mid = (low + up) / 2;\n        if (query(1, 0, N, mid - 1, N) >= 2)\n          up = mid;\n        else\n          low = mid + 1;\n      }\n      t = *L.lower_bound(up);\n      cout << t << \"\\n\";\n\n      // flip answer\n      S[t] = ')';\n      update(1, 0, N, t - 1, N, -2);\n      L.erase(t), R.insert(t);\n    }\n  }\n}\n\nvoid update(int u, int l, int r, int ql, int qr, int qd) {\n  if (ql <= l && r <= qr)\n    Tm[u] += qd, Td[u] += qd;\n  else {\n    int mid = (l + r) / 2;\n\n    if (Td[u] != 0) {\n      update(2 * u,     l, mid, l, mid, Td[u]);\n      update(2 * u + 1, mid, r, mid, r, Td[u]);\n      Td[u] = 0;\n    }\n\n    if (ql < mid) update(2 * u,     l, mid, ql, qr < mid ? qr : mid, qd);\n    if (qr > mid) update(2 * u + 1, mid, r, ql > mid ? ql : mid, qr, qd);\n\n    Tm[u] = min(Tm[2 * u], Tm[2 * u + 1]);\n  }\n}\n\nint query(int u, int l, int r, int ql, int qr) {\n  if (ql <= l && r <= qr)\n    return Tm[u];\n  else {\n    int mid = (l + r) / 2;\n\n    if (Td[u] != 0) {\n      update(2 * u,     l, mid, l, mid, Td[u]);\n      update(2 * u + 1, mid, r, mid, r, Td[u]);\n      Td[u] = 0;\n    }\n\n    int ret = kInf;\n\n    if (ql < mid) ret = min(ret, query(2 * u,     l, mid, ql, qr < mid ? qr : mid));\n    if (qr > mid) ret = min(ret, query(2 * u + 1, mid, r, ql > mid ? ql : mid, qr));\n\n    return ret;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<map>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(int i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(int i=a;i<=j;i++)\n#define rev_rep(i,j) for(int i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\treturn  data[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n    assert(false);\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\nvoid debug_show(string str,Segment_Tree *ST,int n)\n{\n\n  cout<<str<<endl;\n  cout<<\"Sum \";\n  rep(j,n)\n    cout<<ST->get_min(j,j+1)<<\" \";\n  cout<<endl;\n  cout<<\"Min \" ;\n  rep(j,n)\n    cout<<ST->get_min(j,n)<<\" \";\n  cout<<endl;\n}\n\nint  main()\n{\n  int n,q;cin>>n>>q;\n\n  //入力\n  string str;cin>>str;\n\n  Segment_Tree ST(n);\n  \n  rep(i,(int)str.size())\n    {\n      if(str[i]=='('){\n\tST.add(i,n,1);\n      }\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  /* \n\t  int p=-1;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{p=str.find('(',p+1);}\n\t    while(ST.get_min(p,n)<2);\n\t  \n\t  */\n\t  //cout<<\"bf \"<<flip+1<<\"changed\"<<endl;\n\t  //debug_show(str,&ST,n);\n\t  \n\t  int p=0,e=n;\n\t  if(flip==n-1)p=flip;\n\t  else{\n\t    while(e>p+1){\n\t      if(ST.get_min((p+e)/2,n)<2)p=(p+e)/2;\n\t      else e=(p+e)/2;\n\t    }\n\t    p=str.find('(',p+1);\n\t  }\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t  //puts(\"af\");\n\t  //debug_show(str,&ST,n);\n\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (q == 0 || sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n\n        sum_seg.add(q + 1, N + 1, 2);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n      \n        cout << pos_pos + 1 << endl;\n      \n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n          \n          close_parens.erase(q);\n          close_parens.insert(pos_pos);\n          \n          pos_seg.add(q, q + 1, -1);\n          pos_seg.add(pos_pos, pos_pos + 1, 1);\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\ntemplate <class T>\nclass Lazy_Segment_Tree{\n\tprivate:\n\tint n;\n\tvector<T> date,lazy;\n\tvoid Set_Lazy(int k,T x){\n\t\tdate[k]+=x;\n\t\tlazy[k]+=x;\n\t}\n\tvoid Push(int k){\n\t\tSet_Lazy(k*2+1,lazy[k]);\n\t\tSet_Lazy(k*2+2,lazy[k]);\n\t\tlazy[k]=0;\n\t}\n\tvoid Fix(int k){\n\t\tdate[k]=min(date[k*2+1],date[k*2+2]);\n\t}\n\tvoid Add_func(int a,int b,int k,int l,int r,T x){\n\t\tif(r<=a||b<=l) return;\n\t\tif(a<=l&&r<=b){\n\t\t\tSet_Lazy(k,x);\n\t\t\treturn;\n\t\t}\n\t\tPush(k);\n\t\tint m=(l+r)/2;\n\t\tAdd_func(a,b,k*2+1,l,m,x);\n\t\tAdd_func(a,b,k*2+2,m,r,x);\n\t\tFix(k);\n\t}\n\tvoid Update_func(int I,int k,int l,int r,T x){\n\t\tif(r<=I||I<l) return;\n\t\tif(l==I&&r-l==1){\n\t\t\tdate[k]=x;\n\t\t\tlazy[k]=x;\n\t\t\treturn;\n\t\t}\n\t\tPush(k);\n\t\tint m=(l+r)/2;\n\t\tUpdate_func(I,k*2+1,l,m,x);\n\t\tUpdate_func(I,k*2+2,m,r,x);\n\t\tFix(k);\n\t}\n\tT Query_func(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l) return inf;\n\t\tif(a<=l&&r<=b) return date[k];\n\t\tPush(k);\n\t\tint m=(l+r)/2;\n\t\tT vl=Query_func(a,b,k*2+1,l,m);\n\t\tT vr=Query_func(a,b,k*2+2,m,r);\n\t\treturn min(vl,vr);\n\t}\n\tpublic:\n\tLazy_Segment_Tree(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdate=lazy=vector<T>(2*n-1,inf);\n\t}\n\tvoid Add(int a,int b,T x){\n\t\tAdd_func(a,b,0,0,n,x);\n\t}\n\tvoid Update(int k,T x){\n\t\tUpdate_func(k,0,0,n,x);\n\t}\n\tT Query(int a,int b){\n\t\treturn Query_func(a,b,0,0,n);\n\t}\n\tT Open(int k){\n\t\tk+=n-1;\n\t\tT res=date[k];\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tres+=lazy[k];\n\t\t}\n\t\treturn res;\n\t}\n\tvoid Full_Open(){\n\t\tfor(int i=0;i<2*n-1;i++) cout<<date[i]<<' ';\n\t\tcout<<endl;\n\t\tfor(int i=0;i<2*n-1;i++) cout<<lazy[i]<<' ';\n\t\tcout<<endl;\n\t}\n};\n\nint n,q;\nstring s;\n\nint main(){\n\tcin>>n>>q>>s;\n\tLazy_Segment_Tree<int> lst(n);\n\tint x=0;\n\tset<int> s1,s2;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='('){\n\t\t\tx++;\n\t\t\ts1.insert(i);\n\t\t}\n\t\telse{\n\t\t\tx--;\n\t\t\ts2.insert(i);\n\t\t}\n\t\tlst.Update(i,x);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tt--;\n\t\tif(s[t]=='('){\n\t\t\ts[t]=')';\n\t\t\ts1.erase(t);\n\t\t\ts2.insert(t);\n\t\t\tauto it=s2.begin();\n\t\t\ts1.insert(*it);\n\t\t\ts2.erase(it);\n\t\t\tlst.Add(*it,t,2);\n\t\t\ts[*it]='(';\n\t\t\tcout<<*it+1<<endl;\n\t\t}\n\t\telse{\n\t\t\ts[t]='(';\n\t\t\ts2.erase(t);\n\t\t\ts1.insert(t);\n\t\t\tint l=-1,r=t;\n\t\t\twhile(r-l>1){\n\t\t\t\tint m=(l+r)/2;\n\t\t\t\tif(lst.Query(m,t)>=2) r=m;\n\t\t\t\telse l=m;\n\t\t\t}\n\t\t\tauto it=s1.lower_bound(r);\n\t\t\ts2.insert(*it);\n\t\t\ts1.erase(it);\n\t\t\tlst.Add(*it,t,-2);\n\t\t\ts[*it]=')';\n\t\t\tcout<<*it+1<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\nstatic const int MAX_SIZE = 1 << 20; //segment tree のサイズ。この実装では2べきにする必要がある。 2^17 ≒ 1.3 * 10^5\n\ntypedef long long Int;\nint segMin[2 * MAX_SIZE - 1], segAdd[2 * MAX_SIZE - 1];\n\n//区間[a, b)に値xを加算する.\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n\tif (r <= a || b <= l) return; //もし交差しない区間であれば終える.\n\t\n\tif (a <= l && r <= b){ //もし今みている区間[l, r)が[a, b)に完全に内包されていれば\n\t\tsegAdd[k] += x;  //区間[l, r)にkを加算する.\n\t\treturn;\n\t}\n\t\n\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2); //子の区間に(必要があれば)xを加算する.\n\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r); //〃\n\n\t//親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である.一様に加算される値は更新しなくて良い.\n\tsegMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = MAX_SIZE)\n{\n\tif (r <= a || b <= l) return (INT_MAX);\n\t\n\tif (a <= l && r <= b) return (segMin[k] + segAdd[k]); //完全に内包されていれば,その区間の最小値を返す.\n\t\n\tint left = getMin(a, b, k * 2 + 1, l, (l + r) / 2); //子の区間の最小値を求める.\n\tint right = getMin(a, b, k * 2 + 2, (l + r) / 2, r); //子の区間の最小値を求める\n\t\n\treturn (min(left, right) + segAdd[k]); //親の区間の最小値は, 子の区間の最小値 + 自分に一様に加算されている値 である (大切なので2回書きました!!)\n\t\n}\n\n\nint main(){\n    int n,q;cin >> n >> q;\n    string s;cin >> s;\n    set<int> sb;\n    int sum=0;\n    for(int i=0;i<s.length();i++){\n        if(s[i]=='('){\n            sum++;\n        }\n        else{\n            sum--;\n            sb.insert(i);\n        }\n        add(i,i+1,sum);\n    }\n    for(int i=0;i<q;i++){\n        int t;cin >> t;\n        t--;\n        if(s[t]=='('){\n            add(t,n,-2);\n            sb.insert(t);\n            auto p=sb.begin();\n            s[t]=')';\n            s[*p]='(';\n            sb.erase(*p);\n            add(*p,n,2);\n            cout << *p+1 << endl;\n        }\n        else{\n            add(t,n,2);\n            sb.erase(t);\n            s[t]='(';\n            int l=0,r=t;\n            while(abs(r-l)>1){\n                int m=(l+r)/2;\n                if(getMin(m,n)>=2) r=m;\n                else l=m;\n            }\n            s[r]=')';\n            add(r,n,-2);\n            sb.insert(r);\n            cout << r+1 << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000], dat[1048576], size_; string s;\ninline void update(int i, int x) {\n\ti += size_; dat[i] = x;\n\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\tint lc = query(a, b, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < n; i++) update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - query(0, r, 1, 0, size_) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (l = r - 1; l >= 0; l--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl++; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[l];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; update(r, 0);\n\t\t\td[l] = -1; update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = query(0, pm + 1, 1, 0, size_);\n\t\t\t\tif (query(0, pm + 1, 1, 0, size_)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; update(r, 1);\n\t\t\td[pr] = 1; update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef long long ll;\n\nstruct T {\n  ll v;\n  ll s;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),s(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->s += t->lazy*count(t);\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll sum(T* t){ push(t); return t?t->s:0; }\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->s = t->v+sum(t->l)+sum(t->r);\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* erase(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> v = split(t,k);\n  k -= (k-1);\n  pair<T*,T*> u = split(v.second,k);\n  return merge(v.first,u.second);\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\ninline T* add(T* t,int k)\n{\n  push(t);\n  t->lz |= true;\n  t->lazy += k;\n  return update(t);\n}\n\nint n,m;\nchar s[333333];\ninline T* flip(T* t,int k)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  pair<T*,T*> b=split(a.second,1);\n  //b.first->v = -b.first->v;\n  //b.first = add(b.first,k,n);\n  return merge(a.first,merge(b.first,b.second));\n}\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\ninline int gsum(T* t)\n{\n  /*\n  if( !t->r ) return t->v;\n  return gsum(t->r);\n  */\n  return 0;\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q,m;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  //print(root); puts(\"\");\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    //printf(\"%d %d\\n\",mini(t),gsum(t));\n    //print(t); puts(\"\");\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        //printf(\"%d %d\\n\",l,r);\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      //printf(\":%d %d\\n\",l,r);\n      root = add(root,l,n,-2);\n    }\n    //puts(s);\n    //printf(\"%d\\n\",kakko);\n    //print(root); puts(\"\");\n    /*\n      printf(\"sum:%d min:%d\\n\",gsum(t),mini(t));\n    //*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntemplate<typename T> class LazyRMQ {\n    public:\n    int n;\n    T inf = INT_MAX;\n    vector<T> data, lazy;\n\n    LazyRMQ(int m, T init_value=INT_MAX){\n        // 2のべき乗にする\n        n = 1;\n        while(n < m) n <<= 1;\n        data.assign(2*n-1, init_value);\n        lazy.assign(2*n-1, 0);\n    }\n\n    void eval(int k, int kl, int kr){\n        if(data[k] == inf) data[k] = 0;\n        if(lazy[k] == 0) return;\n        data[k] += lazy[k];\n        if(kr - kl > 1){\n            lazy[2*k+1] += lazy[k];\n            lazy[2*k+2] += lazy[k];\n        }\n        lazy[k] = 0;\n    }\n\n    // [s,t)\n    void add(int s, int t, int k, int kl, int kr, T x){\n        eval(k, kl, kr);\n        if(kr <= s || t <= kl) return;\n        if(s <= kl && kr <= t){\n            lazy[k] += x;\n            eval(k, kl, kr);\n            return;\n        }\n        int kc = (kl+kr)/2;\n        add(s, t, 2*k+1, kl, kc, x);\n        add(s, t, 2*k+2, kc, kr, x);\n        data[k] = min(data[2*k+1], data[2*k+2]);\n    }\n\n    // [s,t)\n    T find(int s, int t, int k, int kl, int kr){\n        eval(k, kl, kr);\n        if(kr <= s || t <= kl) return inf;\n        if(s <= kl && kr <= t) return data[k];\n        int kc = (kl+kr)/2;\n        T vl = find(s, t, 2*k+1, kl, kc);\n        T vr = find(s, t, 2*k+2, kc, kr);\n        return min(vl, vr);\n    }\n};\n\nint main(){\n    int n,Q,q;\n    scanf(\"%d %d\", &n, &Q);\n    LazyRMQ<int> rmq(n+1);\n\n    char s[n+1];\n    scanf(\"%s\", s);\n    set<int> close;\n    int data[n+1];\n    data[0] = 0;\n    for(int i=0;i<n;i++){\n        if(s[i]=='('){\n            data[i+1] = data[i]+1;\n        }else{\n            data[i+1] = data[i]-1;\n            close.insert(i+1);\n        }\n        rmq.add(i+1, i+2, 0, 0, rmq.n, data[i+1]);\n    }\n\n    for(int i=0;i<Q;i++){\n        scanf(\"%d\", &q);\n        // 今回の変更により，閉じかっこが開いたか？\n        bool open_parentheses = (s[q-1] == ')');\n        int j;\n        if(open_parentheses){\n            rmq.add(q, rmq.n, 0, 0, rmq.n, 2);\n            s[q-1] = '(';\n            close.erase(q);\n            // どこかの開きかっこを閉じる\n            // 「以降全て2以上」のところはひっくり返せる\n            j = (n+1)/2;\n            int ng = 0, ok = n;\n            while(ok-ng > 1){\n                j = (ng+ok)/2;\n                if(rmq.find(j, rmq.n, 0, 0, rmq.n) >= 2){\n                    ok = j;\n                }else{\n                    ng = j;\n                }\n            }\n            j = ok;\n            rmq.add(j, rmq.n, 0, 0, rmq.n, -2);\n            s[j-1] = ')';\n            close.insert(j);\n        }else{\n            rmq.add(q, rmq.n, 0, 0, rmq.n, -2);\n            s[q-1] = ')';\n            close.insert(q);\n            // どこかの閉じかっこを開く\n            // 先頭の閉じかっこをひっくり返せば良い\n            j = *close.begin();\n            rmq.add(j, rmq.n, 0, 0, rmq.n, 2);\n            s[j-1] = '(';\n            close.erase(j);\n        }\n        printf(\"%d\\n\", j);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<19;\n\tint dp[1<<20];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\tvoid update(int k,int v){\n\t\tk+=N-1;\n\t\tdp[k]=v;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t\t}\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\treturn min(vl,vr);\n\t}\n};\n\nclass rsegtree{\npublic:\n\tstatic const int N=1<<19;\n\tint dp[1<<20];\n\tint lazy[1<<20];\n\trsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\n\tvoid lazy_eval(int k){\n\t\tdp[k]+=lazy[k];\n\t\tif(k<N-1){\n\t\t\tlazy[k*2+1]+=lazy[k];\n\t\t\tlazy[k*2+2]+=lazy[k];\n\t\t}\n\t\tlazy[k]=0;\n\t}\n\tvoid lazy_upd(int k){\n\t\tdp[k]=min(dp[k*2+1],dp[k*2+2]);\n\t}\n\n\tvoid update(int a,int b,int v,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return;\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]+=v;\n\t\t\tlazy_eval(k);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tupdate(a,b,v,k*2+1,l,mid);\n\t\tupdate(a,b,v,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t}\n\n\tint query(int a,int b,int k=0,int l=0,int r=N){\n\t\tlazy_eval(k);\n\t\tif(b<=l || r<=a)return INF;\n\t\tif(a<=l && r<=b)return dp[k];\n\t\tint mid=(l+r)/2;\n\t\tint vl=query(a,b,k*2+1,l,mid);\n\t\tint vr=query(a,b,k*2+2,mid,r);\n\t\tlazy_upd(k);\n\t\treturn min(vl,vr);\n\t}\n};\n\nsegtree seg;\nrsegtree rseg;\nint n,q;\nstring str;\nint type[300005];\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tcin >> str;\n\tfor(int i=0;i<n;i++){\n\t\tif(str[i]=='('){\n\t\t\ttype[i]=1;\n\t\t\tseg.update(i,INF);\n\t\t\trseg.update(i+1,n+1,1);\n\t\t}else{\n\t\t\ttype[i]=-1;\n\t\t\tseg.update(i,i);\n\t\t\trseg.update(i+1,n+1,-1);\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\ttype[a]=-type[a];\n\t\tif(type[a]==-1){\n\t\t\tseg.update(a,a);\n\t\t\trseg.update(a+1,n+1,-2);\n\t\t\tint v=seg.query(0,n);\n\t\t\tprintf(\"%d\\n\",v+1);\n\t\t\tseg.update(v,INF);\n\t\t\trseg.update(v+1,n+1,2);\n\t\t\ttype[v]=-type[v];\n\t\t}else{\n\t\t\tseg.update(a,INF);\n\t\t\trseg.update(a+1,n+1,2);\n\t\t\tint l=0,r=a+1;\n\t\t\twhile(l+1<r){\n\t\t\t\tint mid=(l+r)/2;\n\t\t\t\trseg.update(mid,n+1,-2);\n\t\t\t\tif(rseg.query(mid,n+1)>=0)r=mid;\n\t\t\t\telse l=mid;\n\t\t\t\trseg.update(mid,n+1,2);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",r);\n\t\t\tseg.update(r-1,r-1);\n\t\t\trseg.update(r,n+1,-2);\n\t\t\ttype[r-1]=-type[r-1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int maxn = 500000;\nstruct node {\n    int lt,rt,theFirst,theMin,lazy,dir;\n} tree[maxn<<2];\nint sum,n,m;\nchar str[maxn];\nvoid build(int lt,int rt,int v) {\n    tree[v].lt = lt;\n    tree[v].rt = rt;\n    tree[v].lazy = 0;\n    if(lt == rt) {\n        tree[v].dir = str[lt] == '('?1:-1;\n        sum += tree[v].dir;\n        tree[v].theMin = sum;\n        tree[v].theFirst = tree[v].dir == 1?INF:lt;\n        return;\n    }\n    int mid = (lt + rt)>>1;\n    build(lt,mid,v<<1);\n    build(mid+1,rt,v<<1|1);\n    tree[v].theFirst = min(tree[v<<1].theFirst,tree[v<<1|1].theFirst);\n    tree[v].theMin = min(tree[v<<1].theMin,tree[v<<1|1].theMin);\n}\nint update(int p,int v) {\n    if(tree[v].lt >= p && tree[v].rt <= p) {\n        int tmp = tree[v].dir;\n        tree[v].dir *= -1;\n        tree[v].theFirst = tmp == 1?p:INF;\n        return tmp;\n    }\n    int mid = (tree[v].lt + tree[v].rt)>>1,ret;\n    if(p <= mid) ret = update(p,v<<1);\n    if(p > mid) ret = update(p,v<<1|1);\n    tree[v].theFirst = min(tree[v<<1].theFirst,tree[v<<1|1].theFirst);\n    return ret;\n}\nvoid pushdown(int v) {\n    if(tree[v].lazy) {\n        tree[v<<1].lazy += tree[v].lazy;\n        tree[v<<1|1].lazy += tree[v].lazy;\n        tree[v].lazy = 0;\n    }\n}\nvoid pushup(int v) {\n    tree[v].theMin = min(tree[v<<1].theMin+tree[v<<1].lazy,tree[v<<1|1].theMin+tree[v<<1|1].lazy);\n}\nvoid update(int lt,int rt,int v,int value) {\n    if(tree[v].lt >= lt && tree[v].rt <= rt) {\n        tree[v].lazy += value;\n        return;\n    }\n    pushdown(v);\n    int mid = (tree[v].lt + tree[v].rt)>>1;\n    if(lt <= mid) update(lt,rt,v<<1,value);\n    if(rt > mid) update(lt,rt,v<<1|1,value);\n    pushup(v);\n    //cout<<\"__\"<<tree[v].lt<<\" \"<<tree[v].rt<<\" \"<<tree[v].theMin<<endl;\n}\nint query(int v,int o) {\n    if(tree[v].theMin+tree[v].lazy >= 2) return tree[v].lt;\n    if(tree[v].lt == tree[v].rt) return o;\n    pushdown(v);\n    int ret;\n    if(tree[v<<1|1].theMin+tree[v<<1|1].lazy >= 2)\n        ret = query(v<<1,tree[v<<1|1].lt);\n    else ret = query(v<<1|1,tree[v<<1|1].rt);\n    pushup(v);\n    return ret;\n}\nint main() {\n    int p;\n    while(~scanf(\"%d %d\",&n,&m)) {\n        scanf(\"%s\",str+1);\n        sum = 0;\n        build(1,n,1);\n        while(m--) {\n            scanf(\"%d\",&p);\n            int tmp = update(p,1);\n            if(tmp == 1) {\n                update(p,n,1,-2);\n                printf(\"%d\\n\",p = tree[1].theFirst);\n                tmp = update(p,1);\n                update(p,n,1,2);\n            } else if(tmp == -1) {\n                update(p,n,1,2);\n                printf(\"%d\\n\",p = query(1,n));\n                tmp = update(p,1);\n                update(p,n,1,-1);\n            }\n        }\n    }\n    return 0;\n}\n/*\n6 3\n((()))\n4\n3\n1\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 450;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray1 {\n  const int B;\n  SegmentArray1(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = en - 1; i >= st; --i) {\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nbool data2[((MAX_N + sqrtN - 1) / sqrtN) * sqrtN];\nbool stat2[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray2 {\n  const int B;\n  SegmentArray2(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int p, bool v) {\n    data2[p] = v;\n    int k = p / sqrtN;\n    stat2[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat2[k] = stat2[k] || data2[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat2[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data2[k]) return k;\n        }\n      }\n    }\n  }\n  bool get(int p) {\n    return data2[p];\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(seg2.get(p) == false) {\n      // S[p] = ')';\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      // S[p] = '(';\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      // S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nstruct SegmentTree\n{\n  const int INF = 1 << 30;\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n};\n\nint main()\n{\n  int N, Q;\n\n  scanf(\"%d %d\", &N, &Q);\n  char S[100001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      close.erase(close.begin());\n    } else {\n      close.erase(q);\n      S[q] = '(';\n      int low = -1, high = N - 1;\n      while(high - low > 1) {\n        int mid = (low + high) >> 1;\n        if(tree.RangeMinimumQuery(mid, N) >= 2) high = mid;\n        else low = mid;\n      }\n      while(S[q] == ')') ++high;\n      printf(\"%d\\n\", high + 1);\n      tree.RangeAdd(high, N, -2);\n      S[high] = ')';\n      close.insert(high);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; int i; bool used; };\n \nint MOD = 1000000007;\n\nstruct bit {\n\tvector<ll> v;\n\tbit(int n) : v(n + 1) {}\n\tll sum(int i) {\n\t\tll res = 0;\n\t\tfor (; i > 0; i -= i & -i) res += v[i];\n\t\treturn res;\n\t}\n\tvoid add(int i, ll x) {\n\t\tfor (i++; i < v.size(); i += i & -i) v[i] += x;\n\t}\n\tint lower_bound(ll x) {\n\t\tif (x <= 0) return 0;\n\t\tint res = 0;\n\t\tfor (int i = 1 << 24; i > 0; i >>= 1)\n\t\t\tif (res + i < v.size() && v[res + i] < x) {\n\t\t\t\tres += i; x -= v[res];\n\t\t\t}\n\t\treturn res + 1;\n\t}\n};\n\nint N, Q;\nstring s;\n\nvoid flip(int i, bit& a, bit& b, bit& c) {\n\tif (s[i] == '(') {\n\t\ts[i] = ')';\n\t\ta.add(i, -2);\n\t\tb.add(i, 1);\n\t\tif (i - 2 >= 0 && s[i - 2] == '(' && s[i - 1] == '(') c.add(i - 2, -1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(' && i + 1 < N && s[i + 1] == '(') c.add(i - 1, -1);\n\t\tif (i + 2 < N && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, -1);\n\t}\n\telse {\n\t\ts[i] = '(';\n\t\ta.add(i, 2);\n\t\tb.add(i, -1);\n\t\tif (i - 2 >= 0 && s[i - 2] == '(' && s[i - 1] == '(') c.add(i - 2, 1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(' && i + 1 < N && s[i + 1] == '(') c.add(i - 1, 1);\n\t\tif (i + 2 < N && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, 1);\n\t}\n}\n\nbool check(string& s) {\n\tint n = s.length();\n\tint lev = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '(') lev++;\n\t\telse lev--;\n\t\tif (lev < 0) return false;\n\t}\n\tif (lev != 0) return false;\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> Q >> s;\n\tbit a(N), b(N), c(N);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == '(') a.add(i, 1);\n\t\telse a.add(i, -1);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == ')') b.add(i, 1);\n\tfor (int i = 0; i < N - 2; i++)\n\t\tif (s[i] == '(' && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, 1);\n\twhile (Q--) {\n\t\tint i; cin >> i; i--;\n\t\tstring t = s;\n\t\tstring _s = s;\n\t\tif (_s[i] == '(') _s[i] = ')';\n\t\telse _s[i] = '(';\n\t\tint ans2;\n\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\tif (_s[j] == '(') _s[j] = ')';\n\t\t\telse _s[j] = '(';\n\t\t\tif (check(_s)) {\n\t\t\t\tans2 = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_s[j] == '(') _s[j] = ')';\n\t\t\telse _s[j] = '(';\n\t\t}\n\t\tint ans;\n\t\tif (s[i] == '(') {\n\t\t\tflip(i, a, b, c);\n\t\t\tint j = b.lower_bound(1) - 1;\n\t\t\tflip(j, a, b, c);\n\t\t\tcout << j + 1 << endl;\n\t\t\tans = j;\n\t\t}\n\t\telse {\n\t\t\tif (a.sum(i + 1) == 0) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tans = i;\n\t\t\t}\n\t\t\telse if (a.sum(i) == 2) {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tcout << i << endl;\n\t\t\t\tflip(i - 1, a, b, c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tint j = c.lower_bound(1) - 1;\n\t\t\t\tflip(j + 1, a, b, c);\n\t\t\t\tcout << j + 2 << endl;\n\t\t\t\tans = j + 1;\n\t\t\t}\n\t\t}\n\t\tif (ans != ans2) {\n\t\t\tcout << t << endl;\n\t\t\tcout << ans <<  ' ' << ans2 << endl;\n\t\t\tcout << \"error\" << endl;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nint fix(set<int> &a, set<int> &b, char before, int x)\n{\n    a.erase(x);\n    b.insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    int p;\n    \n    while (l != r){\n        int mid = (l + r) / 2;\n        p = *b.lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        bool cond1 = (p ? abs(getMin(p - 1, p) - getMin(p, p + 1)) == 1 : getMin(0, 1) == 1);\n        bool cond2 = (p != n - 1 ? abs(getMin(p, p + 1) - getMin(p + 1, p + 2)) == 1 : getMin(0, n - 1) == 0);\n        \n        if (segMin[0] + segAdd[0] >= 0 && cond1 && cond2) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    p = *b.lower_bound(l);\n    add(p, n, -2 * base);\n    b.erase(p);\n    a.insert(p);\n    s[p] = before;\n    \n    return (p);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '('){\n            printf(\"%d\\n\", fix(lf, rg, '(', x) + 1);\n        }\n        else {\n            printf(\"%d\\n\", fix(rg, lf, ')', x) + 1);\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nconst int p2=1<<19;\nint N,Q;\nstring s;\nint segm[p2*2],sega[p2*2],inf=1e8;\nset<int> st;\nvoid add(int a,int b,int l,int r,int k,int x){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tsega[k]+=x;\n\t\treturn;\n\t}\n\tadd(a,b,l,(l+r)/2,k*2+1,x);\n\tadd(a,b,(l+r)/2,r,k*2+2,x);\n}\nvoid change(int x){\n\tif(s[x]=='('){\n\t\ts[x]=')';\n\t\tst.insert(x);\n\t\tadd(x,p2,0,p2,0,-2);\n\t}else{\n\t\ts[x]='(';\n\t\tst.erase(x);\n\t\tadd(x,p2,0,p2,0,2);\n\t}\n}\nint getmin(int a,int b,int l,int r,int k){\n\tif(b<=l||r<=a) return inf;\n\tif(a<=l&&r<=b) return segm[k]+sega[k];\n\treturn min(getmin(a,b,l,(l+r)/2,k*2+1),getmin(a,b,(l+r)/2,r,2*k+2))+sega[k];\n}\nint main(){\n\tcin>>N>>Q;\n\tcin>>s;\n\trep(i,N) if(s[i]==')') st.insert(i);\n\trep(i,N) segm[p2-1+i]=segm[p2-2+i]+(s[i]=='('?1:-1);\n\tfor(int i=p2-2;i>=0;i--){\n\t\tsegm[i]=min(segm[i*2+1],segm[i*2+2]);\n\t}\n\trep(i,Q){\n\t\tint q;\n\t\tcin>>q;\n\t\tq--;\n\t\tif(s[q]=='('){\n\t\t\tchange(q);\n\t\t\tint a=*st.begin();\n\t\t\tcout<<a+1<<endl;\n\t\t\tchange(a);\n\t\t}else{\n\t\t\tchange(q);\n\t\t\tint ub=q,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tif(getmin(m,q+1,0,p2,0)>=2) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tassert(s[ub]=='(');\n\t\t\tcout<<ub+1<<endl;\n\t\t\tchange(ub);\n\t\t}\n\t\t/*puts(\"segm\");\n\t\trep(j,p2*2-1) cout<<segm[j]<<\" \";\n\t\tcout<<endl;\n\t\tputs(\"sega\");\n\t\trep(j,p2*2-1) cout<<sega[j]<<\" \";\n\t\tcout<<endl;\n\t\tcout<<s<<endl;\n\t\t*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 700;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      //DEBUG(S);\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      //DEBUG(S);\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n    //DEBUG(S);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCアジア地区予選2014 G. Flipping Parentheses\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 1<<19;\nint segMin[2*N-1];\nint segAdd[2*N-1];\nint segSum[2*N-1];\n\nvoid add(int l, int r, int val, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return;\n\tif(l <= rangeL && rangeR <= r){\n\t\tsegAdd[idx] += val;\n\t\twhile(idx){\n\t\t\tidx = (idx-1)/2;\n\t\t\tsegMin[idx] = min(segMin[2*idx+1]+segAdd[2*idx+1], segMin[2*idx+2]+segAdd[2*idx+2]);\n\t\t}\n\t} else {\n\t\tint rangeM = (rangeL+rangeR)/2;\n\t\tadd(l, r, val, 2*idx+1, rangeL, rangeM);\n\t\tadd(l, r, val, 2*idx+2, rangeM, rangeR);\n\t}\n}\n\nint getMin(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 1000000007;\n\tif(l <= rangeL && rangeR <= r) return segMin[idx]+segAdd[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn min(getMin(l, r, 2*idx+1, rangeL, rangeM), getMin(l, r, 2*idx+2, rangeM, rangeR)) + segAdd[idx];\n}\n\nvoid change(int pos, int val){\n\tint idx = pos+N-1;\n\tint add = val-segSum[idx];\n\tsegSum[idx] = val;\n\twhile(idx){\n\t\tidx = (idx-1)/2;\n\t\tsegSum[idx] += add;\n\t}\n}\n\nint getSum(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 0;\n\tif(l <= rangeL && rangeR <= r) return segSum[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn getSum(l, r, 2*idx+1, rangeL, rangeM)+getSum(l, r, 2*idx+2, rangeM, rangeR);\n}\n\nint main(){\n\tint n, q;\n\tchar str[300001];\n\twhile(~scanf(\"%d %d\", &n, &q)){\n\t\tmemset(segMin, 0, sizeof(segMin));\n\t\tmemset(segAdd, 0, sizeof(segAdd));\n\t\tmemset(segSum, 0, sizeof(segSum));\n\t\tscanf(\"%s\", str);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tadd(i, n, 1);\n\t\t\t} else {\n\t\t\t\tadd(i, n, -1);\n\t\t\t\tchange(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint idx; scanf(\"%d\", &idx); --idx;\n\t\t\tif(idx == 0 || idx == n-1){\n\t\t\t\tprintf(\"%d\\n\", idx+1);\n\t\t\t} else if(str[idx] == '('){\n\t\t\t\tchange(idx, 1);\n\t\t\t\tadd(0, idx, 2);\n\t\t\t\tstr[idx] = ')';\n\t\t\t\tint L = 0, R = n-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getSum(0, mid) > 0) R = mid;\n\t\t\t\t\telse                   L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 0);\n\t\t\t\tadd(0, L, -2);\n\t\t\t\tstr[L] = '(';\n\t\t\t\tprintf(\"%d\\n\", L+1);\n\t\t\t} else {\n\t\t\t\tchange(idx, 0);\n\t\t\t\tadd(0, idx, -2);\n\t\t\t\tstr[idx] = '(';\n\t\t\t\tint L = 0, R = idx+1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getMin(mid, idx+1) >= 0) R = mid;\n\t\t\t\t\telse                        L = mid;\n\t\t\t\t}\n\t\t\t\tchange(R, 1);\n\t\t\t\tadd(0, R, 2);\n\t\t\t\tstr[R] = ')';\n\t\t\t\tprintf(\"%d\\n\", R+1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct StarrySkyTree{\n\tint seg;\n\tvector<int> segMin,segAdd;\n\tStarrySkyTree(int n) : seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tsegMin.resize(seg * 2 - 1);\n\t\tsegAdd.resize(seg * 2 - 1);\n\t}\n\tinline int getDat(int k){ return segMin[k] + segAdd[k]; }\n\tvoid add(int a,int b,int x,int k = 0,int l = 0,int r = -1){\n\t\tif(b == -1) b = seg;\n\t\tif(r == -1) r = seg;\n\t\tif(b <= l || r <= a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tadd(a,b,x,k * 2 + 1,l,(l + r) / 2);\n\t\tadd(a,b,x,k * 2 + 2,(l + r) / 2,r);\n\t\tsegMin[k] = min(getDat(k * 2 + 1),getDat(k * 2 + 2));\n\t}\n\tint find(int x){\n\t\tint k = 0,l = 0,r = seg,sum = 0;\n\t\twhile(r - l > 1){\n\t\t\tsum += segAdd[k];\n\t\t\tif(getDat(k * 2 + 2) + sum < x){\n\t\t\t\tk = k * 2 + 2;\n\t\t\t\tl = (l + r) / 2;\n\t\t\t}else{\n\t\t\t\tk = k * 2 + 1;\n\t\t\t\tr = (l + r) / 2;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n};\n\nstring s;\nset<int> rs;\n\nvoid flip(int x,StarrySkyTree &seg){\n\tif(s[x] == '('){\n\t\ts[x] = ')';\n\t\tseg.add(x + 1,-1,-2);\n\t\trs.insert(x);\n\t}else{\n\t\ts[x] = '(';\n\t\tseg.add(x + 1,-1,2);\n\t\trs.erase(x);\n\t}\n}\n\nsigned main(){\n\tint n,q;\n\tcin >> n >> q >> s;\n\tStarrySkyTree seg(n + 1);\n\tfor(int i = 0;i < n;i++){\n\t\tif(s[i] == '(') seg.add(i + 1,-1,1);\n\t\telse{\n\t\t\tseg.add(i + 1,-1,-1);\n\t\t\trs.insert(i);\n\t\t}\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tint x,ans;\n\t\tcin >> x; x--;\n\t\tflip(x,seg);\n\t\tif(s[x] == ')') ans = *rs.begin();\n\t\telse ans = seg.find(2);\n\t\tflip(ans,seg);\n\t\tcout << ans + 1 << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\nconst int MAX = 300005;\n\nint t[MAX] = {0};\n\nint sum(int n) {\n    int s = 0;\n    while(n > 0) {\n        s += t[n];\n        n -= n & -n;\n    }\n    return s;\n}\n\nvoid add(int n, int d) {\n    while(n <= MAX) {\n        t[n] += d;\n        n += n & -n;\n    }\n}\n\nint query(int a, int b) {\n    return sum(b) - sum(a - 1);\n}\n\nint main()\n{\n    cin.tie(0);\n    cin.sync_with_stdio(0);\n    int N, Q;\n    cin >> N >> Q;\n    string str;\n    cin >> str;\n    set<int> l, r;\n    for(int i = 0; i < str.size(); ++i){\n        if(str[i] == '('){\n            l.insert(i);\n            t[i + 1] = t[i] + 1;\n        } else if(str[i] == ')'){\n            r.insert(i);\n            t[i + 1] = t[i] - 1;\n        }\n    }\n    int q;\n    for(int i = 0; i < Q; ++i){\n        cin >> q;\n        q--;\n        if(l.find(q) != l.end()){\n            l.erase(q);\n            r.insert(q);\n            add(q + 1, -2);\n            int now = *r.begin();\n            cout << now + 1 << endl;\n            l.insert(now);\n            r.erase(now);\n            add(now + 1, 2);\n        } else {\n            r.erase(q);\n            l.insert(q);\n            add(q + 1, 2);\n            if(query(q + 1, str.size()) > 0){\n                cout << q + 1 << endl;\n                l.erase(q);\n                r.insert(q);\n                add(q + 1, -2);\n            } else {\n                int now = *next(l.begin());\n                cout << now + 1 << endl;\n                l.erase(now);\n                r.insert(now);\n                add(now + 1, -2);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate <typename T>\nclass StarrySkyTree {\n\tconst int n;\n\tvector<T> data, lazy;\n\tvoid add_sub(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) { lazy[node] += val; return; }\n\t\tint left = node * 2, right = left + 1;\n\t\tadd_sub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tadd_sub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata[node] = min(data[left] + lazy[left], data[right] + lazy[right]);\n\t}\n\tT min_sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return INF;\n\t\tif (l <= lb && ub <= r) return data[node] + lazy[node];\n\t\tT vl = min_sub(l, r, node * 2 + 0, lb, (lb + ub) / 2);\n\t\tT vr = min_sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t\treturn lazy[node] + min(vl, vr);\n\t}\n\tint size(int n) {\n\t\treturn n == 1 ? n : size((n + 1) / 2) * 2;\n\t}\npublic:\n\tStarrySkyTree(int m) : n(size(m)), data(n * 2, 0), lazy(n * 2, 0) {}\n\tvoid add(int l, int r, T val) { add_sub(l, r, 1, 0, n, val); }\n\tT minimum(int l, int r) { return min_sub(l, r, 1, 0, n); }\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s; cin >> s;\n\tStarrySkyTree<int> seg(N+1);\n\tvi sum(N + 1);\n\tREP(i, N)\n\t{\n\t\tsum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n\t\tseg.add(i + 1, i + 2, sum[i + 1]);\n\t}\n\tset<int> st;\n\tREP(i, N)\n\t{\n\t\tif (s[i] == ')') st.insert(i);\n\t}\n\twhile (Q--)\n\t{\n\t\tint t; cin >> t;\n\t\tt--;\n\t\tif (s[t] == '(')\n\t\t{\n\t\t\ts[t] = ')';\n\t\t\tst.insert(t);\n\t\t\tseg.add(t, N + 1, -2);\n\t\t\tint flip = *st.begin();\n\t\t\ts[flip] = '(';\n\t\t\tseg.add(flip, N + 1, 2);\n\t\t\tst.erase(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t\telse if(s[t] == ')')\n\t\t{\n\t\t\ts[t] = '(';\n\t\t\tst.erase(t);\n\t\t\tseg.add(t, N + 1, 2);\n\t\t\tint l = 0, r = t + 1;\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tif (seg.minimum(mid, r) == 0) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tint flip = r;\n\t\t\ts[flip] = ')';\n\t\t\tseg.add(flip, N + 1, -2);\n\t\t\tst.insert(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lid (id<<1)\n#define rid (id<<1|1)\nusing namespace std;\nconst int N=300010;\nstruct Tree {\n    int mi;\n    int add;\n} tree[N*4];\nint t[N*4];\nchar s[N];\nint a[N];\nint n,m;\nvoid push_down(int id) {\n    tree[lid].add+=tree[id].add;\n    tree[rid].add+=tree[id].add;\n    tree[lid].mi+=tree[id].add;\n    tree[rid].mi+=tree[id].add;\n    tree[id].add=0;\n}\nvoid update(int l,int r,int id,int x,int y,int z) {\n    if (x<=l&&y>=r) {\n        tree[id].mi+=z;\n        tree[id].add+=z;\n        return;\n    }\n    int mid=(l+r)>>1;\n    push_down(id);\n    if (x<=mid) update(l,mid,lid,x,y,z);\n    if (y>mid) update(mid+1,r,rid,x,y,z);\n    tree[id].mi=min(tree[lid].mi,tree[rid].mi);\n}\nint query(int l,int r,int id) {\n    if (l==r) return l;\n    push_down(id);\n    int mid=(l+r)>>1;\n    if (tree[rid].mi<0) return query(mid+1,r,rid);\n    else return query(l,mid,lid);\n}\nvoid update1(int l,int r,int id,int x,int y) {\n    if (l==r) {\n        t[id]+=y;\n        return;\n    }\n    int mid=(l+r)>>1;\n    if (x<=mid) update1(l,mid,lid,x,y);\n    else update1(mid+1,r,rid,x,y);\n    t[id]=t[lid]+t[rid];\n}\nint query1(int l,int r,int id) {\n    if (l==r) return l;\n    int mid=(l+r)>>1;\n    if (t[lid]>0) return query1(l,mid,lid);\n    else return query1(mid+1,r,rid);\n}\nvoid build(int l,int r,int id) {\n    tree[id].add=0;\n    if (l==r) {\n        tree[id].mi=a[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(l,mid,lid);\n    build(mid+1,r,rid);\n    tree[id].mi==min(tree[lid].mi,tree[rid].mi);\n}\nint main() {\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s+1);\n    a[n+1]=0;\n    for (int i=n; i>=1; i--) {\n        if (s[i]==')') a[i]=a[i+1]+1;\n        else a[i]=a[i+1]-1;\n    }\n    memset(t,0,sizeof(t));\n    for (int i=1; i<=n; i++) if (s[i]==')') update1(1,n,1,i,1);\n    build(1,n,1);\n    while (m--) {\n        int x;\n        scanf(\"%d\",&x);\n        if (s[x]=='(') {\n            s[x]=')';\n            update1(1,n,1,x,1);\n            update(1,n,1,1,x,2);\n            int ans=query1(1,n,1);\n            s[ans]='(';\n            update1(1,n,1,ans,-1);\n            update(1,n,1,1,ans,-2);\n            printf(\"%d\\n\",ans);\n        } else {\n            s[x]='(';\n            update(1,n,1,1,x,-2);\n            update1(1,n,1,x,-1);\n            int ans=query(1,n,1);\n            s[ans]=')';\n            update1(1,n,1,ans,1);\n            update(1,n,1,1,ans,2);\n            printf(\"%d\\n\",ans);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef int ll;\n\nstruct T {\n  ll v;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll mini(T* t){ push(t); return t?t->m:INT_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\nint n,m;\nchar s[333333];\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      root = add(root,l,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        /s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                assert(s[l]=='(');                \n                assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCアジア地区予選2014 G. Flipping Parentheses\n\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int N = 1<<19;\nint segMin[2*N-1];\nint segAdd[2*N-1];\nint segSum[2*N-1];\n\nvoid add(int l, int r, int val, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return;\n\tif(l <= rangeL && rangeR <= r){\n\t\tsegAdd[idx] += val;\n\t\twhile(idx){\n\t\t\tidx = (idx-1)/2;\n\t\t\tsegMin[idx] = min(segMin[2*idx+1]+segAdd[2*idx+1], segMin[2*idx+2]+segAdd[2*idx+2]);\n\t\t}\n\t} else {\n\t\tint rangeM = (rangeL+rangeR)/2;\n\t\tadd(l, r, val, 2*idx+1, rangeL, rangeM);\n\t\tadd(l, r, val, 2*idx+2, rangeM, rangeR);\n\t}\n}\n\nint getMin(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 1000000007;\n\tif(l <= rangeL && rangeR <= r) return segMin[idx]+segAdd[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn min(getMin(l, r, 2*idx+1, rangeL, rangeM), getMin(l, r, 2*idx+2, rangeM, rangeR)) + segAdd[idx];\n}\n\nvoid change(int pos, int val){\n\tint idx = pos+N-1;\n\tint add = val-segSum[idx];\n\tsegSum[idx] = val;\n\twhile(idx){\n\t\tidx = (idx-1)/2;\n\t\tsegSum[idx] += add;\n\t}\n}\n\nint getSum(int l, int r, int idx = 0, int rangeL = 0, int rangeR = N){\n\tif(rangeR <= l || r <= rangeL) return 0;\n\tif(l <= rangeL && rangeR <= r) return segSum[idx];\n\tint rangeM = (rangeL+rangeR)/2;\n\treturn getSum(l, r, 2*idx+1, rangeL, rangeM)+getSum(l, r, 2*idx+2, rangeM, rangeR);\n}\n\nint main(){\n\tint n, q;\n\twhile(cin >> n >> q){\n\t\tmemset(segMin, 0, sizeof(segMin));\n\t\tmemset(segAdd, 0, sizeof(segAdd));\n\t\tmemset(segSum, 0, sizeof(segSum));\n\t\tstring str; cin >> str;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(str[i] == '('){\n\t\t\t\tadd(i, n, 1);\n\t\t\t} else {\n\t\t\t\tadd(i, n, -1);\n\t\t\t\tchange(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint idx; cin >> idx; --idx;\n\t\t\tif(idx == 0 || idx == n-1){\n\t\t\t\tcout << idx+1 << endl;\n\t\t\t} else if(str[idx] == '('){\n\t\t\t\tchange(idx, 1);\n\t\t\t\tadd(0, idx, 2);\n\t\t\t\tstr[idx] = ')';\n\t\t\t\tint L = 0, R = n-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getSum(0, mid) > 0) R = mid;\n\t\t\t\t\telse                   L = mid;\n\t\t\t\t}\n\t\t\t\tchange(L, 0);\n\t\t\t\tadd(0, L, -2);\n\t\t\t\tstr[L] = '(';\n\t\t\t\tcout << L+1 << endl;\n\t\t\t} else {\n\t\t\t\tchange(idx, 0);\n\t\t\t\tadd(0, idx, -2);\n\t\t\t\tstr[idx] = '(';\n\t\t\t\tint L = 0, R = idx+1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint mid = (L+R)/2;\n\t\t\t\t\tif(getMin(mid, idx+1) >= 0) R = mid;\n\t\t\t\t\telse                        L = mid;\n\t\t\t\t}\n\t\t\t\tchange(R, 1);\n\t\t\t\tadd(0, R, 2);\n\t\t\t\tstr[R] = ')';\n\t\t\t\tcout << R+1 << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N=(1<<20);\n\nll bit0[2][MAX_N+1],bit1[2][MAX_N+1];\n\nclass BIT{\n\npublic:\n  \n  int n,idx;\n  \n  BIT(){\n    n=MAX_N;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n  }\n\n  BIT(int n,int I){\n    this->n=n;\n    memset(bit0,0,sizeof(bit0));\n    memset(bit1,0,sizeof(bit1));\n    idx=I;\n  }\n  \n  ll sum(ll *b,int i){\n\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(ll *b,int i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n  \n  // [a,b]テ」ツ?ォ xテ」ツつ津・ツ環?」ツ?暗」ツつ?\n  \n  void add(int a,int b,ll x){\n    add(bit0[idx],a,-x*(a-1));\n    add(bit1[idx],a,x);\n    add(bit0[idx],b+1,x*b);\n    add(bit1[idx],b+1,-x);\n  }\n  \n  // [a,b]テ」ツ?ョsumテ」ツつ津・ツセツ療」ツつ?\n  \n  ll sum(int a,int b){\n    ll res=0;\n    res+=sum(bit0[idx],b)+sum(bit1[idx],b)*b;\n    res-=sum(bit0[idx],a-1)+sum(bit1[idx],a-1)*(a-1);\n    return res;\n  }\n  \n};\n\n\n\nstring s;\nint n,q;\n\n\nint main(){\n  \n  cin>>n>>q;\n  \n  cin>>s;\n  \n  BIT L(n,0), R(n,1);\n\n  for(int i=1;i<=n;i++){\n\n    if(s[i-1]=='(') L.add(i,i,1);\n    else R.add(i,i,1);\n    \n  }\n  \n  int x;\n  \n  for(int i=0;i<q;i++){\n    \n    scanf(\"%d\",&x);\n    \n    if(L.sum(x,x)){ // s[x]='('\n     \n      L.add(x,x,-1);\n      R.add(x,x,1);\n      \n      if(L.sum(0,x)<R.sum(0,x)){\n\t\n\tL.add(x,x,1);\n\tR.add(x,x,-1);\n      \n\tprintf(\"%d\\n\",x);\n\tcontinue;\n      }\n      int l=1, r=n+1;\n      \n      while(l<r){\n\t\n\tint m=(l+r)/2;\n\n\tif(R.sum(1,m)>=1) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,1);\n      R.add(l,l,-1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    else{ // s[x]=')'\n\n      L.add(x,x,1);\n      R.add(x,x,-1);\n      \n      if(L.sum(x,n)>R.sum(x,n)){\n\t\n\tL.add(x,x,-1);\n\tR.add(x,x,1);\n      \n\tprintf(\"%d\\n\",x);\n\tcontinue;\n      }\n      \n      int l=1, r=n+1;\n\n      while(l<r){\n\n\tint m=(l+r)/2;\n\t\n\tif(L.sum(0,m-1)>=R.sum(0,m-1)+1) r=m;\n\telse l=m+1;\n\t\n      }\n\n      L.add(l,l,-1);\n      R.add(l,l,1);\n\n      printf(\"%d\\n\",l);\n      \n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n  \nstruct segtree{\n  vector<int> t,u;\n  int n;\n  \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)\n      t[i]=u[i]=0;\n  }\n  \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    \n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    \n    t[k*2+1]+=u[k];\n    u[k*2+2]+=u[k];\n    \n    u[k]=0;\n  }\n  \n  void add(int a,int b,int x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n  \n  int query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      return min(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n  }\n  \n  void add(int a,int b,int x) {\n    add(a,b,x,0,0,n);\n  }\n  \n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n  \nsegtree T;\nint N,Q;\nchar str[300005];\nset< int > U;\n  \nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  scanf(\"%s\",str);\n  T.init(N+2);\n  \n  \n  for(int i=0;i<N;i++){\n    if(str[i]=='('){\n      T.add(i,N,1);\n    }else{\n      T.add(i,N,-1);\n      U.insert(i);\n    }\n  }\n  \n  \n  set<int> :: iterator it;\n  int p,a;\n  while(Q--){\n  \n  \n    scanf(\"%d\",&p);\n    p--;\n    if(str[p]=='('){\n      U.insert(p);\n      str[p]=')';\n      T.add(p,N,-2);\n  \n      it=U.begin();\n      a= *it;\n      printf(\"%d\\n\",a+1);\n      U.erase(it);\n      str[a]='(';\n      T.add(a,N,2);\n    }else if(str[p]==')'){\n      it=U.find(p);\n      U.erase(it);\n      str[p]='(';\n      T.add(p,N,2);\n  \n  \n  \n        \n      int l=0,r=N-1,m,k;\n      while(l<r){\n        m=(l+r)/2;\n        k=T.query(m,N);\n          \n        if(k<2){\n          l=m+1;\n        }else{\n          r=m;\n        }\n      }\n      printf(\"%d\\n\",l+1);\n      str[l]=')';\n      T.add(l,N,-2);\n      U.insert(l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s;\n\tcin >> s;\n\tfor (int i = 0; i < Q; ++i)\n\t{\n\t\tint q;\n\t\tcin >> q;\n\t\t--q;\n\t\tif (s[q] == '(')\n\t\t{\n\t\t\ts[q] = ')';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts[q] = '(';\n\t\t}\n\n\t\tfor (int j = 0; j <= q; ++j)\n\t\t{\n\t\t\tchar buf = s[j];\n\t\t\tint cnt = 0;\n\t\t\tif (s[j] == '(')\n\t\t\t{\n\t\t\t\ts[j] = ')';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[j] = '(';\n\t\t\t}\n\t\t\tfor (int k = 0; k < N; ++k)\n\t\t\t{\n\t\t\t\tif (s[k] == '(')\n\t\t\t\t{\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t--cnt;\n\t\t\t\t}\n\t\t\t\tif (cnt < 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cnt == 0)\n\t\t\t{\n\t\t\t\tcout << j + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[j] = buf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll *min_data,*max_data,*add_data;\nchar buf[300001];\nint N = 1;\n\nvoid init(ll first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid add(int left,int right,ll value,int node_id,int node_left,int node_right){\n\n\tif(right < node_left || left > node_right){\n\t\treturn;\n\t}\n\telse if(left <= node_left && right >= node_right){\n\n\t\tadd_data[node_id] += value;\n\n\t\twhile(node_id != 0){\n\n\t\t\tnode_id = (node_id-1)/2;a[2*node_id+2]+add_data[2*node_id+2]);\n\t\t\tmax_data[node_id] = max(max_data[2*node_id+1]+add_data[2*node_id+1],max_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t}\n\t}else{\n\n\t\tadd(left,right,value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tadd(left,right,value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nll getMin(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn min_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_min  = getMin(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_min = getMin(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn min(left_min,right_min)+add_data[node_id];\n\t}\n}\n\n\nint main(){\n\n\tint first_N,Q;\n\tscanf(\"%d %d\",&first_N,&Q);\n\n\tinit(first_N);\n\n\tmin_data = new ll[2*N-1];\n\tmax_data = new ll[2*N-1];\n\tadd_data = new ll[2*N-1];\n\n\tfor(ll i = 0; i <= 2*N-2; i++){\n\t\tmin_data[i] = 0;\n\t\tmax_data[i] = 0;\n\t\tadd_data[i] = 0;\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tset<int> CLOSE;\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tif(buf[i] == '('){\n\t\t\tadd(i,N-1,1,0,0,N-1);\n\t\t}else{\n\t\t\tCLOSE.insert(i);\n\t\t\tadd(i,N-1,-1,0,0,N-1);\n\t\t}\n\t}\n\n\tint loc,calc_loc;\n\tint left,right,m;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&loc);\n\t\tloc--;\n\n\t\tif(buf[loc] == '('){\n\n\t\t\tbuf[loc] = ')';\n\t\t\tadd(loc,N-1,-2,0,0,N-1);\n\t\t\tCLOSE.insert(loc);\n\n\t\t\tcalc_loc = *begin(CLOSE);\n\t\t\tCLOSE.erase(begin(CLOSE));\n\n\t\t\tadd(calc_loc,N-1,2,0,0,N-1);\n\t\t\tbuf[calc_loc] = '(';\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\n\t\t}else{ //buf[loc] == ')'\n\n\t\t\tCLOSE.erase(loc);\n\t\t\tbuf[loc] = '(';\n\t\t\tadd(loc,N-1,2,0,0,N-1);\n\n\t\t\tleft = 0,right = first_N-1, m = (left+right)/2;\n\n\t\t\twhile(left <= right){\n\t\t\t\tif(getMin(m,N-1,0,0,N-1) >= 2){\n\t\t\t\t\tcalc_loc = m;\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\twhile(buf[calc_loc] != '(')calc_loc++;\n\n\t\t\tbuf[calc_loc] = ')';\n\t\t\tadd(calc_loc,N-1,-2,0,0,N-1);\n\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\t\t\tCLOSE.insert(calc_loc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        \n\n\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        assert(S[pos_pos] == '(');\n        // assert(sum_seg.min(pos_pos + 1, q + 1) >= 0);\n        // assert(sum_seg.min(0, N + 1) >= 0);\n        // assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        cout << pos_pos + 1 << endl;\n        \n        close_parens.erase(q);\n        close_parens.insert(pos_pos);\n        sum_seg.add(q + 1, N + 1, 2);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        \n        pos_seg.add(q, q + 1, -1);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n  \nstruct segtree{\n  vector<int> t,u;\n  int n;\n  \n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    t.clear();\n    u.clear();\n    t.resize(2*n);\n    u.resize(2*n);\n    for(int i=0;i<2*n;i++)\n      t[i]=u[i]=INF;\n  }\n  \n  void delay(int k,int l,int r){\n    if(r-l==1)return;\n    \n    t[k*2+1]+=u[k];\n    u[k*2+1]+=u[k];\n    \n    t[k*2+1]+=u[k];\n    u[k*2+2]+=u[k];\n    \n    u[k]=0;\n  }\n  \n  void add(int a,int b,int x,int k,int l,int r){\n    if(b<=l || r<=a)return;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      t[k]+=x;\n      u[k]=x;\n    }else{\n      int m=(l+r)/2;\n      add(a,b,x,k*2+1,l,m);\n      add(a,b,x,k*2+2,m,r);\n      t[k]=min(t[k*2+1],t[k*2+2]);\n    }\n  }\n  \n  int query(int a,int b,int k,int l,int r){\n    if(b<=l || r<=a)return INF;\n    delay(k,l,r);\n    if(a<=l && r<=b){\n      return t[k];\n    }else{\n      int m=(l+r)/2;\n      return min(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n  }\n  \n  void add(int a,int b,int x) {\n    add(a,b,x,0,0,n);\n  }\n  \n  int query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n};\n  \nsegtree T;\nint N,Q;\nchar str[300005];\nset< int > U;\n  \nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  scanf(\"%s\",str);\n  T.init(N+2);\n  \n  \n  for(int i=0;i<N;i++){\n    if(str[i]=='('){\n      T.add(i,N,1);\n    }else{\n      T.add(i,N,-1);\n      U.insert(i);\n    }\n  }\n  \n  \n  set<int> :: iterator it;\n  int p,a;\n  while(Q--){\n  \n  \n    scanf(\"%d\",&p);\n    p--;\n    if(str[p]=='('){\n      U.insert(p);\n      str[p]=')';\n      T.add(p,N,-2);\n  \n      it=U.begin();\n      a= *it;\n      printf(\"%d\\n\",a+1);\n      U.erase(it);\n      str[a]='(';\n      T.add(a,N,2);\n    }else if(str[p]==')'){\n      it=U.find(p);\n      U.erase(it);\n      str[p]='(';\n      T.add(p,N,2);\n  \n  \n  \n        \n      int l=0,r=N-1,m,k;\n      while(l<r){\n        m=(l+r)/2;\n        k=T.query(m,N);\n          \n        if(k<2){\n          l=m+1;\n        }else{\n          r=m;\n        }\n      }\n      printf(\"%d\\n\",l+1);\n      str[l]=')';\n      T.add(l,N,-2);\n      U.insert(l);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nconst int p2=1<<19;\nint N,Q;\nstring s;\nint segm[p2*2],sega[p2*2],inf=1e8;\nset<int> st;\nvoid add(int a,int b,int l,int r,int k,int x){\n\tif(b<=l||r<=a) return;\n\tif(a<=l&&r<=b){\n\t\tsega[k]+=x;\n\t\treturn;\n\t}\n\tadd(a,b,l,(l+r)/2,k*2+1,x);\n\tadd(a,b,(l+r)/2,r,k*2+2,x);\n}\nvoid change(int x){\n\tif(s[x]=='('){\n\t\ts[x]=')';\n\t\tst.insert(x);\n\t\tadd(x,p2,0,p2,0,-2);\n\t}else{\n\t\ts[x]='(';\n\t\tst.erase(x);\n\t\tadd(x,p2,0,p2,0,2);\n\t}\n}\nint getmin(int a,int b,int l,int r,int k){\n\tif(b<=l||r<=a) return inf;\n\tif(a<=l&&r<=b) return segm[k]+sega[k];\n\treturn min(getmin(a,b,l,(l+r)/2,k*2+1),getmin(a,b,(l+r)/2,r,2*k+2))+sega[k];\n}\nint main(){\n\tcin>>N>>Q;\n\tcin>>s;\n\trep(i,N) if(s[i]==')') st.insert(i);\n\trep(i,N) segm[p2-1+i]=segm[p2-2+i]+(s[i]=='('?1:-1);\n\tfor(int i=p2-2;i>=0;i--){\n\t\tsegm[i]=min(segm[i*2+1],segm[i*2+2]);\n\t}\n\trep(i,Q){\n\t\tint q;\n\t\tcin>>q;\n\t\tq--;\n\t\tif(s[q]=='('){\n\t\t\tchange(q);\n\t\t\tint a=*st.begin();\n\t\t\tcout<<a+1<<endl;\n\t\t\tchange(a);\n\t\t}else{\n\t\t\tchange(q);\n\t\t\tint ub=q,lb=-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(ub+lb)/2;\n\t\t\t\tif(getmin(m,q+1,0,p2,0)>=2) ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tcout<<ub+1<<endl;\n\t\t\tchange(ub);\n\t\t}\n/*\t\tputs(\"segm\");\n\t\trep(j,p2*2-1) cout<<segm[j]<<\" \";\n\t\tcout<<endl;\n\t\tputs(\"sega\");\n\t\trep(j,p2*2-1) cout<<sega[j]<<\" \";\n\t\tcout<<endl;\n\t\tcout<<s<<endl;\n*/\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (テヲツ環スティツアツ。テ」ツδサテヲツアツ偲・ツ個姪ゥツ??・ツサツカテ」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗ヲツ慊ィ)\n// Verified: AOJ テ」ツ?ョテ」ツつサテ」ツつーテヲツ慊ィ verify テ・ツ閉湘・ツ?ィテゥツδィ\n\nconst int SIZE = 1 << 17; // 2^17 = 131072\ntemplate<typename T>\nstruct lazysegtree {\n    // テ」ツδ偲」ツδシテ」ツδ嘉」ツ??・ツ債佚、ツスツ催・ツ??\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // テ」ツつェテ」ツδ堙」ツδャテ」ツδシテ」ツつキテ」ツδァテ」ツδウ (update, query テ」ツ?ョ 2 テ」ツ?、テ」ツ?古・ツソツ?ィツヲツ?ッツシツ?\n    // update function テ」ツ?ッテァツッツ?・ツ崢イテ」ツつ津ヲツ個?・ツョツ堙」ツ?凖」ツつ凝・ツスツ「テ」ツ?ォテ」ツ?療」ツつ暗」ツ??\n    // upd_f(X, Y, l, r) -> テァツッツ?・ツ崢イテ」ツ??[l, r) テ」ツ?ァテ」ツ?づ」ツつ凝」ツつ暗」ツ??」ツ?ェテ」ツδ偲」ツδシテ」ツδ?X テ」ツ?ォ Y テ」ツつ津・ツ渉催ヲツ伉?ッツシツ?\n    // lazy テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ update テ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテァツッツ?・ツ崢イテ」ツつ?1 テ」ツ?ォテ」ツ?療」ツ?ェテ」ツ??」ツ?ィテ」ツδ静」ツつーテ」ツつ甘」ツ?セテ」ツ??\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // テヲツシツ氾ァツョツ療・ツュツ静」ツ?ィテ・ツ債佚、ツスツ催・ツ?ε」ツつ津」ツつサテ」ツδε」ツδ暗」ツ?療」ツ??・ツ?ィテ」ツ?ヲテ」ツ?ョ node テ」ツ?ィ lazy テ」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X, vector<T> vec) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n\n        // vec テ」ツ?ョテ・ツ?、テ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n        for(size_t i=0; i<vec.size(); i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ・ツ?、 val テ」ツつ津・ツ渉催ヲツ伉?」ツ?陛」ツ?崚」ツつ?\n    // (upd_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツつッテ」ツつィテ」ツδェテ」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // (qry_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    if(a == INT_MAX) return (r - l) * b;\n    return a + (r - l) * b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    lazysegtree<int> seg(add, qry, INT_MAX, array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // テ、ツスツ催ァツスツョ idx テ」ツ?ォテ」ツ?づ」ツつ?')' テ」ツつ?'(' テ」ツ?ォ\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                if(val > 2) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(lb));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<30)\n\nstruct segtree{\n  vector<int> datasum;\n  vector<int> delay;\n  \n  int n;\n  \n  void init(int _n){\n    n = 1;\n    while( n < _n ) n *= 2;\n    datasum.resize( 2 * n );\n    delay.resize( 2 * n );\n  }\n\n  void delaycalc(int k){\n    datasum[k] = datasum[k] + delay[k];\n    if( k + 1 < n ){\n      for(int i=1;i<=2;i++){\n        delay[2 * k + i] = delay[ 2 * k + i] + delay[k];\n      }\n    }\n    delay[k] = 0;\n  }\n\n  void add(int a,int b,int x,int k,int l,int r){\n    delaycalc(k);\n    if( r <= a || b <= l ) return;\n    else if( a<= l && r <= b ) {\n      delay[k] = x;\n      delaycalc(k);\n    } else {\n      add( a, b, x, 2*k + 1, l, (l+r)/2 );\n      add( a, b, x, 2*k + 2, (l+r)/2, r );\n      datasum[k] = min(datasum[ 2 * k + 1] , datasum[ 2 * k + 2]);\n    }\n  }\n\n  int query(int a,int b,int k,int l,int r){\n    delaycalc(k);\n    if( r <= a || b <= l ) return INF;\n    if( a <= l && r <= b ) {\n      return datasum[k] + delay[k];\n    } else {\n      int vl = query( a, b, 2*k+1, l, (l+r)/2 );\n      int vr = query( a, b, 2*k+2, (l+r)/2, r );\n      return min( vl , vr );\n    }\n  }\n\n  void add( int a,int b,int x) {//[a,b) add x\n    add( a, b, x, 0,0, n );\n  }\n  int query(int a,int b){//[a,b) 's sum\n    return query(a,b,0,0,n);\n  }\n};\n\nsegtree T;\nint N,Q;\nchar str[300005];\nset< int > U;\n\nint main(){\n  scanf(\"%d %d\",&N,&Q);\n  scanf(\"%s\",str);\n  T.init(N+2);\n\n\n  for(int i=0;i<N;i++){\n    if(str[i]=='('){\n      T.add(i,N,1);\n    }else{\n      T.add(i,N,-1);\n      U.insert(i);\n    }\n  }\n\n\n  set<int> :: iterator it;\n  int p,a;\n  while(Q--){\n\n\n    scanf(\"%d\",&p);\n    p--;\n    if(str[p]=='('){\n      U.insert(p);\n      str[p]=')';\n      T.add(p,N,-2);\n\n      it=U.begin();\n      a= *it;\n      printf(\"%d\\n\",a+1);\n      U.erase(it);\n      str[a]='(';\n      T.add(a,N,2);\n    }else if(str[p]==')'){\n      it=U.find(p);\n      U.erase(it);\n      str[p]='(';\n      T.add(p,N,2);\n\n\n\n      \n      int l=0,r=N-1,m,k;\n      while(l<r){\n        m=(l+r)/2;\n        k=T.query(m,N);\n        \n        if(k<2){\n          l=m+1;\n        }else{\n          r=m;\n        }\n      }\n      printf(\"%d\\n\",l+1);\n      str[l]=')';\n      T.add(l,N,-2);\n      U.insert(l);\n    }\n\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<endl)\n\nstruct DUMP : ostringstream {\n\ttemplate<class T> DUMP &operator,(const T &t) {\n\t\tif(this->tellp()) *this << \", \";\n\t\t*this << t;\n\t\treturn *this; \n\t}\n};\n\ntemplate<class Iterator>\nostream &dump_range(ostream &os, Iterator first, const Iterator &last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const set<T> &c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntypedef int type;\nconstexpr type INIT = (1 << 28);\n\nclass segment_tree {\nprivate:\n\tint n;\n\tvector<type> value;\n\tvector<type> lazy;\n\n\ttype function(type a, type b) {\n\t\treturn min(a, b);\n\t}\n\n\tvoid evaluate(int k, int number_of_children) {\n\t\tif(lazy[k] == 0) return;\n\t\tif(number_of_children > 1) {\n\t\t\tlazy[k * 2 + 1] += lazy[k];\n\t\t\tlazy[k * 2 + 2] += lazy[k];\n\t\t}\n\n\t\tvalue[k] += lazy[k];\n\t\tlazy[k] = 0;\n\t}\n\n\t// [a, b)にvを加える\n\tvoid add(int a, int b, type v, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return;\n\t\tif(a <= l && r <= b) {\n\t\t\tlazy[k] += v;\n\t\t}\n\t\telse {\n\t\t\tconst int m = (l + r) / 2;\n\t\t\tevaluate(k, r - l);\n\t\t\tadd(a, b, v, k * 2 + 1, l, m);\n\t\t\tadd(a, b, v, k * 2 + 2, m, r);\n\t\t\tvalue[k] = function(query(l, m, k * 2 + 1, l, m), query(m, r, k * 2 + 2, m, r));\n\t\t}\n\t}\n\n\ttype query(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INIT;\n\t\tevaluate(k, r - l);\n\t\tif(a <= l && r <= b) return value[k];\n\n\t\tconst int m = (l + r) / 2;\n\t\tconst type vl = query(a, b, k * 2 + 1, l, m);\n\t\tconst type vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn function(vl, vr);\n\t}\n\npublic:\n\tsegment_tree(int n_):n(1) {\n\t\twhile(n < n_) n <<= 1;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\n\tsegment_tree(const vector<int> &a):n(1) {\n\t\tconst int n_ = a.size();\n\t\twhile(n < n_) n <<= 1;\n\t\tvalue.resize(2 * n - 1, INIT);\n\t\tlazy.resize(2 * n - 1, 0);\n\n\t\tfor(int i = 0; i < n_; ++i) {\n\t\t\tvalue[i + n - 1] = a[i];\n\t\t}\n\n\t\tfor(int i = n - 2; i >= 0; --i) {\n\t\t\tvalue[i] = function(value[2 * i + 1], value[2 * i + 2]);\n\t\t}\n\t}\n\n\tvoid add(int a, int b, type v) {\n\t\tadd(a, b, v, 0, 0, n);\n\t}\n\n\ttype query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tvoid print() {\n\t\tfor(const auto &e : value) {\n\t\t\tcout << e << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tstring s;\n\tcin >> s;\n\n\tset<int> S;\n\n\tint sum = 0;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tif(s[i] == '(') {\n\t\t\t++sum;\n\t\t}\n\t\telse {\n\t\t\t--sum;\n\t\t\tS.insert(i);\n\t\t}\n\n\t\ta[i] = sum;\n\t}\n\n\tsegment_tree seg(a);\n\n\twhile(q--) {\n\t\tint p;\n\t\tcin >> p;\n\t\t--p;\n\n\t\tif(s[p] == '(') {\n\t\t\ts[p] = ')';\n\t\t\tS.insert(p);\n\t\t\tseg.add(p, n, -2);\n\n \t\t\tconst int res = *S.begin();\n\n\t\t\tassert(s[res] == ')');\n\n\t\t\ts[res] = '(';\n\t\t\tS.erase(res);\n\t\t\tseg.add(res, n, 2);\n\n\t\t\tcout << res + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\ts[p] = '(';\n\t\t\tS.erase(p);\n\t\t\tseg.add(p, n, 2);\n\n\t\t\tint L = 0, R = p;\n\t\t\twhile(L + 1 < R) {\n\t\t\t\tconst int M = (L + R) / 2;\n\n\t\t\t\tif(seg.query(M, p) <= 1) {\n\t\t\t\t\tL = M;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tR = M;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts[R] = ')';\n\t\t\tS.insert(R);\n\t\t\tseg.add(R, n, -2);\n\n\t\t\tcout << R + 1 << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        \n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        // assert(S[pos_pos] == '(');\n        // assert(sum_seg.min(pos_pos + 1, q + 1) >= 0);\n        // assert(sum_seg.min(0, N + 1) >= 0);\n        // assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        cout << pos_pos + 1 << endl;\n        close_parens.erase(q);\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntemplate <typename T>\nclass StarrySkyTree {\n\tconst int n;\n\tvector<T> data, lazy;\n\tvoid add_sub(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) { lazy[node] += val; return; }\n\t\tint left = node * 2, right = left + 1;\n\t\tadd_sub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tadd_sub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata[node] = min(data[left] + lazy[left], data[right] + lazy[right]);\n\t}\n\tT min_sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return INF;\n\t\tif (l <= lb && ub <= r) return data[node] + lazy[node];\n\t\tT vl = min_sub(l, r, node * 2 + 0, lb, (lb + ub) / 2);\n\t\tT vr = min_sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t\treturn lazy[node] + min(vl, vr);\n\t}\n\tint size(int n) {\n\t\treturn n == 1 ? n : size((n + 1) / 2) * 2;\n\t}\npublic:\n\tStarrySkyTree(int m) : n(size(m)), data(n * 2, 0), lazy(n * 2, 0) {}\n\tvoid add(int l, int r, T val) { add_sub(l, r, 1, 0, n, val); }\n\tT minimum(int l, int r) { return min_sub(l, r, 1, 0, n); }\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s; cin >> s;\n\tStarrySkyTree<int> seg(N);\n\tvi sum(N+1);\n\tREP(i, N)\n\t{\n\t\tsum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n\t\tseg.add(i, i + 1, sum[i+1]);\n\t}\n\tset<int> st;\n\tREP(i, N)\n\t{\n\t\tif (s[i] == ')') st.insert(i);\n\t}\n\tREP(i, Q)\n\t{\n\t\tint t; cin >> t;\n\t\tt--;\n\t\tif (s[t] == '(')\n\t\t{\n\t\t\ts[t] = ')';\n\t\t\tst.insert(t);\n\t\t\tseg.add(t, N, -2);\n\t\t\tint flip = *st.begin();\n\t\t\ts[flip] = '(';\n\t\t\tseg.add(flip, N, 2);\n\t\t\tst.erase(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t\telse if(s[t] == ')')\n\t\t{\n\t\t\ts[t] = '(';\n\t\t\tst.erase(t);\n\t\t\tseg.add(t, N, 2);\n\t\t\tint l = 0, r = N;\n\t\t\twhile (r - l > 1)\n\t\t\t{\n\t\t\t\tint mid = (r + l) / 2;\n\t\t\t\tint tmp = seg.minimum(mid, N);\n\t\t\t\tif (tmp == 2) r = mid;\n\t\t\t\telse l = mid;\n\t\t\t}\n\t\t\tint flip = r;\n\t\t\ts[flip] = ')';\n\t\t\tseg.add(flip, N, -2);\n\t\t\tst.insert(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\n\n//Segment Tree\nclass SegmentTree{\npublic:\n  int n;\n  vi node;\n  vi ofset;\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n=1;\n    while(n<n_)n*=2;\n\n    node = vi(2*n-1, INF);\n    for(int i=0;i<n_;i++)node[i+n-1] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n\n    ofset = vi(2*n-1,0);\n  }\n\n  //return minimum value in [a,b). ( [l,r) is interval in which k is.)\n  int rmq(int a,int b,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return INF;\n    if(a<=l && r<=b)return node[k]+ofset[k];\n    int pl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int pr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(pl,pr) + ofset[k];\n  }\n\n  int search(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r-l<=1)return (node[k]+ofset[k] >= v)?l:INF;\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    if(vr + ofset[k] >= v){\n      int res = search(a,b,v,2*k+1,l,(l+r)/2);\n      if(res != INF)return res;\n      return (l+r)/2;\n    }else{\n      int res = search(a,b,v,2*k+2,(l+r)/2,r);\n      if(res != INF)return res;\n      return INF;\n    }\n  }\n \n  int update_range(int a,int b,int v,int k=0,int l=0,int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return node[k];\n    if(a<=l && r<=b){\n      ofset[k] += v;\n      return node[k]+ofset[k];\n    }\n\n    int vl = update_range(a,b,v,2*k+1,l,(l+r)/2);\n    int vr = update_range(a,b,v,2*k+2,(l+r)/2,r);\n    node[k] = min(vl,vr);\n    return node[k] + ofset[k];\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,q;\n  cin >> n >> q;\n  string s;\n  cin >> s;\n\n  set<int> minus;\n  vi h(n,1);\n  rep(i,n-1){\n    if(s[i+1] == '(')h[i+1] = h[i] + 1;\n    else{\n      h[i+1] = h[i] - 1;\n      minus.insert(i+1);\n    }\n  }\n  SegmentTree st(h);\n\n  while(q--){\n    int p;\n    cin >> p; p--;\n    if(s[p] == '('){\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n\n      p = *minus.begin();\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n    }else{\n      s[p] = '(';\n      minus.erase(p);\n      st.update_range(p,n,2);\n\n      p = st.search(0,p+1,2);\n      s[p] = ')';\n      minus.insert(p);\n      st.update_range(p,n,-2);\n    }\n    cout << p+1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct T;\n#define null ((T*)NULL)\n\ntypedef int ll;\n\nstruct T {\n  ll v;\n  ll m;\n  int c;\n  T *l,*r;\n  bool lz;\n  ll lazy;\n  T(){}\n  T(ll v):v(v),m(v),c(1),l(null),r(null),lz(false),lazy(0){}\n};\n\nint hogeS=0;\n#define SSS 2222222\nT hoge[SSS];\ninline T* New(int v){\n  if(hogeS >= SSS) exit(-1);\n  hoge[hogeS]=T(v);\n  return &hoge[hogeS++];\n}\ninline int count(T* t){ return t?t->c:0; }\ninline void push(T* t)\n{\n  if( !t ) return;\n  if( t->lz ) {\n    t->v += t->lazy;\n    t->m += t->lazy;\n    t->lz = false;\n    if( t->r ) {\n      t->r->lz |= true;\n      t->r->lazy += t->lazy;\n    }\n    if( t->l ) {\n      t->l->lz |= true;\n      t->l->lazy += t->lazy;\n    }\n    t->lazy = 0;\n  }\n}\ninline ll mini(T* t){ push(t); return t?t->m:LLONG_MAX; }\n\ninline T* update(T* t)\n{\n  if(!t)return t;\n  push(t);\n  t->c = count(t->l)+count(t->r)+1;\n  t->m = min(t->v,min(mini(t->l),mini(t->r)));\n  return t;\n}\n\nT* merge(T* a,T* b)\n{\n  push(a);\n  push(b);\n  if(!a || !b)return a?a:b;\n  if(rand()%(count(a)+count(b))<count(a)){\n    a->r = merge(a->r,b);\n    return update(a);\n  } else {\n    b->l = merge(a,b->l);\n    return update(b);\n  }\n}\n\npair<T*,T*> split(T* a,int k)\n{\n  push(a);\n  if(!a)return make_pair(null,null);\n  if(k<=count(a->l)){\n    pair<T*,T*> s=split(a->l,k);\n    a->l = s.second;\n    return make_pair(s.first,update(a));\n  } else {\n    pair<T*,T*> s=split(a->r,k-count(a->l)-1);\n    a->r = s.first;\n    return make_pair(update(a),s.second);\n  }\n}\n\ninline T* insert(T* t,int k,int v)\n{\n  push(t);\n  pair<T*,T*> a=split(t,k);\n  return merge(merge(a.first,New(v)),a.second);\n}\n\ninline T* add(T* t,int l,int r,int k)\n{\n  push(t);\n  pair<T*,T*> u = split(t,r);\n  pair<T*,T*> v = split(u.first,l);\n  T* w = v.second;\n  w->lz = true;\n  w->lazy += k;\n  return merge(merge(v.first,update(w)),u.second);\n}\n\nint n,m;\nchar s[333333];\n\nvoid print(T* t)\n{\n  if(t==null)return;\n  push(t);\n  print(t->l);\n  printf(\"%2lld,%2lld|\",t->v,t->m);\n  print(t->r);\n}\n\nint main(void)\n{\n  T *root = null;\n  int n,q;\n  set<int> toji;\n  scanf(\"%d%d\",&n,&q);\n  scanf(\"%s\",s);\n  for( int i = 0; i < n; i++ ) {\n    root = insert(root,i,0);\n  }\n  for( int i = 0; i < n; i++ ) {\n    root = add(root,i,n,s[i]=='('?1:-1);\n    if( s[i] == ')' ) toji.insert(i);\n  }\n  int k;\n  for( int ii = 0; ii < q; ii++ ) {\n    scanf(\"%d\",&k);\n    if( s[k-1] == '(' ) {\n      s[k-1] = ')';\n      toji.insert(k-1);\n      root = add(root,k-1,n,-2);\n      int me = *(toji.begin());\n      printf(\"%d\\n\",me+1);\n      s[me] = '(';\n      toji.erase(me);\n      root = add(root,me,n,2);\n    } else {\n      toji.erase(k-1);\n      s[k-1] = '(';\n      root = add(root,k-1,n,2);\n      int l=0,r=n;\n      while( l < r ) {\n        int mb = (l+r)/2;\n        auto t = split(root,mb);\n        if( mini(t.second) >= 2 ) {\n          r = mb;\n        } else {\n          l = mb+1;\n        }\n        root = merge(t.first,t.second);\n      }\n      printf(\"%d\\n\",l+1);\n      s[l] = ')';\n      toji.insert(l);\n      root = add(root,l,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<map>\n#include<cmath>\n//#include<>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,j) for(i=0;i<j;i++)\n#define rep_a_to(a,i,j) for(i=a;i<=j;i++)\n#define rev_rep(i,j) for(i=j;i>=0;i--)\n\nconst int INF=1<<30;\n//sumに区間部分加算総和、dataに区間全体各加算和を入れる\nclass Segment_Tree\n{\npublic:\n  int n;\n  vector<int> data,sum;//data:区間の総和最小//sum:その対応区間全てに追加した和\n\n\n  Segment_Tree(int n_)\n  {\n    n=1;\n    while(n<n_)n*=2;\n    data.resize(2*n-1,0);\n    sum.resize(2*n-1,0);\n  }\n\n  //[a,b]にxを加算\n  void add(int a,int b,int x)\n  {\n    add_getmin(a,b,x,0,0,n);\n  }\n\n  int get_min(int a,int b)\n  {\n    return get_min(a,b,0,0,n);\n  }\n\nprivate:\n  //区間に追加してその区間の最小値を返す\n  int add_getmin(int a,int b,int x,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return data[k];\n    //加算希望区間に収まっていたら\n    if(a<=l && r<=b)\n      {\n\tdata[k]+=x;//区間全体に+xなので最小値はその区間最小値+x\n\tsum[k]+=x;\n\treturn data[k];\n      }\n    //加算希望区間を含むなら\n    else if(l<b && a<r)\n      {\n\t//区間最小値は下の最小値にすでに足されていた値を足したもの\n\tdata[k]=min(add_getmin(a,b,x,k*2+1,l,(l+r)/2),add_getmin(a,b,x,k*2+2,(l+r)/2,r))+sum[k];\n      }\n  }\n  //[a,b)の最小値,kは今の場所,[l,r)はkの守備範囲\n  int get_min(int a,int b,int k,int l,int r)\n  {\n    //目的範囲から完全に外れたら\n    if(r<=a||b<=l)return INF;\n    //目的範囲より狭くなったら\n    if(a<=l&&r<=b)return data[k];\n    else {\n      //左の子側の範囲\n      int vl=get_min(a,b,k*2+1,l,(l+r)/2);\n      //右の子側の範囲\n      int vr=get_min(a,b,k*2+2,(l+r)/2,r);\n      return min(vl,vr)+sum[k];\n    }\n  }\n\n};\n\nvoid debug_show(string str,Segment_Tree *ST,int n)\n{\n  int j;\n  cout<<str<<endl;\n  cout<<\"Sum \";\n  rep(j,n)\n    cout<<ST->get_min(j,j+1)<<\" \";\n  cout<<endl;\n  cout<<\"Min \" ;\n  rep(j,n)\n    cout<<ST->get_min(j,n)<<\" \";\n  cout<<endl;\n}\n\nint  main()\n{\n  string str;\n  int n,q;\n  cin>>n>>q;\n  int i,j;\n  //入力\n  cin>>str;\n\n  Segment_Tree ST(n);\n  int sum;\n  \n  rep(i,str.size())\n    {\n      if(str[i]=='('){\n\tST.add(i,n,1);\n      }\n      else\n\tST.add(i,n,-1);\n    }\n\n  rep(i,q)\n    {\n      int flip;\n      cin>>flip;\n      flip--;\n      if(str[flip]=='(')\n\t{\n\t  str[flip]=')';\n\t  int ans=str.find(')',0);\n\t  cout<<ans+1<<endl;\n\t  str[ans]='(';\n\t  ST.add(flip,n,-2);\n\t  ST.add(ans,n,+2);\n\t}\n      else\n\t{\n\t  str[flip]='(';\n\t  ST.add(flip,n,+2);\n\t  /* \n\t  int p=-1;\n\t  if(flip==n-1)p=flip;\n\t  else\n\t    do{p=str.find('(',p+1);}\n\t    while(ST.get_min(p,n)<2);\n\t  \n\t  */\n\t  //cout<<\"bf \"<<flip+1<<\"changed\"<<endl;\n\t  //debug_show(str,&ST,n);\n\t  \n\t  int p=0,e=n;\n\t  if(flip==n-1)p=flip;\n\t  else{\n\t    while(e>p+1){\n\t      if(ST.get_min((p+e)/2,n)<2)p=(p+e)/2;\n\t      else e=(p+e)/2;\n\t    }\n\t    p=str.find('(',p+1);\n\t  }\n\t  cout<<p+1<<endl;\n\t  str[p]=')';\n\t  ST.add(p,n,-2);\n\t  //puts(\"af\");\n\t  //debug_show(str,&ST,n);\n\n\t}\n    }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tinline int query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tinline void update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tinline int query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r * 2 - b1.query(0, r) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0);\n\t\t\td[l] = -1; b1.update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1);\n\t\t\td[pr] = 1; b1.update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n#define MAXN 350000\n#define INF 0x7fffffff\nint n, m, k;\nchar str[MAXN];\nint gap[MAXN] = {0, 1};\nstruct Node {\n\tint start, end;\n\tint minv, pos, add;\n\tint flag;\n} tree[MAXN<<2];\nvoid build (int o, int start, int end) {\n\ttree[o].start = start;\n\ttree[o].end = end;\n\ttree[o].add = 0;\n\tif (start == end) {\n\t\ttree[o].minv = gap[start];\n\t\ttree[o].pos = str[start] == ')' ? start : INF;\n\t\ttree[o].flag = o;\n\t\treturn;\n\t}\n\tint mid = (start + end) >> 1;\n\tbuild (o<<1, start, mid);\n\tbuild (o<<1|1, mid + 1, end);\n\ttree[o].pos = min (tree[o<<1].pos, tree[o<<1|1].pos);\n\ttree[o].minv = min (tree[o<<1].minv, tree[o<<1|1].minv);\n\ttree[o].flag = tree[o<<1|1].flag;\n}\nvoid amend (int o, int add) {\n\ttree[o].minv += add;\n\ttree[o].add += add;\n}\nvoid update (int o, int k, int add) {\n\tif (tree[o].start == tree[o].end) {\n\t\ttree[o].minv += add;\n\t\ttree[o].add = 0;\n\t\tstr[tree[o].start] = (str[tree[o].start] == ')' ? '(' : ')');\n\t\ttree[o].pos = (str[tree[o].start] == ')' ? tree[o].start : INF);\n\t\treturn;\n\t}\n\tif (k <= tree[o<<1].end) {\n\t\tamend (o<<1, tree[o].add);\n\t\tamend (o<<1|1, tree[o].add + add);\n\t\tupdate (o<<1, k, add);\n\t}\n\telse {\n\t\tamend (o<<1, tree[o].add);\n\t\tamend (o<<1|1, tree[o].add);\n\t\tupdate (o<<1|1, k, add);\n\t}\n\ttree[o].add = 0;\n\ttree[o].pos = min (tree[o<<1].pos, tree[o<<1|1].pos);\n\ttree[o].minv = min (tree[o<<1].minv, tree[o<<1|1].minv);\n}\nint query1 (int o, int k, int add) {\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].minv;\n\tif (k <= tree[o<<1].end)\n\t\treturn query1 (o<<1, k, add + tree[o].add);\n\treturn query1 (o<<1|1, k, add + tree[o].add);\n}\nint query (int o) {\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].start;\n\tif (tree[o<<1|1].minv >= 2 && query1(1, tree[tree[o<<1].flag].start, 0) >= 2) {\n\t\t//printf (\"%d %d %d %d\\n\", o, tree[o<<1].flag, tree[tree[o<<1].flag].start ,query1(1, tree[tree[o<<1].flag].start, 0));         \n\t\treturn query (o<<1);\n\t}\n\treturn query (o<<1|1);\n}\nint main () {\n#ifdef TXT\n\tfreopen (\"in.txt\", \"r\", stdin);\n#endif\n\twhile (~scanf (\"%d%d\", &n, &m)) {\n\t\tscanf (\"%s\", str + 1);\n\t\tfor (int i = 2; i <= n; i ++)\n\t\t\tgap[i] = gap[i - 1] + (str[i] == str[1] ? 1 : -1);\n\t\tfor (int i = 2; i <= n; i ++)\n\t\t\tgap[i] = abs (gap[i]);\n\t\tbuild (1, 1, n);\n\t\twhile (m --) {\n\t\t\tscanf (\"%d\", &k);\n\t\t\t//for (int i = 1; i <= n; i ++)\n\t\t\t//\tprintf (\"%d \", query1 (1, i, 0));\n\t\t\t//printf (\"\\n\");\n\t\t\tupdate (1, k, str[k] == ')' ? 2 : -2);\n\t\t\t//printf (\"%d\\n\", query1 (1, 2, 0));\n\t\t\t//printf (\"%s\\n\", str + 1);\n\t\t\t//for (int i = 1; i <= n; i ++)\n\t\t\t//\tprintf (\"%d \", query1 (1, i, 0));\n\t\t\t//printf (\"\\n\");\n\t\t\tk = (str[k] == '(') ? query (1) : tree[1].pos;\n\t\t\tprintf (\"%d\\n\", k);\n\t\t\tupdate (1, k, str[k] == '(' ? -2 : 2);\n\t\t\t//printf (\"%s\\n\", str + 1);\n\t\t}\n\t\t//printf (\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; int i; bool used; };\n \nint MOD = 1000000007;\n\nstruct bit {\n\tvector<ll> v;\n\tbit(int n) : v(n + 1) {}\n\tll sum(int i) {\n\t\tll res = 0;\n\t\tfor (; i > 0; i -= i & -i) res += v[i];\n\t\treturn res;\n\t}\n\tvoid add(int i, ll x) {\n\t\tfor (i++; i < v.size(); i += i & -i) v[i] += x;\n\t}\n\tint lower_bound(ll x) {\n\t\tif (x <= 0) return 0;\n\t\tint res = 0;\n\t\tfor (int i = 1 << 24; i > 0; i >>= 1)\n\t\t\tif (res + i < v.size() && v[res + i] < x) {\n\t\t\t\tres += i; x -= v[res];\n\t\t\t}\n\t\treturn res + 1;\n\t}\n};\n\nint N, Q;\nstring s;\n\nvoid flip(int i, bit& a, bit& b, bit& c) {\n\tif (s[i] == '(') {\n\t\ts[i] = ')';\n\t\ta.add(i, -2);\n\t\tb.add(i, 1);\n\t\tif (i - 2 >= 0 && s[i - 2] == '(' && s[i - 1] == '(') c.add(i - 2, -1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(' && i + 1 < N && s[i + 1] == '(') c.add(i - 1, -1);\n\t\tif (i + 2 < N && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, -1);\n\t}\n\telse {\n\t\ts[i] = '(';\n\t\ta.add(i, 2);\n\t\tb.add(i, -1);\n\t\tif (i - 2 >= 0 && s[i - 2] == '(' && s[i - 1] == '(') c.add(i - 2, 1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(' && i + 1 < N && s[i + 1] == '(') c.add(i - 1, 1);\n\t\tif (i + 2 < N && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, 1);\n\t}\n}\n\nbool check(string& s) {\n\tint n = s.length();\n\tint lev = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == '(') lev++;\n\t\telse lev--;\n\t\tif (lev < 0) return false;\n\t}\n\tif (lev != 0) return false;\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> Q >> s;\n\tbit a(N), b(N), c(N);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == '(') a.add(i, 1);\n\t\telse a.add(i, -1);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == ')') b.add(i, 1);\n\tfor (int i = 0; i < N - 2; i++)\n\t\tif (s[i] == '(' && s[i + 1] == '(' && s[i + 2] == '(') c.add(i, 1);\n\twhile (Q--) {\n\t\tint i; cin >> i; i--;\n\t\tstring t = s;\n\t\tstring _s = s;\n\t\tif (_s[i] == '(') _s[i] = ')';\n\t\telse _s[i] = '(';\n\t\tint ans2;\n\t\tfor (int j = 0; j < s.length(); j++) {\n\t\t\tif (_s[j] == '(') _s[j] = ')';\n\t\t\telse _s[j] = '(';\n\t\t\tif (check(_s)) {\n\t\t\t\tans2 = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (_s[j] == '(') _s[j] = ')';\n\t\t\telse _s[j] = '(';\n\t\t}\n\t\tint ans;\n\t\tif (s[i] == '(') {\n\t\t\tflip(i, a, b, c);\n\t\t\tint j = b.lower_bound(1) - 1;\n\t\t\tflip(j, a, b, c);\n\t\t\tcout << j + 1 << endl;\n\t\t\tans = j;\n\t\t}\n\t\telse {\n\t\t\tif (a.sum(i + 1) == 0) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tans = i;\n\t\t\t}\n\t\t\telse if (a.sum(i) == 2) {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tcout << i << endl;\n\t\t\t\tflip(i - 1, a, b, c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tint j = c.lower_bound(1) - 1;\n\t\t\t\tflip(j + 1, a, b, c);\n\t\t\t\tcout << j + 2 << endl;\n\t\t\t\tans = j + 1;\n\t\t\t}\n\t\t}\n\t\t/*if (ans != ans2) {\n\t\t\tcout << t << endl;\n\t\t\tcout << ans <<  ' ' << ans2 << endl;\n\t\t\tcout << \"error\" << endl;\n\t\t}*/\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nstruct SegmentTree\n{\n  const int INF = 1 << 30;\n \n  vector< int > small, add;\n  int sz;\n \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, 0);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n};\n\nint main()\n{\n  int N, Q;\n\n  scanf(\"%d %d\", &N, &Q);\n  char S[300001];\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      close.insert(q);\n      S[q] = ')';\n      printf(\"%d\\n\", *close.begin() + 1);\n      tree.RangeAdd(*close.begin(), N, +2);\n      S[*close.begin()] = '(';\n      close.erase(close.begin());\n    } else {\n      close.erase(q);\n      S[q] = '(';\n      int low = -1, high = N - 1;\n      while(high - low > 1) {\n        int mid = (low + high) >> 1;\n        if(tree.RangeMinimumQuery(mid, N) >= 2) high = mid;\n        else low = mid;\n      }\n      while(S[q] == ')') ++high;\n      printf(\"%d\\n\", high + 1);\n      tree.RangeAdd(high, N, -2);\n      S[high] = ')';\n      close.insert(high);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;  // 対象区間とノードの区間が交わらないなら処理をしない\n    process_lazy(k);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k) {\n    if (k < n - 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k) {\n    if (k >= n - 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,b)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int b, int k, int l, int r, int val) {\n    if (b <= l) return -2;\n    process_lazy(k);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    int ret_r = getLeftGt(b, RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2 || ret_r == -1) return ret_r;\n    int ret_l = getLeftGt(b, LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(n, 0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;\n    process_lazy(k);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k) {\n    if (k < n - 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k) {\n    if (k >= n - 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n\n  // 区間[x,b)がval以上になる最小のxを返す\n  // 存在しなければ-1\n  int getLeftGt(int b, int k, int l, int r, int val) {\n    if (b <= l) return -2;\n    process_lazy(k);\n    if (tree[k].min >= val) return l;\n    if (r-l == 1) return -1;\n    int ret_r = getLeftGt(b, RC(k), (l + r) / 2, r, val);\n    if (ret_r > (l + r) / 2 || ret_r == -1) return ret_r;\n    int ret_l = getLeftGt(b, LC(k), l, (l + r) / 2, val);\n    if (ret_l == -1) return ret_r;\n    return ret_l;\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n\n    if (s[qq] == '(') {\n      // '(' to ')'\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      // ')' to '('\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int best = tree.getLeftGt(n, 0, 0, nPow2, 2);\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tif(l < r){\n\t\t\t\tdelay[k*2] += delay[k];\n\t\t\t\tdelay[k*2+1] += delay[k];\n\t\t\t\tdelay[k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tif(cand.count(p)) cand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int INF = 1<<28;\n\nclass SegTree{\n\ttypedef int SegT;\n\tstatic const int defvalue = INF;\n\tprivate:\n\t\tvector<SegT> val, lazy;\n\t\tvector<int> lazyf;\n\t\tint n;\n\t\t\n\t\tSegT combine(SegT a, SegT b){\n\t\t\treturn min(a, b);\n\t\t}\n\t\tSegT merge(SegT a, SegT b){\n\t\t\treturn a+b;\n\t\t}\n\t\t\n\t\tvoid applyLazy(int k){\n\t\t\tif(lazyf[k]){\n\t\t\t\tlazyf[k] = 0;\n\t\t\t\tval[k] = merge(val[k], lazy[k]);\n\t\t\t\tif(k*2+2 < lazy.size()){\n\t\t\t\t\tlazy[k*2+1] = lazyf[k*2+1] ? merge(lazy[k*2+1], lazy[k]) : lazy[k];\n\t\t\t\t\tlazy[k*2+2] = lazyf[k*2+2] ? merge(lazy[k*2+2], lazy[k]) : lazy[k];\n\t\t\t\t\tlazyf[k*2+1] = lazyf[k*2+2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tSegTree(int size){\n\t\t\tn=1;\n\t\t\twhile(n<size)n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, 0);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t}\n\t\tSegTree(const vector<SegT> &in){\n\t\t\tn=1;\n\t\t\twhile(n<in.size())n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, -1);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t\tfor(int i=n-1 + in.size()-1;i>=0;i--){\n\t\t\t\tif(n-1 <= i) val[i] = in[i - (n-1)];\n\t\t\t\telse val[i] = combine(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\t//i 番目の要素を a に更新する\n\t\tvoid update(int i,SegT a){\n\t\t\ti+=n-1;\n\t\t\tval[i]=a;\n\t\t\twhile(i>0){\n\t\t\t\ti=(i-1)/2;\n\t\t\t\tval[i]=merge(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値をaに更新する\n\t\tvoid update(int a,int b,SegT x,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l) return;\n\t\t\tapplyLazy(k);\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\tlazy[k] = x;\n\t\t\t\tlazyf[k] = 1;\n\t\t\t}else{\n\t\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t\t\tval[k] = combine(val[k*2+1], val[k*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値を取ってくる\n\t\tSegT query(int a,int b,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l) return defvalue;\n\t\t\tapplyLazy(k);\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\treturn val[k];\n\t\t\t}else{\n\t\t\t\treturn combine(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tcout << val << endl;\n\t\t\tcout << lazy << endl;\n\t\t\tcout << lazyf << endl;\n\t\t}\n};\n\n\nint n, m;\nstring s;\nmain(){\n\tios::sync_with_stdio(false);\n\tset<int> close;\n\tcin >> n >> m >> s;\n\tvi d(s.size());\n\tREP(i, s.size()){\n\t\td[i] = (i?d[i-1]:0) + (s[i]=='(' ? 1 : -1);\n\t\tif(s[i]==')') close.insert(i);\n\t}\n\t\n\tSegTree seg(d);\n\t\n\tREP(q, m){\n\t\tint t;\n\t\tcin >> t;t--;\n\t\tif(s[t] == '('){\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tint t = *close.begin();\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\tcout << t+1 << endl;\n\t\t}else if(s[t] == ')'){\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\t\n\t\t\tint l=0, r=t;\n\t\t\twhile(l<r-1){\n\t\t\t\tint med=(l+r)/2;\n\t\t\t\tif(seg.query(med, t) <= 1) l = med;\n\t\t\t\telse r = med;\n\t\t\t}\n\t\t\tint t = r;\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tcout << t+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\nconst int MAX_N = 300000;\n\nconst int INF = 1e9;\nconst int sqrtN = 700;\n\nint data[(MAX_N + sqrtN - 1) / sqrtN * sqrtN];\nint add[(MAX_N + sqrtN - 1) / sqrtN];\nint min1[(MAX_N + sqrtN - 1) / sqrtN];\n\nstruct SegmentArray1 {\n  const int B;\n  SegmentArray1(int n) : B((n + sqrtN - 1) / sqrtN) { }\n  void update(int a, int b, int v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      min1[k] = INF;\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        if(st <= i && i < en) data[i] += v;\n        if(min1[k] > data[i]) min1[k] = data[i];\n      }\n    }\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min1[k] < 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] < 2) {\n              return k * sqrtN + j + 1;\n            }\n          }\n        }\n      }\n      int st = std::max(a, l), en = std::min(b, r);\n      for(int i = en - 1; i >= st; --i) {\n        if(add[k] + data[i] < 2) {\n          return i + 1;\n        }\n      }\n    }\n  }\n};\n\nchar S[300001];\n\nint main() {\n  int N, Q; scanf(\"%d%d\", &N, &Q);\n  scanf(\"%s\", S);\n  SegmentArray1 seg1(N);\n  set<int> seg2;\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, N, (S[i] == '(' ? 1 : -1));\n    if(S[i] == ')') seg2.insert(i);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; scanf(\"%d\", &p);\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      seg2.insert(p);\n      seg1.update(p, N, -2);\n      int np = *seg2.begin();\n      S[np] = '(';\n      seg2.erase(np);\n      seg1.update(np, N, +2);\n      printf(\"%d\\n\", np + 1);\n    }\n    else {\n      S[p] = '(';\n      seg2.erase(p);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      S[np] = ')';\n      seg2.insert(np);\n      seg1.update(np, N, -2);\n      printf(\"%d\\n\", np + 1);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\n#define  MAXN    300010\nusing namespace std;\nstruct SegTree {\n       int left, right, mid, val, add;\n       SegTree () {}\n} tree[MAXN<<1];\nchar str[MAXN];\nint n, q, prefix[MAXN];\ninline int LC(int x) { return x<<1; }\ninline int RC(int x) { return x<<1|1; }\ninline void push_down (int rt) {\n     if (tree[rt].add == 0) \n        return;  \n     tree[rt].val += tree[rt].add;\n     if (tree[rt].left != tree[rt].right) {\n        tree[LC(rt)].add += tree[rt].add;\n        tree[RC(rt)].add += tree[rt].add;\n     }\n     tree[rt].add = 0;  \n}\ninline void push_up (int rt) {  \n     tree[rt].val = min((tree[LC(rt)].val+tree[LC(rt)].add),\n     (tree[RC(rt)].val+tree[RC(rt)].add))+tree[rt].add;\n}\nvoid makeTree (int L,int R,int rt) {\n     tree[rt].left = L;\n     tree[rt].right = R;\n     tree[rt].mid = (L+R)>>1;\n     tree[rt].add = 0;     \n     if (L == R) {\n        tree[rt].val = prefix[L+1];\n        return ;\n     } \n     int mid = tree[rt].mid;\n     makeTree (L,mid,LC(rt));\n     makeTree (mid+1,R,RC(rt));\n     push_up (rt);    \n}\nvoid update (int L,int R,int rt,int x) {\n     push_down (rt);\n     if (L<= tree[rt].left && tree[rt].right<=R) {\n        tree[rt].add += x;\n        return ;\n     }\n     int mid = tree[rt].mid;\n     if (R <= mid) \n        update (L,R,LC(rt),x);\n     else if (L > mid)\n        update (L,R,RC(rt),x);\n     else {\n        update (L,R,LC(rt),x);       \n        update (L,R,RC(rt),x);  \n     }\n     push_up (rt);\n}\nint query (int L,int R,int rt) {\n     push_down (rt);\n     if (L<= tree[rt].left && tree[rt].right<=R) \n        return tree[rt].val;\n     int mid = tree[rt].mid, tmp;\n     if (R <= mid)\n        tmp = query(L,R,LC(rt));\n     else if (L > mid)\n        tmp = query(L,R,RC(rt));\n     else\n        tmp = min( query(L,R,LC(rt)), query(L,R,RC(rt)) );\n     return tmp;   \n}\nvoid fix (set<int> &prev,set<int> &next,char before,int x) {\n     prev.erase(x);\n     next.insert(x);\n     int p, b = ( before == '(' ? -1 : 1 );\n     str[x] = ( before == '(' ? ')': '(' );\n     update (x,n-1,1,2*b);\n     int l = 0, r = x;\n     while (l < r) {\n           int mid = (l+r)>>1;\n           p = *next.lower_bound(mid);\n           if (query(p,n-1,1) >= 2*b)\n              r = mid;\n           else\n              l = mid+1;    \n     }     \n     p = *next.lower_bound(l);\n     update (p,n-1,1,-2*b);\n     next.erase (p);\n     prev.insert (p);\n     str[p] = before;\n     printf (\"%d\\n\",p+1);\n}\nint main(void) {\n    while ( scanf(\"%d%d\",&n,&q)==2 ) {\n          scanf (\"%s\",str);\n          int x;\n          set <int> left, right;\n          prefix[0] = 0;\n          for (int i=0;i<n;++i)\n              if (str[i] == '(') {\n                 prefix[i+1] = prefix[i]+1;\n                 left.insert (i);        \n              }\n              else {\n                 prefix[i+1] = prefix[i]-1;\n                 right.insert (i);  \n              }  \n          makeTree (0,n-1,1);              \n          for (int i=0;i<q;++i) {\n              scanf (\"%d\",&x);\n              x--;\n              if (str[x] == '(') \n                 fix(left,right,str[x],x);\n              else if (str[x] == ')')\n                 fix(right,left,str[x],x); \n          }\n    }\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tinline int query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tinline void update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tinline int query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tbit b2(n); for (int i = 0; i < n; i++) b2.update(i, d[i]);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = b2.query(0, r), pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0); b2.update(r, 1);\n\t\t\td[l] = -1; b1.update(l, 1); b2.update(l, -1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1); b2.update(r, -1);\n\t\t\td[pr] = 1; b1.update(pr, 0); b2.update(pr, 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define MAXN 301000\nint n;\nchar str[MAXN];\nint diff[MAXN];\nstruct Node {\n\tint start, end;\n\tint minv, flag, add;\n\tvoid operator += (const int& val) {\n\t\tminv += val;\n\t\tflag += val;\n\t\tadd += val;\n\t}\n} tree[MAXN<<2];\nvoid pushdown (int o) {\n\tif (tree[o].add) {\n\t\ttree[o<<1] += tree[o].add;\n\t\ttree[o<<1|1] += tree[o].add;\n\t\ttree[o].add = 0;\n\t}\n}\nvoid pushup (int o) {\n\ttree[o].minv = min(tree[o<<1].minv, tree[o<<1|1].minv);\n\ttree[o].flag = min(tree[o<<1].flag, tree[o<<1|1].flag);\n}\nvoid build (int o, int start, int end) {\n\ttree[o].start = start;\n\ttree[o].end = end;\n\ttree[o].add = 0;\n\tif (start == end) {\n\t\ttree[o].flag = diff[start] - start;\n\t\ttree[o].minv = diff[start];\n\t\treturn;\n\t}\n\tint mid = (start + end) >> 1;\n\tbuild(o<<1, start, mid);\n\tbuild(o<<1|1, mid + 1, end);\n\tpushup(o);\n}\nvoid update (int o, int pos, int val) {\n\t//printf (\"%d %d %d\\n\", tree[o<<1].start, tree[o].end, pos);\n\tif (pos <= tree[o].start) {\n\t\ttree[o] += val;\n\t\treturn;\n\t}\n\tpushdown(o);\n\tif (pos <= tree[o<<1].end)\n\t\tupdate(o<<1, pos, val);\n\tupdate(o<<1|1, pos, val);\n\tpushup (o);\n}\nint query1 (int o) {\n\t//printf (\"%d: %d %d %d\\n\", 1, tree[o].start, tree[o].end, tree[o<<1].flag);\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].start;\n\tpushdown(o);\n\tint r;\n\tif (tree[o<<1].flag < 0)\n\t\tr = query1(o<<1);\n\telse\n\t\tr = query1(o<<1|1);\n\tpushup(o);\n\treturn r;\n}\nint query2(int o) {\n\t//printf (\"%d: %d %d %d\\n\", 2, tree[o].start, tree[o].end, tree[o<<1].minv);\n\tif (tree[o].start == tree[o].end)\n\t\treturn tree[o].minv < 2 ? INF : tree[o].start;\n\tpushdown(o);\n\tint r;\n\tif (tree[o<<1|1].minv < 2)\n\t\tr = query2(o<<1|1);\n\telse\n\t\tr = min(query2(o<<1), tree[o<<1|1].start);\n\tpushup(o);\n\treturn r;\n}\nint main () {\n#ifdef TXT\n\tfreopen (\"in.txt\", \"r\", stdin);\n#endif\n\tint q, pos;\n\twhile (~scanf (\"%d%d\", &n, &q)) {\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tdiff[i] = diff[i - 1] + (str[i] == '(' ? 1 : -1);\n\t\t//for (int i = 1; i <= n; i ++)\n\t\t//\tprintf (\"%d \", diff[i]);\n\t\t//printf (\"\\n\");\n\t\tbuild(1, 1, n);\n\t\tquery1(1);\n\t\twhile (q --) {\n\t\t\tscanf (\"%d\", &pos);\n\t\t\tupdate(1, pos, str[pos] == '(' ? -2 : 2);\n\t\t\tstr[pos] = str[pos] == ')' ? '(' : ')';\n\t\t\tpos = str[pos] == ')' ? query1(1) : query2(1);\n\t\t\t//printf (\"%d %s\\n\", pos, str + 1);\n\t\t\tupdate(1, pos, str[pos] == '(' ? -2 : 2);\n\t\t\tstr[pos] = str[pos] == ')' ? '(' : ')';\n\t\t\tprintf (\"%d\\n\", pos);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n#define lch (id<<1)\n#define rch ((id<<1)|1)\nconst int maxn=300000+100;\nconst int INF=1e9+10;\nchar kuo[maxn];\nint sum[maxn];\nint minv[maxn<<2],maxv[maxn<<2],lazy[maxn<<2];\nvoid build(int id,int l,int r)\n{\n\tlazy[id]=0;\n\tif(l==r)\n\t\tminv[id]=maxv[id]=sum[l];\n\telse\n\t{\n\t\tint mid=l+r>>1;\n\t\tbuild(lch,l,mid);\n\t\tbuild(rch,mid+1,r);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nvoid pushdown(int id)\n{\n\tminv[lch]+=lazy[id];maxv[lch]+=lazy[id];lazy[lch]+=lazy[id];\n\tminv[rch]+=lazy[id];maxv[rch]+=lazy[id];lazy[rch]+=lazy[id];\n\tlazy[id]=0;\n}\nvoid update(int id,int l,int r,int L,int R,int v)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tminv[id]+=v;\n\t\tmaxv[id]+=v;\n\t\tlazy[id]+=v;\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid)update(lch,l,mid,L,R,v);\n\t\tif(R>mid)update(rch,mid+1,r,L,R,v);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_minv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)return l;\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(l==r)return l;\n\t\telse if(minv[rch]==0)return query_minv(rch,mid+1,r,L,R);\n\t\telse return query_minv(lch,l,mid,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\t//cout <<l<<\" \"<<mid<<\" \"<<r<<\" \"<<L<<\" \"<<R<<\" \"<<minv[rch]<<endl;\n\t\tif(R<=mid)return query_minv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_minv(rch,mid+1,r,L,R);\n\t\telse if(minv[rch]==0)return query_minv(rch,mid+1,r,L,R);\n\t\telse return query_minv(lch,l,mid,L,R);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query_maxv(int id,int l,int r,int L,int R)\n{\n\tint mid=l+r>>1;\n\tif(l==r)return l;\n\telse if(L<=l&&r<=R)\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(l==r)return l;\n\t\telse if(maxv[lch]>=2)return query_maxv(lch,l,mid,L,R);\n\t\telse return query_maxv(rch,mid+1,r,L,R);\n\t}\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tif(R<=mid)return query_maxv(lch,l,mid,L,R);\n\t\telse if(L>mid)return query_maxv(rch,mid+1,r,L,R);\n\t\telse if(maxv[lch]>=2)return query_maxv(lch,l,mid,L,R);\n\t\telse return query_maxv(rch,mid+1,r,L,R);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nint query(int id,int l,int r,int pos)\n{\n\tif(l==r)return minv[id];\n\telse\n\t{\n\t\tif(lazy[id]!=0)pushdown(id);\n\t\tint mid=l+r>>1;\n\t\tif(pos<=mid)return query(lch,l,mid,pos);\n\t\telse return query(rch,mid+1,r,pos);\n\t\tminv[id]=min(minv[lch],minv[rch]);\n\t\tmaxv[id]=max(maxv[lch],maxv[rch]);\n\t}\n}\nset<int> qn;\nint main()\n{\n\tint i,pos,n,q,l,r;\n\tscanf(\"%d %d\",&n,&q);\n\tscanf(\"%s\",kuo+1);\n\tmemset(sum,0,sizeof(sum));\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tif(kuo[i]=='(')sum[i]=sum[i-1]+1;\n\t\telse \n\t\t{\n\t\t\tsum[i]=sum[i-1]-1;\n\t\t\tqn.insert(i);\n\t\t}\n\t}\n\tbuild(1,0,n);\n\t//for(int j=0;j<=n;j++)cout <<sum[j]<<\" \";cout <<endl;\n\t//for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\tfor(i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d\",&pos);\n\t\tif(kuo[pos]=='(')\t\t\n\t\t{\n\t\t\tkuo[pos]=')';\n\t\t\tupdate(1,0,n,pos,n,-2);\n\t\t\tqn.insert(pos);\n\t\t\tpos=*qn.lower_bound(0);\n\t\t\tqn.erase(pos);\n\t\t\tkuo[pos]='(';\n\t\t\tupdate(1,0,n,pos,n,2);\n\t\t\tprintf(\"%d\\n\",pos);\n\t\t}\n\t\telse if(kuo[pos]==')')\n\t\t{\n\t\t\tif(query(1,0,n,pos)==0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tkuo[pos]='(';\n\t\t\t\tqn.erase(pos);\n\t\t\t\tupdate(1,0,n,pos,n,2);\t\n\t\t\t\tl=query_minv(1,0,n,0,pos);\n\t\t\t\tr=query_maxv(1,0,n,l+1,pos);\n\t\t\t\tupdate(1,0,n,r,n,-2);\n\t\t\t\tqn.insert(r);\n\t\t\t\t//cout <<kuo[r]<<\" \"<<l<<\" \"<<r<<endl;\n\t\t\t\tkuo[r]=')';\n\t\t\t\tprintf(\"%d\\n\",r);\n\t\t\t}\n\t\t}\n\t\t//printf(\"%s\\n\",kuo+1);for(int j=0;j<=n;j++)cout <<query(1,0,n,j)<<\" \";cout <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <ctype.h>\n#include <limits.h>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <stack>\n#include <set>\n#include <bitset>\n#define CLR(a) memset(a, 0, sizeof(a))\n#define REP(i, a, b) for(int i = a;i < b;i++)\n#define REP_D(i, a, b) for(int i = a;i <= b;i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int maxn = 300000 + 100;\nconst int INF = 0;\nconst int MAX_NODE = maxn*4 + 10;\n\nint tree[MAX_NODE], late[MAX_NODE];\nchar s[maxn];\nint a[maxn];\nint n, rtn, q;\nset<int> you;\n\nvoid pushUp(int rt)\n{\n    int lRt = (rt<<1), rRt = ((rt<<1)|1);\n    tree[rt] = min(tree[lRt], tree[rRt]);\n}\n\nvoid initail()\n{\n    CLR(late);\n    rtn = 1;\n    while(rtn < n)\n    {\n        rtn <<= 1;\n    }\n    for(int i = 1;i<=n;i++)\n    {\n        tree[i+rtn-1] = a[i];\n    }\n    for(int i = rtn+n;i<rtn*2;i++)\n    {\n        tree[i] = 1e9;\n    }\n    for(int i = rtn-1;i>=1;i--)\n    {\n        pushUp(i);\n    }\n}\n\nvoid pushDown(int rt)\n{\n    if(late[rt] == INF)\n        return;\n    int lRt = (rt<<1), rRt = ((rt<<1)|1);\n    int key = late[rt];\n    late[rt] = INF;\n    late[lRt] += key;\n    tree[lRt] += key;\n    late[rRt] += key;\n    tree[rRt] += key;\n}\n\n\nvoid change(int L, int R, int key, int rt, int l, int r)\n{\n    if(L <= l && R >= r)\n    {\n        late[rt] += key;\n        tree[rt] += key;\n        return;\n    }\n    pushDown(rt);\n    int mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(L <= mid)\n    {\n        change(L, R, key, lRt, l, mid);\n    }\n    if(R >= mid + 1)\n    {\n        change(L, R, key, rRt, mid + 1, r);\n    }\n    pushUp(rt);\n}\nint query(int rt, int l, int r)\n{\n    if(l==r)\n    {\n        return l;\n    }\n    pushDown(rt);\n    int mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(tree[rRt] >= 2)\n    {\n        return query(lRt, l, mid);\n    }\n    else\n    {\n        return query(rRt, mid+1, r);\n    }\n}\n\n\n\nint query(int L, int R, int rt, int l, int r)\n{\n    if(L <= l && R >= r)//全包括\n    {\n        return tree[rt];\n    }\n    pushDown(rt);//下一次?延?\n    int ans = INF, mid = ((l + r)>>1), lRt = (rt<<1), rRt = ((rt<<1)|1);\n    if(L <= mid)\n    {\n        ans = min(ans, query(L, R, lRt, l, mid));\n    }\n    if(R >= mid + 1)\n    {\n        ans = min(ans, query(L, R, rRt, mid + 1, r));\n    }\n    return ans;\n}\n\nvoid solve()\n{\n    you.clear();\n    a[0] = 0;\n    for(int i = 1;i<=n;i++)\n    {\n        a[i] = a[i-1];\n        if(s[i]=='(')\n        {\n            a[i]++;\n        }\n        else\n        {\n            you.insert(i);\n            a[i]--;\n        }\n    }\n    initail();\n    int ans;\n    while(q--)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        if(s[x] == '(')\n        {\n            s[x] = ')';\n            change(x, n, -2, 1, 1, rtn);\n            you.insert(x);\n            ans = (*you.begin());\n            printf(\"%d\\n\", ans);\n            s[ans] = '(';\n            change(ans, n, 2, 1, 1, rtn);\n            you.erase(you.begin());\n        }\n        else\n        {\n            s[x] = '(';\n            change(x, n, 2, 1, 1, rtn);\n            you.erase(x);\n            ans = query(1, 1, rtn);\n            ans++;\n            printf(\"%d\\n\", ans);\n            s[ans] = ')';\n            change(ans, n, -2, 1, 1, rtn);\n            you.insert(ans);\n        }\n    }\n}\n\nint main()\n{\n   // freopen(\"7Gin.txt\", \"r\", stdin);\n    //freopen(\"7Gout.txt\", \"w\", stdout);\n    while(scanf(\"%d%d\", &n, &q)!=EOF)\n    {\n        scanf(\"%s\", s+1);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\ntemplate<typename Type> class StarrySkyTree {\npublic:\n\tunsigned size_; std::vector<Type> dat1, dat2, dat;\n\tinline void update_(unsigned a, unsigned b, Type x, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat2[k] += x; return;\n\t\t}\n\t\tupdate_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tupdate_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\tdat1[k] = std::min(dat1[k << 1] + dat2[k << 1], dat1[(k << 1) + 1] + dat2[(k << 1) + 1]);\n\t}\n\tinline Type query_(unsigned a, unsigned b, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return std::numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat1[k] + dat2[k];\n\t\tType lc = query_(a, b, (k << 1), l, (l + r) >> 1);\n\t\tType rc = query_(a, b, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn std::min(lc, rc) + dat2[k];\n\t}\n\t//StarrySkyTree() : size_(0), dat(std::vector<Type>()) {};\n\tStarrySkyTree(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat1.resize(size_ << 1, 0);\n\t\tdat2.resize(size_ << 1, 0);\n\t\tdat.resize(size_ << 1, 0);\n\t}\n\ttemplate<class T>\n\tStarrySkyTree(T begin_, T end_) {\n\t\tunsigned n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::numeric_limits<Type>::max());\n\t\tfor (unsigned i = 0; i < n; i++) dat[i + size_] = *(begin_ + i);\n\t\tfor (unsigned i = size_ - 1; i > 0; i--) dat[i] = std::min(dat[i << 1], dat[(i << 1) + 1]);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void add(unsigned i, Type x) {\n\t\tupdate_(i, i + 1, x, 1, 0, size_);\n\t}\n\tinline void add(unsigned l, unsigned r, Type x) {\n\t\tupdate_(l, r, x, 1, 0, size_);\n\t}\n\tinline Type query(unsigned l, unsigned r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\n\nstring S; int N, Q, P;\nStarrySkyTree<int> X(1);\n\nint solve(int pos) {\n\tint I1 = X.query(pos, pos + 1); // pos の depth\n\tint I2 = X.query(pos + 1, pos + 2); // pos + 1 の depth\n\n\tif (I1 > I2) {\n\t\t// もともと ')' だった : ')' -> '('\n\t\tX.add(pos + 1, N + 1, 2);\n\t\tint L = 0, R = N + 1, M, minx = N + 1;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tint B = X.query(M, N + 1);\n\t\t\tif (B >= 2) { minx = min(minx, M); R = M; }\n\t\t\telse { L = M; }\n\t\t}\n\t\tX.add(minx, N + 1, -2);\n\t\treturn minx - 1;\n\t}\n\telse {\n\t\t// もともと '(' だった : '(' -> ')'\n\t\tX.add(pos + 1, N + 1, -2);\n\t\tint L = 0, R = N + 1, M, minx = N + 1;\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tM = (L + R) / 2;\n\t\t\tint B = X.query(M, M + 1);\n\t\t\tif (M != B) { minx = min(minx, M); R = M; }\n\t\t\telse { L = M; }\n\t\t}\n\t\tX.add(minx, N + 1, 2);\n\t\treturn minx - 1;\n\t}\n}\n\nint main() {\n\tcin >> N >> Q >> S;\n\tX = StarrySkyTree<int>(N + 1);\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == '(') X.add(i + 1, N + 1, 1);\n\t\tif (S[i] == ')') X.add(i + 1, N + 1, -1);\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcin >> P; P--;\n\t\tcout << solve(P) + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct starrysky{\n  int n;\n  starrysky(){}\n  starrysky(int n_){init(n_);};\n  vector<int> data,datm;\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data.clear();\n    datm.clear();\n    data.resize(2*n-1,0);\n    datm.resize(2*n-1,0);\n  }\n  void add(int a,int b,int x,int l,int r,int k){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      data[k]+=x;\n      return;\n    }\n    add(a,b,x,l,(l+r)/2,k*2+1);\n    add(a,b,x,(l+r)/2,r,k*2+2);\n    datm[k]=min(datm[k*2+1]+data[k*2+1],datm[k*2+2]+data[k*2+2]);\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,n,0);\n  }\n  int query(int a,int b,int l,int r,int k){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b){\n      return data[k]+datm[k];\n    }\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2))+data[k];\n  }\n  int query(int a,int b){\n    return query(a,b,0,n,0);\n  }\n};\n#define MAX 333333\nstring buf;\nint dp[MAX],imos[MAX];\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  cin>>buf;\n  set<int> s;\n  for(int i=0;i<n;i++) {\n    if(buf[i]=='(') dp[i]=1;\n    else dp[i]=-1;\n    if(buf[i]==')') s.insert(i);\n  }\n  imos[0]=dp[0];\n  for(int i=1;i<n;i++) imos[i]=imos[i-1]+dp[i];\n  starrysky ss(n);\n  for(int i=0;i<n;i++) ss.add(i,i+1,imos[i]);\n  for(int i=0;i<q;i++){\n    int p;cin>>p;p--;\n    if(dp[p]==1){\n      dp[p]*=-1;\n      s.insert(p);\n      ss.add(p,n,-2);\n      int k=*s.begin();\n      s.erase(k);\n      dp[k]*=-1;\n      ss.add(k,n,2);\n      cout<<k+1<<endl;\n    }else{\n      //cout<<p<<endl;\n      dp[p]*=-1;\n      s.erase(p);\n      ss.add(p,n,2);\n      int l=0,r=p;\n      while(l+1<r){\n\tint m=(l+r)/2;\n\t//cout<<m<<\":\"<<ss.query(m,n)<<endl;\n\tif(ss.query(m,n)>=2) r=m;\n\telse l=m;\n      }\n      cout<<r+1<<endl;\n      dp[r]*=-1;\n      s.insert(r);\n      ss.add(r,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define DEBUG(x) cerr << \"L\" << __LINE__ << \" \" << #x << \" = \" << x << endl\n\ntypedef long long ll;\n\nconst ll INF = (ll)1e18;\nconst int sqrtN = 550;\n\nstruct SegmentArray1 {\n  int B;\n  vector<ll> data;\n  vector<ll> add;\n  vector<ll> min;\n  SegmentArray1(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, 0);\n    add.assign(B, 0);\n    min.assign(B, 0);\n  }\n  void update(int a, int b, ll v) {\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        add[k] += v;\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        data[i] += v;\n      }\n      min[k] = INF;\n      for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        min[k] = std::min(min[k], data[i]);\n      }\n    }\n  }\n  ll query(int a, int b) {\n    ll ret = INF;\n    for(int k = 0; k < B; ++k) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        ret = std::min(ret, add[k] + min[k]);\n        continue;\n      }\n      for(int i = std::max(a, l); i < std::min(b, r); ++i) {\n        ret = std::min(ret, add[k] + data[i]);\n      }\n    }\n    return ret;\n  }\n  int search(int p) {\n    int a = 0;\n    int b = p + 1;\n    for(int k = B - 1; k >= 0; k--) {\n      int l = k * sqrtN, r = (k + 1) * sqrtN;\n      if(r <= a || b <= l) continue;\n      if(a <= l && r <= b) {\n        if(add[k] + min[k] <= 2) {\n          for(int j = sqrtN - 1; j >= 0; --j) {\n            if(add[k] + data[k * sqrtN + j] <= 2) {\n              return k * sqrtN + j;\n            }\n          }\n        }\n      }\n      //DEBUG(k);\n      for(int i = std::min(b, r) - 1; i >= std::max(a, l); --i) {\n        //DEBUG(i);\n        //DEBUG(add[k] + data[i]);\n        if(add[k] + data[i] <= 2) {\n          return i;\n        }\n      }\n    }\n  }\n};\n\nstruct SegmentArray2 {\n  int B;\n  vector<bool> data;\n  vector<bool> stat;\n  SegmentArray2(int n) {\n    B = (n + sqrtN - 1) / sqrtN;\n    data.assign(B * sqrtN, false);\n    stat.assign(B, false);\n  }\n  void update(int p, bool v) {\n    data[p] = v;\n    int k = p / sqrtN;\n    stat[k] = false;\n    for(int i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n      stat[k] = stat[k] || data[i];\n    }\n  }\n  int search() {\n    for(int i = 0; i < B; ++i) {\n      if(stat[i]) {\n        for(int j = 0; j < sqrtN; ++j) {\n          int k = i * sqrtN + j;\n          if(data[k]) return k;\n        }\n      }\n    }\n    return -1;\n  }\n  void show() {\n  }\n};\n\nint main() {\n  // ios::sync_with_stdio(false);\n  int N, Q; cin >> N >> Q;\n  string S; cin >> S;\n  vector<int> SS(N);\n  SS[0] = (S[0] == '(' ? 1 : -1);\n  for(int i = 1; i < N; ++i) {\n    SS[i] = SS[i - 1] + (S[i] == '(' ? 1 : -1);\n  }\n  SegmentArray1 seg1(N);\n  SegmentArray2 seg2(N);\n  for(int i = 0; i < N; ++i) { \n    seg1.update(i, i + 1, SS[i]);\n    if(S[i] == ')') seg2.update(i, true);\n  }\n  for(int q = 0; q < Q; ++q) {\n    int p; cin >> p;\n    --p;\n    if(S[p] == '(') {\n      S[p] = ')';\n      // DEBUG(S);\n      seg2.update(p, true);\n      seg1.update(p, N, -2);\n      int np = seg2.search();\n      // DEBUG(np);\n      S[np] = '(';\n      seg2.update(np, false);\n      seg1.update(np, N, +2);\n      cout << np + 1 << endl;\n    }\n    else {\n      S[p] = '(';\n      // DEBUG(S);\n      seg2.update(p, false);\n      seg1.update(p, N, +2);\n      int np = seg1.search(p);\n      //DEBUG(np);\n      S[np] = ')';\n      seg2.update(np, true);\n      seg1.update(np, N, -2);\n      cout << np + 1 << endl;\n    }\n    // DEBUG(S);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (テヲツ環スティツアツ。テ」ツδサテヲツアツ偲・ツ個姪ゥツ??・ツサツカテ」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗ヲツ慊ィ)\n// Verified: AOJ テ」ツ?ョテ」ツつサテ」ツつーテヲツ慊ィ verify テ・ツ閉湘・ツ?ィテゥツδィ\n\nconst int SIZE = 1 << 19; // 2^17 = 131072\ntemplate<typename T>\nstruct lazysegtree {\n    // テ」ツδ偲」ツδシテ」ツδ嘉」ツ??・ツ債佚、ツスツ催・ツ??\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // テ」ツつェテ」ツδ堙」ツδャテ」ツδシテ」ツつキテ」ツδァテ」ツδウ (update, query テ」ツ?ョ 2 テ」ツ?、テ」ツ?古・ツソツ?ィツヲツ?ッツシツ?\n    // update function テ」ツ?ッテァツッツ?・ツ崢イテ」ツつ津ヲツ個?・ツョツ堙」ツ?凖」ツつ凝・ツスツ「テ」ツ?ォテ」ツ?療」ツつ暗」ツ??\n    // upd_f(X, Y, l, r) -> テァツッツ?・ツ崢イテ」ツ??[l, r) テ」ツ?ァテ」ツ?づ」ツつ凝」ツつ暗」ツ??」ツ?ェテ」ツδ偲」ツδシテ」ツδ?X テ」ツ?ォ Y テ」ツつ津・ツ渉催ヲツ伉?ッツシツ?\n    // lazy テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ update テ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテァツッツ?・ツ崢イテ」ツつ?1 テ」ツ?ォテ」ツ?療」ツ?ェテ」ツ??」ツ?ィテ」ツδ静」ツつーテ」ツつ甘」ツ?セテ」ツ??\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // テヲツシツ氾ァツョツ療・ツュツ静」ツ?ィテ・ツ債佚、ツスツ催・ツ?ε」ツつ津」ツつサテ」ツδε」ツδ暗」ツ?療」ツ??・ツ?ィテ」ツ?ヲテ」ツ?ョ node テ」ツ?ィ lazy テ」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X, vector<T> vec) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n\n        // vec テ」ツ?ョテ・ツ?、テ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n        for(size_t i=0; i<vec.size(); i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ・ツ?、 val テ」ツつ津・ツ渉催ヲツ伉?」ツ?陛」ツ?崚」ツつ?\n    // (upd_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツつッテ」ツつィテ」ツδェテ」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // (qry_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return INT_MAX;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    if(a == INT_MAX) return b;\n    return a + b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    lazysegtree<int> seg(add, qry, INT_MAX, array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // テ、ツスツ催ァツスツョ idx テ」ツ?ォテ」ツ?づ」ツつ?')' テ」ツつ?'(' テ」ツ?ォ\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                // printf(\"mid = %d, val = %d\\n\", mid, val);\n                if(val > 1) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(ub));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#ifndef ___Class_StarrySkyTree\n#define ___Class_StarrySkyTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\n// ------ Starry Sky Tree Class ------ //\ntemplate<typename Type> class StarrySkyTree {\nprivate:\n\tunsigned size_; std::vector<Type> dat1, dat2;\n\tinline void update_(unsigned a, unsigned b, Type x, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat2[k] += x; return;\n\t\t}\n\t\tupdate_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tupdate_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\tdat1[k] = std::min(dat1[k << 1] + dat2[k << 1], dat1[(k << 1) + 1] + dat2[(k << 1) + 1]);\n\t}\n\tinline Type query_(unsigned a, unsigned b, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return std::numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat1[k] + dat2[k];\n\t\tType lc = query_(a, b, (k << 1), l, (l + r) >> 1);\n\t\tType rc = query_(a, b, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn std::min(lc, rc) + dat2[k];\n\t}\npublic:\n\tStarrySkyTree() : size_(0), dat(std::vector<Type>()) {};\n\tStarrySkyTree(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat1.resize(size_ << 1, 0);\n\t\tdat2.resize(size_ << 1, 0);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void add(unsigned i, Type x) {\n\t\tupdate_(i, i + 1, x, 1, 0, size_);\n\t}\n\tinline void add(unsigned l, unsigned r, Type x) {\n\t\tupdate_(l, r, x, 1, 0, size_);\n\t}\n\tinline Type query(unsigned l, unsigned r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, x; string s;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> Q >> s;\n\tBIT<int> r1(N);\n\tStarrySkyTree<int> r2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tr1.add(i, s[i] == '(' ? 1 : -1);\n\t\tr2.add(i, N, s[i] == '(' ? 1 : -1);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> x; x--;\n\t\tif (s[x] == '(') {\n\t\t\tr1.add(x, -2); s[x] = ')';\n\t\t\tr2.add(x, N, -2);\n\t\t\tint l = 0, r = N + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tint res = r1.sum(0, m);\n\t\t\t\tif (res != m) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(l, 2); s[l] = '(';\n\t\t\tr2.add(l, N, 2);\n\t\t\tcout << l + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tr1.add(x, 2); s[x] = '(';\n\t\t\tr2.add(x, N, 2);\n\t\t\tint l = 0, r = N;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (r2.query(m, N) >= 2) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(r, -2); s[r] = ')';\n\t\t\tr2.add(r, N, -2);\n\t\t\tcout << r + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000], dat[1048576], size_; string s;\ninline void update(int i, int x) {\n\ti += size_; dat[i] = x;\n\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\tint lc = query(a, b, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < n; i++) update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - query(0, r, 1, 0, size_) * 2, pl = 0, pr = r, l = r;\n\t\t\twhile(--l) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl++; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[l];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; update(r, 0);\n\t\t\td[l] = -1; update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = query(0, pm + 1, 1, 0, size_);\n\t\t\t\tif (query(0, pm + 1, 1, 0, size_)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; update(r, 1);\n\t\t\td[pr] = 1; update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Abstract Lazy Segment Tree (テヲツ環スティツアツ。テ」ツδサテヲツアツ偲・ツ個姪ゥツ??・ツサツカテ」ツつサテ」ツつーテ」ツδ。テ」ツδウテ」ツδ暗ヲツ慊ィ)\n// Verified: AOJ テ」ツ?ョテ」ツつサテ」ツつーテヲツ慊ィ verify テ・ツ閉湘・ツ?ィテゥツδィ\n\nconst int SIZE = 1 << 17; // 2^17 = 131072\ntemplate<typename T>\nstruct lazysegtree {\n    // テ」ツδ偲」ツδシテ」ツδ嘉」ツ??・ツ債佚、ツスツ催・ツ??\n    T node[2*SIZE], lazy[2*SIZE], I;\n    bool need_upd[2*SIZE];\n\n    // テ」ツつェテ」ツδ堙」ツδャテ」ツδシテ」ツつキテ」ツδァテ」ツδウ (update, query テ」ツ?ョ 2 テ」ツ?、テ」ツ?古・ツソツ?ィツヲツ?ッツシツ?\n    // update function テ」ツ?ッテァツッツ?・ツ崢イテ」ツつ津ヲツ個?・ツョツ堙」ツ?凖」ツつ凝・ツスツ「テ」ツ?ォテ」ツ?療」ツつ暗」ツ??\n    // upd_f(X, Y, l, r) -> テァツッツ?・ツ崢イテ」ツ??[l, r) テ」ツ?ァテ」ツ?づ」ツつ凝」ツつ暗」ツ??」ツ?ェテ」ツδ偲」ツδシテ」ツδ?X テ」ツ?ォ Y テ」ツつ津・ツ渉催ヲツ伉?ッツシツ?\n    // lazy テ」ツ?ォテ」ツ?、テ」ツ??」ツ?ヲ update テ」ツ?凖」ツつ凝」ツ?ィテ」ツ?催」ツ?ッテァツッツ?・ツ崢イテ」ツつ?1 テ」ツ?ォテ」ツ?療」ツ?ェテ」ツ??」ツ?ィテ」ツδ静」ツつーテ」ツつ甘」ツ?セテ」ツ??\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // テヲツシツ氾ァツョツ療・ツュツ静」ツ?ィテ・ツ債佚、ツスツ催・ツ?ε」ツつ津」ツつサテ」ツδε」ツδ暗」ツ?療」ツ??・ツ?ィテ」ツ?ヲテ」ツ?ョ node テ」ツ?ィ lazy テ」ツつ津・ツ債佚、ツスツ催・ツ?ε」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n    lazysegtree(T (*op1)(T, T, int, int), T (*op2)(T, T), T X, vector<T> vec) {\n        upd_f = op1;\n        qry_f = op2;\n        I = X;\n        fill(lazy, lazy+2*SIZE, I);\n        fill(node, node+2*SIZE, I);\n        fill(need_upd, need_upd+2*SIZE, false);\n\n        // vec テ」ツ?ョテ・ツ?、テ」ツ?ァテ・ツ按敕ヲツ慊淌・ツ個?\n        for(size_t i=0; i<vec.size(); i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I;\n        need_upd[k] = false;\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ・ツ?、 val テ」ツつ津・ツ渉催ヲツ伉?」ツ?陛」ツ?崚」ツつ?\n    // (upd_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    void update(int a, int b, T val, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // テ・ツ債甘ゥツ鳴凝・ツ個コテゥツ鳴?[a, b) テ」ツ?ォテ・ツッツセテ」ツ?療」ツ?ヲテ」ツつッテ」ツつィテ」ツδェテ」ツつ津ヲツ環陛」ツ?津」ツつ?\n    // (qry_f テ」ツつ津ァツ板ィテ」ツ??」ツ?ヲテ・ツ?ヲテァツ青?\n    T query(int a, int b, int l=0, int r=SIZE, int k=0) {\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return INT_MAX;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\nint add(int a, int b, int l, int r) {\n    return a + b;\n}\n\nint qry(int a, int b) {\n    return min(a, b);\n}\n\nint main() {\n    int N, Q; scanf(\"%d%d\", &N, &Q);\n\n    vector<int> array(N), info(N);\n    set<int> open, close;\n    for(int i=0; i<N; i++) {\n        char c; scanf(\" %c\", &c);\n        if(c == '(') {\n            info[i]++;\n            open.insert(i);\n            array[i]++;\n        }\n        if(c == ')') {\n            close.insert(i);\n            array[i]--;\n        }\n        if(i != 0) array[i] += array[i-1];\n    }\n\n    lazysegtree<int> seg(add, qry, 0, array);\n    while(Q--) {\n        int q, idx; scanf(\"%d\", &q); q--;\n        if(info[q]) {\n            // '(' -> ')'\n            seg.update(q, N, -2);\n            info[q] ^= 1;\n            open.erase(q);\n            close.insert(q);\n\n            // テ、ツスツ催ァツスツョ idx テ」ツ?ォテ」ツ?づ」ツつ?')' テ」ツつ?'(' テ」ツ?ォ\n            idx = *(close.begin());\n            seg.update(idx, N, 2);\n            info[idx] ^= 1;\n            open.insert(idx);\n            close.erase(idx);\n        }\n        else {\n            // ')' -> '('\n            seg.update(q, N, 2);\n            info[q] ^= 1;\n            close.erase(q);\n            open.insert(q);\n\n            int lb = -1, ub = N;\n            while(ub - lb > 1) {\n                int mid = (ub + lb) / 2;\n                int val = seg.query(mid, N);\n                // printf(\"mid = %d, val = %d\\n\", mid, val);\n                if(val > 1) ub = mid;\n                else lb = mid;\n            }\n\n            idx = *(open.lower_bound(ub));\n            seg.update(idx, N, -2);\n            info[idx] ^= 1;\n            close.insert(idx);\n            open.erase(idx);\n        }\n        printf(\"%d\\n\", idx + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000], dat[1048576], size_; string s;\ninline void update(int i, int x) {\n\ti += size_; dat[i] = x;\n\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n}\ninline int query(int a, int b, int k, int l, int r) {\n\tif (r <= a || b <= l) return 0;\n\tif (a <= l && r <= b) return dat[k];\n\tint lc = query(a, b, 2 * k, l, (l + r) / 2);\n\tint rc = query(a, b, 2 * k + 1, (l + r) / 2, r);\n\treturn lc + rc;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (size_ = 1; size_ < n;) size_ <<= 1;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < n; i++) update(i, d[i] == -1 ? 1 : 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = r - query(0, r, 1, 0, size_) * 2, pl = 0, pr = r, l = r;\n\t\t\tfor (int i = r - 1; i >= 0; i--) {\n\t\t\t\tif (sum < 2) {\n\t\t\t\t\tl = i + 1; break;\n\t\t\t\t}\n\t\t\t\tsum -= d[i];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; update(r, 0);\n\t\t\td[l] = -1; update(l, 1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = query(0, pm + 1, 1, 0, size_);\n\t\t\t\tif (query(0, pm + 1, 1, 0, size_)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; update(r, 1);\n\t\t\td[pr] = 1; update(pr, 0);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0;\n    int l=0;\n    set<pair<int,int>> range;\n    set<int> lp,rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        assert(s[lhs]=='(');\n        assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n));\n        it--;\n        int l=it->first,r=it->second;\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                //assert(s[l+1]=='(');\n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct SegTree {\n    int n;\n    vi lazy, d_min;\n\n    int c1(int k) { return 2 * k + 1; }\n    int c2(int k) { return 2 * k + 2; }\n\n    SegTree(int sz){\n        n = 1;\n        while(n < sz) n *= 2;\n        d_min = vi(2 * n, inf);\n        lazy = vi(2 * n, 0);\n    }\n    SegTree(){}\n\n    void update(int k, int l, int r){\n        int& cur = lazy[k];\n        if(cur == 0) return;\n\n        if(d_min[k] == inf) d_min[k] = 0;\n        d_min[k] += cur;\n\n        if(r - l > 1){\n            lazy[c1(k)] += cur;\n            lazy[c2(k)] += cur;\n        }\n        cur = 0;\n    }\n\n    void add(int a, int b, int x, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return;\n        if(a <= l and r <= b){\n            lazy[k] += x;\n            update(k, l, r);\n            return;\n        }\n        \n        add(a, b, x, c1(k), l, (l + r) / 2);\n        add(a, b, x, c2(k), (l + r) / 2, r);\n        \n        if(r - l > 1){\n            d_min[k] = min(d_min[c1(k)], d_min[c2(k)]);\n        }\n    }\n\n    int get_min(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return inf;\n        if(a <= l and r <= b){\n            return d_min[k];\n        }\n        \n        return min(get_min(a, b, c1(k), l, (l + r) / 2),\n                   get_min(a, b, c2(k), (l + r) / 2, r));\n    }\n};\n\nint n;\nSegTree seg;\n\nbool check(int l, int r){\n    return seg.get_min(l, r) >= 2;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int Q; cin >> n >> Q;\n    string in; cin >> in;\n    set<int> s;\n    vi a(n); rep(i, n) a[i] = (in[i] == '(' ? +1:-1);\n    rep(i, n) if(a[i] < 0) s.insert(i);\n\n    seg = SegTree(n);\n    rep(i, n) seg.add(i, n, a[i]);\n\n    rep(loop, Q){\n        int x; cin >> x; x--;\n        int idx;\n        int cur = a[x];\n        seg.add(x, n, cur * -2);\n\n        // rep(i, n) cerr << seg.get_min(i, i + 1) << \" \"; cerr << endl;\n        if(cur > 0){\n            s.insert(x);\n            idx = *begin(s);\n            s.erase(idx);\n        }\n        else {\n            int lb = -1, ub = x;\n            while(ub - lb > 1){\n                int mid = (lb + ub) / 2;\n                if(check(mid, x + 1)){\n                    ub = mid;\n                }\n                else {\n                    lb = mid;\n                }\n            }\n            idx = ub;\n            s.erase(x);\n            s.insert(idx);\n        }\n        a[idx] *= -1;\n        a[x] *= -1;\n        seg.add(idx, n, cur * 2);\n        cout << idx+1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=1e9;\n\nconst int N_MAX=1<<20;\nconst int DAT_SIZE=N_MAX*2-1;\nint dat[DAT_SIZE],lazy[DAT_SIZE];\nint n;\n\nvoid init(int size){\n  fill(begin(dat),end(dat),INF);\n  n=1;\n  while(n<size){\n    n*=2;\n  }\n}\n\nvoid lazy_eval(int k){\n  dat[k]+=lazy[k];\n  if(k<n-1){\n    lazy[k*2+1]+=lazy[k];\n    lazy[k*2+2]+=lazy[k];\n  }\n  lazy[k]=0;\n}\n\nint rangemin(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return INF;\n  lazy_eval(k);\n  if(a<=l&&r<=b){\n    return dat[k];\n  }else{\n    int v1=rangemin(a,b,k*2+1,l,(l+r)/2);\n    int v2=rangemin(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n}\n\nint rangeadd(int v,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l){\n    lazy_eval(k);\n    return dat[k];\n  }else if(a<=l&&r<=b){\n    lazy[k]+=v;\n    lazy_eval(k);\n    return dat[k];\n  }else{\n    lazy_eval(k);\n    int v1=rangeadd(v,a,b,k*2+1,l,(l+r)/2);\n    int v2=rangeadd(v,a,b,k*2+2,(l+r)/2,r);\n    return dat[k]=min(v1,v2);\n  }\n}\n\nvoid change(int x,int v,int k,int l,int r){\n  lazy_eval(k);\n  if(k<n-1){\n    if(x<(l+r)/2){\n      change(x,v,k*2+1,l,(l+r)/2);\n    }else{\n      change(x,v,k*2+2,(l+r)/2,r);\n    }\n    lazy_eval(k*2+1);\n    lazy_eval(k*2+2);\n    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n  }else{\n    dat[k]=v;\n  }\n}\n\nint main(){\n  int N,Q;\n  cin>>N>>Q;\n  init(N);\n  char s[323456];\n  cin>>s;\n  for(int i=0,c=0;i<N;i++){\n    c+=(s[i]=='(')-(s[i]==')');\n    change(i,c,0,0,n);\n  }\n  for(int i=0;i<n*2-1;i++){\n    //    cout<<i<<' '<<dat[i]<<endl;\n  }\n  while(Q--){\n    int q;\n    cin>>q;\n    q--;\n    if(s[q]=='('){\n      rangeadd(-2,q,N,0,0,n);\n      int l=-1,h=N;\n      while(h-l>1){\n\tint m=(l+h)/2;\n\tif(rangemin(m,m+1,0,0,n)==m+1){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      cout<<h+1<<endl;\n      rangeadd(2,h,N,0,0,n);\n      s[q]=')';\n      s[h]='(';\n    }else{\n      rangeadd(2,q,N,0,0,n);\n      int l=-1,h=q;\n      while(h-l>1){\n\tint m=(h+l)/2;\n\tif(rangemin(m,q+1,0,0,n)<=1){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      // cout<<l<<' '<<h<<endl;\n      // for(int i=0;i<N;i++){\n      // \tcout<<i<<' '<<rangemin(i,i+1,0,0,n)<<endl;\n      // }\n      // cout<<l<<' '<<h<<' '<<q<<endl;\n      // cout<<rangemin(l,q+1,0,0,n)<<endl;\n      // cout<<rangemin(h,q+1,0,0,n)<<endl;\n      cout<<h+1<<endl;\n      rangeadd(-2,h,N,0,0,n);\n      s[q]='(';\n      s[h]=')';\n    }\n    //cerr<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; int i; bool used; };\n \nint MOD = 1000000007;\n\nstruct bit {\n\tvector<ll> v;\n\tbit(int n) : v(n + 1) {}\n\tll sum(int i) {\n\t\tll res = 0;\n\t\tfor (; i > 0; i -= i & -i) res += v[i];\n\t\treturn res;\n\t}\n\tvoid add(int i, ll x) {\n\t\tfor (i++; i < v.size(); i += i & -i) v[i] += x;\n\t}\n\tint lower_bound(ll x) {\n\t\tif (x <= 0) return 0;\n\t\tint res = 0;\n\t\tfor (int i = 1 << 24; i > 0; i >>= 1)\n\t\t\tif (res + i < v.size() && v[res + i] < x) {\n\t\t\t\tres += i; x -= v[res];\n\t\t\t}\n\t\treturn res + 1;\n\t}\n};\n\nint N, Q;\nstring s;\n\nvoid flip(int i, bit& a, bit& b, bit& c) {\n\tif (s[i] == '(') {\n\t\ts[i] = ')';\n\t\ta.add(i, -2);\n\t\tb.add(i, 1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(') c.add(i - 1, -1);\n\t\tif (i + 1 < N && s[i + 1] == '(') c.add(i, -1);\n\t}\n\telse {\n\t\ts[i] = '(';\n\t\ta.add(i, 2);\n\t\tb.add(i, -1);\n\t\tif (i - 1 >= 0 && s[i - 1] == '(') c.add(i - 1, 1);\n\t\tif (i + 1 < N && s[i + 1] == '(') c.add(i, 1);\n\t}\n}\n\nint main() {\n\tcin >> N >> Q >> s;\n\tbit a(N), b(N), c(N);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == '(') a.add(i, 1);\n\t\telse a.add(i, -1);\n\tfor (int i = 0; i < N; i++)\n\t\tif (s[i] == ')') b.add(i, 1);\n\tfor (int i = 0; i < N - 1; i++)\n\t\tif (s[i] == '(' && s[i] == '(') c.add(i, 1);\n\twhile (Q--) {\n\t\tint i; cin >> i; i--;\n\t\tif (s[i] == '(') {\n\t\t\tflip(i, a, b, c);\n\t\t\tint j = b.lower_bound(1) - 1;\n\t\t\tflip(j, a, b, c);\n\t\t\tcout << j + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tif (a.sum(i + 1) == 0) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflip(i, a, b, c);\n\t\t\t\tint j = c.lower_bound(1) - 1;\n\t\t\t\tflip(j + 1, a, b, c);\n\t\t\t\tcout << j + 2 << endl;\n\t\t\t}\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n,Q;\n    cin>>n>>Q;\n    string s;\n    cin>>s;\n    int c=0,l=0;\n    set<pair<int,int>> range;\n    set<int> rp; \n    for(int i=0;i<n;i++){\n        if(s[i]=='(') c++;\n        else c--,rp.insert(i);\n        if(c==0){\n            range.insert({l,i+1});\n            l=i+1;\n        }\n    }\n    assert(c==0);\n    auto swapPar=[&](int lhs,int rhs){\n        rp.erase(rhs),rp.insert(lhs);\n        // assert(s[lhs]=='(');\n        // assert(s[rhs]==')');\n        s[lhs]=')';\n        s[rhs]='(';\n    };\n    while(Q--){\n        int q;\n        cin>>q;\n        q--;\n        auto it=range.upper_bound(make_pair(q,n+1));\n        it--;\n        int l=it->first,r=it->second;\n        assert(l<=q && q<r);\n        if(s[q]==')'){\n            //split\n            if(l+2==r){\n                //assert(q==l+1);\n                cout<<q+1<<\"\\n\";\n            }\n            else{\n                assert(s[l]=='(');                \n                // assert(s[l+1]=='(');                \n                cout<<l+2<<\"\\n\";\n                swapPar(l+1,q);\n                range.erase({l,r});\n                range.insert({l,l+2});\n                range.insert({l+2,r});\n            }\n        }\n        else{\n            //merge\n            int leftr=*rp.begin();\n            if(leftr<q){\n                cout<<leftr+1<<\"\\n\";\n                swapPar(q,leftr);\n                vector<pair<int,int>> tmp;\n                for(auto &e:range){\n                    tmp.push_back(e);\n                    if(e==make_pair(l,r)) break;\n                }\n                for(auto &e:tmp){\n                    range.erase(e);\n                }\n                range.insert({0,r});\n            }\n            else{\n                cout<<q+1<<\"\\n\";\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55)+1e9; // ~ 3.6 * 1e16\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    Int value;\n    T():type(0),value(0){}\n    T(bool type,Int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    Int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(Int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  D INF = D(1LL<<55); /*!!!!!!!!!!!!!!!!!!!!!!!!*/\n\n  Int n;\n  vector<D> dat;\n  vector<T> td;\n  Int toMax; //0 -> RangeMin, 1 -> RangeMax\n  \n  RMAQ(){n=-1;}\n  RMAQ(Int n_,Int toMax = 0){\n    this->toMax = toMax;\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return min(a,b);}\n  \n  void delay(Int k){\n    if(td[k].type==0) return;\n    Int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    Int l = k*2+1,r = k*2+2;\n    dat[l].value += v; td[l].type = 1; td[l].value += v;\n    dat[r].value += v; td[r].type = 1; td[r].value += v;\n  }\n\n  D update(Int k,Int x){\n    td[k].type = 1;\n    td[k].value += x;\n    dat[k].value += x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D add(Int a,Int b,Int x,bool flg=true,Int k=0,Int l=0,Int r=-1){\n    if(r==-1 && toMax) x *= -1; \n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:INF;\n    if(a<=l&&r<=b) return flg? update(k,x):dat[k];\n    \n    delay(k);\n    D vl = add(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = add(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の最小値を得る　find(a,b);\n  Int find(Int a,Int b){\n    D res = add(a,b,0,false);\n    if(toMax) res.value *= -1; \n    return res.value;\n  }\n};\n\nInt valid(string s){\n  Int n = s.size();\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    if(cnt < 0) return false;\n  }\n  return cnt == 0;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  Int n, q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n\n  RMAQ A(n);\n  Int cnt = 0;\n  for(Int i=0;i<n;i++){\n    if(s[i] == '(') cnt++;\n    if(s[i] == ')') cnt--;\n    A.add(i, i+1, cnt);\n  }\n\n  set<Int> open;\n  set<Int> close;\n  for(Int i=0;i<n;i++) s[i] == '('? open.insert(i) : close.insert(i);\n  \n  auto rev=[&](Int x){\n    if(s[x] == '(') {\n      A.add(x, n, -2);\n      s[x] = ')';\n      open.erase(x);\n      close.insert(x);\n    }\n    else if(s[x] == ')') {\n      A.add(x, n, +2);\n      s[x] = '(';\n      close.erase(x);\n      open.insert(x);\n    }\n  };\n  \n  auto check =[&](Int x){\n    rev(x);\n    Int res = 1;\n    if(A.find(0, n) < 0) res = 0;\n    if(A.find(n-1, n) != 0) res = 0;\n    rev(x);\n    return res;\n  };\n    \n  auto find=[&](set<Int> &par,Int R){\n    \n    Int L = -1;\n    while(L+1<R){\n      Int M = (L+R)/2;\n      auto it = par.lower_bound(M);\n      if(it == par.end()) {R = M;continue;}\n      if(check(*it) == false) L = M;\n      else R = M;\n    }\n    \n    return *par.lower_bound(R);\n  };\n\n  srand((unsigned)time(NULL));\n  for(Int i=0;i<q;i++){\n    Int x;\n    cin>>x; x--;\n    rev(x);\n    Int y;\n    if(s[x] == ')') y = find(close,x);\n    if(s[x] == '(') y = find(open,x);\n    rev(y);\n    //assert(valid(s));\n    assert((Int)open.size() + (Int)close.size() == n);\n    cout<<y+1<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_BIT\n#define ___Class_BIT\n\n// ------ Includes ------ //\n#include <vector>\n#pragma warning(disable : 4146)\n\n// ------ Class ------ //\ntemplate <typename Type>\nclass BIT {\nprivate:\n\tunsigned size_; std::vector<Type> v;\n\tType sum(unsigned r) {\n\t\tType ret = 0;\n\t\twhile (r > 0) {\n\t\t\tret += v[r];\n\t\t\tr -= r & (-r);\n\t\t}\n\t\treturn ret;\n\t}\npublic:\n\tBIT() {};\n\tBIT(unsigned size__) {\n\t\tfor (size_ = 1; size_ < size__;) size_ <<= 1;\n\t\tv.resize(size_ + 1, 0);\n\t}\n\tinline void add(unsigned i, Type x) {\n\t\ti++;\n\t\twhile (i <= size_) {\n\t\t\tv[i] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tinline Type sum(unsigned l, unsigned r) {\n\t\treturn sum(r) - sum(l);\n\t}\n\tbool operator[](unsigned x) {\n\t\treturn sum(x, x + 1);\n\t}\n};\n\n#endif\n\n#ifndef ___Class_StarrySkyTree\n#define ___Class_StarrySkyTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\n// ------ Starry Sky Tree Class ------ //\ntemplate<typename Type> class StarrySkyTree {\nprivate:\n\tunsigned size_; std::vector<Type> dat1, dat2;\n\tinline void update_(unsigned a, unsigned b, Type x, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tdat2[k] += x; return;\n\t\t}\n\t\tupdate_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tupdate_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\tdat1[k] = std::min(dat1[k << 1] + dat2[k << 1], dat1[(k << 1) + 1] + dat2[(k << 1) + 1]);\n\t}\n\tinline Type query_(unsigned a, unsigned b, unsigned k, unsigned l, unsigned r) {\n\t\tif (r <= a || b <= l) return std::numeric_limits<Type>::max();\n\t\tif (a <= l && r <= b) return dat1[k] + dat2[k];\n\t\tType lc = query_(a, b, (k << 1), l, (l + r) >> 1);\n\t\tType rc = query_(a, b, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn std::min(lc, rc) + dat2[k];\n\t}\npublic:\n\tStarrySkyTree() : size_(0), dat(std::vector<Type>()) {};\n\tStarrySkyTree(int size__) {\n\t\tfor (size_ = 1; size_ < size__; ) size_ <<= 1;\n\t\tdat1.resize(size_ << 1, 0);\n\t\tdat2.resize(size_ << 1, 0);\n\t}\n\ttemplate<class T>\n\tStarrySkyTree(T begin_, T end_) {\n\t\tunsigned n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::numeric_limits<Type>::max());\n\t\tfor (unsigned i = 0; i < n; i++) dat[i + size_] = *(begin_ + i);\n\t\tfor (unsigned i = size_ - 1; i > 0; i--) dat[i] = std::min(dat[i << 1], dat[(i << 1) + 1]);\n\t}\n\tinline unsigned size() { return size_; }\n\tinline void add(unsigned i, Type x) {\n\t\tupdate_(i, i + 1, x, 1, 0, size_);\n\t}\n\tinline void add(unsigned l, unsigned r, Type x) {\n\t\tupdate_(l, r, x, 1, 0, size_);\n\t}\n\tinline Type query(unsigned l, unsigned r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, x; string s;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> Q >> s;\n\tBIT<int> r1(N);\n\tStarrySkyTree<int> r2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tr1.add(i, s[i] == '(' ? 1 : -1);\n\t\tr2.add(i, N, s[i] == '(' ? 1 : -1);\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> x; x--;\n\t\tif (s[x] == '(') {\n\t\t\tr1.add(x, -2); s[x] = ')';\n\t\t\tr2.add(x, N, -2);\n\t\t\tint l = 0, r = N + 1;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tint res = r1.sum(0, m);\n\t\t\t\tif (res != m) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(l, 2); s[l] = '(';\n\t\t\tr2.add(l, N, 2);\n\t\t\tcout << l + 1 << endl;\n\t\t}\n\t\telse {\n\t\t\tr1.add(x, 2); s[x] = '(';\n\t\t\tr2.add(x, N, 2);\n\t\t\tint l = 0, r = N;\n\t\t\twhile (r - l > 1) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (r2.query(m, N) >= 2) r = m;\n\t\t\t\telse l = m;\n\t\t\t}\n\t\t\tr1.add(r, -2); s[r] = ')';\n\t\t\tr2.add(r, N, -2);\n\t\t\tcout << r + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct {\n\tint val;\n\tint add;\n} Node;\n\nNode seg[1 << 20];\n\ninline void evaluate(int idx)\n{\n\tseg[idx].val += seg[idx].add;\n\tif (idx < (1 << 19) - 1){\n\t\tseg[idx * 2 + 1].add += seg[idx].add;\n\t\tseg[idx * 2 + 2].add += seg[idx].add;\n\t}\n\t\n\tseg[idx].add = 0;\n}\n\nvoid update(int k)\n{\n\tseg[k].val = min(seg[k * 2 + 1].val, seg[k * 2 + 2].val);\n}\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n\tevaluate(k);\n\tif (r <= a || b <= l) return;\n\t\n\tif (a <= l && r <= b){\n\t\tseg[k].add += x;\n\t\tevaluate(k);\n\t\treturn;\n\t}\n\t\n\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);\n\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);\n\tupdate(k);\n}\n\nint n, q;\nchar s[300001];\n\nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    int p;\n    \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        if (seg[0].val + seg[0].add >= 0) r = mid;\n        else l = mid + 1;\n        \n        add(p, n, 2 * base);\n    }\n    \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n    \n    printf(\"%d\\n\", p + 1);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\n \nconst int INF = 1 << 28;\n \nstruct SegmentTree\n{\n  \n  vector< int > small, add;\n  int sz;\n  \n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    small.assign(2 * sz - 1, INF);\n    add.assign(2 * sz - 1, 0);\n  }\n  inline void Merge(int k)\n  {\n    small[k] = min(small[2 * k + 1] + add[2 * k + 1], small[2 * k + 2] + add[2 * k + 2]);\n  }\n  inline int RangeMinimumQuery(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return(INF);\n    if(a <= l && r <= b) return(small[k] + add[k]);\n    int L = RangeMinimumQuery(a, b, 2 * k + 1, l, (l + r) >> 1);\n    int R = RangeMinimumQuery(a, b, 2 * k + 2, (l + r) >> 1, r);\n    return(min(L, R) + add[k]);\n  }\n  int RangeMinimumQuery(int a, int b)\n  {\n    return(RangeMinimumQuery(a, b, 0, 0, sz));\n  }\n  inline void RangeAdd(int a, int b, int x, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return;\n    if(a <= l && r <= b) {\n      add[k] += x;\n      return;\n    }\n    RangeAdd(a, b, x, 2 * k + 1, l, (l + r) >> 1);\n    RangeAdd(a, b, x, 2 * k + 2, (l + r) >> 1, r);\n    Merge(k);\n  }\n  void RangeAdd(int a, int b, int x)\n  {\n    return(RangeAdd(a, b, x, 0, 0, sz));\n  }\n  inline int BinarySearch(int k, int l, int r, int upd)\n  {\n    if(k >= sz - 1) return(r);\n    const int right = small[2 * k + 2] + add[2 * k + 2] + add[k] + upd;\n    if(right >= 2) return(BinarySearch(2 * k + 1, l, (l + r) >> 1, upd + add[k]));\n    return(BinarySearch(2 * k + 2, (l + r) >> 1, r, upd + add[k]));\n  }\n  int BinarySearch()\n  {\n    return(BinarySearch(0, 0, sz, 0));\n  }\n};\n \nint main()\n{\n  int N, Q;\n \n  scanf(\"%d %d\", &N, &Q);\n  char S[300001];\n  bool poped[300001] = {};\n\n  scanf(\" %s\", S);\n  SegmentTree tree(N);\n  set< int > open;\n  priority_queue< int, vector< int >, greater< int > > close;\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, i + 1, -INF);\n  }\n  for(int i = 0; i < N; i++) {\n    tree.RangeAdd(i, N, S[i] == '(' ? +1 : -1);\n    if(S[i] == ')') close.push(i);\n    else open.insert(i);\n  }\n  while(Q--) {\n    int q;\n    scanf(\"%d\", &q);\n    --q;\n    tree.RangeAdd(q, N, S[q] == ')' ? +2 : -2);\n    if(S[q] == '(') {\n      open.erase(q);\n      if(!poped[q]++) close.push(q);\n      S[q] = ')';\n      int p = close.top(); close.pop();\n      poped[p] = false;\n      while(S[p] == '(') {\n        p = close.top();\n        poped[p] = false;\n        close.pop();\n      }\n      printf(\"%d\\n\", p + 1);\n      tree.RangeAdd(p, N, +2);\n      S[p] = '(';\n      open.insert(p);\n    } else {\n      open.insert(q);\n      S[q] = '(';\n      int pos = *open.lower_bound(tree.BinarySearch());\n      printf(\"%d\\n\", pos + 1);\n      tree.RangeAdd(pos, N, -2);\n      S[pos] = ')';\n      open.erase(pos);\n      if(!poped[pos]++) close.push(pos);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 300010\n\n/* Starry Sky Tree */\n//0-index\n\nstruct StarrySkyTree{\n  typedef int Type;\n  int segn2;\n  vector<Type> data,s_data;\n  \n  StarrySkyTree(int n){\n    for(segn2=1;segn2<n;segn2*=2);\n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get minimum value of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    if(r<a || b<l) return INF;\n    if(a<=l && r<=b) return data[k] + s_data[k];\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2+1,r,k*2+2))+s_data[k];\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = min(add(a,b,x,l,(l+r)/2,k*2+1),add(a,b,x,(l+r)/2+1,r,k*2+2));\n    }\n    return data[k] + s_data[k];\n  }\n  \n};\n\n\n\nint main(){\n  int n,q;\n  char s[SIZE];\n  int sum[SIZE];\n  priority_queue<int> right;\n  scanf(\"%d%d%s\",&n,&q,s);\n\n  StarrySkyTree seg(n);\n  \n  for(int i=0;i<n;i++){\n    if(s[i] == '('){\n      sum[i] = 1;\n    }else{\n      sum[i] = -1;\n      right.push(-i);\n    }\n\n    if(i > 0){\n      sum[i] += sum[i-1];\n    }\n\n    seg.add(i,i,sum[i]);\n  }\n  \n  for(int i=0;i<q;i++){\n    int p, ans;\n    scanf(\"%d\",&p);\n    p--;\n    \n    if(s[p] == '('){\n      s[p] = ')';\n      right.push(-p);\n      seg.add(p,n-1,-2);\n\n      while(right.size() && s[-right.top()] == '(') right.pop();\n\n      ans = -right.top();\n      s[ans] = '(';\n      seg.add(ans,n-1,2);\n      \n    }else{\n      s[p] = '(';\n      seg.add(p,n-1,2);\n\n      int l=0, r=p;\n\n      while(l<r){\n        int mid = (l+r)/2;\n        if(seg.query(mid,n-1) >= 2){\n          r = mid;\n        }else{\n          l = mid+1;\n        }\n      }\n\n      ans = l;\n      s[ans] = ')';\n      right.push(-ans);\n      seg.add(ans,n-1,-2);\n    }\n\n    printf(\"%d\\n\",ans+1);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < s.size(); i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = 0; bool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tsum += d[j];\n\t\t\t\tif (sum >= 2) {\n\t\t\t\t\td[j] = -1, d[r] = 1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t\telse {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < r; j++) {\n\t\t\t\tif (d[j] == -1) {\n\t\t\t\t\td[j] = 1, d[r] = -1, flag = true; printf(\"%d\\n\", j + 1); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) printf(\"%d\\n\", r + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tint query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tint query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tbit b2(n); for (int i = 0; i < n; i++) b2.update(i, d[i]);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = b2.query(0, r), l = r;\n\t\t\tfor (l = r - 1; l >= 0; l--) {\n\t\t\t\tif (sum < 2) break;\n\t\t\t\tsum -= d[l];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 2);\n\t\t\td[r] = 1; b1.update(r, 0); b2.update(r, 1);\n\t\t\td[l] = -1; b1.update(l, 1); b2.update(l, -1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1); b2.update(r, -1);\n\t\t\td[pr] = 1; b1.update(pr, 0); b2.update(pr, 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat, dat2, lazy;\n\npublic:\n  SegmentTree() {\n  }\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat = lazy = vector<int>(n*2-1, 0);\n    dat2 = vector<int>(n*2-1, 0);\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat[k] += dat[k*2+1] + dat[k*2+2];\n    dat2[k] = min(dat2[k], min(dat2[k*2+1], dat2[k*2+2]));\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    if (lazy[k]) {\n      dat[k] += (r - l) * lazy[k];\n      dat2[k] += lazy[k];\n      if (k < n-1) {\n        lazy[k*2+1] += lazy[k];\n        lazy[k*2+2] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        vector<int> pos;\n        for (int i = 0; i < s.size(); ++i) {\n          if (s[i] == '(') pos.push_back(i);\n        }\n        assert(pos.empty());\n        int l = 0, r = pos.size();\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(pos[m], N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << pos[r] + 1 << endl;\n        change(pos[r]);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\nint n, q;\nchar s[300001];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return (INT_MAX);\n    \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n    \n    int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2);\n    int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r);\n    \n    return (min(left, right) + segAdd[k]);\n    \n}\n\nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    int p;\n    \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        if (getMin(p, n) >= 2 * base) r = mid;\n        else l = mid + 1;\n    }\n    \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n    \n    printf(\"%d\\n\", p + 1);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint segMin[1 << 20], segAdd[1 << 20];\n\nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return;\n    \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1],\n                            segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n    \n    add(a, b, x, k * 2 + 1, l, l + r >> 1);\n    add(a, b, x, k * 2 + 2, l + r >> 1, r);\n}\n\nint getMin(int a, int b, int k = 0, int l = 0, int r = 1 << 19)\n{\n    if (b <= l || r <= a) return (INT_MAX);\n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n    \n    return (min(getMin(a, b, k * 2 + 1, l, l + r >> 1),\n                getMin(a, b, k * 2 + 2, l + r >> 1, r)) + segAdd[k]);\n}\n\nint n, q;\nchar s[300001];\n\nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n    \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n    \n    add(x, n, 2 * base);\n    \n    int l = 0, r = x;\n    int p;\n    \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        add(p, n, -2 * base);\n        \n        if (segMin[0] + segAdd[0] >= 0) r = mid;\n        else l = mid + 1;\n        add(p, n, 2 * base);\n    }\n    \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n    \n    printf(\"%d\\n\", p + 1);\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n    \n    set<int> lf, rg;\n    \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n    \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n        \n        \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\nusing namespace std;\nchar str[310000];\nset<int>S;\nint segtree[1048576];\nint getmin(int a,int b,int c,int d,int e,int f){\n\tif(d<a||b<c||c>d)return 1000000007;\n\tif(c<=a&&b<=d)return f+segtree[e];\n\treturn min(getmin(a,(a+b)/2,c,d,e*2,f+segtree[e]),getmin((a+b)/2+1,b,c,d,e*2+1,f+segtree[e]));\n}\nvoid add(int a,int b,int c,int d,int e,int f){\n\tif(c>d)return;\n\tif(d<a||b<c)return ;\n\tif(c<=a&&b<=d){\n\t\tsegtree[e]+=f;\n\t\treturn;\n\t}\n\tadd(a,(a+b)/2,c,d,e*2,f);\n\tadd((a+b)/2+1,b,c,d,e*2+1,f);\n\tif(segtree[e*2]>0&&segtree[e*2+1]>0){\n\t\tint val=min(segtree[e*2],segtree[e*2+1]);\n\t\tsegtree[e]+=val;\n\t\tsegtree[e*2]-=val;\n\t\tsegtree[e*2+1]-=val;\n\t}\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",str);\n\tfor(int i=0;i<a;i++)if(str[i]==')')S.insert(i);\n\tint now=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(str[i]=='(')now++;\n\t\telse now--;\n\t\tadd(0,524287,i+1,i+1,1,now);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint c;scanf(\"%d\",&c);c--;\n\t\tif(str[c]=='('){\n\t\t\tS.insert(c);\n\t\t\tstr[c]=')';\n\t\t\tint at=*(S.begin());\n\t\t\tprintf(\"%d\\n\",at+1);\n\t\t\tstr[at]='(';\n\t\t\tS.erase(at);\n\t\t\tadd(0,524287,at+1,c,1,2);\n\t\t}else{\n\t\t\tS.erase(c);\n\t\t\tstr[c]='(';\n\t\t\tadd(0,524287,c+1,a,1,2);\n\t\t\tint L=-1;\n\t\t\tint R=c;\n\t\t\twhile(L+1<R){\n\t\t\t\tint M=(L+R)/2;\n\t\t\t\tint val=getmin(0,524287,M+1,c+1,1,0);\n\t\t\t\tif(val>=2)R=M;\n\t\t\t\telse L=M;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",R+1);\n\t\t\tstr[R]=')';\n\t\t\tS.insert(R);\n\t\t\tadd(0,524287,R+1,a,1,-2);\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MAX 1000100\n#define N 3001000\n\nint n, m, qidx;\nchar str[N];\nint minval[MAX], flag[MAX], prefix[MAX];\nmap<int, int> ridxs;\n\ninline void push_down(int left, int right, int idx){\n  if(left == right){\n    minval[idx] += flag[idx];\n    flag[idx] = 0;\n    return;\n  }\n  \n  minval[idx] += flag[idx];\n  flag[idx << 1] += flag[idx];\n  flag[idx << 1 | 1] += flag[idx];\n  flag[idx] = 0;\n}\n\ninline void push_up(int left, int right, int idx){\n  if(left == right){ push_down(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  push_down(left, right, idx);\n  push_down(left, mid, idx << 1);\n  push_down(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\ninline int query(int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end) return minval[idx];\n  \n  int mid = (left + right) >> 1, res;\n  if(end <= mid) res = query(start, end, left, mid, idx << 1);\n  else if(mid < start) res = query(start, end, mid + 1, right, idx << 1 | 1);\n  else res = min(query(start, end, left, mid, idx << 1), query(start, end, mid + 1, right, idx << 1 | 1));\n  return res;\n}\n\ninline void update(int val, int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end){ flag[idx] += val; push_up(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  if(end <= mid) update(val, start, end, left, mid, idx << 1);\n  else if(mid < start) update(val, start, end, mid + 1, right, idx << 1 | 1);\n  else{\n    update(val, start, end, left, mid, idx << 1);\n    update(val, start, end, mid + 1, right, idx << 1 | 1);\n  }\n  push_up(left, right, idx);\n}\n\ninline void build(int left, int right, int idx){\n  if(left == right){ minval[idx] = prefix[left]; return; }\n\n  int mid = (left + right) >> 1;\n  build(left, mid, idx << 1);\n  build(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\nint main(){\n  while(scanf(\"%d%d\", &n, &m) == 2){\n    ridxs.clear();\n    memset(flag, 0, sizeof(flag));\n    \n    scanf(\"%s\", str + 1);\n    \n    prefix[0] = 0;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + (str[i] == '(' ? 1 : -1);\n    for(int i = 1; i <= n; i++) if(str[i] == ')') ridxs[i] = 1;\n    \n    build(1, n, 1);\n    \n    int ans;\n    for(int i = 1; i <= m; i++){\n      scanf(\"%d\", &qidx);\n      \n      if(str[qidx] == '('){\n        ridxs[qidx] = 1;\n        ans = ridxs.begin()->first;\n        ridxs.erase(ridxs.find(ans));\n        str[qidx] = ')'; str[ans] = '(';\n        if(ans != qidx) update(2, ans, qidx - 1, 1, n, 1);\n      }\n      else{\n        if(query(qidx - 1, qidx - 1, 1, n, 1) < 2) ans = qidx;\n        else{\n          int lidx = 1, ridx = qidx - 1;\n          while(ridx - lidx > 1){\n            int mid = (lidx + ridx) >> 1;\n            if(query(mid, ridx, 1, n, 1) < 2) lidx = mid;\n            else ridx = mid;\n          }\n          ans = ridx;\n          \n          update(-2, ans, qidx - 1, 1, n, 1);\n          ridxs.erase(ridxs.find(qidx));\n          ridxs[ans] = 1;\n          str[qidx] = '('; str[ans] = ')';\n        }\n      }\n      \n         \n      printf(\"%d\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N (1<<19)\n#define INF 100000000\n#define MOD 1000000007\n#define RANK 1000000000\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> IP;\n\nstruct segtree{\n    int n, dat[2*MAX_N-1]; //(1<<17) = 130000\n    int add[2*MAX_N-1];\n\n    void init(int n_){\n        n = 1;\n        while(n < n_) n *= 2;\n        for(int i = 0; i < 2*n-1; i++) dat[i] = 0;\n        for(int i = 0; i < 2*n-1; i++) add[i] = 0;\n    }\n\n    void Add(int a, int b, int k, int l, int r, int v){\n        if(a >= r || b <= l) return;\n        if(a <= l && r <= b){\n            add[k] += v;\n            return;\n        }\n        Add(a,b,k*2+1,l,(r+l)/2,v);\n        Add(a,b,k*2+2,(r+l)/2,r,v);\n        dat[k] = min(dat[k*2+1]+add[k*2+1],dat[k*2+2]+add[k*2+2]);\n    }\n\n    //(a,b,0,0,seg.n)??§?????¶\n    int query(int a, int b, int k, int l, int r, int v){\n        if(k >= n-1) return k-(n-1);\n        v += add[k];\n        if(dat[k*2+2]+v < 0) return query(a,b,k*2+2,(l+r)/2,r,v);\n        else return query(a,b,k*2+1,l,(l+r)/2,v);\n    }\n} seg;\n\nint n, q;\nstring s;\npriority_queue<int, vector<int>, greater<int> > que;\nint bla[300000];\n\nint main(){\n    cin >> n >> q;\n    seg.init(n);\n    cin >> s;\n    rep(i,n){\n        if(s[i] == ')'){\n            que.push(i);\n            bla[i]++;\n        }\n    }\n    int cnt = 0;\n    for(int i = n-1; i >= 0; i--){\n        if(s[i] == ')') cnt++;\n        else cnt--;\n        seg.Add(i,i+1,0,0,seg.n,cnt);\n    }\n    rep(i,q){\n        int x; cin >> x;\n        x--;\n        if(s[x] == '('){\n            s[x] = ')';\n            seg.Add(0,x+1,0,0,seg.n,2);\n            que.push(x);\n            bla[x]++;\n            while(true){\n                int p = que.top();\n                que.pop();\n                if(bla[p] > 0){\n                    s[p] = '(';\n                    seg.Add(0,p+1,0,0,seg.n,-2);\n                    bla[p]--;\n                    cout << p+1 << endl;\n                    break;\n                }\n            }\n        } else{\n            s[x] = '(';\n            bla[x]--;\n            seg.Add(0,x+1,0,0,seg.n,-2);\n            int y = seg.query(0,n,0,0,seg.n,0);\n            s[y] = ')';\n            bla[y]++;\n            que.push(y);\n            seg.Add(0,y+1,0,0,seg.n,2);\n            cout << y+1 << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nuint64_t ary[5000]__attribute__((aligned(32)));\nint diff[5000]__attribute__((aligned(32)));\nint inf[5000]__attribute__((aligned(32)));\nint l1,l2,n;\n\nint _mm_popcnt_u64(uint64_t x) {\n  return __builtin_popcountll(x);\n}\n\nvoid update(int i) {\n  if (i != l1) {\n    diff[i] = 2 * _mm_popcnt_u64(ary[i]) - 64;\n    int cnt = 0;\n    inf[i] = 0;\n    REP(j,64) {\n      cnt += ((ary[i] >> j) & 1) ? 1 : -1;\n      inf[i] = min(inf[i], cnt);\n    }\n  } else {\n    diff[l1] = 2 * _mm_popcnt_u64(ary[l1]) - (n % 64);\n    int cnt = 0;\n    inf[l1] = 0;\n    REP(j,n % 64) {\n      cnt += ((ary[l1] >> j) & 1) ? 1 : -1;\n      inf[l1] = min(inf[l1], cnt);\n    }\n  }\n}\n\nint main() {\n  int q;\n  cin>>n>>q;\n  string s;\n  cin>>s;\n  REP(i,n){\n    if(s[i]=='(')\n      ary[i/64] |= UINT64_C(1) << (i % 64);\n  }\n  l1 = n/64;\n  l2 = (n+63)/64;\n  REP(i,l1){\n    diff[i] = 2 * _mm_popcnt_u64(ary[i]) - 64;\n  }\n  if (l1 != l2) diff[l1] = 2 * _mm_popcnt_u64(ary[l1]) - (n % 64);\n  REP(i,l1) {\n    int cnt = 0;\n    REP(j,64) {\n      cnt += ((ary[i] >> j) & 1) ? 1 : -1;\n      inf[i] = min(inf[i], cnt);\n    }\n  }\n  if (l1 != l2) {\n    int cnt = 0;\n    REP(j,n % 64) {\n      cnt += ((ary[l1] >> j) & 1) ? 1 : -1;\n      inf[l1] = min(inf[l1], cnt);\n    }\n  }\n  REP(cnt1,q){\n    int p;\n    cin>>p;\n    --p;\n    if ((ary[p/64] >> (p % 64)) & 1) {\n      ary[p/64] ^= UINT64_C(1) << (p % 64);\n      update(p/64);\n      int pos = -1;\n      REP(j,l1) {\n        if (diff[j] != 64) {\n          pos = j * 64;\n          REP(k,64) {\n            if (!((ary[j] >> k) & 1)) {\n              pos += k;\n              break;\n            }\n          }\n          break;\n        }\n      }\n      if (pos < 0) {\n        pos = l1 * 64;\n        REP(j,n%64) {\n          if (!((ary[l1] >> j) & 1)) {\n            pos += j;\n            break;\n          }\n        }\n      }\n      cout << pos+1 << endl;\n      ary[pos/64] ^= UINT64_C(1) << (pos % 64);\n      update(pos/64);\n    } else {\n      ary[p/64] ^= UINT64_C(1) << (p % 64);\n      update(p/64);\n      int last1 = 0;\n      int last1sum = 0;\n      int sum = 0;\n      REP(i,l1) {\n        if (sum + inf[i] <= 1) {\n          last1 = i;\n          last1sum = sum;\n        }\n        sum += diff[i];\n      }\n      if (l1 != l2) {\n        if (sum + inf[l1] <= 1) {\n          last1 = l1;\n          last1sum = sum;\n        }\n      }\n      int pos = 0;\n      if (last1 != l1) {\n        int last1_s = 0;\n        REP(i,64) {\n          last1sum += ((ary[last1] >> i) & 1) ? 1 : -1;\n          if (last1sum <= 1) last1_s = i;\n        }\n        pos = last1 * 64 + last1_s + 1;\n      } else {\n        int last1_s = 0;\n        REP(i,n%64) {\n          last1sum += ((ary[last1] >> i) & 1) ? 1 : -1;\n          if (last1sum <= 1) last1_s = i;\n        }\n        pos = last1 * 64 + last1_s + 1;\n      }\n      cout << pos+1 << endl;\n      ary[pos/64] ^= UINT64_C(1) << (pos % 64);\n      update(pos/64);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstruct SegTree {\n    int n;\n    vi lazy, d_min;\n\n    int c1(int k) { return 2 * k + 1; }\n    int c2(int k) { return 2 * k + 2; }\n\n    SegTree(int sz){\n        n = 1;\n        while(n < sz) n *= 2;\n        d_min = vi(2 * n, inf);\n        lazy = vi(2 * n, 0);\n    }\n    SegTree(){}\n\n    void update(int k, int l, int r){\n        int& cur = lazy[k];\n        if(cur == 0) return;\n\n        if(d_min[k] == inf) d_min[k] = 0;\n        d_min[k] += cur;\n\n        if(r - l > 1){\n            lazy[c1(k)] += cur;\n            lazy[c2(k)] += cur;\n        }\n        cur = 0;\n    }\n\n    void add(int a, int b, int x, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return;\n        if(a <= l and r <= b){\n            lazy[k] += x;\n            update(k, l, r);\n            return;\n        }\n        \n        add(a, b, x, c1(k), l, (l + r) / 2);\n        add(a, b, x, c2(k), (l + r) / 2, r);\n        \n        if(r - l > 1){\n            d_min[k] = min(d_min[c1(k)], d_min[c2(k)]);\n        }\n    }\n\n    int get_min(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0) r = n;\n        update(k, l, r);\n\n        if(a >= r or l >= b) return inf;\n        if(a <= l and r <= b){\n            return d_min[k];\n        }\n        \n        return min(get_min(a, b, c1(k), l, (l + r) / 2),\n                   get_min(a, b, c2(k), (l + r) / 2, r));\n    }\n};\n\nint n;\nSegTree seg;\n\nbool check(int l, int r){\n    return seg.get_min(l, r) >= 2;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int Q; cin >> n >> Q;\n    string in; cin >> in;\n    set<int> s;\n    vi a(n); rep(i, n) a[i] = (in[i] == '(' ? +1:-1);\n    rep(i, n) if(a[i] < 0) s.insert(i);\n\n    seg = SegTree(n);\n    rep(i, n) seg.add(i, n, a[i]);\n\n    rep(loop, Q){\n        int x; cin >> x; x--;\n        int idx;\n        int cur = a[x];\n        // rep(i, n) cerr << seg.get_min(i, i + 1) << \" \"; cerr << endl;\n        if(cur > 0){\n            s.insert(x);\n            idx = *begin(s);\n            s.erase(idx);\n        }\n        else {\n            int lb = 0, ub = x;\n            while(ub - lb > 1){\n                int mid = (lb + ub) / 2;\n                if(check(mid, x + 1)){\n                    ub = mid;\n                }\n                else {\n                    lb = mid;\n                }\n            }\n            idx = ub;\n            s.erase(x);\n            s.insert(idx);\n        }\n        a[idx] *= -1;\n        a[x] *= -1;\n        seg.add(idx, n, cur * 2);\n        seg.add(  x, n, cur * -2);\n        cout << idx+1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint segMin[1 << 20], segAdd[1 << 20];\nint n, q;\nchar s[300001];\n \nvoid add(int a, int b, int x, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return;\n     \n    if (a <= l && r <= b){\n        segAdd[k] += x;\n        while (k){\n            k = (k - 1) / 2;\n            segMin[k] = min(segMin[k * 2 + 1] + segAdd[k * 2 + 1], segMin[k * 2 + 2] + segAdd[k * 2 + 2]);\n        }\n        return;\n    }\n     \n    add(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    add(a, b, x, k * 2 + 2, (l + r) / 2, r);\n}\n \nint getMin(int a, int b, int k = 0, int l = 0, int r = n)\n{\n    if (r <= a || b <= l) return (INT_MAX);\n     \n    if (a <= l && r <= b) return (segMin[k] + segAdd[k]);\n     \n    int left = getMin(a, b, k * 2 + 1, l, (l + r) / 2);\n    int right = getMin(a, b, k * 2 + 2, (l + r) / 2, r);\n     \n    return (min(left, right) + segAdd[k]);\n     \n}\n \nvoid fix(set<int> *a, set<int> *b, char before, int x)\n{\n    a->erase(x);\n    b->insert(x);\n     \n    int base = before == '(' ? -1 : 1;\n    s[x] = before == '(' ? ')' : '(';\n     \n    add(x, n, 2 * base);\n     \n    int l = 0, r = x;\n    int p;\n     \n    while (l != r){\n        int mid = l + r >> 1;\n        p = *b->lower_bound(mid);\n        if (getMin(p, n) >= 2 * base) r = mid;\n        else l = mid + 1;\n    }\n     \n    p = *b->lower_bound(l);\n    add(p, n, -2 * base);\n    b->erase(p);\n    a->insert(p);\n    s[p] = before;\n     \n    printf(\"%d\\n\", p + 1);\n}\n \nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    scanf(\"%s\", s);\n     \n    set<int> lf, rg;\n     \n    for (int i = 0; s[i]; i++){\n        if (s[i] == '('){\n            add(i, n, 1);\n            lf.insert(i);\n        }\n        else {\n            add(i, n, -1);\n            rg.insert(i);\n        }\n    }\n     \n    for (int i = 0; i < q; i++){\n        int x;\n        scanf(\"%d\", &x); x--;\n         \n        if (s[x] == '(') fix(&lf, &rg, '(', x);\n        else fix(&rg, &lf, ')', x);\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\ntemplate<typename V> class segtree{\nprivate:\n    int n,sz; vector<V> node, lazy;\npublic:\n    segtree(vector<V>& v){\n        sz = (int)v.size(); n = 1;\n        while(n < sz) n *= 2;\n        node.resize(2*n-1); lazy.resize(2*n-1, 0);\n        rep(i,sz) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[i*2+1],node[i*2+2]);\n    }\n    void eval(int k, int l, int r){\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k]; lazy[2*k+2] += lazy[k];\n            }\n            lazy[k] = 0;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] += x; eval(k, l, r);\n        }else{\n            range(a, b, x, 2*k+1, l, (l+r)/2); range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = min(node[2*k+1],node[2*k+2]);\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return numeric_limits<V>::max();\n        if(a <= l && r <= b) return node[k];\n        V vl = query(a, b, 2*k+1, l, (l+r)/2), vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl,vr);\n    }\n    void print(){rep(i,sz)cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<int> v(n);\n\tset<int>st;\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i]=='('){\n\t\t\tv[i]=1;\n\t\t}else{\n\t\t\tv[i] = -1;\n\t\t\tst.insert(i);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tv[i] += v[i-1];\n\t}\n\tsegtree<int> sg(v);\n\tfor(int i=0;i<m;i++){\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tif(s[a]=='('){\n\t\t\ts[a] = ')';\n\t\t\tsg.range(a,n,-2);\n\t\t\tst.insert(a);\n\t\t\tint x = *st.begin();\n\t\t\tcout << x+1 << endl;\n\t\t\ts[x] = '(';\n\t\t\tsg.range(x,n,2);\n\t\t\tst.erase(st.begin());\n\t\t}else{\n\t\t\ts[a] = '(';\n\t\t\tst.erase(a);\n\t\t\tsg.range(a,n,2);\n\t\t\tint ok = n-1,ng =-1;\n\t\t\twhile(abs(ok-ng)!=1){\n\t\t\t\tint mid = (ok+ng)/2;\n\t\t\t\tif(sg.query(mid,n)>=2){\n\t\t\t\t\tok = mid;\n\t\t\t\t}else{\n\t\t\t\t\tng = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsg.range(ok,n,-2);\n\t\t\ts[ok] = ')';\n\t\t\tst.insert(ok);\n\t\t\tcout << ok+1 << endl;\n\t\t}\n\t}\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, q, r, d[300000]; string s;\nclass bit {\nprivate:\n\tvector<int> dat; int size_;\n\tint query_(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return dat[k];\n\t\tint lc = query_(a, b, 2 * k, l, (l + r) / 2);\n\t\tint rc = query_(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tbit(int si) {\n\t\tfor (size_ = 1; size_ < si;) size_ <<= 1;\n\t\tdat.resize(size_ * 2);\n\t}\n\tvoid update(int i, int x) {\n\t\ti += size_; dat[i] = x;\n\t\twhile (i > 1) i >>= 1, dat[i] = dat[2 * i] + dat[2 * i + 1];\n\t}\n\tint query(int l, int r) {\n\t\treturn query_(l, r, 1, 0, size_);\n\t}\n};\nint main() {\n\tscanf(\"%d%d\", &n, &q); cin >> s;\n\tfor (int i = 0; i < n; i++) d[i] = (s[i] == '(' ? 1 : -1);\n\tbit b1(n); for (int i = 0; i < n; i++) b1.update(i, d[i] == -1 ? 1 : 0);\n\tbit b2(n); for (int i = 0; i < n; i++) b2.update(i, d[i]);\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> r; r--;\n\t\tif (d[r] == -1) {\n\t\t\tint sum = b2.query(0, r), l = r;\n\t\t\tfor (; l >= 1; l--) {\n\t\t\t\tif (sum < 2) break;\n\t\t\t\tsum -= d[l - 1];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", l + 1);\n\t\t\td[r] = 1; b1.update(r, 0); b2.update(r, 1);\n\t\t\td[l] = -1; b1.update(l, 1); b2.update(l, -1);\n\t\t}\n\t\telse {\n\t\t\tint pl = 0, pr = r;\n\t\t\twhile (pr - pl > 1) {\n\t\t\t\tint pm = (pl + pr) / 2, pc = b1.query(0, pm + 1);\n\t\t\t\tif (b1.query(0, pm + 1)) pr = pm;\n\t\t\t\telse pl = pm;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", pr + 1);\n\t\t\td[r] = -1; b1.update(r, 1); b2.update(r, -1);\n\t\t\td[pr] = 1; b1.update(pr, 0); b2.update(pr, 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\ntemplate<typename T> class segtree {\nprivate:\n  int n,sz,h;\n  vector<pair<T, int> > node;\n  vector<T> lazy;\n  void eval(int k) {\n    if(lazy[k]){\n      node[k].first += lazy[k];\n      if(k < n) {\n        lazy[k*2] += lazy[k], lazy[k*2+1] += lazy[k];\n      }\n      lazy[k] = 0;\n    }\n  }\npublic:\n  segtree(const vector<T>& v) : sz((int)v.size()), h(0) {\n    n = 1;\n    while(n < sz) n *= 2, h++;\n    node.resize(2*n, pair<T, int>(numeric_limits<T>::max(), sz));\n    lazy.resize(2*n, 0);\n    for(int i = 0; i < sz; i++){\n      node[i+n] = make_pair(v[i], i);\n    }\n    for(int i = n-1; i >= 1; i--){\n      node[i] = min(node[2*i], node[2*i+1]);\n    }\n  }\n  void range(int a, int b, T x, int k=1, int l=0, int r=-1){\n    if(r < 0) r = n;\n    eval(k);\n    if(b <= l || r <= a){\n      return;\n    }\n    if(a <= l && r <= b){\n      lazy[k] += x;\n      eval(k);\n    }else{\n      range(a, b, x, 2*k, l, (l+r)/2);\n      range(a, b, x, 2*k+1, (l+r)/2, r);\n      node[k] = min(node[2*k], node[2*k+1]);\n    }\n  }\n  pair<T, int> query(int a, int b) {\n    a += n, b += n - 1;\n    for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n    b++;\n    pair<T, int> res1 = make_pair(numeric_limits<T>::max(), sz);\n    pair<T, int> res2 = make_pair(numeric_limits<T>::max(), sz);\n    while(a < b) {\n      if(a & 1) eval(a), res1 = min(res1, node[a++]);\n      if(b & 1) eval(--b), res2 = min(res2, node[b]);\n      a >>= 1, b >>= 1;\n    }\n    return min(res1, res2);\n  }\n  void print() {\n    for(int i = 0; i < sz; i++){\n      pair<T,int> p;\n      p = query(i,i+1);\n      cout << \"st[\" << i << \"]: \" << p.first << \" \" << p.second << endl;\n    }\n  }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, q; cin >> n >> q;\n  string s; cin >> s;\n  vi v(n+1);\n  set<int> stl, str;\n  for(int i=0;i<(n);++i) {\n    if(s[i] == '(') {\n      v[i+1] = v[i] + 1;\n      stl.insert(i);\n    } else {\n      v[i+1] = v[i] - 1;\n      str.insert(i);\n    }\n  }\n  segtree<int> st(v);\n  for(int i=0;i<(q);++i) {\n    int idx; cin >> idx;\n    idx--;\n    if(stl.find(idx) != stl.end()) {\n      stl.erase(idx);\n      str.insert(idx);\n      st.range(idx+1, n+1, -2);\n      int pos = *(str.begin());\n      cout << pos + 1 << endl;\n      str.erase(pos);\n      stl.insert(pos);\n      st.range(pos+1, n+1, 2);\n    } else {\n      str.erase(idx);\n      stl.insert(idx);\n      st.range(idx+1, n+1, 2);\n      int l = -1, r = n-1;\n      while(r - l > 1) {\n        int mid = (l + r) / 2;\n        int mi = st.query(mid+1, n+1).first;\n        if(mi >= 2) {\n          r = mid;\n        } else {\n          l = mid;\n        }\n      }\n      cout << r + 1 << endl;\n      stl.erase(r);\n      str.insert(r);\n      st.range(r+1, n+1, -2);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        assert(q > 0);\n        close_parens.erase(q);\n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        \n        assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        \n        \n        \n        cout << pos_pos + 1 << endl;\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int INF = 1<<28;\n\nclass SegTree{\n\ttypedef int SegT;\n\tstatic const SegT defvalue = INF;\n\tprivate:\n\t\tvector<SegT> val, lazy;\n\t\tvector<int> lazyf;\n\t\tint n;\n\t\t\n\t\tSegT combine(SegT a, SegT b){\n\t\t\treturn min(a, b);\n\t\t}\n\t\tSegT merge(SegT a, SegT b){\n\t\t\treturn a+b;\n\t\t}\n\t\t\n\t\tvoid applyLazy(SegT k){\n\t\t\tif(lazyf[k]){\n\t\t\t\tlazyf[k] = 0;\n\t\t\t\tval[k] = merge(val[k], lazy[k]);\n\t\t\t\tif(k*2+2 < lazy.size()){\n\t\t\t\t\tlazy[k*2+1] = lazyf[k*2+1] ? merge(lazy[k*2+1], lazy[k]) : lazy[k];\n\t\t\t\t\tlazy[k*2+2] = lazyf[k*2+2] ? merge(lazy[k*2+2], lazy[k]) : lazy[k];\n\t\t\t\t\tlazyf[k*2+1] = lazyf[k*2+2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tSegTree(int size){\n\t\t\tn=1;\n\t\t\twhile(n<size)n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, 0);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t}\n\t\tSegTree(const vector<SegT> &in){\n\t\t\tn=1;\n\t\t\twhile(n<in.size())n<<=1;\n\t\t\tval=vector<SegT>(2*n, defvalue);\n\t\t\tlazy=vector<SegT>(2*n, -1);\n\t\t\tlazyf=vector<int>(2*n, 0);\n\t\t\tfor(int i=n-1 + in.size()-1;i>=0;i--){\n\t\t\t\tif(n-1 <= i) val[i] = in[i - (n-1)];\n\t\t\t\telse val[i] = combine(val[i*2+1],val[i*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値をaに更新する\n\t\tvoid update(int a,int b,SegT x,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tapplyLazy(k);\n\t\t\tif(r<=a||b<=l) return;\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\tlazy[k] = x;\n\t\t\t\tlazyf[k] = 1;\n\t\t\t\tapplyLazy(k);\n\t\t\t}else{\n\t\t\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\t\t\tval[k] = combine(val[k*2+1], val[k*2+2]);\n\t\t\t}\n\t\t}\n\t\t//[a, b) の値を取ってくる\n\t\tSegT query(int a,int b,int k=0,int l=0,int r=-1){\n\t\t\tif(r==-1)r=n;\n\t\t\tif(r<=a||b<=l) return defvalue;\n\t\t\tapplyLazy(k);\n\t\t\tif(a<=l&&r<=b){\n\t\t\t\treturn val[k];\n\t\t\t}else{\n\t\t\t\treturn combine(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t\t\t}\n\t\t}\n\t\tvoid print(){\n\t\t\tcout << val << endl;\n\t\t\tcout << lazy << endl;\n\t\t\tcout << lazyf << endl;\n\t\t}\n};\n\n\nint n, m;\nstring s;\nmain(){\n\tios::sync_with_stdio(false);\n\tset<int> close;\n\tcin >> n >> m >> s;\n\tvi d(s.size());\n\tREP(i, s.size()){\n\t\td[i] = (i?d[i-1]:0) + (s[i]=='(' ? 1 : -1);\n\t\tif(s[i]==')') close.insert(i);\n\t}\n\t\n\tSegTree seg(d);\n\t\n\tREP(q, m){\n\t\tint t;\n\t\tcin >> t;t--;\n\t\tif(s[t] == '('){\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tint t = *close.begin();\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\tcout << t+1 << endl;\n\t\t}else if(s[t] == ')'){\n\t\t\tseg.update(t, n, 2);\n\t\t\tclose.erase(t);\n\t\t\ts[t] = '(';\n\t\t\t\n\t\t\tint l=0, r=t;\n\t\t\twhile(l<r-1){\n\t\t\t\tint med=(l+r)/2;\n\t\t\t\tif(seg.query(med, t) <= 1) l = med;\n\t\t\t\telse r = med;\n\t\t\t}\n\t\t\tint t = r;\n\t\t\tseg.update(t, n, -2);\n\t\t\tclose.insert(t);\n\t\t\ts[t] = ')';\n\t\t\tcout << t+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct starrysky{\n  int n;\n  starrysky(){}\n  starrysky(int n_){init(n_);};\n  vector<int> data,datm;\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    data.clear();\n    datm.clear();\n    data.resize(2*n-1,0);\n    datm.resize(2*n-1,0);\n  }\n  void add(int a,int b,int x,int l,int r,int k){\n    if(r<=a||b<=l) return;\n    if(a<=l&&r<=b){\n      data[k]+=x;\n      return;\n    }\n    add(a,b,x,l,(l+r)/2,k*2+1);\n    add(a,b,x,(l+r)/2,r,k*2+2);\n    datm[k]=min(datm[k*2+1]+data[k*2+1],datm[k*2+2]+data[k*2+2]);\n  }\n  void add(int a,int b,int x){\n    add(a,b,x,0,n,0);\n  }\n  int query(int a,int b,int l,int r,int k){\n    if(r<=a||b<=l) return INT_MAX;\n    if(a<=l&&r<=b){\n      return data[k]+datm[k];\n    }\n    return min(query(a,b,l,(l+r)/2,k*2+1),query(a,b,(l+r)/2,r,k*2+2))+data[k];\n  }\n  int query(int a,int b){\n    return query(a,b,0,n,0);\n  }\n};\n#define MAX (1<<18)\nstring buf;\nint dp[MAX],imos[MAX];\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  cin>>buf;\n  set<int> s;\n  for(int i=0;i<n;i++) {\n    if(buf[i]=='(') dp[i]=1;\n    else dp[i]=-1;\n    if(buf[i]==')') s.insert(i);\n  }\n  imos[0]=dp[0];\n  for(int i=1;i<n;i++) imos[i]=imos[i-1]+dp[i];\n  starrysky ss(n);\n  for(int i=0;i<n;i++) ss.add(i,i+1,imos[i]);\n  for(int i=0;i<q;i++){\n    int p;cin>>p;p--;\n    if(dp[p]==1){\n      dp[p]*=-1;\n      s.insert(p);\n      ss.add(p,n,-2);\n      int k=*s.begin();\n      s.erase(k);\n      dp[k]*=-1;\n      ss.add(k,n,2);\n      cout<<k+1<<endl;\n    }else{\n      //cout<<p<<endl;\n      dp[p]*=-1;\n      s.erase(p);\n      ss.add(p,n,2);\n      int l=-1,r=p;\n      while(l+1<r){\n\tint m=(l+r)/2;\n\t//cout<<m<<\":\"<<ss.query(m,n)<<endl;\n\tif(ss.query(m,n)>=2) r=m;\n\telse l=m;\n      }\n      cout<<r+1<<endl;\n      dp[r]*=-1;\n      s.insert(r);\n      ss.add(r,n,-2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define For(i,n) for(int i=1;i<=n;i++)\n#define Fork(i,k,n) for(int i=k;i<=n;i++)\n#define Rep(i,n) for(int i=0;i<n;i++)\n#define ForD(i,n) for(int i=n;i;i--)\n#define ForkD(i,k,n) for(int i=n;i>=k;i--)\n#define RepD(i,n) for(int i=n;i>=0;i--)\n#define Forp(x) for(int p=Pre[x];p;p=Next[p])\n#define Forpiter(x) for(int &p=iter[x];p;p=Next[p])  \n#define Lson (o<<1)\n#define Rson ((o<<1)+1)\n#define MEM(a) memset(a,0,sizeof(a));\n#define MEMI(a) memset(a,127,sizeof(a));\n#define MEMi(a) memset(a,128,sizeof(a));\n#define INF (2139062143)\n#define F (1000000007)\n#define pb push_back\n#define mp make_pair \n#define fi first\n#define se second\n#define vi vector<int> \n#define pi pair<int,int>\n#define SI(a) ((a).size())\n#define Pr(kcase,ans) printf(\"Case #%d: %I64d\\n\",kcase,ans);\n#define PRi(a,n) For(i,n-1) cout<<a[i]<<' '; cout<<a[n]<<endl;\n#define PRi2D(a,n,m) For(i,n) { \\\n\t\t\t\t\t\tFor(j,m-1) cout<<a[i][j]<<' ';\\\n\t\t\t\t\t\tcout<<a[i][m]<<endl; \\\n\t\t\t\t\t\t} \n#pragma comment(linker, \"/STACK:102400000,102400000\")\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nll mul(ll a,ll b){return (a*b)%F;}\nll add(ll a,ll b){return (a+b)%F;}\nll sub(ll a,ll b){return ((a-b)%F+F)%F;}\nvoid upd(ll &a,ll b){a=(a%F+b%F)%F;}\nint read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(!isdigit(ch)) {if (ch=='-') f=-1; ch=getchar();}\n\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n} \n#define MAXN (200000+10)\n#define MEM2(a,x) memset(a,x,sizeof(a));\nint A[MAXN];\nclass SegmentTree  \n{  \n    ll a[MAXN*4],minv[MAXN*4],addv[MAXN*4];  \n    int n;  \npublic:  \n    void mem(int _n)  \n    {  \n        n=_n;  \n        MEMI(a) MEM(minv) MEM(addv)  \n    }  \n\tvoid build(int o,int L,int R) {\n\t\tif (L==R) {\n\t\t\tminv[o]=a[o]=A[L];\n\t\t\treturn;\n\t\t}\n\t\tint m=(L+R)/2;\n\t\tbuild(Lson,L,m);\n\t\tbuild(Rson,m+1,R);\n\t\tmaintain(o,L,R);\n\t}\n    void maintain(int o,int L,int R)  \n    {\n\t\tminv[o]=0;\n    \tif (L<R)\n\t\t{\n\t\t\tminv[o]=min(minv[Lson],minv[Rson]);\n\t\t} \n\t\tminv[o]+=addv[o];\n\t}\n\n\tint y1,y2,v;\n\tvoid update(int o,int L,int R)\n\t{\n\t\tif (y1<=L&&R<=y2) {\n\t\t\taddv[o]+=v; minv[o]+=v; return;\n\t\t}\n\t\telse{\n\t\t\tpushdown(o,L,R);\n\t\t\tint M=(R+L)>>1;\n\t\t\tif (y1<=M) update(Lson,L,M);\n\t\t\tif (M< y2) update(Rson,M+1,R);\n\t\t}\n\t\tmaintain(o,L,R); \n\t}\n\tvoid add(int l,int r,int v) {\n\t\ty1=l,y2=r,this->v=v;\n\t\tupdate(1,1,n);\n\t}\n\tvoid pushdown(int o,int L,int R) {\n\t\tif (L!=R&&addv[o]) {\n\t\t\taddv[Lson]+=addv[o];\n\t\t\taddv[Rson]+=addv[o];\n\t\t\tminv[Lson]+=addv[o];\n\t\t\tminv[Rson]+=addv[o];\n\t\t\taddv[o]=0;\n\t\t}\n\t}\n\tint query(int o,int L,int R)\n\t{\n\t\tif (L==R) return L;\n\t\tpushdown(o,L,R);\n\t\tint m=(L+R)/2;\n\t\tif (minv[Rson]<2) return query(Rson,m+1,R);\n\t\telse return query(Lson,L,m);\n\t}\n}S;   \nset<int> S1;\nset<int>::iterator it;\nint n;\nchar s[MAXN];\nint main()\n{\n//\tfreopen(\"G_data.in\",\"r\",stdin);\n//\tfreopen(\"G.out\",\"w\",stdout);\n\tint m;\n\twhile(cin>>n>>m) {\n\t\tscanf(\"%s\",s+1);\n\t\tS.mem(n); S1.clear();\n\t\tint p=0;\n\t\tFor(i,n) {\n\t\t\tif (s[i]=='(') p++; else p--,S1.insert(i);\n\t\t\tA[i]=p;\n\t\t}\n\t\tS.build(1,1,n);\n\t\tRep(i,m) {\n\t\t\tint c=0,p=read();\n//\t\t\tprintf(\"%s\\n\",s+1);\n//\t\t\tcout<<p<<endl;\n\t\t\tif (s[p]=='(') {\n\t\t\t\ts[p]=')';\n\t\t\t\tS1.insert(p);\n\t\t\t\tc=*S1.begin();\n\t\t\t\ts[c]='(';\n\t\t\t\tS1.erase(c);\n\t\t\t\tS.add(p,n,-2);\n\t\t\t\tS.add(c,n,2);\n\t\t\t} else {\n\t\t\t\tS1.erase(p);\n\t\t\t\tS.add(p,n,2);\n\t\t\t\ts[p]='(';\n\t\t\t\tint l=1,r=n,ans=r;\n\t\t\t\tans=S.query(1,1,n)+1;\n\t\t\t\tc=ans;\n\t\t\t\ts[c]=')';\n\t\t\t\tS1.insert(c);\n\t\t\t\tS.add(c,n,-2);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",c);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int INF=1e9;\n\nconst int N_MAX=1<<20;\nconst int DAT_SIZE=N_MAX*2-1;\nint dat[DAT_SIZE],lazy[DAT_SIZE];\nint n;\n\nvoid init(int size){\n  fill(begin(dat),end(dat),INF);\n  n=1;\n  while(n<size){\n    n*=2;\n  }\n}\n\nvoid lazy_eval(int k){\n  dat[k]+=lazy[k];\n  if(k<n-1){\n    lazy[k*2+1]+=lazy[k];\n    lazy[k*2+2]+=lazy[k];\n  }\n  lazy[k]=0;\n}\n\nint rangemin(int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return INF;\n  lazy_eval(k);\n  if(a<=l&&r<=b){\n    return dat[k];\n  }else{\n    int v1=rangemin(a,b,k*2+1,l,(l+r)/2);\n    int v2=rangemin(a,b,k*2+2,(l+r)/2,r);\n    return min(v1,v2);\n  }\n}\n\nint rangeadd(int v,int a,int b,int k,int l,int r){\n  if(r<=a||b<=l)return dat[k];\n  if(a<=l&&r<=b){\n    lazy[k]+=v;\n    lazy_eval(k);\n    return dat[k];\n  }else{\n    lazy_eval(k);\n    int v1=rangeadd(v,a,b,k*2+1,l,(l+r)/2);\n    int v2=rangeadd(v,a,b,k*2+2,(l+r)/2,r);\n    return dat[k]=min(v1,v2);\n  }\n}\n\nvoid change(int x,int v,int k,int l,int r){\n  lazy_eval(k);\n  if(k<n-1){\n    if(x<(l+r)/2){\n      change(x,v,k*2+1,l,(l+r)/2);\n    }else{\n      change(x,v,k*2+2,(l+r)/2,r);\n    }\n    lazy_eval(k*2+1);\n    lazy_eval(k*2+2);\n    dat[k]=min(dat[k*2+1],dat[k*2+2]);\n  }else{\n    dat[k]=v;\n  }\n}\n\nint main(){\n  int N,Q;\n  cin>>N>>Q;\n  init(N);\n  char s[323456];\n  cin>>s;\n  for(int i=0,c=0;i<N;i++){\n    c+=(s[i]=='(')-(s[i]==')');\n    change(i,c,0,0,n);\n  }\n  for(int i=0;i<n*2-1;i++){\n    //    cout<<i<<' '<<dat[i]<<endl;\n  }\n  while(Q--){\n    int q;\n    cin>>q;\n    q--;\n    if(s[q]=='('){\n      rangeadd(-2,q,N,0,0,n);\n      int l=-1,h=N;\n      while(h-l>1){\n\tint m=(l+h)/2;\n\tif(rangemin(m,m+1,0,0,n)==m+1){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      cout<<h+1<<endl;\n      rangeadd(2,h,N,0,0,n);\n      s[q]=')';\n      s[h]='(';\n    }else{\n      rangeadd(2,q,N,0,0,n);\n      int l=-1,h=q;\n      while(h-l>1){\n\tint m=(h+l)/2;\n\tif(rangemin(m,q+1,0,0,n)<=1){\n\t  l=m;\n\t}else{\n\t  h=m;\n\t}\n      }\n      // cout<<l<<' '<<h<<endl;\n      // for(int i=0;i<N;i++){\n      // \tcout<<i<<' '<<rangemin(i,i+1,0,0,n)<<endl;\n      // }\n      // cout<<l<<' '<<h<<' '<<q<<endl;\n      // cout<<rangemin(l,q+1,0,0,n)<<endl;\n      // cout<<rangemin(h,q+1,0,0,n)<<endl;\n      cout<<h+1<<endl;\n      rangeadd(-2,h,N,0,0,n);\n      s[q]='(';\n      s[h]=')';\n    }\n    //    cerr<<s<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  \n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N){\n    if (S[i] == ')') close_parens.insert(i);\n  }\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    // cout << S << \" \" << q << endl;\n    // REP(i, N) {\n    //   cout << pos_seg.sum(i, i + 1) << \" \" ;\n    // } \n    // cout << endl;\n    // cout << S << \" \" << q << endl;\n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      \n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n\n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx, N, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (q == 0 || sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        // cout << \"POYO\" << endl;\n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val =  pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        // cout << sum_pos + 1 << \" \" << q + 1 << endl;\n        // cout << pos_val << endl;\n        // cout << pos_pos << endl;\n        sum_seg.add(q + 1, N + 1, 2);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n      \n        cout << pos_pos + 1 << endl;\n      \n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        \n          close_parens.erase(q);\n          close_parens.insert(pos_pos);\n          pos_seg.add(q, q + 1, -1);\n          pos_seg.add(pos_pos, pos_pos + 1, 1);\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<set>\nusing namespace std;\nint n, q, x, ans ;\nstring str;\nset<int> l;\nset<int> r;\n#define INF (1<<29)\n\nint seg[1<<20];\nint all[1<<20];\n\nvoid add(int l, int r, int val, int bottom = 0, int top = 1 << 19, int p = 1){\n\tif(r <= bottom || top <= l)return;\n\tif(l <= bottom && top <= r){\n\t\tall[p] += val;\n\t\treturn;\n\t}\n\tint mid = (top + bottom) / 2;\n\tadd(l, r, val, bottom, mid, p*2);\n\tadd(l, r, val, mid, top, p*2+1);\n\tseg[p] = min(seg[p*2] + all[p*2], seg[p*2+1] + all[p*2+1]);\n}\n\nint minval(int l, int r, int bottom = 0, int top = 1 << 19, int p = 1){\n\tif(r <= bottom || top <= l)return INF;\n\tif(l <= bottom && top <= r)return seg[p] + all[p];\n\tint mid = (top + bottom) / 2;\n\treturn all[p] + min(minval(l, r, bottom, mid, p * 2),\n\t\t\t\t\t\t\t\t\t\t\tminval(l, r, mid, top, p * 2 + 1));\n}\n\n\n\nint solve(int x){\n\tint l = 0, rr = n;\n\twhile(rr - l > 1){\n\t\tint mid = (l + rr) / 2;\n\t\tint tmp = *r.lower_bound(mid);\n\t\tif(minval(mid, n) < 2)l = mid;\n\t\telse rr = mid;\n\t}\n\treturn rr;\n}\n\nint main(){\n\tcin >> n >> q;\n\tcin >> str;\n\tfor(int i = 0;i < str.size();i++){\n\t\tif(str[i] == '('){\n\t\t\tadd(i,n, 1);\n\t\t\tl.insert(i);\n\t\t}\n\t\tif(str[i] == ')'){\n\t\t\tadd(i,n, -1);\n\t\t\tr.insert(i);\n\t\t}\n\t}\n\twhile(q--){\n\t\tcin >> x;x--;\n\t\tif(str[x] == '('){\n\t\t\tstr[x] = ')';\n\t\t\tl.erase(x);\n\t\t\tr.insert(x);\n\t\t\tadd(x,n,-2);\n\t\t\tans = *r.begin();\n\t\t\tr.erase(ans);\n\t\t\tl.insert(ans);\n\t\t\tadd(ans, n, 2);\n\t\t\tstr[ans] = '(';\n\t\t}\n\t\telse{\n\t\t\tl.insert(x);\n\t\t\tr.erase(x);\n\t\t\tstr[x] = '(';\n\t\t\tadd(x, n, 2);\n\t\t\tans = solve(x);\n\t\t\tl.erase(ans);\n\t\t\tr.insert(ans);\n\t\t\tadd(ans,n, -2);\n\t\t\tstr[ans] = ')';\n\t\t}\n\t\tans++;\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#define MAX 1000100\n#define N 300100\n\nint n, m, qidx;\nchar str[N];\nint minval[MAX], flag[MAX], prefix[MAX];\nmap<int, int> ridxs;\n\ninline void push_down(int left, int right, int idx){\n  if(left == right){\n    minval[idx] += flag[idx];\n    flag[idx] = 0;\n    return;\n  }\n  \n  minval[idx] += flag[idx];\n  flag[idx << 1] += flag[idx];\n  flag[idx << 1 | 1] += flag[idx];\n  flag[idx] = 0;\n}\n\ninline void push_up(int left, int right, int idx){\n  if(left == right){ push_down(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  push_down(left, right, idx);\n  push_down(left, mid, idx << 1);\n  push_down(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\ninline int query(int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end) return minval[idx];\n  \n  int mid = (left + right) >> 1, res;\n  if(end <= mid) res = query(start, end, left, mid, idx << 1);\n  else if(mid < start) res = query(start, end, mid + 1, right, idx << 1 | 1);\n  else res = min(query(start, end, left, mid, idx << 1), query(start, end, mid + 1, right, idx << 1 | 1));\n  return res;\n}\n\ninline void update(int val, int start, int end, int left, int right, int idx){\n  push_down(left, right, idx);\n  if(start <= left && right <= end){ flag[idx] += val; push_up(left, right, idx); return; }\n  \n  int mid = (left + right) >> 1;\n  if(end <= mid) update(val, start, end, left, mid, idx << 1);\n  else if(mid < start) update(val, start, end, mid + 1, right, idx << 1 | 1);\n  else{\n    update(val, start, end, left, mid, idx << 1);\n    update(val, start, end, mid + 1, right, idx << 1 | 1);\n  }\n  push_up(left, right, idx);\n}\n\ninline void build(int left, int right, int idx){\n  if(left == right){ minval[idx] = prefix[left]; return; }\n\n  int mid = (left + right) >> 1;\n  build(left, mid, idx << 1);\n  build(mid + 1, right, idx << 1 | 1);\n  minval[idx] = min(minval[idx << 1], minval[idx << 1 | 1]);\n}\n\nint main(){\n  while(scanf(\"%d%d\", &n, &m) == 2){\n    ridxs.clear();\n    memset(flag, 0, sizeof(flag));\n    \n    scanf(\"%s\", str + 1);\n    \n    prefix[0] = 0;\n    for(int i = 1; i <= n; i++) prefix[i] = prefix[i - 1] + (str[i] == '(' ? 1 : -1);\n    for(int i = 1; i <= n; i++) if(str[i] == ')') ridxs[i] = 1;\n    \n    build(1, n, 1);\n    \n    int ans;\n    for(int i = 1; i <= m; i++){\n      scanf(\"%d\", &qidx);\n      \n      if(str[qidx] == '('){\n        ridxs[qidx] = 1;\n        ans = ridxs.begin()->first;\n        ridxs.erase(ridxs.find(ans));\n        str[qidx] = ')'; str[ans] = '(';\n        if(ans != qidx) update(2, ans, qidx - 1, 1, n, 1);\n      }\n      else{\n        if(query(qidx - 1, qidx - 1, 1, n, 1) < 2) ans = qidx;\n        else{\n          int lidx = 1, ridx = qidx - 1;\n          while(ridx - lidx > 1){\n            int mid = (lidx + ridx) >> 1;\n            if(query(mid, ridx, 1, n, 1) < 2) lidx = mid;\n            else ridx = mid;\n          }\n          ans = ridx;\n          \n          update(-2, ans, qidx - 1, 1, n, 1);\n          ridxs.erase(ridxs.find(qidx));\n          ridxs[ans] = 1;\n          str[qidx] = '('; str[ans] = ')';\n        }\n      }\n      \n         \n      printf(\"%d\\n\", ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <set>\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n\n\ntemplate <typename T> class SegTree{\n  struct node_t{\n    T   min;\n    T   sum;\n    T   add;\n    int left_pos;\n    int right_pos;\n  };\n    \n  int                 N;\n  std::vector<T>      A;\n  std::vector<node_t> data;\n\n  inline void eval(int k, int l, int r){\n    if(data[k].add == 0) return;\n    \n    if(r - l > 1){\n      data[2 * k + 1].add += data[k].add;\n      data[2 * k + 2].add += data[k].add;\n    }\n    \n    data[k].sum += data[k].add * (r - l);\n    data[k].min += data[k].add;\n    data[k].add  = 0;\n  }\n  \n  inline void merge(int k){\n    int chl  = k * 2 + 1;\n    int chr  = k * 2 + 2;\n    T   lmin = data[chl].min;\n    T   rmin = data[chr].min;\n    data[k].sum = data[chl].sum + data[chr].sum;\n    data[k].min = std::min(lmin, rmin);\n    data[k].left_pos = lmin <= rmin ? data[chl].left_pos : data[chr].left_pos;\n    data[k].right_pos = lmin >= rmin ? data[chr].right_pos : data[chl].right_pos;\n  }\n    \n  void build(int k, int l, int r){\n    if(r - l == 1){\n      data[k].min = A[l];\n      data[k].sum = A[l];\n      data[k].left_pos = data[k].right_pos = l;\n      data[k].add = 0;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = 2 * k + 1;\n      int chr = 2 * k + 2;\n      build(chl, l, m);\n      build(chr, m, r);\n      merge(k);\n    }\n  }\n  \n  void add(int a, int b, T x, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return;\n    }else if(a <= l && r <= b){\n      data[k].add += x;\n      eval(k, l, r);\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      add(a, b, x, chl, l, m);\n      add(a, b, x, chr, m, r);\n      merge(k);\n    }\n  }\n  \n  T min(int a, int b, int &pos, int k, int l, int r, bool left_min_pos){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return std::numeric_limits<T>::max();\n    }else if(a <= l && r <= b){\n      pos =left_min_pos ? data[k].left_pos :  data[k].right_pos;\n      return data[k].min;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      int lpos = -1, rpos = -1;\n      T lmin = min(a, b, lpos, chl, l, m, left_min_pos);\n      T rmin = min(a, b, rpos, chr, m, r, left_min_pos);\n      merge(k);\n      pos = lmin < rmin ? lpos : rpos;\n      if (lmin == rmin){\n        pos  = (left_min_pos ? lpos : rpos);\n      }\n      return std::min(lmin, rmin);\n    }\n  }\n  \n  T sum(int a, int b, int k, int l, int r){\n    eval(k, l, r);\n    if(b <= l || r <= a){\n      return 0;\n    }else if(a <= l && r <= b){\n      return data[k].sum;\n    }else{\n      int m   = (l + r) / 2;\n      int chl = k * 2 + 1;\n      int chr = k * 2 + 2;\n      T   vl  = sum(a, b, chl, l, m);\n      T   vr  = sum(a, b, chr, m, r);\n      merge(k);\n      return vl + vr;\n    }\n  }\n  \npublic:\n  SegTree(size_t N) : N(N), A(std::vector<T>(N, 0)){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  SegTree(const std::vector<T> &A) : N(A.size()), A(A){\n    data.resize(4 * N);\n    build(0, 0, N);\n  }\n    \n  void add(int l, int r, T x) {add(l, r, x, 0, 0, N);}\n  T min(int l, int r, int &pos, bool left_min_pos = true)\n  {pos = -1; return min(l, r, pos, 0, 0, N, left_min_pos);}\n  T min(int l, int r){int tmp;return min(l, r, tmp);}\n  T sum(int l, int r){return sum(l, r, 0, 0, N);}\n};\n\nint main(int argc, char *argv[])\n{\n  int N, Q;\n  string S;\n  cin >> N >> Q;\n  cin >> S;\n  \n  vector<int> open_sum(N + 1, 0);\n  vector<int> open_pos(N);\n  \n  REP(i, N){\n    open_sum[i + 1] = open_sum[i] + (S[i] == '(' ? 1 : -1);\n    open_pos[i] = (S[i] != '(');\n  }\n  \n  assert(open_sum[N] == 0);\n  SegTree<int> sum_seg(open_sum);\n  SegTree<int> pos_seg(open_pos);\n  \n  set<int> close_parens;\n  REP(i, N) if(S[i] == ')') close_parens.insert(i);\n  \n  while (Q--){\n    int q;\n    cin >> q; q--;\n    \n    if (S[q] == '('){\n      close_parens.insert(q);\n      int min_idx = *close_parens.begin();\n      close_parens.erase(min_idx);\n      if (min_idx != q){\n        S[min_idx] = '(';\n        S[q] = ')';\n        \n        sum_seg.add(q + 1, N + 1, -2);\n        sum_seg.add(min_idx + 1, N + 1, 2);\n        \n        pos_seg.add(min_idx, min_idx + 1, -1);\n        pos_seg.add(q, q + 1, 1);\n      }\n      cout << min_idx + 1 << endl;\n    } else if (S[q] == ')'){\n      if (sum_seg.sum(q + 1, q + 2) == 0) {\n        cout << q + 1 << endl;\n      } else {\n        // assert(q > 0);\n        close_parens.erase(q);\n        pos_seg.add(q, q + 1, -1);\n        sum_seg.add(q + 1, N + 1, 2);\n        \n        int sum_pos = -1, pos_pos = -1;\n        int min_val = sum_seg.min(0, q + 1, sum_pos, false);\n        int pos_val = pos_seg.min(sum_pos + 1, q + 1, pos_pos, true);\n        \n        assert(sum_seg.min(0, N + 1) >= 0);\n        // assert(sum_seg.sum(sum_pos + 0, sum_pos + 1) == 0);\n        // cout << sum_seg.sum(sum_pos + 2, sum_pos + 3) << endl;\n        // assert(sum_seg.sum(sum_pos + 2, sum_pos + 3) == 2);\n        cout << pos_pos + 1 << endl;\n        close_parens.insert(pos_pos);\n        sum_seg.add(pos_pos + 1, N + 1, -2);\n        pos_seg.add(pos_pos, pos_pos + 1, 1);\n\n        if (q != pos_pos){\n          S[q] = '(';\n          S[pos_pos] = ')';\n        }\n      }\n    } else { assert(false);}\n  } \n \n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll *min_data,*max_data,*add_data;\nchar buf[300001];\nint N = 1;\n\nvoid init(ll first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid add(int left,int right,ll value,int node_id,int node_left,int node_right){\n\n\tif(right < node_left || left > node_right){\n\t\t//範囲外ならreturn\n\t\treturn;\n\t}\n\telse if(left <= node_left && right >= node_right){ //このノードのカバーしている区間が、更新区間の部分区間である場合\n\n\t\tadd_data[node_id] += value; //一様に加える値を加算\n\n\t\twhile(node_id != 0){\n\n\t\t\tnode_id = (node_id-1)/2; //下から上に向かって、最小値および最大値更新\n\t\t\tmin_data[node_id] = min(min_data[2*node_id+1]+add_data[2*node_id+1],min_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t\tmax_data[node_id] = max(max_data[2*node_id+1]+add_data[2*node_id+1],max_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t}\n\t}else{\n\n\t\tadd(left,right,value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tadd(left,right,value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nll getMin(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn min_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_min  = getMin(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_min = getMin(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn min(left_min,right_min)+add_data[node_id];\n\t}\n}\n\nll getMax(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return -BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn max_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_max  = getMax(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_max = getMax(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn max(left_max,right_max)+add_data[node_id];\n\t}\n}\n\nint main(){\n\n\tint first_N,Q;\n\tscanf(\"%d %d\",&first_N,&Q);\n\n\tinit(first_N);\n\n\tmin_data = new ll[2*N-1];\n\tmax_data = new ll[2*N-1];\n\tadd_data = new ll[2*N-1];\n\n\tfor(ll i = 0; i <= 2*N-2; i++){\n\t\tmin_data[i] = 0;\n\t\tmax_data[i] = 0;\n\t\tadd_data[i] = 0;\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tset<int> CLOSE;\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tif(buf[i] == '('){\n\t\t\tadd(i,N-1,1,0,0,N-1);\n\t\t}else{\n\t\t\tCLOSE.insert(i);\n\t\t\tadd(i,N-1,-1,0,0,N-1);\n\t\t}\n\t}\n\n\tint loc,calc_loc;\n\tint left,right,m;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&loc);\n\t\tloc--;\n\n\t\tif(buf[loc] == '('){\n\n\t\t\tbuf[loc] = ')';\n\t\t\tadd(loc,N-1,-2,0,0,N-1);\n\t\t\tCLOSE.insert(loc);\n\n\t\t\tcalc_loc = *begin(CLOSE);\n\t\t\tCLOSE.erase(begin(CLOSE));\n\n\t\t\tadd(calc_loc,N-1,2,0,0,N-1);\n\t\t\tbuf[calc_loc] = '(';\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\n\t\t}else{ //buf[loc] == ')'\n\n\t\t\tCLOSE.erase(loc);\n\t\t\tbuf[loc] = '(';\n\t\t\tadd(loc,N-1,2,0,0,N-1);\n\n\t\t\tleft = 0,right = first_N-1, m = (left+right)/2;\n\n\t\t\twhile(left <= right){\n\t\t\t\tif(getMin(m,N-1,0,0,N-1) >= 2){\n\t\t\t\t\tcalc_loc = m;\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\twhile(buf[calc_loc] != '(')calc_loc++;\n\n\t\t\tbuf[calc_loc] = ')';\n\t\t\tadd(calc_loc,N-1,-2,0,0,N-1);\n\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\t\t\tCLOSE.insert(calc_loc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<int> seg, delay;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t\tdelay.resize(1<<(size+1));\n\t}\n\t\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++){\n\t\t\tseg[i] = inf;\n\t\t\tdelay[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid eval(int l, int r, int k)\n\t{\n\t\tif(delay[k]){\n\t\t\tseg[k] += delay[k];\n\t\t\tdelay[k*2] += delay[k];\n\t\t\tdelay[k*2+1] += delay[k];\n\t\t\tdelay[k] = 0;\n\t\t}\n\t}\n\t\n\tvoid update(int i, int val)\n\t{\n\t\ti += (1 << size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\t\n\tvoid add(int a, int b, int k, int l, int r, int val)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return;\n\t\tif(a <= l && r <= b){\n\t\t\tdelay[k] += val;\n\t\t\teval(l, r, k);\n\t\t\treturn;\n\t\t}\n\t\tadd(a, b, k*2, l, (l+r)/2, val);\n\t\tadd(a, b, k*2+1, (l+r)/2+1, r, val);\n\t\tseg[k] = min(seg[k*2], seg[k*2+1]);\n\t}\n\tvoid add(int a, int b, int val){\n\t\tif(a > b) return;\n\t\tadd(a, b, 1, 0, (1<<size)-1, val);\n\t}\n\n\tint query(int a, int b, int k, int l, int r)\n\t{\n\t\teval(l, r, k);\n\t\t\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nint N, Q;\nstring s;\nSegTree seg(19);\nset<int> cand;\n\nint getans(int p)\n{\n\tint ub = p, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(seg.query(mid, p) >= 2) ub = mid;\n\t\telse lb = mid;\n\t}\n\treturn ub;\n}\n\nint main(void)\n{\n\tcin >> N >> Q;\n\tcin >> s;\n\ts = \" \" + s;\n\t\n\tseg.init();\n\tint sum = 0;\n\tfor(int i = 1; i <= N; i++){\n\t\tif(s[i] == '(') sum++;\n\t\telse{\n\t\t\tsum--;\n\t\t\tcand.insert(i);\n\t\t}\n\t\tseg.update(i, sum);\n\t}\n\t\n\tint p, ans;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p;\n\t\tif(s[p] == '('){\n\t\t\ts[p] = ')';\n\t\t\tcand.insert(p);\n\t\t\tseg.add(p, N, -2);\n\t\t\t\n\t\t\twhile(s[*cand.begin()] == '(') cand.erase(cand.begin());\n\t\t\tans = *cand.begin();\n\t\t\ts[ans] = '(';\n\t\t\tcand.erase(cand.begin());\n\t\t\tseg.add(ans, N, 2);\n\t\t}\n\t\telse{\n\t\t\ts[p] = '(';\n\t\t\tcand.erase(p);\n\t\t\tseg.add(p, N, 2);\n\t\t\t\n\t\t\tans = getans(p);\n\t\t\ts[ans] = ')';\n\t\t\tcand.insert(ans);\n\t\t\tseg.add(ans, N, -2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M = 1000000007;\n\nclass segtree {\npublic:\n    struct node {\n        int mi, sum, mii;\n        node() {}\n        node(int mi, int sum, int mii) : mi(mi), sum(sum), mii(mii) {}\n    };\nprivate:\n    int n, s, t;\n    vector<node> tr;\n\n    node f(node a, node b) {\n        return node(min(a.mi, a.sum + b.mi), a.sum + b.sum, a.mi < a.sum + b.mi ? a.mii : b.mii);\n    }\n    const node ex = node(M, 0, -1);\n    node q(int k, int l, int r) {\n        return r <= s || t <= l ? ex : s <= l && r <= t ? tr[k]\n                : f(q(k << 1 | 1, l, (l + r) >> 1), q((k + 1) << 1, (l + r) >> 1, r));\n    }\n\npublic:\n    segtree(int m) {\n        n = 1;\n        while (n < m) n <<= 1;\n        tr.clear();\n        tr.resize((n << 1) - 1, ex);\n    }\n    void update(int j, const int& x) {\n        int i = j + n - 1;\n        tr[i] = node(x, x, j);\n        while (i > 0) { i = (i - 1) >> 1; tr[i] = f(tr[i << 1 | 1], tr[(i + 1) << 1]); }\n    }\n    // [s, t)\n    node run(int _s, int _t) { s = _s; t = _t; return q(0, 0, n); }\n};\n\n\n\nint main() {\n    int n, q;\n    string s;\n    cin >> n >> q >> s;\n    set<int> cp;\n    segtree sg(n);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(')\n            sg.update(i, 1);\n        else {\n            sg.update(i, -1);\n            cp.insert(i);\n        }\n    }\n    for (int _ = 0; _ < q; ++_) {\n        int t;\n        cin >> t;\n        --t;\n        if (s[t] == '(') {\n            cp.insert(t);\n            sg.update(t, -1);\n\n            s[t] = ')';\n\n            int u = *cp.begin();\n            cp.erase(cp.begin());\n            sg.update(u, 1);\n\n            s[u] = '(';\n            cout << u + 1 << \"\\n\";\n        }\n        else {\n            cp.erase(t);\n            sg.update(t, 1);\n\n            s[t] = '(';\n\n            segtree::node nod = sg.run(0, n);\n            if (nod.mi == 0)\n                nod = sg.run(nod.mii + 1, n);\n\n            int u = nod.mii + 1;\n            cp.insert(u);\n            sg.update(u, -1);\n\n            s[u] = ')';\n            cout << u + 1 << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300000;\nconst int MAX_Q = 150000;\nconst int MAX_E2 = 1 << 20;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef set<int> si;\n\nstruct SegTreeSumMin {\n  int n, e2;\n  int nodes[MAX_E2], mins[MAX_E2];\n\n  SegTreeSumMin() { clear(); }\n  SegTreeSumMin(int _n) { init(_n); clear(); }\n\n  void init(int _n) {\n    n = _n;\n    for (e2 = 1; e2 < n; e2 <<= 1);\n  }\n\n  void clear() {\n    //for (int i = 0; i < MAX_E2; i++) nodes[i] = INF;\n  }\n\n  int get(int i) { return nodes[e2 - 1 + i]; }\n\n  void set(int i, int v) {\n    int j = e2 - 1 + i;\n    nodes[j] = mins[j] = v;\n    j = (j - 1) / 2;\n\n    for (;;) {\n      int j0 = j * 2 + 1, j1 = j0 + 1;\n      nodes[j] = nodes[j0] + nodes[j1];\n      mins[j] = min(mins[j0], nodes[j0] + mins[j1]);\n      if (j == 0) break;\n      j = (j - 1) / 2;\n    }\n  }\n\n  int min_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return INF;\n    if (r0 <= i0 && i1 <= r1) return mins[k] + sum_range(0, i0);\n\n    int im = (i0 + i1) / 2;\n    int v0 = min_range(r0, r1, k * 2 + 1, i0, im);\n    int v1 = min_range(r0, r1, k * 2 + 2, im, i1);\n\n    return min(v0, v1);\n  }\n\n  int min_range(int r0, int r1) {\n    return min_range(r0, r1, 0, 0, e2);\n  }\n\n  int min_all() { return mins[0]; }\n\n  int sum_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return 0;\n    if (r0 <= i0 && i1 <= r1) return nodes[k];\n\n    int im = (i0 + i1) / 2;\n    int v0 = sum_range(r0, r1, k * 2 + 1, i0, im);\n    int v1 = sum_range(r0, r1, k * 2 + 2, im, i1);\n\n    return v0 + v1;\n  }\n\n  int sum_range(int r0, int r1) {\n    return sum_range(r0, r1, 0, 0, e2);\n  }\n\n  int sum_all() { return sum_range(0, n); }\n  \n  void print() {\n    for (int i = 0; i < n; i++) cout << min_range(i, n) << ' ';\n    cout << endl;\n  }\n};\n\n/* global variables */\n\nint n, q;\nstring str;\nint ps[MAX_N];\n\nSegTreeSumMin stsm;\nsi pcls;\n\n/* main */\n\nint main() {\n  cin >> n >> q;\n  cin >> str;\n\n  stsm.init(n);\n  \n  for (int i = 0; i < n; i++) {\n    if (str[i] == '(')\n      stsm.set(i, 1);\n    else {\n      stsm.set(i, -1);\n      pcls.insert(i);\n    }\n  }\n  \n  while (q--) {\n    int qi;\n    cin >> qi;\n    qi--;\n\n    int pqi = stsm.get(qi);\n    int r = -pqi;\n    stsm.set(qi, r);\n\n    //stsm.print();\n    //cout << stsm.min_all() << endl;\n\n    if (pqi == 1) { // '('->')'\n      pcls.insert(qi);\n      int i = *pcls.begin();\n      pcls.erase(pcls.begin());\n      stsm.set(i, 1);\n      cout << (i + 1) << endl;\n    }\n    else { // ')'->'('\n      pcls.erase(qi);\n      //stsm.print();\n      \n      int i0 = -1, i1 = qi;\n\n      while (i0 + 1 < i1) {\n\tint i = (i0 + i1) / 2;\n\tif (stsm.min_range(i, qi) >= 2) i1 = i;\n\telse i0 = i;\n      }\n      //printf(\"i1=%d\\n\", i1);\n      while (stsm.get(i1) != 1) i1++;\n\n      stsm.set(i1, -1);\n      pcls.insert(i1);\n      cout << (i1 + 1) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nusing pii = pair<int, int>;\npair<int, int> operator+(const pair<int, int> &l, const pair<int, int> &r) {\n\treturn make_pair(l.first + r.first, l.second + r.second);\n}\ntemplate<typename T> T inf() { assert(false); }\ntemplate<> constexpr pii inf<pii>() { return pii(1e9,1e9); }\ntemplate <typename T>\nclass StarrySkyTree {\n\tconst int n;\n\tvector<T> data, lazy;\n\tvoid add_sub(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) { lazy[node] = lazy[node] + val; return; }\n\t\tint left = node * 2, right = left + 1;\n\t\tadd_sub(l, r, left, lb, (lb + ub) / 2, val);\n\t\tadd_sub(l, r, right, (lb + ub) / 2, ub, val);\n\t\tdata[node] = min(data[left] + lazy[left], data[right] + lazy[right]);\n\t}\n\tT min_sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return inf<pii>();\n\t\tif (l <= lb && ub <= r) return data[node] + lazy[node];\n\t\tT vl = min_sub(l, r, node * 2 + 0, lb, (lb + ub) / 2);\n\t\tT vr = min_sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t\treturn lazy[node] + min(vl, vr);\n\t}\n\tint size(int n) {\n\t\treturn n == 1 ? n : size((n + 1) / 2) * 2;\n\t}\npublic:\n\tStarrySkyTree(int m) : n(size(m)), data(n * 2, pii(0, 0)), lazy(n * 2, pii(0, 0)) {}\n\tvoid add(int l, int r, T val) { add_sub(l, r, 1, 0, n, val); }\n\tT minimum(int l, int r) { return min_sub(l, r, 1, 0, n); }\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint N, Q;\n\tcin >> N >> Q;\n\tstring s; cin >> s;\n\tStarrySkyTree<pii> seg(N);\n\tvi sum(N+1);\n\tREP(i, N)\n\t{\n\t\tsum[i + 1] = sum[i] + (s[i] == '(' ? 1 : -1);\n\t\tseg.add(i, i + 1, pii(sum[i+1], -i));\n\t}\n\tset<int> st;\n\tREP(i, N)\n\t{\n\t\tif (s[i] == ')') st.insert(i);\n\t}\n\tREP(i, Q)\n\t{\n\t\tint t; cin >> t;\n\t\tt--;\n\t\tif (s[t] == '(')\n\t\t{\n\t\t\ts[t] = ')';\n\t\t\tst.insert(t);\n\t\t\tseg.add(t, N, pii(-2, 0));\n\t\t\tint flip = *st.begin();\n\t\t\ts[flip] = '(';\n\t\t\tseg.add(flip, N, pii(2, 0));\n\t\t\tst.erase(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t\telse if(s[t] == ')')\n\t\t{\n\t\t\ts[t] = '(';\n\t\t\tst.erase(t);\n\t\t\tseg.add(t, N, pii(2, 0));\n\t\t\tpii tmp = seg.minimum(0, t);\n\t\t\tint flip;\n\t\t\tif (tmp.first == 0) flip = -tmp.second + 2;\n\t\t\telse if (tmp.first == 1) flip = -tmp.second + 1;\n\t\t\telse flip = 1;\n\t\t\ts[flip] = ')';\n\t\t\tseg.add(flip, N, pii(-2, 0));\n\t\t\tst.insert(flip);\n\t\t\tcout << flip + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\n#ifndef LIB_DATA_SEGMENT_TREE_HPP\n#define LIB_DATA_SEGMENT_TREE_HPP\n#include <vector>\n#include <limits>\n#include <cassert>\n#ifndef LIB_REPEAT_HPP\n#define LIB_REPEAT_HPP\n#define repeat(i,n) for (int i = 0; i < (n); ++i)\n#define repeat_from(i,m,n) for (int i = (m); i < (n); ++i)\n#define repeat_one(i,n) for (int i = 1; i <= (n); ++i)\n#define repeat_rev(i,n) for (int i = (n)-1; 0 <= i; --i)\n#define foreach(it, cont) for (decltype(cont.begin()) it = cont.begin(); it != cont.end(); ++it)\n#endif\nstruct segment_index {\n    int k;\n    operator int() const { return k; }\n    segment_index up()    const { return (segment_index) { (k-1)/2 }; }\n    segment_index left()  const { return (segment_index) { k*2+1 }; }\n    segment_index right() const { return (segment_index) { k*2+2 }; }\n};\n\nstruct segment_range {\n    int k, l, r;\n    operator int() const { return k; }\n    segment_range left()  const { return (segment_range) { k*2+1, l, (l+r)/2 }; }\n    segment_range right() const { return (segment_range) { k*2+2, (l+r)/2, r }; }\n    bool is_contained  (int a, int b) const { return a <= l and r <= b; }\n    bool is_intersected(int a, int b) const { return l < b and a < r; }\n};\n\ntemplate <typename T>\nstruct segment_tree {\n    static int power_ge(int n) {\n        int m = 1;\n        while (m < n) m *= 2;\n        return m;\n    }\n    std::vector<T> v;\n    int orig_n;\n    segment_tree(int n)            : v(power_ge(n)*2-1)          , orig_n(n) {}\n    segment_tree(int n, T initial) : v(power_ge(n)*2-1, initial) , orig_n(n) {}\n    T & operator [] (size_t i) { return v[i]; }\n    const T & operator [] (size_t i) const { return v[i]; }\n    segment_index index_at(int i) const { return (segment_index) { i + power_ge(orig_n) - 1 }; }\n    segment_range root_range()    const { return (segment_range) { 0, 0, power_ge(orig_n) }; }\n};\n\ntemplate <typename T>\nstruct range_maximum_query {\n    segment_tree<T> v;\n    int size() const { return v.orig_n; }\n    range_maximum_query(int n)            : v(n)          {}\n    range_maximum_query(int n, T initial) : v(n, initial) {}\n    range_maximum_query(std::vector<T> w) : v(w.size()) {\n        repeat (i,w.size()) update_at(i,w[i]);\n    }\n\n    void update_at(int i, T x) {\n        assert (0 <= i and i < size());\n        segment_index k = v.index_at(i);\n        v[k] = x;\n        while (0 < k) {\n            k = k.up();\n            v[k] = std::max(v[k.left()], v[k.right()]);\n        }\n    }\n\n    // [s,t)\n    T max_query(int s, int t) {\n        assert (0 <= s and s < t and t <= size());\n        return max_query(s, t, v.root_range());\n    }\n    T max_query(int s, int t, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::max(\n                    max_query(s, t, range.left()),\n                    max_query(s, t, range.right()));\n        } else {\n            return std::numeric_limits<T>::min();\n        }\n    }\n    T max_query_all() { return max_query(0, size()); }\n};\n\ntemplate <typename T>\nstruct range_minimum_add_query {\n    segment_tree<T> v; // minimum\n    segment_tree<T> w; // added\n    int size() const { return v.orig_n; }\n    range_minimum_add_query(int n)            : v(n),          w(n) {}\n    range_minimum_add_query(int n, T initial) : v(n, initial), w(n) {}\n    range_minimum_add_query(std::vector<T> a) : v(a.size()), w(a.size()/2) {\n        repeat (i,a.size()) add_at(i,a[i]);\n    }\n\n    void add_range(int s, int t, T x) {\n        assert (0 <= s and s < t and t <= size());\n        add_range(s, t, x, v.root_range());\n    }\n    void add_range(int s, int t, T x, const segment_range & range) {\n        if (range.is_contained(s,t)) {\n            v[range] += x;\n            w[range] += x;\n        } else if (range.is_intersected(s,t)) {\n            add_range(s, t, x, range.left());\n            add_range(s, t, x, range.right());\n            v[range] = std::min(\n                    min_query(0, size(), range.left()),\n                    min_query(0, size(), range.right())) + w[range];\n        }\n    }\n\n    // [s,t)\n    T min_query(int s, int t) const {\n        assert (0 <= s and s < t and t <= size());\n        return min_query(s, t, v.root_range());\n    }\n    T min_query(int s, int t, const segment_range & range) const {\n        if (range.is_contained(s,t)) {\n            return v[range];\n        } else if (range.is_intersected(s,t)) {\n            return std::min(\n                    min_query(s, t, range.left()),\n                    min_query(s, t, range.right())) + w[range];\n        } else {\n            return std::numeric_limits<T>::max();\n        }\n    }\n\n    void add_at(int i, T x) { add_range(i,i+1,x); }\n    T min_query_all() const { return min_query(0, size()); }\n};\n\n#endif\n#ifndef LIB_TYPEDEF_LL_HPP\n#define LIB_TYPEDEF_LL_HPP\ntypedef long long ll;\ntypedef unsigned long long ull;\n#endif\nusing namespace std;\n#define MAX_N 300000\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    ll N, Q; cin >> N >> Q;\n    vector<bool> is_open(N);\n    range_minimum_add_query<ll> segtree(N, 0);\n    {\n        ll nest = 0;\n        repeat (i,N) {\n            char c; cin >> c;\n            is_open[i] = c == '(';\n            if (is_open[i]) {\n                segtree.add_at(i,nest);\n                nest ++;\n            } else {\n                nest --;\n                segtree.add_at(i,nest);\n            }\n        }\n    }\n    repeat (query,Q) {\n        ll i; cin >> i; -- i;\n        repeat (j,N) {\n            if (i == j) {\n                cout << i+1 << endl;\n                break;\n            } else if (is_open[j] != is_open[i]) {\n                if (is_open[i] or 0 < segtree.min_query(j, i+1)) {\n                    segtree.add_range(j, i+1, is_open[i] ? 1 : -1);\n                    swap(is_open[i], is_open[j]);\n                    cout << j+1 << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n    #include <stdio.h>\n    #include <math.h>\n    #include <string.h>\n    #include <set>\n    #define maxn 300008\n    #define inf 200000000\n    using namespace std;\n    int minn[maxn << 2],add[maxn << 2];\n    set<int> L,R;\n    int sum[maxn];\n    int n,q;\n    int ans;\n    struct kh\n    {\n        char c;\n    }s[maxn];\n    void pushdown(int i,int l,int r)\n    {\n        if(add[i]!=0)\n        {\n            int mid = (l+r)>>1;\n            add[i<<1] += add[i];\n            minn[i<<1] += add[i];\n            add[i<<1|1] += add[i];\n            minn[i<<1|1] += add[i];\n            add[i]= 0;\n        }\n        return;\n    }\n    void update(int i,int l,int r,int ql,int qr,int val)\n    {\n    if(l > qr || ql > r)\n        return;\n        if(l>=ql&&r <= qr)\n        {\n            minn[i]+=val;\n            add[i]+=val;\n            return;\n        }\n        pushdown(i,l,r);\n        int mid = (l+r)>>1;\n        update(i<<1,l,mid,ql,qr,val);\n        update(i<<1|1,mid+1,r,ql,qr,val);\n        minn[i]=min(minn[i<<1],minn[i<<1|1]);\n    }\n    int que(int i,int l,int r,int ql,int qr)\n    {\n        if(l>qr||r<ql)\n            {\n                return inf;\n            }\n            if(l>=ql&&r <= qr)\n            {\n                return minn[i];\n            }\n            pushdown(i,l,r);\n            int mid = (l + r)>> 1;\n            return min(que(i<<1,l,mid,ql,qr),que(i<<1|1,mid+1,r,ql,qr));\n    }\n    void ef(int from,int to,int flag)   \n    {\n        if(from >= to)\n        {\n            ans =*(L.lower_bound(from));\n            return;\n        }\n        int mid = (from+to)>>1;\n        //cout << mid << endl;\n        if(que(1,1,n,mid,flag)>=2)\n        {\n            ef(from,mid,flag);\n        }\n        else\n        {\n            ef(mid+1,to,flag);\n        }\n    }\n    void flip(int res)\n    {\n        if(s[res].c==')')\n        {\n            s[res].c = '(';\n            R.erase(res);\n            L.insert(res);\n            update(1,1,n,res,n,2);\n        }\n        else\n        {\n            s[res].c = ')';\n            R.insert(res);\n            L.erase(res);\n            update(1,1,n,res,n,-2);\n        }\n    }\n    int main()\n    {\n       // freopen(\"in.txt\",\"r\",stdin);\n        sum[0] = 0;\n        scanf(\"%d%d\\n\",&n,&q);\n        for(int i = 1;i <= n;i ++)\n        {\n            //cout << \"firstb:\" <<  firstb << endl;\n            scanf(\"%c\",&s[i].c);\n            \n            if(s[i].c=='(')\n            {\n                L.insert(i);\n            }\n            else\n            {\n                R.insert(i);\n            }\n            if(s[i].c==')')\n            {\n                sum[i] = sum[i-1]-1;\n            }\n            else\n            {\n                sum[i] = sum[i-1]+1;\n            }\n            update(1,1,n,i,i,sum[i]);\n        }\n        while(q--)\n        {\n            //cout << \"fb:\" << *R.begin() << endl;\n            int qu;\n            scanf(\"%d\",&qu);\n            if(s[qu].c=='(')\n            {\n                flip(qu);\n                ans = *R.begin();\n                flip(ans);\n            }\n            else\n            {\n                //ans = que(1,1,n,1,qu);\n                flip(qu);\n                ef(1,qu,qu);\n                flip(ans);\n            }  \n            \n            printf(\"%d\\n\",ans);\n        }\n       \n    }\n        "
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//cout<<setprecision(20)\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint LBI(vector<llint>&ar,llint in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint UBI(vector<llint>&ar,llint in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nstatic int val[869120]={0};//最小値が親+何段か\nstatic int dco[869120]={0};//最小値のうち右端はどこか\nclass seg{\npublic:\n\t\n\t//524288\n\t//(1<<19)+300000 以上\n\t//奇数場所優先\n\tvoid cha(int bas,int num){\n\t\tbas+=(1<<19);\n\t\twhile(bas>1){\n\t\t\tif(bas%2==1){\n\t\t\t\tval[bas-1]+=num;\n\t\t\t\tint hen=min(val[bas],val[bas-1]);\n\t\t\t\tval[bas]-=hen;\n\t\t\t\tval[bas-1]-=hen;\n\t\t\t\tval[bas/2]+=hen;\n\t\t\t\tif(val[bas]==0){dco[bas/2]=dco[bas];}\n\t\t\t\telse{dco[bas/2]=dco[bas-1];}\n\t\t\t}else{\n\t\t\t\tint hen=min(val[bas],val[bas+1]);\n\t\t\t\tval[bas]-=hen;\n\t\t\t\tval[bas+1]-=hen;\n\t\t\t\tval[bas/2]+=hen;\n\t\t\t\tif(val[bas+1]==0){dco[bas/2]=dco[bas+1];}\n\t\t\t\telse{dco[bas/2]=dco[bas];}\n\t\t\t}\n\t\t\tbas/=2;\n\t\t}\n\t}\n\tint que(int bas){\n\t\tint ans=-2;\n\t\tbas+=(1<<19);\n\t\twhile(bas>1){\n\t\t\tif(val[bas]>0){ans=-2;}\n\t\t\tif(bas%2==1){maxeq(ans,dco[bas-1]);}\n\t\t\tbas/=2;\n\t\t}\n\t\treturn ans;\n\t}\n};\nint main(void){\n\tint n,Q,i;cin>>n>>Q;\n\tstring str;cin>>str;\n\t//最小値右端+1\n\tset<int>clo;\n\tseg ki;\n\tfor(i=0;i<n;i++){\n\t\tdco[(i+1)/2+(1<<19)]=i+1;\n\t\tif(str[i]=='('){ki.cha((i+1)/2,-1);}\n\t\telse{ki.cha((i+1)/2,1);clo.ins(i);}\n\t}\n\tdco[(1<<19)]=0;\n\twhile(Q--){\n\t\tint q;cin>>q;q--;\n\t\tif(str[q]=='('){\n\t\t\tstr[q]=')';\n\t\t\tclo.ins(q);\n\t\t\tki.cha((q+1)/2,2);\n\t\t\tint ter=*clo.begin();\n\t\t\tcout<<ter+1<<endl;\n\t\t\tki.cha((ter+1)/2,-2);\n\t\t\tclo.era(ter);\n\t\t\tstr[ter]='(';\n\t\t}else{\n\t\t\t//cerr<<\"de\";\n\t\t\tstr[q]='(';\n\t\t\tclo.era(q);\n\t\t\tki.cha((q+1)/2,-2);\n\t\t\tint ter=ki.que((q+2)/2);\n\t\t\tif(ter==0){ter++;}\n\t\t\tcout<<ter+1<<endl;\n\t\t\tki.cha((ter+1)/2,2);\n\t\t\tclo.ins(ter);\n\t\t\tstr[ter]=')';\n\t\t}\n\t\t//cerr<<str<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nll *min_data,*max_data,*add_data;\nchar buf[300001];\nint N = 1;\n\nvoid init(ll first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid add(int left,int right,ll value,int node_id,int node_left,int node_right){\n\n\tif(right < node_left || left > node_right){\n\t\t//範囲外ならreturn\n\t\treturn;\n\t}\n\telse if(left <= node_left && right >= node_right){ //このノードのカバーしている区間が、更新区間の部分区間である場合\n\n\t\tadd_data[node_id] += value; //一様に加える値を加算\n\n\t\twhile(node_id != 0){\n\n\t\t\tnode_id = (node_id-1)/2; //下から上に向かって、最小値および最大値更新\n\t\t\tmin_data[node_id] = min(min_data[2*node_id+1]+add_data[2*node_id+1],min_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t\tmax_data[node_id] = max(max_data[2*node_id+1]+add_data[2*node_id+1],max_data[2*node_id+2]+add_data[2*node_id+2]);\n\t\t}\n\t}else{\n\n\t\tadd(left,right,value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tadd(left,right,value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nll getMin(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn min_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_min  = getMin(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_min = getMin(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn min(left_min,right_min)+add_data[node_id];\n\t}\n}\n\nll getMax(int left,int right,int node_id,int node_left,int node_right){\n\tif(right < node_left || left > node_right)return -BIG_NUM;\n\telse if(left <= node_left && right >= node_right){\n\t\treturn max_data[node_id]+add_data[node_id];\n\n\t}else{\n\n\t\tll  left_max  = getMax(left,right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tll  right_max = getMax(left,right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\treturn max(left_max,right_max)+add_data[node_id];\n\t}\n}\n\nint main(){\n\n\tint first_N,Q;\n\tscanf(\"%d %d\",&first_N,&Q);\n\n\tinit(first_N);\n\n\tmin_data = new ll[2*N-1];\n\tmax_data = new ll[2*N-1];\n\tadd_data = new ll[2*N-1];\n\n\tfor(ll i = 0; i <= 2*N-2; i++){\n\t\tmin_data[i] = 0;\n\t\tmax_data[i] = 0;\n\t\tadd_data[i] = 0;\n\t}\n\n\tscanf(\"%s\",buf);\n\n\tset<int> CLOSE;\n\n\tfor(int i = 0; i < first_N; i++){\n\t\tif(buf[i] == '('){\n\t\t\tadd(i,N-1,1,0,0,N-1);\n\t\t}else{\n\t\t\tCLOSE.insert(i);\n\t\t\tadd(i,N-1,-1,0,0,N-1);\n\t\t}\n\t}\n\n\tint loc,calc_loc;\n\tint left,right,m;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tscanf(\"%d\",&loc);\n\t\tloc--;\n\n\t\tif(buf[loc] == '('){\n\n\t\t\tbuf[loc] = ')';\n\t\t\tadd(loc,N-1,-2,0,0,N-1);\n\t\t\tCLOSE.insert(loc);\n\n\t\t\tcalc_loc = *begin(CLOSE);\n\t\t\tCLOSE.erase(begin(CLOSE));\n\n\t\t\tadd(calc_loc,N-1,2,0,0,N-1);\n\t\t\tbuf[calc_loc] = '(';\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\n\t\t}else{ //buf[loc] == ')'\n\n\t\t\tCLOSE.erase(loc);\n\t\t\tbuf[loc] = '(';\n\t\t\tadd(loc,N-1,2,0,0,N-1);\n\n\t\t\tleft = 0,right = first_N-1, m = (left+right)/2;\n\n\t\t\twhile(left <= right){\n\t\t\t\tif(getMin(m,N-1,0,0,N-1) >= 2){\n\t\t\t\t\tcalc_loc = m;\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\twhile(buf[calc_loc] != '(')calc_loc++;\n\n\t\t\tbuf[calc_loc] = ')';\n\t\t\tadd(calc_loc,N-1,-2,0,0,N-1);\n\n\t\t\tprintf(\"%d\\n\",calc_loc+1);\n\t\t\tCLOSE.insert(calc_loc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 300000;\nconst int MAX_Q = 150000;\nconst int MAX_E2 = 1 << 20;\n\n/* typedef */\n\nstruct SegTreeSumMin {\n  int n, e2;\n  int nodes[MAX_E2], mins[MAX_E2];\n\n  SegTreeSumMin() { clear(); }\n  SegTreeSumMin(int _n) { init(_n); clear(); }\n\n  void init(int _n) {\n    n = _n;\n    for (e2 = 1; e2 < n; e2 <<= 1);\n  }\n\n  void clear() {\n    //for (int i = 0; i < MAX_E2; i++) nodes[i] = INF;\n  }\n\n  int get(int i) { return nodes[e2 - 1 + i]; }\n\n  void set(int i, int v) {\n    int j = e2 - 1 + i;\n    nodes[j] = mins[j] = v;\n    j = (j - 1) / 2;\n\n    for (;;) {\n      int j0 = j * 2 + 1, j1 = j0 + 1;\n      nodes[j] = nodes[j0] + nodes[j1];\n      mins[j] = min(mins[j0], nodes[j0] + mins[j1]);\n      if (j == 0) break;\n      j = (j - 1) / 2;\n    }\n  }\n\n  int min_all() { return mins[0]; }\n\n  int sum_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return 0;\n    if (r0 <= i0 && i1 <= r1) return nodes[k];\n\n    int im = (i0 + i1) / 2;\n    int v0 = sum_range(r0, r1, k * 2 + 1, i0, im);\n    int v1 = sum_range(r0, r1, k * 2 + 2, im, i1);\n\n    return v0 + v1;\n  }\n\n  int sum_range(int r0, int r1) {\n    return sum_range(r0, r1, 0, 0, e2);\n  }\n\n  void print() {\n    for (int i = 1; i <= n; i++) cout << sum_range(0, i) << ' ';\n    cout << endl;\n  }\n};\n\n/* global variables */\n\nint n, q;\nstring str;\nint ps[MAX_N];\n\nSegTreeSumMin stsm;\n\n/* main */\n\nint main() {\n  cin >> n >> q;\n  cin >> str;\n\n  stsm.init(n);\n  \n  for (int i = 0; i < n; i++)\n    stsm.set(i, (str[i] == '(') ? 1 : -1);\n\n  while (q--) {\n    int qi;\n    cin >> qi;\n    qi--;\n\n    int pqi = stsm.get(qi);\n    int r = -pqi;\n    stsm.set(qi, r);\n\n    //stsm.print();\n    //cout << stsm.min_all() << endl;\n\n    int rr = -r;\n    int min_i = -1;\n    \n    for (int i = 0; i <= qi; i++)\n      if (stsm.get(i) == r) {\n\tstsm.set(i, rr);\n\tif (stsm.min_all() == 0 && stsm.sum_range(0, n) == 0) {\n\t  min_i = i;\n\t  break;\n\t}\n\tstsm.set(i, r);\n      }\n\n    cout << (min_i + 1) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define pb push_back\n#define N 300007\nvector<int> rp,lp;\nvector<int>::iterator it;\nint n,m,len;\nint a[N];\nchar str[N];\nstruct Tree{\n\tint l,r,ls,rs;\n\tint cnt[2];\n}\ttree[N<<1];\nint tot;\nvoid up(int t){\n\tfor(int i=0;i<2;++i){\n\t\ttree[t].cnt[i]=tree[tree[t].ls].cnt[i]+tree[tree[t].rs].cnt[i];\n\t}\n}\nvoid build(int l,int r){\n\tint t=++tot;\n\ttree[t].l=l,tree[t].r=r;\n\ttree[t].ls=tree[t].rs=0;\n\tif(l==r){\n\t\ttree[t].cnt[0]=tree[t].cnt[1]=0;\n\t\t++tree[t].cnt[a[l]];\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(l<=mid){\n\t\ttree[t].ls=1+tot;\n\t\tbuild(l,mid);\n\t}\n\t++mid;\n\tif(mid<=r){\n\t\ttree[t].rs=1+tot;\n\t\tbuild(mid,r);\n\t}\n\tup(t);\n}\nvoid update(int t,int l,int r,int x){\n\tif(t<=0) return ;\n\tif(l==tree[t].l && r==tree[t].r){\n\t\ta[l]=x;\n\t\ttree[t].cnt[0]=tree[t].cnt[1]=0;\n\t\t++tree[t].cnt[x];\n\t\treturn ;\n\t}\n\tint mid=(tree[t].l+tree[t].r)>>1;\n\tif(r<=mid) update(tree[t].ls,l,r,x);\n\tif(l> mid) update(tree[t].rs,l,r,x);\n}\nint query(int t,int l,int r,int x){\n\tif(t<=0) return 0;\n\tif(l==tree[t].l && r==tree[t].r) return tree[t].cnt[x]-tree[t].cnt[x^1];\n\tint mid=(tree[t].l+tree[t].r)>>1;\n\tif(r<=mid) return query(tree[t].ls,l,r,x);\n\tif(l> mid) return query(tree[t].rs,l,r,x);\n\treturn query(tree[t].ls,l,mid,x)+query(tree[t].rs,mid+1,r,x);\n}\nint main(){\n\tint i,x,l,r,mid;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\" %s\",str);len=strlen(str);\n\tlp.clear();rp.clear();\n\tfor(i=0;i<len;++i)\n\tif(str[i]=='('){\n\t\ta[i+1]=0;lp.pb(i+1);\n\t}\n\telse{\n\t\ta[i+1]=1;rp.pb(i+1);\n\t}\n\ttot=0;build(1,n);\n\n\twhile(m--){\n\t\tscanf(\"%d\",&x);\n\t\t// ( -> )\n\t\tif(a[x]==0){\n\t\t\tif(rp.size()>0 && rp[0]<x){\n\t\t\t\tprintf(\"%d\\n\",rp[0]);\n\t\t\t\tupdate(1,x,x,1);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.erase(it);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.insert(it,x);\n\t\t\t\tx=rp[0];\n\t\t\t\tupdate(1,x,x,0);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.erase(it);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.insert(it,x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t}\n\t\t// ) -> (\n\t\telse{\n\t\t\tif(x==n || query(1,x+1,n,0)>=0){\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tupdate(1,x,x,0);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.erase(it);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.insert(it,x);\n\t\t\t\tl=0;\n\t\t\t\tr=lower_bound(lp.begin(),lp.end(),x)-lp.begin();\n\t\t\t\twhile(l+1<r){\n\t\t\t\t\tmid=(l+r)>>1;\n\t\t\t\t\tquery(1,lp[mid],n,0)<=0?r=mid:l=mid;\n\t\t\t\t}\n\t\t\t\tx=query(1,lp[l],n,0)>0?lp[l]:lp[r];\n\t\t\t\tupdate(1,x,x,1);\n\t\t\t\tit=lower_bound(lp.begin(),lp.end(),x);lp.erase(it);\n\t\t\t\tit=lower_bound(rp.begin(),rp.end(),x);rp.insert(it,x);\n\t\t\t\tprintf(\"%d\\n\",x);\n\t\t\t}\n\t\t}\n//\t\tfor(i=1;i<=n;++i) printf(\"%c\",a[i]?')':'(');printf(\"\\n\");\n//\t\tputs(\"( :\");for(i=0;i<(int)lp.size();++i) printf(\" %d\",lp[i]);printf(\"\\n\");\n//\t\tputs(\") :\");for(i=0;i<(int)rp.size();++i) printf(\" %d\",rp[i]);printf(\"\\n\");\n\t}\n\treturn 0;\n}\n/*\n6 3\n((()))\n4\n3\n1\n\n20 9\n()((((()))))()()()()\n15\n20\n13\n5\n3\n10\n3\n17\n18\n */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF (1<<29)\n\nstruct segtree{\n\n  //テヲツ慊?・ツーツ湘・ツ?、テ」ツつ津ヲツアツづ」ツつ?」ツつ凝ァツ板ィ\n  vector<int> datamin;\n  //テゥツ??・ツサツカテァツ板ィ\n  vector<int> delay;\n  int n;\n\n  //テ・ツ按敕ヲツ慊淌・ツ個?\n  void init(int _n){\n    n = 1;\n    while( n < _n ) n*=2;\n    datamin.resize( 2 * n );\n    delay.resize( 2 * n );\n  }\n\n  //テァツーツ。テヲツ伉禿ァツ可暗ッツシツ暗ァツキツ湘・ツ陳古」ツ?ォテ・ツッツセテ」ツ?凖」ツつ凝・ツ?ヲテァツ青?ァツ?。テ」ツ?預nd0テ・ツ按敕ヲツ慊淌・ツ個姪ァツ?。テ」ツ?要er)\n  void delaycalc(int k){\n    datamin[k] = datamin[k]+delay[k];\n    if( k+1 < n )\n      for(int i=1;i<=2;i++)\n        delay[2*k+i] = delay[2*k+i]+delay[k];\n    delay[k] = 0;\n  }\n  \n\n  //テ・ツ個コテゥツ鳴禿」ツ??a,b)テ」ツ??」ツ?ォテ、ツクツ?ヲツァツ佚」ツ?ォテ」ツ??テ」ツ??」ツつ津ィツカツウテ」ツ??\n  void add(int a,int b,int x,int k,int l,int r){\n    delaycalc(k);\n    if( r<=a || b<=l ) return;\n    else if( a<=l && r<=b ){\n      delay[k] = x;\n      delaycalc(k);\n    } else {\n      add( a, b, x, 2*k + 1, l, (l+r)/2 );\n      add( a, b, x, 2*k + 2, (l+r)/2, r );\n      datamin[k] = min( datamin[2*k+1], datamin[2*k+2] );\n    }\n  }\n\n  //テ」ツ?づ」ツつ凝・ツ個コテゥツ鳴禿」ツ?ョテヲツ慊?・ツーツ湘・ツ?、テ」ツつ津ヲツアツづ」ツつ?」ツつ?\n  int querymin(int a,int b,int k,int l,int r){\n    delaycalc(k);\n    if( r<=a || b<=l ) return INF;\n    if( a<=l && r<=b ){\n      return datamin[k]+delay[k];\n    } else {\n      int vl = querymin( a, b, 2*k+1, l,(l+r)/2 );\n      int vr = querymin( a, b, 2*k+2, (l+r)/2,r );\n      return min(vl,vr);\n    }\n  }\n\n\n  void add( int a,int b,int x){ add( a, b, x, 0,0,n); }//テ・ツ環?」ツ?暗」ツつ?\n  int querymin(int a,int b){ return querymin(a,b,0,0,n); }//テヲツ慊?・ツーツ湘・ツ?、テ・ツ渉姪・ツセツ?\n};\n\nint N,Q;\nstring str;\nsegtree S;\nint main(){\n  cin >> N >> Q;\n  cin >> str;\n  S.init(N);\n  int cnt = 0;\n  for(int i=0;i<N;i++){\n    if( str[i] == '(' ) cnt++;\n    else cnt--;\n    S.add(i,i+1,cnt);\n  }\n\n  for(int i=0;i<Q;i++){\n    int id; cin >> id; --id;\n   \n    if( str[id] == ')' ){\n      str[id] = '(';\n      S.add(id,id+N,2);\n\n      int st = 0,ed = id;\n      int res = id;\n      while( st <= ed ){\n        int h = (st + ed)/2;\n        int mini = S.querymin(h,id+1);\n        if( mini >= 2 ){\n          ed = h-1; res = min( res, h );\n        }\n        else st = h+1;\n      }\n      str[res]  = ')';\n      cout << res+1 << endl;\n      S.add(res,id+N,-2);\n    } else {// ( -> )\n      str[id] = ')';\n      S.add(id,id+N,-2);\n\n      int st = 0,ed = id;\n      int res = id;\n      while( st <= ed ){\n        int h = (st + ed)/2;\n        int mini = S.querymin(h,h+1);       \n        if( h+1 == mini) st = h + 1;\n        else{\n          ed = h-1; res = min( res, h );\n        }\n      }\n      str[res]  = '(';\n      cout << res+1 << endl;\n      S.add(res,id+N,2);\n      \n    }    \n  \n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\n\nstruct BIT\n{\n  int n;\n  vector<int> tree;\n  BIT(int n_)\n  {\n    tree = vector<int>(n_ + 1, 0);\n    n = n_;\n  }\n  int sum(int i)\n  {\n    int ret = 0;\n    while( i > 0 ) {\n      ret += tree[i];\n      i -= i & -i;\n    }\n    return ret;\n  }\n  void add(int i, int x)\n  {\n    while( i <= n ) {\n      tree[i] += x;\n      i += i & -i;\n    }\n  }\n};\n\n\nmain()\n{\n  int N, Q;\n  string s;\n  BIT L(N+1), R(N+1); //L:(  R:)\n\n  cin >> N >> Q >> s;\n\n  Rep(i, N) {\n    if( s[i] == '(' ) L.add( i+1, 1 );\n    else R.add( i+1, 1 );\n  }\n  \n  while( Q-- ) {\n    //cout << L.sum( N ) << \" \" << R.sum( N ) << endl;\n    int q;\n    cin >> q;\n\n    if( L.sum( q ) - L.sum( q-1 ) == 1 ) { // ( -> )\n      L.add( q, -1 );\n      R.add( q, 1 );\n      int l = 1, r = q;\n      while( r - l > 1 ) {\n\tint mod = (l + r) / 2;\n\tif( R.sum( mod ) ) r = mod;\n\t  else l = mod;\n      }\n      \n      if( R.sum( l ) ) {\n\tcout << l << endl;\n\tR.add( l, -1 );\n\tL.add( l, 1 );\n      }\n      else {\n\tcout << r << endl;\n\tR.add( r, -1 );\n\tL.add( r, 1 );\n      }\n    }\n\n    else { // ) -> (\n      //cout << 'R' << endl;\n      if( q != N && L.sum( N ) - L.sum( q ) < R.sum( N ) - R.sum( q ) ) {\n\tL.add( q, 1 );\n\tR.add( q, -1 );\n\tint l = 2, r = q;\n\twhile( r - l > 1 ) {\n\t  int mod = (l + r) / 2;\n\t  if( L.sum( mod ) > R.sum( mod ) ) r = mod;\n\t  else l = mod;\n\t}\n\t\n\tif( L.sum( l ) > R.sum( l ) ) {\n\t  cout << l << endl;\n\t  L.add( l, -1 );\n\t  R.add( l, 1 );\n\t}\n\telse {\n\t  cout << r << endl;\n\t  L.add( r, -1 );\n\t  R.add( r, 1 );\n\t}\n      } else {\n\tcout << q << endl;\n      }\n    }\n  }\n  \n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#include<climits>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n\n\nstruct StarrySkyTree{\n\tint n;\n\tstd::vector<long long> segv,segAdd;\n\tvoid add(int a,int b,int x,int k,int l,int r){\n\t\tif(r<=a || b<=l)return;\n\t\tif(a<=l && r<=b){\n\t\t\tsegAdd[k] += x;\n\t\t\treturn;\n\t\t}\n\t\tint m=(l+r)/2;\n\t\tadd(a,b,x,2*k+1,l,m);\n\t\tadd(a,b,x,2*k+2,m,r);\n\t\tsegv[k]=std::min(segAdd[2*k+1]+segv[2*k+1] ,segAdd[2*k+2]+segv[2*k+2]);\n\t}\n\tlong long min(int a,int b,int k,int l,int r)const{\n\t\tif(r<=a || b<=l)return LLONG_MAX;\n\t\tif(a<=l && r<=b){\n\t\t\treturn segv[k]+segAdd[k];\n\t\t}\n\t\tint m=(l+r)/2;\n\t\treturn segAdd[k]+std::min(min(a,b,2*k+1,l,m),min(a,b,2*k+2,m,r));\n\t}\npublic:\n\tStarrySkyTree(int n=1<<18){\n\t\tinit(n);\n\t}\n\tvoid init(int n){\n\t\tthis->n=n;\n\t\tsegv.assign(2*n-1,0);\n\t\tsegAdd.assign(2*n-1,0);\n\t}\n\tvoid add(int a,int b,int x){//[a,b)にxを加算\n\t\tadd(a,b,x,0,0,n);\n\t}\n\tlong long min(int a,int b)const{//[a,b)の最小値\n\t\treturn min(a,b,0,0,n);\n\t}\n};\n\n\n\nint main(){\n\tStarrySkyTree sst;\n\tset<int> s;\n\tstring str;\n\tint n,q;\n\tcin>>n>>q>>str;\n\trep(i,n){\n\t\tif(str[i]=='(')sst.add(i,n,1);\n\t\telse{\n\t\t\tsst.add(i,n,-1);\n\t\t\ts.insert(i);\n\t\t}\n\t}\n\trep(i,q){\n\t\tint p;\n\t\tcin>>p;\n\t\tp--;\n\t\tint lb,ub,ans;\n\t\tif(str[p]=='('){\n\t\t\tstr[p]=')';\n\t\t\tsst.add(p,n,-2);\n\t\t\ts.insert(p);\n\t\t\tans=*s.begin();\n\t\t\tstr[ans]='(';\n\t\t\tsst.add(ans,n,2);\n\t\t\ts.erase(ans);\n\t\t\tans++;\n\t\t}else{\n\t\t\tstr[p]='(';\n\t\t\tsst.add(p,n,2);\n\t\t\ts.erase(p);\n\t\t\tlb=-1;ub=n-1;\n\t\t\twhile(ub-lb>1){\n\t\t\t\tint m=(lb+ub)/2;\n\t\t\t\tif(sst.min(m,n)>=2)ub=m;\n\t\t\t\telse lb=m;\n\t\t\t}\n\t\t\tstr[ub]=')';\n\t\t\tsst.add(ub,n,-2);\n\t\t\ts.insert(ub);\n\t\t\tans=ub+1;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n#define repn(i,s,n) for (int i=int(s); i < int(n); i++)\n#define rep(i,n) repn(i,0,n)\n#define repd(i,n) for (int i=int(n)-1; i >= 0; i--)\n\n\nstruct Node {\n  int val;  // この区間に足される値\n  int min;  // この区間の最小値（valを含む）\n  Node() : min(0), val(0) {}\n};\n\n#define LC(k) (k*2 + 1)  // 左の子\n#define RC(k) (k*2 + 2)  // 右の子\n\nconst int INF = INT_MAX;\n\nstruct RMQRangeAddSegTree {\n  vector<Node> tree;\n  int n;\n  RMQRangeAddSegTree(int n) : n(n), tree(n*2 - 1) {}  // nは2のべき乗でなければならない\n\n  // 区間[l,r)内の要素にvalを足す\n  void addRange(int l, int r, int val) {\n    addRange(l, r, 0, 0, n, val);\n  }\n\n  // a,b: クエリ対象の範囲[a,b)\n  // k: 現在のノードの番号\n  // l,r: 現在のノードkの範囲[l,r)\n  // val: [a,b)に追加する値\n  void addRange(int a, int b, int k, int l, int r, int val) {\n    if (r <= a || b <= l) return;  // 対象区間とノードの区間が交わらないなら処理をしない\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) {\n      tree[k].val += val;\n    }\n    else {\n      addRange(a, b, LC(k), l, (l + r) / 2, val);\n      addRange(a, b, RC(k), (l + r) / 2, r, val);\n    }\n    update_node(k, r-l);\n  }\n\n  // 遅延評価の実行。根ノード側の更新分を下へ伝搬していく\n  void process_lazy(int k, int size) {\n    if (size > 1 && tree[k].val != 0) {\n      tree[LC(k)].val += tree[k].val;\n      tree[RC(k)].val += tree[k].val;\n      tree[LC(k)].min += tree[k].val;\n      tree[RC(k)].min += tree[k].val;\n      tree[k].val = 0;\n    }\n  }\n\n  // 頂点情報の更新。葉ノード側の更新を上へ伝搬していく\n  void update_node(int k, int size) {\n    if (size == 1) {  // kは葉\n      tree[k].min = tree[k].val;\n    }\n    else {  // kは葉でない\n      tree[k].min = tree[k].val + min(tree[LC(k)].min, tree[RC(k)].min);\n    }\n  }\n\n  // 区間[l,r)内の要素の最小値を返す\n  int minRange(int l, int r) {\n    return minRange(l, r, 0, 0, n);\n  }\n\n  int minRange(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return INF;\n    process_lazy(k, r-l);\n    if (a <= l && r <= b) return tree[k].min;\n    return min(\n      minRange(a, b, LC(k), l, (l + r) / 2),\n      minRange(a, b, RC(k), (l + r) / 2, r)\n    );\n  }\n};\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  int n, q;\n  cin >> n >> q;\n  int nPow2 = n-1;\n  nPow2 |= nPow2 >> 1;\n  nPow2 |= nPow2 >> 2;\n  nPow2 |= nPow2 >> 4;\n  nPow2 |= nPow2 >> 8;\n  nPow2 |= nPow2 >> 16;\n  nPow2++;\n\n  RMQRangeAddSegTree tree(nPow2);\n  string s;\n  cin >> s;\n  set<int> kets;\n  rep(i, n) {\n    if (s[i] == '(') {\n      tree.addRange(i, n, 1);\n    }\n    else {\n      tree.addRange(i, n, -1);\n      kets.insert(i);\n    }\n  }\n  // cout << tree.minRange(0, n) << endl;\n  rep(qi, q) {\n    int qq;\n    cin >> qq;\n    qq--;\n    if (s[qq] == '(') {\n      s[qq] = ')';\n      kets.insert(qq);\n      int best = *kets.begin();\n      s[best] = '(';\n      kets.erase(best);\n      cout << best+1 << endl;\n      if (best != qq) {\n        tree.addRange(qq, n, -2);\n        tree.addRange(best, n, 2);\n      }\n    }\n    else {\n      s[qq] = '(';\n      kets.erase(qq);\n      tree.addRange(qq, n, 2);\n      int lb = 1;\n      int ub = qq;\n      while (lb < ub) {\n        int m = (lb + ub) / 2;\n        if (tree.minRange(m, n) >= 2) {\n          ub = m;\n        }\n        else {\n          lb = m + 1;\n        }\n      }\n      int best = lb;\n      if (s[best] == ')') throw \"BUG\";\n      s[best] = ')';\n      kets.insert(best);\n      cout << best+1 << endl;\n      tree.addRange(best, n, -2);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nclass SegmentTree {\nprivate:\n  int n;\n  vector<int> dat1, dat2, lazy;\n\npublic:\n  SegmentTree() {}\n\n  SegmentTree(int _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    dat1 = dat2 = lazy = vector<int>(n*2-1, 0);\n  }\n\n  inline void evaluation(int k, int l, int r) {\n    dat1[k] += (r - l) * lazy[k];\n    dat2[k] += lazy[k];\n    if (k < n-1) {\n      lazy[k*2+1] += lazy[k];\n      lazy[k*2+2] += lazy[k];\n    }\n    lazy[k] = 0;\n  }\n\n  void add(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] += x;\n      evaluation(k, l, r);\n      return;\n    }\n    add(a, b, x, k*2+1, l, (l+r)/2);\n    add(a, b, x, k*2+2, (l+r)/2, r);\n    dat1[k] += dat1[k*2+1] + dat1[k*2+2];\n    dat2[k] = min(dat2[k*2+1], dat2[k*2+2]);\n  }\n\n  int sum(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat1[k];\n    int v1 = sum(a, b, k*2+1, l, (l+r)/2);\n    int v2 = sum(a, b, k*2+2, (l+r)/2, r);\n    return v1 + v2;\n  }\n\n  int mini(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r == -1) r = n;\n    evaluation(k, l, r);\n    if (r <= a || b <= l) return INF;\n    if (a <= l && r <= b) return dat2[k];\n    int v1 = mini(a, b, k*2+1, l, (l+r)/2);\n    int v2 = mini(a, b, k*2+2, (l+r)/2, r);\n    return min(v1, v2);\n  }\n};\n\nint N, Q;\nstring s;\nset<int> cs;\nSegmentTree seg;\n\nvoid init() {\n  cs = set<int>();\n  seg = SegmentTree(N);\n  for (int i = 0; i < N; ++i) {\n    if (s[i] == ')') cs.insert(i);\n    seg.add(i, N, s[i] == '(' ? +1 : -1);\n  }\n}\n\nvoid change(int index) {\n  if (s[index] == '(') {\n    s[index] = ')';\n    seg.add(index, N, -2);\n    cs.insert(index);\n  } else {\n    s[index] = '(';\n    seg.add(index, N, +2);\n    cs.erase(index);\n  }\n}\n\nint main() {\n  while (cin >> N >> Q) {\n    cin >> s;\n    init();\n    while (Q--) {\n      int q; cin >> q; --q;\n      if (s[q] == '(') { // '(' => ')'\n        change(q);\n        int p = *cs.begin();\n        cout << p + 1 << endl;\n        change(p);\n      } else { // ')' => '('\n        change(q);\n        int l = 0, r = N;\n        while (r-l) {\n          int m = (l + r) / 2;\n          if (seg.mini(m, N) > 1) {\n            r = m;\n          } else {\n            l = m+1;\n          }\n        }\n        cout << r + 1 << endl;\n        change(r);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconstexpr int IINF = INT_MAX;\n\ntemplate <typename Monoid, typename OperatorMonoid>\nstruct LazySegmentTree{\nprivate:\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    using P = function<OperatorMonoid(OperatorMonoid, int)>;\n    int N;\n    vector<Monoid> node;\n    vector<OperatorMonoid> lazy;\n    F f;\n    G g;\n    H h;\n    P p;\n    Monoid e;  // identity element\n    OperatorMonoid oe;  // identity element\n\npublic:\n    LazySegmentTree(){}\n    LazySegmentTree(F f, G g, H h, Monoid e, OperatorMonoid oe, P p=[](OperatorMonoid a, int b){return a;}):f(f), g(g), h(h), e(e), oe(oe), p(p){}\n    void init(int sz){\n        N = 1;\n        while(N < sz) N <<= 1;\n        node.assign(2*N-1, e);\n        lazy.assign(2*N-1, oe);\n    }\n    void build(vector<Monoid>& v){\n        int sz = int(v.size());\n        init(sz);\n        for(int i=0; i<sz; i++){\n            node[i+N-1] = v[i];\n        }\n        for(int i=N-2; i>=0; i--){\n            node[i] = f(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void eval(int k, int len){\n        if(lazy[k] != oe){\n            node[k] = g(node[k], p(lazy[k], len));\n            if(k < N-1){\n                lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = oe;\n        }\n    }\n    Monoid update(int a, int b, OperatorMonoid x){return update(a, b, x, 0, 0, N);}\n    Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r){\n        eval(k, r-l);\n        if(b <= l || r <= a) return node[k];\n        if(a <= l && r <= b){\n            lazy[k] = h(lazy[k], x);\n            return g(node[k], p(lazy[k], r-l));\n        }\n        return node[k] = f(update(a,b,x,2*k+1,l,(l+r)/2), update(a,b,x,k*2+2,(l+r)/2,r));\n    }\n    // [a,b)\n    Monoid query(int a, int b){return query(a, b, 0, 0, N);}\n    Monoid query(int a, int b, int k, int l, int r){\n        eval(k, r-l);\n        if(b <= l || r <= a) return e;\n        if(a <= l && r <= b) return node[k];\n        Monoid vl, vr;\n        vl = query(a, b, 2*k+1, l, (l+r)/2);\n        vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n};\n\nint main() {\n    int n, q;\n    string s;\n    cin >> n >> q >> s;\n    vector<int> v(n);\n    set<int> st;\n    for(int i=0;i<n;i++){\n        v[i] += (s[i]=='('?1:-1);\n        if(s[i]==')') st.insert(i);\n    }\n    for(int i=0;i<n-1;i++){\n        v[i+1] += v[i];\n    }\n    auto f = [=](int a, int b){return min(a,b);};\n    auto g = [=](int a, int b){return a+b;};\n    LazySegmentTree<int, int> seg(f,g,g,IINF,0);\n    seg.build(v);\n    for(;q>0;q--){\n        int k;\n        cin >> k;\n        k--;\n        if(s[k]=='('){\n            s[k] = ')';\n            st.insert(k);\n            seg.update(k,n,-2);\n            int ans = *st.begin();\n            seg.update(ans,n,2);\n            cout << ans+1 << endl;\n            s[ans] = '(';\n            st.erase(st.begin());\n        }\n        else{\n            s[k] = '(';\n            st.erase(k);\n            seg.update(k,n,2);\n            int ok = n-1, ng = -1;\n            while(abs(ok-ng)>1){\n                int mid = (ok+ng)/2;\n                if(seg.query(mid,n)>=2){\n                    ok = mid;\n                }\n                else{\n                    ng = mid;\n                }\n            }\n            seg.update(ok,n,-2);\n            cout << ok+1 << endl;\n            s[ok] = ')';\n            st.insert(ok);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define SIZE 300005\n\ntypedef struct stack{char elm[SIZE]; int top;}stack_t;  //スタック\n\n//スタック操作関数\n//初期化\nvoid Reset(stack_t *s){s->top = -1;}\n\n//プッシュ\nvoid push(stack_t *s, char e){\n  s->top++;\n  s->elm[s->top] = e;\n}\n\n//ポップ\nchar pop(stack_t *s){\n  char e;\n\n  e = s->elm[s->top];\n  s->top--;\n  return e;\n}\n\n//空の判断\nint isEmpty(stack_t *s){return s->top == -1;}\n\n//位置qの括弧をひっくり返す\nvoid Flip(char st[], int q){\n  switch (st[q-1]) {\n    case '(':\n      st[q-1] = ')';\n      break;\n    case ')':\n      st[q-1] = '(';\n      break;\n  }\n}\n\n//括弧の対応がとれているなら1,取れていないなら0を返す\nint Balance(char st[]){\n  stack_t s;\n\n  Reset(&s);\n  for(int i = 0; st[i] != '\\0'; ++i){\n    switch (st[i]) {\n      case '(':\n        push(&s, st[i]);\n        break;\n      case ')':\n        if(isEmpty(&s))\n          return 0;\n        pop(&s);\n        break;\n    }\n  }\n  if(isEmpty(&s))\n    return 1;\n  else\n    return 0;\n}\n\n//ひっくり返したとき括弧の対応がとれている最も左の位置を返す\nint Position(char st[]){\n  for(int i = 1; st[i-1] != '\\0'; ++i){\n    Flip(st, i);\n    if(Balance(st)) //対応がとれているなら、その位置を返す\n      return i;\n    else  //とれていないなら、もとに戻す\n      Flip(st, i);\n  }\n}\n/*\nvoid Print(char st[]){\n  for(int j = 0; st[j] != '\\0'; j++){\n    printf(\"%c\", st[j]);\n  }\n  printf(\"\\n\");\n}\n*/\nint main(){\n  char st[SIZE];\n  int p, q, n;\n\n  scanf(\"%d%d\", &n, &q);\n  scanf(\"%s\", st);\n  for(int i = 1; i <= q; i++){\n    scanf(\"%d\", &p);\n    Flip(st, p);\n    //Print(st);\n    //printf(\"Balance %d\\n\", Balance(st));\n    //Print(st);\n    printf(\"%d\\n\", Position(st));\n    //Print(st);\n    //printf(\"Balance %d\\n\", Balance(st));\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define STSIZE 300001\n#define TREESIZE 300001 * 4\n#define MAX 300000\n\n#define min(x, y) x < y ? x : y\n\n//遅延評価セグメント木\ntypedef struct{\n  int tree[TREESIZE], lazy[TREESIZE], lazyFlag[TREESIZE];\n}segtree_t;\n\n//プロトタイプ宣言\nint Power2(int n);\nvoid Make_tree(char st[], int n);\nvoid update(int a, int b, int x, int k, int left, int right);\nvoid lazyEvaluate(int k, int left, int right);\nint minimum(int a, int b, int k, int left, int right);\nint get_leaf(int pos, int k, int left, int right);\n//void Print_tree(int n);\nvoid Flip(char st[], int q, int val);\nint Balance(char st[], int n);\n\nint f_open = 0, f_close = 0;  //ひっくり返されたとき1になる\nsegtree_t segtree;\n\n//nより大きい2の累乗\nint Power2(int n){\n  int value;\n  for(value = 1; value < n; value *= 2)\n    ;\n  return value;\n}\n\n//木の作成\nvoid Make_tree(char st[], int n){\n  int sum = 0, i, j;\n\n  for(i = 0; st[i] != '\\0'; ++i){\n    switch(st[i]){\n      case '(':\n        sum++;\n        segtree.tree[n + i - 1] = sum;\n        break;\n      case ')':\n        sum--;\n        segtree.tree[n + i - 1] = sum;\n        break;\n    }\n  }\n  //葉ノードの数が2の累乗になるまでノードを作る\n  for(;i < n; ++i)\n    segtree.tree[n + i - 1] = MAX;\n  //親ノードの生成\n  for(i = n - 1, j = n + i - 1; j > 0; j -= 2)\n    segtree.tree[(j - 1) / 2] = min(segtree.tree[j], segtree.tree[j - 1]);\n}\n\n//半開区間[a, b)のノードすべてにxを加える\nvoid update(int a, int b, int x, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(right <= a || b <= left)\n    return;\n  if(a <= left && right <= b){\n    segtree.lazy[k] += x;\n    segtree.lazyFlag[k] = 1;\n    lazyEvaluate(k, left, right);\n  }\n  else{\n    update(a, b, x, k * 2 + 1, left, (left + right) / 2);\n    update(a, b, x, k * 2 + 2, (left + right) / 2, right);\n    segtree.tree[k] = min(segtree.tree[k * 2 + 1], segtree.tree[k * 2 + 2]);\n  }\n}\n\n//遅延評価\nvoid lazyEvaluate(int k, int left, int right){\n  if(segtree.lazyFlag[k]){\n    segtree.tree[k] += segtree.lazy[k];\n    if(right - left > 1){  //kが葉ではないとき\n      segtree.lazy[k * 2 + 1] += segtree.lazy[k];\n      segtree.lazy[k * 2 + 2] += segtree.lazy[k];\n      segtree.lazyFlag[k * 2 + 1] = segtree.lazyFlag[k * 2 + 2] = 1;\n    }\n    segtree.lazy[k] = 0;\n    segtree.lazyFlag[k] = 0;\n  }\n}\n\n//半開区間[a, b)の最小値\nint minimum(int a, int b, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(right <= a || b <= left)\n    return MAX;\n  if(a <= left && right <= b)\n    return segtree.tree[k];\n  else{\n    int vl = minimum(a, b, k * 2 + 1, left, (left + right) / 2);\n    int vr = minimum(a, b, k * 2 + 2, (left + right) / 2, right);\n    return min(vl, vr);\n  }\n}\n\n//葉ノードの値を取得\nint get_leaf(int pos, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(pos == left)\n    return segtree.tree[k];\n  if(pos < (left + right) / 2)\n    return get_leaf(pos, k * 2 + 1, left, (left + right) / 2);\n  else\n    return get_leaf(pos, k * 2 + 2, (left + right) / 2, right);\n}\n\n/*\n//木の表示\nvoid Print_tree(int n){\n  for(int i = 0; i < 2 * n - 1; i++)\n    printf(\"%d \", segtree.tree[i]);\n  printf(\"\\n\");\n}\n*/\n\n//位置qの括弧をひっくり返す\nvoid Flip(char st[], int q, int n){\n  switch (st[q-1]) {\n    case '(':\n      st[q-1] = ')';\n      f_open = 1;\n      update(q - 1, n, -2, 0, 0, n);\n      break;\n    case ')':\n      st[q-1] = '(';\n      f_close = 1;\n      update(q - 1, n, 2, 0, 0, n);\n      break;\n  }\n}\n\n//ひっくり返したとき括弧の対応がとれている最も左の位置を返す\nint Balance(char st[], int n){\n  int sum = 0;\n\n  if(f_open){  //開きが閉じにひっくり返されたとき\n    for(int i = 1; st[i - 1] != '\\0'; ++i)\n      if(st[i - 1] == ')'){  //一番左の閉じを開きにすればよい\n        Flip(st, i, n);\n        return i;\n      }\n  }\n  else if(f_close){  //閉じが開きにひっくり返されたとき\n    for(int i = 0; st[i] != '\\0'; ++i){\n      if(st[i] == '(' /*&& get_leaf(i, 0, 0, n) >= 2*/){\n        sum++;\n        if(sum >= 2 && minimum(i + 1, n, 0, 0, n) > 1){\n          Flip(st, i + 1, n);\n          return i + 1;\n        }\n        else continue;\n      }\n      else sum--;\n    }\n  }\n  else\n    return -1;\n}\n\nint main(){\n  char st[STSIZE];\n  int p, q, n;\n  int val;\n\n  scanf(\"%d%d\", &n, &q);\n  val = Power2(n);\n  scanf(\"%s\", st);\n  Make_tree(st, val);\n  //Print_tree(val);\n  for(int i = 0; i < 2 * val - 1; ++i)\n    segtree.lazy[i] = 0;\n  for(int i = 1; i <= q; i++){\n    f_open = 0; f_close = 0;\n    scanf(\"%d\", &p);\n    Flip(st, p, val);\n    printf(\"%d\\n\", Balance(st, val));\n    //Print_tree(val);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "# include <stdio.h>\n\n#define STSIZE 300001\n#define TREESIZE 300001 * 4\n#define MAX 300000\n\n#define min(x, y) x < y ? x : y\n\nint f_open = 0, f_close = 0;  //ひっくり返されたとき1になる\nint tree[TREESIZE];  //木\n\nint Power2(int n){\n  int value;\n  for(value = 1; value < n; value *= 2)\n    ;\n  return value;\n}\n\n//木の作成\nvoid Make_tree(char st[], int n){\n  int sum = 0, i, j;\n\n  for(i = 0; st[i] != '\\0'; ++i){\n    switch(st[i]){\n      case '(':\n        sum++;\n        tree[n + i - 1] = sum;\n        break;\n      case ')':\n        sum--;\n        tree[n + i - 1] = sum;\n        break;\n    }\n  }\n  for(;i < n; ++i)\n    tree[n + i - 1] = MAX;\n  for(i = n - 1, j = n + i - 1; j > 0; j -= 2)\n    tree[(j - 1) / 2] = min(tree[j], tree[j - 1]);\n}\n\n/*\n//木の表示\nvoid Print_tree(int tree[], int n){\n  for(int i = 0; i < 2 * n - 1; i++)\n    printf(\"%d \", tree[i]);\n  printf(\"\\n\");\n}\n*/\n\n//半閉区間[a, b)の最小値\nint minimum(int a, int b, int k, int left, int right){\n  if(right <= a || b <= left)\n    return MAX;\n  if(a <= left && right <= b)\n    return tree[k];\n  else{\n    int vl = minimum(a, b, k * 2 + 1, left, (left + right) / 2);\n    int vr = minimum(a, b, k * 2 + 2, (left + right) / 2, right);\n    return min(vl, vr);\n  }\n}\n\n//位置qの括弧をひっくり返す\nvoid Flip(char st[], int q){\n  switch (st[q-1]) {\n    case '(':\n      st[q-1] = ')';\n      f_open = 1;\n      break;\n    case ')':\n      st[q-1] = '(';\n      f_close = 1;\n      break;\n  }\n}\n\n//ひっくり返したとき括弧の対応がとれている最も左の位置を返す\nint Balance(char st[], int n){\n  if(f_open){  //開きが閉じにひっくり返されたとき\n    for(int i = 1; st[i - 1] != '\\0'; ++i)\n      if(st[i - 1] == ')'){  //一番左の閉じを開きにすればよい\n        Flip(st, i);\n        return i;\n      }\n  }\n  else if(f_close){  //閉じが開きにひっくり返されたとき\n    Make_tree(st, n);  //木の作成\n    for(int i = 0; st[i] != '\\0'; ++i){\n      if(st[i] == '(' && tree[n + i - 1] >= 2){\n        //printf(\"%d\\n\", minimum(i + 1, n, 0, 0, n));\n        if(minimum(i + 1, n, 0, 0, n) > 1){\n          Flip(st, i + 1);\n          return i + 1;\n        }\n      }\n    }\n  }\n  else\n    return -1;\n}\n\nint main(){\n  char st[STSIZE];\n  int p, q, n;\n  int val;\n\n  scanf(\"%d%d\", &n, &q);\n  val = Power2(n);\n  scanf(\"%s\", st);\n  for(int i = 1; i <= q; i++){\n    f_open = 0; f_close = 0;\n    scanf(\"%d\", &p);\n    Flip(st, p);\n    printf(\"%d\\n\", Balance(st, val));\n    //Print_tree(tree, val);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n\tint n,m;\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tint d[300005];\n\tint i,j;\n\tchar c;\n\tscanf(\"%c\",&c);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%c\",&c);\n\t\tif(c=='(')\n\t\t\td[i]=1;\n\t\telse\n\t\t\td[i]=-1;\n\t}\n\tint e,sum,mus;\n\tfor(i=0;i<m;++i)\n\t{\n\t\tsum=0;\n\t\tmus=0;\n\t\tint temp;\n\t\tscanf(\"%d\",&e);\n\t\tif(d[e]==-1)\n\t\t{\n\t\t\td[e]=-d[e];\n\t\t\tfor(j=e+1;j<=n;++j)\n\t\t\t{\n\t\t\t\tsum+=d[j];\n\t\t\t}\n\t\t\tif(sum==0)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",e);\n\t\t\t\td[e]=-d[e];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=e;j>1;--j)\n\t\t\t\t{\n\t\t\t\t\tmus+=d[j];\n\t\t\t\t\tif(mus+sum==1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(mus>=1)\n\t\t\t\t\t{\n\t\t\t\t\t\td[j]=-d[j];\n\t\t\t\t\t\ttemp=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",temp);\n\t\t\t\td[temp]=-d[temp];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\td[e]=-d[e];\n\t\t\tfor(j=e+1;j<=n;++j)\n\t\t\t{\n\t\t\t\tsum+=d[j];\n\t\t\t}\n\t\t\tfor(j=1;j<=e;++j)\n\t\t\t{\n\t\t\t\tif(d[j]==-1)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d\\n\",j);\n\t\t\t\t\td[j]=-d[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#define MX 300005\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define root 1,n,1\nusing namespace std;\n\nchar W[MX];\nint ls[MX << 2], rs[MX << 2], col_L[MX << 2],col_R[MX << 2], A[MX],B[MX];\n\nvoid push_up(int rt) {\n    ls[rt] = min(ls[rt << 1], ls[rt << 1 | 1]);\n    rs[rt] = min(rs[rt << 1], rs[rt << 1 | 1]);\n}\n\nvoid push_down_L(int rt) {\n    if(col_L[rt]) {\n        col_L[rt << 1] += col_L[rt];\n        col_L[rt << 1 | 1] += col_L[rt];\n        ls[rt << 1] += col_L[rt];\n        ls[rt << 1 | 1] += col_L[rt];\n        col_L[rt] = 0;\n    }\n        if(col_R[rt]) {\n        col_R[rt << 1] += col_R[rt];\n        col_R[rt << 1 | 1] += col_R[rt];\n        rs[rt << 1] += col_R[rt];\n        rs[rt << 1 | 1] += col_R[rt];\n        col_R[rt] = 0;\n    }\n}\nvoid push_down_R(int rt) {\n    if(col_R[rt]) {\n        col_R[rt << 1] += col_R[rt];\n        col_R[rt << 1 | 1] += col_R[rt];\n        rs[rt << 1] += col_R[rt];\n        rs[rt << 1 | 1] += col_R[rt];\n        col_R[rt] = 0;\n    }\n       if(col_L[rt]) {\n        col_L[rt << 1] += col_L[rt];\n        col_L[rt << 1 | 1] += col_L[rt];\n        ls[rt << 1] += col_L[rt];\n        ls[rt << 1 | 1] += col_L[rt];\n        col_L[rt] = 0;\n    }\n}\nvoid build(int l, int r, int rt) {\n    col_R[rt] = 0;\n    col_L[rt] = 0;\n\n    if(l == r) {\n        ls[rt] = A[l];\n        rs[rt] = B[l];\n        return;\n    }\n\n    int m = (l + r) >> 1;\n    build(lson);\n    build(rson);\n    push_up(rt);\n}\n\nvoid update_L(int L, int R, int d, int l, int r, int rt) {\n    if(L <= l && r <= R) {\n        ls[rt] += d;\n        col_L[rt] += d;\n        return;\n    }\n\n    int m = (l + r) >> 1;\n    push_down_L(rt);\n    if(L <= m) update_L(L, R, d, lson);\n    if(R > m)  update_L(L, R, d, rson);\n    push_up(rt);\n}\nvoid update_R(int L, int R, int d, int l, int r, int rt) {\n    if(L <= l && r <= R) {\n        rs[rt] += d;\n        col_R[rt] += d;\n        return;\n    }\n\n    int m = (l + r) >> 1;\n    push_down_R(rt);\n    if(L <= m) update_R(L, R, d, lson);\n    if(R > m)  update_R(L, R, d, rson);\n    push_up(rt);\n}\nint query_1(int l, int r, int rt) {\n    if(l == r) {\n        return l;\n    }\n\n    int m = (l + r) >> 1;\n    push_down_L(rt);\n    push_down_R(rt);\n\n    if(rs[rt << 1] > 0) return query_1(lson);\n    else return query_1(rson);\n}\n\nint query_2(int l, int r, int rt) {\n    if(l == r) {\n        return l;\n    }\n\n    int m = (l + r) >> 1;\n    push_down_L(rt);\n    push_down_R(rt);\n    if((ls[rt << 1 | 1]-rs[rt << 1 | 1] )<= 2) return query_2(rson);\n    else return query_2(lson);\n}\n\nint main() {\n    int n, m, t, pos;\n    while(scanf(\"%d%d\", &n, &m)!=EOF) {\n        scanf(\"%s\", W + 1);\n\n        int lsum = 0,rsum=0;\n        for(int i = 1; i <= n; i++) {\n            if(W[i]=='('){\n                lsum++;\n               }\n            else{\n                rsum++;\n            }\n\n            A[i] = lsum;\n            B[i] = rsum;\n        }\n        build(root);\n\n        while(m--) {\n            scanf(\"%d\", &t);\n            //cout<<W[t]<<endl;\n            if(W[t] == '(') {\n                W[t] = ')'; update_L(t, n, -1, root);update_R(t, n, 1, root);\n                t = query_1(root); W[t] = '('; update_L(t, n, 1, root);update_R(t, n, -1, root);\n            } else {\n                W[t] = '('; update_L(t, n, 1, root);update_R(t, n, -1, root);\n                t = query_2(root) + 1; W[t] = ')'; update_L(t, n, -1, root);update_R(t, n, 1, root);\n            }\n            printf(\"%d\\n\", t);\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cctype>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n#define Inf 0x3f3f3f3f\n#define MAXN 300010\n#define MAXM 150010\n#define LL long long\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\nstruct node\n{\n    int max,l,r;\n    int add;\n}tr[MAXN*5];\nint a[MAXN],b[MAXN],ans[MAXM];\nint jsq,n,m;\nchar st[MAXN];\nvoid pushup(int rt)\n{\n    int L=rt*2,R=rt*2+1;\n    tr[rt].max=max(tr[L].max,tr[R].max);\n}\n\nvoid pushdown(int rt)\n{\n    if (tr[rt].add)\n    {\n        int L=rt*2,R=rt*2+1;\n        int x=tr[rt].add;\n        tr[L].max+=x;\n        tr[R].max+=x;\n        tr[L].add+=x;\n        tr[R].add+=x;\n        tr[rt].add=0;\n    }\n}\n\nvoid build(int l,int r,int rt)\n{\n    tr[rt].l=l;tr[rt].r=r;\n    tr[rt].add=0;\n    if (l==r)\n    {\n        tr[rt].max=b[l];\n        return ;\n    }\n    int m=(l+r)/2;\n    build (lson);\n    build(rson);\n    pushup(rt);\n}\n\nvoid update(int L,int R,int val,int l,int r,int rt)\n{\n    //printf(\"%d %d\\n\",L,R);\n    if (L==l && r==R)\n    {\n        tr[rt].add+=val;\n        tr[rt].max+=val;\n        return ;\n    }\n    int m=(l+r)/2;\n    if (R<=m)   update(L,R,val,lson);\n    else if (L>m)  update(L,R,val,rson);\n    else\n    {\n        update(L,m,val,lson);\n        update(m+1,R,val,rson);\n    }\n    pushup(rt);\n}\n\nint find(int x,int l,int r,int rt)\n{\n    int L=rt*2,R=rt*2+1;\n    if (l==r) return l;\n    int m=(l+r)/2;\n    if (tr[L].max>=x)  return find(x,lson);\n    else return find(x,rson);\n}\nint main()\n{\n    int i,j;\n    while (scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        scanf(\"%s\",st);\n        jsq=0;\n        for (i=0; i<n; i++)\n        {\n            if (st[i]=='(')  a[i+1]=1;\n            else a[i+1]=-1;\n        }\n        for (i=1; i<=n; i++)  b[i]=b[i-1]+a[i];\n        build(1,n,1);\n        //for (i=1; i<=20; i++) printf(\"%d \",tr[i].max); printf(\"\\n\");\n        for (i=1; i<=m; i++)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            int d=0;\n            if (a[x]==1)  d=-2;\n                else d=2;\n            //printf(\"x==%d\\n\",x);\n            update(x,n,d,1,n,1);\n            a[x]=-a[x];\n            int k;\n            if(d==2) k=find(2,1,n,1);\n            else\n            {\n                for (j=1; j<=n; j++)  if (a[j]<0) break;\n                k=j;\n            }\n            printf(\"%d\\n\",k);\n            update(k,n,-d,1,n,1);\n            a[k]=-a[k];\n            ans[++jsq]=k;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define STSIZE 300001\n#define TREESIZE 300001 * 4\n#define MAX 300000\n\n#define min(x, y) x < y ? x : y\n\n//遅延評価セグメント木\ntypedef struct{\n  int tree[TREESIZE], lazy[TREESIZE], lazyFlag[TREESIZE];\n}segtree_t;\n\n//プロトタイプ宣言\nint Power2(int n);\nvoid Make_tree(char st[], int n);\nvoid update(int a, int b, int x, int k, int left, int right);\nvoid lazyEvaluate(int k, int left, int right);\nint minimum(int a, int b, int k, int left, int right);\nint get_leaf(int pos, int k, int left, int right);\n//void Print_tree(int n);\nvoid Flip(char st[], int q, int val);\nint Balance(char st[], int n);\n\nint f_open = 0, f_close = 0;  //ひっくり返されたとき1になる\nsegtree_t segtree;\n\n//nより大きい2の累乗\nint Power2(int n){\n  int value;\n  for(value = 1; value < n; value *= 2)\n    ;\n  return value;\n}\n\n//木の作成\nvoid Make_tree(char st[], int n){\n  int sum = 0, i, j;\n\n  for(i = 0; st[i] != '\\0'; ++i){\n    switch(st[i]){\n      case '(':\n        sum++;\n        segtree.tree[n + i - 1] = sum;\n        break;\n      case ')':\n        sum--;\n        segtree.tree[n + i - 1] = sum;\n        break;\n    }\n  }\n  for(;i < n; ++i)\n    segtree.tree[n + i - 1] = MAX;\n  for(i = n - 1, j = n + i - 1; j > 0; j -= 2)\n    segtree.tree[(j - 1) / 2] = min(segtree.tree[j], segtree.tree[j - 1]);\n}\n\n//値の更新\nvoid update(int a, int b, int x, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(right <= a || b <= left)\n    return;\n  if(a <= left && right <= b){\n    segtree.lazy[k] += x;\n    segtree.lazyFlag[k] = 1;\n    lazyEvaluate(k, left, right);\n  }\n  else{\n    update(a, b, x, k * 2 + 1, left, (left + right) / 2);\n    update(a, b, x, k * 2 + 2, (left + right) / 2, right);\n    segtree.tree[k] = min(segtree.tree[k * 2 + 1], segtree.tree[k * 2 + 2]);\n  }\n}\n\n//遅延評価\nvoid lazyEvaluate(int k, int left, int right){\n  if(segtree.lazyFlag[k]){\n    segtree.tree[k] += segtree.lazy[k];\n    if(right - left > 1){  //kが葉ではないとき\n      segtree.lazy[k * 2 + 1] += segtree.lazy[k];\n      segtree.lazy[k * 2 + 2] += segtree.lazy[k];\n      segtree.lazyFlag[k * 2 + 1] = segtree.lazyFlag[k * 2 + 2] = 1;\n    }\n    segtree.lazy[k] = 0;\n    segtree.lazyFlag[k] = 0;\n  }\n}\n\n//半閉区間[a, b)の最小値\nint minimum(int a, int b, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(right <= a || b <= left)\n    return MAX;\n  if(a <= left && right <= b)\n    return segtree.tree[k];\n  else{\n    int vl = minimum(a, b, k * 2 + 1, left, (left + right) / 2);\n    int vr = minimum(a, b, k * 2 + 2, (left + right) / 2, right);\n    return min(vl, vr);\n  }\n}\n\n//葉ノードの値を取得\nint get_leaf(int pos, int k, int left, int right){\n  lazyEvaluate(k, left, right);\n  if(pos == left)\n    return segtree.tree[k];\n  if(pos < (left + right) / 2)\n    return get_leaf(pos, k * 2 + 1, left, (left + right) / 2);\n  else\n    return get_leaf(pos, k * 2 + 2, (left + right) / 2, right);\n}\n\n/*\n//木の表示\nvoid Print_tree(int n){\n  for(int i = 0; i < 2 * n - 1; i++)\n    printf(\"%d \", segtree.tree[i]);\n  printf(\"\\n\");\n}\n*/\n\n//位置qの括弧をひっくり返す\nvoid Flip(char st[], int q, int n){\n  switch (st[q-1]) {\n    case '(':\n      st[q-1] = ')';\n      f_open = 1;\n      update(q - 1, n, -2, 0, 0, n);\n      break;\n    case ')':\n      st[q-1] = '(';\n      f_close = 1;\n      update(q - 1, n, 2, 0, 0, n);\n      break;\n  }\n}\n\n//ひっくり返したとき括弧の対応がとれている最も左の位置を返す\nint Balance(char st[], int n){\n  if(f_open){  //開きが閉じにひっくり返されたとき\n    for(int i = 1; st[i - 1] != '\\0'; ++i)\n      if(st[i - 1] == ')'){  //一番左の閉じを開きにすればよい\n        Flip(st, i, n);\n        return i;\n      }\n  }\n  else if(f_close){  //閉じが開きにひっくり返されたとき\n    for(int i = 0; st[i] != '\\0'; ++i){\n      if(st[i] == '(' && get_leaf(i, 0, 0, n) >= 2){\n        //update(i + 1, n, 0, 0, 0, n);\n        //printf(\"%d\\n\", minimum(i + 1, n, 0, 0, n));\n        if(minimum(i + 1, n, 0, 0, n) > 1){\n          Flip(st, i + 1, n);\n          return i + 1;\n        }\n      }\n    }\n  }\n  else\n    return -1;\n}\n\nint main(){\n  char st[STSIZE];\n  int p, q, n;\n  int val;\n\n  scanf(\"%d%d\", &n, &q);\n  val = Power2(n);\n  scanf(\"%s\", st);\n  Make_tree(st, val);\n  //Print_tree(val);\n  for(int i = 0; i < 2 * val - 1; ++i)\n    segtree.lazy[i] = 0;\n  for(int i = 1; i <= q; i++){\n    f_open = 0; f_close = 0;\n    scanf(\"%d\", &p);\n    Flip(st, p, val);\n    printf(\"%d\\n\", Balance(st, val));\n    //Print_tree(val);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=Math.max(0, start/sz-1); i<=n/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) - 1);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(new Integer(i));\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.higher(new Integer(-1));\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                    }\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){\n        //int from = f - f%sz;\n        //int to = from + sz;\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=Math.max(0, start/sz-1); i<=last/sz+1; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q-1);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to = from + sz;\n        }\n    }\n\n    int search(int f){\n        int from = f - f%sz;\n        int to = from + sz;\n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=Math.max(0, from); j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "himport java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) + 10);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i * sz <=last; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=Math.max(from, start); j<to && j<last; j++){\n                    a[j] += num;\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tchar[] in = sc.next().toCharArray();\n\t\t\n\t\tint[] a = new int[n];\n\t\tTreeSet<Integer> Q = new TreeSet<Integer>();\n\t\t\n\t\tfor(int i = 0; i < n; i++){ //&#151;&#221;&#144;&#207;&#152;a&#139;&#129;&#130;&#223;&#130;&#233;\n\t\t\ta[i] = (i == 0 ? 0 : a[i - 1]) + (in[i] == '(' ? 1 : -1);\n\t\t\tif(in[i] == ')') Q.add(i); //&#149;&#194;&#130;¶&#138;&#135;&#140;&#202;&#130;&#204;&#136;&#202;&#146;u&#130;&#205;&#143;W&#141;&#135;&#130;&#197;&#130;&#224;&#130;&#193;&#130;&#196;&#130;&#353;&#130;&#173;&#129;@&#129;i&#141;&#237;&#143;&#156;&#129;A&#141;&#197;&#143;&#172;&#146;l&#130;&#204;&#142;&#230;&#147;&#376;&#130;&#240;&#145;&#172;&#130;&#173;&#130;&#181;&#130;&#339;&#130;&#162;&#130;&#169;&#130;&#231;&#129;j\n\t\t}\n\t\t\n\t\tRMQ rmq = new RMQ(n, a);\n\t\t\n\t\twhile(q-- > 0){\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tif(in[p] == '('){\n\t\t\t\tQ.add(p);\n\t\t\t\trmq.addQuery(p, n, -2);\n\t\t\t\tin[p] = ')';\n\t\t\t\tp = Q.pollFirst();\n\t\t\t\trmq.addQuery(p, n, 2);\n\t\t\t\tin[p] = '(';\n\t\t\t\tSystem.out.println(p + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\trmq.addQuery(p, n, 2);\n\t\t\t\tin[p] = '(';\n\t\t\t\tQ.remove(p);\n\t\t\t\tp = rmq.findRightMostOne(0, n) + 1;\n\t\t\t\trmq.addQuery(p, n, -2);\n\t\t\t\tin[p] = ')';\n\t\t\t\tQ.add(p);\n\t\t\t\tSystem.out.println(p + 1);\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\tclass RMQ{\n\t\tint n;\n\t\tint[] a;\n\t\tint[] bkt, add;\n\t\tint bktSize;\n\t\t\n\t\tRMQ(int n, int[] a){\n\t\t\t\n\t\t\tbktSize = Math.max(100, (int)Math.sqrt(n)); //&#131;o&#131;P&#131;b&#131;g&#130;&#204;&#131;T&#131;C&#131;Y&#130;&#205;&#130;&#376;&#130;&#162;&#130;&#339;&#130;&#162;sqrt(n)\n\t\t\tthis.a = Arrays.copyOf(a, n);\n\t\t\tthis.n = n;\n\t\t\t\n\t\t\tint bktNum = (n + bktSize - 1) / bktSize; //&#131;o&#131;P&#131;b&#131;g&#130;&#204;&#140;&#194;&#144;&#148;&#130;&#205;(n / &#131;T&#131;C&#131;Y)&#130;&#240;&#144;&#216;&#130;&#232;&#143;&#227;&#130;°\n\t\t\t\n\t\t\tbkt = new int[bktNum]; //&#131;o&#131;P&#131;b&#131;g&#147;&#224;&#130;&#204;&#141;&#197;&#143;&#172;&#146;l\n\t\t\tadd = new int[bktNum]; //&#131;o&#131;P&#131;b&#131;g&#145;S&#145;&#204;&#130;&#201;&#145;&#171;&#130;&#181;&#130;&#339;&#146;l\n\t\t\t\n\t\t\tArrays.fill(bkt, Integer.MAX_VALUE);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tbkt[i / bktSize] = Math.min(bkt[i / bktSize], a[i]); //&#131;o&#131;P&#131;b&#131;g&#147;&#224;&#130;&#204;&#141;&#197;&#143;&#172;&#146;l&#130;&#240;&#140;v&#142;Z\n\t\t\t}\n\t\t\t//System.err.println(\"bktSize: \" + bktSize + \" bktNum: \" + bktNum);\n\t\t}\n\t\tvoid addQuery(int l, int r, int val){\n\t\t\t\n\t\t\t//l&#145;&#8364;&#130;&#197;&#131;o&#131;P&#131;b&#131;g&#130;&#169;&#130;&#231;&#130;&#205;&#130;&#221;&#143;o&#130;&#196;&#130;&#162;&#130;&#233;&#149;&#148;&#149;&#170;&#130;&#201;&#140;&#194;&#149;&#202;&#130;&#201;&#145;&#171;&#130;&#183;\n\t\t\t//&#145;&#171;&#130;&#181;&#130;&#339;&#140;&#227;&#130;&#197;&#129;A&#130;&#187;&#130;&#204;&#149;&#148;&#149;&#170;&#130;&#204;&#131;o&#131;P&#131;b&#131;g&#130;&#376;&#130;&#175;&#141;&#197;&#143;&#172;&#146;l&#130;&#240;&#130;&#224;&#130;&#8364;&#136;&#234;&#147;x&#139;&#129;&#130;&#223;&#130;&#233;\n\t\t\tint b = l / bktSize;\n\t\t\tbkt[b] = Integer.MAX_VALUE;\n\t\t\tfor(; l < r && l % bktSize > 0; l++) a[l] += val;\n\t\t\tfor(int i = b * bktSize; i < n && i < (b + 1) * bktSize; i++) bkt[b] = Math.min(bkt[b], a[i]);\n\t\t\t\n\t\t\t//r&#145;&#8364;&#130;&#197;&#131;o&#131;P&#131;b&#131;g&#130;&#169;&#130;&#231;&#130;&#205;&#130;&#221;&#143;o&#130;&#196;&#130;&#162;&#130;&#233;&#149;&#148;&#149;&#170;&#130;&#201;&#140;&#194;&#149;&#202;&#130;&#201;&#145;&#171;&#130;&#183;\n\t\t\tif(r % bktSize > 0){\n\t\t\t\tb = r / bktSize;\n\t\t\t\tbkt[b] = Integer.MAX_VALUE;\n\t\t\t\tfor(; l < r && r % bktSize > 0; ) a[--r] += val;\n\t\t\t\tfor(int i = b * bktSize; i < n && i < (b + 1) * bktSize; i++) bkt[b] = Math.min(bkt[b], a[i]);\n\t\t\t}\n\t\t\t\n\t\t\t//&#131;o&#131;P&#131;b&#131;g&#130;&#204;&#147;&#224;&#149;&#148;&#130;&#201;&#147;&#252;&#130;&#193;&#130;&#196;&#130;&#162;&#130;&#233;&#149;&#148;&#149;&#170;&#130;&#205;&#136;&#234;&#139;C&#130;&#201;&#145;&#171;&#130;&#183;\n\t\t\tl /= bktSize; r /= bktSize;\n\t\t\tfor(; l < r; l++) add[l] += val;\n\t\t\t\n\t\t\t//for(int i = 0; i < n; i++) System.err.print(a[i] + (i == n - 1 ? \"\\n\" :\" \"));\n\t\t\t\n\t\t}\n\t\tint findRightMostOne(int l, int r){ //&#136;&#234;&#148;&#212;&#137;E&#130;&#204;1&#130;&#204;&#146;l&#130;&#240;&#139;&#129;&#130;&#223;&#130;&#233;\n\t\t\t//r&#130;&#204;&#145;&#8364;&#130;&#197;&#131;o&#131;P&#131;b&#131;g&#130;&#169;&#130;&#231;&#130;&#205;&#130;&#221;&#143;o&#130;&#196;&#130;&#162;&#130;&#233;&#149;&#148;&#149;&#170;\n\t\t\tfor(; l < r && r % bktSize > 0; ){\n\t\t\t\t--r;\n\t\t\t\tif(a[r] + add[r / bktSize] == 1) return r;\n\t\t\t}\n\t\t\t//&#131;o&#131;P&#131;b&#131;g&#130;&#240;&#137;E&#130;&#169;&#130;&#231;&#140;&#169;&#130;&#196;&#130;&#162;&#130;&#173;\n\t\t\tr /= bktSize;\n\t\t\tfor(int b = l / bktSize; b < r; ){\n\t\t\t\t--r;\n\t\t\t\tif(bkt[r] + add[r] > 1) continue;\n\t\t\t\t\n\t\t\t\t//&#131;o&#131;P&#131;b&#131;g&#130;&#204;&#146;&#134;&#130;&#201;&#130;&#160;&#130;&#233;&#130;&#204;&#130;&#197;&#146;T&#130;&#183;&#129;B\n\t\t\t\tfor(int i = (r + 1) * bktSize - 1; i >= r * bktSize; i--)\n\t\t\t\t\tif(a[i] + add[r] == 1) return i;\n\t\t\t}\n\t\t\t//&#130;&#140;&#130;&#204;&#145;&#8364;&#130;&#197;&#131;o&#131;P&#131;b&#131;g&#130;&#169;&#130;&#231;&#130;&#205;&#130;&#221;&#143;o&#130;&#196;&#130;&#162;&#130;&#233;&#149;&#148;&#149;&#170;&#129;i&#136;&#234;&#148;&#212;&#137;E&#130;&#204;&#130;&#240;&#139;&#129;&#130;&#223;&#130;&#339;&#130;&#162;&#130;&#204;&#130;&#197;&#137;E&#130;&#169;&#130;&#231;&#140;&#169;&#130;&#196;&#130;&#162;&#130;&#173;&#129;j\n\t\t\tr *= bktSize;\n\t\t\tfor(; l < r; ){\n\t\t\t\t--r;\n\t\t\t\tif(a[r] + add[r / bktSize] == 1) return r;\n\t\t\t}\n\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) - 1);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i * sz <=last; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=Math.max(from, start); j<to && j<last; j++){\n                    a[j] += num;\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q-1);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){\n        //int from = f - f%sz;\n        //int to = from + sz;\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        \n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        \n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        /*\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        */\n        for(int i=f; i>=0; i--){\n            if(a[i] + add[i/sz]==1) return i+1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=n/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) - 1);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                    }\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q-1);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to = from + sz;\n        }\n    }\n\n    int search(int f){\n        \n        int from = f - f%sz;\n        int to = from + sz;\n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f+1, to)-1; j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        /*\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n        */\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.higher(new Integer(-1));\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) + 10);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i * sz <=last; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=Math.max(from, start); j<to && j<last; j++){\n                    a[j] += num;\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<=n/sz; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        \n        int from = 0;\n        int to = sz;\n        for(int i=0; i<=n/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        \n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        \n        /*\n        for(int i=f; i>=0; i--){\n            if(a[i] + add[i/sz]==1) return i+1;\n        }\n        */\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) - 1);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(new Integer(i));\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                    }\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main2{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        /*\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        */\n        for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        /*\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        */\n        for(int i=f; i>=0; i--){\n            if(a[i]==1) return i+1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main2().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(100, (int)Math.sqrt(n) + 10);\n        a = new int[n];\n        bkt = new int[n/sz+1];\n        add = new int[n/sz+1];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i * sz <=last; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=Math.max(from, start); j<to && j<last; j++){\n                    a[j] += num;\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        /*\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n        */\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.higher(new Integer(-1));\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q-1);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){\n        //int from = f - f%sz;\n        //int to = from + sz;\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=Math.max(0, from); j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+2];\n        add = new int[n/sz+2];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n        /*\n        for(int i=0; i<=n/sz; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n        */\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        \n        int from = 0;\n        int to = sz;\n        for(int i=0; i<=n/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        \n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        \n        int from = f - f%sz;\n        int to = from + sz;\n        //while(!(from<=f && f<to)){\n        //    from = to;\n        //    to += sz;\n        // }\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        \n        /*\n        for(int i=f; i>=0; i--){\n            if(a[i] + add[i/sz]==1) return i+1;\n        }\n        */\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){\n        //int from = f - f%sz;\n        //int to = from + sz;\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=Math.max(0, from); j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\n// Computational cost: O( N + Q log N )\n// using segment trees for paren depths and # of close parens + 1-pass search\n\nclass Main {\n    static final int BIG = 2*512*1024;\n    static int [] ds;  // depths of open parens (for region-min)\n    static int [] ds2; // depths of open parens (for region-max)\n    static int [] ods; // depths of parens\n    static int [] us;  // lazy updates\n    static int [] ss;  // sums of close parens\n    static int n;      // # of chars\n    static char [] ps; // parens\n    static int N;      // # of leaves in each of the trees (i.e., the minimum 2^k >= n)\n    static int [] mnx; // the results of min/max-query\n    static void out(int [] xs) {\n        for(int i = 1, d = 2; i < 2*N; i++) {\n            if(i == d) {\n                d *= 2;\n                System.out.println();\n            }\n            System.out.print(\" \" + xs[i]);\n        }\n        System.out.println();\n    }\n\n    public static void main(String [] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        N = 1;\n        for(int i = n; i > 0; i >>= 1, N<<=1 );\n        if(2*n == N) N = n;\n        ds = new int[2*N];\n        ds2 = new int[2*N];\n        ods = new int[2*N];\n        ss = new int[2*N];\n        us = new int[2*N];\n        mnx = new int[2];\n        for(int i = 0; i < 2*N; i++) {\n            us[i] = 0;\n            ds[i] = BIG;\n            ds2[i] = -BIG;\n            ods[i] = BIG;\n            ss[i] = 0;\n        }\n        int q = Integer.parseInt(st.nextToken());\n        ps = br.readLine().toCharArray();\n        // paren depths & # of closes\n        int d = 0;\n        for(int i = 0; i < n; i++) {\n            if(ps[i] == ')') {\n                ods[i+N] = d;\n                ds[i+N] = BIG;\n                ds2[i+N] = -BIG;\n                d--;\n                ss[i+N] = 1;\n            } else {\n                ods[i+N] = d;\n                ds[i+N] = d;\n                ds2[i+N] = d;\n                d++;\n            }\n        }\n        // initialize the internal nodes\n        for(int i = N-1; i > 0; i--) {\n            ds[i] = Math.min(ds[i*2], ds[i*2+1]);\n            ds2[i] = Math.max(ds2[i*2], ds2[i*2+1]);\n            ss[i] = ss[i*2] + ss[i*2+1];\n        }\n        for(int i = 0; i < q; i++) {\n            int j = Integer.parseInt(br.readLine()) - 1;\n            if(ss[j+N] == 1) {\n                open(j);\n                int k = rightmost_open_2nd();\n                System.out.println(k+1);\n                close(k);\n            } else {\n                close(j);\n                int k = leftmost_close();\n                System.out.println(k+1);\n                open(k);\n            }\n        }\n    }\n    static int rightmost_open_2nd() {\n        return rightmost_open_2nd_rec(1, 0, N);\n    }\n    static int rightmost_open_2nd_rec(int k, int l, int r) {\n        if(r - l == 1) return k - N;\n        if(us[k] != 0) {\n            push(2*k  , us[k], l, (l+r)/2);\n            push(2*k+1, us[k], (l+r)/2, r);\n            us[k] = 0;\n        }\n        if( ds[2*k+1] <= 1 && 1 <= ds2[2*k+1] ) {\n            return rightmost_open_2nd_rec(2*k+1, (l+r)/2, r);\n        } else {\n            return rightmost_open_2nd_rec(2*k, l, (l+r)/2);\n        }\n    }\n    static int leftmost_close() {\n        return leftmost_close_rec(1, 0, N);\n    }\n    static int leftmost_close_rec(int k, int l, int r) {\n        if(r - l == 1) return k - N;\n        if( ss[2*k] >= 1 ) {\n            return leftmost_close_rec(2*k, l, (l+r)/2);\n        } else {\n            return leftmost_close_rec(2*k+1, (l+r)/2, r);\n        }\n    }\n    static void open(int j) {\n        //ps[j] = '(';\n        write_s(j, 0);\n        clear(j, 1, 0, N); // path clear (to make ods[N+j] valid);\n        write_d(j, ods[N+j]); // put the depth ods[N+j]\n        update_region(j+1, n, 1, 2, 0, N);  // update the depths by +2\n    }\n    static void close(int j) {\n        //ps[j] = ')';\n        write_s(j, 1);\n        write_d(j, BIG); // remove the depth \n        update_region(j+1, n, 1, -2, 0, N);  // update the depths by -2\n    }\n    static void write_s(int i, int v) {\n        i += N;\n        ss[i] = v;\n        for(i >>=1; i > 0; i >>=1) ss[i] = ss[i*2] + ss[i*2+1];\n    }\n    static int sum_s(int i, int j, int k, int l, int r) {\n        if(r <= i || j <= l) return 0;\n        if(i <= l && r <= j) return ss[k];\n        int sl = sum_s(i, j, k*2    , l, (l+r)/2);\n        int sr = sum_s(i, j, k*2 + 1, (l+r)/2, r);\n        return sl + sr;\n    }\n    static void clear(int i, int k, int l, int r) {\n        min_max_d2(i, i+1, k, l, r);\n    }\n    static void write_d(int i, int v) {\n        clear(i, 1, 0, N); // clear the path\n        i += N;\n        ds[i] = v;\n        ds2[i] = v > n ? -v : v;\n        for(i >>=1; i > 0; i >>=1) {\n            ds[i]  = Math.min(ds[i*2] , ds[i*2+1] );\n            ds2[i] = Math.max(ds2[i*2], ds2[i*2+1]);\n        }\n    }\n    static void push(int k, int u, int l, int r) {\n        us[k] += u;\n        ds[k] += u;\n        ds2[k] += u;\n        if(l - r == -1) { ods[k] += u; us[k] = 0; }\n    }\n    static void min_max_d2(int i, int j, int k, int l, int r) {\n        if(r <= i || j <= l) return;\n        if(us[k] != 0) {\n            push(2*k  , us[k], l, (l+r)/2);\n            push(2*k+1, us[k], (l+r)/2, r);\n            us[k] = 0;\n        }\n        if(i <= l && r <= j) {\n            if(mnx[0] > ds[k])  mnx[0] = ds[k];\n            if(mnx[1] < ds2[k]) mnx[1] = ds2[k];\n            return;\n        }\n        min_max_d2(i, j, k*2    , l, (l+r)/2);\n        min_max_d2(i, j, k*2 + 1, (l+r)/2, r);\n    }\n    static void update_region(int i, int j, int k, int v, int l, int r) {\n        if(r <= i || j <= l) return;\n        if(i <= l && r <= j) {\n            push(k, v, l, r);\n        } else {\n            update_region(i, j, k*2    , v, l, (l+r)/2);\n            update_region(i, j, k*2 + 1, v, (l+r)/2, r);\n            ds[k]  = Math.min(ds[k*2] , ds[k*2+1] );\n            ds2[k] = Math.max(ds2[k*2], ds2[k*2+1]);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) - 1);\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(new Integer(i));\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.higher(new Integer(-1));\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n/sz+10];\n        add = new int[n/sz+10];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(new Integer(i));\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.higher(new Integer(-1));\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i<=last/sz; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n        //System.out.println(Arrays.toString(a));\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q-1);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to = from + sz;\n        }\n\n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        \n        int from = f - f%sz;\n        int to = from + sz;\n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.max(0, from); j<to; j++){\n                    if(j<=f && a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        \n        /*\n        int idx = (from-1)/sz;\n        for(int i=idx; i>=0; i--){\n            if(bkt[i]<=1){\n                for(int j=0; j<sz; j++){\n\n                }\n            }\n        }\n        */\n        /*\n        for(int i=f; i>=0; i--){\n            if(a[i]==1) return i+1;\n        }\n        */\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        \n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        \n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        \n        int from = f - f%sz;\n        int to = from + sz;\n\n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        \n        /*\n        for(int i=f; i>=0; i--){\n            if(a[i] + add[i/sz]==1) return i+1;\n        }\n        */\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        \n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        \n        //for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        /*\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        */\n        for(int i=f; i>=0; i--){\n            if(a[i] + add[i/sz]==1) return i+1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = (int)Math.sqrt(n) - 1;\n        a = new int[n];\n        bkt = new int[n];\n        add = new int[n];\n        PriorityQueue<Integer> set = new PriorityQueue<Integer>(10, new Comparator<Integer>(){\n                public int compare(Integer a, Integer b){\n                    return (int)(a - b);\n                }\n            });\n\n        a[0] = 1;\n        for(int i=1; i<n; i++){\n            if(kakko[i]=='(') a[i] = a[i-1] + 1;\n            else{\n                a[i] = a[i-1] - 1;\n                set.add(new Integer(i));\n            }\n        }\n\n        for(int i=0; i<n; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j=0; j<sz && j*i<n; j++){\n                min = Math.min(min, a[j * i]);\n            }\n            bkt[i] = min;\n        }\n\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(new Integer(q));\n                add(q, n, -2);\n                idx = set.poll();\n                kakko[idx] = '(';\n                set.remove(new Integer(idx));\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(new Integer(q));\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(new Integer(idx));\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        /*\n        int from = 0;\n        int to = sz;\n        for(int i=0; i<n; i++){\n            if(from<=start && last<=to){\n                add[i] += num;\n                //bkt[i] += num;\n            }else{\n                for(int j=from; j<to; j++){\n                    if(start<=j && j<last){\n                        a[j] += num;\n                        if(a[j] < bkt[i]) bkt[i] = a[j];\n                    }\n                }\n            }\n            from = to;\n            to += sz;\n        }\n        */\n        for(int i=start; i<last; i++) a[i] += num;\n    }\n\n    int search(int f){\n        /*\n        int from = 0;\n        int to = sz;\n        while(!(from<=f && f<to)){\n            from = to;\n            to += sz;\n        }\n            \n        for(int i=0; i<n; i++){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        */\n        for(int i=f; i>=0; i--){\n            if(a[i]==1) return i+1;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, sz;\n    char[] kakko;\n    int[] a, bkt, add;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        kakko = sc.next().toCharArray();\n\n        sz = Math.max(1, (int)Math.sqrt(n) + 10);\n        a = new int[n];\n        bkt = new int[n/sz+1];\n        Arrays.fill(bkt, Integer.MAX_VALUE);\n        add = new int[n/sz+1];\n        TreeSet<Integer> set = new TreeSet<Integer>();\n\n        for(int i=0; i<n; i++){\n            if(i==0) a[i] = 1;\n            else{\n                if(kakko[i]=='(') a[i] = a[i-1] + 1;\n                else{\n                    a[i] = a[i-1] - 1;\n                    set.add(i);\n                }\n            }\n            bkt[i/sz] = Math.min(a[i], bkt[i/sz]);\n        }\n\n        for(int i=0; i<m; i++){\n            int q = sc.nextInt()-1;\n            int idx = 0;\n            if(kakko[q]=='('){\n                kakko[q] = ')';\n                set.add(q);\n                add(q, n, -2);\n                //idx = set.higher(new Integer(-1));\n                idx = set.pollFirst();\n                kakko[idx] = '(';\n                set.remove(idx);\n                add(idx, n, 2);\n            }else{\n                kakko[q] = '(';\n                set.remove(q);\n                add(q, n, 2);\n                idx = search(q);\n                kakko[idx] = ')';\n                add(idx, n, -2);\n                set.add(idx);\n            }\n            //System.out.println(Arrays.toString(kakko));\n            System.out.println(idx+1);\n        }\n    }\n\n    void add(int start, int last, int num){\n        int from = start - start%sz;\n        int to = from + sz;\n        for(int i=start/sz; i * sz <=last; i++){\n            if(start<=from && to<=last){\n                add[i] += num;\n            }else{\n                for(int j=Math.max(from, start); j<to && j<last; j++){\n                    a[j] += num;\n                }\n                int min = Integer.MAX_VALUE;\n                for(int j=from; j<to && j<a.length; j++){\n                    min = Math.min(min, a[j]);\n                }\n                bkt[i] = min;\n            }\n            from = to;\n            to += sz;\n        }\n    }\n\n    int search(int f){        \n        int from = f - f%sz;\n        int to = from + sz;\n            \n        for(int i=f/sz; i>=0; i--){\n            if(bkt[i]+add[i]<=1){\n                for(int j=Math.min(f-1, to-1); j>=from; j--){\n                    if(a[j]+add[i]==1) return j+1;\n                }\n            }\n            to = from;\n            from -= sz;\n        }\n        return 0;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "class SegmentTree\n\tdef initialize(arr, l = 0, r = arr.size - 1)\n\t\t@l = l\n\t\t@r = r\n\t\tif l == r\n\t\t\t@val = arr[l]\n\t\t\t@leftmost_min = [l, @val]\n\t\t\t@sum = arr[l]\n\t\t\t@sum_rightmost_min = [r, @val]\n\t\telse\n\t\t\tc = (l + r) / 2\n\t\t\t@left_child = self.class.new(arr, l, c)\n\t\t\t@right_child = self.class.new(arr, c+1, r)\n\t\t\t@sum = @left_child.sum + @right_child.sum\n\n\t\t\tlx, lv = @left_child.leftmost_min\n\t\t\trx, rv = @right_child.leftmost_min\n\t\t\t@leftmost_min = ( rv < lv ? [rx, rv] : [lx, lv] )\n\n\t\t\tlx, lv = @left_child.sum_rightmost_min\n\t\t\trx, rv = @right_child.sum_rightmost_min\n\t\t\trv += @left_child.sum\n\t\t\t@sum_rightmost_min = ( rv <= lv ? [rx, rv] : [lx, lv] )\n\t\tend\n\tend\n\n\tdef sum(l = @l, r = @r)\n\t\tif l == @l && r == @r\n\t\t\t@sum\n\t\telsif r <= @left_child.r\n\t\t\t@left_child.sum(l, r)\n\t\telsif @right_child.l <= l\n\t\t\t@right_child.sum(l, r)\n\t\telse\n\t\t\tls = @left_child.sum(l, @left_child.r)\n\t\t\trs = @right_child.sum(@right_child.l, r)\n\t\t\tls + rs\n\t\tend\n\tend\n\n\tdef sum_rightmost_min(l = @l, r = @r)\n\t\tif l == @l && r == @r\n\t\t\t@sum_rightmost_min\n\t\telsif r <= @left_child.r\n\t\t\t@left_child.sum_rightmost_min(l, r)\n\t\telsif @right_child.l <= l\n\t\t\t@right_child.sum_rightmost_min(l, r)\n\t\telse\n\t\t\tlx, lv = @left_child.sum_rightmost_min(l, @left_child.r)\n\t\t\trx, rv = @right_child.sum_rightmost_min(@right_child.l, r)\n\t\t\trv += @left_child.sum(l, @left_child.r)\n\t\t\t(rv <= lv) ? [rx, rv] : [lx, lv]\n\t\tend\n\tend\n\n\tdef leftmost_min(l = @l, r = @r)\n\t\treturn @leftmost_min if l == @l && r == @r\n\t\tif r <= @left_child.r\n\t\t\t@left_child.leftmost_min(l, r)\n\t\telsif @right_child.l <= l\n\t\t\t@right_child.leftmost_min(l, r)\n\t\telse\n\t\t\tlx, lv = @left_child.leftmost_min(l, @left_child.r)\n\t\t\trx, rv = @right_child.leftmost_min(@right_child.l, r)\n\t\t\trv < lv ? [rx, rv] : [lx, lv]\n\t\tend\n\tend\n\n\tdef update(i, x)\n\t\tif @l == i && @l == @r\n\t\t\t@val = x\n\t\t\t@leftmost_min[1] = x\n\t\t\t@sum = x\n\t\t\t@sum_rightmost_min = [r, @val]\n\t\t\treturn\n\t\tend\n\t\tif i <= @left_child.r\n\t\t\t@left_child.update(i, x)\n\t\telsif @right_child.l <= i\n\t\t\t@right_child.update(i, x)\n\t\telse\n\t\t\traise\n\t\tend\n\t\tlx, lv = @left_child.leftmost_min\n\t\trx, rv = @right_child.leftmost_min\n\t\t@leftmost_min = (rv < lv ? [rx, rv] : [lx, lv])\n\n\t\t@sum = @left_child.sum + @right_child.sum\n\n\t\tlx, lv = @left_child.sum_rightmost_min\n\t\trx, rv = @right_child.sum_rightmost_min\n\t\trv += @left_child.sum\n\t\t@left_child.sum\n\t\t@sum_rightmost_min = ( rv < lv ? [rx, rv] : [lx, lv] )\n\tend\n\n\tattr_reader :val, :l, :r\nend\n\nclass Array\n\tdef accum\n\t\tac = Array.new(size + 1)\n\t\tac[0] = 0\n\t\t(1..size).each do |i|\n\t\t\tac[i] = ac[i-1] + self[i-1]\n\t\tend\n\t\tac\n\tend\nend\n\nn, q = gets.split.map(&:to_i)\npar = gets.chomp.split(\"\").map {|c| 1 - 2 * (c.ord - 40)}\n\nt = SegmentTree.new(par)\n\nq.times do\n\ti = gets.to_i - 1\n\tj = nil\n\tif par[i] == +1\n\t\tj, _ = t.leftmost_min\n\t\tj = i if j > i\n\telse\n\t\tj, x = t.sum_rightmost_min(0, i)\n\t\tif x > 0\n\t\t\tj = 1\n\t\tend\n\tend\n\tp j + 1\n\tpar[i] *= -1\n\tpar[j] *= -1\n\tt.update(i, par[i])\n\tt.update(j, par[j])\nend"
  },
  {
    "language": "Ruby",
    "code": "class SegmentTree\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @l = l\n    @r = r\n    if @l == @r\n      @leftmost_close = (arr[l] == ?) ? l : Float::INFINITY)\n    else\n      c = (l + r) / 2\n      @left_child = self.class.new(arr, l, c)\n      @right_child = self.class.new(arr, c + 1, r)\n      @leftmost_close = [@left_child.leftmost_close, @right_child.leftmost_close].min\n    end\n  end\n\n  attr_reader :leftmost_close, :l, :r\n\n  def flip(i)\n    if @l == @r\n      @leftmost_close = (@leftmost_close == Float::INFINITY ? l : Float::INFINITY)\n    else\n      (i <= @left_child.r ? @left_child : @right_child).flip(i)\n      @leftmost_close = [@left_child.leftmost_close, @right_child.leftmost_close].min\n    end\n  end\nend\n\nclass LazySegmentTree\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @l, @r = l, r\n    @lazy = nil\n    if @l == @r\n      @min = arr[l]\n    else\n      c = (l + r) / 2\n      @left_child = self.class.new(arr, l, c)\n      @right_child = self.class.new(arr, c + 1, r)\n      @min = [@left_child.min, @right_child.min].min\n    end\n  end\n\n  attr_reader :min, :l, :r, :left_child, :right_child, :lazy\n\n  def add(l, x)\n    if @l == @r\n      @min += x\n    elsif l == @l\n      if @lazy\n        @lazy += x\n      else\n        @lazy = x\n      end\n    else\n      force\n      if l <= @left_child.r\n        @left_child.add(l, x)\n        @right_child.add(@right_child.l, x)\n      else\n        @right_child.add(l, x)\n      end\n      @left_child.force\n      @right_child.force\n      @min = [@left_child.min, @right_child.min].min\n    end\n  end\n\n  def force\n    return if !@lazy\n    x = @lazy\n    @lazy = nil\n    @min += x\n    @left_child.add(@left_child.l, x)\n    @right_child.add(@right_child.l, x)\n  end\n\n  def rightmost_zero_pos(r)\n    force\n    return -1 if @min > 0\n    return @l if @l == @r\n    return @left_child.rightmost_zero_pos(r) if r <= @left_child.r\n    ret = @right_child.rightmost_zero_pos(r)\n    return @left_child.rightmost_zero_pos(@left_child.r) if ret == -1\n    ret\n  end\n\n  def rightmost_one_pos(r)\n    force\n    return -1 if @min > 1\n    return @min == 1 ? @l : -1 if @l == @r\n    return @left_child.rightmost_one_pos(r) if r <= @left_child.r\n    ret = @right_child.rightmost_one_pos(r)\n    return @left_child.rightmost_one_pos(@left_child.r) if ret == -1\n    ret\n  end\nend\n\nn, q = gets.split.map(&:to_i)\na = gets.chomp.split(\"\")\nb = [0]\na.each do |c|\n  if c == ?(\n    b << b[-1] + 1\n  else\n    b << b[-1] - 1\n  end\nend\nb.shift\n\nseg1 = SegmentTree.new(a)\nseg2 = LazySegmentTree.new(b)\nq.times do\n  i = gets.to_i - 1\n  if a[i] == ?(\n    a[i] = ?)\n    seg1.flip(i)\n    seg2.add(i, -2)\n    j = seg1.leftmost_close\n    puts j + 1\n    seg1.flip(j)\n    seg2.add(j, 2)\n    a[j] = ?(\n  else # a[i] == ?)\n    a[i] = ?(\n    seg1.flip(i)\n    seg2.add(i, 2)\n    zero = seg2.rightmost_zero_pos(i)\n    j = nil\n    if zero == -1\n      j = seg2.rightmost_one_pos(i) + 1\n    else\n      one = seg2.rightmost_one_pos(i)\n      if zero + 1 < one\n        j = one + 1\n      else\n        j = zero + 2\n      end\n    end\n    puts j + 1\n    seg1.flip(j)\n    seg2.add(j, -2)\n    a[j] = ?)\n  end\nend\n"
  },
  {
    "language": "D",
    "code": "/* ICPC 2014 Asia Regional Tokyo Problem G, Flipping Parentheses\n\n * 開括弧が閉括弧になったとき -> 最も左にある閉括弧または変化した括弧のうち、左にあるものを操作.\n * 閉括弧が開括弧になったとき -> どの区間の深さも負にならないように操作できる開括弧のうち、最も左のものを操作\n\n */\n\nimport std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nconst INF = long.max / 8L;\n\nclass SegmentTree {\n    // rootのindexは1\n    int N;\n    long[] V, L;\n    static int FindPow2(int x) {\n        int x1 = 1;\n        while (x1 < x) x1 *= 2;\n        return x1;\n    }\n    this(int N_) {\n        N = FindPow2(N_);\n        V = new long[N * 2];\n        L = new long[N * 2];\n    }\n    /* [s, t)に一様にxを加算 */\n    void add(long x, int s, int t) { return add(x, s, t, 0, N, 1); }\n    void add(long x, int s, int t, int a, int b, int k) {\n        if (t <= a || b <= s) return;\n        if (s <= a && b <= t) {\n            L[k] += x;\n        } else if (s < b || a < t) {\n            int m = (a + b) / 2;\n            add(x, s, t, a, m, k * 2);\n            add(x, s, t, m, b, k * 2 + 1);\n            V[k] = min(V[k * 2] + L[k * 2], V[k * 2 + 1] + L[k * 2 + 1]);\n        }\n    }\n    /* [s, t)の最小値 */\n    long query(int s, int t) { return query(s, t, 0, N, 1); }\n    long query(int s, int t, int a, int b, int k) {\n        if (t <= a || b <= s) return INF;\n        if (s <= a && b <= t) return V[k] + L[k];\n        int m = (a + b) / 2;\n        return min( query(s, t, a, m, k * 2), query(s, t, m, b, k * 2 + 1)) + L[k];\n    }\n};\n\nvoid main() {\n    int N, Q; scanf(\"%d %d\\n\", &N, &Q);\n    char[] s = readln.chomp.dup;\n    auto seg = new SegmentTree(N + 1);\n    for (int i = 1; i <= N; i++) {\n        auto c = s[i - 1];\n        auto d = (c == '(' ? +1 : -1);\n        seg.add(d, i, N + 1);\n    }\n    void dump() {\n        foreach (i; 0 .. N + 1) {\n            write(seg.query(i, i + 1), \" \");\n        }\n        writeln;\n    }\n\n    auto open  = new RedBlackTree!int,\n         close = new RedBlackTree!int;\n\n    foreach (int i, c; s) {\n        ( c == '(' ? open : close ).insert(i);\n    }\n\n    foreach (i; 0 .. Q) {\n        int q; scanf(\"%d\\n\", &q);\n        int sign = (s[q - 1] == '(' ? -1 : 1);\n\n        //writeln(\"q: \", q);\n        //writeln(\"s: \", s);\n        //writeln(\"open: \", open[]);\n        //writeln(\"close: \", close[]);\n\n        if (s[q - 1] == '(') {\n            auto r = close.lowerBound(q); // qより左の閉括弧\n            if (r.empty) {\n                writeln(q);\n            } else {\n                seg.add(-2, q, N + 1);\n                auto index = r.front; // 開く閉括弧のインデックス\n                writeln(index + 1);\n                open.removeKey(q - 1);\n                close.insert(q - 1);\n                close.removeKey(index);\n                open.insert(index);\n                seg.add(2, index + 1, N + 1);\n                s[index] = '('; s[q - 1] = ')';\n            }\n        } else {\n            seg.add(2, q, N + 1);\n            int lb = 0, ub = q; // (lb, ub]\n            bool C(int x) {\n                return seg.query(x, q) >= 2;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                ( C(mid) ? ub : lb ) = mid;\n            }\n            writeln(ub);\n            close.removeKey(q - 1);\n            open.insert(q - 1);\n            open.removeKey(ub - 1);\n            close.insert(ub - 1);\n            seg.add(-2, ub, N + 1);\n            s[q - 1] = '(';\n            s[ub - 1] = ')';\n        }\n        //dump;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N, Q = map(int, readline().split())\n\n    INF = 2**31-1\n\n    LV = (N-1).bit_length()\n    N0 = 2**LV\n    data = [0]*(2*N0)\n    lazy = [0]*(2*N0)\n    L0 = [0]*(2*N0)\n    L1 = [0]*(2*N0)\n\n    def init(A):\n        for i in range(N):\n            data[N0-1+i] = A[i]\n        for i in range(N0):\n            L0[N0-1+i] = L1[N0-1+i] = i\n        for i in range(N0-2, -1, -1):\n            data[i] = min(data[2*i+1], data[2*i+2])\n            L0[i] = L0[2*i+1]\n            L1[i] = L1[2*i+2]\n\n    def gindex(l, r):\n        L = (l + N0) >> 1; R = (r + N0) >> 1\n        lc = 0 if l & 1 else (L & -L).bit_length()\n        rc = 0 if r & 1 else (R & -R).bit_length()\n        for i in range(LV):\n            if rc <= i:\n                yield R\n            if L < R and lc <= i:\n                yield L\n            L >>= 1; R >>= 1\n\n    def propagates(*ids):\n        for i in reversed(ids):\n            v = lazy[i-1]\n            if not v:\n                continue\n            lazy[2*i-1] += v; lazy[2*i] += v\n            data[2*i-1] += v; data[2*i] += v\n            lazy[i-1] = 0\n\n    def update(l, r, x):\n        *ids, = gindex(l, r)\n        propagates(*ids)\n\n        L = N0 + l; R = N0 + r\n        while L < R:\n            if R & 1:\n                R -= 1\n                lazy[R-1] += x; data[R-1] += x\n            if L & 1:\n                lazy[L-1] += x; data[L-1] += x\n                L += 1\n            L >>= 1; R >>= 1\n        for i in ids:\n            data[i-1] = min(data[2*i-1], data[2*i])\n        u = 1\n\n    def query(r):\n        propagates(*gindex(0, r))\n        R = N0 + r\n\n        R = N0 + r\n        while R:\n            if R & 1:\n                R -= 1\n                if data[R-1] < 2:\n                    l0 = L0[R-1]\n                    r0 = L1[R-1]+1\n                    break\n            R >>= 1\n        else:\n            return 0\n\n        k = R-1\n        while k < N0-1:\n            v = lazy[k]\n            if v:\n                lazy[2*k+1] += v; lazy[2*k+2] += v\n                data[2*k+1] += v; data[2*k+2] += v\n                lazy[k] = 0\n            if data[2*k+2] < 2:\n                l0 = (l0 + r0) >> 1\n                k = 2*k+2\n            else:\n                r0 = (l0 + r0) >> 1\n                k = 2*k+1\n        return r0\n\n    que = []\n    *s, = map(\"()\".index, readline().strip())\n    A = [0]*N\n    C = [0]*N\n    cur = 0\n    for i in range(N):\n        if s[i]:\n            que.append(i)\n            C[i] = 1\n            cur -= 1\n        else:\n            cur += 1\n        A[i] = cur\n    heapify(que)\n    init(A)\n\n    for i in range(Q):\n        q = int(readline())\n        if s[q-1] == 0:\n            while que and s[que[0]] == 0:\n                v = heappop(que)\n                C[v] = 0\n            if not que or q-1 <= que[0]:\n                write(\"%d\\n\" % q)\n            else:\n                k = heappop(que)\n                C[k] = 0\n                s[k] = 0\n                s[q-1] = 1\n                heappush(que, q-1)\n                write(\"%d\\n\" % (k+1))\n                update(k, q-1, 2)\n        else:\n            v = query(q-1)\n            if v == q-1:\n                write(\"%d\\n\" % q)\n            else:\n                s[v] = 1\n                s[q-1] = 0\n                if C[v] == 0:\n                    heappush(que, v)\n                    C[v] = 1\n                write(\"%d\\n\" % (v + 1))\n                update(v, q-1, -2)\nsolve()\n"
  }
]