[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100000\n\nint main() {\n    int n, m;\n    char s[MAXN + 2];\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s);\n\n    int *stack = (int *)malloc(n * sizeof(int));\n    int top = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '(') {\n            stack[++top] = i;\n        } else {\n            if (top >= 0 && s[stack[top]] == '(') {\n                top--;\n            } else {\n                stack[++top] = i;\n            }\n        }\n    }\n\n    int pos;\n    while (m--) {\n        scanf(\"%d\", &pos);\n        pos--; // convert to 0-based index\n\n        s[pos] = (s[pos] == '(') ? ')' : '(';\n\n        top = -1;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') {\n                stack[++top] = i;\n            } else {\n                if (top >= 0 && s[stack[top]] == '(') {\n                    top--;\n                } else {\n                    stack[++top] = i;\n                }\n            }\n        }\n\n        if (top == -1) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", stack[0] + 1); // convert to 1-based index\n        }\n    }\n\n    free(stack);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:54:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, q;\n    string s;\n    cin >> n >> q >> s;\n    set<int> open, close;\n    stack<int> st;\n    vector<int> match(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty()) {\n                match[i] = st.top();\n                match[st.top()] = i;\n                st.pop();\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            open.insert(i);\n        } else {\n            close.insert(i);\n        }\n    }\n\n    while (q--) {\n        int pos;\n        cin >> pos;\n        pos--;\n\n        if (s[pos] == '(') {\n            s[pos] = ')';\n            open.erase(pos);\n            close.insert(pos);\n        } else {\n            s[pos] = '(';\n            close.erase(pos);\n            open.insert(pos);\n        }\n\n        if (s[pos] == '(') {\n            int matched = match[pos];\n            if (matched != -1 && s[matched] == ')') {\n                cout << pos + 1 << \"\\n\";\n                s[pos] = ')';\n                s[matched] = '(';\n                open.erase(pos);\n                close.erase(matched);\n                open.insert(matched);\n                close.insert(pos);\n                match[pos] = -1;\n                match[matched] = -1;\n                continue;\n            }\n        } else {\n            int matched = match[pos];\n            if (matched != -1 && s[matched] == '(') {\n                cout << pos + 1 << \"\\n\";\n                s[pos] = '(';\n                s[matched] = ')';\n                close.erase(pos);\n                open.erase(matched);\n                close.insert(matched);\n                open.insert(pos);\n                match[pos] = -1;\n                match[matched] = -1;\n                continue;\n            }\n        }\n\n        if (open.empty() || close.empty()) {\n            cout << pos + 1 << \"\\n\";\n            continue;\n        }\n\n        int first_open = *open.begin();\n        int last_close = *prev(close.end());\n\n        if (first_open > last_close) {\n            cout << first_open + 1 << \"\\n\";\n            s[first_open] = ')';\n            s[last_close] = '(';\n            open.erase(first_open);\n            close.erase(last_close);\n            open.insert(last_close);\n            close.insert(first_open);\n            match[first_open] = -1;\n            match[last_close] = -1;\n        } else {\n            cout << first_open + 1 << \"\\n\";\n            int matched = match[first_open];\n            if (matched != -1) {\n                s[matched] = '(';\n                close.erase(matched);\n                open.insert(matched);\n                match[first_open] = -1;\n                match[matched] = -1;\n            }\n            s[first_open] = ')';\n            open.erase(first_open);\n            close.insert(first_open);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:55:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BalancedParentheses {\n    private int[] tree;\n    private int n;\n    private char[] arr;\n\n    public BalancedParentheses(String s) {\n        n = s.length();\n        arr = s.toCharArray();\n        tree = new int[4 * n];\n        build(0, 0, n - 1);\n    }\n\n    private void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = (arr[start] == '(') ? 1 : -1;\n        } else {\n            int mid = (start + end) / 2;\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    private void update(int node, int start, int end, int idx) {\n        if (start == end) {\n            arr[idx] = (arr[idx] == '(') ? ')' : '(';\n            tree[node] = (arr[idx] == '(') ? 1 : -1;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx);\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    private int query(int node, int start, int end, int sum) {\n        if (start == end) {\n            return start;\n        }\n        int mid = (start + end) / 2;\n        if (tree[2 * node + 1] < sum) {\n            return query(2 * node + 1, start, mid, sum);\n        } else {\n            return query(2 * node + 2, mid + 1, end, sum - tree[2 * node + 1]);\n        }\n    }\n\n    public int flip(int idx) {\n        update(0, 0, n - 1, idx);\n        if (tree[0] == 0) {\n            return -1;\n        }\n        int sum = (tree[0] < 0) ? tree[0] / 2 : (tree[0] + 1) / 2;\n        return query(0, 0, n - 1, sum);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n        BalancedParentheses bp = new BalancedParentheses(s);\n        int q = scanner.nextInt();\n        for (int i = 0; i < q; i++) {\n            int idx = scanner.nextInt();\n            System.out.println(bp.flip(idx));\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 20:56:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int[] getLeftmostFlipPositions(String s, int[] queries) {\n        int n = s.length();\n        int[] result = new int[queries.length];\n        \n        for (int i = 0; i < queries.length; i++) {\n            char[] chars = s.toCharArray();\n            int pos = queries[i];\n            \n            chars[pos] = (chars[pos] == '(') ? ')' : '(';\n            \n            result[i] = findLeftmostFlip(chars);\n        }\n        \n        return result;\n    }\n    \n    private int findLeftmostFlip(char[] chars) {\n        int openCount = 0;\n        int leftmostFlip = -1;\n        \n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == '(') {\n                openCount++;\n            } else {\n                openCount--;\n            }\n            \n            if (openCount < 0) {\n                leftmostFlip = findRebalancingPosition(chars, i);\n                break;\n            }\n        }\n        \n        return leftmostFlip;\n    }\n    \n    private int findRebalancingPosition(char[] chars, int start) {\n        int openCount = 0;\n        \n        for (int i = start; i >= 0; i--) {\n            if (chars[i] == '(') {\n                openCount++;\n            } else {\n                openCount--;\n            }\n            \n            if (openCount > 0) {\n                return i;\n            }\n        }\n        \n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 20:56:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint findLeftmostFlip(char* s, int flippedPos) {\n    int len = strlen(s);\n    int open = 0, close = 0;\n    \n    // Determine original direction of flipped parenthesis\n    int isOpenToClose = (s[flippedPos] == '(');\n    \n    // First pass: count unbalanced parentheses\n    for (int i = 0; i < len; i++) {\n        if (i == flippedPos) {\n            // Consider the flipped position\n            if (isOpenToClose) {\n                close++;\n            } else {\n                open++;\n            }\n        } else {\n            if (s[i] == '(') open++;\n            else close++;\n        }\n        \n        // If at any point close > open, we need to flip\n        if (close > open) {\n            // Scan backwards to find leftmost position to flip\n            for (int j = i; j >= 0; j--) {\n                if (j == flippedPos) continue;\n                \n                if (isOpenToClose && s[j] == ')') return j;\n                if (!isOpenToClose && s[j] == '(') return j;\n            }\n        }\n    }\n    \n    return -1; // Should not happen for balanced input\n}\n\nint main() {\n    // Example usage\n    char s[] = \"()()()\";\n    int queries[] = {1, 3};\n    \n    for (int i = 0; i < sizeof(queries)/sizeof(queries[0]); i++) {\n        int result = findLeftmostFlip(s, queries[i]);\n        printf(\"Leftmost flip position for query %d: %d\\n\", queries[i], result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    vector<int> getLeftmostFlipPositions(string s, vector<vector<int>>& queries) {\n        int n = s.length();\n        vector<int> result;\n        \n        for (auto& query : queries) {\n            int pos = query[0];\n            char newChar = query[1] == 0 ? '(' : ')';\n            s[pos] = newChar;\n            \n            int leftmostFlip = findLeftmostFlip(s);\n            result.push_back(leftmostFlip);\n        }\n        \n        return result;\n    }\n    \nprivate:\n    int findLeftmostFlip(string& s) {\n        int n = s.length();\n        stack<int> st;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') {\n                st.push(i);\n            } else {\n                if (st.empty()) {\n                    return i;\n                }\n                st.pop();\n            }\n        }\n        \n        return st.empty() ? -1 : st.top();\n    }\n};",
    "timestamp": "2025-08-05 20:56:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class BalancedParentheses:\n    def __init__(self, s):\n        self.s = list(s)\n        self.n = len(s)\n        self.open = [0] * self.n\n        self.close = [0] * self.n\n        self.preprocess()\n\n    def preprocess(self):\n        balance = 0\n        for i in range(self.n):\n            if self.s[i] == '(':\n                balance += 1\n            else:\n                balance -= 1\n            self.open[i] = balance\n\n        balance = 0\n        for i in range(self.n - 1, -1, -1):\n            if self.s[i] == ')':\n                balance += 1\n            else:\n                balance -= 1\n            self.close[i] = balance\n\n    def flip_and_fix(self, index):\n        if self.s[index] == '(':\n            self.s[index] = ')'\n        else:\n            self.s[index] = '('\n\n        self.preprocess()\n\n        balance = 0\n        for i in range(self.n):\n            if self.s[i] == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return i + 1\n\n        balance = 0\n        for i in range(self.n - 1, -1, -1):\n            if self.s[i] == ')':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return i + 1\n\n    def query(self, index):\n        return self.flip_and_fix(index - 1)\n\n\n# Example Usage:\nbp = BalancedParentheses(\"(()())\")\nprint(bp.query(1))  # Each query is a 1-based index\nprint(bp.query(3))",
    "timestamp": "2025-08-13 04:06:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BalancedParentheses {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        int q = scanner.nextInt();\n        int[] queries = new int[q];\n        for(int i = 0; i < q; i++) {\n            queries[i] = scanner.nextInt() - 1;\n        }\n        \n        List<Integer> leftPositions = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n        \n        for(int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if(c == '(') {\n                stack.push(i);\n            } else {\n                if(!stack.isEmpty()) stack.pop();\n                else leftPositions.add(i);\n            }\n        }\n        \n        while(!stack.isEmpty()) {\n            leftPositions.add(stack.pop());\n        }\n\n        for(int flipIndex : queries) {\n            if(s.charAt(flipIndex) == '(') {\n                leftPositions.remove((Integer)flipIndex);\n            } else {\n                int pos = Collections.binarySearch(leftPositions, flipIndex);\n                if(pos < 0) pos = -pos - 1;\n                leftPositions.add(pos, flipIndex);\n            }\n            \n            System.out.println(leftPositions.isEmpty() ? 0 : leftPositions.get(0) + 1);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 04:06:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    char s[n + 1];\n    scanf(\"%s\", s);\n    \n    int balance = 0, minBalance = 0, minPos = -1;\n    int position[n];\n    \n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') balance++;\n        else balance--;\n        \n        if (balance < minBalance) {\n            minBalance = balance;\n            minPos = i;\n        }\n        position[i] = minPos;\n    }\n    \n    for (int query = 0; query < q; ++query) {\n        int flipIndex;\n        scanf(\"%d\", &flipIndex);\n        flipIndex--; // Assuming 1-based index input\n        \n        // Flip the parenthesis\n        if (s[flipIndex] == '(') s[flipIndex] = ')';\n        else s[flipIndex] = '(';\n        \n        // Reset the balancing variables\n        balance = 0;\n        minBalance = 0;\n        minPos = -1;\n        \n        // Re-calculate positions after flip\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '(') balance++;\n            else balance--;\n            \n            if (balance < minBalance) {\n                minBalance = balance;\n                minPos = i;\n            }\n            position[i] = minPos;\n        }\n        \n        // Output the result for the current query\n        if (balance == 0) {\n            printf(\"%d\\n\", position[n - 1] + 1);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 04:06:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_flip_position(s):\n    n = len(s)\n    open_count = 0\n    close_count = 0\n    \n    for char in s:\n        if char == '(':\n            open_count += 1\n        else:\n            close_count += 1\n    \n    if open_count != close_count:\n        return -1\n    \n    def is_balanced(string):\n        balance = 0\n        for char in string:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    def solve(string, flipped_index):\n        for i in range(flipped_index, -1, -1):\n            new_string = list(string)\n            new_string[i] = '(' if new_string[i] == ')' else ')'\n            \n            if is_balanced(new_string):\n                return i\n        \n        for i in range(flipped_index + 1, len(string)):\n            new_string = list(string)\n            new_string[i] = '(' if new_string[i] == ')' else ')'\n            \n            if is_balanced(new_string):\n                return i\n        \n        return -1\n    \n    return solve\n\ndef process_queries(s, queries):\n    flip_finder = find_flip_position(s)\n    result = []\n    \n    for query in queries:\n        result.append(flip_finder(s, query))\n    \n    return result",
    "timestamp": "2025-08-13 04:06:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    s = list(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    queries = list(map(int, input[ptr:ptr+q]))\n    \n    # Precompute the balance and track positions\n    balance = 0\n    stack = []\n    positions = []\n    for i, char in enumerate(s):\n        if char == '(':\n            balance += 1\n            stack.append(i)\n        else:\n            balance -= 1\n            if stack:\n                stack.pop()\n        positions.append(balance)\n    \n    # Process each query\n    for query in queries:\n        pos = query - 1  # convert to 0-based\n        # Flip the parenthesis\n        if s[pos] == '(':\n            s[pos] = ')'\n            # Update balance and stack\n            # Need to find the first unmatched ')'\n            # The balance after flipping is reduced by 2\n            # So we look for the first position where balance becomes negative\n            # But we can simulate the balance changes\n            balance = 0\n            res = -1\n            for i in range(len(s)):\n                if s[i] == '(':\n                    balance += 1\n                else:\n                    balance -= 1\n                if balance < 0:\n                    res = i + 1  # 1-based\n                    break\n            if res == -1:\n                # No negative balance, find the last '('\n                res = len(s)\n            print(res)\n            # Flip back to original for next query (since each query is independent)\n            s[pos] = '('\n        else:\n            s[pos] = '('\n            # Update balance and stack\n            # Need to find the first unmatched '('\n            # The balance after flipping is increased by 2\n            # So we look for the last '(' that can be matched\n            # But we can simulate the balance changes\n            balance = 0\n            stack = []\n            res = -1\n            for i in range(len(s)):\n                if s[i] == '(':\n                    balance += 1\n                    stack.append(i)\n                else:\n                    balance -= 1\n                    if stack:\n                        stack.pop()\n            if balance == 0:\n                # No unmatched '(', so flip the last '('\n                res = len(s)\n            else:\n                # The first unmatched '(' is stack[0]\n                res = stack[0] + 1\n            print(res)\n            # Flip back to original for next query\n            s[pos] = ')'\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 04:07:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass BalancedParentheses {\nprivate:\n    string s;\n    vector<int> imbalance;\n\npublic:\n    BalancedParentheses(string str) : s(str) {\n        int n = s.length();\n        imbalance.resize(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            imbalance[i + 1] = imbalance[i] + (s[i] == '(' ? 1 : -1);\n        }\n    }\n\n    void flip(int idx) {\n        s[idx] = (s[idx] == '(') ? ')' : '(';\n        int n = s.length();\n        for (int i = idx; i < n; ++i) {\n            imbalance[i + 1] = imbalance[i] + (s[i] == '(' ? 1 : -1);\n        }\n    }\n\n    int findFixPosition() {\n        int n = s.length();\n        for (int i = 0; i <= n; ++i) {\n            if (imbalance[i] < 0) {\n                return -1;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (imbalance[i] == imbalance[n]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    string s;\n    int q;\n    cin >> s >> q;\n    BalancedParentheses bp(s);\n    while (q--) {\n        int idx;\n        cin >> idx;\n        bp.flip(idx);\n        cout << bp.findFixPosition() << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:14"
  }
]