[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\n#define AHOSIZE 26\n\nconst int mod = 1000000007;\nint N,M,K;\nvector<int> dict[500];\nstring from[250], to[250];\nint ahosize;\nchar memo[1000]; // ahoid\n\nstruct Aho{\n    bool accept;\n    int id;\n    Aho *next[AHOSIZE], *fail;\n\n    Aho(){\n        int i;\n        fail = NULL;\n        accept = false;\n        id = ahosize; //\n        ahosize++; //\n        rep(i,AHOSIZE) next[i] = NULL;\n    }\n    ~Aho(){\n        int i;\n        rep(i,AHOSIZE) if( next[i] ) delete next[i];\n    }\n\n    void insert(const string& in){\n        int i,n = in.length();\n        Aho *now = this;\n\n        rep(i,n){\n            if( now->next[in[i]-'a'] == NULL ){\n                now->next[in[i]-'a'] = new Aho();\n            }\n            now = now->next[in[i]-'a'];\n        }\n        now->accept = true;\n    }\n\n    // failツづーツ催ャツづゥ\n    void build(){\n        int i;\n        queue<Aho*> q;\n        q.push(this);\n        \n        while( !q.empty() ){\n            Aho *now = q.front();\n            q.pop();\n            \n            rep(i,AHOSIZE) if( now->next[i] ) {\n                q.push(now->next[i]);\n\n                Aho *r = now->fail;\n                while( r != NULL && r->next[i] == NULL ) r = r->fail;\n                if( r != NULL ){\n                    now->next[i]->fail = r->next[i];\n                }\n                else{\n                    now->next[i]->fail = this;\n                }\n            }\n        }\n    }\n\n    Aho* match(Aho* root, const string& in, int* hit){\n        int i, n = in.length();\n        Aho *now = root;\n        \n        rep(i,n){\n            if( now->next[in[i]-'a'] ){\n                now = now->next[in[i]-'a'];\n            }\n            else{\n                while( now != this ){\n                    now = now->fail;\n                    if( now->next[in[i]-'a'] ){\n                        now = now->next[in[i]-'a'];\n                        break;\n                    }\n                }\n            }\n            \n            // ツつアツつアツづ個渉按猟敖づ債δδつ可サツつキツづゥツつアツづづ債つ堕ャツ可サツづつォツづゥ\n            Aho* tmp = now;\n            \n            // ツ全ツ探ツ催オ\n            /*\n            while( tmp != this ){\n                if( tmp->accept ) ++*hit;\n                if( *hit >= 2 ) return NULL;\n                tmp = tmp->fail;\n            }\n            */\n\n            // ツδδつ可サ\n            int cc = 0;\n            if( memo[now->id] != -1 ){\n                cc = memo[now->id];\n            }\n            else{\n                while( tmp != this ){\n                    if( memo[tmp->id] != -1 ){\n                        cc += memo[tmp->id];\n                        break;\n                    }\n                    else{\n                        if( tmp->accept ) cc++;\n                    }\n                    tmp = tmp->fail;\n                }\n                memo[now->id] = cc;\n            }\n            *hit += cc;\n            if( *hit >= 2 ) return NULL;\n        }\n\n        return now;\n    }\n\n};\n\n\nstruct state{\n    int from,cnt;\n    Aho* node;\n    state(int f, int c, Aho *n){\n        from = f, cnt = c, node = n;\n    }\n    bool operator<(const state& a)const{\n        if( cnt != a.cnt ) return cnt < a.cnt;\n        if( node != a.node ) return node < a.node;\n        return from < a.from;\n    }\n};\n\nmap<state,int> dp[550];\n\nint main(){\n    int i,j;\n\n    while( cin >> N >> M >> K, N|M|K ){\n        // init\n        rep(i,550) dp[i].clear();\n        rep(i,500) dict[i].clear();\n        memset(memo, -1, sizeof(memo));\n        ahosize = 0;\n\n\n        Aho Ahoinit;\n        set<string> ss;\n\n\n        // dict[from is new index][ツ古つ青脳 = to is new index \n\n        // input\n        rep(i,N){\n            cin >> from[i] >> to[i];\n            ss.insert(from[i]);\n            ss.insert(to[i]);\n        }\n\n        //\n        vector<string> words(ss.begin(), ss.end());\n        rep(i,words.size()){\n            rep(j,N) if( words[i] == from[j] ) {\n                dict[i].push_back(lower_bound(all(words), to[j]) - words.begin());\n            }\n        }\n\n        rep(i,K){\n            string kigo; cin >> kigo;\n            Ahoinit.insert(kigo);\n        }\n        Ahoinit.build();\n\n        // start\n        rep(i,words.size()){\n            int cnt = 0;\n            Aho* next = Ahoinit.match(&Ahoinit, words[i], &cnt);\n            if( cnt < 2 ){\n                dp[words[i].length()][state(i,cnt,next)] = 1;\n            }\n        }\n        \n        rep(j,M){\n            foreach(it,dp[j]){\n                int f_id = it->first.from;\n                int cnt = it->first.cnt;\n                Aho *now = it->first.node;\n                int res = it->second;\n\n                rep(i,dict[f_id].size()){\n                    int t_id = dict[f_id][i];\n                    int n = words[t_id].length();\n                    if( j + n > M ) continue;\n\n                    int tcnt = cnt;\n                    Aho *next = Ahoinit.match(now, words[t_id], &tcnt);\n                    if( tcnt < 2 && next != NULL ){\n                        dp[j + n][state(t_id, tcnt, next)] += res;\n                        dp[j + n][state(t_id, tcnt, next)] %= mod;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        foreach(it,dp[M]) if( it->first.cnt == 1 ) {\n            ans += it->second;\n            ans %= mod;\n        }\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  TrieNode() : exist(0), accept(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 250;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    continue;\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][450][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n/*\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  //  rep(i,ini.size()){\n  //int id=ini[i];\n  rep(i,all.size()){\n    int id=i;\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t      int nextlen=i+all[readword].size();\n\t      int nextn=readword;\n\t      int nextpma=move[l][readword];\n\t      int nextac=m+ac[l][readword];\n\t      if (nextlen > len ||nextpma == -1)continue;\n\t      if (nextac >= 2)continue;\n\t      nextlen%=MOD;\n\t      dp[nextlen][nextn][nextpma][nextac]=\n\t\t(dp[nextlen][nextn][nextpma][nextac]+\n\t\t dp[i%MOD][j][l][m])%mod;\n\t    }\n\t  }\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n*/\n\nclass st{\npublic:\n  int n,p,ac;\n  bool operator<(const st & a)const{\n    if (n != a.n)return n < a.n;\n    if (p != a.p)return p < a.p;\n    return ac < a.ac;\n  }\n};\n\nconst int MOD=21;\nmap<st,int> dp[MOD];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  //rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,MOD)dp[i].clear();\n  //  rep(i,ini.size()){\n  //int id=ini[i];\n  rep(i,all.size()){\n    int id=i;\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      //dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n      dp[size%mod][(st){id,move[ROOT][id],ac[ROOT][id]}]=1;\n    }\n  }\n  rep(i,len){\n    map<st,int>::iterator itr = dp[i%MOD].begin();\n    //    rep(j,n){\n    while(itr != dp[i%MOD].end()){\n      int j=(*itr).first.n,l=(*itr).first.p,m=(*itr).first.ac;\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\tint nextlen=i+all[readword].size();\n\tint nextn=readword;\n\tint nextpma=move[l][readword];\n\tint nextac=m+ac[l][readword];\n\tif (nextlen > len ||nextpma == -1)continue;\n\tif (nextac >= 2)continue;\n\tnextlen%=MOD;\n\tint tmp=dp[nextlen][(st){nextn,nextpma,nextac}];\n\tdp[nextlen][(st){nextn,nextpma,nextac}]=\n\t  (tmp+\n\t   (*itr).second)%mod;\n\t/*\n\tdp[nextlen][nextn][nextpma][nextac]=\n\t  (dp[nextlen][nextn][nextpma][nextac]+\n\t   dp[i%MOD][j][l][m])%mod;\n\t*/\n      }\n      itr++;\n    }\n    //rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n    dp[i%MOD].clear();\n  }\n  int ret=0;\n  //rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  map<st,int>::iterator itr = dp[len%MOD].begin();\n  while(itr != dp[len%MOD].end()){\n    if ((*itr).first.ac == 1)ret=(ret+(*itr).second)%mod;\n    itr++;\n  }\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[128];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nint dp[30][500][500][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%30][w][x][res+t]+=dp[pos%30][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%30][0][0],dp[pos%30][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%30][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct PMA{\n\tPMA *next[0x100];\n\tvector<int> accept;\n};\nint sz;\nPMA pma[1000];\nPMA *mynew(){\n\trep(i, 256) pma[sz].next[i] = 0;\n\tpma[sz].accept.clear();\n\treturn pma + sz++;\n}\nPMA *buildPMA(const vector<string> &p) {\n\tPMA *root = mynew();\n\trep(i, p.size()){\n\t\tPMA *t = root;\n\t\trep(j, p[i].size()){\n\t\t\tchar c = p[i][j];\n\t\t\tif(t->next[c] == NULL) t->next[c] = mynew();\n\t\t\tt = t->next[c];\n\t\t}\n\t\tt->accept.pb(i);\n\t}\n\tqueue<PMA*> Q;\n\tfor(char c = 'A'; c <= 'z'; c++){\n\t\tif (root->next[c]) {\n\t\t\troot->next[c]->next[0] = root;\n\t\t\tQ.push(root->next[c]);\n\t\t}\n\t\telse root->next[c] = root;\n\t}\n\twhile(!Q.empty()){\n\t\tPMA *t = Q.front();\n\t\tQ.pop();\n\t\tfor(char c = 'A'; c <= 'z'; c++){\n\t\t\tif(t->next[c]){\n\t\t\t\tQ.push(t->next[c]);\n\t\t\t\tPMA *r = t->next[0];\n\t\t\t\twhile(!r->next[c]) r = r->next[0];\n\t\t\t\tt->next[c]->next[0] = r->next[c];\n\t\t\t\teach(i, r->next[c]->accept) t->next[c]->accept.pb(*i);\n\t\t\t}\n\t\t}\n\t}\n\treturn root;\n}\n\nconst int mod = (int)1e9 + 7;\nint n, m, k, N, dp[22][500][700][2]; //文字数, prev, state, match\nvector<vi> e;\nstring a[300], b[300];\nvector<string> c;\nvector<string> v;\npi memo[700][500];\npi next(PMA *p, int s) {\n\tpi &res = memo[p - pma][s];\n\tif(res.second >= 0) return res;\n\tint count = 0;\n\trep(i, v[s].size()){\n\t\tchar c = v[s][i];\n\t\twhile (!p->next[c]) p = p->next[0];\n\t\tp = p->next[c];\n\t\trep(j, p->accept.size()) count++;\n\t}\n\treturn res = mp(p - pma, count);\n}\n\nint main(){\n\twhile(cin >> n >> m >> k, n){\n\t\tv.clear();\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> a[i] >> b[i], v.pb(a[i]), v.pb(b[i]);\n\t\tsort(all(v));\n\t\tv.erase(unique(all(v)), v.end());\n\t\t\n\t\te.clear(); e.resize(v.size());\n\t\trep(i, n){\n\t\t\tint p = lower_bound(all(v), a[i]) - v.begin();\n\t\t\tint q = lower_bound(all(v), b[i]) - v.begin();\n\t\t\te[p].pb(q);\n\t\t}\n\t\tc.clear(); c.resize(k);\n\t\trep(i, k) cin >> c[i];\n\t\tsz = 0;\n\t\tPMA* r = buildPMA(c);\n\t\t\n\t\trep(i, sz) rep(j, v.size()) memo[i][j].second = -1;\n\t\t\n\t\trep(i, v.size()){\n\t\t\tpi x = next(r, i);\n\t\t\t//cerr<<v[i]<<\" \"<<x.first<<\" \"<<x.second<<endl;\n\t\t\tif(v[i].size() < m && x.second < 2) dp[v[i].size() % 22][i][x.first][x.second] = 1;\n\t\t}\n\t\trep(i, m){\n\t\t\tmemset(dp[(i + 21) % 22], 0, sizeof(dp[0]));\n\t\t\trep(j, v.size()) rep(k, sz) rep(l, 2) if(dp[i % 22][j][k][l]){\n\t\t\t\t//cerr<<i<<\" \"<<v[j]<<\" \"<<k<<\" \"<<l<<endl;\n\t\t\t\trep(h, e[j].size()){\n\t\t\t\t\tpi x = next(pma + k, e[j][h]);\n\t\t\t\t\tint ni = v[e[j][h]].size() + i;\n\t\t\t\t\tif(ni <= m && x.second + l < 2)\n\t\t\t\t\t(dp[ni % 22][e[j][h]][x.first][x.second + l] += dp[i % 22][j][k][l]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\trep(i, v.size()) rep(j, sz) (res += dp[m % 22][i][j][1]) %= mod;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\nlong long mod=1000000007;\nchar in[30];\nstring table[600];\nvector<int>g[600];\nstruct wolf{\n\tint chi[26];\n\tint mark;\n\tint par;\n\tint fail;\n\tint var;\n\twolf(){\n\t\tfor(int i=0;i<26;i++)chi[i]=-1;mark=0;\n\t\tpar=fail=var=-1;\n\t}\n};\nwolf node[700];\nint ns;\nvoid add(){\n\tint at=0;\n\tfor(int i=0;in[i];i++){\n\t\tif(node[at].chi[in[i]-'a']==-1){\n\t\t\tnode[at].chi[in[i]-'a']=ns;\n\t\t\tnode[ns].par=at;\n\t\t\tnode[ns].var=in[i]-'a';\n\t\t\tat=ns++;\n\t\t}else{\n\t\t\tat=node[at].chi[in[i]-'a'];\n\t\t}\n\t}\n\tnode[at].mark++;\n}\nint n;\nvector<int>dp[2][520][520];\nint conv[520][700];\nint cs[520];\nint calc(int a,int b,int c,int d){\n//\tif(c&&conv[b][c]==0)printf(\"%d %d %d\\n\",b,c,conv[b][c]);\n\tif(~dp[d][a][b][conv[b][c]])return dp[d][a][b][conv[b][c]];\n\tif(a==n){\n\t\tif(d==1)return 1;\n\t\telse return 0;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<g[b].size();i++){\n\t\tint to=c;\n\t\tint cnt=d;\n\t\tint use=g[b][i];\n\t\tif(a+table[use].size()>n)continue;\n\t\tfor(int j=0;j<table[use].size();j++){\n\t\t\twhile(1){\n\t\t\t\tif(node[to].chi[table[use][j]-'a']!=-1){\n\t\t\t\t\tto=node[to].chi[table[use][j]-'a'];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(to==0)break;\n\t\t\t\tto=node[to].fail;\n\t\t\t}\n\t\t\tcnt+=node[to].mark;\n\t\t}\n\t\tif(cnt>1)continue;\n\t\tret=(ret+calc(a+table[use].size(),use,to,cnt))%mod;\n\t}\n\t//if(ret)printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[d][a][b][conv[b][c]]=ret;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=b;\n\t\tmap<string,int> word;\n\t\tfor(int i=0;i<600;i++)g[i].clear();\n\t\tfor(int k=0;k<2;k++)for(int i=0;i<520;i++)for(int j=0;j<520;j++)dp[k][i][j].clear();\n\t\tfor(int i=0;i<520;i++)cs[i]=0;\n\t\tint sz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint P,Q2;\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring p=in;\n\t\t\tif(word.count(p))P=word[p];\n\t\t\telse{\n\t\t\t\tword[p]=sz;\n\t\t\t\ttable[sz]=p;\n\t\t\t\tP=sz++;\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring q=in;\n\t\t\tif(word.count(q))Q2=word[q];\n\t\t\telse{\n\t\t\t\tword[q]=sz;\n\t\t\t\ttable[sz]=q;\n\t\t\t\tQ2=sz++;\n\t\t\t}\n\t\t\tg[P].push_back(Q2);\n\t\t}\n\t\tfor(int i=0;i<600;i++)node[i]=wolf();\n\t\tns=1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tadd();\n\t\t}\n\t\tqueue<int>Q;\n\t\tQ.push(0);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tif(at==0||node[at].par==0)node[at].fail=0;\n\t\t\telse{\n\t\t\t\tint to=node[at].par;\n\t\t\t\twhile(1){\n\t\t\t\t\tint tmp=node[to].fail;\n\t\t\t\t\tif(node[tmp].chi[node[at].var]!=-1){\n\t\t\t\t\t\tnode[at].fail=node[tmp].chi[node[at].var];\n\t\t\t\t\t\tnode[at].mark+=node[node[at].fail].mark;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tto=tmp;\n\t\t\t\t\tif(to==0){node[at].fail=0;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<26;i++)if(node[at].chi[i]!=-1){\n\t\t\t\tQ.push(node[at].chi[i]);\n\t\t\t}\n\t\t}\n\t//\tprintf(\"%d\\n\",ns);\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<ns;j++){\n\t\t\t\tbool ok=true;\n\t\t\t\tint at=j;\n\t\t\t\tint in=table[i].size()-1;\n\t\t\t\twhile(at&&in>=0){\n\t\t\t\t\tif(node[at].var!=table[i][in]-'a'){ok=false;break;}\n\t\t\t\t\tat=node[at].par;\n\t\t\t\t\tin--;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tconv[i][j]=cs[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<sz;i++)printf(\"%d\\n\",cs[i]);\n\t\tconv[sz][0]=0;cs[sz]=1;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=b;j++)for(int k=0;k<=sz;k++){\n\t\t\tdp[i][j][k]=vector<int>(cs[k],-1);\n\t\t}\n\t\tfor(int i=0;i<sz;i++)g[sz].push_back(i);\n\t\tint ret=calc(0,sz,0,0);\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nint wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,ps){\n\t\t\t\trep(k,ws){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],a[i%21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) rep(k,ws) a[i%21][j][k]=b[i%21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 601;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    if (readword > all.size())continue;\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nmap< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\nnamespace libcomp {\nnamespace string {\n\n\nclass AhoCorasick {\n\nprivate:\n\tstruct State {\n\t\tint next[256];\n\t\tint failure;\n\t\tvector<int> accept;\n\t\tState() : failure(0), accept() { fill(next, next + 256, -1); }\n\t};\n\n\tvector<State> m_states;\n\n\tint get_next(int i, int j) const {\n\t\tif(m_states[i].next[j] >= 0){\n\t\t\treturn m_states[i].next[j];\n\t\t}else if(i == 0){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\npublic:\n\tAhoCorasick(const vector<std::string> &patterns) : m_states() {\n\t\tvector<State> &ss = m_states;\n\t\tss.push_back(State());\n\t\t// Make trie\n\t\tfor(size_t i = 0; i < patterns.size(); ++i){\n\t\t\tconst std::string &s = patterns[i];\n\t\t\tint cur = 0;\n\t\t\tfor(size_t j = 0; j < s.size(); ++j){\n\t\t\t\tconst unsigned char c = s[j];\n\t\t\t\tif(ss[cur].next[c] < 0){\n\t\t\t\t\tss[cur].next[c] = static_cast<int>(ss.size());\n\t\t\t\t\tss.push_back(State());\n\t\t\t\t}\n\t\t\t\tcur = ss[cur].next[c];\n\t\t\t}\n\t\t\tss[cur].accept.push_back(static_cast<int>(i));\n\t\t}\n\t\t// Make failure paths\n\t\tqueue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int s = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < 256; ++i){\n\t\t\t\tif(ss[s].next[i] < 0){ continue; }\n\t\t\t\tconst int next = get_next(s, i);\n\t\t\t\tif(next >= 0){ q.push(next); }\n\t\t\t\tif(s != 0){\n\t\t\t\t\tint f = ss[s].failure;\n\t\t\t\t\twhile(get_next(f, i) < 0){ f = ss[f].failure; }\n\t\t\t\t\tconst int failure = get_next(f, i);\n\t\t\t\t\tss[next].failure = failure;\n\t\t\t\t\tconst vector<int> &acc = ss[failure].accept;\n\t\t\t\t\tcopy(\n\t\t\t\t\t\tacc.begin(), acc.end(),\n\t\t\t\t\t\tback_inserter(ss[next].accept));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint match(\n\t\tconst std::string &s, vector<int> &counters, int state = 0) const\n\t{\n\t\tconst vector<State> &ss = m_states;\n\t\tfor(size_t i = 0; i < s.size(); ++i){\n\t\t\tconst unsigned char c = s[i];\n\t\t\twhile(get_next(state, c) < 0){ state = ss[state].failure; }\n\t\t\tstate = get_next(state, c);\n\t\t\tfor(size_t j = 0; j < ss[state].accept.size(); ++j){\n\t\t\t\t++counters[ss[state].accept[j]];\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}\n\n\tsize_t size() const { return m_states.size(); }\n\n};\n\n\n}\n}\n\n\nconst int MOD = 1000000007;\n\nmap<int, int> dp[21][501][2];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint N, M, K;\n\t\tcin >> N >> M >> K;\n\t\tif(N == 0 && M == 0 && K == 0){ break; }\n\t\tvector<int> next_words[501];\n\t\tmap<string, int> word_map;\n\t\tvector<string> words(1);\n\t\tword_map.insert(pair<string, int>(\"\", 0));\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tint from_index = 0, to_index = 0;\n\t\t\tif(word_map.find(from) != word_map.end()){\n\t\t\t\tfrom_index = word_map[from];\n\t\t\t}else{\n\t\t\t\tfrom_index = word_map.size();\n\t\t\t\tword_map[from] = from_index;\n\t\t\t\twords.push_back(from);\n\t\t\t\tnext_words[0].push_back(from_index);\n\t\t\t}\n\t\t\tif(word_map.find(to) != word_map.end()){\n\t\t\t\tto_index = word_map[to];\n\t\t\t}else{\n\t\t\t\tto_index = word_map.size();\n\t\t\t\tword_map[to] = to_index;\n\t\t\t\twords.push_back(to);\n\t\t\t\tnext_words[0].push_back(to_index);\n\t\t\t}\n\t\t\tnext_words[from_index].push_back(to_index);\n\t\t}\n\t\tvector<string> season_words(K);\n\t\tfor(int i = 0; i < K; ++i){ cin >> season_words[i]; }\n\t\tlibcomp::string::AhoCorasick ac(season_words);\n\t\tint state_num = ac.size();\n\t\tfor(int i = 0; i < 21; ++i){\n\t\t\tfor(int j = 0; j < 501; ++j){\n\t\t\t\tfor(int k = 0; k < 2; ++k){ dp[i][j][k].clear(); }\n\t\t\t}\n\t\t}\n\t\tdp[0][0][0][0] = 1;\n\t\tvector<int> result(K);\n\t\tfor(int i = 0; i < M; ++i){\n\t\t\tfor(int j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\tfor(\n\t\t\t\t\t\tmap<int, int>::iterator it = dp[i % 21][j][k].begin();\n\t\t\t\t\t\tit != dp[i % 21][j][k].end(); ++it)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int n = 0; n < next_words[j].size(); ++n){\n\t\t\t\t\t\t\tint next = next_words[j][n];\n\t\t\t\t\t\t\tstring &word = words[next];\n\t\t\t\t\t\t\tif(i + word.size() > M){ continue; }\n\t\t\t\t\t\t\tfill(result.begin(), result.end(), 0);\n\t\t\t\t\t\t\tint s = ac.match(word, result, it->first);\n\t\t\t\t\t\t\tint m = k + accumulate(result.begin(), result.end(), 0);\n\t\t\t\t\t\t\tif(m >= 2){ continue; }\n\t\t\t\t\t\t\tdp[(i + word.size()) % 21][next][m][s] += it->second;\n\t\t\t\t\t\t\tdp[(i + word.size()) % 21][next][m][s] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][k].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < words.size(); ++i){\n\t\t\tfor(int j = 0; j < state_num; ++j){\n\t\t\t\tanswer += dp[M % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[21][450][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i % 21][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[(i + nums[t].size()) % 21][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i % 21][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M % 21][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i < 21; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct PMA{\n\tPMA *next[0x100];\n\tvector<int> accept;\n};\nint sz;\nPMA pma[1000];\nPMA *mynew(){\n\trep(i, 256) pma[sz].next[i] = 0;\n\tpma[sz].accept.clear();\n\treturn pma + sz++;\n}\nPMA *buildPMA(const vector<string> &p) {\n\tPMA *root = mynew();\n\trep(i, p.size()){\n\t\tPMA *t = root;\n\t\trep(j, p[i].size()){\n\t\t\tchar c = p[i][j];\n\t\t\tif(t->next[c] == NULL) t->next[c] = mynew();\n\t\t\tt = t->next[c];\n\t\t}\n\t\tt->accept.pb(i);\n\t}\n\tqueue<PMA*> Q;\n\tfor(char c = 'A'; c <= 'z'; c++){\n\t\tif (root->next[c]) {\n\t\t\troot->next[c]->next[0] = root;\n\t\t\tQ.push(root->next[c]);\n\t\t}\n\t\telse root->next[c] = root;\n\t}\n\twhile(!Q.empty()){\n\t\tPMA *t = Q.front();\n\t\tQ.pop();\n\t\tfor(char c = 'A'; c <= 'z'; c++){\n\t\t\tif(t->next[c]){\n\t\t\t\tQ.push(t->next[c]);\n\t\t\t\tPMA *r = t->next[0];\n\t\t\t\twhile(!r->next[c]) r = r->next[0];\n\t\t\t\tt->next[c]->next[0] = r->next[c];\n\t\t\t\teach(i, r->next[c]->accept) t->next[c]->accept.pb(*i);\n\t\t\t}\n\t\t}\n\t}\n\treturn root;\n}\n\nconst int mod = (int)1e9 + 7;\nint n, m, k, N, dp[22][500][610][2]; //文字数, prev, state, match\nvector<vi> e;\nstring a[300], b[300];\nvector<string> c, v;\npi memo[610][500];\npi next(PMA *p, int s) {\n\tpi &res = memo[p - pma][s];\n\tif(res.second >= 0) return res;\n\tint count = 0;\n\trep(i, v[s].size()){\n\t\tchar c = v[s][i];\n\t\twhile (!p->next[c]) p = p->next[0];\n\t\tp = p->next[c];\n\t\trep(j, p->accept.size()) count++;\n\t}\n\treturn res = mp(p - pma, count);\n}\n\nint main(){\n\twhile(cin >> n >> m >> k, n){\n\t\tv.clear();\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> a[i] >> b[i], v.pb(a[i]), v.pb(b[i]);\n\t\tsort(all(v));\n\t\tv.erase(unique(all(v)), v.end());\n\t\t\n\t\te.clear(); e.resize(v.size());\n\t\trep(i, n){\n\t\t\tint p = lower_bound(all(v), a[i]) - v.begin();\n\t\t\tint q = lower_bound(all(v), b[i]) - v.begin();\n\t\t\te[p].pb(q);\n\t\t}\n\t\tc.clear(); c.resize(k);\n\t\trep(i, k) cin >> c[i];\n\t\tsz = 0;\n\t\tPMA* r = buildPMA(c);\n\t\t\n\t\tassert(sz < 610);\n\t\trep(i, sz) rep(j, v.size()) memo[i][j].second = -1;\n\t\t\n\t\trep(i, v.size()){\n\t\t\tpi x = next(r, i);\n\t\t\tif(v[i].size() < m && x.second < 2) dp[v[i].size() % 22][i][x.first][x.second] = 1;\n\t\t}\n\t\trep(i, m){\n\t\t\tmemset(dp[(i + 21) % 22], 0, sizeof(dp[0]));\n\t\t\trep(j, v.size()) rep(k, sz) rep(l, 2) if(dp[i % 22][j][k][l]){\n\t\t\t\trep(h, e[j].size()){\n\t\t\t\t\tpi x = next(pma + k, e[j][h]);\n\t\t\t\t\tint ni = v[e[j][h]].size() + i;\n\t\t\t\t\tif(ni <= m && x.second + l < 2)\n\t\t\t\t\t(dp[ni % 22][e[j][h]][x.first][x.second + l] += dp[i % 22][j][k][l]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\trep(i, v.size()) rep(j, sz) (res += dp[m % 22][i][j][1]) %= mod;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\nclass st{\npublic:\n  int n,p,ac;\n  bool operator<(const st & a)const{\n    if (n != a.n)return n < a.n;\n    if (p != a.p)return p < a.p;\n    return ac < a.ac;\n  }\n};\n\nconst int MOD=21;\nmap<st,int> dp[MOD];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)dp[i].clear();\n  rep(i,all.size()){\n    int id=i;\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%mod][(st){id,move[ROOT][id],ac[ROOT][id]}]=1;\n    }\n  }\n  rep(i,len){\n    map<st,int>::iterator itr = dp[i%MOD].begin();\n    while(itr != dp[i%MOD].end()){\n      int j=(*itr).first.n,l=(*itr).first.p,m=(*itr).first.ac;\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\tint nextlen=i+all[readword].size();\n\tint nextn=readword;\n\tint nextpma=move[l][readword];\n\tint nextac=m+ac[l][readword];\n\tif (nextlen > len ||nextpma == -1)continue;\n\tif (nextac >= 2)continue;\n\tnextlen%=MOD;\n\tint tmp=dp[nextlen][(st){nextn,nextpma,nextac}];\n\tdp[nextlen][(st){nextn,nextpma,nextac}]=\n\t  (tmp+\n\t   (*itr).second)%mod;\n      }\n      itr++;\n    }\n    dp[i%MOD].clear();\n  }\n  int ret=0;\n  map<st,int>::iterator itr = dp[len%MOD].begin();\n  while(itr != dp[len%MOD].end()){\n    if ((*itr).first.ac == 1)ret=(ret+(*itr).second)%mod;\n    itr++;\n  }\n  return ret;\n}\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n    \n    sm->feed(\"\",mr);\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      if(prev_word_length % 3) dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nconst char ALPHABET_MIN = 'a';\nconst char ALPHABET_MAX = 'z';\nconst int ALPHABET_SIZE = ALPHABET_MAX - ALPHABET_MIN + 1;\n\nstruct State {\n    vector<int> next;\n    vector<int> accept;\n    int failure;\n    State(): next(ALPHABET_SIZE, -1), failure(-1) {}\n};\n\nvector<State> build_pma(const vector<string>& keywords) {\n    vector<State> pma(1);\n    // make trie\n    REP(i, keywords.size()) {\n        int k = 0;\n        for (char ch : keywords[i]) {\n            assert(ALPHABET_MIN <= ch && ch <= ALPHABET_MAX);\n            ch -= ALPHABET_MIN;\n            if (pma[k].next[ch] == -1) {\n                pma[k].next[ch] = pma.size();\n                pma.emplace_back();\n            }\n            k = pma[k].next[ch];\n        }\n        pma[k].accept.push_back(i);\n    }\n    // bfs\n    queue<int> Q;\n    REP(ch, ALPHABET_SIZE) {\n        int k = pma[0].next[ch];\n        if (k == -1) {\n            pma[0].next[ch] = 0;\n        } else {\n            pma[k].failure = 0;\n            Q.push(k);\n        }\n    }\n    while (!Q.empty()) {\n        int k = Q.front(); Q.pop();\n        REP(ch, ALPHABET_SIZE) {\n            int j = pma[k].next[ch];\n            if (j == -1) continue;\n            int i = pma[k].failure;\n            while (pma[i].next[ch] == -1) i = pma[i].failure;\n            i = pma[i].next[ch];\n            pma[j].failure = i;\n            vector<int> accept;\n            set_union(pma[j].accept.begin(), pma[j].accept.end(),\n                      pma[i].accept.begin(), pma[i].accept.end(), back_inserter(accept));\n            pma[j].accept = accept;\n            Q.push(j);\n        }\n    }\n    return pma;\n}\n\npair<int, int> transit(const vector<State>& pma, const string& s, int initial) {\n    int k = initial, accept = 0;\n    REP(i, s.size()) {\n        char ch = s[i] - ALPHABET_MIN;\n        while (pma[k].next[ch] == -1)\n            k = pma[k].failure;\n        k = pma[k].next[ch];\n        accept += pma[k].accept.size();\n    }\n    return make_pair(k, accept);\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, K;\n    while (cin>>N>>M>>K, N|M|K) {\n        unordered_map<string, int> word2id;\n        vector<vector<int>> graph;\n        REP(i, N) {\n            string s, t; cin >> s >> t;\n            if (!word2id.count(s)) {\n                int id = word2id.size();\n                word2id[s] = id;\n            }\n            if (!word2id.count(t)) {\n                int id = word2id.size();\n                word2id[t] = id;\n            }\n            graph.resize(word2id.size());\n            graph[word2id[s]].push_back(word2id[t]);\n        }\n        vector<string> seasonword(K);\n        REP(i, K) cin >> seasonword[i];\n\n        vector<State> pma = build_pma(seasonword);\n\n        vector<vector<int>> next_state(pma.size(), vector<int>(word2id.size()));\n        vector<vector<int>> n_accept(pma.size(), vector<int>(word2id.size()));\n        REP(state, pma.size()) {\n            for (auto p : word2id) {\n                string word; int i; tie(word, i) = p;\n                tie(next_state[state][i], n_accept[state][i]) = transit(pma, word, state);\n            }\n        }\n\n        vector<int> word_len(word2id.size());\n        for (auto p : word2id) {\n            string word; int i; tie(word, i) = p;\n            word_len[i] = word.size();\n        }\n\n        using Entry = tuple<short, short, char>;\n        vector<map<Entry, int>> dp(M+1);\n        REP(word, word2id.size()) {\n            Entry e = Entry(next_state[0][word], word, n_accept[0][word]);\n            if (word_len[word] <= M && get<2>(e) <= 1)\n                dp[word_len[word]][e] = 1;\n        }\n        REP(length, M+1) {\n            REP(state, pma.size()) {\n                REP(word1, word2id.size()) {\n                    REP(n_season, 2) {\n                        int c = dp[length][Entry(state, word1, n_season)];\n                        for (int word2 : graph[word1]) {\n                            int length2 = length + word_len[word2];\n                            Entry next = Entry(\n                                next_state[state][word2],\n                                word2,\n                                n_season + n_accept[state][word2]);\n                            if (length2 > M || get<2>(next) > 1) continue;\n                            dp[length2][next] = (dp[length2][next] + c) % 1000000007;\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(state, pma.size()) REP(word, word2id.size()) if (dp[M].count(Entry(state, word, 1)))\n            ans = (ans + dp[M][Entry(state, word, 1)]) % 1000000007;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint getNum(char ch){\n\treturn ch-'a';\n}\n\nstruct PMA{\n\tstruct node{\n\t\tint to[26];\n\t\tint fail;\n\t\tint leaf;//0,1,or2(>=2)\n\t\tnode(){\n\t\t\tfor(int i=0;i<26;i++) to[i]=-1;\n\t\t\tfail=-1;\n\t\t\tleaf=0;\n\t\t}\n\t};\n\tnode nodes[700];\n\tint c;\n\tvoid init(){\n\t\tc=1;\n\t\tfor(int i=0;i<700;i++) nodes[i]=node();\n\t}\n\tvoid add(string str){\n\t\tint cur=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint num=getNum(str[i]);\n\t\t\tif(nodes[cur].to[num]==-1){\n\t\t\t\tnodes[cur].to[num]=c;\n\t\t\t\tcur=c;\n\t\t\t\tc++;\n\t\t\t}else{\n\t\t\t\tcur=nodes[cur].to[num];\n\t\t\t}\n\t\t}\n\t\tnodes[cur].leaf=min(nodes[cur].leaf+1,2);\n\t}\n\tvoid getFail(){\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(nodes[0].to[i]!=-1){\n\t\t\t\tnodes[nodes[0].to[i]].fail=0;\n\t\t\t\tque.push(nodes[0].to[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint r=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tif(nodes[r].to[i]!=-1){\n\t\t\t\t\tint u=nodes[r].to[i];\n\t\t\t\t\tque.push(u);\n\t\t\t\t\tint v=nodes[r].fail;\n\t\t\t\t\twhile(v!=0&&nodes[v].to[i]==-1){\n\t\t\t\t\t\tprintf(\"v=%d\\n\",v);\n\t\t\t\t\t\tv=nodes[v].fail;\n\t\t\t\t\t}\n\t\t\t\t\tif(nodes[v].to[i]==-1) nodes[u].fail=0;\n\t\t\t\t\telse nodes[u].fail=nodes[v].to[i];\n\t\t\t\t\tint f=nodes[u].fail;\n\t\t\t\t\tnodes[u].leaf=min(nodes[u].leaf+nodes[f].leaf,2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpair<int,int> move(int v,string str){\n\t///\tbool flg=(str==\"negawakuha\");\n\t//\tif(flg) cout<<v<<\" \"<<str<<\"\\n\";\n\t\tint cur=v;\n\t\tint res=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint num=getNum(str[i]);\n\t\t\twhile(cur!=0&&nodes[cur].to[num]==-1) cur=nodes[cur].fail;\n\t\t\tif(nodes[cur].to[num]==-1){}\n\t\t\telse{\n\t\t\t\tcur=nodes[cur].to[num];\n\t\t\t}\n\t\t\tres+=nodes[cur].leaf;\n\t\t}\n\t//\tif(flg) cout<<cur<<\" \"<<res<<\"\\n\";\n\t\treturn make_pair(cur,res);\n\t}\n};\n\nPMA pma;\n\nint dp[21][650][500][2];\n\nconst long long mod=1000000007;\n\nmap<string,int> mp;\nint sz[501];\nvector<int> to[501];\nstring strs[501];\n\nint main(){\n\tint N,M,K;\n\twhile(true){\n\t\tpma.init();\n\t\tcin>>N>>M>>K;\n\t\tmp.clear();\n\t\tfor(int i=0;i<501;i++) to[i].clear();\n\t\tif(N==0&&M==0&&K==0) break;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring from,to;\n\t\t\tcin>>from>>to;\n\t\t\tif(mp.count(from)==0){\n\t\t\t\tint a=mp.size();\n\t\t\t\tmp[from]=a;\n\t\t\t\tsz[a]=from.size();\n\t\t\t\tstrs[a]=from;\n\t\t\t}\n\t\t\tif(mp.count(to)==0){\n\t\t\t\tint a=mp.size();\n\t\t\t\tmp[to]=a;\n\t\t\t\tsz[a]=to.size();\n\t\t\t\tstrs[a]=to;\n\t\t\t}\n\t\t\t::to[mp[from]].push_back(mp[to]);\n\t\t}\n\t//\tfor(int i=0;i<mp.size();i++){\n\t//\t\tcout<<i<<\" \"<<strs[i]<<\"\\n\";\n\t//\t}\n\t//\tprintf(\"b\\n\");\n\t\tfor(int i=0;i<K;i++){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t//\t\tcout<<\"add:\"<<str<<\"\\n\";\n\t\t\tpma.add(str);\n\t\t}\n\t//\tprintf(\"c\\n\");\n\t\tpma.getFail();\n\t//\tprintf(\"d\\n\");\n\t//\tfor(int i=0;i<mp.size();i++){\n\t//\t\tcout<<strs[i]<<\"->\";\n\t//\t\tfor(int j=0;j<to[i].size();j++){\n\t//\t\t\tcout<<strs[to[i][j]]<<\" \";\n\t//\t\t}\n\t//\t\tcout<<\"\\n\";\n\t//\t}\n\t\tint C=pma.c;\n\t\tfor(int l=0;l<21;l++) for(int i=0;i<C;i++) for(int j=0;j<=mp.size();j++) for(int k=0;k<2;k++){\n\t\t\tdp[l][i][j][k]=0;\n\t\t}\n\t\tfor(int i=0;i<mp.size();i++){\n\t\t\tpair<int,int> p=pma.move(0,strs[i]);\n\t\t\tif(p.second>=2) continue;\n\t\t\tdp[sz[i]][p.first][i][p.second]=1;\n\t\t}\n\t//\tprintf(\"a\\n\");\n\t\tfor(int l=1;l<M;l++){\n\t\t\tfor(int v=0;v<C;v++){\n\t\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\tfor(int i=0;i<to[w].size();i++){\n\t\t\t\t\t\t\tint nw=to[w][i];\n\t\t\t\t\t\t\tint nl=(l+sz[nw])%21;\n\t\t\t\t\t\t\tpair<int,int> p=pma.move(v,strs[nw]);\n\t\t\t\t\t\t\tint nv=p.first;\n\t\t\t\t\t\t\tint nb=b+p.second;\n\t\t\t\t\t\t\tif(nb>=2) continue;\n\t\t\t\t\t\t\tdp[nl][nv][nw][nb]+=dp[l%21][v][w][b];\n\t\t\t\t\t\t\tdp[nl][nv][nw][nb]%=mod;\n\t\t//\t\t\t\t\tif(dp[l%21][v][w][b]!=0){\n\t\t//\t\t\t\t\t\tprintf(\"(%d,%d,%d,%d)->(%d,%d,%d,%d)\\n\",\n\t\t//\t\t\t\t\t\t\tl,v,w,b,l+sz[nw],nv,nw,nb);\n\t\t//\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v=0;v<C;v++){\n\t\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\tdp[l%21][v][w][b]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans=0;\n\t\tfor(int v=0;v<C;v++){\n\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\tans+=dp[(M%21)][v][w][1];\n\t\t\t\tans%=mod;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[256];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nconst int MD=21;\nint dp[MD][500][600][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    //    cout<<e<<\" \"<<l<<\" \"<<m<<endl;\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    //cout<<l<<\"*\"<<e<<\"*\"<<vs<<\"*2=\"<<l*e*vs*2<<endl;\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  //int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(mov[w][v].Y+t<2)\n\t    (dp[(pos+toi[w].size())%MD][w][mov[w][v].X][mov[w][v].Y+t]+=dp[pos%MD][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%MD][0][0],dp[pos%MD][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%MD][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      if(matching_result->match_count >= 2) break;\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n    \n    sm->feed(\"\",mr);\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    \n    int res = 0;\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n      \n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(const int &p, const int &c){\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct Ahocora{\n \n  int idx=0;\n \n  struct PMA {\n      int state;\n      PMA* next[256];\n      vector<int> matched;\n      PMA(int idx) { memset(next, 0, sizeof(next)); state = idx ; }\n      ~PMA() { for(int i = 0; i < 256; i++) if(next[i]) delete next[i]; }\n  };\n  vector<int> set_uni(const vector<int> &a,const vector<int> &b) {\n      vector<int> res;\n      set_union(a.begin(),a.end(),b.begin(),b.end(), back_inserter(res));\n      return res;\n  };\n \n  PMA *root;\n \n  map<int,PMA*>M;\n \n  Ahocora(vector<string> &pattern) {\n      root = new PMA(idx++);\n      M[idx-1]=root;\n      PMA *now;\n      root->next[0] = root;\n      for(int i = 0; i < pattern.size(); i++) {\n          now = root;\n          for(int j = 0; j < pattern[i].size(); j++) {\n              if(now->next[(int)pattern[i][j]] == 0){\n                  now->next[(int)pattern[i][j]] = new PMA(idx++);\n                  M[idx-1] = now->next[(int)pattern[i][j]];\n                }\n              now = now->next[(int)pattern[i][j]];\n          }\n          now->matched.push_back(i);\n      }\n \n      queue<PMA*> que;\n \n      for(int i=1;i<256;i++){\n          if(!root->next[i]) root->next[i] = root;\n          else{\n              root->next[i]->next[0] = root;\n              que.push(root->next[i]);\n          }\n      }\n \n      while(!que.empty()) {\n          now = que.front(); que.pop();//cout<<1;\n          for(int i = 1; i < 256; i++) {\n              if(now->next[i]){\n                  PMA *nxt = now->next[0];\n                  while(!nxt->next[i]) nxt = nxt->next[0];\n                  now->next[i]->next[0] = nxt->next[i];\n                  now->next[i]->matched = set_uni(now->next[i]->matched, nxt->next[i]->matched);\n                  que.push(now->next[i]);\n              }\n          }\n      }\n \n  }\n  void match( const string s, vector<int> &res) {\n    PMA *pma=root;\n      for(int i = 0; i < s.size(); i++){\n          int c = s[i];\n          while(!pma->next[c]) pma = pma->next[0];\n          pma = pma->next[c];\n          for(int j = 0; j < pma->matched.size(); j++)\n              res[pma->matched[j]] = true;\n      }\n  }\n  typedef pair<string,int>Pi;\n\n \n  pair<int,int> match( const string &s,int S) {\n    PMA *pma=M[S];\n    int res=0;\n      for(int i = 0; i < s.size(); i++){\n          int c = s[i];\n          while(!pma->next[c]) pma = pma->next[0];\n          pma = pma->next[c];\n          for(int j = 0; j < pma->matched.size(); j++) res++;\n      }\n    return make_pair(res,pma->state);\n  }\n \n  /*  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2212\n  int NG( const string s,int S) {\n    PMA *pm = M[S];\n    for(int i = 0; i < s.size(); i++){\n        int c = s[i];\n        while(!pm->next[c]) pm = pm->next[0];\n        pm = pm->next[c];\n        for(int j = 0; j < pm->matched.size(); j++) return -1;\n    }\n    return pm->state;\n  }\n  */\n};\n \n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>P2;\nint n,m,k;\n \nint main(){\n \n  while(1){\n    int IDX=0;\n    map<P2,int>dp;\n    cin>>n>>m>>k;\n    if(!n)break;\n    string is[n*2];\n    map<string,int>si;\n    string s[n],t[n],a;\n    vector<string>v;\n    set<string>st;\n    \n    vector<int>G[n*2],ALL;\n    r(i,n){\n      cin>>s[i]>>t[i];\n\n      if(!st.count(s[i])) si[s[i]] = IDX , is[IDX] = s[i] , IDX++,st.insert(s[i]);\n      if(!st.count(t[i])) si[t[i]] = IDX , is[IDX] = t[i] , IDX++,st.insert(t[i]);\n      G[si[s[i]]].push_back(si[t[i]]); \n    }\n    r(i,k){\n      cin>>a;\n\n      v.push_back(a);\n    }\n    Ahocora AHO(v);\n    for(int i=0;i<IDX;i++){\n      pair<int,int> p=AHO.match(is[i],0);\n      int A=is[i].size();\n      int B=p.second;\n      int C=p.first;\n      int D=i;\n      if(C>1)continue;\n      if(A>m)continue;\n      dp[P2(P(A,B),P(D,C))]++;\n      //cout<<A<<B<<C<<D<<endl;\n    }\n\n    vector< vector< pair<int,int> > > vec[604];\n\n    r(i,AHO.idx){\n      vec[i].resize(IDX);\n      r(j,IDX){\n        r(K,G[j].size()){\n          pair<int,int> p = AHO.match(is[G[j][K]],i);\n          vec[i][j].push_back(p);\n        }\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<AHO.idx;j++){\n        for(int K=0;K<2;K++){\n          for(int l=0;l<IDX;l++){\n \n            if( !dp.count(P2(P(i,j),P(l,K)))  )continue;\n \n            for(int z=0;z<G[l].size();z++){\n              pair<int,int> p=vec[j][l][z];\n              int A=i+is[G[l][z]].size();\n              int B=p.second;\n              int C=K+p.first;\n              int D=G[l][z];\n              //cout<<A<<endl;\n              if(C>1)continue;\n              if(A>m)continue;\n              //cout<<A<<endl;\n              dp[P2(P(A,B),P(D,C))] += dp[P2(P(i,j),P(l,K))];\n              dp[P2(P(A,B),P(D,C))] %= 1000000007;\n            }\n \n            dp.erase(P2(P(i,j),P(l,K)));\n          }\n        }\n      }\n    }\n    int ans=0;\n    for(int i=0;i<AHO.idx;i++){\n      for(int j=0;j<IDX;j++){\n        ans += dp[P2(P(m,i),P(j,1))];\n        dp.erase(P2(P(m,i),P(j,1)));\n        ans %= 1000000007;\n      }\n    }\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MOD>\nclass mod_int {\n\tunsigned x;\npublic:\n\tmod_int() : x(0) { }\n\tmod_int(int sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tmod_int(long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tmod_int &operator+=(mod_int that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator-=(mod_int that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator*=(mod_int that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tmod_int &operator/=(mod_int that) { return *this *= that.inverse(); }\n\n\tmod_int operator+(mod_int that) const { return mod_int(*this) += that; }\n\tmod_int operator-(mod_int that) const { return mod_int(*this) -= that; }\n\tmod_int operator*(mod_int that) const { return mod_int(*this) *= that; }\n\tmod_int operator/(mod_int that) const { return mod_int(*this) /= that; }\n\n\tbool operator==(const mod_int& that) const { return x == that.x; }\n\n\tmod_int inverse() const {\n\t\tlong long a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\treturn mod_int(u);\n\t}\n};\n\ntemplate<int MOD>\nistream& operator >> (istream& is, mod_int<MOD>& val) {\n\tlong long x;\n\tis >> x; val = x;\n\treturn is;\n}\n\ntemplate<int MOD>\nostream& operator << (ostream& os, const mod_int<MOD>& val) {\n\tos << val.get();\n\treturn os;\n}\n\nconst int mod = 1e9 + 7;\nusing mint = mod_int<mod>;\n\nconst int var = 26;\n\nint trans(char c) {\n\treturn c - 'a';\n}\n\nclass aho_corasick {\n\tstruct ac_node {\n\t\tint fail;\n\t\tint next[var];\n\t\tvector<int> ok;\n\t\tac_node() : fail(-1) {\n\t\t\tfor (int i = 0; i < var; i++) next[i] = -1;\n\t\t}\n\t};\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn move(res);\n\t}\n\tint n;\n\tvector<ac_node> dat;\npublic:\n\taho_corasick(const vector<string>& Ts) : n(Ts.size()), dat(1) {\n\t\tint now;\n\t\tdat[0].fail = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = 0;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (dat[now].next[trans(c)] == -1) {\n\t\t\t\t\tdat[now].next[trans(c)] = dat.size();\n\t\t\t\t\tdat.emplace_back();\n\t\t\t\t}\n\t\t\t\tnow = dat[now].next[trans(c)];\n\t\t\t}\n\t\t\tdat[now].ok.push_back(i);\n\t\t}\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < var; i++) {\n\t\t\tif (dat[0].next[i] == -1) {\n\t\t\t\tdat[0].next[i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdat[dat[0].next[i]].fail = 0;\n\t\t\t\tq.push(dat[0].next[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < var; i++) {\n\t\t\t\tif (dat[now].next[i] != -1) {\n\t\t\t\t\tint nx = dat[now].fail;\n\t\t\t\t\twhile (dat[nx].next[i] == -1) {\n\t\t\t\t\t\tnx = dat[nx].fail;\n\t\t\t\t\t}\n\t\t\t\t\tint nex = dat[now].next[i];\n\t\t\t\t\tdat[nex].fail = dat[nx].next[i];\n\t\t\t\t\tdat[nex].ok = unite(dat[nex].ok, dat[dat[nx].next[i]].ok);\n\t\t\t\t\tq.push(nex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint size() const {\n\t\treturn dat.size();\n\t}\n\tbool is_ok(int id) const {\n\t\treturn !dat[id].ok.empty();\n\t}\n\tint ok_cnt(int id) const {\n\t\treturn dat[id].ok.size();\n\t}\n\tint get_next(int id, char c) const {\n\t\twhile (dat[id].next[trans(c)] == -1) id = dat[id].fail;\n\t\treturn dat[id].next[trans(c)];\n\t}\n\tvector<int> count(const string& S) const {\n\t\tvector<int> res(n);\n\t\tint now = 0;\n\t\tfor (auto c : S) {\n\t\t\tnow = get_next(now, c);\n\t\t\tfor (auto k : dat[now].ok) res[k]++;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vector<int>> all_count(const string& S) const {\n\t\tint N = S.size();\n\t\tvector<vector<int>> res(N);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnow = get_next(now, S[i]);\n\t\t\tres[i] = dat[now].ok;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nmint dp[501][500][2][610];\n\nint main()\n{\n\tint N, M, K;\n\twhile (cin >> N >> M >> K, N | M | K) {\n\t\tvector<string> f(N), t(N);\n\t\tvector<string> word;\n\t\tmap<string, int> dic;\n\t\tvector<vector<int>> g(500);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> f[i] >> t[i];\n\t\t\tif (!dic.count(f[i])) dic[f[i]] = word.size(), word.push_back(f[i]);\n\t\t\tif (!dic.count(t[i])) dic[t[i]] = word.size(), word.push_back(t[i]);\n\t\t\tint fid = dic[f[i]], tid = dic[t[i]];\n\t\t\tg[fid].push_back(tid);\n\t\t}\n\t\tN = word.size();\n\t\tg.resize(N);\n\t\tvector<string> ss(K);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> ss[i];\n\t\t}\n\t\taho_corasick ac(ss);\n\t\tint sz = ac.size();\n\t\tvector<vector<pair<int, int>>> nex(N, vector<pair<int, int>>(sz));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tint it = j;\n\t\t\t\tfor (auto c : word[i]) {\n\t\t\t\t\tit = ac.get_next(it, c);\n\t\t\t\t\tcnt += ac.ok_cnt(it);\n\t\t\t\t}\n\t\t\t\tnex[i][j] = make_pair(cnt, it);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tfor (int l = 0; l < sz; l++) {\n\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tauto &p = nex[i][0];\n\t\t\tint pos = word[i].size();\n\t\t\tif (pos <= M && p.first < 2) dp[pos][i][p.first][p.second] += 1;\n\t\t}\n\t\tfor (int i = 1; i < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (auto to : g[j]) {\n\t\t\t\t\tfor (int k = 0; k < sz; k++) {\n\t\t\t\t\t\tfor (int b = 0; b < 2; b++) if (dp[i][j][b][k].get() != 0) {\n\t\t\t\t\t\t\tauto &p = nex[to][k];\n\t\t\t\t\t\t\tint pos = i + word[to].size(), c = b + p.first;\n\t\t\t\t\t\t\tif (pos <= M && c < 2) {\n\t\t\t\t\t\t\t\tdp[pos][to][c][p.second] += dp[i][j][b][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tres += dp[M][i][1][j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nstruct Node {\n    vector<int> accept;\n    map<char,Node*> next;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    Node* addNode() {\n        Node* node = new Node();\n        node->next[failure] = root;\n\n        return node;\n    }\n\n    void build(vector<string> vstr) {\n        for (int i = 0, vlen = vstr.size(); i < vlen; i++) {\n            Node* now = root;\n            for (auto c : vstr[i]) {\n                if (now->next.find(c) == now->next.end())\n                    now->next[c] = addNode();\n                now = now->next[c];\n            }\n            now->accept.push_back(i);\n        }\n\n        queue<Node*> que;\n\n        const string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto c : symbol_array) {\n            if (root->next.find(c) != root->next.end()) {\n                root->next[c]->next[failure] = root;\n                que.push(root->next[c]);\n            } else {\n                root->next[c] = root;\n            }\n        }\n\n        while (!que.empty()) {\n            Node* node = que.front(); que.pop();\n            for (auto p : node->next) {\n\n                char c = p.first; // i\n                Node* now = p.second; // now->next[i]\n\n                if (c == failure) {\n                    continue;\n                }\n\n                que.push(now);\n\n                Node* rev = node->next[failure];\n                while (rev->next.find(c) == rev->next.end())\n                    rev = rev->next[failure];\n                now->next[failure] = rev->next[c];\n\n                vector<int> acc;\n                set_union(now->accept.begin(),\n                          now->accept.end(),\n                          rev->next[c]->accept.begin(),\n                          rev->next[c]->accept.end(),\n                          back_inserter(acc));\n                now->accept = acc;\n            }\n        }\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto c : str) {\n            while (now->next.find(c) == now->next.end())\n                now = now->next[failure];\n            now = now->next[c];\n\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,int> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        vector<vector<bool> > flag(M+1, vector<bool>(ston.size(), false));\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (from[i].size() > M || count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1;\n            flag[from[i].size()][ston[from[i]]] = true;\n        }\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(to[i], now, count);\n            if (to[i].size() > M || count > 1) continue;\n            dp[to[i].size()][ston[to[i]]][count][now] = 1;\n            flag[to[i].size()][ston[to[i]]] = true;\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                if (!flag[i][j]) continue;\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            int num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                                flag[i+ntos[nx].size()][nx] = true;\n                            }\n                        }\n                    }\n                    dp[i][j][k].clear();\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Trie {\n    struct Node {\n        int num; // node number\n        Node *next[27], *fail;\n        int words;\n\n        Node() : words(0) {;}\n        Node(int n) : words(0), num(n) {\n            for(int i=0; i<27; ++i) next[i] = NULL;\n            fail = NULL;\n        }\n    };\n\n    // default constructor\n    Trie() { nodes.clear(); nodes.push_back(new Node(0)); }\n\n    // insert string\n    void insert(const string &s) {\n        Node *cur = nodes[0];\n        for(int i=0; i<s.length(); ++i) {\n            if(cur->next[s[i]-'a'] == NULL) {\n                cur->next[s[i]-'a'] = new Node(nodes.size());\n                nodes.push_back(cur->next[s[i]-'a']);\n            }\n            cur = cur->next[s[i]-'a'];\n        }\n        cur->words += 1;\n    }\n\n    // list of node\n    vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n    Aho_Corasick(const vector<string> &vs) : keys(vs) {\n        _trie = Trie();\n        for(int i=0; i<vs.size(); ++i) _trie.insert(vs[i]);\n        make_failure_link();\n    }\n\n    void make_failure_link() {\n        queue<Trie::Node *> q;\n        Trie::Node *root = _trie.nodes[0];\n        for(int i=0; i<27; ++i) {\n            if(root->next[i]) {\n                root->next[i]->fail = root;\n                q.push(root->next[i]);\n            }else root->next[i] = root;\n        }\n\n        while(!q.empty()) {\n            Trie::Node *t = q.front(); q.pop();\n            for(int i=0; i<27; ++i) {\n                Trie::Node *u = t->next[i];\n                if(u) {\n                    q.push(u);\n                    Trie::Node *r = t->fail;\n                    while(!r->next[i]) r = r->fail;\n                    u->fail = r->next[i];\n                    u->words += u->fail->words;\n                }\n            }\n        }\n    }\n\n    pair<int,int> match(const string &s,int num = 0) {\n        Trie::Node *v = _trie.nodes[num];\n        int ret = 0;\n        for(int i=0; i<s.length(); ++i) {\n            while(!v->next[s[i]-'a']) v = v->fail;\n            v = v->next[s[i]-'a'];\n            if(v->words > 0) ret += v->words;\n        }\n        return make_pair(ret,v->num);\n    }\n\n    void free() {\n        for(int i=0; i<_trie.nodes.size(); ++i)\n            delete _trie.nodes[i];\n    }\n\n    Trie _trie;\n    vector<string> keys;\n};\n\nconst int MAXM = 501;\nconst int MAXS = 20*30+5;\nconst int MAXN = 501;\nconst int mod = 1000000007;\nmap<int,int> dp[21];\npair<int,int> memo[MAXS][MAXN];\n\ninline int encode(int k,int s,int w) { return (s*MAXN+w)*MAXN+k; }\n\nint main() {\n    int n,m,k;\n    while(cin>>n>>m>>k, n|m|k) {\n        string from,to;\n\n        map<int, vector<int> > edge;\n        map<string,int> idx;\n        vector<string> ridx;\n\n        for(int i=0; i<n; ++i) {\n            cin>>from>>to;\n\n            // make index of word\n            if(idx.find(from) == idx.end()) {\n                idx[from] = ridx.size();\n                ridx.push_back(from);\n            }\n            if(idx.find(to) == idx.end()) {\n                idx[to] = ridx.size();\n                ridx.push_back(to);\n            }\n\n\n            if(edge.find(idx[from]) == edge.end())\n                edge[idx[from]] = vector<int>(1,idx[to]);\n            else\n                edge[idx[from]].push_back(idx[to]);\n        }\n\n        vector<string> kigo(k);\n        for(int i=0; i<k; ++i) cin>>kigo[i];\n        Aho_Corasick ac(kigo);\n\n        int s = ac._trie.nodes.size();\n\n        for(int i=0; i<s; ++i)\n            for(int j=0; j<ridx.size(); ++j)\n                memo[i][j] = ac.match(ridx[j],i);\n\n        // hoge\n        for(int i=0; i<21; ++i) dp[i].clear();\n        for(int i=0; i<ridx.size(); ++i) {\n            int m = ridx[i].length();\n            pair<int,int> p = ac.match(ridx[i]);\n            dp[m%21][encode(p.first,p.second,i)] = 1;\n        }\n\n        for(int i=0; i<=m; ++i) {\n            for(map<int,int>::iterator it = dp[i%21].begin(); it != dp[i%21].end(); ++it) {\n                int key = it->first;\n                int k = key%MAXN, prev = (key/MAXN)%MAXN, s = (key/MAXN)/MAXN,d = it->second;\n\n                for(int j=0; j<edge[prev].size(); ++j) {\n                    int nlen = i+ridx[edge[prev][j]].length();\n                    if(nlen > m) continue;\n\n                    pair<int,int> p = memo[s][edge[prev][j]];\n                    if(k+p.first < 2) {\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] += d;\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] %= mod;\n                    }\n                }\n            }\n            if(i < m) dp[i%21].clear();\n        }\n\n\n        ac.free();\n\n        int ans = 0;\n        for(int i=0; i<ridx.size(); ++i) {\n            for(int j=0; j<MAXS; ++j) {\n                ans += dp[m%21][encode(1,j,i)];\n                ans %= mod;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[21][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i % 21][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[(i + nums[t].size()) % 21][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i % 21][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M % 21][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 0; i < 21; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    /*\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    */\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      //int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      //ini.push_back(tf);\n      //edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    /*\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    */\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    \n    AhoCorasick::MatchingResult* start = new AhoCorasick::MatchingResult();\n    sm->feed(\"\",start);\n    unordered_map<State,int> dp[600];\n\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->set_state(start->id);\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tREP(i, MAXCHAR){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst) continue;\n\t\t\t\tq.push(dst);\n\t\t\t\tint f = states[p].failure;\n\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\tif(p){\n\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tint apply(const string &s, int &p){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tint p = p_->first;\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tint res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res][*v][p], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< unsigned short, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[26];\n\tint decode(int c){\n\t\treturn c-'a';\n\t}\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tint c=decode(s[j]);\n\t\t\t\tif(!t->next[c])t->next[c]=new PMA(++num);\n\t\t\t\tt=t->next[c];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(int c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(decode(s[i]));\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[521];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tfor(int i=0;i<521;i++)dp[i].clear();\n\t\tvector<int> to[250];\n\t\tstring str[250];\n\t\tmap<string,int> id;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tADD(dp[i+str[dest].size()][t],it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass PMA\n{\n    int n;\n    vector<vector<int> > next;\n    vector<bitset<32> > match;\n    vector<int> failure;\npublic:\n    PMA(const vector<string>& pattern){\n        next.assign(1, vector<int>(128, -1));\n        match.assign(1, 0);\n        for(unsigned i=0; i<pattern.size(); ++i){\n            int curr = 0;\n            for(unsigned j=0; j<pattern[i].size(); ++j){\n                if(next[curr][pattern[i][j]] == -1){\n                    next[curr][pattern[i][j]] = next.size();\n                    next.push_back(vector<int>(128, -1));\n                    match.push_back(0);\n                }\n                curr = next[curr][pattern[i][j]];\n            }\n            match[curr][i] = true;\n        }\n\n        n = next.size();\n        failure.resize(n, 0);\n        vector<int> node1(1, 0);\n        while(!node1.empty()){\n            vector<int> node2;\n            for(unsigned i=0; i<node1.size(); ++i){\n                for(int j=0; j<128; ++j){\n                    int s = node1[i];\n                    if(next[s][j] == -1)\n                        continue;\n                    node2.push_back(next[s][j]);\n                    int t = s;\n                    while(t != 0){\n                        if(next[failure[t]][j] != -1){\n                            failure[next[s][j]] = next[failure[t]][j];\n                            match[next[s][j]] |= match[next[failure[t]][j]];\n                            break;\n                        }\n                        t = failure[t];\n                    }\n                }\n            }\n            node1.swap(node2);\n        }\n    }\n    int size(){\n        return n;\n    }\n    int transition(int curr, char c){\n        if(next[curr][c] != -1)\n            return next[curr][c];\n        if(curr == 0)\n            return 0;\n        return transition(failure[curr], c);\n    }\n    bitset<32> checkMatch(int curr){\n        return match[curr];\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        index.insert(make_pair(\"\", 0));\n        vector<string> word(1, \"\");\n        vector<vector<int> > connect(1);\n        for(int i=0; i<n; ++i){\n            string from, to;\n            cin >> from >> to;\n            int j, k;\n            if(index.find(from) == index.end()){\n                j = index.size();\n                index[from] = j;\n                word.push_back(from);\n                connect.resize(connect.size()+1);\n            }else{\n                j = index[from];\n            }\n            if(index.find(to) == index.end()){\n                k = index.size();\n                index[to] = k;\n                word.push_back(to);\n                connect.resize(connect.size()+1);\n            }else{\n                k = index[to];\n            }\n            connect[j].push_back(k);\n        }\n        n = index.size();\n        for(int i=1; i<n; ++i)\n            connect[0].push_back(i);\n\n        vector<string> season(p);\n        for(int i=0; i<p; ++i)\n            cin >> season[i];\n        PMA pma(season);\n        p = pma.size();\n\n        vector<vector<int> > seasonNum(p, vector<int>(n, 0));\n        vector<vector<int> > next(p, vector<int>(n));\n        for(int i=0; i<p; ++i){\n            for(int j=0; j<n; ++j){\n                next[i][j] = i;\n                for(unsigned k=0; k<word[j].size(); ++k){\n                    next[i][j] = pma.transition(next[i][j], word[j][k]);\n                    seasonNum[i][j] += pma.checkMatch(next[i][j]).count();\n                }\n            }\n        }\n\n        map<pair<pair<int, int>, pair<int, int> >, int> num;\n        num[make_pair(make_pair(0, 0), make_pair(0, 0))] = 1;\n        int ret = 0;\n        while(!num.empty()){\n            int a = num.begin()->first.first.first;   // ¶\n            int b = num.begin()->first.first.second;  // ÅãÌPê\n            int c = num.begin()->first.second.first;  // PMAÌJÚ}É¨¯éÊu\n            int d = num.begin()->first.second.second; // GêÌ\n            int x = num.begin()->second;\n            num.erase(num.begin());\n\n            for(int i=0; i<connect[b].size(); ++i){\n                int b2 = connect[b][i];\n                int a2 = a + word[b2].size();\n                if(a2 > m)\n                    continue;\n                int c2 = next[c][b2];\n                int d2 = d + seasonNum[c][b2];\n                if(d2 > 1)\n                    continue;\n\n                if(a2 == m){\n                    if(d2 == 1){\n                        ret += x;\n                        ret %= MOD;\n                    }\n                }else{\n                    (num[make_pair(make_pair(a2, b2), make_pair(c2, d2))] += x) %= MOD;\n                }\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,M,K;\nstring U[500],V[500];\nvector<int> g[500];\nint dp[22][601][501][2];\nconst int L=22;\n\nint main(){\n  while(1){\n    cin>>N>>M>>K;\n    if(N==0)break;\n\n    rep(i,500)g[i].clear();\n\n    vector<string> S;\n    rep(i,N){\n      cin>>U[i]>>V[i];\n      S.push_back(U[i]);\n      S.push_back(V[i]);\n    }\n    sort(all(S));\n    uni(S);\n    rep(i,N){\n      ll u=lower_bound(all(S),U[i])-S.begin();\n      ll v=lower_bound(all(S),V[i])-S.begin();\n      g[u].push_back(v);\n    }\n    N=S.size();\n\n    vector<string> P(K),pfx;\n    rep(i,K){\n      cin>>P[i];\n      rep(j,P[i].size()+1)pfx.push_back(P[i].substr(0,j));\n    }\n    sort(all(pfx));\n    uni(pfx);\n    int T=pfx.size();\n\n    vector<int> ok(T,0);\n    vector<vector<int> > nxt(T,vector<int>(26,-1));\n    rep(i,T){\n      rep(j,K){\n        if(P[j].size()<=pfx[i].size()){\n          if(pfx[i].substr(pfx[i].size()-P[j].size(),P[j].size())==P[j])ok[i]++;\n        }\n      }\n      rep(j,26){\n        string tmp=pfx[i];\n        tmp+='a'+j;\n        int k;\n        while(1){\n          k=lower_bound(all(pfx),tmp)-pfx.begin();\n          if(k<T&&pfx[k]==tmp)break;\n          tmp=tmp.substr(1);\n        }\n        nxt[i][j]=k;\n      }\n    }\n\n    vector<vector<int> > mov(T,vector<int>(N,-1)),cnt(T,vector<int>(N,0));\n    rep(i,T){\n      rep(j,N){\n        mov[i][j]=i;\n        rep(k,S[j].size()){\n          mov[i][j]=nxt[mov[i][j]][S[j][k]-'a'];\n          cnt[i][j]+=ok[mov[i][j]];\n        }\n      }\n    }\n\n    memset(dp,0,sizeof(dp));\n    rep(v,N){\n      if(cnt[0][v]<=1)dp[S[v].size()][mov[0][v]][v][cnt[0][v]]=1;\n    }\n    int i=0;\n    rep(ri,M){\n      i++; i%=L;\n      rep(j,T)rep(v,N)rep(f,2)dp[(i-1+L)%L][j][v][f]=0;\n      rep(j,T)rep(v,N)rep(f,2){\n        for(ll nv : g[v]){\n          if(f+cnt[j][nv]<=1&&i+(int)S[nv].size()<=M){\n            (dp[(i+S[nv].size())%L][mov[j][nv]][nv][f+cnt[j][nv]]+=dp[i][j][v][f])%=mod;\n          }\n        }\n      }\n    }\n    ll res=0;\n    rep(j,T)rep(v,N)(res+=dp[M%L][j][v][1])%=mod;\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst ll MOD = 1e9+7;\n\nstruct Node {\n    vector<int> accept;\n    map<char,Node*> chd;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\n\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    void build(vector<string> vstr) {\n        int vlen = vstr.size();\n        vector<vector<pair<int,int> > > substring(vlen);\n        for (int i = 0; i < vlen; i++) {\n            for (int j = 0; j < vlen; j++) {\n                if (i == j) continue;\n                auto pos = vstr[i].find(vstr[j]);\n                if (pos != string::npos) {\n                    substring[i].push_back(make_pair(j, pos + vstr[j].size()-1));\n                }\n            }\n        }\n        for (int i = 0; i < vlen; i++) {\n            Node* now = root;\n            for (int j = 0; j < vstr[i].size(); j++) {\n                char s = vstr[i][j];\n                if (now->chd.find(s) == now->chd.end())\n                    now->chd[s] = new Node();\n                now = now->chd[s];\n                for (auto p : substring[i]) {\n                    int v = p.first;\n                    int ps = p.second;\n                    if (ps == j) {\n                        now->accept.push_back(v);\n                    }\n                }\n            }\n            now->accept.push_back(i);\n        }\n\n\n        queue<Node*> que;\n        string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto s : symbol_array) {\n            if (root->chd.find(s) == root->chd.end()) {\n                root->chd[s] = root;\n            } else {\n                root->chd[s]->chd[failure] = root;\n                que.push(root->chd[s]);\n            }\n        }\n\n        while (!que.empty()) {\n            Node* now = que.front();\n            que.pop();\n\n            for (auto& v : now->chd) {\n                if (v.first == failure) continue;\n                que.push(v.second);\n                Node* rev = now->chd[failure];\n                while (!rev->chd[v.first])\n                    rev = rev->chd[failure];\n                now->chd[v.first]->chd[failure] = rev->chd[v.first];\n            }\n        }\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto s : str) {\n            while (now->chd.find(s) == now->chd.end())\n                now = now->chd[failure];\n            now = now->chd[s];\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,ll> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1LL;\n        }\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            ll num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        ll ans = 0LL;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MOD=1e9+7;\nint n, m, k;\nstring fr[250], to[250];\nunordered_map<string, int> word;\nstring w[501];\nunordered_map<int, int> dp[2][501][501];\nvector<int> g[500];\nstruct node{\n\tnode* nxt[26];\n\tnode* fail;\n\tint cnt;\n\tint num;\n\tnode():fail(nullptr), cnt(0), num(0){\n\t\tfill(nxt, nxt+26, nullptr);\n\t}\n};\nnode v[602];\nint nw, ns;\nvoid add(string s){\n\tnode* v0=&v[0];\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(!v0->nxt[s[i]-'a']){\n\t\t\tv0->nxt[s[i]-'a']=&v[ns];\n\t\t\tv[ns].num=ns;\n\t\t\tns++;\n\t\t}\n\t\tv0=v0->nxt[s[i]-'a'];\n\t}\n\tv0->cnt++;\n}\nvoid addfail(){\n\tqueue<node*> que;\n\tque.push(&v[0]);\n\twhile(!que.empty()){\n\t\tnode* v0=que.front(); que.pop();\n\t\tfor(int i=0; i<26; i++){\n\t\t\tif(!v0->nxt[i]) continue;\n\t\t\tnode* v1=v0;\n\t\t\twhile(1){\n\t\t\t\tif(v1==&v[0]){\n\t\t\t\t\tv0->nxt[i]->fail=&v[0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(v1->fail->nxt[i]){\n\t\t\t\t\tv0->nxt[i]->fail=v1->fail->nxt[i];\n\t\t\t\t\tv0->nxt[i]->cnt+=v0->nxt[i]->fail->cnt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv1=v1->fail;\n\t\t\t}\n\t\t\tque.push(v0->nxt[i]);\n\t\t}\n\t}\n}\n\nvoid init(){\n\tword.clear();\n\tfor(int t=0; t<2; t++){\n\t\tfor(int i=0; i<=m; i++){\n\t\t\tfor(int j=0; j<nw; j++){\n\t\t\t\tdp[t][i][j].clear();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<nw; i++) g[i].clear();\n\tfor(int i=0; i<ns; i++){\n\t\tv[i].fail=nullptr;\n\t\tfill(v[i].nxt, v[i].nxt+26, nullptr);\n\t\tv[i].cnt=v[i].num=0;\n\t}\n}\nint solve(){\n\tdp[0][0][0][0]=1;\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=0; j<nw; j++){\n\t\t\tfor(int t=0; t<2; t++){\n\t\t\t\tfor(auto p:dp[t][i][j]){\n\t\t\t\t\tint x=p.first;\n\t\t\t\t\tfor(auto y:g[j]){\n\t\t\t\t\t\tif(i+(int)w[y].size()>m) continue;\n\t\t\t\t\t\tnode* v0=&v[x]; int t1=t;\n\t\t\t\t\t\tfor(int l=0; l<w[y].size(); l++){\n\t\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\t\tif(v0->nxt[w[y][l]-'a']){\n\t\t\t\t\t\t\t\t\tv0=v0->nxt[w[y][l]-'a'];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(v0==&v[0]){\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tv0=v0->fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt1+=v0->cnt;\n\t\t\t\t\t\t\tif(t1>1) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(t1>1) continue;\n\t\t\t\t\t\tdp[t1][i+(int)w[y].size()][y][v0->num]+=p.second;\n\t\t\t\t\t\tdp[t1][i+(int)w[y].size()][y][v0->num]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1; i<nw; i++){\n\t\tfor(auto p:dp[1][m][i]){\n\t\t\tans+=p.second;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\twhile(1){\n\t\tinit();\n\t\tcin>>n>>m>>k;\n\t\tif(n==0) return 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>fr[i]>>to[i];\n\t\t\tword[fr[i]]=0, word[to[i]]=0;\n\t\t}\n\t\tnw=1;\n\t\tfor(auto& p:word){\n\t\t\tp.second=nw; w[nw]=p.first; nw++;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tg[word[fr[i]]].push_back(word[to[i]]);\n\t\t}\n\t\tfor(int i=1; i<nw; i++) g[0].push_back(i);\n\t\tns=1;\n\t\tv[0].fail=&v[0];\n\t\tfor(int i=0; i<k; i++){\n\t\t\tstring s; cin>>s;\n\t\t\tadd(s);\n\t\t}\n\t\taddfail();\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m)rep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\tif(dp[i][make_tuple(j,k,l)]==0) continue;\n\t\t\tif(i>0&&j==w) continue;\n\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\tif(ni>m) continue;\n\t\t\t\tint nk=k,nl=l;\n\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t}\n\t\t\t\tif(nl>=2) continue;\n\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t}\n\t\t}\n\t\tll ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t\t// 大量に呼び出す時はnextを全部埋めとくといい\n\t\t\t\t\tint q=p;\n\t\t\t\t\twhile(q && !states[q].next[i]) q = states[q].failure;\n\t\t\t\t\tstates[p].next[i] = states[q].next[i];\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\t// nextが埋まってるならここはいらない\n\t\t// while(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, int> dp[32][2][500];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2)REP(u, strs.size()){\n\t\t\tFOR(p_, dp[i&31][f][u]){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[(i+s.size())&31][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i&31][f][u].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tREP(u, strs.size()){\n\t\t\tFOR(p_, dp[M&31][1][u])ans += p_->second;\n\t\t\tdp[M&31][0][u].clear();\n\t\t\tdp[M&31][1][u].clear();\n\t\t}\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps) cans[i].clear();\n\t\trep(i,ps){\n\t\t\trep(j,ws){\n\t\t\t\tstring st=pre[i]+words[j];\n\t\t\t\tif(st.size()>20) st=st.substr(st.size()-20);\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=pre[i];\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=a[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t\tb[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(b[ni21][ne[j][u]][u]>=mod) b[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) for(int j:cans[i]){\n\t\t\tans+=a[M%21][i][j];\n\t\t\tif(ans>=mod) ans-=mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\nlong long mod=1000000007;\nchar in[30];\nstring table[600];\nvector<int>g[600];\nstruct wolf{\n\tint chi[26];\n\tint mark;\n\tint par;\n\tint fail;\n\tint var;\n\twolf(){\n\t\tfor(int i=0;i<26;i++)chi[i]=-1;mark=0;\n\t\tpar=fail=var=-1;\n\t}\n};\nwolf node[700];\nint ns;\nvoid add(){\n\tint at=0;\n\tfor(int i=0;in[i];i++){\n\t\tif(node[at].chi[in[i]-'a']==-1){\n\t\t\tnode[at].chi[in[i]-'a']=ns;\n\t\t\tnode[ns].par=at;\n\t\t\tnode[ns].var=in[i]-'a';\n\t\t\tat=ns++;\n\t\t}else{\n\t\t\tat=node[at].chi[in[i]-'a'];\n\t\t}\n\t}\n\tnode[at].mark++;\n}\nint n;\nmap<pair<pair<int,int>,pair<int,int> >,int>dp;\nint calc(int a,int b,int c,int d){\n\tpair<pair<int,int>,pair<int,int> >state=make_pair(make_pair(a,b),make_pair(c,d));\n\tif(dp.count(state))return dp[state];\n\tif(a==n){\n\t\tif(d==1)return 1;\n\t\telse return 0;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<g[b].size();i++){\n\t\tint to=c;\n\t\tint cnt=d;\n\t\tint use=g[b][i];\n\t\tif(a+table[use].size()>n)continue;\n\t\tfor(int j=0;j<table[use].size();j++){\n\t\t\twhile(1){\n\t\t\t\tif(node[to].chi[table[use][j]-'a']!=-1){\n\t\t\t\t\tto=node[to].chi[table[use][j]-'a'];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(to==0)break;\n\t\t\t\tto=node[to].fail;\n\t\t\t}\n\t\t\tcnt+=node[to].mark;\n\t\t}\n\t\tif(cnt>1)continue;\n\t\tret=(ret+calc(a+table[use].size(),use,to,cnt))%mod;\n\t}\n//\tprintf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[state]=ret;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=b;\n\t\tmap<string,int> word;\n\t\tfor(int i=0;i<600;i++)g[i].clear();\n\t\tint sz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint P,Q2;\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring p=in;\n\t\t\tif(word.count(p))P=word[p];\n\t\t\telse{\n\t\t\t\tword[p]=sz;\n\t\t\t\ttable[sz]=p;\n\t\t\t\tP=sz++;\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring q=in;\n\t\t\tif(word.count(q))Q2=word[q];\n\t\t\telse{\n\t\t\t\tword[q]=sz;\n\t\t\t\ttable[sz]=q;\n\t\t\t\tQ2=sz++;\n\t\t\t}\n\t\t\tg[P].push_back(Q2);\n\t\t}\n\t\tfor(int i=0;i<600;i++)node[i]=wolf();\n\t\tns=1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tadd();\n\t\t}\n\t\tqueue<int>Q;\n\t\tQ.push(0);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tif(at==0||node[at].par==0)node[at].fail=0;\n\t\t\telse{\n\t\t\t\tint to=node[at].par;\n\t\t\t\twhile(1){\n\t\t\t\t\tint tmp=node[to].fail;\n\t\t\t\t\tif(node[tmp].chi[node[at].var]!=-1){\n\t\t\t\t\t\tnode[at].fail=node[tmp].chi[node[at].var];\n\t\t\t\t\t\tnode[at].mark+=node[node[at].fail].mark;\n\t\t\t\t\t}\n\t\t\t\t\tto=tmp;\n\t\t\t\t\tif(to==0){node[at].fail=0;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<26;i++)if(node[at].chi[i]!=-1){\n\t\t\t\tQ.push(node[at].chi[i]);\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<ns;i++){\n//\t\t\tprintf(\"%d: %d %d\\n\",i,node[i].fail,node[i].mark);\n\t//\t}\n\t\tdp.clear();\n\t\tfor(int i=0;i<sz;i++)g[sz].push_back(i);\n\t\tint ret=calc(0,sz,0,0);\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<int, int>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = vector<V<T>>;\ntemplate <typename T> using VVV = vector<VV<T>>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n \nconst ll INF = (1LL<<60);\nconst int MOD = 1000000007;\n \ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n \nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n// 文字の種類数をtemplate引数で渡す\ntemplate <int types = 26>\nstruct AhoCorasick {\n  // trie木のnode\n  struct node {\n    int fail;\n    V<int> next;\n    V<int> matched;\n    node() : fail(-1), next(types, -1) {}\n  };\n\n  // node の集合\n  V<node> nodes;\n  // 辞書の種類数, trie木の根\n  int sz, root;\n  // 文字と数字の対応付けをする関数\n  function<int(char)> trans;\n\n  // 初期化\n  AhoCorasick() {}\n  AhoCorasick(V<string> pattern, function<int(char)> f = [](char c){return c-'a';}) \n    : sz(pattern.size()), root(0)\n  {\n    nodes.resize(1);\n    trans = f;\n    build(pattern);\n  }\n  // vectorを結合\n  V<int> unite(const V<int> &a, const V<int> &b) {\n    V<int> ret;\n    set_union(ALL(a), ALL(b), back_inserter(ret));\n    return ret;\n  }\n  // 文字列集合patternからtrie木っぽいオートマトンを作成\n  void build(V<string> pattern) {\n    int now;\n    nodes[root].fail = root;\n    REP(i, pattern.size()) {\n      now = root;\n      for(const auto &c: pattern[i]) {\n        if(nodes[now].next[trans(c)] == -1) {\n          nodes.push_back(node());\n          nodes[now].next[trans(c)] = nodes.size() - 1;\n        }\n        now = nodes[now].next[trans(c)];\n      }\n      nodes[now].matched.push_back(i);\n    }\n\n    queue<int> que;\n    REP(i, types) {\n      if(nodes[root].next[i] == -1) {\n        nodes[root].next[i] = root;\n      } else {\n        nodes[nodes[root].next[i]].fail = root;\n        que.push(nodes[root].next[i]);\n      }\n    }\n    while(que.size()) {\n      now = que.front(); que.pop();\n      REP(i, types) {\n        if(nodes[now].next[i] != -1) {\n          int nxt = nodes[now].fail;\n          while(nodes[nxt].next[i] == -1) nxt = nodes[nxt].fail;\n          int nxt_tmp = nodes[now].next[i];\n          nodes[nxt_tmp].fail = nodes[nxt].next[i];\n          nodes[nxt_tmp].matched\n            = unite(nodes[nxt_tmp].matched, nodes[nodes[nxt].next[i]].matched);\n          que.push(nxt_tmp);\n        }\n      }\n    }\n  }\n  // 一文字ずつ照合していく\n  int next(int p, const char c) {\n    while(nodes[p].next[trans(c)] == -1) p = nodes[p].fail;\n    return nodes[p].next[trans(c)];\n  }\n  // 文字列s中に辞書と一致する部分列がどれだけあるか\n  V<int> match(const string s) {\n    V<int> res(sz);\n    int now = root;\n    for(auto c : s) {\n      now = next(now, c);\n      for(auto i : nodes[now].matched) res[i]++;\n    }\n    return res;\n  }\n};\n\nmap<int, int> dp[505][505][2];\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n \n  while(1) {\n    int n, m, K;\n    cin >> n >> m >> K;\n    if(!n) break;\n    V<string> from(n), to(n), sw(K), word(2*n);\n    REP(i, n) {\n      cin >> from[i] >> to[i];\n      word[i] = from[i];\n      word[n+i] = to[i];\n    }\n    REP(i, K) cin >> sw[i];\n\n    REP(i, 505) REP(j, 505) REP(k, 2) dp[i][j][k].clear();\n\n    // 単語iから単語jにつながるか？のリストをつくる\n    sort(ALL(word));\n    word.erase(unique(ALL(word)), word.end());\n    VV<int> g(word.size());\n    REP(i, n) {\n      // from[i] から to[i] へつなぐ\n      int s = -1, t = -1;\n      REP(j, word.size()) {\n        if(word[j] == from[i]) s = j;\n        if(word[j] == to[i]) t = j;\n      }\n      g[s].PB(t);\n    }\n\n    AhoCorasick<26> aho(sw);\n    // 初期状態\n    REP(to, word.size()) {\n      if(word[to].size() > m) continue;\n      int now = 0;\n      int num = 0;\n      for(auto c: word[to]) {\n        now = aho.next(now, c);\n        num += aho.nodes[now].matched.size();\n      }\n      if(num >= 2) continue;\n      (dp[word[to].size()][to][num][now] += 1) %= MOD;\n    }\n\n    // dp[文字列長i][最後の単語k][季語があるかl][あほこらの位置j]\n    REP(i, m) {\n      REP(j, aho.nodes.size()) REP(k, word.size()) REP(l, 2) {\n        if(dp[i][k][l].find(j) == dp[i][k][l].end()) continue;\n        for(auto to: g[k]) {\n          // toに対しての遷移 dp[i+word[to].size()][to][num][now]\n          if(i+word[to].size() > m) continue;\n          int now = j;\n          int num = l;\n          bool flag = false;\n          for(auto c: word[to]) {\n            now = aho.next(now, c);\n            num += aho.nodes[now].matched.size();\n          }\n          if(num >= 2) continue;\n          (dp[i+word[to].size()][to][num][now] += dp[i][k][l][j]) %= MOD;\n        }\n      }\n      REP(k, word.size()) REP(l, 2) dp[i][k][l].clear();\n    }\n\n    int ret = 0;\n    REP(i, aho.nodes.size()) REP(j, word.size()) {\n      (ret += dp[m][j][1][i]) %= MOD;\n      // cout << dp[m][j][1][i] << endl;\n    }\n    cout << ret << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  string last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length <= word_limit; prev_word_length++){\n\tfor(map<State,int>::iterator prev_state_it = dp[prev_word_length].begin();\n\t    prev_state_it != dp[prev_word_length].end();\n\t    prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& from = it->first;\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n\t}\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps) cans[i].clear();\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],a[i21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b,c) make_pair(make_pair(a,b),c)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint cur = 0;\n\nstruct T{\n\tshort id,flag;\n\tT *next[26];\n\tT(){ id = flag=0;for(int i = 0 ; i < 26 ; i++) next[i] = NULL; }\n};\n\nT *rope[1000];\nint bad[1000];\n\nstring ttt[1000];\n\nint n,m,K;\nvoid add(T *root,string s){\n\t//cout << \"[\" << s << \"]\" << endl;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t}else{\n\t\t\troot = root->next[s[i]-'a'] = new T();\n\t\t\trope[cur] = root;\n\t\t\troot->id = cur++;\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tif( ttt[j].size() <= (i+1) ){\n\t\t\t\t\tif( s.substr(i+1-ttt[j].size(),ttt[j].size()) == ttt[j] ){\n\t\t\t\t\t\troot->flag++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool done[1000];\n\nint tmp;\nint exists(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t\ttmp += root->flag;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn root->id;\n}\nvoid failed_generate(T *root,string c,T *src){\n\tif( done[root->id] ) return;\n\telse done[root->id] = true;\n\t//cout << root->id << \": \" << c << \" \" << root->flag << endl;\n\tfor(int i = 0 ; i < 26 ; i++){\n\t\tif( root->next[i] ){\n\t\t\tfailed_generate(root->next[i],c+(char)(i+'a'),src);\n\t\t}else{\n\t\t\t\n\t\t\tstring w = c + (char)(i+'a');\n\t\t\tint idx = 0;\n\t\t\tfor(int j = 0 ; j < w.size() ; j++){\n\t\t\t\tint r = exists(src,w.substr(j));\n\t\t\t\tif( r != -1 ){\n\t\t\t\t\tidx = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot->next[i] = rope[idx];\n\t\t}\n\t}\n}\n\n\nmap<string,int> dic;\nstring ln[500];\n\nvector<int> connect[500];\n\nint mem[610][500];\nint mem2[610][500];\n\nmap<pair<pair<int,int>,int>,int>  dp[21];\n\n/*\nmap< pair< pair<int,int> , pair<int,int> >, int > memo;\nint dfs(int pos,int word,int info,int ok){\n\tif( ok > 1 ) return 0;\n\tpair< pair<int,int>, pair<int,int> > key = make_pair( make_pair(pos,word) , make_pair(info,ok) );\n\t//cout << ln[pos] << \" \" << word << \" \" << info << \" \" << ok << endl;\n\tif( memo.count(key) ) return memo[key];\n\tif( word < 0 ) return 0;\n\tif( word == 0 ) return ok == 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < connect[pos].size() ; i++){\n\t\tans += dfs(connect[pos][i],word - ln[connect[pos][i]].size() , mem[info][connect[pos][i]],ok+mem2[info][connect[pos][i]]);\n\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t}\n\treturn memo[key] = ans;\n}\n*/\nint main(){\n\twhile(cin >> n >> m >> K && n){\n\t\tdic.clear();\n\t\t\n\t\tfor(int i = 0 ; i < 1000 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 500 ; i++) ln[i] = \"\", connect[i].clear();\n\t\tfor(int i = 0 ; i < 1000 ; i++) rope[i] = NULL;\n\t\tfor(int i = 0 ; i < 1000 ; i++)bad[i] = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif( dic.count(a) == 0 ){ int k = dic.size(); dic[a] = k; ln[k] = a;}\n\t\t\tif( dic.count(b) == 0 ){ int k = dic.size(); dic[b] = k; ln[k] = b;}\n\t\t\tconnect[dic[a]].push_back(dic[b]);\n\t\t\t\n\t\t}\n\t\tT *root = new T();\n\t\trope[0] = root;\n\t\tcur = 1;\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tstring l;\n\t\t\tcin >> l;\n\t\t\tttt[i] = l;\n\t\t\t//cout << l << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tadd(root,ttt[i]);\n\t\t}\n\t\t\n\t\tfailed_generate(root,\"\",root);\n\t\t\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tfor(int k = 0 ; k < dic.size() ; k++){\n\t\t\t\ttmp = 0;\n\t\t\t\tmem[i][k] = exists(rope[i],ln[k]);\n\t\t\t\tmem2[i][k] = tmp;\n\t\t\t\t//cout << i << \" \" << ln[k] << \" \" << tmp << \" \" << mem[i][k] << \" \" << mem2[i][k] << endl;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < 21 ; i++) dp[i].clear();\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tif( mem2[0][i] < 2 ) dp[ln[i].size()][mp(i,mem[0][i],mem2[0][i])] = 1;\n\t\t}\n\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tEACH(it,dp[i%21]){\n\t\t\t\tint j = it->first.first.first;\n\t\t\t\tint k = it->first.first.second;\n\t\t\t\tint f = it->first.second;\n\t\t\t\tint v = it->second;\n\t\t\t\tfor(int l = 0 ; l < connect[j].size() ; l++){\n\t\t\t\t\tif( i + ln[connect[j][l]].size() <= m && f+mem2[k][connect[j][l]] < 2 ){\n\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][mp(connect[j][l],mem[k][connect[j][l]],f+mem2[k][connect[j][l]])] += v;\n\t\t\t\t\t\tif( dp[(i+ln[connect[j][l]].size())%21][mp(connect[j][l],mem[k][connect[j][l]],f+mem2[k][connect[j][l]])] >= 1000000007 ){\n\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][mp(connect[j][l],mem[k][connect[j][l]],f+mem2[k][connect[j][l]])] -= 1000000007;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i%21].clear();\n\t\t}\n\t\tEACH(it,dp[m%21]){\n\t\t\tint j = it->first.first.first;\n\t\t\tint k = it->first.first.second;\n\t\t\tint f = it->first.second;\n\t\t\tint v = it->second;\n\t\t\tif( f == 1 ) ans += v;\n\t\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n  return 0;\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[256];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nconst int MD=21;\nint dp[MD][500][600][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%MD][w][x][res+t]+=dp[pos%MD][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%MD][0][0],dp[pos%MD][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%MD][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass PMA\n{\n    int n;\n    vector<vector<int> > next;\n    vector<bitset<32> > match;\n    vector<int> failure;\npublic:\n    PMA(const vector<string>& pattern){\n        next.assign(1, vector<int>(128, -1));\n        match.assign(1, 0);\n        for(unsigned i=0; i<pattern.size(); ++i){\n            int curr = 0;\n            for(unsigned j=0; j<pattern[i].size(); ++j){\n                if(next[curr][pattern[i][j]] == -1){\n                    next[curr][pattern[i][j]] = next.size();\n                    next.push_back(vector<int>(128, -1));\n                    match.push_back(0);\n                }\n                curr = next[curr][pattern[i][j]];\n            }\n            match[curr][i] = true;\n        }\n\n        n = next.size();\n        failure.resize(n, 0);\n        vector<int> node1(1, 0);\n        while(!node1.empty()){\n            vector<int> node2;\n            for(unsigned i=0; i<node1.size(); ++i){\n                for(int j=0; j<128; ++j){\n                    int s = node1[i];\n                    if(next[s][j] == -1)\n                        continue;\n                    node2.push_back(next[s][j]);\n                    int t = s;\n                    while(t != 0){\n                        if(next[failure[t]][j] != -1){\n                            failure[next[s][j]] = next[failure[t]][j];\n                            match[next[s][j]] |= match[next[failure[t]][j]];\n                            break;\n                        }\n                        t = failure[t];\n                    }\n                }\n            }\n            node1.swap(node2);\n        }\n    }\n    int size(){\n        return n;\n    }\n    int transition(int curr, char c){\n        if(next[curr][c] != -1)\n            return next[curr][c];\n        if(curr == 0)\n            return 0;\n        return transition(failure[curr], c);\n    }\n    bitset<32> checkMatch(int curr){\n        return match[curr];\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        index.insert(make_pair(\"\", 0));\n        vector<string> word(1, \"\");\n        vector<vector<int> > connect(1);\n        for(int i=0; i<n; ++i){\n            string from, to;\n            cin >> from >> to;\n            int j, k;\n            if(index.find(from) == index.end()){\n                j = index.size();\n                index[from] = j;\n                word.push_back(from);\n                connect.resize(connect.size()+1);\n            }else{\n                j = index[from];\n            }\n            if(index.find(to) == index.end()){\n                k = index.size();\n                index[to] = k;\n                word.push_back(to);\n                connect.resize(connect.size()+1);\n            }else{\n                k = index[to];\n            }\n            connect[j].push_back(k);\n        }\n        n = index.size();\n        for(int i=1; i<n; ++i)\n            connect[0].push_back(i);\n\n        vector<string> season(p);\n        for(int i=0; i<p; ++i)\n            cin >> season[i];\n        PMA pma(season);\n        p = pma.size();\n\n        map<pair<pair<int, int>, pair<int, int> >, int> num;\n        num[make_pair(make_pair(0, 0), make_pair(0, 0))] = 1;\n        int ret = 0;\n        while(!num.empty()){\n            int a = num.begin()->first.first.first;\n            int b = num.begin()->first.first.second;\n            int c = num.begin()->first.second.first;\n            int d = num.begin()->first.second.second;\n            int x = num.begin()->second;\n            num.erase(num.begin());\n\n            for(int i=0; i<connect[b].size(); ++i){\n                int b2 = connect[b][i];\n                int a2 = a + word[b2].size();\n                if(a2 > m)\n                    continue;\n                int c2 = c;\n                int d2 = d;\n                for(unsigned j=0; j<word[b2].size(); ++j){\n                    c2 = pma.transition(c2, word[b2][j]);\n                    d2 += pma.checkMatch(c2).count();\n                }\n                if(d2 > 1)\n                    continue;\n\n                if(a2 == m){\n                    if(d2 == 1){\n                        ret += x;\n                        ret %= MOD;\n                    }\n                }else{\n                    (num[make_pair(make_pair(a2, b2), make_pair(c2, d2))] += x) %= MOD;\n                }\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    const string& from = it->first;\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\tif(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n      }\n      dp[prev_word_length].clear();\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t\t// 大量に呼び出す時はnextを全部埋めとくといい\n\t\t\t\t\tint q=p;\n\t\t\t\t\twhile(q && !states[q].next[i]) q = states[q].failure;\n\t\t\t\t\tstates[p].next[i] = states[q].next[i];\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\t// nextが埋まってるならここはいらない\n\t\t// while(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, int> dp[32][2][500];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2)REP(u, strs.size()){\n\t\t\tFOR(p_, dp[i&31][f][u]){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[(i+s.size())&31][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i&31][f][u].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tREP(u, strs.size()){\n\t\t\tFOR(p_, dp[M&31][1][u])ans += p_->second;\n\t\t\tdp[M&31][0][u].clear();\n\t\t\tdp[M&31][1][u].clear();\n\t\t}\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][505][22][606];\nInt used[2][2][505][22][606];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    memset(dp,0,sizeof(dp));\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    \n    auto mfill=[&](Int f){\n      for(Int i=0;i<2;i++)\n\tfor(Int j=0;j<505;j++)\n\t  for(Int k=0;k<22;k++)\n\t    for(Int l=0;l<606;l++)\n\t      dp[i][f][j][k][l]=used[i][f][j][k][l]=0;\n    };\n    \n    Int pre=-1;\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      if(pre!=d){\n\tmfill(!f);\n\tpre=d;\n      }\n     \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) continue;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) continue;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n//BEGIN CUT HERE\ntemplate<size_t X>\nstruct Trie{\n  struct Node{\n    char c;\n    array<int, X> nxt;\n    vector<int> idxs;\n    int idx;\n    Node(char c):c(c),idx(-1){fill(nxt.begin(),nxt.end(),-1);}\n  };\n\n  using F = function<int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,int x){\n    int pos=0;\n    for(int i=0;i<(int)s.size();i++){\n      int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n        pos=v[pos].nxt[k];\n        continue;\n      }\n      int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  int find(const string &s){\n    int pos=0;\n    for(int i=0;i<(int)s.size();i++){\n      int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  int find(int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  int idx(int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<int> idxs(int pos){\n    return pos<0?vector<int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<size_t X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    int n=v.size();\n    cnt.resize(n);\n    for(int i=0;i<n;i++){\n      if(heavy) sort(v[i].idxs.begin(),v[i].idxs.end());      \n      cnt[i]=v[i].idxs.size();\n    }\n    \n    queue<int> q;\n    for(int i=0;i<(int)X;i++){\n      if(~v[0].nxt[i]){\n        v[v[0].nxt[i]].nxt[X]=0;\n        q.emplace(v[0].nxt[i]);\n      }else{\n        v[0].nxt[i]=0;\n      }      \n    }\n    \n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(int i=0;i<(int)X;i++){\n        if(x.nxt[i]<0) continue;\n        int fail=x.nxt[X];\n        while(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n        v[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n        if(heavy){\n          auto &idx=v[x.nxt[i]].idxs;\n          auto &idy=v[v[fail].nxt[i]].idxs;\n          vector<int> idz;\n          set_union(idx.begin(),idx.end(),\n                    idy.begin(),idy.end(),\n                    back_inserter(idz));\n          idx=idz;\n        }\n        q.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<int> match(string s,int heavy=true){\n    auto &v=TRIE::v;\n    vector<int> res(heavy?TRIE::size():1);\n    int pos=0;\n    for(auto &c:s){\n      int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  int move(int pos,char c){\n    auto &v=TRIE::v;\n    int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n\n  int count(int pos){\n    return cnt[pos];\n  }\n};\n\n//END CUT HERE\n\n//INSERT ABOVE HERE\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\nsigned dp[2][2][501][21][601];\nbool used[2][2][501][21][601];\n\nsigned AOJ_2257(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;      \n      \n      if(p==(Int)v[x].size()){\n        for(Int y:G[x]){\n          Int npos=aho.move(pos,v[y][0]);\n          if(aho.cnt[npos]>1) continue;\n          Int nc=aho.cnt[npos];\n          if(c&&nc) continue;\n          dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n          dp[c||nc][!f][y][1][npos]%=MOD;\n          if(!used[c||nc][!f][y][1][npos])\n            q.emplace((c||nc),d+1,y,1,npos);\n          used[c||nc][!f][y][1][npos]=1;\n        }\n      }else{\n        Int npos=aho.move(pos,v[x][p]);\n        Int np=p+1;\n        if(aho.cnt[npos]>1) goto END;\n        Int nc=aho.cnt[npos];\n        if(c&&nc) goto END;\n        dp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n        dp[c||nc][!f][x][np][npos]%=MOD;\n        if(!used[c||nc][!f][x][np][npos])\n          q.emplace((c||nc),d+1,x,np,npos);\n        used[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n        ans+=dp[1][m&1][i][v[i].size()][j];\n        ans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/05/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2257\n*/\n\nsigned SPOJ_BLHETA(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  string s;\n  cin>>s;\n    \n  int n;\n  cin>>n;\n  vector<string> ts(n);\n  for(int i=0;i<n;i++)cin>>ts[i];\n  \n  auto conv=[](char c){return c-'A';};\n  AhoCorasick<26> aho(conv);\n  for(int i=0;i<n;i++){\n    aho.add(ts[i],i);\n  }\n  aho.build();\n\n  int l=s.size();\n  int pos=0;\n  \n  vector<int> vs;\n  vs.emplace_back(pos);\n\n  string ans;\n  for(int i=0;i<l;i++){    \n    pos=aho.move(pos,s[i]);\n    vs.emplace_back(pos);\n    ans+=s[i];\n    if(aho.count(pos)){\n      int k=aho.v[pos].idxs[0];\n      for(int j=0;j<(int)ts[k].size();j++){\n        vs.pop_back();\n        pos=vs.back();\n        ans.pop_back();\n      }\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/05/24\n  https://www.spoj.com/problems/BLHETA/\n*/\n\n\nsigned main(){\n  AOJ_2257();\n  //SPOJ_BLHETA();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nconstexpr int mod = 1e9 + 7;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n    auto val = table(args...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\n\nstruct alphabets { // example: lower letters\n    static int const size = 26;\n    static int convert(char c) {\n\t\tassert('a' <= c && c <= 'z');\n\t\treturn c - 'a';\n    }\n    static char convert_inv(int i) {\n\t\tassert(0 <= i && i < size);\n\t\treturn 'a' + i;\n    }\n};\n\ntemplate <typename Alphabets>\nclass aho_corasick {\n    static const int invalid_idx = -1;\n\n    struct PMA {\n        int fail;\n        std::vector<int> next, accept;\n\n        PMA() : fail(invalid_idx), next(Alphabets::size, invalid_idx) {}\n    };\n\npublic:\n    aho_corasick(std::vector<std::string> const& ts)\n    : K(ts.size()) {\n        const int root_idx = 0;\n        nodes.push_back(std::make_unique<PMA>()); // root node\n        nodes[root_idx]->fail = root_idx; // root idx\n        for(int i = 0; i < K; ++i) {\n            int now = root_idx;\n            for(auto cc : ts[i]) {\n                int c = Alphabets::convert(cc);\n                if(nodes[now]->next[c] == invalid_idx) {\n                    nodes[now]->next[c] = static_cast<int>(nodes.size());\n                    nodes.push_back(std::make_unique<PMA>());\n                }\n                now = nodes[now]->next[c];\n            }\n            nodes[now]->accept.push_back(i);\n        }\n\n        std::queue<int> que;\n        for(int c = 0; c < Alphabets::size; ++c) {\n            if(nodes[root_idx]->next[c] != invalid_idx) {\n                nodes[nodes[root_idx]->next[c]]->fail = root_idx;\n                que.push(nodes[root_idx]->next[c]);\n            }\n        }\n        while(!que.empty()) {\n            int now = que.front();\n            que.pop();\n            for(int c = 0; c < Alphabets::size; ++c) {\n                if(nodes[now]->next[c] != invalid_idx) {\n                    que.push(nodes[now]->next[c]);\n                    int nxt = transition(nodes[now]->fail, Alphabets::convert_inv(c));\n                    nodes[nodes[now]->next[c]]->fail = nxt;\n                    for(auto ac : nodes[nxt]->accept) {\n                        nodes[nodes[now]->next[c]]->accept.push_back(ac);\n                    }\n                }\n            }\n        }\n    }\n\n    int transition(int node_idx, char cc) {\n        assert(0 <= node_idx && node_idx < static_cast<int>(nodes.size()));\n        int c = Alphabets::convert(cc);\n        int now = node_idx;\n        while(nodes[now]->next[c] == invalid_idx && now != 0) {\n            now = nodes[now]->fail;\n        }\n        now = nodes[now]->next[c];\n        if(now == invalid_idx) now = 0;\n        return now;\n    }\n\n    int accept_size(int node_idx) const {\n        assert(0 <= node_idx && node_idx < static_cast<int>(nodes.size()));\n        return nodes[node_idx]->accept.size();\n    }\n\n    int node_size() const {\n        return static_cast<int>(nodes.size());\n    }\n\nprivate:\n    const int K;\n    std::vector<std::unique_ptr<PMA>> nodes;\n};\n\nint main() {\n    int n, m, k;\n    while(cin >> n >> m >> k, n) {\n        vector<string> ss = {\"\"}; // empty (start node)\n        vector<string> from(n), to(n), seasonwords(k);\n        for(int i = 0; i < n; ++i) {\n            cin >> from[i] >> to[i];\n            ss.push_back(from[i]), ss.push_back(to[i]);\n        }\n        for(int i = 0; i < k; ++i) {\n            cin >> seasonwords[i];\n        }\n        sort(begin(ss), end(ss));\n        ss.erase(unique(begin(ss), end(ss)), end(ss));\n        const int s_sz = ss.size();\n        vector<vector<int>> g(s_sz);\n        for(int i = 0; i < n; ++i) {\n            const int s = lower_bound(begin(ss), end(ss), from[i]) - begin(ss);\n            const int t = lower_bound(begin(ss), end(ss), to[i]) - begin(ss);\n            g[s].push_back(t);\n        }\n        for(int i = 1; i < s_sz; ++i) {\n            g[0].push_back(i);\n        }\n\n        aho_corasick<alphabets> aho(seasonwords);\n        vector<vector<map<pii, int>>> dp(m + 1, vector<map<pii, int>>(2));\n        dp[0][0][make_pair(0, 0)] = 1;\n        for(int len = 0; len < m; ++len) {\n            for(int s = 0; s < 2; ++s) {\n                for(auto& p : dp[len][s]) {\n                    const int nid = p.first.first, sid = p.first.second;\n                    for(auto t : g[sid]) {\n                        auto& to_str = ss[t];\n                        if((int)to_str.size() + len > m) continue;\n                        int now = nid, ac_sz = s;\n                        for(auto c : to_str) {\n                            now = aho.transition(now, c);\n                            ac_sz += aho.accept_size(now);\n                        }\n                        if(ac_sz >= 2) continue;\n                        (dp[to_str.size() + len][ac_sz][make_pair(now, t)] += p.second) %= mod;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for(auto& p : dp[m][1]) {\n            (ans += p.second) %= mod;\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[256];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nint dp[30][312][612][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%30][w][x][res+t]+=dp[pos%30][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%30][0][0],dp[pos%30][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%30][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nconst int NUMC = 26;\n\nclass Trie {\npublic:\n\tvector<vector<int> > V;\n\tint find(string s) {\n\t\tint cur=0;\n\t\trep(i,s.size()){\n            if((cur=V[cur][s[i]+1])==0) return -1;\n        }\n\t\treturn cur;\n\t}\n\tvoid create(vector<string> S){\n\t\tV.clear();\n\t\tV.push_back(vector<int>(NUMC+1));\n\t\tsort(S.begin(),S.end());\n\t\trep(i,S.size()){\n\t\t\tint cur=0;\n\t\t\trep(j,S[i].size()){\n\t\t\t\tif(V[cur][S[i][j]+1]==0) V.push_back(vector<int>(NUMC+1)),V[cur][S[i][j]+1]=V.size()-1;\n\t\t\t\tcur=V[cur][S[i][j]+1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass ACmatch_num {\npublic:\n\tTrie t;\n\tvector<int> acc;\n\tint ma;\n\tvoid create(vector<string> S) {\n        rep(i,(int)S.size()){\n            rep(j,(int)S[i].size()){\n                S[i][j] -= 'a';\n            }\n        }\n\t\tint i;\n\t\tma=S.size();\n\t\tt.create(S);\n\t\tacc.clear();\n\t\tacc.resize(t.V.size());\n\t\trep(i,S.size()) acc[t.find(S[i])]++;\n\t\tqueue<int> Q;\n\t\trep(i,NUMC) if(t.V[0][i+1]) t.V[t.V[0][i+1]][0]=0, Q.push(t.V[0][i+1]);\n\n\t\twhile(!Q.empty()) {\n\t\t\tint k=Q.front(); Q.pop();\n\t\t\trep(i,NUMC) if(t.V[k][i+1]) {\n\t\t\t\tQ.push(t.V[k][i+1]);\n\t\t\t\tint pre=t.V[k][0];\n\t\t\t\twhile(pre && t.V[pre][i+1]==0) pre=t.V[pre][0];\n\t\t\t\tt.V[t.V[k][i+1]][0]=t.V[pre][i+1];\n\t\t\t\tacc[t.V[k][i+1]] += acc[t.V[pre][i+1]];\n\t\t\t}\n\t\t}\n\t}\n\tint match(string S) {\n        rep(i,(int)S.size()){\n            S[i] -= 'a';\n        }\n\t\tint R=0;\n\t\tint cur=0;\n\t\trep(i,(int)S.size()){\n\t\t\twhile(cur && t.V[cur][S[i]+1]==0) cur=t.V[cur][0];\n\t\t\tcur=t.V[cur][S[i]+1];\n\t\t\tR += acc[cur];\n\t\t}\n\t\treturn R;\n\t}\n};\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nvector<int> G[501];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,K;\n        cin >> n >> m >> K;\n        if(n == 0){\n            break;\n        }\n        rep(i,501){\n            G[i].clear();\n        }\n        map<string,int> mp;\n        vs s,t(K);\n        int num = 0;\n        rep(i,n){\n            string a,b;\n            cin >> a >> b;\n            if(mp.find(a) == mp.end()){\n                s.pb(a);\n                mp[a] = num++;\n            }\n            if(mp.find(b) == mp.end()){\n                s.pb(b);\n                mp[b] = num++;\n            }\n            G[mp[a]].pb(mp[b]);\n        }\n        rep(i,num-1){\n            G[num].pb(i);\n        }\n        int comp[31][21][21];\n        vector<RollingHash> rh(K);\n        map<pll,vi> st[21];\n        rep(i,K){\n            cin >> t[i];\n            rh[i].init(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    st[k-j][rh[i].hash(j,k)] = {i,j,k};\n                }\n            }\n        }\n        ACmatch_num an;\n        an.create(t);\n        // cout << an.match(\"sakura\") << \"\\n\";\n        // cout << an.match(\"sakur\") << \"\\n\";\n        rep(i,K){\n            // show(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    // cout << j << \" \" << k << \"\\n\";\n                    comp[i][j][k] = an.match(t[i].substr(j,k-j+1));\n                }\n            }\n        }\n        map<vi,ll> dp[501];\n        dp[0][{-1,0,0,num,0}] = 1;\n        rep(i,m){\n            each(it,dp[i]){\n                int idx = it.fi[0], idy = it.fi[1], idz = it.fi[2],pre = it.fi[3],nw = it.fi[4];\n                ll val = it.se;\n                each(j,G[pre]){\n                    if(i+len(s[j]) > m){\n                        continue;\n                    }\n                    string cri;\n                    int diff = 0;\n                    if(idx == -1){\n                        cri = s[j];\n                    }else{\n                        cri = t[idx].substr(idy,idz-idy+1);\n                        cri += s[j];\n                        diff = comp[idx][idy][idz];\n                    }\n                    RollingHash ch;\n                    ch.init(cri);\n                    vi nx = {-1,0,0};\n                    for(int id=len(cri)-1;id>=0;id--){\n                        if(len(st[len(cri)-id-1]) == 0){\n                            break;\n                        }\n                        pll foo = ch.hash(id,len(cri)-1);\n                        if(st[len(cri)-id-1].find(foo) == st[len(cri)-id-1].end()){\n                            break;\n                        }else{\n                            nx = st[len(cri)-id-1][foo];\n                        }\n                    }\n                    int res = an.match(cri) - diff;\n                    if(res == 1){\n                        if(nw == 0){\n                            dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] + val) % MOD;\n                        }\n                    }else{\n                        dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] + val) % MOD;\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        each(it,dp[m]){\n            ans += it.se;\n        }\n        cout << ans % MOD << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct PMA{\n\tPMA *next[0x100];\n\tvector<int> accept;\n};\nint sz;\nPMA pma[1000];\nPMA *mynew(){\n\trep(i, 256) pma[sz].next[i] = 0;\n\tpma[sz].accept.clear();\n\treturn pma + sz++;\n}\nPMA *buildPMA(const vector<string> &p) {\n\tPMA *root = mynew();\n\trep(i, p.size()){\n\t\tPMA *t = root;\n\t\trep(j, p[i].size()){\n\t\t\tchar c = p[i][j];\n\t\t\tif(t->next[c] == NULL) t->next[c] = mynew();\n\t\t\tt = t->next[c];\n\t\t}\n\t\tt->accept.pb(i);\n\t}\n\tqueue<PMA*> Q;\n\tfor(char c = 'A'; c <= 'z'; c++){\n\t\tif (root->next[c]) {\n\t\t\troot->next[c]->next[0] = root;\n\t\t\tQ.push(root->next[c]);\n\t\t}\n\t\telse root->next[c] = root;\n\t}\n\twhile(!Q.empty()){\n\t\tPMA *t = Q.front();\n\t\tQ.pop();\n\t\tfor(char c = 'A'; c <= 'z'; c++){\n\t\t\tif(t->next[c]){\n\t\t\t\tQ.push(t->next[c]);\n\t\t\t\tPMA *r = t->next[0];\n\t\t\t\twhile(!r->next[c]) r = r->next[0];\n\t\t\t\tt->next[c]->next[0] = r->next[c];\n\t\t\t\teach(i, r->next[c]->accept) t->next[c]->accept.pb(*i);\n\t\t\t}\n\t\t}\n\t}\n\treturn root;\n}\n\nconst int mod = (int)1e9 + 7;\nint n, m, k, N, dp[22][500][610][2]; //文字数, prev, state, match\nvector<vi> e;\nstring a[300], b[300];\nvector<string> c, v;\npi memo[610][500];\npi next(PMA *p, int s) {\n\tpi &res = memo[p - pma][s];\n\tif(res.second >= 0) return res;\n\tint count = 0;\n\trep(i, v[s].size()){\n\t\tchar c = v[s][i];\n\t\twhile (!p->next[c]) p = p->next[0];\n\t\tp = p->next[c];\n\t\trep(j, p->accept.size()) count++;\n\t}\n\treturn res = mp(p - pma, count);\n}\n\nint main(){\n\twhile(cin >> n >> m >> k, n){\n\t\tv.clear();\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> a[i] >> b[i], v.pb(a[i]), v.pb(b[i]);\n\t\tsort(all(v));\n\t\tv.erase(unique(all(v)), v.end());\n\t\t\n\t\te.clear(); e.resize(v.size());\n\t\trep(i, n){\n\t\t\tint p = lower_bound(all(v), a[i]) - v.begin();\n\t\t\tint q = lower_bound(all(v), b[i]) - v.begin();\n\t\t\te[p].pb(q);\n\t\t}\n\t\tc.clear(); c.resize(k);\n\t\trep(i, k) cin >> c[i];\n\t\tsz = 0;\n\t\tPMA* r = buildPMA(c);\n\t\t\n\t\trep(i, sz) rep(j, v.size()) memo[i][j].second = -1;\n\t\t\n\t\trep(i, v.size()){\n\t\t\tpi x = next(r, i);\n\t\t\tif(v[i].size() < m && x.second < 2) dp[v[i].size() % 22][i][x.first][x.second] = 1;\n\t\t}\n\t\trep(i, m){\n\t\t\tmemset(dp[(i + 21) % 22], 0, sizeof(dp[0]));\n\t\t\trep(j, v.size()) rep(k, sz) rep(l, 2) if(dp[i % 22][j][k][l]){\n\t\t\t\trep(h, e[j].size()){\n\t\t\t\t\tpi x = next(pma + k, e[j][h]);\n\t\t\t\t\tint ni = v[e[j][h]].size() + i;\n\t\t\t\t\tif(ni <= m && x.second + l < 2)\n\t\t\t\t\t(dp[ni % 22][e[j][h]][x.first][x.second + l] += dp[i % 22][j][k][l]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\trep(i, v.size()) rep(j, sz) (res += dp[m % 22][i][j][1]) %= mod;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define MOD 1000000007\n\nclass State\n{\npublic:\n\tint pv,pl,f;\n\tState(int pv, int pl, int f)\n\t\t:pv(pv),pl(pl),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(pv!=s.pv) return pv<s.pv;\n\t\tif(pl!=s.pl) return pl<s.pl;\n\n\t\treturn f<s.f;\n\t}\n};\n\nmap<State, int> dp[21];\nconst int WL = 21;\n//[前につかったやつ(500)][どこまで(500)][PMAどこまで(20)][季語の有無(2)]=数%100000007\nint Psz;\n\nstruct PMA {\n\tint n;\n\tPMA *next[0x100]; // next[0] is for fail\n\tvector<int> accept;\n\tPMA() { fill(next, next+0x100, (PMA*)0); }\n\tPMA(int a)\n\t{\n\t\tn=a;\n\t\tfill(next, next+0x100, (PMA*)0);\n\t}\n};\nPMA *buildPMA(vector<string>& p, vector<PMA*>& vpma, int size) {\n  Psz=0;\n  PMA *root = new PMA(Psz++);\n  vpma.push_back(root);\n  for (int i = 0; i < size; ++i) { // make trie\n    PMA *t = root;\n    for (int j = 0; j<p[i].size(); ++j) {\n      char c = p[i][j];\n      if (t->next[c] == NULL) \n\t  {\n\t\t  t->next[c] = new PMA(Psz++);\n\t\t  vpma.push_back(t->next[c]);\n\t  }\n      t = t->next[c];\n    }\n    //t->accept.push_back(i);\n  }\n  queue<PMA*> Q; // make failure link using bfs\n  for (int c = 'a'; c <= 'z'; ++c) {\n    if (root->next[c]) {\n      root->next[c]->next[0] = root;\n      Q.push(root->next[c]);\n    } else root->next[c] = root;\n  }\n  while (!Q.empty()) {\n    PMA *t = Q.front(); Q.pop();\n    for (int c = 'a'; c <= 'z'; ++c) {\n      if (t->next[c]) {\n        Q.push(t->next[c]);\n        PMA *r = t->next[0];\n        while (!r->next[c]) r = r->next[0];\n        t->next[c]->next[0] = r->next[c];\n      }\n    }\n  }\n  return root;\n}\n\nbool g[500][500];\n\nint match(string t, PMA *v, int &ret) {\n  int n = t.size();\n  int r = v->n;\n\n  for (int i = 0; i < n; ++i) {\n    char c = t[i];\n    while (!v->next[c]) v = v->next[0];\n    v = v->next[c];\n\tr = v->n;\n\tret+=v->accept.size();\n  }\n\n  return r;\n}\n\nvoid aaa(PMA* p, int n, string w)\n{\n    PMA *t = p;\n    for (int j = 0; j<w.size(); ++j) {\n      char c = w[j];\n      if (t->next[c] == NULL) return;\n      t = t->next[c];\n    }\n\tfor(int i=0; i<t->accept.size(); i++)\n\t\tif(t->accept[i]==n) return;\n    t->accept.push_back(n);\n}\n\nint kigo[505][25];\nint nextpma[505][25];\n\nint main()\n{\n\tint N,M,K;\n\twhile(cin >> N >> M >> K, (N||M||K))\n\t{\n\t\tfor(int i=0; i<WL; i++)\n\t\t\tdp[i].clear();\n\n\t\tmemset(g,0,sizeof(g));\n\t\tmemset(kigo, 0, sizeof(kigo));\n\n\t\tint d=0;\n\t\tmap<string, int> dic;\n\t\tvector<string> w(K);\n\t\tvector<string> str;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tcin >> s >> t;\n\t\t\tif(!dic.count(s)) \n\t\t\t{\n\t\t\t\tdic[s]=d++;\n\t\t\t\tstr.push_back(s);\n\t\t\t}\n\t\t\tif(!dic.count(t)) \n\t\t\t{\n\t\t\t\tdic[t]=d++;\n\t\t\t\tstr.push_back(t);\n\t\t\t}\n\n\t\t\tg[dic[s]][dic[t]]=1;\n\t\t}\n\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tw[i]=t;\n\t\t}\n\n\t\tvector<PMA*> vpma;\n\t\tPMA* tree=buildPMA(w,vpma,w.size());\n\t\tfor(int j=0; j<K; j++)\n\t\tfor(int i=0; i<Psz; i++)\n\t\t{\n\t\t\tPMA* p=vpma[i];\n\t\t\taaa(p, j, w[j]);\n\t\t}\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\tfor(int j=0; j<str.size(); j++)\n\t\t\tnextpma[j][i] = match(str[j], vpma[i], kigo[j][i]);\n\n\t\tfor(int i=0; i<str.size(); i++)\n\t\t{\n\t\t\tif(kigo[i][0]>1) continue;\n\t\t\tState s=State(i,nextpma[i][0],kigo[i][0]);\n\n\t\t\tint l = str[i].size();\n\t\t\tdp[l][s]=1;\n\t\t}\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tfor(map<State, int>::iterator it = dp[i%WL].begin(); it != dp[i%WL].end(); it++)\n\t\t\t{\n\t\t\t\tState t=it->first;\n\t\t\t\tint val = it->second;\n\t\t\t\n\t\t\t\tfor(int m=0; m<str.size(); m++)\n\t\t\t\t{\n\t\t\t\t\tif(!g[t.pv][m]) continue;\n\n\t\t\t\t\tint k = t.pl;\n\t\t\t\t\tint twl=i+str[m].size();\n\t\t\t\t\tint r=nextpma[m][k];\n\t\t\t\t\tint tf=t.f+kigo[m][k];\n\n\t\t\t\t\tif(twl>M) continue;\n\t\t\t\t\tif(tf>1) continue;\n\n\t\t\t\t\tState ns = State(m,r, tf);\n\n\t\t\t\t\tif(!dp[twl%WL].count(ns)) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl%WL][ns]=val;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl%WL][ns]+=val;\n\t\t\t\t\t\tdp[twl%WL][ns]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\t\t\tdp[i%WL].clear();\n\n\t\t}\n\n\t\tint ret=0;\n\t\tfor(map<State, int>::iterator it = dp[M%WL].begin(); it != dp[M%WL].end(); it++)\n\t\t{\n\t\t\tState s=it->first;\n\t\t\tif(s.f != 1) continue;\n\t\t\tret+=dp[M%WL][s];\n\t\t\tret%=MOD;\n\t\t}\n\n\t\tcout << ret << endl;\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\t\tdelete vpma[i];\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <map>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\n#define DEB 0\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n/*----------------------------------------------------\n  Aho-Corasick\n  ----------------------------------------------------*/\nstruct PMA{\n  PMA *next[27]; // next[0] is for fail\n  vector<int> accept;\n  PMA(){ fill(next, next+27, (PMA*)0); }\n};\n\nPMA *buildPMA(const vector<string>& p){\n  PMA *root = new PMA;\n  rep(i,p.size()){ // make trie\n    PMA *t = root;\n    rep(j,p[i].size()){\n      char c = p[i][j] -'a'+1;\n      if( t->next[c]==NULL ) t->next[c] = new PMA;\n      t = t->next[c];\n    }\n    t->accept.push_back(i);\n  }\n  queue<PMA*> q; // make failure link using bfs\n  // init \n  for(int c=1; c<27; ++c){ // lower\n    if( root->next[c] ){\n      root->next[c]->next[0] = root;\n      q.push(root->next[c]);\n    }else{\n      root->next[c] = root;\n    }\n  }\n  while( !q.empty() ){\n    PMA *t = q.front(); q.pop();\n    for(int c=1; c<27; ++c)if( t->next[c] ){  // lower\n      q.push(t->next[c]);\n      PMA *r = t->next[0];\n      while( !r->next[c] ){\n        r=r->next[0];\n      }\n      t->next[c]->next[0] = r->next[c];\n    }\n  }\n  return root;\n}\nPMA *next_PMA(const string& str, PMA *v, int *result){\n  PMA *ret = v;\n  rep(i,str.length()){\n    char c = str[i] -'a' + 1;\n    while( !ret->next[c] ) ret=ret->next[0];\n    ret = ret->next[c];\n    *result += ret->accept.size();\n    if( ret->next[0] ) *result += ret->next[0]->accept.size();\n    if( *result>1 ) return ret;\n  }\n  return ret;\n}\n\nconst int mod = 1000000007;\nint n,m,k;\n//bool edge[510][510];\nvector<int> edge[510];\nvector<int> fm;\nset<int> fmms;\nmap<string,int> ms;\nmap<PMA*,int> dp[2][510][510]; // [kigo][n][edge] [PMA]\nvector<string> kigo;\n//vector<pair<string,string> > se;\n//vector<pair<int,int> > edge;\n\nint main(){\n  while(cin>>n>>m>>k,n|m|k){\n    kigo.clear();\n    ms.clear();\n    //se.clear();\n    rep(i,510)rep(j,510){\n      dp[0][i][j].clear(); dp[1][i][j].clear();\n    }\n    //memset(edge,false,sizeof(edge));\n    rep(i,510)edge[i].clear();\n    fm.clear();\n    fmms.clear();\n    //edge.clear();\n    \n    rep(i,n){\n      string a,b; cin>>a>>b;\n      int c,d;\n      if( ms.count(a) ) c=ms[a]; else{ c=ms.size(); ms[a]=c; }\n      if( ms.count(b) ) d=ms[b]; else{ d=ms.size(); ms[b]=d; }\n      //edge[c][d] = true;\n      edge[c].push_back(d);\n      if( fmms.find(c)==fmms.end() ){\n        fmms.insert(c);\n        fm.push_back(c);\n      }\n      //se.push_back(make_pair(a,b));\n    }\n    rep(i,k){\n      string a; cin>>a;\n      kigo.push_back(a);\n    }\n    PMA *root = buildPMA(kigo);\n\n#if DEB\n    rep(i,fm.size()){\n      int from = fm[i];\n      rep(j,edge[from].size()){\n        printf(\"%d -> %d\\n\",from, edge[from][j]);\n      }\n    }\n#endif\n    \n    vector<string> vs(ms.size());\n    map<string,int>::iterator it;\n    for(it=ms.begin(); it!=ms.end(); it++){\n      vs[it->second] = it->first;\n    }\n    /*\n    rep(i,se.size()){\n      edge.push_back(make_pair(ms[se[i].first],ms[se[i].second]));\n    }\n      */\n    \n\n    set<PMA*> pm;\n    set<PMA*>::iterator itr;\n    // init\n    rep(i,vs.size()){\n      int re = 0;\n      PMA *ne = next_PMA(vs[i],root,&re);\n      int len = vs[i].size();\n      if( re<=1 ){\n        dp[re][len][i][ne]++;\n        pm.insert(ne);\n      }\n    }\n    /*\n    REP(len,1,m){\n      rep(i,edge.size()){\n        int from = edge[i].first;\n        int to = edge[i].second;\n        for(itr=pm.begin(); itr!=pm.end(); itr++){\n          rep(u,2){\n            if( dp[u][len][from].count(*itr) && len+vs[to].length()<=m ){\n              int re = 0;\n              PMA *tmp = next_PMA(vs[to], *itr, &re);\n              int h = re+u;\n              if( h>1 )continue;              \n              dp[h][len+vs[to].length()][to][tmp] =\n                (dp[h][len+vs[to].length()][to][tmp] + dp[u][len][from][*itr] ) % mod;\n              pm.insert(tmp);\n            }\n          }\n        }\n      }\n    }\n    */\n\n    // vector<int> edge[510] & fm ver\n    REP(len,1,m){\n      rep(i,fm.size()){\n        int from = fm[i];\n        for(itr=pm.begin(); itr!=pm.end(); itr++){\n          rep(u,2){\n            if( dp[u][len][from].count(*itr) ){\n              rep(j,edge[from].size())if( len+vs[edge[from][j]].length()<=m ){\n                int to = edge[from][j];\n                int re = 0;\n                PMA *tmp = next_PMA(vs[to], *itr, &re);\n                int h = re+u;\n                if( h>1 )continue;              \n                dp[h][len+vs[to].length()][to][tmp] =\n                  (dp[h][len+vs[to].length()][to][tmp] + dp[u][len][from][*itr] ) % mod;\n                pm.insert(tmp);\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    /*\n    REP(len,1,m){\n      rep(i,vs.size()){\n        for(itr=pm.begin(); itr!=pm.end(); itr++){\n          rep(u,2){\n            if( dp[u][len][i].count(*itr) ){\n              rep(j,vs.size())if( edge[i][j] && len+vs[j].length()<=m ){\n                int re = 0;\n                PMA *tmp = next_PMA(vs[j], *itr, &re);\n                int h = re+u;\n                if( h>1 )continue;              \n                dp[h][len+vs[j].length()][j][tmp] =\n                  (dp[h][len+vs[j].length()][j][tmp] + dp[u][len][i][*itr] ) % mod;\n                pm.insert(tmp);\n              }\n            }\n          }\n        }\n      }\n    }\n      */\n    \n    int ret = 0;\n    rep(i,vs.size()){\n      for(itr=pm.begin(); itr!=pm.end(); itr++){\n        ret = (ret + dp[1][m][i][*itr]) % mod;\n      }\n    }\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct state{\n  int n,m,f;\n  string str;\n  state(){}\n  state(int n,int m,int f,string str) : n(n),m(m),f(f),str(str){}\n  bool operator<(const state& st) const{\n    if( n == st.n )\n      if( m == st.m )\n\tif( f == st.f )\n\t  return str < st.str;\n\telse\n\t  return f < st.f;\n      else\n\treturn m < st.m;\n    else\n      return n < st.n;\t    \n  }\n};\nunordered_map<string,int> S;\nmap<state,int> dp;\n\nint N,M,K;\nvector<int> G[255];\nstring Sm[255];\nstring Sk[55];\nunordered_map<string,pair<string,int>> mcp;\nvoid init(){\n  mcp.clear();\n  dp.clear();\n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\npair<string,int> check(const string &s){\n  if( mcp.count(s) != 0 ){\n    return mcp[s];\n  }\n  int cnt = 0;\n  string ret = \"\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"\" ) ret = ss;\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  return mcp[s] = {ret,cnt};\n} \nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  if( dp.count( state(n,m,cnt,str) ) != 0 ) return dp[{n,m,cnt,str}];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n    return dp[{n,m,cnt,str}] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    pair<string,int> np = check(rs);\n    int nct = cnt + np.second - check(str).second;\n    rs = np.first;\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n  //    cout << N << \" \" << M << \" \" << K << endl;\n  //cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[{n,m,cnt,str}] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      auto np = check(rs);\n      rs = np.first;\n      int cnt = np.second;\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nshort wnxt[601][505];\nshort wcnt[601][505];\nvector<P> vec[255];\nvector<short> v2[605][505];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=596;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps) cans[i].clear();\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=a[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t\tb[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(b[ni21][ne[j][u]][u]>=mod) b[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) for(int j:cans[i]){\n\t\t\tans+=a[M%21][i][j];\n\t\t\tif(ans>=mod) ans-=mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE], ssword[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\n\nbool solve(){\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n    //debug(ssword);\n  }\n\n  if(n == 250 && m == 500 & q == 30){\n    puts(\"Skip\");\n    return true;\n  }\n  \n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[501];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    //debug(i);\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n  \n  return true;\n}\n\nint main(){\n  while(solve()){\n    for(int i=0;i<pos_size;i++){\n      free(pos[i]);\n    }\n    pos_size = 0;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MM = 150;\n\nstruct Node {\n  int id;\n  int next[MM];\n  int fail;\n  vector<int> value;\n  Node() {\n    for(int i=0; i<MM; ++i) next[i] = 0;\n    value.clear();\n  }\n};\n\nclass Trie {\npublic:\n  Trie(const vector<string> &vs) {\n    nodes.push_back(new Node()); // dummy\n    nodes.push_back(new Node());\n    for(int i=0; i<vs.size(); ++i)\n      insert(vs[i],i);\n  }\n  Trie() {\n    nodes.clear();\n  }\n\n  void insert(const string &s,int k) {\n    Node *cur = nodes[1];\n    for(int i=0; i<s.length(); ++i) {\n      if(cur->next[s[i]] == 0) {\n        cur->next[s[i]] = nodes.size();\n        nodes.push_back(new Node());\n      }\n      cur = nodes[cur->next[s[i]]];\n    }\n    cur->value.push_back(k);\n  }\n  vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n  Aho_Corasick(const vector<string> &vs) {\n    nodes = Trie(vs).nodes;\n    make_failure_link();\n  }\n\n  void make_failure_link() {\n    queue<int> q;\n    Node *root = nodes[1];\n    for(int i=0; i<MM; ++i) {\n      if(root->next[i]) {\n        nodes[root->next[i]]->fail = 1;\n        q.push(root->next[i]);\n      }else root->next[i] = 1;\n    }\n\n    while(!q.empty()) {\n      Node *t = nodes[q.front()]; q.pop();\n      for(int i=0; i<MM; ++i) {\n        int u = t->next[i];\n        if(u) {\n          q.push(u);\n          int r = t->fail;\n          while(!nodes[r]->next[i]) r = nodes[r]->fail;\n          nodes[u]->fail = nodes[r]->next[i];\n          FOR(it, nodes[nodes[u]->fail]->value) {\n            nodes[u]->value.push_back(*it);\n          }\n        }\n      }\n    }\n  }\n\n  pair<int, int> match(int v, const string &s) {\n    int cnt = 0;\n    for(int i=0; i<s.length(); ++i) {\n      while(!nodes[v]->next[s[i]]) {\n        v = nodes[v]->fail;\n      }\n      v = nodes[v]->next[s[i]];\n      if(!(nodes[v]->value.empty())) { // found the word\n        cnt += nodes[v]->value.size();\n      }\n    }\n    return make_pair(v, cnt);\n  }\n\n  // ツ個サツ催敖づ個湘ウツ妥板づ閉カツ篠堋づーツ与ツつヲツづ湘ウツ妥板遷ツ暗堋つウツつケツづゥツ。\n  // AOJ2212ツづづ債マツッツチツつオツつスツづァツつセツづ淞つセツづつスツづ個づ、ツマツッツチツつオツつスツづつォ-1ツづーツ陛板つキツづヲツつ、ツづ可つオツづつ「ツづゥツ。\n  int next(int v, char c) {\n    while(!nodes[v]->next[c]) {\n      v = nodes[v]->fail;\n    }\n    v = nodes[v]->next[c];\n    // if(!(nodes[v]->value.empty())) { // found the word\n    //   return -1;\n    // }\n    return v;\n  }\n  \n  int match(int v) {\n    return nodes[v]->value.size();\n  }\n  \n  void free() {\n    for(int i=0; i<nodes.size(); ++i)\n      delete nodes[i];\n  }\n\n  vector<Node*> nodes;\n};\n\nstruct P {\n  int state, now;\n  bool f;\n  P(int state, int now, bool f) : state(state),now(now),f(f) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.state!=b.state ? a.state<b.state :\n    a.now!=b.now ? a.now<b.now : a.f<b.f;\n}\nmap<P,int> dp[21];\n\nconst int MOD = 1e9+7;\nconst int M = 21;\nint main() {\n  int n, m, k;\n  while(cin >> n >> m >> k, n||m||k) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> g[500];\n    string str[500];\n    REP(i, n) {\n      string a, b;\n      cin >> a >> b;\n      if (mp.count(a) == 0) {\n        str[num] = a;\n        mp[a] = num++;\n      }\n      if (mp.count(b) == 0) {\n        str[num] = b;\n        mp[b] = num++;\n      }\n      g[mp[a]].push_back(mp[b]);\n    }\n    vector<string> vs(k);\n    REP(i, k) cin >> vs[i];\n    Aho_Corasick pma(vs);\n    int ssize = pma.nodes.size();\n\n    \n    pii PMA[ssize][num];\n    vector<int> v[num];\n    for (int i=1; i<ssize; ++i) {\n      REP(j, num) {\n        PMA[i][j] = pma.match(i,str[j]);\n        if (PMA[i][j].second <= 1)\n          v[j].push_back(PMA[i][j].first);\n      }\n    }\n    REP(i, num) {\n      sort(ALL(v[i]));\n      v[i].erase(unique(ALL(v[i])), v[i].end());\n    }\n    REP(i, M) dp[i].clear();\n    REP(i, num) {\n      pii p = pma.match(1, str[i]);\n      int ss = p.first, f = p.second;\n      if (f<=1) {\n        dp[str[i].size()][P(ss,i,f)] = 1;\n        //cout << str[i].size() << \": \" << ss << \" \" << i << \" \" << f << endl;\n      }\n    }\n    //cout << ssize << \" \" << num << endl;\n    for (int i=1; i<=m; ++i) {\n      dp[(i+M-1)%M].clear();\n      FOR(it, dp[i%M]) {\n        const P *p = &it->first;\n        FOR(jt, g[p->now]) {\n          int ss = PMA[p->state][*jt].first;\n          int f = PMA[p->state][*jt].second;\n          if (p->f+f<=1) {\n            (dp[(i+str[*jt].size())%M][P(ss,*jt,p->f+f)] += it->second) %= MOD;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i, num) {\n      for (int s=1; s<ssize; ++s) {\n        ans = (ans + dp[m%M][P(s,i,1)]) % MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n//    makeGraph(all,P);\n //   sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][500][20][600];\nbool used[2][2][505][22][606];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) goto END;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) goto END;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class Converter, class SuffixInfo, int NODE_NUM = 1000000>\nclass AhoCorasick {\npublic:\n  using value_structure = typename Converter::value_structure;\n  using size_type = std::uint64_t;\n  static constexpr size_type num_of_kinds = Converter::num_of_kinds;\n\n  using value_type = typename SuffixInfo::value_type;\n  using merged_value_type = typename SuffixInfo::merged_value_type;\n\n  struct Node {\n    size_type size, end, len, faillink;\n    value_type val;\n    merged_value_type suf_info;\n    std::array<int, num_of_kinds> ch;\n    Node () : size(0), end(0), len(0), val(SuffixInfo::identity()),\n              suf_info(SuffixInfo::midentity()), faillink(0) { ch.fill(-1); }\n  };\n\nprivate:\n  std::vector<Node> node;\n\npublic:\n  AhoCorasick() {\n    node.reserve(NODE_NUM);\n    node.push_back(Node());\n  }\n\n  void insert(const value_structure& v, size_type num = 1, value_type val = value_type(), size_type k = 0, size_type idx = 0) {\n    node[idx].size += num;\n    if (k == v.size()) {\n      node[idx].end += num;\n      node[idx].val = SuffixInfo::operation(node[idx].val, val);\n      return;\n    }\n    size_type nxt = Converter::convert(v[k]);\n    if (node[idx].ch[nxt] == -1) {\n      node.push_back(Node());\n      node[idx].ch[nxt] = node.size()-1;\n      node.back().len = k+1;\n    }\n    insert(v, num, val, k+1, node[idx].ch[nxt]);\n  }\n\n  size_type count_prefix(const value_structure& v, size_type k = 0, size_type idx = 0) {\n    if (v.size() == k) return node[idx].size;\n    size_type nxt = Converter::convert(v[k]);\n    if (node[idx].ch[nxt] == -1) return 0;\n    return count_prefix(v, k+1, node[idx].ch[nxt]);\n  }\n\n  size_type count(const value_structure& v, size_type k = 0, size_type idx = 0) {\n    if (v.size() == k) return node[idx].end;\n    size_type nxt = Converter::convert(v[k]);\n    if (node[idx].ch[nxt] == -1) return 0;\n    return count(v, k+1, node[idx].ch[nxt]);\n  }\n\n  template<typename F>\n  void query(const value_structure& v, const F& f, size_type k = 0, size_type idx = 0) {\n    if (node[idx].size > 0) f(node[idx]);\n    if (v.size() == k) return;\n    size_type nxt = Converter::convert(v[k]);\n    if (node[idx].ch[nxt] == -1) return;\n    query(v, f, k+1, node[idx].ch[nxt]);\n  }\n\n  size_type proceed(size_type k, size_type c, bool need_convert = 1) {\n    if (need_convert) c = Converter::convert(c);\n    while (node[k].ch[c] == -1)  k = node[k].faillink;\n    return node[k].ch[c];\n  }\n\n  void build() {\n    std::queue<size_type> que;\n    for (int i = 0; i < num_of_kinds; i++) {\n      if (node[0].ch[i] == -1) node[0].ch[i] = 0;\n      else {\n        que.push(node[0].ch[i]);\n        SuffixInfo::merge(node[node[0].ch[i]].suf_info, node[node[0].ch[i]].val);\n      }\n    }\n    while (que.size()) {\n      int k = que.front();\n      que.pop();\n      for (int i = 0; i < num_of_kinds; i++) {\n        if (node[k].ch[i] == -1) continue;\n        size_type nx = node[k].ch[i];\n        node[nx].faillink = proceed(node[k].faillink, i, false);\n\n        SuffixInfo::merge(node[nx].suf_info, node[nx].val);\n        SuffixInfo::merge(node[nx].suf_info, node[node[nx].faillink].suf_info);\n        que.push(nx);\n      }\n    }\n  }\n\n  const Node& operator[](size_type k) {\n    return node[k];\n  }\n\n  int64 size() {\n    return node.size();\n  }\n};\n\nclass Converter {\npublic:\n  using value_structure = std::string;\n  using value_type = typename value_structure::value_type;\n  static constexpr std::size_t num_of_kinds = 26;\n  static std::size_t convert(const value_type& v) {\n    return v-'a';\n  }\n};\n\nclass SuffixInfo {\npublic:\n  using value_type = int;\n  using merged_value_type = int;\n  static value_type identity() { return 0; }\n  static merged_value_type midentity() { return 0; }\n  static value_type operation(const value_type& a, const value_type& b) {\n    return a + b;\n  }\n  static void merge(merged_value_type& a, const merged_value_type& b) {\n    a += b;\n  }\n//  static void merge(merged_value_type& a, const value_type& b) {\n//    a |= b;\n//  }\n};\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n  using value_type = ::std::uint_fast64_t;\n  value_type n;\npublic:\n  ModInt() : n(0) {}\n  ModInt(value_type n_) : n(n_ % mod) {}\n  ModInt(const ModInt& m) : n(m.n) {}\n\n  template<typename T>\n  explicit operator T() const { return static_cast<T>(n); }\n  value_type get() const { return n; }\n\n  friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n    return os << a.n;\n  }\n\n  friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n    value_type x;\n    is >> x;\n    a = ModInt<mod>(x);\n    return is;\n  }\n\n  bool operator==(const ModInt& m) const { return n == m.n; }\n  bool operator!=(const ModInt& m) const { return n != m.n; }\n  ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n  ModInt pow(value_type b) const{\n    ModInt ans = 1, m = ModInt(*this);\n    while(b){\n      if(b & 1) ans *= m;\n      m *= m;\n      b >>= 1;\n    }\n    return ans;\n  }\n\n  ModInt inv() const { return (*this).pow(mod-2); }\n  ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n  ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n  ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n  ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n  ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n  ModInt& operator++(){ n += 1; return *this; }\n  ModInt& operator--(){ n -= 1; return *this; }\n  ModInt operator++(int){\n    ModInt old(n);\n    n += 1;\n    return old;\n  }\n  ModInt operator--(int){\n    ModInt old(n);\n    n -= 1;\n    return old;\n  }\n  ModInt operator-() const { return ModInt(mod-n); }\n};\nconstexpr int64 mod = 1e9+7;\nusing Mint = ModInt<mod>;\n\nint main(void) {\n  int64 N, M, K;\n  while (cin >> N >> M >> K && N+M+K) {\n    map<string, int> id;\n    vector<vector<int>> G;\n    vector<string> vs;\n    G.push_back(vector<int>());\n    vs.push_back(\"\");\n    REP(i, N) {\n      string from, to;\n      cin >> from >> to;\n      if (id.count(from) == 0) {\n        id[from] = vs.size();\n        vs.push_back(from); G.push_back(vector<int>());\n      }\n      if (id.count(to) == 0) {\n        id[to] = vs.size();\n        vs.push_back(to); G.push_back(vector<int>());\n      }\n      G[id[from]].push_back(id[to]);\n    }\n    FOR(i, 1, vs.size()) G[0].push_back(i);\n    AhoCorasick<Converter, SuffixInfo> ah;\n    REP(i, K) {\n      string s;\n      cin >> s;\n      ah.insert(s, 1, 1);\n    }\n    ah.build();\n    using T = tuple<int, int, int>;\n    vector<map<T, Mint>> dp(M+1);\n    dp[0][T(0, 0, 0)] = 1;\n\n    REP(i, M) {\n      for (auto &x : dp[i]) {\n        int64 j, v, kigo;\n        tie(j, v, kigo) = x.fs;\n        for (auto k : G[j]) {\n          int u = v;\n          int sum = kigo;\n          if (vs[k].size() + i > M) continue;\n          REP(l, vs[k].size()) {\n            u = ah.proceed(u, vs[k][l]);\n            sum += ah[u].suf_info;\n          }\n          if (sum > 1) continue;\n          dp[i+vs[k].size()][T(k, u, sum)] += x.sc;\n        }\n      }\n    }\n    Mint res = 0;\n    for (auto &x : dp[M]) {\n      if (get<2>(x.fs) == 1) {\n        res += x.sc;\n      }\n    }\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps) cans[i].clear();\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta[ni21][ne[j][u]][u]+=a[i21][j][k];\n\t\t\t\t\t\t\tif(a[ni21][ne[j][u]][u]>=mod) a[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t\tb[ni21][ne[j][u]][u]+=b[i21][j][k];\n\t\t\t\t\t\t\tif(b[ni21][ne[j][u]][u]>=mod) b[ni21][ne[j][u]][u]-=mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n   // PMA *root = buildPMA(kigo,m,P);\n//    makeGraph(all,P);\n //   sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  return -1;\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length <= word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& from = it->first;\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\tif(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n\t}\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 601;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t\tint q=p;\n\t\t\t\t\twhile(q && !states[q].next[i]) q = states[q].failure;\n\t\t\t\t\tstates[p].next[i] = states[q].next[i];\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(const int &p, const int &c){\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <vector>\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint add_name(const std::string &s){\n\t\treturn (*this)[s];\n\t}\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n\tconst std::string &operator[](size_t i) const {\n\t\treturn m_inv_table[i];\n\t}\n\tsize_t size() const { return m_inv_table.size(); }\n};\n}\nnamespace lc {\ntemplate <int MAX_CODE = std::numeric_limits<char>::max()>\nclass AhoCorasick {\nprivate:\n\tstruct State {\n\t\tint next[MAX_CODE + 1];\n\t\tint failure;\n\t\tstd::vector<int> accept;\n\t\tState() : failure(0), accept() {\n\t\t\tconst int EMPTY_LINK = std::numeric_limits<int>::min();\n\t\t\tstd::fill(next, next + MAX_CODE + 1, EMPTY_LINK);\n\t\t}\n\t};\n\tstd::vector<State> m_states;\n\ttemplate <class Iterator>\n\tvoid construct_trie(Iterator first, Iterator last){\n\t\tm_states.emplace_back();\n\t\tint i = 0;\n\t\tfor(Iterator it = first; it != last; ++it, ++i){\n\t\t\tint cur = 0;\n\t\t\tfor(const int c : *it){\n\t\t\t\tif(m_states[cur].next[c] < 0){\n\t\t\t\t\tm_states[cur].next[c] = m_states.size();\n\t\t\t\t\tm_states.emplace_back();\n\t\t\t\t}\n\t\t\t\tcur = m_states[cur].next[c];\n\t\t\t}\n\t\t\tm_states[cur].accept.push_back(i);\n\t\t}\n\t}\n\tvoid write_failure_links(){\n\t\tstd::queue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int index = q.front();\n\t\t\tq.pop();\n\t\t\tconst State &s = m_states[index];\n\t\t\tfor(int i = 0; i <= MAX_CODE; ++i){\n\t\t\t\tconst int next = s.next[i];\n\t\t\t\tif(next < 0){ continue; }\n\t\t\t\tq.push(next);\n\t\t\t\tif(index == 0){ continue; }\n\t\t\t\tint f = s.failure;\n\t\t\t\twhile(f != 0 && m_states[f].next[i] < 0){\n\t\t\t\t\tf = m_states[f].failure;\n\t\t\t\t}\n\t\t\t\tconst int failure = std::max(0, m_states[f].next[i]);\n\t\t\t\tm_states[next].failure = failure;\n\t\t\t\tconst auto &accept = m_states[failure].accept;\n\t\t\t\tstd::copy(\n\t\t\t\t\taccept.begin(), accept.end(),\n\t\t\t\t\tstd::back_inserter(m_states[next].accept));\n\t\t\t}\n\t\t}\n\t}\n\tint shorten_recur(int i, int c){\n\t\tconst int EMPTY_LINK = std::numeric_limits<int>::min();\n\t\tState &s = m_states[i];\n\t\tif(i == 0 || s.next[c] >= 0){ return ~i; }\n\t\tif(s.next[c] != EMPTY_LINK){ return s.next[c]; }\n\t\ts.next[c] = shorten_recur(s.failure, c);\n\t\treturn s.next[c];\n\t}\n\tvoid shorten_failure_links(){\n\t\tconst int n = m_states.size();\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tfor(int j = 0; j <= MAX_CODE; ++j){ shorten_recur(i, j); }\n\t\t}\n\t}\npublic:\n\tAhoCorasick()\n\t\t: m_states(1)\n\t{ }\n\ttemplate <class Iterator>\n\tAhoCorasick(Iterator first, Iterator last)\n\t\t: m_states()\n\t{\n\t\tconstruct_trie(first, last);\n\t\twrite_failure_links();\n\t\tshorten_failure_links();\n\t}\n\tstd::pair<int, const std::vector<int> &> iterate(int c, int s) const {\n\t\tif(s != 0 && m_states[s].next[c] < 0){ s = ~m_states[s].next[c]; }\n\t\ts = std::max(0, m_states[s].next[c]);\n\t\treturn std::pair<int, const std::vector<int> &>(s, m_states[s].accept);\n\t}\n\tsize_t size() const {\n\t\treturn m_states.size();\n\t}\n};\n}\nusing namespace std;\ntypedef lc::AhoCorasick<'z'> AhoCorasick;\nstatic const int MOD = 1000000007;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, k;\n\t\tcin >> n >> m >> k;\n\t\tif(n == 0 && m == 0 && k == 0){ break; }\n\t\tvector< vector<int> > next_words(2 * n + 1);\n\t\tlc::NameTable words;\n\t\twords.add_name(\"\");\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tconst int from_key = words[from], to_key = words[to];\n\t\t\tnext_words[from_key].push_back(to_key);\n\t\t}\n\t\tfor(size_t i = 1; i < words.size(); ++i){\n\t\t\tnext_words[0].push_back(i);\n\t\t}\n\t\tvector<string> season_words(k);\n\t\tfor(int i = 0; i < k; ++i){ cin >> season_words[i]; }\n\t\tAhoCorasick ac(season_words.begin(), season_words.end());\n\t\tmap<int, int> dp[21][501][2];\n\t\tdp[0][0][0].insert(make_pair(0, 1));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(size_t j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int f = 0; f < 2; ++f){\n\t\t\t\t\tfor(const auto &p : dp[i % 21][j][f]){\n\t\t\t\t\t\tfor(const int next : next_words[j]){\n\t\t\t\t\t\t\tconst string &word = words[next];\n\t\t\t\t\t\t\tif(static_cast<int>(i + word.size()) > m){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint state = p.first, sum = f;\n\t\t\t\t\t\t\tfor(const char c : word){\n\t\t\t\t\t\t\t\tconst auto res = ac.iterate(c, state);\n\t\t\t\t\t\t\t\tstate = res.first;\n\t\t\t\t\t\t\t\tsum += res.second.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(sum >= 2){ continue; }\n\t\t\t\t\t\t\tconst int rot = (i + word.size()) % 21;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] += p.second;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][f].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(size_t i = 0; i < words.size(); ++i){\n\t\t\tfor(size_t j = 0; j < ac.size(); ++j){\n\t\t\t\tanswer += dp[m % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate<u32 M = 1000000007>\nstruct modint{\n    u32 val;\n    modint(): val(0){}\n    template<typename T>\n    modint(T t){t %= (T)M; if(t < 0) t += (T)M; val = t;}\n\n    modint pow(ll k) const {\n        modint res(1), x(val);\n        while(k){\n            if(k&1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n    template<typename T>\n    modint& operator=(T t){t %= (T)M; if(t < 0) t += (T)M; val = t; return *this;}\n    modint inv() const {return pow(M-2);}\n    modint& operator+=(modint a){val += a.val; if(val >= M) val -= M; return *this;}\n    modint& operator-=(modint a){if(val < a.val) val += M-a.val; else val -= a.val; return *this;}\n    modint& operator*=(modint a){val = (u64)val*a.val%M; return *this;}\n    modint& operator/=(modint a){return (*this) *= a.inv();}\n    modint operator+(modint a) const {return modint(val) +=a;}\n    modint operator-(modint a) const {return modint(val) -=a;}\n    modint operator*(modint a) const {return modint(val) *=a;}\n    modint operator/(modint a) const {return modint(val) /=a;}\n    modint operator-(){return modint(M-val);}\n    bool operator==(const modint a) const {return val == a.val;}\n    bool operator!=(const modint a) const {return val != a.val;}\n    bool operator<(const modint a) const {return val < a.val;}\n};\nusing mint = modint<MOD>;\n\ntemplate<int W, int start>\nclass AhoCorasick {\npublic:\n    struct Node {\n        array<int, W> to;\n        int fail;\n    };\n    explicit AhoCorasick() : v(1) {}\n    vector<Node> v;\n    vector<int> ord;\n    int add(string &s, int cur = 0){\n        for (auto &&i : s) {\n            if(!v[cur].to[i-start]) v[cur].to[i-start] = v.size(), v.emplace_back();\n            cur = v[cur].to[i-start];\n        }\n        return cur;\n    }\n\n    void build() {\n        v[0].fail = -1;\n        int l = 0, r = 1;\n        ord.clear();\n        ord.reserve(v.size());\n        ord.emplace_back(0);\n        while(l < r){\n            int i = ord[l]; l++;\n            for (int c = 0; c < W; ++c) {\n                if(!v[i].to[c]) continue;\n                int to = v[i].to[c];\n                v[to].fail = (v[i].fail == -1 ? 0 : v[v[i].fail].to[c]);\n                ord.emplace_back(to);\n                r++;\n            }\n            if(i != 0){\n                for (int c = 0; c < W; ++c) {\n                    if(!v[i].to[c]) v[i].to[c] = v[v[i].fail].to[c];\n                }\n            }\n        }\n    }\n    inline int next(int x, char c){ return v[x].to[c-start]; }\n};\n\nmint dp[32][501][601][2];\nint to[601][501];\nint to2[601][501];\nint dp0[601];\nvoid solve(int n, int m, int K){\n    vector<string> words;\n    vector<vector<int>> G;\n    fill(dp0, dp0+601, 0);\n    vector<string> kigo(K);\n    int sz = 0;\n    {\n        int cur = 0;\n        map<string, int> exist;\n        for (int i = 0; i < n; ++i) {\n            string s, t;\n            cin >> s >> t;\n            if(!exist.count(s)) {\n                exist[s] = cur++;\n                words.emplace_back(s);\n                G.emplace_back();\n            }\n            if(!exist.count(t)){\n                exist[t] = cur++;\n                words.emplace_back(t);\n                G.emplace_back();\n            }\n            G[exist[s]].emplace_back(exist[t]);\n        }\n        n = words.size();\n        AhoCorasick<26, 'a'> aho;\n        for (int i = 0; i < K; ++i) {\n            cin >> kigo[i];\n            dp0[aho.add(kigo[i])]++;\n        }\n        aho.build();\n        for (auto &&i : aho.ord) if(i) dp0[i] += dp0[aho.v[i].fail];\n        sz = aho.v.size();\n        for (int i = 0; i < sz; ++i) {\n            for (int j = 0; j < n; ++j) {\n                to[i][j] = i;\n                to2[i][j] = 0;\n                for (auto &&c : words[j]) {\n                    to[i][j] = aho.next(to[i][j], c);\n                    to2[i][j] += dp0[to[i][j]];\n                }\n            }\n        }\n    }\n    for (int i = 0; i < 32; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < sz; ++k) {\n                for (int l = 0; l < 2; ++l) {\n                    dp[i][j][k][l] = 0;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if(to2[0][i] < 2) dp[words[i].size()&31][i][to[0][i]][to2[0][i]] += mint(1);\n    }\n    for (int i = 1; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int k = 0; k < sz; ++k) {\n                for (int l = 0; l < 2; ++l) {\n                    dp[(i+22)&31][j][k][l] = 0;\n                }\n            }\n        }\n        for (int o = 0; o < n; ++o) {\n            for (auto &&j : G[o]) {\n                if(i+words[j].size() > m) continue;\n                int now = i&31, next = (now+words[j].size())&31;\n                for (int k = 0; k < sz; ++k) {\n                    for (int l = 0; l < 2; ++l) {\n                        if(l + to2[k][j] >= 2) continue;\n                        dp[next][j][to[k][j]][l+to2[k][j]] += dp[now][o][k][l];\n                    }\n                }\n            }\n        }\n    }\n    mint ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < sz; ++j) {\n            ans += dp[m&31][i][j][1];\n        }\n    }\n    cout << ans.val << \"\\n\";\n}\n\nint main() {\n    int n, m, k;\n    while(cin >> n >> m >> k, n){\n        solve(n, m, k);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\n\n/*\nsymbol : !\"#$%&'()*+,-./\ndigit : 0~9\nsymbol2 : :;<=>?@\nupper : A~Z\nsymbol3 : [\\]^_`\nlower : a~z\t\nsynbol4 : {|}~\n\ndon't forget!!!!  :  build  \n*/\nstruct AhoCorasick{\n\t//  c \\in [OFF,OFF+LEN)\n\tstatic const int OFF=(int)('a');\n\tstatic const int SUP=(int)('z');\n\tstatic const int LEN=SUP-OFF+1;\n\t\n\tstruct Node{\n\t\tint nex[LEN];\n\t\tint failink;\n\t\tvector<int>suflist;\n\t\tNode():failink(0){memset(nex,-1,sizeof(nex));}\n\t};\n\tvector<Node>nds;\n\n\tAhoCorasick():nds(1){}\n\n\tint process(int k,int c){\n\t\tc-=OFF;\n\t\twhile(nds[k].nex[c]==-1)k=nds[k].failink;\n\t\treturn nds[k].nex[c];\n\t}\n\n\tvoid add(const string &s,int id){\n\t\tint k=0;\n\t\tfor(auto c:s){\n\t\t\tc-=OFF;\n\t\t\tif(nds[k].nex[c]==-1){\n\t\t\t\tnds[k].nex[c]=nds.size();\n\t\t\t\tnds.emplace_back();\n\t\t\t}\n\t\t\tk=nds[k].nex[c];\n\t\t}\n\t\tnds[k].suflist.push_back(id);\n\t}\n\n\tvoid build(){\n\t\tqueue<int>que;\n\t\tfor(int i=0;i<LEN;i++){\n\t\t\tif(nds[0].nex[i]==-1)nds[0].nex[i]=0;\n\t\t\telse que.push(nds[0].nex[i]);\n\t\t}\n\t\twhile(que.size()){\n\t\t\tint k=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<LEN;i++){\n\t\t\t\tif(nds[k].nex[i]==-1)continue;\n\t\t\t\tint nx=nds[k].nex[i];\n\t\t\t\tnds[nx].failink=process(nds[k].failink,i+OFF);\n\n\t\t\t\tvector<int>&curlist=nds[nds[nx].failink].suflist;\n\t\t\t\tvector<int>&nexlist=nds[nx].suflist;\n\n\t\t\t\tnexlist.insert(nexlist.end(),curlist.begin(),curlist.end());\n\t\t\t\tque.push(nx);\n\t\t\t}\n\t\t}\n\t}\n};\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,const ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<1000000007>;\n\nint N,M,K;\n\nunordered_map<int,mint>dp[2][510][510];\n\nvint G[555];\nvector<string>dic;\nint nextState[666][666];\nint numMatch[666][666];\n\nmint dfs(int ex,int v,int l,int s){\n\tif(l==M){\n\t\tif(!ex)return 0;\n\t\treturn 1;\n\t}\n\tif(dp[ex][v][l].count(s))return dp[ex][v][l][s];\n\tmint ret=0;\n\tfor(auto &u:G[v]){\n\t\tint ns=nextState[s][u];\n\t\tint nl=l+dic[u].size();\n\t\tint nv=u;\n\t\tint nx=ex+numMatch[s][u];\n\t\tif(nl>M||nx>1)continue;\n\t\tret+=dfs(nx,nv,nl,ns);\n\t}\n\treturn dp[ex][v][l][s]=ret;\n}\nvoid solve(){\n\tdic=vector<string>();\n\trep(i,555)G[i]=vint();\n\trep(i,2)rep(j,510)rep(k,510)dp[i][j][k]=unordered_map<int,mint>();\n\n\tvector<string>from(N),to(N);\n\trep(i,N){\n\t\tcin>>from[i]>>to[i];\n\t\tdic.pb(from[i]);\n\t\tdic.pb(to[i]);\n\t}\n\n\tsort(all(dic));dic.erase(unique(all(dic)),dic.end());\n\trep(i,N){\n\t\tint a=lower_bound(all(dic),from[i])-dic.begin();\n\t\tint b=lower_bound(all(dic),to[i])-dic.begin();\n\t\tG[a].pb(b);\n\t}\n\n\tAhoCorasick ac;\n\trep(i,K){\n\t\tstring s;\n\t\tcin>>s;\n\t\tac.add(s,i);\n\t}\n\n\tac.build();\n\n\tfor(int i=0;i<ac.nds.size();i++){\n\t\tfor(int j=0;j<dic.size();j++){\n\t\t\tint s=i;\n\t\t\tint cnt=0;\n\t\t\trep(k,dic[j].size()){\n\t\t\t\ts=ac.process(s,dic[j][k]);\n\t\t\t\tcnt+=ac.nds[s].suflist.size();\n\t\t\t}\n\t\t\tnextState[i][j]=s;\n\t\t\tnumMatch[i][j]=cnt;\n\t\t}\n\t}\n\n\tmint ans=0;\n\tfor(int i=0;i<dic.size();i++)if(dic[i].size()<=M&&numMatch[0][i]<=1){\n\t\tans+=dfs(numMatch[0][i],i,dic[i].size(),nextState[0][i]);\n\t}\n\tcout<<ans<<endl;\n}\n\nsigned main(){\n\twhile(cin>>N>>M>>K,N)solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct AhoCorasick {\n  static const int SIZE = 128;\n  struct State {\n    int index;\n    int next[SIZE]; // next[0] is failuer link\n    vector<int> accept;\n    State(int index) : index(index) {\n      memset(next, -1, sizeof(next));\n    }\n  };\n\n  bool build;\n  vector<State> pma;\n  vector<int> lens;\n  //vector<string. strs;\n\n  AhoCorasick() {\n    build = false;\n    pma.clear();\n    pma.push_back(State(0));\n    lens.clear();\n    //strs.clear();\n  }\n\n  void AddString(const char *str) {\n    assert(!build);\n    int t = 0;\n    for (int i = 0; str[i]; i++) {\n      int c = str[i];\n      if (pma[t].next[c] == -1) {\n        int m = pma.size();\n        pma[t].next[c] = m;\n        pma.push_back(State(m));\n      }\n      t = pma[t].next[c];\n    }\n    pma[t].accept.push_back(lens.size());\n    lens.push_back(strlen(str));\n    //strs.push_back(str);\n  }\n\n  void BuildPMA() {\n    assert(!build);\n    queue<int> que;  // make failure link using bfs\n    for (int c = 1; c < SIZE; c++) {\n      if (pma[0].next[c] != -1) {\n        pma[pma[0].next[c]].next[0] = 0;\n        que.push(pma[0].next[c]);\n      } else {\n        pma[0].next[c] = 0;\n      }\n    }\n    while (!que.empty()) {\n      int t = que.front();\n      que.pop();\n      for (int c = 1; c < SIZE; c++) {\n        if (pma[t].next[c] != -1) {\n          que.push(pma[t].next[c]);\n          int r = pma[t].next[0];\n          while (pma[r].next[c] == -1) {\n            r = pma[r].next[0];\n          }\n          pma[pma[t].next[c]].next[0] = pma[r].next[c];\n          for (vector<int>::iterator it = pma[pma[r].next[c]].accept.begin(); it != pma[pma[r].next[c]].accept.end(); it++) {\n            pma[pma[t].next[c]].accept.push_back(*it);\n          }\n        }\n      }\n    }\n    build = true;\n  }\n\n  int OneMove(int index, int c) {\n    return pma[index].next[c] != -1 ?\n      pma[index].next[c] :\n      pma[index].next[c] = OneMove(pma[index].next[0], c);\n    //while (pma[index].next[c] == -1) { index = pma[index].next[0]; }\n    //return pma[index].next[c];\n  }\n\n  // return first match indices\n  vector<int> Match(const char *t) {\n    assert(build);\n    int index = 0;\n    vector<int> ret(lens.size(), -1);\n    int n = strlen(t);\n    for (int i = 0; i < n; i++) {\n      int c = t[i];\n      index = OneMove(index, c);\n      for (vector<int>::const_iterator it = pma[index].accept.begin(); it != pma[index].accept.end(); it++) {\n        if (ret[*it] != -1) { continue; }\n        ret[*it] = i - lens[*it] + 1;\n      }\n    }\n    return ret;\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\n//=======================================\n\nstruct State {\n  int prev;\n  int index;\n  char exist;\n  State() {;}\n  State(int prev, int index, int exist) : prev(prev), index(index), exist(exist) {;}\n  bool operator<(const State &rhs) const {\n    //if (depth != rhs.depth) { return depth < rhs.depth; }\n    if (prev != rhs.prev) { return prev < rhs.prev; }\n    if (index != rhs.index) { return index < rhs.index; }\n    return exist < rhs.exist;\n  }\n};\n\nll MOD = 1000000007;\nint n, m, k, s;\nGraph g;\nmap<string, int> mapto;\nstring mapfrom[1010];\nint len[1010];\nAhoCorasick aho;\nmap<State, int> memo[510];\npair<int, char> moveMemo[1001][1010];\n\n//===========================================\n\npair<int, int> Move(int index, int word) {\n  if (moveMemo[index][word].first != -1) { return moveMemo[index][word]; }\n  pair<int, int> ret(index, 0);\n  FORIT(it, mapfrom[word]) {\n    ret.first = aho.OneMove(ret.first, *it);\n    ret.second += aho.pma[ret.first].accept.size();\n  }\n  ret.second = min(ret.second, 2);\n  return moveMemo[index][word] = ret;\n}\n\nState NextState(State state, int word) {\n  pair<int, char> result = Move(state.index, word);\n  return State(word, result.first, state.exist + result.second);\n}\n\nchar str1[100], str2[100];\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &k), n|m|k) {\n    REP(i, 510) { memo[i].clear(); }\n    aho = AhoCorasick();\n    MEMSET(moveMemo, -1);\n    mapto.clear();\n    s = 0;\n    g = Graph(n * 2);\n    REP(i, n) {\n      scanf(\"%s %s\", str1, str2);\n      if (!mapto.count(str1)) {\n        mapto[str1] = s++;\n        mapfrom[mapto[str1]] = str1;\n        len[mapto[str1]] = strlen(str1);\n      }\n      if (!mapto.count(str2)) {\n        mapto[str2] = s++;\n        mapfrom[mapto[str2]] = str2;\n        len[mapto[str2]] = strlen(str2);\n      }\n      g[mapto[str1]].push_back(mapto[str2]);\n    }\n    REP(i, k) {\n      scanf(\"%s\", str1);\n      aho.AddString(str1);\n    }\n    aho.BuildPMA();\n    assert(aho.pma.size() <= 1000);\n    ll ans = 0;\n    REP(i, s) {\n      memo[len[i]][NextState(State(-1, 0, 0), i)] += 1;\n    }\n    REP(i, m) {\n      FORIT(it1, memo[i]) {\n        State state = it1->first;\n        int cnt = it1->second;\n        FORIT(it2, g[state.prev]) {\n          int ndepth = i + len[*it2];\n          if (ndepth > m) { continue; }\n          State next = NextState(state, *it2);\n          if (next.exist >= 2) { continue; }\n          if (ndepth == m) {\n            ans = next.exist == 1 ? (ans + cnt) % MOD : ans;\n          } else {\n            memo[ndepth][next] = (memo[ndepth][next] + cnt) % MOD;\n          }\n        }\n      }\n      memo[i].clear();\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nconst int NUMC = 26;\n\nclass Trie {\npublic:\n\tvector<vector<int> > V;\n\tint find(string s) {\n\t\tint cur=0;\n\t\trep(i,s.size()){\n            if((cur=V[cur][s[i]+1])==0) return -1;\n        }\n\t\treturn cur;\n\t}\n\tvoid create(vector<string> S){\n\t\tV.clear();\n\t\tV.push_back(vector<int>(NUMC+1));\n\t\tsort(S.begin(),S.end());\n\t\trep(i,S.size()){\n\t\t\tint cur=0;\n\t\t\trep(j,S[i].size()){\n\t\t\t\tif(V[cur][S[i][j]+1]==0) V.push_back(vector<int>(NUMC+1)),V[cur][S[i][j]+1]=V.size()-1;\n\t\t\t\tcur=V[cur][S[i][j]+1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass ACmatch_num {\npublic:\n\tTrie t;\n\tvector<int> acc;\n\tint ma;\n\tvoid create(vector<string> S) {\n        rep(i,(int)S.size()){\n            rep(j,(int)S[i].size()){\n                S[i][j] -= 'a';\n            }\n        }\n\t\tint i;\n\t\tma=S.size();\n\t\tt.create(S);\n\t\tacc.clear();\n\t\tacc.resize(t.V.size());\n\t\trep(i,S.size()) acc[t.find(S[i])]++;\n\t\tqueue<int> Q;\n\t\trep(i,NUMC) if(t.V[0][i+1]) t.V[t.V[0][i+1]][0]=0, Q.push(t.V[0][i+1]);\n\n\t\twhile(!Q.empty()) {\n\t\t\tint k=Q.front(); Q.pop();\n\t\t\trep(i,NUMC) if(t.V[k][i+1]) {\n\t\t\t\tQ.push(t.V[k][i+1]);\n\t\t\t\tint pre=t.V[k][0];\n\t\t\t\twhile(pre && t.V[pre][i+1]==0) pre=t.V[pre][0];\n\t\t\t\tt.V[t.V[k][i+1]][0]=t.V[pre][i+1];\n\t\t\t\tacc[t.V[k][i+1]] += acc[t.V[pre][i+1]];\n\t\t\t}\n\t\t}\n\t}\n\tint match(string S) {\n        rep(i,(int)S.size()){\n            S[i] -= 'a';\n        }\n\t\tint R=0;\n\t\tint cur=0;\n\t\trep(i,(int)S.size()){\n\t\t\twhile(cur && t.V[cur][S[i]+1]==0) cur=t.V[cur][0];\n\t\t\tcur=t.V[cur][S[i]+1];\n\t\t\tR += acc[cur];\n\t\t}\n\t\treturn R;\n\t}\n};\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nvector<int> G[501];\n\nbool ok(int id,string& cri,map<pll,vi>* st,RollingHash& ch)\n{\n    if(len(st[len(cri)-id-1]) == 0){\n        return false;\n    }\n    pll foo = ch.hash(id,len(cri)-1);\n    if(st[len(cri)-id-1].find(foo) == st[len(cri)-id-1].end()){\n        return false;\n    }else{\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,K;\n        cin >> n >> m >> K;\n        if(n == 0){\n            break;\n        }\n        rep(i,501){\n            G[i].clear();\n        }\n        map<string,int> mp;\n        vs s,t(K);\n        int num = 0;\n        rep(i,n){\n            string a,b;\n            cin >> a >> b;\n            if(mp.find(a) == mp.end()){\n                s.pb(a);\n                mp[a] = num++;\n            }\n            if(mp.find(b) == mp.end()){\n                s.pb(b);\n                mp[b] = num++;\n            }\n            G[mp[a]].pb(mp[b]);\n        }\n        rep(i,num){\n            G[num].pb(i);\n        }\n        int comp[31][21][21];\n        vector<RollingHash> rh(K);\n        map<pll,vi> st[21];\n        rep(i,K){\n            cin >> t[i];\n            rh[i].init(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    st[k-j][rh[i].hash(j,k)] = {i,j,k};\n                }\n            }\n        }\n        // each(it,st[0]){\n        //     spair(it.fi);\n        //     svec(it.se);\n        // }\n        ACmatch_num an;\n        an.create(t);\n        // cout << an.match(\"sakura\") << \"\\n\";\n        // cout << an.match(\"sakur\") << \"\\n\";\n        rep(i,K){\n            // show(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    // cout << j << \" \" << k << \"\\n\";\n                    comp[i][j][k] = an.match(t[i].substr(j,k-j+1));\n                }\n            }\n        }\n        map<vi,ll> dp[501];\n        dp[0][{-1,0,0,num,0}] = 1;\n        rep(i,m){\n            each(it,dp[i]){\n                int idx = it.fi[0], idy = it.fi[1], idz = it.fi[2],pre = it.fi[3],nw = it.fi[4];\n                ll val = it.se;\n                // show(i);\n                // svec(it.fi),show(it.se);\n                each(j,G[pre]){\n                    if(i+len(s[j]) > m){\n                        continue;\n                    }\n                    string cri;\n                    int diff = 0;\n                    if(idx == -1){\n                        cri = s[j];\n                    }else{\n                        cri = t[idx].substr(idy,idz-idy+1);\n                        cri += s[j];\n                        diff = comp[idx][idy][idz];\n                    }\n                    // show(pre);\n                    // show(cri);\n                    RollingHash ch;\n                    ch.init(cri);\n                    vi nx = {-1,0,0};\n                    int l = -1,r = len(cri)-1;\n                    if(ok(r,cri,st,ch)){\n                        while(r-l>1){\n                            int mid = (l+r)/2;\n                            if(ok(mid,cri,st,ch)){\n                                r = mid;\n                            }else{\n                                l = mid;\n                            }\n                        }\n                        nx = st[len(cri)-r-1][ch.hash(r,len(cri)-1)];\n                    }\n                    // cout << ok(0,cri,st,ch) << \"\\n\";\n                    // cout << nx[1] << \" \" << nx[2] << \"\\n\";\n                    // spair(ch.hash(0,0));\n                    int res = an.match(cri) - diff;\n                    // cout << cri << \" \" << nw << \" \" << res << \"\\n\";\n                    // svec(nx);\n                    if(res == 1){\n                        if(nw == 0){\n                            dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] + val) % MOD;\n                        }\n                    }else{\n                        dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,nw}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,nw}] + val) % MOD;\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        each(it,dp[m]){\n            if(it.fi[4] == 1){\n                ans += it.se;\n            }\n        }\n        cout << ans % MOD << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\nint wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,MAX_ps) cans[i].clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],a[i%21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) rep(k,ws) a[i%21][j][k]=b[i%21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int MOD = 1e9+7;\n\nstruct Node {\n    string suffix;\n    vector<int> accept;\n    map<char,Node*> next;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    Node* addNode() {\n        Node* node = new Node();\n        node->next[failure] = root;\n\n        return node;\n    }\n\n    void build(vector<string> vstr) {\n        for (int i = 0, vlen = vstr.size(); i < vlen; i++) {\n            Node* now = root;\n            string tmp;\n            for (auto c : vstr[i]) {\n                if (now->next.find(c) == now->next.end())\n                    now->next[c] = addNode();\n                now = now->next[c];\n                tmp += c;\n                now->suffix = tmp;\n            }\n            now->accept.push_back(i);\n        }\n\n        queue<Node*> que;\n\n        const string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto c : symbol_array) {\n            if (root->next.find(c) != root->next.end()) {\n                root->next[c]->next[failure] = root;\n                que.push(root->next[c]);\n            } else {\n                root->next[c] = root;\n            }\n        }\n\n        while (!que.empty()) {\n            Node* node = que.front(); que.pop();\n            for (auto p : node->next) {\n\n                char c = p.first; // i\n                Node* now = p.second; // now->next[i]\n\n                if (c == failure) {\n                    continue;\n                }\n\n                que.push(now);\n\n                Node* rev = node->next[failure];\n                while (rev->next.find(c) == rev->next.end())\n                    rev = rev->next[failure];\n                now->next[failure] = rev->next[c];\n\n                vector<int> acc;\n                set_union(now->accept.begin(),\n                          now->accept.end(),\n                          rev->next[c]->accept.begin(),\n                          rev->next[c]->accept.end(),\n                          back_inserter(acc));\n                now->accept = acc;\n            }\n        }\n    }\n\n    int match(string str, Node* now, vector<int>& result) {\n        int len = str.size();\n        int count = 0;\n\n        for (auto c  : str) {\n            while (now->next.find(c) == now->next.end()) now = now->next[failure];\n            now = now->next[c];\n\n            for (auto ac : now->accept) {\n                result[ac]++;\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto c : str) {\n            while (now->next.find(c) == now->next.end())\n                now = now->next[failure];\n            now = now->next[c];\n\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,int> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        // dp[0][0][0][pma.getRoot()] = 1LL;\n\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (from[i].size() > M || count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1;\n        }\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(to[i], now, count);\n            if (to[i].size() > M || count > 1) continue;\n            dp[to[i].size()][ston[to[i]]][count][now] = 1;\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            ll num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                            }\n                        }\n                    }\n                    dp[i][j][k].clear();\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n    \n    sm->feed(\"\",mr);\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      if(prev_word_length % 2) dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nshort move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MM = 150;\n\nstruct Node {\n  int id;\n  int next[MM];\n  int fail;\n  vector<int> value;\n  Node() {\n    for(int i=0; i<MM; ++i) next[i] = 0;\n    value.clear();\n  }\n};\n\nclass Trie {\npublic:\n  Trie(const vector<string> &vs) {\n    nodes.push_back(new Node()); // dummy\n    nodes.push_back(new Node());\n    for(int i=0; i<vs.size(); ++i)\n      insert(vs[i],i);\n  }\n  Trie() {\n    nodes.clear();\n  }\n\n  void insert(const string &s,int k) {\n    Node *cur = nodes[1];\n    for(int i=0; i<s.length(); ++i) {\n      if(cur->next[s[i]] == 0) {\n        cur->next[s[i]] = nodes.size();\n        nodes.push_back(new Node());\n      }\n      cur = nodes[cur->next[s[i]]];\n    }\n    cur->value.push_back(k);\n  }\n  vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n  Aho_Corasick(const vector<string> &vs) {\n    nodes = Trie(vs).nodes;\n    make_failure_link();\n  }\n\n  void make_failure_link() {\n    queue<int> q;\n    Node *root = nodes[1];\n    for(int i=0; i<MM; ++i) {\n      if(root->next[i]) {\n        nodes[root->next[i]]->fail = 1;\n        q.push(root->next[i]);\n      }else root->next[i] = 1;\n    }\n\n    while(!q.empty()) {\n      Node *t = nodes[q.front()]; q.pop();\n      for(int i=0; i<MM; ++i) {\n        int u = t->next[i];\n        if(u) {\n          q.push(u);\n          int r = t->fail;\n          while(!nodes[r]->next[i]) r = nodes[r]->fail;\n          nodes[u]->fail = nodes[r]->next[i];\n          FOR(it, nodes[nodes[u]->fail]->value) {\n            nodes[u]->value.push_back(*it);\n          }\n        }\n      }\n    }\n  }\n\n  pair<int, int> match(int v, const string &s) {\n    int cnt = 0;\n    for(int i=0; i<s.length(); ++i) {\n      while(!nodes[v]->next[s[i]]) {\n        v = nodes[v]->fail;\n      }\n      v = nodes[v]->next[s[i]];\n      if(!(nodes[v]->value.empty())) { // found the word\n        cnt += nodes[v]->value.size();\n      }\n    }\n    return make_pair(v, cnt);\n  }\n\n  // ツ個サツ催敖づ個湘ウツ妥板づ閉カツ篠堋づーツ与ツつヲツづ湘ウツ妥板遷ツ暗堋つウツつケツづゥツ。\n  // AOJ2212ツづづ債マツッツチツつオツつスツづァツつセツづ淞つセツづつスツづ個づ、ツマツッツチツつオツつスツづつォ-1ツづーツ陛板つキツづヲツつ、ツづ可つオツづつ「ツづゥツ。\n  int next(int v, char c) {\n    while(!nodes[v]->next[c]) {\n      v = nodes[v]->fail;\n    }\n    v = nodes[v]->next[c];\n    // if(!(nodes[v]->value.empty())) { // found the word\n    //   return -1;\n    // }\n    return v;\n  }\n  \n  int match(int v) {\n    return nodes[v]->value.size();\n  }\n  \n  void free() {\n    for(int i=0; i<nodes.size(); ++i)\n      delete nodes[i];\n  }\n\n  vector<Node*> nodes;\n};\n\nstruct P {\n  int state, now;\n  bool f;\n  P(int state, int now, bool f) : state(state),now(now),f(f) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.state!=b.state ? a.state<b.state :\n    a.now!=b.now ? a.now<b.now : a.f<b.f;\n}\nmap<P,int> dp[21];\n\nconst int MOD = 1e9+7;\nconst int M = 21;\nint main() {\n  int n, m, k;\n  while(cin >> n >> m >> k, n||m||k) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> g[500];\n    string str[500];\n    REP(i, n) {\n      string a, b;\n      cin >> a >> b;\n      if (mp.count(a) == 0) {\n        str[num] = a;\n        mp[a] = num++;\n      }\n      if (mp.count(b) == 0) {\n        str[num] = b;\n        mp[b] = num++;\n      }\n      g[mp[a]].push_back(mp[b]);\n    }\n    vector<string> vs(k);\n    REP(i, k) cin >> vs[i];\n    Aho_Corasick pma(vs);\n    int ssize = pma.nodes.size();\n\n    REP(i, M) dp[i].clear();\n    REP(i, num) {\n      pii p = pma.match(1, str[i]);\n      int ss = p.first, f = p.second;\n      if (f<=1) {\n        dp[str[i].size()][P(ss,i,f)] = 1;\n        //cout << str[i].size() << \": \" << ss << \" \" << i << \" \" << f << endl;\n      }\n    }\n    pii PMA[ssize][num];\n    for (int i=1; i<ssize; ++i) {\n      REP(j, num) {\n        PMA[i][j] = pma.match(i,str[j]);\n      }\n    }\n    for (int i=1; i<=m; ++i) {\n      if (i>=M) dp[i%M].clear(); \n      REP(j, num) {\n        FOR(it, g[j]) {\n          int len = str[*it].size();\n          int pos = i-len;\n          if (pos<0) continue;\n          for (int s=1; s<ssize; ++s) {\n            pii p = PMA[s][*it];\n            //pii p = pma.match(s, str[*it]);\n            int ss = p.first;\n            int f = p.second;\n            //cout << pos << \" \" << i << \" \" << j << \" \" << *it << \" \" << ss << \" \" << f << endl;\n            for (int l=0; l+f<=1; ++l) {\n              //cout << pos << \" \" << s << \" \" << j << \" \" << l << endl;\n              if (dp[pos%M].count(P(s,j,l))) {\n                // printf(\"(pos,s,j,l)=(%d,%d,%d,%d) -> \", pos,s,j,l);\n                // printf(\"(i,ss,*it,l+f)=(%d,%d,%d,%d)\\n\", i,ss,*it,l+f);\n                (dp[i%M][P(ss,*it,l+f)] += dp[pos%M][P(s,j,l)]) %= MOD;\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i, num) {\n      for (int s=1; s<ssize; ++s) {\n        ans = (ans + dp[m%M][P(s,i,1)]) % MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[128];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nint dp[30][500][600][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%30][w][x][res+t]+=dp[pos%30][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%30][0][0],dp[pos%30][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%30][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  string last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length <= word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& from = it->first;\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n\t}\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nconst int NUMC = 26;\n\nclass Trie {\npublic:\n\tvector<vector<int> > V;\n\tint find(string s) {\n\t\tint cur=0;\n\t\trep(i,s.size()){\n            if((cur=V[cur][s[i]+1])==0) return -1;\n        }\n\t\treturn cur;\n\t}\n\tvoid create(vector<string> S){\n\t\tV.clear();\n\t\tV.push_back(vector<int>(NUMC+1));\n\t\tsort(S.begin(),S.end());\n\t\trep(i,S.size()){\n\t\t\tint cur=0;\n\t\t\trep(j,S[i].size()){\n\t\t\t\tif(V[cur][S[i][j]+1]==0) V.push_back(vector<int>(NUMC+1)),V[cur][S[i][j]+1]=V.size()-1;\n\t\t\t\tcur=V[cur][S[i][j]+1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass ACmatch_num {\npublic:\n\tTrie t;\n\tvector<int> acc;\n\tint ma;\n\tvoid create(vector<string> S) {\n        rep(i,(int)S.size()){\n            rep(j,(int)S[i].size()){\n                S[i][j] -= 'a';\n            }\n        }\n\t\tint i;\n\t\tma=S.size();\n\t\tt.create(S);\n\t\tacc.clear();\n\t\tacc.resize(t.V.size());\n\t\trep(i,S.size()) acc[t.find(S[i])]++;\n\t\tqueue<int> Q;\n\t\trep(i,NUMC) if(t.V[0][i+1]) t.V[t.V[0][i+1]][0]=0, Q.push(t.V[0][i+1]);\n\n\t\twhile(!Q.empty()) {\n\t\t\tint k=Q.front(); Q.pop();\n\t\t\trep(i,NUMC) if(t.V[k][i+1]) {\n\t\t\t\tQ.push(t.V[k][i+1]);\n\t\t\t\tint pre=t.V[k][0];\n\t\t\t\twhile(pre && t.V[pre][i+1]==0) pre=t.V[pre][0];\n\t\t\t\tt.V[t.V[k][i+1]][0]=t.V[pre][i+1];\n\t\t\t\tacc[t.V[k][i+1]] += acc[t.V[pre][i+1]];\n\t\t\t}\n\t\t}\n\t}\n\tint match(string S) {\n        rep(i,(int)S.size()){\n            S[i] -= 'a';\n        }\n\t\tint R=0;\n\t\tint cur=0;\n\t\trep(i,(int)S.size()){\n\t\t\twhile(cur && t.V[cur][S[i]+1]==0) cur=t.V[cur][0];\n\t\t\tcur=t.V[cur][S[i]+1];\n\t\t\tR += acc[cur];\n\t\t}\n\t\treturn R;\n\t}\n};\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nvector<int> G[501];\n\nbool ok(int id,string& cri,map<pll,vi>* st,RollingHash& ch)\n{\n    if(len(st[len(cri)-id-1]) == 0){\n        return false;\n    }\n    pll foo = ch.hash(id,len(cri)-1);\n    if(st[len(cri)-id-1].find(foo) == st[len(cri)-id-1].end()){\n        return false;\n    }else{\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,K;\n        cin >> n >> m >> K;\n        if(n == 0){\n            break;\n        }\n        rep(i,501){\n            G[i].clear();\n        }\n        map<string,int> mp;\n        vs s,t(K);\n        int num = 0;\n        rep(i,n){\n            string a,b;\n            cin >> a >> b;\n            if(mp.find(a) == mp.end()){\n                s.pb(a);\n                mp[a] = num++;\n            }\n            if(mp.find(b) == mp.end()){\n                s.pb(b);\n                mp[b] = num++;\n            }\n            G[mp[a]].pb(mp[b]);\n        }\n        rep(i,num-1){\n            G[num].pb(i);\n        }\n        int comp[31][21][21];\n        vector<RollingHash> rh(K);\n        map<pll,vi> st[21];\n        rep(i,K){\n            cin >> t[i];\n            rh[i].init(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    st[k-j][rh[i].hash(j,k)] = {i,j,k};\n                }\n            }\n        }\n        ACmatch_num an;\n        an.create(t);\n        // cout << an.match(\"sakura\") << \"\\n\";\n        // cout << an.match(\"sakur\") << \"\\n\";\n        rep(i,K){\n            // show(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    // cout << j << \" \" << k << \"\\n\";\n                    comp[i][j][k] = an.match(t[i].substr(j,k-j+1));\n                }\n            }\n        }\n        map<vi,ll> dp[501];\n        dp[0][{-1,0,0,num,0}] = 1;\n        rep(i,m){\n            each(it,dp[i]){\n                int idx = it.fi[0], idy = it.fi[1], idz = it.fi[2],pre = it.fi[3],nw = it.fi[4];\n                ll val = it.se;\n                each(j,G[pre]){\n                    if(i+len(s[j]) > m){\n                        continue;\n                    }\n                    string cri;\n                    int diff = 0;\n                    if(idx == -1){\n                        cri = s[j];\n                    }else{\n                        cri = t[idx].substr(idy,idz-idy+1);\n                        cri += s[j];\n                        diff = comp[idx][idy][idz];\n                    }\n                    RollingHash ch;\n                    ch.init(cri);\n                    vi nx = {-1,0,0};\n                    int l = 0,r = len(cri)-1;\n                    if(ok(r,cri,st,ch)){\n                        while(r-l>1){\n                            int mid = (l+r)/2;\n                            if(ok(mid,cri,st,ch)){\n                                r = mid;\n                            }else{\n                                l = mid;\n                            }\n                        }\n                    }\n                    nx = st[len(cri)-r-1][ch.hash(r,len(cri)-1)];\n                    int res = an.match(cri) - diff;\n                    if(res == 1){\n                        if(nw == 0){\n                            dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] + val) % MOD;\n                        }\n                    }else{\n                        dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] + val) % MOD;\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        each(it,dp[m]){\n            ans += it.se;\n        }\n        cout << ans % MOD << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    multimap<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv.insert(pair<string,int>(*it,index - it->length() + 1));\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[5000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n\n    map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->set_state(start.id);\n      AhoCorasick::MatchingResult mr = sm->feed(words[i]);\n      //last_word,season_count,last_node\n      dp[words[i].size()][State(i,mr.rv.size(),mr.id)] = 1;\n    }\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      if(dp[prev_word_length].size() == 0) continue;\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  AhoCorasick::MatchingResult mr\n\t    = sm->feed(words[next_idx]);\n\t  \n\t  if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t     mr.id);\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    map<State,int>& last_state = dp[word_limit];\n    for(map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 250;\nconst int NODE=100;\nvector<int> redge[N];\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n/*\nint dp[101][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,len+1)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len+1){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\n\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n  }\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len][i][j][1])%mod;\n  return ret;\n}\n*/\n\n\nconst int MOD=30;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      redge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n      redge[tt].push_back(tf);\n    }\n    rep(i,m)cin>>kigo[i];\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n   // cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  short nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  TrieNode() : exist(0), accept(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n// class AhoCorasick {\n//     void clear_graph() {\n//         root.child.clear();\n//         root.pattern = 0;\n//     }\n//     void generate_trie(const vector<string>& patterns) {\n//         ll n = patterns.size();\n//         rep(i, n) {\n//             Node* t = &root;\n//             each(c, patterns[i]) {\n//                 if (t->child.count(c) == 0) {\n//                     t->child[c] = Node(nodes.size());\n//                     nodes.pb(&t->child[c]);\n//                 }\n//                 t = &(t->child[c]);\n//             }\n//             t->pattern++;\n//         }\n//     }\n//     void add_failure_edge() {\n//         queue<Node*> Q; Q.push(&root);\n//         //幅優先探索で帰納的に失敗時の遷移辺を追加していく\n//         while (!Q.empty()) {\n//             Node* t = Q.front(); Q.pop();\n//             each(p, t->child) {\n//                 Q.push(&(p.second));\n//                 char c = p.first;\n//                 Node* node = &(p.second); // 文字cで遷移する頂点\n//                 Node* anode = t->failure; // 失敗したときの遷移先\n//                 while ( anode != NULL && anode->child.count(c) == 0 ) {\n//                     anode = anode->failure;\n//                 }\n//                 //遷移失敗時に続けられる別の頂点へ遷移\n//                 if (anode == NULL) {\n//                     node->failure = &root;\n//                 }\n//                 else {\n//                     node->failure = &(anode->child[c]);\n//                 }\n//                 //マッチするパターンを追加\n//                 node->pattern += node->failure->pattern;\n//             }\n//         }\n//     }\n//     //Pattern Match Automatonを構築\n//     void make_PMA(const vector<string>& patterns) {\n//         clear_graph();\n//         generate_trie(patterns);\n//         add_failure_edge();\n//     }\n// public:\n//     struct Node {\n//         ll id;\n//         map<char,Node> child; //遷移辺(!)\n//         ll pattern;\n//         Node* failure; //遷移失敗時の遷移先ノード\n//         Node():failure(NULL), pattern(0) {\n//         }\n//         Node(ll id):failure(NULL), id(id), pattern(0) {}\n//     };\n//     vector<Node*> nodes;\n//     Node root;\n//     AhoCorasick(const vector<string>& patterns) : nodes(0), root(0) {\n//         nodes.assign(1, &root);\n//         make_PMA(patterns);\n//     }\n//     pair<Node*, ll> find(Node* node, char c) {\n//         ll res = 0;\n//         while (node != NULL && node->child.count(c) == 0) {\n//             node = node->failure;\n//         }\n//         if (node == NULL) node = &root;\n//         else node = &(node->child[c]);\n//         res += node->pattern;\n//         return {node, res};\n//     }\n//     pair<ll, ll> find(ll nid, char c) {\n//         auto res = find(nodes[nid], c);\n//         return {res.first->id, res.second};\n//     }\n// };\nclass AhoCorasick {\n    vector<map<char, ll>> G;\n    vector<ll> failure, pattern;\n    ll fresh_node() {\n        const ll res = G.size();\n        G.resize(res+1);\n        pattern.pb(-1);\n        return res;\n    }\n    ll follow(ll v, char c) const {\n        while (v >= 0 && G[v].count(c) == 0) {\n            v = failure[v];\n        }\n        return v < 0 ? 0 : G[v].find(c)->second;\n    }\n    void generate_trie(const vector<string>& patterns) {\n        rep(i, patterns.size()) {\n            ll v = 0;\n            each(c, patterns[i]) {\n                if (G[v].count(c) == 0) {\n                    G[v][c] = fresh_node();\n                }\n                v = G[v][c];\n            }\n            pattern[v] = i;\n        }\n    }\n    void add_failure_edge() {\n        queue<ll> Q; Q.push(0);\n        failure.assign(size(), -1);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(p, G[v]) {\n                char c; ll to; tie(c, to) = p;\n                Q.push(p.second);\n                failure[to] = follow(failure[v], c);\n            }\n        }\n    }\npublic:\n    AhoCorasick(const vector<string>& patterns) : G(1), pattern(1, -1) {\n        generate_trie(patterns);\n        add_failure_edge();\n    }\n    size_t size() const {\n        return G.size();\n    }\n    pair<ll, vector<ll>> find(ll v, char c) const {\n        vector<ll> res;\n        v = follow(v, c);\n        ll now = v;\n        while (now >= 0) {\n            if (pattern[now] >= 0) res.pb(pattern[now]);\n            now = failure[now];\n        }\n        return {v, res};\n    }\n};\n\nconst ll mod = 1e9+7;\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n    ll res = 1;\n    each(v, t) res = mul(res, v);\n    return res;\n}\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n    ll res = 0;\n    each(v, t) res = add(res, v);\n    return res;\n}\nll sub(ll a, ll b) {\n    return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = sub(res, *(it++));\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = divi(res, *(it++));\n    }\n    return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n    fact.assign(n+1, 1);\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i-1], i);\n    }\n}\n\nll comb(ll n, ll r) {\n    if (r < 0) return 0;\n    if (r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) {\n    Matrix res(n, Row(n, 0));\n    rep(i, n) res[i][i] = 1;\n    return res;\n}\nMatrix mul(const Matrix& A, const Matrix& B) {\n    const ll n = A.size(), m = A[0].size(), l = B[0].size();\n    assert(m == B.size());\n    Matrix res(n, Row(l, 0));\n    rep(i, n) rep(j, m) rep(k, l) {\n        res[i][k] = add(res[i][k], mul(A[i][j], B[j][k]));\n    }\n    return res;\n}\nMatrix power(Matrix A, ll n) {\n    assert(A.size() == A[0].size());\n    Matrix res = E(A.size());\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, A);\n        A = mul(A, A);\n    }\n    return res;\n}\nconst ll M = 21;\nint dp[M][501][2][600];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    // AhoCorasick aaa({\"a\", \"b\", \"c\", \"aa\"});\n    // cout << aaa.find(aaa.find(0LL, 'a').first, 'a').second << endl;\n    // return 0;\n    ll n, m, K;\n    while (cin >> n >> m >> K, n || m || K) {\n        map<string, ll> words;\n        vector<vector<ll>> G(1);\n        auto get_word_id = [&](const string& word) {\n            if (words.count(word) == 0) {\n                ll wid = words.size();\n                words[word] = wid;\n                G.resize(words.size()+1);\n            }\n            return words[word];\n        };\n        rep(i, n) {\n            string s, t; cin >> s >> t;\n            ll a = get_word_id(s);\n            ll b = get_word_id(t);\n            G[a].pb(b);\n        }\n        vector<string> rwords(words.size());\n        each(p, words) {\n            rwords[p.second] = p.first;\n            G.back().pb(p.second);\n        }\n        vector<string> sws(K); cin >> sws;\n        AhoCorasick ac(sws);\n        const ll V = ac.size();\n        fill(dp[0][0][0], dp[M-1][500][2], 0);\n        // vector<vector<vector<vector<int>>>> dp(M, vector<vector<vector<int>>>(G.size(), vector<vector<int>>(2, vector<int>(V, 0))));\n        dp[0][G.size()-1][0][0] = 1;\n        vector<vector<P>> g(V, vector<P>(words.size()));\n        rep(i, V) rep(j, words.size()) {\n            ll cnt = 0, nid = i;\n            each(c, rwords[j]) {\n                pair<ll, vector<ll>> result = ac.find(nid, c);\n                nid = result.first;\n                cnt += result.second.size();\n            }\n            g[i][j] = {cnt, nid};\n        }\n        rep(i, m) {\n            fill(dp[(i-1+M)%M][0][0], dp[(i-1+M)%M][500][2], 0);\n            // dp[(i-1+M)%M].assign(G.size(), vector<vector<int>>(2, vector<int>(V, 0)));\n            rep(j, G.size()) rep(k, 2) rep(l, V) {\n                if (dp[i%M][j][k][l] == 0) continue;\n                each(to, G[j]) {\n                    ll cnt, nid; tie(cnt, nid) = g[l][to];\n                    if (cnt + k > 1) continue;\n                    ll ni = i + rwords[to].size();\n                    ll nj = to;\n                    ll nk = k + cnt;\n                    ll nl = nid;\n                    if (ni > m) continue;\n                    assert(ni < m+1 && nj < G.size() && nk < 2 && nl < V);\n                    // cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n                    // cout << \"-> \" << ni << \" \" << nj << \" \" << nk << \" \" << nl << endl;\n                    dp[ni%M][nj][nk][nl] = add(dp[ni%M][nj][nk][nl], dp[i%M][j][k][l]);\n                }\n            }\n        }\n        // cout << dp << endl;\n        ll ans = 0;\n        rep(i, G.size()) rep(j, V) {\n            ans = add(ans, dp[m%M][i][1][j]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nbool is_suffix(string const & a, string const & b) {\n    if (a.length() > b.length()) return false;\n    return b.compare(b.length() - a.length(), b.length(), a) == 0;\n}\nconstexpr int mod = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, k; cin >> n >> m >> k;\n        if (n == 0) break;\n        multimap<string, string> conn;\n        repeat (i, n) {\n            string from, to; cin >> from >> to;\n            conn.emplace(from, to);\n        }\n        vector<string> seasonword(k);\n        repeat (i, k) {\n            cin >> seasonword[i];\n        }\n        // solve\n        unordered_map<string, int> count_seasonwords_memo;\n        auto count_seasonwords = [&](string const & s) {\n            if (count_seasonwords_memo.count(s)) return count_seasonwords_memo[s];\n            int cnt = 0;\n            repeat (i, k) {\n                for (int j = 0; ; ) {\n                    j = s.find(seasonword[i], j);\n                    if (j == string::npos) break;\n                    ++ j;\n                    ++ cnt;\n                    if (cnt >= 2) return count_seasonwords_memo[s] = cnt;\n                }\n            }\n            return count_seasonwords_memo[s] = cnt;\n        };\n        unordered_map<string, string> shrink_memo;\n        auto shrink = [&](string s) {\n            if (shrink_memo.count(s)) return shrink_memo[s];\n            int len = 0;\n            repeat (i, k) {\n                string t = seasonword[i];\n                if (t.length() > s.length()) t = t.substr(0, s.length());\n                for (; not t.empty(); t.pop_back()) {\n                    if (is_suffix(t, s)) {\n                        setmax<int>(len, t.length());\n                        break;\n                    }\n                }\n            }\n            return shrink_memo[s] = s.substr(s.length() - len);\n        };\n        vector<string> word;\n        map<string, int> index;\n        for (auto const & it : conn) {\n            for (string s : { it.first, it.second }) {\n                if (not index.count(s)) {\n                    index.emplace(s, index.size());\n                    word.push_back(s);\n                }\n            }\n        }\n        vector<vector<int> > g(word.size());\n        for (auto const & it : conn) {\n            g[index[it.first]].push_back(index[it.second]);\n        }\n        vector<map<tuple<int, bool, string>, int> > dp(m + 1);\n        repeat (i, word.size()) if (word[i].length() <= m) {\n            int season = count_seasonwords(word[i]);\n            if (season >= 2) continue;\n            dp[word[i].length()][make_tuple(i, bool(season), word[i])] += 1;\n        }\n        repeat (l, m) {\ncerr << \"loop \" << l << \" / \" << dp[l].size() << endl;\n            for (auto const & state : dp[l]) {\n                int i; bool is_season; string s; tie(i, is_season, s) = state.first;\n                int cnt = state.second;\n// cerr << s << \" / \" << cnt << endl;\n                int count_seasonwords_s = count_seasonwords(s);\n                for (int j : g[i]) if (l + word[j].length() <= m) {\n                    string t = s + word[j];\n                    int next_season = is_season + count_seasonwords(t) - count_seasonwords_s;\n                    if (next_season >= 2) continue;\n                    int & it = dp[l + word[j].length()][make_tuple(j, bool(next_season), shrink(t))];\n                    it = (it + cnt) % mod;\n                }\n            }\n            dp[l] = map<tuple<int, bool, string>, int>(); // release\n        }\n        // output\n        int result = 0;\n        for (auto const & state : dp[m]) {\n            bool is_season; tie(ignore, is_season, ignore) = state.first;\n            if (not is_season) continue;\n            int cnt = state.second;\n            result = (result + cnt) % mod;\n        }\n        cout << result << endl;\ncerr << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int ALPHA = 26;\nconstexpr int BASE = 'a';\n\nconstexpr int MAX_N = 250;\nconstexpr int MAX_LEN = 20;\nconstexpr int MAX_K = 30;\nconstexpr int MAX_V = MAX_LEN * MAX_K + 1;\n\nconstexpr int mod = 1000000007;\n\nstruct trie {\n\tint v;\n\tint failure;\n\tarray<int, ALPHA> next;\n\tint match;\n\n\texplicit trie(int v_):v(v_), failure(0), match(0) { next.fill(-1); }\n};\n\nvector<trie> nodes;\n\nvoid add(const string &s) {\n\tint v = 0;\n\n\tfor(const char &c : s) {\n\t\tconst int id = c - BASE;\n\t\tif(nodes[v].next[id] == -1) {\n\t\t\tnodes[v].next[id] = nodes.size();\n\t\t\tnodes.emplace_back(nodes.size());\n\t\t}\n\t\tv = nodes[v].next[id];\n\t}\n\tnodes[v].match = 1;\n}\n\nvoid construct(const vector<string> &dict) {\n\tnodes.clear();\n\tnodes.emplace_back(0);\n\n\tfor(const auto &s : dict) {\n\t\tadd(s);\n\t}\n\n\tqueue<int> que;\n\tque.push(0);\n\n\twhile(!que.empty()) {\n\t\tconst trie &current = nodes[que.front()];\n\t\tque.pop();\n\n\t\tfor(int i = 0; i < ALPHA; ++i) {\n\t\t\tconst int next_id = current.next[i];\n\n\t\t\tif(next_id == -1) continue;\n\n\t\t\tque.push(next_id);\n\n\t\t\ttrie &u = nodes[next_id];\n\n\t\t\tif(current.v) {\n\t\t\t\tint f = current.failure;\n\t\t\t\twhile(f && nodes[f].next[i] == -1) {\n\t\t\t\t\tf = nodes[f].failure;\n\t\t\t\t}\n\n\t\t\t\tconst int nf = nodes[f].next[i];\n\n\t\t\t\tif(nf != -1) {\n\t\t\t\t\tu.failure = nf;\n\t\t\t\t\tu.match += nodes[nf].match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\npair<int, int> move_to(int v, const string &s) {\n\tint match = 0;\n\n\tfor(const char &c : s) {\n\t\tconst int id = c - BASE;\n\t\t\n\t\twhile(v && nodes[v].next[id] == -1) {\n\t\t\tv = nodes[v].failure;\n\t\t}\n\n\t\tif(v == 0 && nodes[v].next[id] == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tv = nodes[v].next[id];\n\t\tmatch += nodes[v].match;\n\t}\n\n\treturn {v, match};\n}\n\nunordered_map<string, int> converter(MAX_N);\nvector<string> words;\nvector<vector<int>> G;\n\nint encode(const string &s) {\n\tif(!converter.count(s)) {\n\t\tconverter.insert({s, converter.size()});\n\t\twords.emplace_back(s);\n\t\tG.emplace_back();\n\t}\n\treturn converter[s];\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tnodes.reserve(MAX_V);\n\twords.reserve(MAX_N);\n\tG.reserve(MAX_N * 2);\n\n\tfor(int n, m, k; cin >> n >> m >> k && n;) {\n\t\tconverter.clear();\n\t\twords.clear();\n\t\tG.clear();\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tG[encode(from)].emplace_back(encode(to));\n\t\t}\n\n\t\tvector<string> seasonwords(k);\n\t\tfor(auto &e : seasonwords) cin >> e;\n\t\tconstruct(seasonwords);\n\n\t\tconst int num = words.size();\n\n\t\ttypedef tuple<int, int, bool> state; // last word, trie v, exist seasonword\n\t\tvector<map<state, int>> dp(m + 1);\n\n\t\tfor(int i = 0; i < num; ++i) {\n\t\t\tif(static_cast<int>(words[i].size()) > m) continue;\n\n\t\t\tconst auto p = move_to(0, words[i]);\n\t\t\tif(p.second <= 1) dp[words[i].size()][state(i, p.first, p.second)] = 1;\n\t\t}\n\n\t\tfor(int len = 1; len < m; ++len) {\n\t\t\tfor(const auto &curr : dp[len]) {\n\t\t\t\tint w, v;\n\t\t\t\tint match;\n\t\t\t\ttie(w, v, match) = curr.first;\n\n\t\t\t\tfor(const auto &to : G[w]) {\n\t\t\t\t\tconst int sum_len = len + words[to].size();\n\t\t\t\t\tif(sum_len > m) continue;\n\n\t\t\t\t\tconst auto p = move_to(v, words[to]);\n\t\t\t\t\tconst int sum_match = match + p.second;\n\t\t\t\t\tif(sum_match > 1) continue;\n\n\t\t\t\t\tauto &target = dp[sum_len][state(to, p.first, sum_match)];\n\t\t\t\t\ttarget += curr.second;\n\t\t\t\t\tif(target >= mod) target -= mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp[len].clear();\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(const auto &e : dp[m]) {\n\t\t\tif(get<2>(e.first)) {\n\t\t\t\tans += e.second;\n\t\t\t\tif(ans >= mod) ans -= mod;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\nint wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,MAX_ps) cans[i].clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],a[i%21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i%21][j][k]=b[i%21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  void init()\n  {\n    exist = accept = 0;\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nTrieNode nodes[600];\n\nstruct Trie\n{\n  int ptr;\n\n  Trie()\n  {\n    nodes[0].init();\n    ptr = 1;\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[ptr].init();\n        nodes[node_index].nxt[c] = ptr++;\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return (ptr);\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,MAX_ps) cans[i].clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni%21][ne[j][u]][u],a[i%21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni%21][ne[j][u]][u],b[i%21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i%21][j][k]=b[i%21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nconst int MM = 150;\n\nstruct Node {\n  int id;\n  int next[MM];\n  int fail;\n  vector<int> value;\n  Node() {\n    for(int i=0; i<MM; ++i) next[i] = 0;\n    value.clear();\n  }\n};\n\nclass Trie {\npublic:\n  Trie(const vector<string> &vs) {\n    nodes.push_back(new Node()); // dummy\n    nodes.push_back(new Node());\n    for(int i=0; i<vs.size(); ++i)\n      insert(vs[i],i);\n  }\n  Trie() {\n    nodes.clear();\n  }\n\n  void insert(const string &s,int k) {\n    Node *cur = nodes[1];\n    for(int i=0; i<s.length(); ++i) {\n      if(cur->next[s[i]] == 0) {\n        cur->next[s[i]] = nodes.size();\n        nodes.push_back(new Node());\n      }\n      cur = nodes[cur->next[s[i]]];\n    }\n    cur->value.push_back(k);\n  }\n  vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n  Aho_Corasick(const vector<string> &vs) {\n    nodes = Trie(vs).nodes;\n    make_failure_link();\n  }\n\n  void make_failure_link() {\n    queue<int> q;\n    Node *root = nodes[1];\n    for(int i=0; i<MM; ++i) {\n      if(root->next[i]) {\n        nodes[root->next[i]]->fail = 1;\n        q.push(root->next[i]);\n      }else root->next[i] = 1;\n    }\n\n    while(!q.empty()) {\n      Node *t = nodes[q.front()]; q.pop();\n      for(int i=0; i<MM; ++i) {\n        int u = t->next[i];\n        if(u) {\n          q.push(u);\n          int r = t->fail;\n          while(!nodes[r]->next[i]) r = nodes[r]->fail;\n          nodes[u]->fail = nodes[r]->next[i];\n          FOR(it, nodes[nodes[u]->fail]->value) {\n            nodes[u]->value.push_back(*it);\n          }\n        }\n      }\n    }\n  }\n\n  pair<int, int> match(int v, const string &s) {\n    int cnt = 0;\n    for(int i=0; i<s.length(); ++i) {\n      while(!nodes[v]->next[s[i]]) {\n        v = nodes[v]->fail;\n      }\n      v = nodes[v]->next[s[i]];\n      if(!(nodes[v]->value.empty())) { // found the word\n        cnt += nodes[v]->value.size();\n      }\n    }\n    return make_pair(v, cnt);\n  }\n\n  // ツ個サツ催敖づ個湘ウツ妥板づ閉カツ篠堋づーツ与ツつヲツづ湘ウツ妥板遷ツ暗堋つウツつケツづゥツ。\n  // AOJ2212ツづづ債マツッツチツつオツつスツづァツつセツづ淞つセツづつスツづ個づ、ツマツッツチツつオツつスツづつォ-1ツづーツ陛板つキツづヲツつ、ツづ可つオツづつ「ツづゥツ。\n  int next(int v, char c) {\n    while(!nodes[v]->next[c]) {\n      v = nodes[v]->fail;\n    }\n    v = nodes[v]->next[c];\n    // if(!(nodes[v]->value.empty())) { // found the word\n    //   return -1;\n    // }\n    return v;\n  }\n  \n  int match(int v) {\n    return nodes[v]->value.size();\n  }\n  \n  void free() {\n    for(int i=0; i<nodes.size(); ++i)\n      delete nodes[i];\n  }\n\n  vector<Node*> nodes;\n};\n\nstruct P {\n  int state, now;\n  bool f;\n  P(int state, int now, bool f) : state(state),now(now),f(f) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.state!=b.state ? a.state<b.state :\n    a.now!=b.now ? a.now<b.now : a.f<b.f;\n}\nmap<P,int> dp[21];\n\nconst int MOD = 1e9+7;\nconst int M = 21;\nint main() {\n  int n, m, k;\n  while(cin >> n >> m >> k, n||m||k) {\n    map<string, int> mp;\n    int num = 0;\n    vector<int> g[500];\n    string str[500];\n    REP(i, n) {\n      string a, b;\n      cin >> a >> b;\n      if (mp.count(a) == 0) {\n        str[num] = a;\n        mp[a] = num++;\n      }\n      if (mp.count(b) == 0) {\n        str[num] = b;\n        mp[b] = num++;\n      }\n      g[mp[a]].push_back(mp[b]);\n    }\n    vector<string> vs(k);\n    REP(i, k) cin >> vs[i];\n    Aho_Corasick pma(vs);\n    int ssize = pma.nodes.size();\n\n    REP(i, M) dp[i].clear();\n    REP(i, num) {\n      pii p = pma.match(1, str[i]);\n      int ss = p.first, f = p.second;\n      if (f<=1) {\n        dp[str[i].size()][P(ss,i,f)] = 1;\n        //cout << str[i].size() << \": \" << ss << \" \" << i << \" \" << f << endl;\n      }\n    }\n    for (int i=1; i<=m; ++i) {\n      if (i>=M) dp[i%M].clear(); \n      REP(j, num) {\n        FOR(it, g[j]) {\n          int len = str[*it].size();\n          int pos = i-len;\n          if (pos<0) continue;\n          for (int s=1; s<ssize; ++s) {\n            pii p = pma.match(s, str[*it]);\n            int ss = p.first;\n            int f = p.second;\n            //cout << pos << \" \" << i << \" \" << j << \" \" << *it << \" \" << ss << \" \" << f << endl;\n            for (int l=0; l+f<=1; ++l) {\n              //cout << pos << \" \" << s << \" \" << j << \" \" << l << endl;\n              if (dp[pos%M].count(P(s,j,l))) {\n                // printf(\"(pos,s,j,l)=(%d,%d,%d,%d) -> \", pos,s,j,l);\n                // printf(\"(i,ss,*it,l+f)=(%d,%d,%d,%d)\\n\", i,ss,*it,l+f);\n                (dp[i%M][P(ss,*it,l+f)] += dp[pos%M][P(s,j,l)]) %= MOD;\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(i, num) {\n      for (int s=1; s<ssize; ++s) {\n        ans = (ans + dp[m%M][P(s,i,1)]) % MOD;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    multimap<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv.insert(pair<string,int>(*it,index - it->length() + 1));\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n\n    map<State,int> dp[600];\n\n    //init\n    for(map<string,vector<string> >::iterator conn_it = connects.begin();\n\tconn_it != connects.end();\n\tconn_it++){\n\n      const string& from = conn_it->first;\n      sm->set_state(start.id);\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n      \n      //last_word,season_count,last_node\n      dp[from.size()][State(from,mr.rv.size(),mr.id)] = 1;\n\n      for(int i = 0; i< conn_it->second.size();i++){\n      \tconst string& to = conn_it->second[i];\n      \tsm->set_state(start.id);\n      \tmr = sm->feed(to);\n\n      \tdp[to.size()][State(to,mr.rv.size(),mr.id)] = 1;\n      }\n    }\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      if(dp[prev_word_length].size() == 0) continue;\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tmap<string,vector<string> >::iterator conn_it;\n\tif((conn_it = connects.find(prev_state_it->first.last_word))\n\t   != connects.end()){\n\n\t  for(int to_idx = 0; to_idx < conn_it->second.size(); to_idx++){\n\t    const string& to = conn_it->second[to_idx];\n\n\t    sm->set_state(prev_state_it->first.last_node_address);\n\t    AhoCorasick::MatchingResult mr = sm->feed(to);\n\t      \n\t    if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t    //last_word,season_count,last_node\n\t    State next(to, \n\t\t       prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t       mr.id);\n\t    \n\t    dp[prev_word_length + to.size()][next]\n\t      += prev_state_it->second % MOD;\n\t    \n\t    dp[prev_word_length + to.size()][next] %= MOD;\n\t  }\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    map<State,int>& last_state = dp[word_limit];\n    for(map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nunordered_map<string,int> dp[501][251][2];\nunordered_map<string,int> S;\n\nint N,M,K;\nvector<int> G[255];\nstring Sm[255];\nstring Sk[55];\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<=M;j++){\n      dp[i][j][0].clear();\n      dp[i][j][1].clear();\n    }\n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\nint check(string &s){\n  int cnt = 0;\n  string ret = \"!\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"!\" ) ret = Sk[i].substr(0,ss.size());\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  if( ret == \"!\" ) s=\"\";\n  else  s = ret;\n  return cnt;\n}\nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  if( dp[n][m][cnt].count(str) != 0 ) return dp[n][m][cnt][str];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n     return dp[n][m][cnt][str] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    int nct = cnt + check(rs);\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n\n  // cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[n][m][cnt][str] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n \n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      int cnt = check(rs);\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=550;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass AhoCorasick {\n    void clear_graph() {\n        root.child.clear();\n        root.pattern = 0;\n    }\n    void generate_trie(const vector<string>& patterns) {\n        ll n = patterns.size();\n        rep(i, n) {\n            Node* t = &root;\n            each(c, patterns[i]) {\n                if (t->child.count(c) == 0) {\n                    t->child[c] = Node(nodes.size());\n                    nodes.pb(&t->child[c]);\n                }\n                t = &(t->child[c]);\n            }\n            t->pattern++;\n        }\n    }\n    void add_failure_edge() {\n        queue<Node*> Q; Q.push(&root);\n        //幅優先探索で帰納的に失敗時の遷移辺を追加していく\n        while (!Q.empty()) {\n            Node* t = Q.front(); Q.pop();\n            each(p, t->child) {\n                Q.push(&(p.second));\n                char c = p.first;\n                Node* node = &(p.second); // 文字cで遷移する頂点\n                Node* anode = t->failure; // 失敗したときの遷移先\n                while ( anode != NULL && anode->child.count(c) == 0 ) {\n                    anode = anode->failure;\n                }\n                //遷移失敗時に続けられる別の頂点へ遷移\n                if (anode == NULL) {\n                    node->failure = &root;\n                }\n                else {\n                    node->failure = &(anode->child[c]);\n                }\n                //マッチするパターンを追加\n                node->pattern += node->failure->pattern;\n            }\n        }\n    }\n    //Pattern Match Automatonを構築\n    void make_PMA(const vector<string>& patterns) {\n        clear_graph();\n        generate_trie(patterns);\n        add_failure_edge();\n    }\npublic:\n    struct Node {\n        ll id;\n        map<char,Node> child; //遷移辺(!)\n        ll pattern;\n        Node* failure; //遷移失敗時の遷移先ノード\n        Node():failure(NULL), pattern(0) {\n        }\n        Node(ll id):failure(NULL), id(id), pattern(0) {}\n    };\n    vector<Node*> nodes;\n    Node root;\n    AhoCorasick(const vector<string>& patterns) : nodes(0), root(0) {\n        nodes.assign(1, &root);\n        make_PMA(patterns);\n    }\n    pair<Node*, ll> find(Node* node, char c) {\n        ll res = 0;\n        while (node != NULL && node->child.count(c) == 0) {\n            node = node->failure;\n        }\n        if (node == NULL) node = &root;\n        else node = &(node->child[c]);\n        res += node->pattern;\n        return {node, res};\n    }\n    pair<ll, ll> find(ll nid, char c) {\n        auto res = find(nodes[nid], c);\n        return {res.first->id, res.second};\n    }\n};\nconst ll mod = 1e9+7;\nll mul(ll a, ll b) {\n    return a * b % mod;\n}\nll mul(initializer_list<ll> t) {\n    ll res = 1;\n    each(v, t) res = mul(res, v);\n    return res;\n}\nll add(ll a, ll b) {\n    return (a + b) % mod;\n}\nll add(initializer_list<ll> t) {\n    ll res = 0;\n    each(v, t) res = add(res, v);\n    return res;\n}\nll sub(ll a, ll b) {\n    return (a - b + mod) % mod;\n}\nll sub(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = sub(res, *(it++));\n    }\n    return res;\n}\nll power(ll x, ll n) {\n    ll res = 1;\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, x);\n        x = mul(x, x);\n    }\n    return res;\n}\nll inv(ll n) {\n    return power(n, mod-2);\n}\nll divi(ll a, ll b) {\n    return mul(a, inv(b));\n}\nll divi(initializer_list<ll> t) {\n    auto it = t.begin();\n    ll res = *(it++);\n    while (it != t.end()) {\n        res = divi(res, *(it++));\n    }\n    return res;\n}\nvector<ll> fact;\nvoid init_fact(ll n) {\n    fact.assign(n+1, 1);\n    FOR(i, 1, fact.size()) {\n        fact[i] = mul(fact[i-1], i);\n    }\n}\n\nll comb(ll n, ll r) {\n    if (r < 0) return 0;\n    if (r > n) return 0;\n    return divi(fact[n], mul(fact[r], fact[n-r]));\n}\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) {\n    Matrix res(n, Row(n, 0));\n    rep(i, n) res[i][i] = 1;\n    return res;\n}\nMatrix mul(const Matrix& A, const Matrix& B) {\n    const ll n = A.size(), m = A[0].size(), l = B[0].size();\n    assert(m == B.size());\n    Matrix res(n, Row(l, 0));\n    rep(i, n) rep(j, m) rep(k, l) {\n        res[i][k] = add(res[i][k], mul(A[i][j], B[j][k]));\n    }\n    return res;\n}\nMatrix power(Matrix A, ll n) {\n    assert(A.size() == A[0].size());\n    Matrix res = E(A.size());\n    for (ll i = 1; i <= n; i <<= 1) {\n        if (i & n) res = mul(res, A);\n        A = mul(A, A);\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    // AhoCorasick aaa({\"a\", \"b\", \"c\", \"aa\"});\n    // cout << aaa.find(aaa.find(0LL, 'a').first, 'a').second << endl;\n    // return 0;\n    ll n, m, K;\n    while (cin >> n >> m >> K, n || m || K) {\n        map<string, ll> words;\n        vector<vector<ll>> G(1);\n        auto get_word_id = [&](const string& word) {\n            if (words.count(word) == 0) {\n                ll wid = words.size();\n                words[word] = wid;\n                G.resize(words.size()+1);\n            }\n            return words[word];\n        };\n        rep(i, n) {\n            string s, t; cin >> s >> t;\n            ll a = get_word_id(s);\n            ll b = get_word_id(t);\n            G[a].pb(b);\n        }\n        vector<string> rwords(words.size());\n        each(p, words) {\n            rwords[p.second] = p.first;\n            G.back().pb(p.second);\n        }\n        vector<string> sws(K); cin >> sws;\n        AhoCorasick ac(sws);\n        const ll V = ac.nodes.size();\n        const ll M = 25;\n        vector<vector<vector<vector<int>>>> dp(M, vector<vector<vector<int>>>(G.size(), vector<vector<int>>(2, vector<int>(V, 0))));\n        dp[0][G.size()-1][0][0] = 1;\n        vector<vector<P>> g(V, vector<P>(words.size()));\n        rep(i, V) rep(j, words.size()) {\n            ll cnt = 0, nid = i;\n            each(c, rwords[j]) {\n                pair<ll, ll> result = ac.find(nid, c);\n                nid = result.first;\n                cnt += result.second;\n            }\n            g[i][j] = {cnt, nid};\n        }\n        rep(i, m) {\n            dp[(i-1+M)%M].assign(G.size(), vector<vector<int>>(2, vector<int>(V, 0)));\n            rep(j, G.size()) rep(k, 2) rep(l, V) {\n                if (dp[i%M][j][k][l] == 0) continue;\n                each(to, G[j]) {\n                    ll cnt, nid; tie(cnt, nid) = g[l][to];\n                    if (cnt + k > 1) continue;\n                    ll ni = i + rwords[to].size();\n                    ll nj = to;\n                    ll nk = k + cnt;\n                    ll nl = nid;\n                    if (ni > m) continue;\n                    assert(ni < m+1 && nj < G.size() && nk < 2 && nl < V);\n                    // cout << i << \" \" << j << \" \" << k << \" \" << l << endl;\n                    // cout << \"-> \" << ni << \" \" << nj << \" \" << nk << \" \" << nl << endl;\n                    dp[ni%M][nj][nk][nl] = add(dp[ni%M][nj][nk][nl], dp[i%M][j][k][l]);\n                }\n            }\n        }\n        // cout << dp << endl;\n        ll ans = 0;\n        rep(i, G.size()) rep(j, V) {\n            ans = add(ans, dp[m%M][i][1][j]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][450][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v)\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define MOD 1000000007\n\nclass State\n{\npublic:\n\tint pv,wl,pl,f;\n\tState(int pv, int wl, int pl, int f)\n\t\t:pv(pv),wl(wl),pl(pl),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(pv!=s.pv) return pv<s.pv;\n\t\tif(wl!=s.wl) return wl<s.wl;\n\t\tif(pl!=s.pl) return pl<s.pl;\n\n\t\treturn f<s.f;\n\t}\n};\n\nmap<State, int> dp;\n//[OÉÂ©Á½âÂ(250)][Ç±ÜÅ(500)][PMAÇ±ÜÅ(20)][GêÌL³(2)]=%100000007\nint Psz;\n\nstruct PMA {\n\tint n;\n\tPMA *next[0x100]; // next[0] is for fail\n\tvector<int> accept;\n\tPMA() { fill(next, next+0x100, (PMA*)0); }\n\tPMA(int a)\n\t{\n\t\tn=a;\n\t\tfill(next, next+0x100, (PMA*)0);\n\t}\n};\nPMA *buildPMA(vector<string>& p, vector<PMA*>& vpma, int size) {\n  Psz=0;\n  PMA *root = new PMA(Psz++);\n  vpma.push_back(root);\n  for (int i = 0; i < size; ++i) { // make trie\n    PMA *t = root;\n    for (int j = 0; j<p[i].size(); ++j) {\n      char c = p[i][j];\n      if (t->next[c] == NULL) \n\t  {\n\t\t  t->next[c] = new PMA(Psz++);\n\t\t  vpma.push_back(t->next[c]);\n\t  }\n      t = t->next[c];\n    }\n    t->accept.push_back(i);\n  }\n  queue<PMA*> Q; // make failure link using bfs\n  for (int c = 'a'; c <= 'z'; ++c) {\n    if (root->next[c]) {\n      root->next[c]->next[0] = root;\n      Q.push(root->next[c]);\n    } else root->next[c] = root;\n  }\n  while (!Q.empty()) {\n    PMA *t = Q.front(); Q.pop();\n    for (int c = 'a'; c <= 'z'; ++c) {\n      if (t->next[c]) {\n        Q.push(t->next[c]);\n        PMA *r = t->next[0];\n        while (!r->next[c]) r = r->next[0];\n        t->next[c]->next[0] = r->next[c];\n      }\n    }\n  }\n  return root;\n}\n\nbool g[500][500];\n\nint match(string t, PMA *v, int &ret) {\n  int n = t.size();\n  int r = v->n;\n\n  for (int i = 0; i < n; ++i) {\n    char c = t[i];\n    while (!v->next[c]) v = v->next[0];\n    v = v->next[c];\n\tr = v->n;\n    for (int j = 0; j < v->accept.size(); ++j)\n      ret++;\n  }\n\n  return r;\n}\n\nint main()\n{\n\tint N,M,K;\n\twhile(cin >> N >> M >> K, (N||M||K))\n\t{\n\t\tdp.clear();\n\t\tmemset(g,0,sizeof(g));\n\n\t\tint d=0;\n\t\tmap<string, int> dic;\n\t\tvector<string> w(K);\n\t\tvector<string> str;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tcin >> s >> t;\n\t\t\tif(!dic.count(s)) \n\t\t\t{\n\t\t\t\tdic[s]=d++;\n\t\t\t\tstr.push_back(s);\n\t\t\t}\n\t\t\tif(!dic.count(t)) \n\t\t\t{\n\t\t\t\tdic[t]=d++;\n\t\t\t\tstr.push_back(t);\n\t\t\t}\n\n\t\t\tg[dic[s]][dic[t]]=1;\n\t\t}\n\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tw[i]=t;\n\t\t}\n\n\t\tvector<PMA*> vpma;\n\t\tPMA* tree=buildPMA(w,vpma,w.size());\n\t\tfor(int i=0; i<str.size(); i++)\n\t\t{\n\t\t\tPMA* p=tree;\n\t\t\tint c=0;\n\t\t\tint r=match(str[i], p, c);\n\t\t\tif(c>1) continue;\n\t\t\tState s=State(i,str[i].size(), r, c);\n\n\t\t\tdp[s]=1;\n\t\t}\n\n\t\t//[OÉÂ©Á½âÂ(500)][Ç±ÜÅ(500)][PMAÇ±ÜÅ(20)][GêÌL³(2)]=%100000007\n\t\tfor(int i=0; i<M; i++)\n\t\tfor(int j=0; j<str.size(); j++)\n\t\tfor(int k=0; k<Psz; k++)\n\t\tfor(int l=0; l<2; l++)\n\t\t{\n\t\t\tState t=State(j,i,k,l);\n\t\t\tif(!dp.count(t)) continue;\n\n\t\t\tfor(int m=0; m<str.size(); m++)\n\t\t\t{\n\t\t\t\tif(!g[j][m]) continue;\n\n\t\t\t\t\n\t\t\t\tint twl=t.wl+str[m].size();\n\t\t\t\tPMA* p=vpma[k];\n\t\t\t\tint ff=0;\n\t\t\t\tint r=match(str[m], p, ff);\n\t\t\t\tint tf=t.f+ff;\n\n\t\t\t\tif(twl>M) continue;\n\t\t\t\tif(tf>1) continue;\n\n\t\t\t\tState ns = State(m,twl,r, tf);\n\n\t\t\t\tif(!dp.count(ns)) \n\t\t\t\t{\n\t\t\t\t\tdp[ns]=dp[t];\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tdp[ns]+=dp[t];\n\t\t\t\t\tdp[ns]%=MOD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint ret=0;\n\t\tfor(int j=0; j<str.size(); j++)\n\t\tfor(int k=0; k<Psz; k++)\n\t\t{\n\t\t\tState s=State(j,M,k,1);\n\t\t\tif(!dp.count(s)) continue;\n\t\t\tret+=dp[s];\n\t\t\tret%=MOD;\n\t\t}\n\n\t\tcout << ret << endl;\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\t\tdelete vpma[i];\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nconst int NUMC = 26;\n\nclass Trie {\npublic:\n\tvector<vector<int> > V;\n\tint find(string s) {\n\t\tint cur=0;\n\t\trep(i,s.size()){\n            if((cur=V[cur][s[i]+1])==0) return -1;\n        }\n\t\treturn cur;\n\t}\n\tvoid create(vector<string> S){\n\t\tV.clear();\n\t\tV.push_back(vector<int>(NUMC+1));\n\t\tsort(S.begin(),S.end());\n\t\trep(i,S.size()){\n\t\t\tint cur=0;\n\t\t\trep(j,S[i].size()){\n\t\t\t\tif(V[cur][S[i][j]+1]==0) V.push_back(vector<int>(NUMC+1)),V[cur][S[i][j]+1]=V.size()-1;\n\t\t\t\tcur=V[cur][S[i][j]+1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass ACmatch_num {\npublic:\n\tTrie t;\n\tvector<int> acc;\n\tint ma;\n\tvoid create(vector<string> S) {\n        rep(i,(int)S.size()){\n            rep(j,(int)S[i].size()){\n                S[i][j] -= 'a';\n            }\n        }\n\t\tint i;\n\t\tma=S.size();\n\t\tt.create(S);\n\t\tacc.clear();\n\t\tacc.resize(t.V.size());\n\t\trep(i,S.size()) acc[t.find(S[i])]++;\n\t\tqueue<int> Q;\n\t\trep(i,NUMC) if(t.V[0][i+1]) t.V[t.V[0][i+1]][0]=0, Q.push(t.V[0][i+1]);\n\n\t\twhile(!Q.empty()) {\n\t\t\tint k=Q.front(); Q.pop();\n\t\t\trep(i,NUMC) if(t.V[k][i+1]) {\n\t\t\t\tQ.push(t.V[k][i+1]);\n\t\t\t\tint pre=t.V[k][0];\n\t\t\t\twhile(pre && t.V[pre][i+1]==0) pre=t.V[pre][0];\n\t\t\t\tt.V[t.V[k][i+1]][0]=t.V[pre][i+1];\n\t\t\t\tacc[t.V[k][i+1]] += acc[t.V[pre][i+1]];\n\t\t\t}\n\t\t}\n\t}\n\tint match(string S) {\n        rep(i,(int)S.size()){\n            S[i] -= 'a';\n        }\n\t\tint R=0;\n\t\tint cur=0;\n\t\trep(i,(int)S.size()){\n\t\t\twhile(cur && t.V[cur][S[i]+1]==0) cur=t.V[cur][0];\n\t\t\tcur=t.V[cur][S[i]+1];\n\t\t\tR += acc[cur];\n\t\t}\n\t\treturn R;\n\t}\n};\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nvector<int> G[501];\n\nbool ok(int id,string& cri,map<pll,vi>* st,RollingHash& ch)\n{\n    if(len(st[len(cri)-id-1]) == 0){\n        return false;\n    }\n    pll foo = ch.hash(id,len(cri)-1);\n    if(st[len(cri)-id-1].find(foo) == st[len(cri)-id-1].end()){\n        return false;\n    }else{\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,K;\n        cin >> n >> m >> K;\n        if(n == 0){\n            break;\n        }\n        rep(i,501){\n            G[i].clear();\n        }\n        map<string,int> mp;\n        vs s,t(K);\n        int num = 0;\n        rep(i,n){\n            string a,b;\n            cin >> a >> b;\n            if(mp.find(a) == mp.end()){\n                s.pb(a);\n                mp[a] = num++;\n            }\n            if(mp.find(b) == mp.end()){\n                s.pb(b);\n                mp[b] = num++;\n            }\n            G[mp[a]].pb(mp[b]);\n        }\n        rep(i,num){\n            G[num].pb(i);\n        }\n        int comp[31][21][21];\n        vector<RollingHash> rh(K);\n        map<pll,vi> st[21];\n        rep(i,K){\n            cin >> t[i];\n            rh[i].init(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    st[k-j][rh[i].hash(j,k)] = {i,j,k};\n                }\n            }\n        }\n        // each(it,st[0]){\n        //     spair(it.fi);\n        //     svec(it.se);\n        // }\n        ACmatch_num an;\n        an.create(t);\n        // cout << an.match(\"sakura\") << \"\\n\";\n        // cout << an.match(\"sakur\") << \"\\n\";\n        rep(i,K){\n            // show(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    // cout << j << \" \" << k << \"\\n\";\n                    comp[i][j][k] = an.match(t[i].substr(j,k-j+1));\n                }\n            }\n        }\n        map<vi,ll> dp[501];\n        dp[0][{-1,0,0,num,0}] = 1;\n        rep(i,m){\n            each(it,dp[i]){\n                int idx = it.fi[0], idy = it.fi[1], idz = it.fi[2],pre = it.fi[3],nw = it.fi[4];\n                ll val = it.se;\n                // svec(it.fi),show(it.se);\n                each(j,G[pre]){\n                    if(i+len(s[j]) > m){\n                        continue;\n                    }\n                    string cri;\n                    int diff = 0;\n                    if(idx == -1){\n                        cri = s[j];\n                    }else{\n                        cri = t[idx].substr(idy,idz-idy+1);\n                        cri += s[j];\n                        diff = comp[idx][idy][idz];\n                    }\n                    // show(pre);\n                    // show(cri);\n                    RollingHash ch;\n                    ch.init(cri);\n                    vi nx = {-1,0,0};\n                    int l = 0,r = len(cri)-1;\n                    if(ok(r,cri,st,ch)){\n                        while(r-l>1){\n                            int mid = (l+r)/2;\n                            if(ok(mid,cri,st,ch)){\n                                r = mid;\n                            }else{\n                                l = mid;\n                            }\n                        }\n                        nx = st[len(cri)-r-1][ch.hash(r,len(cri)-1)];\n                    }\n                    // spair(ch.hash(0,0));\n                    int res = an.match(cri) - diff;\n                    // cout << cri << \" \" << nw << \" \" << res << \"\\n\";\n                    // svec(nx);\n                    if(res == 1){\n                        if(nw == 0){\n                            dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] + val) % MOD;\n                        }\n                    }else{\n                        dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,nw}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,nw}] + val) % MOD;\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        each(it,dp[m]){\n            if(it.fi[4] == 1){\n                ans += it.se;\n            }\n        }\n        cout << ans % MOD << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m)rep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\tif(i>0&&j==w) continue;\n\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\tif(ni>m) continue;\n\t\t\t\tint nk=k,nl=l;\n\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t}\n\t\t\t\tif(nl>=2) continue;\n\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t}\n\t\t}\n\t\tll ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//謎 Runtime Error\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[621];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tfor(int i=0;i<621;i++)dp[i].clear();\n\t\tvector<int> to[250];\n\t\tstring str[500];\n\t\tmap<string,int> id;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tint len=i+str[dest].size();\n\t\t\t\t\t\tmap<S,int>::iterator it2=dp[len].find(t);\n\t\t\t\t\t\tif(it2==dp[len].end())it2=dp[len].insert(make_pair(t,0)).first;\n\t\t\t\t\t\tADD(it2->second,it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nbool is_prefix(string const & a, string const & b) {\n    return a.compare(0, b.length(), b);\n}\nconstexpr int mod = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, k; cin >> n >> m >> k;\n        if (n == 0) break;\n        multimap<string, string> conn;\n        repeat (i, n) {\n            string from, to; cin >> from >> to;\n            conn.emplace(from, to);\n        }\n        vector<string> seasonword(k);\n        repeat (i, k) {\n            cin >> seasonword[i];\n        }\n        // solve\n        auto count_seasonwords = [&](string const & s) {\n            int cnt = 0;\n            repeat (i, k) {\n                for (int j = 0; ; ) {\n                    j = s.find(seasonword[i], j);\n                    if (j == string::npos) break;\n                    ++ j;\n                    ++ cnt;\n                    if (cnt >= 2) return cnt;\n                }\n            }\n            return cnt;\n        };\n        int max_seasonword_length = 0;\n        repeat (i, k) {\n            setmax<int>(max_seasonword_length, seasonword[i].length());\n        }\n        auto shrink = [&](string s) {\n            int len = 0;\n            repeat (i, k) {\n                string t = seasonword[i];\n                if (t.length() > s.length()) t = t.substr(0, s.length());\n                for (; not t.empty(); t.pop_back()) {\n                    if (is_prefix(t, s)) {\n                        setmax<int>(len, t.length());\n                        break;\n                    }\n                }\n            }\n            return s.substr(s.length() - len);\n        };\n        vector<string> word;\n        map<string, int> index;\n        for (auto const & it : conn) {\n            for (string s : { it.first, it.second }) {\n                if (not index.count(s)) {\n                    index.emplace(s, index.size());\n                    word.push_back(s);\n                }\n            }\n        }\n        vector<vector<int> > g(word.size());\n        for (auto const & it : conn) {\n            g[index[it.first]].push_back(index[it.second]);\n        }\n        vector<map<tuple<int, bool, string>, int> > dp(m + 1);\n        repeat (i, word.size()) if (word[i].length() <= m) {\n            int season = count_seasonwords(word[i]);\n            if (season >= 2) continue;\n            dp[word[i].length()][make_tuple(i, bool(season), word[i])] += 1;\n        }\n        repeat (l, m) {\n            for (auto const & state : dp[l]) {\n                int i; bool is_season; string s; tie(i, is_season, s) = state.first;\n                int cnt = state.second;\n                int count_seasonwords_s = count_seasonwords(s);\n                for (int j : g[i]) if (l + word[j].length() <= m) {\n                    string t = s + word[j];\n                    int next_season = is_season + count_seasonwords(t) - count_seasonwords_s;\n                    if (next_season >= 2) continue;\n                    int & it = dp[l + word[j].length()][make_tuple(j, bool(next_season), shrink(t))];\n                    it = (it + cnt) % mod;\n                }\n            }\n            dp[l] = map<tuple<int, bool, string>, int>(); // release\n        }\n        // output\n        int result = 0;\n        for (auto const & state : dp[m]) {\n            bool is_season; tie(ignore, is_season, ignore) = state.first;\n            if (not is_season) continue;\n            int cnt = state.second;\n            result = (result + cnt) % mod;\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\nlong long mod=1000000007;\nchar in[30];\nstring table[600];\nvector<int>g[600];\nstruct wolf{\n\tint chi[26];\n\tint mark;\n\tint par;\n\tint fail;\n\tint var;\n\twolf(){\n\t\tfor(int i=0;i<26;i++)chi[i]=-1;mark=0;\n\t\tpar=fail=var=-1;\n\t}\n};\nwolf node[700];\nint ns;\nvoid add(){\n\tint at=0;\n\tfor(int i=0;in[i];i++){\n\t\tif(node[at].chi[in[i]-'a']==-1){\n\t\t\tnode[at].chi[in[i]-'a']=ns;\n\t\t\tnode[ns].par=at;\n\t\t\tnode[ns].var=in[i]-'a';\n\t\t\tat=ns++;\n\t\t}else{\n\t\t\tat=node[at].chi[in[i]-'a'];\n\t\t}\n\t}\n\tnode[at].mark++;\n}\nint n;\nvector<int>dp[2][520][520];\nint conv[520][520];\nint cs[520];\n//map<pair<pair<int,int>,pair<int,int> >,int>dp;\nint calc(int a,int b,int c,int d){\n//\tpair<pair<int,int>,pair<int,int> >state=make_pair(make_pair(a,b),make_pair(c,d));\n//\tif(dp.count(state))return dp[state];\n//\tprintf(\"%d %d %d %d %d\\n\",a,b,c,d,conv[b][c]);\n\tif(~dp[d][a][b][conv[b][c]])return dp[d][a][b][conv[b][c]];\n//\tprintf(\"%d %d %d %d %d\\n\",a,b,c,d,conv[b][c]);\n\tif(a==n){\n\t\tif(d==1)return 1;\n\t\telse return 0;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<g[b].size();i++){\n\t\tint to=c;\n\t\tint cnt=d;\n\t\tint use=g[b][i];\n\t\tif(a+table[use].size()>n)continue;\n\t\tfor(int j=0;j<table[use].size();j++){\n\t\t\twhile(1){\n\t\t\t\tif(node[to].chi[table[use][j]-'a']!=-1){\n\t\t\t\t\tto=node[to].chi[table[use][j]-'a'];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(to==0)break;\n\t\t\t\tto=node[to].fail;\n\t\t\t}\n\t\t\tcnt+=node[to].mark;\n\t\t}\n\t\tif(cnt>1)continue;\n\t\tret=(ret+calc(a+table[use].size(),use,to,cnt))%mod;\n\t}\n//\tprintf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n//\treturn dp[state]=ret;\n\treturn dp[d][a][b][conv[b][c]]=ret;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=b;\n\t\tmap<string,int> word;\n\t\tfor(int i=0;i<600;i++)g[i].clear();\n\t\tfor(int k=0;k<2;k++)for(int i=0;i<520;i++)for(int j=0;j<520;j++)dp[k][i][j].clear();\n\t\tfor(int i=0;i<520;i++)cs[i]=0;\n\t\tint sz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint P,Q2;\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring p=in;\n\t\t\tif(word.count(p))P=word[p];\n\t\t\telse{\n\t\t\t\tword[p]=sz;\n\t\t\t\ttable[sz]=p;\n\t\t\t\tP=sz++;\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring q=in;\n\t\t\tif(word.count(q))Q2=word[q];\n\t\t\telse{\n\t\t\t\tword[q]=sz;\n\t\t\t\ttable[sz]=q;\n\t\t\t\tQ2=sz++;\n\t\t\t}\n\t\t\tg[P].push_back(Q2);\n\t\t}\n\t\tfor(int i=0;i<600;i++)node[i]=wolf();\n\t\tns=1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tadd();\n\t\t}\n\t\tqueue<int>Q;\n\t\tQ.push(0);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tif(at==0||node[at].par==0)node[at].fail=0;\n\t\t\telse{\n\t\t\t\tint to=node[at].par;\n\t\t\t\twhile(1){\n\t\t\t\t\tint tmp=node[to].fail;\n\t\t\t\t\tif(node[tmp].chi[node[at].var]!=-1){\n\t\t\t\t\t\tnode[at].fail=node[tmp].chi[node[at].var];\n\t\t\t\t\t\tnode[at].mark+=node[node[at].fail].mark;\n\t\t\t\t\t}\n\t\t\t\t\tto=tmp;\n\t\t\t\t\tif(to==0){node[at].fail=0;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<26;i++)if(node[at].chi[i]!=-1){\n\t\t\t\tQ.push(node[at].chi[i]);\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<ns;i++){\n\t//\t\tprintf(\"%d: %d %d\\n\",i,node[i].fail,node[i].mark);\n\t//\t}\n\t//\tdp.clear();\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<ns;j++){\n\t\t\t\tbool ok=true;\n\t\t\t\tint at=j;\n\t\t\t\tint in=table[i].size()-1;\n\t\t\t\twhile(at&&in>=0){\n\t\t\t\t\tif(node[at].var!=table[i][in]-'a'){ok=false;break;}\n\t\t\t\t\tat=node[at].par;\n\t\t\t\t\tin--;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t//\tprintf(\"%d \",j);\n\t\t\t\t\tconv[i][j]=cs[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t\t//for(int i=0;i<sz;i++)printf(\"%d\\n\",cs[i]);\n\t\tconv[sz][0]=0;cs[sz]=1;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=b;j++)for(int k=0;k<=sz;k++){\n\t\t\tdp[i][j][k]=vector<int>(cs[k],-1);\n\t\t//\tprintf(\"%d %d %d: %u\\n\",i,j,k,dp[i][j][k].size());\n\t\t}\n\t\tfor(int i=0;i<sz;i++)g[sz].push_back(i);\n\t\tint ret=calc(0,sz,0,0);\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint main()\n{\n  int N, M, K;\n  string from[250], to[250];\n  string seasonword[30];\n  unordered_map< int, int > dp[501][500][2];\n\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[256];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nint dp[30][512][612][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%30][w][x][res+t]+=dp[pos%30][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%30][0][0],dp[pos%30][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%30][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define MOD 1000000007\n\nclass State\n{\npublic:\n\tint pv,pl,f;\n\tState(int pv, int pl, int f)\n\t\t:pv(pv),pl(pl),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(pv!=s.pv) return pv<s.pv;\n\t\tif(pl!=s.pl) return pl<s.pl;\n\n\t\treturn f<s.f;\n\t}\n};\n\nmap<State, int> dp[500];\n//[前につかったやつ(500)][どこまで(500)][PMAどこまで(20)][季語の有無(2)]=数%100000007\nint Psz;\n\nstruct PMA {\n\tint n;\n\tPMA *next[0x100]; // next[0] is for fail\n\tvector<int> accept;\n\tPMA() { fill(next, next+0x100, (PMA*)0); }\n\tPMA(int a)\n\t{\n\t\tn=a;\n\t\tfill(next, next+0x100, (PMA*)0);\n\t}\n};\nPMA *buildPMA(vector<string>& p, vector<PMA*>& vpma, int size) {\n  Psz=0;\n  PMA *root = new PMA(Psz++);\n  vpma.push_back(root);\n  for (int i = 0; i < size; ++i) { // make trie\n    PMA *t = root;\n    for (int j = 0; j<p[i].size(); ++j) {\n      char c = p[i][j];\n      if (t->next[c] == NULL) \n\t  {\n\t\t  t->next[c] = new PMA(Psz++);\n\t\t  vpma.push_back(t->next[c]);\n\t  }\n      t = t->next[c];\n    }\n    //t->accept.push_back(i);\n  }\n  queue<PMA*> Q; // make failure link using bfs\n  for (int c = 'a'; c <= 'z'; ++c) {\n    if (root->next[c]) {\n      root->next[c]->next[0] = root;\n      Q.push(root->next[c]);\n    } else root->next[c] = root;\n  }\n  while (!Q.empty()) {\n    PMA *t = Q.front(); Q.pop();\n    for (int c = 'a'; c <= 'z'; ++c) {\n      if (t->next[c]) {\n        Q.push(t->next[c]);\n        PMA *r = t->next[0];\n        while (!r->next[c]) r = r->next[0];\n        t->next[c]->next[0] = r->next[c];\n      }\n    }\n  }\n  return root;\n}\n\nbool g[500][500];\n\nint match(string t, PMA *v, int &ret) {\n  int n = t.size();\n  int r = v->n;\n\n  for (int i = 0; i < n; ++i) {\n    char c = t[i];\n    while (!v->next[c]) v = v->next[0];\n    v = v->next[c];\n\tr = v->n;\n\tret+=v->accept.size();\n  }\n\n  return r;\n}\n\nvoid aaa(PMA* p, int n, string w)\n{\n    PMA *t = p;\n    for (int j = 0; j<w.size(); ++j) {\n      char c = w[j];\n      if (t->next[c] == NULL) return;\n      t = t->next[c];\n    }\n\tfor(int i=0; i<t->accept.size(); i++)\n\t\tif(t->accept[i]==n) return;\n    t->accept.push_back(n);\n}\n\nint kigo[505][25];\nint nextpma[505][25];\n\nint main()\n{\n\tint N,M,K;\n\twhile(cin >> N >> M >> K, (N||M||K))\n\t{\n\t\tfor(int i=0; i<=M; i++)\n\t\t\tdp[i].clear();\n\n\t\tmemset(g,0,sizeof(g));\n\t\tmemset(kigo, 0, sizeof(kigo));\n\n\t\tint d=0;\n\t\tmap<string, int> dic;\n\t\tvector<string> w(K);\n\t\tvector<string> str;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tcin >> s >> t;\n\t\t\tif(!dic.count(s)) \n\t\t\t{\n\t\t\t\tdic[s]=d++;\n\t\t\t\tstr.push_back(s);\n\t\t\t}\n\t\t\tif(!dic.count(t)) \n\t\t\t{\n\t\t\t\tdic[t]=d++;\n\t\t\t\tstr.push_back(t);\n\t\t\t}\n\n\t\t\tg[dic[s]][dic[t]]=1;\n\t\t}\n\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tw[i]=t;\n\t\t}\n\n\t\tvector<PMA*> vpma;\n\t\tPMA* tree=buildPMA(w,vpma,w.size());\n\t\tfor(int j=0; j<K; j++)\n\t\tfor(int i=0; i<Psz; i++)\n\t\t{\n\t\t\tPMA* p=vpma[i];\n\t\t\taaa(p, j, w[j]);\n\t\t}\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\tfor(int j=0; j<str.size(); j++)\n\t\t\tnextpma[j][i] = match(str[j], vpma[i], kigo[j][i]);\n\n\t\tfor(int i=0; i<str.size(); i++)\n\t\t{\n\t\t\tif(kigo[i][0]>1) continue;\n\t\t\tState s=State(i,nextpma[i][0],kigo[i][0]);\n\n\t\t\tint l = str[i].size();\n\t\t\tdp[l][s]=1;\n\t\t}\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tfor(map<State, int>::iterator it = dp[i].begin(); it != dp[i].end(); it++)\n\t\t\t{\n\t\t\t\tState t=it->first;\n\t\t\t\tint val = it->second;\n\t\t\t\n\t\t\t\tfor(int m=0; m<str.size(); m++)\n\t\t\t\t{\n\t\t\t\t\tif(!g[t.pv][m]) continue;\n\n\t\t\t\t\tint k = t.pl;\n\t\t\t\t\tint twl=i+str[m].size();\n\t\t\t\t\tint r=nextpma[m][k];\n\t\t\t\t\tint tf=t.f+kigo[m][k];\n\n\t\t\t\t\tif(twl>M) continue;\n\t\t\t\t\tif(tf>1) continue;\n\n\t\t\t\t\tState ns = State(m,r, tf);\n\n\t\t\t\t\tif(!dp[twl].count(ns)) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl][ns]=val;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl][ns]+=val;\n\t\t\t\t\t\tdp[twl][ns]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint ret=0;\n\t\tfor(map<State, int>::iterator it = dp[M].begin(); it != dp[M].end(); it++)\n\t\t{\n\t\t\tState s=it->first;\n\t\t\tif(s.f != 1) continue;\n\t\t\tret+=dp[M][s];\n\t\t\tret%=MOD;\n\t\t}\n\n\t\tcout << ret << endl;\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\t\tdelete vpma[i];\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].emplace_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].emplace_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n    \n    sm->feed(\"\",mr);\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n   // rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[600];\n\n    //init\n\n    for(map<string,vector<string> >::iterator conn_it = connects.begin();\n\tconn_it != connects.end();\n\tconn_it++){\n      sm->set_state(start.id);\n      const string& from = conn_it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n      \n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tmap<string,vector<string> >::iterator conn_it;\n\tif((conn_it = connects.find(prev_state_it->first.last_word))\n\t   != connects.end()){\n\n\t  for(int to_idx = 0; to_idx < conn_it->second.size(); to_idx++){\n\t    const string& to = conn_it->second[to_idx];\n\n\t    sm->set_state(prev_state_it->first.last_node_address);\n\t    AhoCorasick::MatchingResult mr = sm->feed(to);\n\t      \n\t    if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t    //last_word,season_count,last_node\n\t    State next(to, \n\t\t       prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t       mr.id);\n\t    \n\t    // cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t    \n\t    dp[prev_word_length + to.size()][next]\n\t      += dp[prev_word_length][prev_state_it->first] % MOD;\n\t    dp[prev_word_length + to.size()][next] %= MOD;\n\t  }\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    map<State,int>& last_state = dp[word_limit];\n    for(map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nstruct PMA{\n\tPMA *next[0x100];\n\tvector<int> accept;\n};\nint sz;\nPMA pma[1000];\nPMA *mynew(){\n\trep(i, 256) pma[sz].next[i] = 0;\n\tpma[sz].accept.clear();\n\treturn pma + sz++;\n}\nPMA *buildPMA(const vector<string> &p) {\n\tPMA *root = mynew();\n\trep(i, p.size()){\n\t\tPMA *t = root;\n\t\trep(j, p[i].size()){\n\t\t\tchar c = p[i][j];\n\t\t\tif(t->next[c] == NULL) t->next[c] = mynew();\n\t\t\tt = t->next[c];\n\t\t}\n\t\tt->accept.pb(i);\n\t}\n\tqueue<PMA*> Q;\n\tfor(char c = 'A'; c <= 'z'; c++){\n\t\tif (root->next[c]) {\n\t\t\troot->next[c]->next[0] = root;\n\t\t\tQ.push(root->next[c]);\n\t\t}\n\t\telse root->next[c] = root;\n\t}\n\twhile(!Q.empty()){\n\t\tPMA *t = Q.front();\n\t\tQ.pop();\n\t\tfor(char c = 'A'; c <= 'z'; c++){\n\t\t\tif(t->next[c]){\n\t\t\t\tQ.push(t->next[c]);\n\t\t\t\tPMA *r = t->next[0];\n\t\t\t\twhile(!r->next[c]) r = r->next[0];\n\t\t\t\tt->next[c]->next[0] = r->next[c];\n\t\t\t\teach(i, r->next[c]->accept) t->next[c]->accept.pb(*i);\n\t\t\t}\n\t\t}\n\t}\n\treturn root;\n}\n\nconst int mod = (int)1e9 + 7;\nint n, m, k, N, dp[22][500][610][2]; //文字数, prev, state, match\nvector<vi> e;\nstring a[300], b[300];\nvector<string> c, v;\npi memo[610][500];\npi next(PMA *p, int s) {\n\tpi &res = memo[p - pma][s];\n\tif(res.second >= 0) return res;\n\tint count = 0;\n\trep(i, v[s].size()){\n\t\tchar c = v[s][i];\n\t\twhile (!p->next[c]) p = p->next[0];\n\t\tp = p->next[c];\n\t\trep(j, p->accept.size()) count++;\n\t}\n\treturn res = mp(p - pma, count);\n}\n\nint main(){\n\twhile(cin >> n >> m >> k, n){\n\t\tv.clear();\n\t\tmemset(dp, 0, sizeof(dp));\n\t\t\n\t\trep(i, n) cin >> a[i] >> b[i], v.pb(a[i]), v.pb(b[i]);\n\t\tsort(all(v));\n\t\tv.erase(unique(all(v)), v.end());\n\t\t\n\t\te.clear(); e.resize(v.size());\n\t\trep(i, n){\n\t\t\tint p = lower_bound(all(v), a[i]) - v.begin();\n\t\t\tint q = lower_bound(all(v), b[i]) - v.begin();\n\t\t\te[p].pb(q);\n\t\t}\n\t\tc.clear(); c.resize(k);\n\t\trep(i, k) cin >> c[i];\n\t\tsz = 0;\n\t\tPMA* r = buildPMA(c);\n\t\t\n\t\tassert(sz < 610);\n\t\trep(i, sz) rep(j, v.size()) memo[i][j].second = -1;\n\t\t\n\t\trep(i, v.size()){\n\t\t\tpi x = next(r, i);\n\t\t\tif(v[i].size() <= m && x.second < 2) dp[v[i].size() % 22][i][x.first][x.second] = 1;\n\t\t}\n\t\trep(i, m){\n\t\t\tmemset(dp[(i + 21) % 22], 0, sizeof(dp[0]));\n\t\t\trep(j, v.size()) rep(k, sz) rep(l, 2) if(dp[i % 22][j][k][l]){\n\t\t\t\trep(h, e[j].size()){\n\t\t\t\t\tpi x = next(pma + k, e[j][h]);\n\t\t\t\t\tint ni = v[e[j][h]].size() + i;\n\t\t\t\t\tif(ni <= m && x.second + l < 2)\n\t\t\t\t\t(dp[ni % 22][e[j][h]][x.first][x.second + l] += dp[i % 22][j][k][l]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\trep(i, v.size()) rep(j, sz) (res += dp[m % 22][i][j][1]) %= mod;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE], ssword[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\n\nbool solve(){\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n    //debug(ssword);\n  }\n\n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[501];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    //debug(i);\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  for(int i=0;i<pos_size;i++){\n    free(pos[i]);\n  }\n  pos_size = 0;\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][400][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nint wnxt[601][605];\nint wcnt[601][605];\nvector<P> vec[255];\nvector<int> v2[605][605];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 505\n#define SIZE 21\n#define TRIE_SIZE 605\n\nenum Type{\n    Unknown,\n    TRUE,\n    FALSE,\n};\n\nstruct Node{\n\tint parent_id,children[26],suffix_link;\n\tbool finish_FLG,bad_finish;\n};\n\nstruct Info{\n    Info(int arg_node_id,int arg_ch){\n        node_id = arg_node_id;\n        ch = arg_ch;\n    }\n\n    int node_id,ch;\n};\n\nstruct State{\n\tState(int arg_total_length,int arg_last_word,int arg_num_match){\n\t\ttotal_length = arg_total_length;\n\t\tlast_word = arg_last_word;\n\t\tnum_match = arg_num_match;\n\t}\n\tint total_length,last_word,num_match;\n};\n\nint num_relation,LENGTH,num_season_word;\nint num_word,word_len[NUM];\nint root,trie_index;\nchar table[NUM][SIZE],buf_from[SIZE],buf_to[SIZE],buf_season[SIZE];\nvector<int> G[NUM];\nNode nodes[TRIE_SIZE];\nmap<int,int> DP[NUM][2][501]; //DP[最後の文字][一致回数][総長][trie_pos] = 場合の数\nType memo[TRIE_SIZE];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint get_next_loc(int current_loc,int next){\n\n\tif(nodes[current_loc].children[next] != -1){\n\n\t\treturn nodes[current_loc].children[next];\n\n\t}else{\n\n\t\tif(current_loc == root){\n\t\t\treturn root;\n\t\t}\n\n\t\tfor(current_loc = nodes[current_loc].suffix_link; current_loc != root; current_loc = nodes[current_loc].suffix_link){\n\t\t\tif(nodes[current_loc].children[next] != -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nodes[current_loc].children[next] != -1){\n\n\t\t\treturn nodes[current_loc].children[next];\n\n\t\t}else{\n\n\t\t\treturn root;\n\t\t}\n\t}\n}\n\nint recursive(int total_length,int last_word,int trie_pos,int num_match){\n\n\tint ret = 0;\n\n\t//メモがあれば返却\n\tauto at = DP[last_word][num_match][total_length].find(trie_pos);\n\tif(at != DP[last_word][num_match][total_length].end()){\n\t\treturn DP[last_word][num_match][total_length][trie_pos];\n\t}\n\n\t//文字が完成した場合\n\tif(total_length == LENGTH){\n\t\tif(num_match == 1){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint next_word,next_trie_pos,add_match;\n\tbool FLG;\n\n\tfor(int i = 0; i < G[last_word].size(); i++){\n\n\t\tnext_word = G[last_word][i];\n\t\tif(total_length+word_len[next_word] > LENGTH)continue;\n\n\t\tnext_trie_pos = trie_pos;\n\t\tadd_match = 0;\n\t\tFLG = true;\n\n\t\t//next_word分文字を進める。途中で、num_matchが2以上になったら不可\n\t\tfor(int k = 0; k < word_len[next_word]; k++){\n\t\t\tnext_trie_pos = get_next_loc(next_trie_pos,table[next_word][k]-'a');\n\n\t\t\tif(nodes[next_trie_pos].bad_finish){\n\t\t\t\t//★★2つ以上の、季語の終端を通過するのは不可★★\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(memo[next_trie_pos] == TRUE){ //★1つの季語の終端である場合★\n\t\t\t\tadd_match++;\n\t\t\t\tif(num_match+add_match > 1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(FLG == false)continue;\n\n\t\tret += recursive(total_length+word_len[next_word],next_word,next_trie_pos,num_match+add_match);\n\t\tret %= MOD;\n\t}\n\n\treturn DP[last_word][num_match][total_length][trie_pos] = ret;\n}\n\nvoid func(){\n\n\tnum_word = 0;\n\n\tfor(int i = 0; i < NUM; i++)G[i].clear();\n\n\tint from_index,to_index,length;\n\n\tfor(int loop = 0; loop < num_relation; loop++){\n\t\tscanf(\"%s %s\",buf_from,buf_to);\n\n\t\tfrom_index = -1;\n\t\tfor(int i = 0; i < num_word; i++){\n\t\t\tif(strCmp(buf_from,table[i])){\n\t\t\t\tfrom_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(from_index == -1){\n\t\t\tfor(length = 0; buf_from[length] != '\\0'; length++);\n\t\t\tword_len[num_word] = length;\n\t\t\tstrcpy(table[num_word],buf_from);\n\t\t\tfrom_index = num_word++;\n\t\t}\n\n\t\tto_index = -1;\n\t\tfor(int i = 0; i < num_word; i++){\n\t\t\tif(strCmp(buf_to,table[i])){\n\t\t\t\tto_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(to_index == -1){\n\t\t\tfor(length = 0; buf_to[length] != '\\0'; length++);\n\t\t\tword_len[num_word] = length;\n\t\t\tstrcpy(table[num_word],buf_to);\n\t\t\tto_index = num_word++;\n\t\t}\n\t\tG[from_index].push_back(to_index);\n\t}\n\n\t//★★空文字列を定義する(全ての文字に接続可能)★★\n\tword_len[num_word] = 0;\n\tfor(int i = 0; i < num_word; i++){\n\t\tG[num_word].push_back(i);\n\t}\n\tnum_word++;\n\n\troot = 0;\n\ttrie_index = 1;\n\n\t//トライ木のノードを初期化\n\tfor(int i = 0; i < TRIE_SIZE; i++){\n\t\tnodes[i].parent_id = -1;\n\t\tnodes[i].finish_FLG = false;\n\t\tnodes[i].suffix_link = root; //siffx_link先はとりあえずrootにしておく\n\t\tnodes[i].bad_finish = false;\n\t\tfor(int k = 0; k < 26; k++){\n\t\t\tnodes[i].children[k] = -1;\n\t\t}\n\t}\n\n\tint tmp_ch,tmp_loc,parent_id,tmp_index;\n\n\tbool FLG;\n\n\t//トライ木を構成する\n\tfor(int loop = 0; loop < num_season_word; loop++){\n\n\t\tscanf(\"%s\",buf_season);\n\n\t\ttmp_index = 0;\n\t\ttmp_ch = buf_season[tmp_index]-'a';\n\n\t\ttmp_loc = root;\n\t\ttmp_index = 0;\n\n\t\twhile(true){\n\n\t\t\t parent_id = tmp_loc;\n\t\t\t FLG = false;\n\n\t\t\tif(nodes[tmp_loc].children[tmp_ch] == -1){\n\t\t\t\tFLG = true;\n\t\t\t\tnodes[tmp_loc].children[tmp_ch] = trie_index++; //★新しいノードへ移動する場合★\n\t\t\t}\n\t\t\t//子ノードに移動\n\t\t\ttmp_loc = nodes[tmp_loc].children[tmp_ch];\n\n\t\t\tif(FLG){\n\t\t\t\tnodes[tmp_loc].parent_id = parent_id;\n\t\t\t}\n\t\t\ttmp_index++;\n\n\t\t\tif(buf_season[tmp_index] == '\\0'){ //今回の数字が最後の文字だった場合\n\t\t\t\tnodes[tmp_loc].finish_FLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_ch = buf_season[tmp_index]-'a';\n\t\t}\n\t}\n\n\t//Suffix_linkを構築する\n\tint node_id;\n\tqueue<Info> MAKE_SL;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(nodes[root].children[i] != -1){\n\t\t\tnode_id = nodes[root].children[i];\n\t\t\tnodes[node_id].suffix_link = root; //★root直下のsuffix_linkは必ずrootなので、queueには突っ込まない★\n\t\t\tfor(int k = 0; k < 26; k++){\n\t\t\t\tif(nodes[node_id].children[k] != -1){\n\t\t\t\t\tMAKE_SL.push(Info(nodes[node_id].children[k],k)); //ノードのidと、最後の経路をpushする\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(!MAKE_SL.empty()){\n\t\tnode_id = MAKE_SL.front().node_id; //★新たにsuffix_linkを張りたいノードのid★\n\t\ttmp_ch = MAKE_SL.front().ch;\n\t\tMAKE_SL.pop();\n\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(nodes[node_id].children[i] != -1){\n\t\t\t\tMAKE_SL.push(Info(nodes[node_id].children[i],i));\n\t\t\t}\n\t\t}\n\n\t\tfor(tmp_loc = nodes[nodes[node_id].parent_id].suffix_link; tmp_loc != root; tmp_loc = nodes[tmp_loc].suffix_link){\n\t\t\tif(nodes[tmp_loc].children[tmp_ch] != -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(tmp_loc == root){\n\t\t\tif(nodes[root].children[tmp_ch] != -1){\n\t\t\t\tnodes[node_id].suffix_link = nodes[root].children[tmp_ch];\n\t\t\t}else{\n\t\t\t\tnodes[node_id].suffix_link = root;\n\t\t\t}\n\t\t}else{\n\t\t\tnodes[node_id].suffix_link = nodes[tmp_loc].children[tmp_ch];\n\t\t}\n\t}\n\n\t //suffix_linkを辿り、finish_flgがtrueのものに出くわすか調べる\n\tfor(int i = 0; i < trie_index; i++){\n\t\tmemo[i] = Unknown;\n\t}\n\n\tqueue<int> Q;\n\tfor(int i = 0; i < 26; i++){\n\t\tif(nodes[root].children[i] != -1){\n\t\t\tQ.push(nodes[root].children[i]);\n\t\t}\n\t}\n\n\t//ノードに近いものから調べる\n\twhile(!Q.empty()){\n\t\ttmp_loc = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(nodes[tmp_loc].children[i] != -1){\n\t\t\t\tQ.push(nodes[tmp_loc].children[i]);\n\t\t\t}\n\t\t}\n\n\t\tif(nodes[tmp_loc].finish_FLG){\n\t\t\tmemo[tmp_loc] = TRUE;\n\t\t}else{\n\t\t\tfor(int k = nodes[tmp_loc].suffix_link; k != root; k = nodes[k].suffix_link){\n\t\t\t\tif(memo[k] != Unknown){\n\t\t\t\t\tmemo[tmp_loc] = memo[k];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(nodes[k].finish_FLG){\n\t\t\t\t\tmemo[tmp_loc] = TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(memo[tmp_loc] == Unknown){\n\t\t\t\tmemo[tmp_loc] = FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < trie_index; i++){\n\t\tif(nodes[i].finish_FLG == true && memo[nodes[i].suffix_link] == TRUE){\n\t\t\t//printf(\"%dが不可\\n\",i);\n\t\t\tnodes[i].bad_finish = true;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 26; i++){\n\t\tif(nodes[root].children[i] != -1){\n\t\t\tQ.push(nodes[root].children[i]);\n\t\t}\n\t}\n\n\twhile(!Q.empty()){\n\t\ttmp_loc = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(nodes[tmp_loc].children[i] != -1){\n\t\t\t\tQ.push(nodes[tmp_loc].children[i]);\n\t\t\t}\n\t\t}\n\n\t\tif(nodes[tmp_loc].bad_finish){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tfor(int k = nodes[tmp_loc].suffix_link; k != root; k = nodes[k].suffix_link){\n\t\t\t\tif(nodes[k].bad_finish){\n\t\t\t\t\tnodes[tmp_loc].bad_finish = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < num_word; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tfor(int a = 0; a <= LENGTH; a++){\n\t\t\t\tDP[i][k][a].clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",recursive(0,num_word-1,root,0));\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&num_relation,&LENGTH,&num_season_word);\n\t\tif(num_relation == 0 && LENGTH == 0 && num_season_word == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(256), fail(NULL) {}\n    ~Node() { for(int i = 0; i < 256; i++) if(next[i]) delete next[i]; }\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 256; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 256; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            // add que\n            que.push(np);\n\n            // search failure link\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            // update matching list\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\n// (node id, match count)\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        static int dp[501][500][610][2] = {}; // len, last str, last node, season or not\n        memset(dp, 0, sizeof(dp));\n        // start\n        for(auto& p : next){\n            string bs = idm.get(p.first);\n            pair<int, int> pi = match(root, bs);\n            if(pi.second < 2){\n                //cout << bs.length() << \" \" << bs << \" \" << pi.first << \" \" << pi.second << endl;\n                dp[ bs.length() ][p.first][pi.first][ pi.second ] = 1;\n            }\n        }\n        // update\n        for(int l = 0; l < M; l++)\n        for(int i = 0; i < 2 * N; i++)\n        for(int k = 0; k < nodes.size(); k++)\n        for(int s = 0; s <= 1; s++){\n            for(auto ni : next[i]){\n                if(dp[l][i][k][s] > 0 && ni != -1){\n                    //cout << l << \" \" << idm.get(i) << \" \" << k << \" \" << s << \" \" << dp[l][i][k][s] << endl;\n\n                    string str = idm.get(ni);\n                    pair<int, int> pi = match(nodes[k], str);\n                    if(l + str.size() <= M && s + pi.second <= 1){\n                        update(dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ], dp[l][i][k][s]);\n                        /*\n                        cout << \"\\t\" << l + str.size() << \" \" << idm.get(ni) << \" \" << pi.first << \" \" << s + pi.second << \" \" << \n                           dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ] << endl;\n                        */\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i < 2 * N; i++)\n        for(int k = 0; k < nodes.size(); k++)\n        if(dp[M][i][k][1] > 0){\n            //cout << idm.get(i) << \" \" << k << endl;\n            update(ans, dp[M][i][k][1]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(128), fail(NULL) {}\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 128; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 128; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            // add que\n            que.push(np);\n\n            // search failure link\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            // update matching list\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\n// (node id, match count)\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\nstruct State{\n    int i, k, s;\n    State(int i, int k, int s) :\n        i(i), k(k), s(s) {}\n    bool operator < (const State& st) const {\n        if(i != st.i) return i < st.i;\n        if(k != st.k) return k < st.k;\n        return s < st.s;\n    }\n};\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        map<State, int> dp[501];\n        // start\n        for(auto& p : next){\n            string bs = idm.get(p.first);\n            pair<int, int> pi = match(root, bs);\n            if(pi.second < 2){\n                //cout << bs.length() << \" \" << bs << \" \" << pi.first << \" \" << pi.second << endl;\n                update(dp[ bs.length() ][ State(p.first, pi.first, pi.second) ], 1);\n            }\n        }\n\n        // update\n        for(int l = 0; l < M; l++)\n        for(auto& p : dp[l]){\n            int i = p.first.i, k = p.first.k, s = p.first.s;\n            for(auto ni : next[i]){\n                //cout << l << \" \" << idm.get(i) << \" \" << k << \" \" << s << \" \" << dp[l][i][k][s] << endl;\n\n                string str = idm.get(ni);\n                pair<int, int> pi = match(nodes[k], str);\n                if(l + str.size() <= M && s + pi.second <= 1){\n                    update(dp[l + str.size()][ State(ni, pi.first, s + pi.second) ], p.second);\n                    /*\n                       cout << \"\\t\" << l + str.size() << \" \" << idm.get(ni) << \" \" << pi.first << \" \" << s + pi.second << \" \" << \n                       dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ] << endl;\n                       */\n                }\n            }\n        }\n\n        int ans = 0;\n        for(auto& p : dp[M]){\n            if(p.first.s == 1){\n                update(ans, p.second);\n            }\n        }\n        cout << ans << endl;\n\n        for(auto p : nodes) delete p;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=1000;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE], ssword[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\n\nbool solve(){\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n    //debug(ssword);\n  }\n\n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[501];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    debug(i);\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  for(int i=0;i<pos_size;i++){\n    free(pos[i]);\n  }\n  pos_size = 0;\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  void feed(const string& text,AhoCorasick::MatchingResult* matching_result){\n    matching_result->match_count = 0; //init\n\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result->match_count += state->get_results().size();\n      index++;\n    }\n    matching_result->id = state->get_id();\n    state = root;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    \n    AhoCorasick::MatchingResult* start = new AhoCorasick::MatchingResult();\n    sm->feed(\"\",start);\n    unordered_map<State,int> dp[600];\n\n    AhoCorasick::MatchingResult* mr = new AhoCorasick::MatchingResult();\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->set_state(start->id);\n      sm->feed(words[i],mr);\n      //last_word,season_count,last_node\n      if(mr->match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr->match_count,mr->id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  sm->feed(words[next_idx],mr);\n\n\t  if(prev_state_it->first.seasonword_count + mr->match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr->match_count,\n\t\t     mr->id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint getNum(char ch){\n\treturn ch-'a';\n}\n\nstruct PMA{\n\tstruct node{\n\t\tint to[26];\n\t\tint fail;\n\t\tint leaf;//0,1,or2(>=2)\n\t\tnode(){\n\t\t\tfor(int i=0;i<26;i++) to[i]=-1;\n\t\t\tfail=-1;\n\t\t\tleaf=0;\n\t\t}\n\t};\n\tnode nodes[700];\n\tint c;\n\tP moved[650][500];\n\tvoid init(){\n\t\tc=1;\n\t\tfor(int i=0;i<700;i++) nodes[i]=node();\n\t\tfor(int i=0;i<650;i++) for(int j=0;j<501;j++) moved[i][j]=make_pair(-1,-1);\n\t}\n\tvoid add(string str){\n\t\tint cur=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint num=getNum(str[i]);\n\t\t\tif(nodes[cur].to[num]==-1){\n\t\t\t\tnodes[cur].to[num]=c;\n\t\t\t\tcur=c;\n\t\t\t\tc++;\n\t\t\t}else{\n\t\t\t\tcur=nodes[cur].to[num];\n\t\t\t}\n\t\t}\n\t\tnodes[cur].leaf=min(nodes[cur].leaf+1,2);\n\t}\n\tvoid getFail(){\n\t\tqueue<int> que;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(nodes[0].to[i]!=-1){\n\t\t\t\tnodes[nodes[0].to[i]].fail=0;\n\t\t\t\tque.push(nodes[0].to[i]);\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint r=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<26;i++){\n\t\t\t\tif(nodes[r].to[i]!=-1){\n\t\t\t\t\tint u=nodes[r].to[i];\n\t\t\t\t\tque.push(u);\n\t\t\t\t\tint v=nodes[r].fail;\n\t\t\t\t\twhile(v!=0&&nodes[v].to[i]==-1){\n\t\t\t//\t\t\tprintf(\"v=%d\\n\",v);\n\t\t\t\t\t\tv=nodes[v].fail;\n\t\t\t\t\t}\n\t\t\t\t\tif(nodes[v].to[i]==-1) nodes[u].fail=0;\n\t\t\t\t\telse nodes[u].fail=nodes[v].to[i];\n\t\t\t\t\tint f=nodes[u].fail;\n\t\t\t\t\tnodes[u].leaf=min(nodes[u].leaf+nodes[f].leaf,2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpair<int,int> move(int v,string str,int id){\n\t\tif(moved[v][id]!=P(-1,-1)) return moved[v][id];\n\t///\tbool flg=(str==\"negawakuha\");\n\t//\tif(flg) cout<<v<<\" \"<<str<<\"\\n\";\n\t\tint cur=v;\n\t\tint res=0;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tint num=getNum(str[i]);\n\t\t\twhile(cur!=0&&nodes[cur].to[num]==-1) cur=nodes[cur].fail;\n\t\t\tif(nodes[cur].to[num]==-1){}\n\t\t\telse{\n\t\t\t\tcur=nodes[cur].to[num];\n\t\t\t}\n\t\t\tres+=nodes[cur].leaf;\n\t\t}\n\t//\tif(flg) cout<<cur<<\" \"<<res<<\"\\n\";\n\t\tmoved[v][id]=make_pair(cur,res);\n\t\treturn make_pair(cur,res);\n\t}\n};\n\nPMA pma;\n\nint dp[21][650][500][2];\n\nconst long long mod=1000000007;\n\nmap<string,int> mp;\nint sz[501];\nvector<int> to[501];\nstring strs[501];\n\nint main(){\n\tint N,M,K;\n\twhile(true){\n\t\tpma.init();\n\t\tcin>>N>>M>>K;\n\t\tmp.clear();\n\t\tfor(int i=0;i<501;i++) to[i].clear();\n\t\tif(N==0&&M==0&&K==0) break;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring from,to;\n\t\t\tcin>>from>>to;\n\t\t\tif(mp.count(from)==0){\n\t\t\t\tint a=mp.size();\n\t\t\t\tmp[from]=a;\n\t\t\t\tsz[a]=from.size();\n\t\t\t\tstrs[a]=from;\n\t\t\t}\n\t\t\tif(mp.count(to)==0){\n\t\t\t\tint a=mp.size();\n\t\t\t\tmp[to]=a;\n\t\t\t\tsz[a]=to.size();\n\t\t\t\tstrs[a]=to;\n\t\t\t}\n\t\t\t::to[mp[from]].push_back(mp[to]);\n\t\t}\n\t//\tfor(int i=0;i<mp.size();i++){\n\t//\t\tcout<<i<<\" \"<<strs[i]<<\"\\n\";\n\t//\t}\n\t//\tprintf(\"b\\n\");\n\t\tfor(int i=0;i<K;i++){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t//\t\tcout<<\"add:\"<<str<<\"\\n\";\n\t\t\tpma.add(str);\n\t\t}\n\t//\tprintf(\"c\\n\");\n\t\tpma.getFail();\n\t//\tprintf(\"d\\n\");\n\t//\tfor(int i=0;i<mp.size();i++){\n\t//\t\tcout<<strs[i]<<\"->\";\n\t//\t\tfor(int j=0;j<to[i].size();j++){\n\t//\t\t\tcout<<strs[to[i][j]]<<\" \";\n\t//\t\t}\n\t//\t\tcout<<\"\\n\";\n\t//\t}\n\t\tint C=pma.c;\n\t\tfor(int l=0;l<21;l++) for(int i=0;i<C;i++) for(int j=0;j<=mp.size();j++) for(int k=0;k<2;k++){\n\t\t\tdp[l][i][j][k]=0;\n\t\t}\n\t\tfor(int i=0;i<mp.size();i++){\n\t\t\tpair<int,int> p=pma.move(0,strs[i],i);\n\t\t\tif(p.second>=2) continue;\n\t\t\tdp[sz[i]][p.first][i][p.second]=1;\n\t\t}\n\t//\tprintf(\"a\\n\");\n\t\tfor(int l=1;l<M;l++){\n\t\t\tfor(int v=0;v<C;v++){\n\t\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\tfor(int i=0;i<to[w].size();i++){\n\t\t\t\t\t\t\tint nw=to[w][i];\n\t\t\t\t\t\t\tint nl=(l+sz[nw])%21;\n\t\t\t\t\t\t\tpair<int,int> p=pma.move(v,strs[nw],nw);\n\t\t\t\t\t\t\tint nv=p.first;\n\t\t\t\t\t\t\tint nb=b+p.second;\n\t\t\t\t\t\t\tif(nb>=2) continue;\n\t\t\t\t\t\t\tdp[nl][nv][nw][nb]+=dp[l%21][v][w][b];\n\t\t\t\t\t\t\tdp[nl][nv][nw][nb]%=mod;\n\t\t//\t\t\t\t\tif(dp[l%21][v][w][b]!=0){\n\t\t//\t\t\t\t\t\tprintf(\"(%d,%d,%d,%d)->(%d,%d,%d,%d)\\n\",\n\t\t//\t\t\t\t\t\t\tl,v,w,b,l+sz[nw],nv,nw,nb);\n\t\t//\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int v=0;v<C;v++){\n\t\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\t\tfor(int b=0;b<2;b++){\n\t\t\t\t\t\tdp[l%21][v][w][b]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ans=0;\n\t\tfor(int v=0;v<C;v++){\n\t\t\tfor(int w=0;w<mp.size();w++){\n\t\t\t\tans+=dp[(M%21)][v][w][1];\n\t\t\t\tans%=mod;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct state{\n  int n,m,f;\n  string str;\n  state(){}\n  state(int n,int m,int f,string str) : n(n),m(m),f(f),str(str){}\n  bool operator<(const state& st) const{\n    if( n == st.n )\n      if( m == st.m )\n\tif( f == st.f )\n\t  return str < st.str;\n\telse\n\t  return f < st.f;\n      else\n\treturn m < st.m;\n    else\n      return n < st.n;\t    \n  }\n};\nunordered_map<string,int> S;\n//map<state,int> dp;\nunordered_map<string,int> dp[501][501][2];\n\nint N,M,K;\nvector<int> G[505];\nstring Sm[515];\nstring Sk[55];\nunordered_map<string,pair<string,int>> mcp;\nvoid init(){\n  mcp.clear();\n  //dp.clear();\n  for(int i=0;i<=2*N;i++){\n    for(int j=0;j<M;j++){\n      dp[i][j][0].clear();\n      dp[i][j][1].clear();\n    }\n  }\n      \n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\npair<string,int> check(const string &s){\n  if( mcp.count(s) != 0 ){\n    return mcp[s];\n  }\n  int cnt = 0;\n  string ret = \"\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"\" ) ret = ss;\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  return mcp[s] = {ret,cnt};\n} \nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  //  if( dp.count( state(n,m,cnt,str) ) != 0 ) return dp[{n,m,cnt,str}];\n  if( dp[n][m][cnt].count(str) != 0 ) return dp[n][m][cnt][str];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n    // return dp[{n,m,cnt,str}] = cnt;\n    return dp[n][m][cnt][str] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    pair<string,int> np = check(rs);\n    int nct = cnt + np.second - check(str).second;\n    rs = np.first;\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n  //    cout << N << \" \" << M << \" \" << K << endl;\n  //cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  //  return dp[{n,m,cnt,str}] = ret;\n  return dp[n][m][cnt][str] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    //cout << N << \" \" << M << \" \"<< K << endl;\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    //cout << S.size() << endl;    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      auto np = check(rs);\n      rs = np.first;\n      int cnt = np.second;\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nint wnxt[601][601];\nint wcnt[601][601];\nvector<P> vec[255];\nvector<int> v2[605][601];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[501][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  char ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  //  rep(i,ini.size()){\n  //int id=ini[i];\n  rep(i,all.size()){\n    int id=i;\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t      int nextlen=i+all[readword].size();\n\t      int nextn=readword;\n\t      int nextpma=move[l][readword];\n\t      int nextac=m+ac[l][readword];\n\t      if (nextlen > len ||nextpma == -1)continue;\n\t      if (nextac >= 2)continue;\n\t      nextlen%=MOD;\n\t      dp[nextlen][nextn][nextpma][nextac]=\n\t\t(dp[nextlen][nextn][nextpma][nextac]+\n\t\t dp[i%MOD][j][l][m])%mod;\n\t    }\n\t  }\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    multimap<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  AhoCorasick::MatchingResult feed(const string& text){\n    AhoCorasick::MatchingResult matching_result;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmatching_result.rv.insert(pair<string,int>(*it,index - it->length() + 1));\n      }\n      index++;\n    }\n    matching_result.id = state->get_id();\n    state = root;\n    return matching_result;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    \n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->set_state(start.id);\n      AhoCorasick::MatchingResult mr = sm->feed(words[i]);\n      //last_word,season_count,last_node\n      if(mr.rv.size() >= 2) continue;\n      dp[words[i].size()][State(i,mr.rv.size(),mr.id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  AhoCorasick::MatchingResult mr = sm->feed(words[next_idx]);\n\n\t  if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t     mr.id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][505][22][606];\nbool used[2][2][505][22][606];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) goto END;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) goto END;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint cur = 0;\n\nstruct T{\n\tint id,flag;\n\tT *next[26];\n\tT(){ id = flag=0;for(int i = 0 ; i < 26 ; i++) next[i] = NULL; }\n};\n\nT *rope[1000];\nint bad[1000];\n\nstring ttt[1000];\n\nint n,m,K;\nvoid add(T *root,string s){\n\t//cout << \"[\" << s << \"]\" << endl;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t}else{\n\t\t\troot = root->next[s[i]-'a'] = new T();\n\t\t\trope[cur] = root;\n\t\t\troot->id = cur++;\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tif( ttt[j].size() <= (i+1) ){\n\t\t\t\t\tif( s.substr(i+1-ttt[j].size(),ttt[j].size()) == ttt[j] ){\n\t\t\t\t\t\troot->flag++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool done[1000];\n\nint tmp;\nint exists(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t\ttmp += root->flag;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn root->id;\n}\nvoid failed_generate(T *root,string c,T *src){\n\tif( done[root->id] ) return;\n\telse done[root->id] = true;\n\t//cout << root->id << \": \" << c << \" \" << root->flag << endl;\n\tfor(int i = 0 ; i < 26 ; i++){\n\t\tif( root->next[i] ){\n\t\t\tfailed_generate(root->next[i],c+(char)(i+'a'),src);\n\t\t}else{\n\t\t\t\n\t\t\tstring w = c + (char)(i+'a');\n\t\t\tint idx = 0;\n\t\t\tfor(int j = 0 ; j < w.size() ; j++){\n\t\t\t\tint r = exists(src,w.substr(j));\n\t\t\t\tif( r != -1 ){\n\t\t\t\t\tidx = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot->next[i] = rope[idx];\n\t\t}\n\t}\n}\n\n\nmap<string,int> dic;\nstring ln[500];\n\nvector<int> connect[500];\n\nint mem[1000][500];\nint mem2[1000][500];\n\nint dp[25][500][610][2];\n\nmap< pair< pair<int,int> , pair<int,int> >, int > memo;\nint dfs(int pos,int word,int info,int ok){\n\tif( ok > 1 ) return 0;\n\tpair< pair<int,int>, pair<int,int> > key = make_pair( make_pair(pos,word) , make_pair(info,ok) );\n\t//cout << ln[pos] << \" \" << word << \" \" << info << \" \" << ok << endl;\n\tif( memo.count(key) ) return memo[key];\n\tif( word < 0 ) return 0;\n\tif( word == 0 ) return ok == 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < connect[pos].size() ; i++){\n\t\tans += dfs(connect[pos][i],word - ln[connect[pos][i]].size() , mem[info][connect[pos][i]],ok+mem2[info][connect[pos][i]]);\n\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t}\n\treturn memo[key] = ans;\n}\nint main(){\n\twhile(cin >> n >> m >> K && n){\n\t\tdic.clear();\n\t\t\n\t\tfor(int i = 0 ; i < 1000 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 500 ; i++) ln[i] = \"\", connect[i].clear();\n\t\tfor(int i = 0 ; i < 1000 ; i++) rope[i] = NULL;\n\t\tfor(int i = 0 ; i < 1000 ; i++)bad[i] = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif( dic.count(a) == 0 ){ int k = dic.size(); dic[a] = k; ln[k] = a;}\n\t\t\tif( dic.count(b) == 0 ){ int k = dic.size(); dic[b] = k; ln[k] = b;}\n\t\t\tconnect[dic[a]].push_back(dic[b]);\n\t\t\t\n\t\t}\n\t\tT *root = new T();\n\t\trope[0] = root;\n\t\tcur = 1;\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tstring l;\n\t\t\tcin >> l;\n\t\t\tttt[i] = l;\n\t\t\t//cout << l << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tadd(root,ttt[i]);\n\t\t}\n\t\t\n\t\tfailed_generate(root,\"\",root);\n\t\t\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tfor(int k = 0 ; k < dic.size() ; k++){\n\t\t\t\ttmp = 0;\n\t\t\t\tmem[i][k] = exists(rope[i],ln[k]);\n\t\t\t\tmem2[i][k] = tmp;\n\t\t\t\t//cout << i << \" \" << ln[k] << \" \" << tmp << \" \" << mem[i][k] << \" \" << mem2[i][k] << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tint ans = 0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tif( mem2[0][i] < 2 ) dp[ln[i].size()][i][mem[0][i]][mem2[0][i]] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tfor(int j = 0 ; j < dic.size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\t\tfor(int f = 0 ; f < 2 ; f ++){\n\t\t\t\t\t\tif( dp[i%25][j][k][f] == 0 ) continue;\n\t\t\t\t\t\tfor(int l = 0 ; l < connect[j].size() ; l++){\n\t\t\t\t\t\t\tif( i + ln[connect[j][l]].size() <= m && f+mem2[k][connect[j][l]] < 2 ){\n\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%25][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] += dp[i%25][j][k][f];\n\t\t\t\t\t\t\t\tif( dp[(i+ln[connect[j][l]].size())%25][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] >= 1000000007 ){\n\t\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%25][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] -= 1000000007;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(dp[i%25],0,sizeof(dp[i%25]));\n\t\t}\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\tans += dp[m%25][i][k][1];\n\t\t\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nconst char ALPHABET_MIN = 'a';\nconst char ALPHABET_MAX = 'z';\nconst int ALPHABET_SIZE = ALPHABET_MAX - ALPHABET_MIN + 1;\n\nstruct State {\n    vector<int> next;\n    vector<int> accept;\n    int failure;\n    State(): next(ALPHABET_SIZE, -1), failure(-1) {}\n};\n\nvector<State> build_pma(const vector<string>& keywords) {\n    vector<State> pma(1);\n    // make trie\n    REP(i, keywords.size()) {\n        int k = 0;\n        for (char ch : keywords[i]) {\n            assert(ALPHABET_MIN <= ch && ch <= ALPHABET_MAX);\n            ch -= ALPHABET_MIN;\n            if (pma[k].next[ch] == -1) {\n                pma[k].next[ch] = pma.size();\n                pma.emplace_back();\n            }\n            k = pma[k].next[ch];\n        }\n        pma[k].accept.push_back(i);\n    }\n    // bfs\n    queue<int> Q;\n    REP(ch, ALPHABET_SIZE) {\n        int k = pma[0].next[ch];\n        if (k == -1) {\n            pma[0].next[ch] = 0;\n        } else {\n            pma[k].failure = 0;\n            Q.push(k);\n        }\n    }\n    while (!Q.empty()) {\n        int k = Q.front(); Q.pop();\n        REP(ch, ALPHABET_SIZE) {\n            int j = pma[k].next[ch];\n            if (j == -1) continue;\n            int i = pma[k].failure;\n            while (pma[i].next[ch] == -1) i = pma[i].failure;\n            i = pma[i].next[ch];\n            pma[j].failure = i;\n            vector<int> accept;\n            set_union(pma[j].accept.begin(), pma[j].accept.end(),\n                      pma[i].accept.begin(), pma[i].accept.end(), back_inserter(accept));\n            pma[j].accept = accept;\n            Q.push(j);\n        }\n    }\n    return pma;\n}\n\npair<int, int> transit(const vector<State>& pma, const string& s, int initial) {\n    int k = initial, accept = 0;\n    REP(i, s.size()) {\n        char ch = s[i] - ALPHABET_MIN;\n        while (pma[k].next[ch] == -1)\n            k = pma[k].failure;\n        k = pma[k].next[ch];\n        accept += pma[k].accept.size();\n    }\n    return make_pair(k, accept);\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, K;\n    while (cin>>N>>M>>K, N|M|K) {\n        unordered_map<string, int> word2id;\n        vector<vector<int>> graph;\n        REP(i, N) {\n            string s, t; cin >> s >> t;\n            if (!word2id.count(s)) {\n                int id = word2id.size();\n                word2id[s] = id;\n            }\n            if (!word2id.count(t)) {\n                int id = word2id.size();\n                word2id[t] = id;\n            }\n            graph.resize(word2id.size());\n            graph[word2id[s]].push_back(word2id[t]);\n        }\n        vector<string> seasonword(K);\n        REP(i, K) cin >> seasonword[i];\n\n        vector<State> pma = build_pma(seasonword);\n\n        vector<vector<int>> next_state(pma.size(), vector<int>(word2id.size()));\n        vector<vector<int>> n_accept(pma.size(), vector<int>(word2id.size()));\n        REP(state, pma.size()) {\n            for (auto p : word2id) {\n                string word; int i; tie(word, i) = p;\n                tie(next_state[state][i], n_accept[state][i]) = transit(pma, word, state);\n            }\n        }\n\n        vector<int> word_len(word2id.size());\n        for (auto p : word2id) {\n            string word; int i; tie(word, i) = p;\n            word_len[i] = word.size();\n        }\n\n        using Entry = tuple<int, int, int, int>;\n        map<Entry, int> dp;\n        REP(word, word2id.size()) {\n            Entry e = Entry(word_len[word], next_state[0][word], word, n_accept[0][word]);\n            if (get<0>(e) <= M && get<3>(e) <= 1)\n                dp[e] = 1;\n        }\n        REP(length, M+1) {\n            REP(state, pma.size()) {\n                REP(word1, word2id.size()) {\n                    REP(n_season, 2) {\n                        int c = dp[Entry(length, state, word1, n_season)];\n                        for (int word2 : graph[word1]) {\n                            Entry next = Entry(\n                                length + word_len[word2],\n                                next_state[state][word2],\n                                word2,\n                                n_season + n_accept[state][word2]);\n                            if (get<0>(next) > M || get<3>(next) > 1) continue;\n                            dp[next] = (dp[next] + c) % 1000000007;\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(state, pma.size()) REP(word, word2id.size()) if (dp.count(Entry(M, state, word, 1)))\n            ans = (ans + dp[Entry(M, state, word, 1)]) % 1000000007;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstruct State{\n\t\tint next[256], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tREP(i, 256){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst) continue;\n\t\t\t\tq.push(dst);\n\t\t\t\tint f = states[p].failure;\n\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\tif(p){\n\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tunordered_map<int, unordered_map<int, int>> dp[1000][2];\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2)FOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\tconst ll t = p_->second;\n\t\t\tconst int u = u_->first;\n\t\t\tint p = p_->first;\n\t\t\tFOR(v, g[u]){\n\t\t\t\tconst string &s = strs[*v];\n\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=1000;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    //if (nextn >= N || nextpma >= NODE)cout <<\"ERR\"<<endl;\n\t    if (nextn >= N){\n\t      //cout <<\"ERR \" <<  nextn << endl;\n\t    }\n\t    if (nextpma >= NODE){\n\t      cout << \"err \" << nextpma << endl;\n\t    }\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,MAX_ps) cans[i].clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],a[i21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    /*\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    */\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\nint dp[510][510][610][2]; // len words state ac\n\nint main(void){\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][w][root][0]=1LL;\n\t\trep(i,m)rep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\tif(i>0&&j==w) continue;\n\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\tif(ni>m) continue;\n\t\t\t\tint nk=k,nl=l;\n\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t}\n\t\t\t\tif(nl>=2) continue;\n\t\t\t\tdp[ni][nj][nk][nl]+=dp[i][j][k][l];\n\t\t\t\tdp[ni][nj][nk][nl]%=mod;\n\t\t\t}\n\t\t}\n\t\tll ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tans+=dp[m][j][k][1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint cur = 0;\n\nstruct T{\n\tint id,flag;\n\tT *next[26];\n\tT(){ id = 0; flag=0;for(int i = 0 ; i < 26 ; i++) next[i] = NULL; }\n};\n\nT *rope[1000];\n\nvoid add(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t}else{\n\t\t\troot = root->next[s[i]-'a'] = new T();\n\t\t\trope[cur] = root;\n\t\t\troot->id = cur++;\n\t\t}\n\t}\n\troot->flag ++;\n}\n\nbool done[1000];\n\nint tmp;\nint exists(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t\ttmp += root->flag;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn root->id;\n}\nvoid failed_generate(T *root,string c,T *src){\n\tif( done[root->id] ) return;\n\telse done[root->id] = true;\n\t\n\tfor(int i = 0 ; i < 26 ; i++){\n\t\tif( root->next[i] ){\n\t\t\tfailed_generate(root->next[i],c+(char)(i+'a'),src);\n\t\t}else{\n\t\t\tstring w = c + (char)(i+'a');\n\t\t\tint idx = 0;\n\t\t\tfor(int j = 0 ; j < w.size() ; j++){\n\t\t\t\tint r = exists(src,w.substr(j));\n\t\t\t\tif( r != -1 ){\n\t\t\t\t\tidx = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot->next[i] = rope[idx];\n\t\t}\n\t}\n}\n\n\nmap<string,int> dic;\nstring ln[500];\n\nvector<int> connect[500];\n\nint mem[1000][500];\nint mem2[1000][500];\nmap< pair< pair<int,int> , pair<int,int> >, int > memo;\nint dfs(int pos,int word,int info,int ok){\n\tif( ok > 1 ) return 0;\n\tpair< pair<int,int>, pair<int,int> > key = make_pair( make_pair(pos,word) , make_pair(info,ok) );\n\tif( memo.count(key) ) return memo[key];\n\tif( word < 0 ) return 0;\n\tif( word == 0 ) return ok == 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < connect[pos].size() ; i++){\n\t\tans += dfs(connect[pos][i],word - ln[connect[pos][i]].size() , mem[info][connect[pos][i]],ok+mem2[info][connect[pos][i]]);\n\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t}\n\treturn memo[key] = ans;\n}\nint main(){\n\tint n,m,k;\n\twhile(cin >> n >> m >> k && n){\n\t\tdic.clear();\n\t\t\n\t\tfor(int i = 0 ; i < 1000 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 500 ; i++) ln[i] = \"\", connect[i].clear();\n\t\tfor(int i = 0 ; i < 1000 ; i++) rope[i] = NULL;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif( dic.count(a) == 0 ){ int k = dic.size(); dic[a] = k; ln[k] = a;}\n\t\t\tif( dic.count(b) == 0 ){ int k = dic.size(); dic[b] = k; ln[k] = b;}\n\t\t\tconnect[dic[a]].push_back(dic[b]);\n\t\t\t\n\t\t}\n\t\tT *root = new T();\n\t\trope[0] = root;\n\t\tcur = 1;\n\t\t\n\t\tvector<string> ttt;\n\t\t\n\t\tfor(int i = 0 ; i < k ; i++){\n\t\t\tstring l;\n\t\t\tcin >> l;\n\t\t\tttt.push_back(l);\n\t\t}\n\t\tbool bad[1000]={};\n\t\tfor(int i = 0 ; i < k ; i++){\n\t\t\tfor(int j = 0 ; j < k ; j++){\n\t\t\t\tif( i != j ){\n\t\t\t\t\tif( ~ttt[i].find(ttt[j]) ){\n\t\t\t\t\t\tbad[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nk = 0;\n\t\tfor(int i = 0 ; i < k ; i++){\n\t\t\tif( !bad[i] ){\n\t\t\t\tnk++;\n\t\t\t\tadd(root,ttt[i]);\n\t\t\t}\n\t\t}\n\t\tk = nk;\n\t\t\n\t\tfailed_generate(root,\"\",root);\n\t\t\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tfor(int k = 0 ; k < dic.size() ; k++){\n\t\t\t\ttmp = 0;\n\t\t\t\tmem[i][k] = exists(rope[i],ln[k]);\n\t\t\t\tmem2[i][k] = tmp;\n\t\t\t\t//cout << i << \" \" << ln[k] << \" \" << tmp << \" \" << mem[i][k] << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.clear();\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tans += dfs(i,m - ln[i].size(),mem[0][i],mem2[0][i]);\n\t\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct SAComp {\n  const int h, *g;\n  SAComp(int h, int* g) : h(h), g(g) {}\n  bool operator() (int a, int b) {\n    return a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a+h] < g[b+h];\n  }\n};\nint *buildSA(const char* t, int n) {\n  int g[n+1], b[n+1], *v = new int[n+1];\n  REP(i,n+1) v[i] = i, g[i] = t[i];\n  b[0] = 0; b[n] = 0;\n\n  sort(v, v+n+1, SAComp(0, g));\n  for(int h = 1; b[n] != n ; h *= 2) {\n    SAComp comp(h, g);\n    sort(v, v+n+1, comp);\n    REP(i, n) b[i+1] = b[i] + comp(v[i], v[i+1]);\n    REP(i, n+1) g[v[i]] = b[i];\n  }\n  return v;\n}\n\nstring S;\nint lb(int *sa, string s) {\n\tint l = 0, r = S.size()+1;\n\tREP(t, 50) {\n\t\tint m = (l + r) / 2;\n\t\tstring ss = sa[m]+s.size() <= S.size() ? S.substr(sa[m], s.size()) : S.substr(sa[m]);\n\t\tif (ss >= s) {\n\t\t\tr = m;\n\t\t}\n\t\telse {\n\t\t\tl = m;\n\t\t}\n\t}\n\treturn r;\n}\nint ub(int *sa, string s) {\n\tint l = 0, r = S.size()+1;\n\tREP(t, 50) {\n\t\tint m = (l + r) / 2;\n\t\tstring ss = sa[m]+s.size() <= S.size() ? S.substr(sa[m], s.size()) : S.substr(sa[m]);\n\t\tif (ss > s) {\n\t\t\tr = m;\n\t\t}\n\t\telse {\n\t\t\tl = m;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint *sa, *sa_r;\n\tcin >> S;\n\tstring S_r = S; reverse(ALL(S_r));\n\tint n = S.size();\n\tsa = buildSA(S.c_str(), n);\n\tsa_r = buildSA(S_r.c_str(), n);\n\tint Q; cin >> Q;\n\tREP(i, n) {\n//\t\tcout << i << \" \" << S.substr(sa[i]) << endl;\n\t}\n\tREP(q, Q) {\n\t\tstring a, b; cin >> a >> b;\n//\t\treverse(ALL(b));\n\t\tint r1 = inf, r2 = -inf;\n\t\t// cout << lb(sa, a) << \" \" << ub(sa, a) << endl;\n\t\tFOR(i, lb(sa, a), ub(sa, a)) {\n\t\t\tr1 = min(r1, sa[i]);\n\t\t}\n\t\tFOR(i, lb(sa, b), ub(sa, b)) {\n\t\t\tr2 = max(r2, sa[i]);\n\t\t}\n\t\tint ans = 0;\n\t\t// cout << r1 << \" \" << r2 << endl;\n\t\tif (r2 >= r1) {\n\t\t\tans = r2-r1+b.size();\n\t\t\tif (ans < a.size()) ans = 0;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct AhoCorasick {\n  static const int SIZE = 128;\n  struct State {\n    int index;\n    int next[SIZE]; // next[0] is failuer link\n    vector<int> accept;\n    State(int index) : index(index) {\n      memset(next, -1, sizeof(next));\n    }\n  };\n\n  bool build;\n  vector<State> pma;\n  vector<int> lens;\n  //vector<string. strs;\n\n  AhoCorasick() {\n    build = false;\n    pma.clear();\n    pma.push_back(State(0));\n    lens.clear();\n    //strs.clear();\n  }\n\n  void AddString(const char *str) {\n    assert(!build);\n    int t = 0;\n    for (int i = 0; str[i]; i++) {\n      int c = str[i];\n      if (pma[t].next[c] == -1) {\n        int m = pma.size();\n        pma[t].next[c] = m;\n        pma.push_back(State(m));\n      }\n      t = pma[t].next[c];\n    }\n    pma[t].accept.push_back(lens.size());\n    lens.push_back(strlen(str));\n    //strs.push_back(str);\n  }\n\n  void BuildPMA() {\n    assert(!build);\n    queue<int> que;  // make failure link using bfs\n    for (int c = 1; c < SIZE; c++) {\n      if (pma[0].next[c] != -1) {\n        pma[pma[0].next[c]].next[0] = 0;\n        que.push(pma[0].next[c]);\n      } else {\n        pma[0].next[c] = 0;\n      }\n    }\n    while (!que.empty()) {\n      int t = que.front();\n      que.pop();\n      for (int c = 1; c < SIZE; c++) {\n        if (pma[t].next[c] != -1) {\n          que.push(pma[t].next[c]);\n          int r = pma[t].next[0];\n          while (pma[r].next[c] == -1) {\n            r = pma[r].next[0];\n          }\n          pma[pma[t].next[c]].next[0] = pma[r].next[c];\n          for (vector<int>::iterator it = pma[pma[r].next[c]].accept.begin(); it != pma[pma[r].next[c]].accept.end(); it++) {\n            pma[pma[t].next[c]].accept.push_back(*it);\n          }\n        }\n      }\n    }\n    build = true;\n  }\n\n  int OneMove(int index, int c) {\n    return pma[index].next[c] != -1 ?\n      pma[index].next[c] :\n      pma[index].next[c] = OneMove(pma[index].next[0], c);\n    //while (pma[index].next[c] == -1) { index = pma[index].next[0]; }\n    //return pma[index].next[c];\n  }\n\n  // return first match indices\n  vector<int> Match(const char *t) {\n    assert(build);\n    int index = 0;\n    vector<int> ret(lens.size(), -1);\n    int n = strlen(t);\n    for (int i = 0; i < n; i++) {\n      int c = t[i];\n      index = OneMove(index, c);\n      for (vector<int>::const_iterator it = pma[index].accept.begin(); it != pma[index].accept.end(); it++) {\n        if (ret[*it] != -1) { continue; }\n        ret[*it] = i - lens[*it] + 1;\n      }\n    }\n    return ret;\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\n//=======================================\n\nstruct State {\n  int prev;\n  int index;\n  char exist;\n  State() {;}\n  State(int prev, int index, int exist) : prev(prev), index(index), exist(exist) {;}\n  bool operator<(const State &rhs) const {\n    //if (depth != rhs.depth) { return depth < rhs.depth; }\n    if (prev != rhs.prev) { return prev < rhs.prev; }\n    if (index != rhs.index) { return index < rhs.index; }\n    return exist < rhs.exist;\n  }\n};\n\nll MOD = 1000000007;\nint n, m, k, s;\nGraph g;\nmap<string, int> mapto;\nstring mapfrom[1010];\nint len[1010];\nAhoCorasick aho;\nmap<State, int> memo[510];\npair<int, char> moveMemo[1001][1010];\n\n//===========================================\n\npair<int, int> Move(int index, int word) {\n  if (moveMemo[index][word].first != -1) { return moveMemo[index][word]; }\n  pair<int, int> ret(index, 0);\n  FORIT(it, mapfrom[word]) {\n    ret.first = aho.OneMove(ret.first, *it);\n    ret.second += aho.pma[ret.first].accept.size();\n  }\n  ret.second = min(ret.second, 2);\n  return moveMemo[index][word] = ret;\n}\n\nState NextState(State state, int word) {\n  pair<int, char> result = Move(state.index, word);\n  return State(word, result.first, state.exist + result.second);\n}\n\nchar str1[100], str2[100];\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &k), n|m|k) {\n    REP(i, 510) { memo[i].clear(); }\n    aho = AhoCorasick();\n    MEMSET(moveMemo, -1);\n    mapto.clear();\n    s = 0;\n    g = Graph(n * 2);\n    REP(i, n) {\n      scanf(\"%s %s\", str1, str2);\n      if (!mapto.count(str1)) {\n        mapto[str1] = s++;\n        mapfrom[mapto[str1]] = str1;\n        len[mapto[str1]] = strlen(str1);\n      }\n      if (!mapto.count(str2)) {\n        mapto[str2] = s++;\n        mapfrom[mapto[str2]] = str2;\n        len[mapto[str2]] = strlen(str2);\n      }\n      g[mapto[str1]].push_back(mapto[str2]);\n    }\n    REP(i, k) {\n      scanf(\"%s\", str1);\n      aho.AddString(str1);\n    }\n    aho.BuildPMA();\n    assert(aho.pma.size() <= 1000);\n    ll ans = 0;\n    REP(i, s) {\n      memo[len[i]][NextState(State(-1, 0, 0), i)] += 1;\n    }\n    REP(i, m + 1) {\n      FORIT(it1, memo[i]) {\n        State state = it1->first;\n        int cnt = it1->second;\n        if (i == m) {\n          ans = state.exist == 1 ? (ans + cnt) % MOD : ans;\n          continue;\n        }\n        FORIT(it2, g[state.prev]) {\n          int ndepth = i + len[*it2];\n          if (ndepth > m) { continue; }\n          State next = NextState(state, *it2);\n          if (next.exist >= 2) { continue; }\n          memo[ndepth][next] = (memo[ndepth][next] + cnt) % MOD;\n        }\n      }\n      memo[i].clear();\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MOD>\nclass mod_int {\n\tunsigned x;\npublic:\n\tmod_int() : x(0) { }\n\tmod_int(int sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tmod_int(long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tmod_int &operator+=(mod_int that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator-=(mod_int that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator*=(mod_int that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tmod_int &operator/=(mod_int that) { return *this *= that.inverse(); }\n\n\tmod_int operator+(mod_int that) const { return mod_int(*this) += that; }\n\tmod_int operator-(mod_int that) const { return mod_int(*this) -= that; }\n\tmod_int operator*(mod_int that) const { return mod_int(*this) *= that; }\n\tmod_int operator/(mod_int that) const { return mod_int(*this) /= that; }\n\n\tbool operator==(const mod_int& that) const { return x == that.x; }\n\n\tmod_int inverse() const {\n\t\tlong long a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\treturn mod_int(u);\n\t}\n};\n\ntemplate<int MOD>\nistream& operator >> (istream& is, mod_int<MOD>& val) {\n\tlong long x;\n\tis >> x; val = x;\n\treturn is;\n}\n\ntemplate<int MOD>\nostream& operator << (ostream& os, const mod_int<MOD>& val) {\n\tos << val.get();\n\treturn os;\n}\n\nconst int mod = 1e9 + 7;\nusing mint = mod_int<mod>;\n\nconst int var = 26;\n\nint trans(char c) {\n\treturn c - 'a';\n}\n\nclass aho_corasick {\n\tstruct ac_node {\n\t\tint fail;\n\t\tvector<int> next;\n\t\tvector<int> ok;\n\t\tac_node() : fail(-1), next(var, -1) {}\n\t};\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn move(res);\n\t}\n\tint n;\n\tvector<ac_node> dat;\npublic:\n\taho_corasick(const vector<string>& Ts) : n(Ts.size()), dat(1) {\n\t\tint now;\n\t\tdat[0].fail = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = 0;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (dat[now].next[trans(c)] == -1) {\n\t\t\t\t\tdat[now].next[trans(c)] = dat.size();\n\t\t\t\t\tdat.emplace_back();\n\t\t\t\t}\n\t\t\t\tnow = dat[now].next[trans(c)];\n\t\t\t}\n\t\t\tdat[now].ok.push_back(i);\n\t\t}\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < var; i++) {\n\t\t\tif (dat[0].next[i] == -1) {\n\t\t\t\tdat[0].next[i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdat[dat[0].next[i]].fail = 0;\n\t\t\t\tq.push(dat[0].next[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < var; i++) {\n\t\t\t\tif (dat[now].next[i] != -1) {\n\t\t\t\t\tint nx = dat[now].fail;\n\t\t\t\t\twhile (dat[nx].next[i] == -1) {\n\t\t\t\t\t\tnx = dat[nx].fail;\n\t\t\t\t\t}\n\t\t\t\t\tint nex = dat[now].next[i];\n\t\t\t\t\tdat[nex].fail = dat[nx].next[i];\n\t\t\t\t\tdat[nex].ok = unite(dat[nex].ok, dat[dat[nx].next[i]].ok);\n\t\t\t\t\tq.push(nex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint size() const {\n\t\treturn dat.size();\n\t}\n\tbool is_ok(int id) const {\n\t\treturn !dat[id].ok.empty();\n\t}\n\tint ok_cnt(int id) const {\n\t\treturn dat[id].ok.size();\n\t}\n\tint get_next(int id, char c) const {\n\t\twhile (dat[id].next[trans(c)] == -1) id = dat[id].fail;\n\t\treturn dat[id].next[trans(c)];\n\t}\n\tvector<int> count(const string& S) const {\n\t\tvector<int> res(n);\n\t\tint now = 0;\n\t\tfor (auto c : S) {\n\t\t\tnow = get_next(now, c);\n\t\t\tfor (auto k : dat[now].ok) res[k]++;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vector<int>> all_count(const string& S) const {\n\t\tint N = S.size();\n\t\tvector<vector<int>> res(N);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnow = get_next(now, S[i]);\n\t\t\tres[i] = dat[now].ok;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tint N, M, K;\n\twhile (cin >> N >> M >> K, N | M | K) {\n\t\tvector<string> f(N), t(N);\n\t\tvector<string> word;\n\t\tmap<string, int> dic;\n\t\tvector<vector<int>> g(500);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> f[i] >> t[i];\n\t\t\tif (!dic.count(f[i])) dic[f[i]] = word.size(), word.push_back(f[i]);\n\t\t\tif (!dic.count(t[i])) dic[t[i]] = word.size(), word.push_back(t[i]);\n\t\t\tint fid = dic[f[i]], tid = dic[t[i]];\n\t\t\tg[fid].push_back(tid);\n\t\t}\n\t\tN = word.size();\n\t\tg.resize(N);\n\t\tvector<string> ss(K);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> ss[i];\n\t\t}\n\t\taho_corasick ac(ss);\n\t\tint sz = ac.size();\n\t\tvector<vector<pair<int, int>>> nex(N, vector<pair<int, int>>(sz));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tint it = j;\n\t\t\t\tfor (auto c : word[i]) {\n\t\t\t\t\tit = ac.get_next(it, c);\n\t\t\t\t\tcnt += ac.ok_cnt(it);\n\t\t\t\t}\n\t\t\t\tnex[i][j] = make_pair(cnt, it);\n\t\t\t}\n\t\t}\n\t\tvector<vector<vector<vector<mint>>>> dp(M + 1, vector<vector<vector<mint>>>(N, vector<vector<mint>>(2, vector<mint>(sz))));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tauto &p = nex[i][0];\n\t\t\tint pos = word[i].size();\n\t\t\tif (pos <= M && p.first < 2) dp[pos][i][p.first][p.second] += 1;\n\t\t}\n\t\tfor (int i = 1; i < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (auto to : g[j]) {\n\t\t\t\t\tfor (int k = 0; k < sz; k++) {\n\t\t\t\t\t\tfor (int b = 0; b < 2; b++) if (dp[i][j][b][k].get() != 0) {\n\t\t\t\t\t\t\tauto &p = nex[to][k];\n\t\t\t\t\t\t\tint pos = i + word[to].size(), c = b + p.first;\n\t\t\t\t\t\t\tif (pos <= M && c < 2) {\n\t\t\t\t\t\t\t\tdp[pos][to][c][p.second] += dp[i][j][b][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tres += dp[M][i][1][j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[621];\nvector<int> to[500];\nstring str[500];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tmap<string,int> id;\t\n\t\tfor(int i=0;i<621;i++)dp[i].clear();\n\t\tfor(int i=0;i<500;i++)to[i].clear(),str[i].clear();\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tADD(dp[i+str[dest].size()][t],it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\n#define AHOSIZE 256\n\nstruct Aho;\n\nconst int mod = 1000000007;\nint N,M,K;\nmap<Aho*,int> memo;\nvector<int> dict[500];\nstring from[250], to[250];\n\nstruct Aho{\n    string str;\n    Aho *next[AHOSIZE], *fail;\n\n    Aho(){\n        int i,j;\n        fail = NULL;\n        rep(i,AHOSIZE) next[i] = NULL;\n    }\n    ~Aho(){\n        int i;\n        rep(i,AHOSIZE) if( next[i] ) delete next[i];\n    }\n\n    void insert(const string& in){\n        int i,n = in.length();\n        Aho *now = this;\n\n        rep(i,n){\n            if( now->next[in[i]] == NULL ){\n                now->next[in[i]] = new Aho();\n            }\n            now = now->next[in[i]];\n        }\n        now->str = in;\n    }\n\n    // failツづーツ催ャツづゥ\n    void build(){\n        int i;\n        queue<Aho*> q;\n        q.push(this);\n        \n        while( !q.empty() ){\n            Aho *now = q.front();\n            q.pop();\n            \n            rep(i,AHOSIZE) if( now->next[i] ) {\n                q.push(now->next[i]);\n\n                Aho *r = now->fail;\n                while( r != NULL && r->next[i] == NULL ) r = r->fail;\n                if( r != NULL ){\n                    now->next[i]->fail = r->next[i];\n                }\n                else{\n                    now->next[i]->fail = this;\n                }\n            }\n        }\n    }\n\n    Aho* match(Aho* root, const string& in, int* hit){\n        int i, n = in.length();\n        Aho *now = root;\n        \n        rep(i,n){\n            if( now->next[in[i]] ){\n                now = now->next[in[i]];\n            }\n            else{\n                while( now != this ){\n                    now = now->fail;\n                    if( now->next[in[i]] ){\n                        now = now->next[in[i]];\n                        break;\n                    }\n                }\n            }\n            \n            // ツつアツつアツづ個渉按猟敖づ債δδつ可サツつキツづゥツつアツづづ債つ堕ャツ可サツづつォツづゥ\n            /*\n              [now] = hit\n             */\n            \n            Aho* tmp = now;\n            \n            // ツ全ツ探ツ催オ\n            /*\n            while( tmp != this ){\n                if( tmp->str != \"\" ) ++*hit;\n                if( *hit >= 2 ) return NULL;\n                tmp = tmp->fail;\n            }\n            */\n            \n            // ツδδつ可サ\n            \n            if( memo.count(now) ){\n                *hit += memo[now];\n                if( *hit >= 2 ) return NULL;\n            }\n            else{\n                int cc = 0;\n                while( tmp != NULL ){\n                    if( tmp->str != \"\" ){\n                        cc++;\n                    }\n                    tmp = tmp->fail;\n                    if( memo.count(tmp) ) break;\n                }\n                if( tmp == NULL ){\n                    memo[now] = cc;\n                    *hit += cc;\n                }\n                else{\n                    memo[now] = memo[tmp] + cc;\n                    *hit += memo[tmp] + cc;\n                }\n                if( *hit >= 2 ) return NULL;\n            }\n            \n            \n        }\n\n        return now;\n    }\n\n};\n\n\nstruct state{\n    int from,cnt;\n    Aho* node;\n    state(int f, int c, Aho *n){\n        from = f, cnt = c, node = n;\n    }\n    bool operator<(const state& a)const{\n        if( cnt != a.cnt ) return cnt < a.cnt;\n        if( node != a.node ) return node < a.node;\n        return from < a.from;\n    }\n};\n\nmap<state,int> dp[550];\n\nint main(){\n    int i,j;\n\n    while( cin >> N >> M >> K, N|M|K ){\n        // init\n        rep(i,550) dp[i].clear();\n        rep(i,500) dict[i].clear();\n        memo.clear();\n\n\n        Aho Ahoinit;\n        set<string> ss;\n\n\n        // dict[from is new index][ツ古つ青脳 = to is new index \n\n        // input\n        rep(i,N){\n            cin >> from[i] >> to[i];\n            ss.insert(from[i]);\n            ss.insert(to[i]);\n        }\n\n        //\n        vector<string> words(ss.begin(), ss.end());\n        rep(i,words.size()){\n            rep(j,N) if( words[i] == from[j] ) {\n                dict[i].push_back(lower_bound(all(words), to[j]) - words.begin());\n            }\n        }\n\n        rep(i,K){\n            string kigo; cin >> kigo;\n            Ahoinit.insert(kigo);\n        }\n        Ahoinit.build();\n\n        // start\n        rep(i,words.size()){\n            int cnt = 0;\n            Aho* next = Ahoinit.match(&Ahoinit, words[i], &cnt);\n            if( cnt < 2 ){\n                dp[words[i].length()][state(i,cnt,next)] = 1;\n            }\n        }\n        \n        rep(j,M){\n            foreach(it,dp[j]){\n                int f_id = it->first.from;\n                int cnt = it->first.cnt;\n                Aho *now = it->first.node;\n                int res = it->second;\n\n                rep(i,dict[f_id].size()){\n                    int t_id = dict[f_id][i];\n                    int n = words[t_id].length();\n                    if( j + n > M ) continue;\n\n                    int tcnt = cnt;\n                    Aho *next = Ahoinit.match(now, words[t_id], &tcnt);\n                    if( tcnt < 2 && next != NULL ){\n                        dp[j + n][state(t_id, tcnt, next)] += res;\n                        dp[j + n][state(t_id, tcnt, next)] %= mod;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        foreach(it,dp[M]) if( it->first.cnt == 1 ) {\n            ans += it->second;\n            ans %= mod;\n        }\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstruct State{\n\t\tint next[256], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tREP(i, 256){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst) continue;\n\t\t\t\tq.push(dst);\n\t\t\t\tint f = states[p].failure;\n\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\tif(p){\n\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(N+5);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tunordered_map<int, unordered_map<int, int>> dp[1000][2];\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2)FOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\tconst ll t = p_->second;\n\t\t\tconst int u = u_->first;\n\t\t\tint p = p_->first;\n\t\t\tFOR(v, g[u]){\n\t\t\t\tconst string &s = strs[*v];\n\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][501][21][601];\nbool used[2][2][501][21][601];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) goto END;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) goto END;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\n#define AHOSIZE 26\n\nconst int mod = 1000000007;\nint N,M,K;\nvector<int> dict[500];\nstring from[250], to[250];\nint ahosize;\nchar memo[1000]; // ahoid\n\nstruct Aho{\n    bool accept;\n    int id;\n    Aho *next[AHOSIZE], *fail;\n\n    Aho(){\n        int i;\n        fail = NULL;\n        accept = false;\n        id = ahosize; //\n        ahosize++; //\n        rep(i,AHOSIZE) next[i] = NULL;\n    }\n    ~Aho(){\n        int i;\n        rep(i,AHOSIZE) if( next[i] ) delete next[i];\n    }\n\n    void insert(const string& in){\n        int i,n = in.length();\n        Aho *now = this;\n\n        rep(i,n){\n            if( now->next[in[i]-'a'] == NULL ){\n                now->next[in[i]-'a'] = new Aho();\n            }\n            now = now->next[in[i]-'a'];\n        }\n        now->accept = true;\n    }\n\n    // failツづーツ催ャツづゥ\n    void build(){\n        int i;\n        queue<Aho*> q;\n        q.push(this);\n        \n        while( !q.empty() ){\n            Aho *now = q.front();\n            q.pop();\n            \n            rep(i,AHOSIZE) if( now->next[i] ) {\n                q.push(now->next[i]);\n\n                Aho *r = now->fail;\n                while( r != NULL && r->next[i] == NULL ) r = r->fail;\n                if( r != NULL ){\n                    now->next[i]->fail = r->next[i];\n                }\n                else{\n                    now->next[i]->fail = this;\n                }\n            }\n        }\n    }\n\n    Aho* match(Aho* root, const string& in, int* hit){\n        int i, n = in.length();\n        Aho *now = root;\n        \n        rep(i,n){\n            if( now->next[in[i]-'a'] ){\n                now = now->next[in[i]-'a'];\n            }\n            else{\n                while( now != this ){\n                    now = now->fail;\n                    if( now->next[in[i]-'a'] ){\n                        now = now->next[in[i]-'a'];\n                        break;\n                    }\n                }\n            }\n            \n            // ツつアツつアツづ個渉按猟敖づ債δδつ可サツつキツづゥツつアツづづ債つ堕ャツ可サツづつォツづゥ\n            Aho* tmp = now;\n            \n            // ツ全ツ探ツ催オ\n            /*\n            while( tmp != this ){\n                if( tmp->accept ) ++*hit;\n                if( *hit >= 2 ) return NULL;\n                tmp = tmp->fail;\n            }\n            */\n\n            // ツδδつ可サ\n            int cc = 0;\n            if( memo[now->id] != -1 ){\n                cc = memo[now->id];\n            }\n            else{\n                while( tmp != this ){\n                    if( memo[tmp->id] != -1 ){\n                        cc += memo[tmp->id];\n                        break;\n                    }\n                    else{\n                        if( tmp->accept ) cc++;\n                    }\n                    tmp = tmp->fail;\n                }\n                memo[now->id] = cc;\n            }\n            *hit += cc;\n            if( *hit >= 2 ) return NULL;\n        }\n\n        return now;\n    }\n\n};\n\n\nstruct state{\n    int from,cnt;\n    Aho* node;\n    state(int f, int c, Aho *n){\n        from = f, cnt = c, node = n;\n    }\n    bool operator<(const state& a)const{\n        if( cnt != a.cnt ) return cnt < a.cnt;\n        if( node != a.node ) return node < a.node;\n        return from < a.from;\n    }\n};\n\n#define Z 21\nmap<state,int> dp[Z];\n\nint main(){\n    int i,j;\n\n    while( cin >> N >> M >> K, N|M|K ){\n        // init\n        rep(i,Z) dp[i].clear();\n        rep(i,500) dict[i].clear();\n        memset(memo, -1, sizeof(memo));\n        ahosize = 0;\n\n\n        Aho Ahoinit;\n        set<string> ss;\n\n\n        // dict[from is new index][ツ古つ青脳 = to is new index \n\n        // input\n        rep(i,N){\n            cin >> from[i] >> to[i];\n            ss.insert(from[i]);\n            ss.insert(to[i]);\n        }\n\n        //\n        vector<string> words(ss.begin(), ss.end());\n        rep(i,words.size()){\n            rep(j,N) if( words[i] == from[j] ) {\n                dict[i].push_back(lower_bound(all(words), to[j]) - words.begin());\n            }\n        }\n\n        rep(i,K){\n            string kigo; cin >> kigo;\n            Ahoinit.insert(kigo);\n        }\n        Ahoinit.build();\n\n        // start\n        rep(i,words.size()){\n            int cnt = 0;\n            Aho* next = Ahoinit.match(&Ahoinit, words[i], &cnt);\n            if( cnt < 2 ){\n                dp[words[i].length()][state(i,cnt,next)] = 1;\n            }\n        }\n        \n        rep(j,M){\n            foreach(it,dp[j%Z]){\n                int f_id = it->first.from;\n                int cnt = it->first.cnt;\n                Aho *now = it->first.node;\n                int res = it->second;\n\n                rep(i,dict[f_id].size()){\n                    int t_id = dict[f_id][i];\n                    int n = words[t_id].length();\n                    if( j + n > M ) continue;\n\n                    int tcnt = cnt;\n                    Aho *next = Ahoinit.match(now, words[t_id], &tcnt);\n                    if( tcnt < 2 && next != NULL ){\n                        dp[(j + n)%Z][state(t_id, tcnt, next)] += res;\n                        dp[(j + n)%Z][state(t_id, tcnt, next)] %= mod;\n                    }\n                }\n            }\n            // clear\n            dp[j%Z].clear();\n        }\n\n        int ans = 0;\n        foreach(it,dp[M%Z]) if( it->first.cnt == 1 ) {\n            ans += it->second;\n            ans %= mod;\n        }\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//  ch_cnts[now]++;\n//  for (auto&& e : g[now]) {\n//      ch_cnts[now] += dfs(g, e, ch_cnts);\n//  }\n//  return ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//  int from;\n//  int to;\n//  bool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//  int max_ch_id = 1;\n//  {\n//      int max_ch_num = -1;\n//      for (auto&&e : g[now]) {\n//          if (max_ch_num < ch_cnts[e]) {\n//              max_ch_num = ch_cnts[e];\n//              max_ch_id = e;\n//          }\n//      }\n//  }\n//  for (auto e : g[now]) {\n//      bool heavy = (e == max_ch_id);\n//\n//      hl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//  }\n//  return;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//  vector<int>ch_cnts(ro_tree.size());\n//\n//  dfs(ro_tree, 0, ch_cnts);\n//\n//  vector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//  dfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//  using C = complex< double >;\n//\n//  void DiscreteFourierTransform(vector< C > &F, bool rev)\n//  {\n//      const int N = (int)F.size();\n//      const double PI = (rev ? -1 : 1) * acos(-1);\n//      for (int i = 0, j = 1; j + 1 < N; j++) {\n//          for (int k = N >> 1; k > (i ^= k); k >>= 1);\n//          if (i > j) swap(F[i], F[j]);\n//      }\n//      C w, s, t;\n//      for (int i = 1; i < N; i <<= 1) {\n//          for (int k = 0; k < i; k++) {\n//              w = polar(1.0, PI / i * k);\n//              for (int j = 0; j < N; j += i * 2) {\n//                  s = F[j + k];\n//                  t = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//                      F[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//                  F[j + k] = s + t, F[j + k + i] = s - t;\n//              }\n//          }\n//      }\n//      if (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//  }\n//\n//  vector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//  {\n//      int sz = 1;\n//      while (sz <= A.size() + B.size()) sz <<= 1;\n//      vector< C > F(sz), G(sz);\n//      for (int i = 0; i < A.size(); i++) F[i] = A[i];\n//      for (int i = 0; i < B.size(); i++) G[i] = B[i];\n//      DiscreteFourierTransform(F, false);\n//      DiscreteFourierTransform(G, false);\n//      for (int i = 0; i < sz; i++) F[i] *= G[i];\n//      DiscreteFourierTransform(F, true);\n//      vector< int > X(A.size() + B.size() - 1);\n//      for (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//      return (X);\n//  }\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr), valid(-1) {\n\n\t}\n\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j = 0; j<sts.size(); ++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next = now->chs[sts[j][i] - 'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i] - 'a'] = make_shared<PMA>();\n\t\t\t\tnext = now->chs[sts[j][i] - 'a'];\n\t\t\t}\n\n\t\t\tnow = next;\n\n\t\t}\n\t\tnow->valid = j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor (int i = 0; i<26; ++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r = afront->fail;\n\n\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod = 1e9 + 7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif (!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto&& nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (next_kigo <= 1) {\n\n\t\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\twhile (true) {\n\t\tcout<<0<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nconst int NUMC = 26;\n\nclass Trie {\npublic:\n\tvector<vector<int> > V;\n\tint find(string s) {\n\t\tint cur=0;\n\t\trep(i,s.size()){\n            if((cur=V[cur][s[i]+1])==0) return -1;\n        }\n\t\treturn cur;\n\t}\n\tvoid create(vector<string> S){\n\t\tV.clear();\n\t\tV.push_back(vector<int>(NUMC+1));\n\t\tsort(S.begin(),S.end());\n\t\trep(i,S.size()){\n\t\t\tint cur=0;\n\t\t\trep(j,S[i].size()){\n\t\t\t\tif(V[cur][S[i][j]+1]==0) V.push_back(vector<int>(NUMC+1)),V[cur][S[i][j]+1]=V.size()-1;\n\t\t\t\tcur=V[cur][S[i][j]+1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass ACmatch_num {\npublic:\n\tTrie t;\n\tvector<int> acc;\n\tint ma;\n\tvoid create(vector<string> S) {\n        rep(i,(int)S.size()){\n            rep(j,(int)S[i].size()){\n                S[i][j] -= 'a';\n            }\n        }\n\t\tint i;\n\t\tma=S.size();\n\t\tt.create(S);\n\t\tacc.clear();\n\t\tacc.resize(t.V.size());\n\t\trep(i,S.size()) acc[t.find(S[i])]++;\n\t\tqueue<int> Q;\n\t\trep(i,NUMC) if(t.V[0][i+1]) t.V[t.V[0][i+1]][0]=0, Q.push(t.V[0][i+1]);\n\n\t\twhile(!Q.empty()) {\n\t\t\tint k=Q.front(); Q.pop();\n\t\t\trep(i,NUMC) if(t.V[k][i+1]) {\n\t\t\t\tQ.push(t.V[k][i+1]);\n\t\t\t\tint pre=t.V[k][0];\n\t\t\t\twhile(pre && t.V[pre][i+1]==0) pre=t.V[pre][0];\n\t\t\t\tt.V[t.V[k][i+1]][0]=t.V[pre][i+1];\n\t\t\t\tacc[t.V[k][i+1]] += acc[t.V[pre][i+1]];\n\t\t\t}\n\t\t}\n\t}\n\tint match(string S) {\n        rep(i,(int)S.size()){\n            S[i] -= 'a';\n        }\n\t\tint R=0;\n\t\tint cur=0;\n\t\trep(i,(int)S.size()){\n\t\t\twhile(cur && t.V[cur][S[i]+1]==0) cur=t.V[cur][0];\n\t\t\tcur=t.V[cur][S[i]+1];\n\t\t\tR += acc[cur];\n\t\t}\n\t\treturn R;\n\t}\n};\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nvector<int> G[501];\n\nbool ok(int id,string& cri,map<pll,vi>* st,RollingHash& ch)\n{\n    if(len(st[len(cri)-id-1]) == 0){\n        return false;\n    }\n    pll foo = ch.hash(id,len(cri)-1);\n    if(st[len(cri)-id-1].find(foo) == st[len(cri)-id-1].end()){\n        return false;\n    }else{\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,K;\n        cin >> n >> m >> K;\n        if(n == 0){\n            break;\n        }\n        rep(i,501){\n            G[i].clear();\n        }\n        map<string,int> mp;\n        vs s,t(K);\n        int num = 0;\n        rep(i,n){\n            string a,b;\n            cin >> a >> b;\n            if(mp.find(a) == mp.end()){\n                s.pb(a);\n                mp[a] = num++;\n            }\n            if(mp.find(b) == mp.end()){\n                s.pb(b);\n                mp[b] = num++;\n            }\n            G[mp[a]].pb(mp[b]);\n        }\n        rep(i,num-1){\n            G[num].pb(i);\n        }\n        int comp[31][21][21];\n        vector<RollingHash> rh(K);\n        map<pll,vi> st[21];\n        rep(i,K){\n            cin >> t[i];\n            rh[i].init(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    st[k-j][rh[i].hash(j,k)] = {i,j,k};\n                }\n            }\n        }\n        ACmatch_num an;\n        an.create(t);\n        // cout << an.match(\"sakura\") << \"\\n\";\n        // cout << an.match(\"sakur\") << \"\\n\";\n        rep(i,K){\n            // show(t[i]);\n            rep(j,len(t[i])-1){\n                srep(k,j,len(t[i])-1){\n                    // cout << j << \" \" << k << \"\\n\";\n                    comp[i][j][k] = an.match(t[i].substr(j,k-j+1));\n                }\n            }\n        }\n        map<vi,ll> dp[501];\n        dp[0][{-1,0,0,num,0}] = 1;\n        rep(i,m){\n            each(it,dp[i]){\n                int idx = it.fi[0], idy = it.fi[1], idz = it.fi[2],pre = it.fi[3],nw = it.fi[4];\n                ll val = it.se;\n                each(j,G[pre]){\n                    if(i+len(s[j]) > m){\n                        continue;\n                    }\n                    string cri;\n                    int diff = 0;\n                    if(idx == -1){\n                        cri = s[j];\n                    }else{\n                        cri = t[idx].substr(idy,idz-idy+1);\n                        cri += s[j];\n                        diff = comp[idx][idy][idz];\n                    }\n                    RollingHash ch;\n                    ch.init(cri);\n                    vi nx = {-1,0,0};\n                    int l = 0,r = len(cri)-1;\n                    if(ok(r,cri,st,ch)){\n                        while(r-l>1){\n                            int mid = (l+r)/2;\n                            if(ok(mid,cri,st,ch)){\n                                r = mid;\n                            }else{\n                                l = mid;\n                            }\n                        }\n                    }\n                    nx = st[len(cri)-r-1][ch.hash(r,len(cri)-1)];\n                    int res = an.match(cri) - diff;\n                    if(res == 1){\n                        if(nw == 0){\n                            dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,1}] + val) % MOD;\n                        }\n                    }else{\n                        dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] = (dp[i+len(s[j])][{nx[0],nx[1],nx[2],j,0}] + val) % MOD;\n                    }\n                }\n            }\n        }\n        ll ans = 0;\n        each(it,dp[m]){\n            ans += it.se;\n        }\n        cout << ans % MOD << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int> state;\nmap<state,int> dp[510][2]; // len ac words state\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].emplace_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].emplace_back(i);\n\n\t\tdp[0][0][make_tuple(w,root)]=1LL;\n\t\trep(i,m){\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tif(dp[i][l].find(make_tuple(j,k))==dp[i][l].end()) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][nl][make_tuple(nj,nk)]+=dp[i][l][make_tuple(j,k)];\n\t\t\t\t\tdp[ni][nl][make_tuple(nj,nk)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(l,2) dp[i][l].clear();\n\t\t}\n\t\tint ans=0LL;\n\t\tfor(auto &i:dp[m][1]){\n\t\t\tans+=i.second;\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t\trep(l,2) dp[m][l].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].emplace_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].emplace_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i%2==0&&i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  string last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n    dp[0][State()] = 1;\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n    for(int prev_word_length = 0; prev_word_length <= word_limit; prev_word_length++){\n\tfor(map<State,int>::iterator prev_state_it = dp[prev_word_length].begin();\n\t    prev_state_it != dp[prev_word_length].end();\n\t    prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& from = it->first;\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n\t}\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint cur = 0;\n\nstruct T{\n\tshort id,flag;\n\tT *next[26];\n\tT(){ id = flag=0;for(int i = 0 ; i < 26 ; i++) next[i] = NULL; }\n};\n\nT *rope[1000];\nint bad[1000];\n\nstring ttt[1000];\n\nint n,m,K;\nvoid add(T *root,string s){\n\t//cout << \"[\" << s << \"]\" << endl;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t}else{\n\t\t\troot = root->next[s[i]-'a'] = new T();\n\t\t\trope[cur] = root;\n\t\t\troot->id = cur++;\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tif( ttt[j].size() <= (i+1) ){\n\t\t\t\t\tif( s.substr(i+1-ttt[j].size(),ttt[j].size()) == ttt[j] ){\n\t\t\t\t\t\troot->flag++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool done[1000];\n\nint tmp;\nint exists(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t\ttmp += root->flag;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn root->id;\n}\nvoid failed_generate(T *root,string c,T *src){\n\tif( done[root->id] ) return;\n\telse done[root->id] = true;\n\t//cout << root->id << \": \" << c << \" \" << root->flag << endl;\n\tfor(int i = 0 ; i < 26 ; i++){\n\t\tif( root->next[i] ){\n\t\t\tfailed_generate(root->next[i],c+(char)(i+'a'),src);\n\t\t}else{\n\t\t\t\n\t\t\tstring w = c + (char)(i+'a');\n\t\t\tint idx = 0;\n\t\t\tfor(int j = 0 ; j < w.size() ; j++){\n\t\t\t\tint r = exists(src,w.substr(j));\n\t\t\t\tif( r != -1 ){\n\t\t\t\t\tidx = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot->next[i] = rope[idx];\n\t\t}\n\t}\n}\n\n\nmap<string,int> dic;\nstring ln[500];\n\nvector<int> connect[500];\n\nshort mem[610][500];\nshort mem2[610][500];\n\nint dp[21][500][610][2];\n\n/*\nmap< pair< pair<int,int> , pair<int,int> >, int > memo;\nint dfs(int pos,int word,int info,int ok){\n\tif( ok > 1 ) return 0;\n\tpair< pair<int,int>, pair<int,int> > key = make_pair( make_pair(pos,word) , make_pair(info,ok) );\n\t//cout << ln[pos] << \" \" << word << \" \" << info << \" \" << ok << endl;\n\tif( memo.count(key) ) return memo[key];\n\tif( word < 0 ) return 0;\n\tif( word == 0 ) return ok == 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < connect[pos].size() ; i++){\n\t\tans += dfs(connect[pos][i],word - ln[connect[pos][i]].size() , mem[info][connect[pos][i]],ok+mem2[info][connect[pos][i]]);\n\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t}\n\treturn memo[key] = ans;\n}\n*/\nint main(){\n\twhile(cin >> n >> m >> K && n){\n\t\tdic.clear();\n\t\t\n\t\tfor(int i = 0 ; i < 1000 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 500 ; i++) ln[i] = \"\", connect[i].clear();\n\t\tfor(int i = 0 ; i < 1000 ; i++) rope[i] = NULL;\n\t\tfor(int i = 0 ; i < 1000 ; i++)bad[i] = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif( dic.count(a) == 0 ){ int k = dic.size(); dic[a] = k; ln[k] = a;}\n\t\t\tif( dic.count(b) == 0 ){ int k = dic.size(); dic[b] = k; ln[k] = b;}\n\t\t\tconnect[dic[a]].push_back(dic[b]);\n\t\t\t\n\t\t}\n\t\tT *root = new T();\n\t\trope[0] = root;\n\t\tcur = 1;\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tstring l;\n\t\t\tcin >> l;\n\t\t\tttt[i] = l;\n\t\t\t//cout << l << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tadd(root,ttt[i]);\n\t\t}\n\t\t\n\t\tfailed_generate(root,\"\",root);\n\t\t\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tfor(int k = 0 ; k < dic.size() ; k++){\n\t\t\t\ttmp = 0;\n\t\t\t\tmem[i][k] = exists(rope[i],ln[k]);\n\t\t\t\tmem2[i][k] = tmp;\n\t\t\t\t//cout << i << \" \" << ln[k] << \" \" << tmp << \" \" << mem[i][k] << \" \" << mem2[i][k] << endl;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tif( mem2[0][i] < 2 ) dp[ln[i].size()][i][mem[0][i]][mem2[0][i]] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tfor(int j = 0 ; j < dic.size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\t\tfor(int f = 0 ; f < 2 ; f ++){\n\t\t\t\t\t\tif( dp[i%21][j][k][f] == 0 ) continue;\n\t\t\t\t\t\tfor(int l = 0 ; l < connect[j].size() ; l++){\n\t\t\t\t\t\t\tif( i + ln[connect[j][l]].size() <= m && f+mem2[k][connect[j][l]] < 2 ){\n\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] += dp[i%21][j][k][f];\n\t\t\t\t\t\t\t\tif( dp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] >= 1000000007 ){\n\t\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] -= 1000000007;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(dp[i%21],0,sizeof(dp[i%21]));\n\t\t}\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\tans += dp[m%21][i][k][1];\n\t\t\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//\tch_cnts[now]++;\n//\tfor (auto&& e : g[now]) {\n//\t\tch_cnts[now] += dfs(g, e, ch_cnts);\n//\t}\n//\treturn ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//\tint from;\n//\tint to;\n//\tbool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//\tint max_ch_id = 1;\n//\t{\n//\t\tint max_ch_num = -1;\n//\t\tfor (auto&&e : g[now]) {\n//\t\t\tif (max_ch_num < ch_cnts[e]) {\n//\t\t\t\tmax_ch_num = ch_cnts[e];\n//\t\t\t\tmax_ch_id = e;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (auto e : g[now]) {\n//\t\tbool heavy = (e == max_ch_id);\n//\n//\t\thl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//\t}\n//\treturn;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//\tvector<int>ch_cnts(ro_tree.size());\n//\n//\tdfs(ro_tree, 0, ch_cnts);\n//\n//\tvector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//\tdfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//\tusing C = complex< double >;\n//\n//\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n//\t{\n//\t\tconst int N = (int)F.size();\n//\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n//\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n//\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n//\t\t\tif (i > j) swap(F[i], F[j]);\n//\t\t}\n//\t\tC w, s, t;\n//\t\tfor (int i = 1; i < N; i <<= 1) {\n//\t\t\tfor (int k = 0; k < i; k++) {\n//\t\t\t\tw = polar(1.0, PI / i * k);\n//\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n//\t\t\t\t\ts = F[j + k];\n//\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//\t}\n//\n//\tvector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//\t{\n//\t\tint sz = 1;\n//\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n//\t\tvector< C > F(sz), G(sz);\n//\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n//\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n//\t\tDiscreteFourierTransform(F, false);\n//\t\tDiscreteFourierTransform(G, false);\n//\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n//\t\tDiscreteFourierTransform(F, true);\n//\t\tvector< int > X(A.size() + B.size() - 1);\n//\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//\t\treturn (X);\n//\t}\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr),valid(-1) {\n\n\t}\n\t\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j=0;j<sts.size();++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next=now->chs[sts[j][i]-'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i]-'a']=make_shared<PMA>();\n\t\t\t\tnext=now->chs[sts[j][i]-'a'];\n\t\t\t}\n\n\t\t\tnow=next;\n\n\t\t}\n\t\tnow->valid=j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor(int i=0;i<26;++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r=afront->fail;\n\n\t\t\t\t\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod=1e9+7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif(!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto&& nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  void init()\n  {\n    exist = accept = 0;\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nTrieNode nodes[600];\n\nstruct Trie\n{\n  int ptr;\n\n  Trie()\n  {\n    nodes[0].init();\n    ptr = 1;\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[ptr].init();\n        nodes[node_index].nxt[c] = ptr++;\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return (ptr);\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nmap< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 250;\nconst int NODE=100;\nvector<int> redge[N];\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n/*\nint dp[101][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,len+1)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len+1){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\n\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n  }\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len][i][j][1])%mod;\n  return ret;\n}\n*/\n\n\nconst int MOD=30;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      redge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n      redge[tt].push_back(tf);\n    }\n    rep(i,m)cin>>kigo[i];\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].emplace_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].emplace_back(i);\n\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t\tdp[m].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[501];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length <= word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& from = it->first;\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n\t}\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    vector<pair<string,string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects.push_back(pair<string,string>(from,to));\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[600];\n\n    //init\n    for(int connect_idx=0; connect_idx < connect_dic_size; connect_idx++){\n      sm->set_state(start.id);\n      const string& from = connects[connect_idx].first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int connect_idx=0; connect_idx < connect_dic_size; connect_idx++){\n\t    const string& from = connects[connect_idx].first;\n\t    const string& to = connects[connect_idx].second;\n\t    \n\t    if(from == prev_state_it->first.last_word){\n\t      sm->set_state(prev_state_it->first.last_node_address);\n\t      AhoCorasick::MatchingResult mr = sm->feed(to);\n\t      \n\t      if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t      //last_word,season_count,last_node\n\t      State next(to, \n\t\t\t prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t mr.id);\n\t      \n\t      // cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t      \n\t      dp[prev_word_length + to.size()][next]\n\t\t+= dp[prev_word_length][prev_state_it->first] % MOD;\n\t      dp[prev_word_length + to.size()][next] %= MOD;\n\t    }\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n    inline int size() const { return v.size(); }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(128), fail(NULL) {}\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 128; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 128; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            que.push(np);\n\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\nstruct State{\n    int i, k, s;\n    State(int i, int k, int s) :\n        i(i), k(k), s(s) {}\n    bool operator < (const State& st) const {\n        if(i != st.i) return i < st.i;\n        if(k != st.k) return k < st.k;\n        return s < st.s;\n    }\n};\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        map<State, int> dp[501];\n        for(int i = 0; i < idm.size(); i++){\n            string bs = idm.get(i);\n            pair<int, int> pi = match(root, bs);\n            if(bs.length() <= M && pi.second < 2){\n                update(dp[ bs.length() ][ State(i, pi.first, pi.second) ], 1);\n            }\n        }\n\n        for(int l = 0; l < M; l++){\n            for(auto& p : dp[l]){\n                int i = p.first.i, k = p.first.k, s = p.first.s;\n                for(auto ni : next[i]){\n                    string str = idm.get(ni);\n                    pair<int, int> pi = match(nodes[k], str);\n                    if(l + str.size() <= M && s + pi.second <= 1){\n                        update(dp[l + str.size()][ State(ni, pi.first, s + pi.second) ], p.second);\n                    }\n                }\n            }\n            dp[l].clear();\n        }\n\n        int ans = 0;\n        for(auto& p : dp[M]){\n            if(p.first.s == 1){\n                update(ans, p.second);\n            }\n        }\n        cout << ans << endl;\n\n        for(auto p : nodes) delete p;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      //edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    /*\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    */\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nunordered_map<string,int> dp[501][251][2];\nunordered_map<string,int> S;\n\nint N,M,K;\nvector<int> G[255];\nstring Sm[255];\nstring Sk[55];\n\nvoid init(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<=M;j++){\n      dp[i][j][0].clear();\n      dp[i][j][1].clear();\n    }\n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\nint check(string &s){\n  int cnt = 0;\n  string ret = \"!\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"!\" ) ret = Sk[i].substr(0,ss.size());\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  if( ret == \"!\" ) s=\"\";\n  else  s = ret;\n  return cnt;\n}\nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  if( dp[n][m][cnt].count(str) != 0 ) return dp[n][m][cnt][str];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n     return dp[n][m][cnt][str] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    int nct = cnt + check(rs);\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n\n  // cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[n][m][cnt][str] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n \n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      int cnt = check(rs);\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[621];\nvector<int> to[500];\nstring str[500];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tmap<string,int> id;\t\n\t\tfor(int i=0;i<621;i++)dp[i].clear();\n\t\tfor(int i=0;i<500;i++)to[i].clear(),str[i].clear();\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tint len=i+str[dest].size();\n\t\t\t\t\t\tmap<S,int>::iterator it2=dp[len].find(t);\n\t\t\t\t\t\tif(it2==dp[len].end())it2=dp[len].insert(make_pair(t,0)).first;\n\t\t\t\t\t\tADD(it2->second,it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <vector>\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint add_name(const std::string &s){\n\t\treturn (*this)[s];\n\t}\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n\tconst std::string &operator[](size_t i) const {\n\t\treturn m_inv_table[i];\n\t}\n\tsize_t size() const { return m_inv_table.size(); }\n};\n}\nnamespace lc {\ntemplate <int MAX_CODE = std::numeric_limits<char>::max()>\nclass AhoCorasick {\nprivate:\n\tstruct State {\n\t\tint next[MAX_CODE + 1];\n\t\tint failure;\n\t\tstd::vector<int> accept;\n\t\tState() : failure(0), accept() {\n\t\t\tstd::fill(next, next + MAX_CODE + 1, -1);\n\t\t}\n\t};\n\tstd::vector<State> m_states;\n\ttemplate <class Iterator>\n\tvoid construct_trie(Iterator first, Iterator last){\n\t\tm_states.emplace_back();\n\t\tint i = 0;\n\t\tfor(Iterator it = first; it != last; ++it, ++i){\n\t\t\tint cur = 0;\n\t\t\tfor(const int c : *it){\n\t\t\t\tif(m_states[cur].next[c] < 0){\n\t\t\t\t\tm_states[cur].next[c] = m_states.size();\n\t\t\t\t\tm_states.emplace_back();\n\t\t\t\t}\n\t\t\t\tcur = m_states[cur].next[c];\n\t\t\t}\n\t\t\tm_states[cur].accept.push_back(i);\n\t\t}\n\t}\n\tvoid write_failure_links(){\n\t\tstd::queue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int index = q.front();\n\t\t\tq.pop();\n\t\t\tconst State &s = m_states[index];\n\t\t\tfor(int i = 0; i <= MAX_CODE; ++i){\n\t\t\t\tconst int next = s.next[i];\n\t\t\t\tif(next < 0){ continue; }\n\t\t\t\tq.push(next);\n\t\t\t\tif(index == 0){ continue; }\n\t\t\t\tint f = s.failure;\n\t\t\t\twhile(f != 0 && m_states[f].next[i] < 0){\n\t\t\t\t\tf = m_states[f].failure;\n\t\t\t\t}\n\t\t\t\tconst int failure = std::max(0, m_states[f].next[i]);\n\t\t\t\tm_states[next].failure = failure;\n\t\t\t\tconst auto &accept = m_states[failure].accept;\n\t\t\t\tstd::copy(\n\t\t\t\t\taccept.begin(), accept.end(),\n\t\t\t\t\tstd::back_inserter(m_states[next].accept));\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tAhoCorasick()\n\t\t: m_states(1)\n\t{ }\n\ttemplate <class Iterator>\n\tAhoCorasick(Iterator first, Iterator last)\n\t\t: m_states()\n\t{\n\t\tconstruct_trie(first, last);\n\t\twrite_failure_links();\n\t}\n\tstd::pair<int, const std::vector<int> &> iterate(int c, int s) const {\n\t\twhile(s != 0 && m_states[s].next[c] < 0){ s = m_states[s].failure; }\n\t\ts = std::max(0, m_states[s].next[c]);\n\t\treturn std::pair<int, const std::vector<int> &>(s, m_states[s].accept);\n\t}\n\tsize_t size() const {\n\t\treturn m_states.size();\n\t}\n};\n}\nusing namespace std;\ntypedef lc::AhoCorasick<'z'> AhoCorasick;\nstatic const int MOD = 1000000007;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, k;\n\t\tcin >> n >> m >> k;\n\t\tif(n == 0 && m == 0 && k == 0){ break; }\n\t\tvector< vector<int> > next_words(2 * n + 1);\n\t\tlc::NameTable words;\n\t\twords.add_name(\"\");\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tconst int from_key = words[from], to_key = words[to];\n\t\t\tnext_words[from_key].push_back(to_key);\n\t\t}\n\t\tfor(size_t i = 1; i < words.size(); ++i){\n\t\t\tnext_words[0].push_back(i);\n\t\t}\n\t\tvector<string> season_words(k);\n\t\tfor(int i = 0; i < k; ++i){ cin >> season_words[i]; }\n\t\tAhoCorasick ac(season_words.begin(), season_words.end());\n\t\tmap<int, int> dp[21][501][2];\n\t\tdp[0][0][0].insert(make_pair(0, 1));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(size_t j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int f = 0; f < 2; ++f){\n\t\t\t\t\tfor(const auto &p : dp[i % 21][j][f]){\n\t\t\t\t\t\tfor(const int next : next_words[j]){\n\t\t\t\t\t\t\tconst string &word = words[next];\n\t\t\t\t\t\t\tif(static_cast<int>(i + word.size()) > m){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint state = p.first, sum = f;\n\t\t\t\t\t\t\tfor(const char c : word){\n\t\t\t\t\t\t\t\tconst auto res = ac.iterate(c, state);\n\t\t\t\t\t\t\t\tstate = res.first;\n\t\t\t\t\t\t\t\tsum += res.second.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(sum >= 2){ continue; }\n\t\t\t\t\t\t\tconst int rot = (i + word.size()) % 21;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] += p.second;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][f].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(size_t i = 0; i < words.size(); ++i){\n\t\t\tfor(size_t j = 0; j < ac.size(); ++j){\n\t\t\t\tanswer += dp[m % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nshort wnxt[601][605];\nshort wcnt[601][605];\nvector<P> vec[255];\nvector<short> v2[605][605];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tif(ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j])cnt[i]++;\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=1;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tfor(int i=0;i<vs2.size();i++){\n\t\tint v=lower_bound(vs.begin(),vs.end(),vs2[i])-vs.begin();\n\t\tif(v==vs.size() || vs[v]!=vs2[i]){\n\t\t\tif(vs2[i].size()==m && wcnt[i][0]==1)ans++;\n\t\t}\n\t}\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2 || nl==0)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=27;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=601;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nchar ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(l,pmasize){\n\t  rep(m,2){\n\t    if (dp[i%MOD][j][l][m] == 0)continue;\n\t    rep(k,(int)edge[j].size()){\n\t      int readword=edge[j][k];\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    //cout << P.size() << endl;\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[521];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tfor(int i=1;i<=m;i++)dp[i].clear();\n\t\tvector<int> to[250];\n\t\tstring str[250];\n\t\tmap<string,int> id;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tADD(dp[i+str[dest].size()][t],it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nint wnxt[601][605];\nint wcnt[601][605];\nvector<P> vec[255];\nvector<int> v2[605][605];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][255][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nmap< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\ntemplate<int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<int> nxt,idxs;\n    int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,int x){\n    int pos=0;\n    for(int i=0;i<(int)s.size();i++){\n      int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  int find(const string &s){\n    int pos=0;\n    for(int i=0;i<(int)s.size();i++){\n      int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  int find(int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  int idx(int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<int> idxs(int pos){\n    return pos<0?vector<int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    int n=v.size();\n    cnt.resize(n);\n    for(int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<int> q;\n    for(int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tint fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<int> match(string s,int heavy=true){\n    auto &v=TRIE::v;\n    vector<int> res(heavy?TRIE::size():1);\n    int pos=0;\n    for(auto &c:s){\n      int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  int move(int pos,char c){\n    auto &v=TRIE::v;\n    int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n//END CUT HERE\n\n//INSERT ABOVE HERE\ntemplate<typename T> void chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T> void chmax(T &a,T b){if(a<b) a=b;}\n\nsigned TENKA12016_C(){\n  string s;\n  cin>>s;\n  int m;\n  cin>>m;\n  vector<string> p(m);\n  for(int i=0;i<m;i++) cin>>p[i];\n  \n  vector<int> w(m);\n  for(int i=0;i<m;i++) cin>>w[i];\n\n  Trie<27>::F f=[](char c){return c-'a';};\n  AhoCorasick<26> aho(f);\n\n  for(int i=0;i<m;i++) aho.add(p[i],i);\n  aho.build(false);\n  \n  int n=s.size();\n  vector<int> dp(n+1,0);\n  int ans=0;\n  for(int i=0;i<n;i++){\n    chmax(ans,dp[i]);\n    int pos=0;\n    for(int j=0;j<222&&i+j<n;j++){\n      pos=aho.move(pos,s[i+j]);\n      if(pos<0) break;\n      int k=aho.idx(pos);\n      if(~k) chmax(dp[i+j+1],ans+w[k]);\n    }\n  }\n  chmax(ans,dp[n]);\n  cout<<ans<<endl;\n  return 0;\n}\n\n/*\n  verified on 2018/05/20\n  https://beta.atcoder.jp/contests/tenka1-2016-final/tasks/tenka1_2016_final_c\n*/\n\nsigned dp[2][2][501][21][601];\nbool used[2][2][501][21][601];\nsigned AOJ_2257(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) goto END;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) goto END;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/05/20\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2257\n*/\n\nsigned main(){\n  //TENKA12016_C();\n  AOJ_2257();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\ntemplate<int char_size, int margin>\nstruct Trie {\n    struct Node {\n        vector<int> next, accept;\n        Node() : next(char_size, -1) {}\n    };\n\n    vector<Node> nodes;\n    int root;\n    Trie() : root(0) { nodes.push_back(Node()); }\n\n    inline Node operator[](int k) const { return nodes[k]; }\n    inline Node& operator[](int k) { return nodes[k]; }\n\n    inline int size() const { return nodes.size(); }\n\n    void add(const string& s, int id = 0) {\n        int now = root;\n        for (char c : s) {\n            if (nodes[now].next[c - margin] == -1) {\n                nodes[now].next[c - margin] = nodes.size();\n                nodes.push_back(Node());\n            }\n            now = nodes[now].next[c - margin];\n        }\n        nodes[now].accept.push_back(id);\n    }\n\n    friend ostream& operator<<(ostream& os, const Trie& trie) {\n        function<void(int)> dfs = [&](int now) {\n            os << \"{\";\n            bool a = 0;\n            for (int i = 0; i < char_size; ++i) {\n                int nxt = trie[now].next[i];\n                if (nxt != -1) {\n                    if (a) os << \", \"; a = 1;\n                    os << (char)(i + margin) << \": \";\n                    dfs(nxt);\n                }\n            }\n            os << \"}\";\n        };\n        dfs(trie.root);\n        return os;\n    }\n\n};\n\ntemplate<int char_size, int margin>\nstruct AhoCorasick {\n    Trie<char_size + 1, margin> trie;\n    const int FAIL = char_size;\n\n    AhoCorasick() : trie() {}\n\n    using Node = typename Trie<char_size + 1, margin>::Node;\n\n    inline Node operator[](int k) const { return trie[k]; }\n    inline Node& operator[](int k) { return trie[k]; }\n\n    inline int size() const { return trie.size(); }\n    inline int root() const { return trie.root; }\n\n    void add(const string& s, int id = 0) {\n        trie.add(s, id);\n    }\n\n    void build() {\n        queue<int> que;\n        for (int i = 0; i < char_size; ++i) {\n            if (trie[trie.root].next[i] == -1) {\n                trie[trie.root].next[i] = trie.root;\n            } else {\n                que.push(trie[trie.root].next[i]);\n                trie[trie[trie.root].next[i]].next[FAIL] = trie.root;\n            }\n        }\n        while (!que.empty()) {\n            int now = que.front(); que.pop();\n            for (int i = 0; i < char_size; ++i) {\n                if (trie[now].next[i] == -1) continue;\n                int fail = trie[now].next[FAIL];\n                while (trie[fail].next[i] == -1) {\n                    fail = trie[fail].next[FAIL];\n                }\n                trie[trie[now].next[i]].next[FAIL] = trie[fail].next[i];\n                auto &u = trie[trie[now].next[i]].accept;\n                auto &v = trie[trie[fail].next[i]].accept;\n                vector<int> accept;\n                set_union(u.begin(), u.end(), v.begin(), v.end(),\n                        back_inserter(accept));\n                u = accept;\n                que.push(trie[now].next[i]);\n            }\n        }\n    }\n\n    map<int,int> match(const string& str) const {\n        map<int,int> ret;\n        int now = trie.root;\n        for (char c : str) {\n            while (trie[now].next[c - margin] == -1) now = trie[now].next[FAIL];\n            now = trie[now].next[c - margin];\n            for (int id : trie[now].accept) ++ret[id];\n        }\n        return ret;\n    }\n\n    friend ostream& operator<<(ostream& os, const AhoCorasick& aho) {\n        const int n = aho.size();\n        vector<bool> used(n);\n        function<void(int)> dfs = [&](int now) {\n            used[now] = true;\n            os << \"{\" << now << \" \" << \"#:\" << aho[now].next[aho.FAIL];\n            for (int i = 0; i < char_size; ++i) {\n                int nxt = aho[now].next[i];\n                if (nxt != -1) {\n                    os << \", \" << (char)(i + margin) << \":\";\n                    if (!used[nxt]) dfs(nxt);\n                    else os << nxt;\n                }\n            }\n\n            os << \"}\";\n        };\n        dfs(aho.trie.root);\n        return os;\n    }\n};\n\nconst int64_t MOD = 1e9+7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    using Int = modint<MOD>;\n\n    while (true) {\n        int N, M, K; cin >> N >> M >> K;\n        if (N == 0) break;\n        map<string,int> str_ord;\n        map<string,vector<string>> conn;\n        for (int i = 0; i < N; ++i) {\n            string from, to;\n            cin >> from >> to;\n            conn[from].push_back(to);\n            str_ord[from] = str_ord[to] = -1;\n        }\n        for (const auto& tp : str_ord) {\n            conn[\"\"].push_back(tp.first);\n        }\n        str_ord[\"\"] = -1;\n        int cnt = 0;\n        for (auto& tp : str_ord) {\n            tp.second = cnt++;\n        }\n        vector<string> strs;\n        for (const auto& tp : str_ord) {\n            strs.push_back(tp.first);\n        }\n\n        AhoCorasick<26,'a'> aho;\n        for (int i = 0; i < K; ++i) {\n            string sw; cin >> sw;\n            aho.add(sw, i);\n        }\n        aho.build();\n\n        auto dp = make_v<map<int,map<int,Int>>>(2, M+1);\n        dp[0][0][0][aho.root()] = 1;\n        for (int k : { 0, 1 }) {\n            for (int i = 0; i < M; ++i) {\n                for (const auto& tp : dp[k][i]) {\n                    int j = tp.first;\n                    for (const auto& ttp : dp[k][i][j]) {\n                        int s = ttp.first;\n                        for (const string& to : conn[strs[j]]) {\n                            if (i + to.size() > M) continue;\n                            int now = s, match = 0;\n                            for (char c : to) {\n                                while (aho[now].next[c - 'a'] == -1) now = aho[now].next[aho.FAIL];\n                                now = aho[now].next[c - 'a'];\n                                for (int id : aho[now].accept) ++match;\n                            }\n                            if (k + match > 1) continue;\n                            dp[k + match][i + to.size()][str_ord[to]][now] += dp[k][i][j][s];\n                        }\n                    }\n                }\n            }\n        }\n\n        Int ans = 0;\n        for (const auto& tp : dp[1][M]) {\n            int j = tp.first;\n            for (const auto& ttp : dp[1][M][j]) {\n                ans += ttp.second;\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    int match_count;\n    long long id;\n    MatchingResult() : match_count(0), id(0){}\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  unordered_map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  AhoCorasick::MatchingResult feed(const string& text){\n    AhoCorasick::MatchingResult matching_result;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      matching_result.match_count += state->get_results().size();\n      index++;\n    }\n    matching_result.id = state->get_id();\n    state = root;\n    return matching_result;\n  }\n};\n\nclass State{\npublic:\n  int last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(0),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(0),seasonword_count(0),last_node_address(_a) {}\n  State(int _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n\n  bool operator==(const State& s) const{\n    return (last_word == s.last_word\n\t    && seasonword_count == s.seasonword_count\n\t    && last_node_address == s.last_node_address);\n  }\n};\n\nnamespace std {\n  template <>\n  struct hash<State>\n  {\n    std::size_t operator()(const State& k) const\n    {\n      using std::size_t;\n      using std::hash;\n      using std::string;\n      \n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n      \n      return ((hash<int>()(k.last_word)\n\t       ^ (hash<int>()(k.seasonword_count) << 1)) >> 1)\n\t^ (hash<ll>()(k.last_node_address) << 1);\n    }\n  };\n};\n\n\nvector<string> words;\nmap<string,int> visited_words;\n\nint word2num(const string& str){\n  if(visited_words.find(str) == visited_words.end()){\n    words.push_back(str);\n    visited_words[str] = words.size() - 1;\n    return words.size() - 1;\n  }\n  return visited_words[str];\n}\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    words.clear();\n    visited_words.clear();\n\n    set<string> seasonwords;\n    vector<int> connects[1000];\n\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      int f_num = word2num(from);\n      int t_num = word2num(to);\n      connects[f_num].push_back(t_num);\n    }\n\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    \n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    unordered_map<State,int> dp[600];\n\n    //init\n    for(int i=0;i<words.size();i++){\n      sm->set_state(start.id);\n      AhoCorasick::MatchingResult mr = sm->feed(words[i]);\n      //last_word,season_count,last_node\n      if(mr.match_count >= 2) continue;\n      dp[words[i].size()][State(i,mr.match_count,mr.id)] = 1;\n    }\n\n    for(int prev_word_length = 0; \n\tprev_word_length < word_limit; \n\tprev_word_length++){\n      unordered_map<State,int>& prev = dp[prev_word_length];\n      for(unordered_map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int to_idx=0;\n\t    to_idx < connects[prev_state_it->first.last_word].size();\n\t    to_idx++){\n\n\t  int next_idx = connects[prev_state_it->first.last_word][to_idx];\n\t  sm->set_state(prev_state_it->first.last_node_address);\n\t  AhoCorasick::MatchingResult mr = sm->feed(words[next_idx]);\n\n\t  if(prev_state_it->first.seasonword_count + mr.match_count >= 2) continue;\n\t  //last_word,season_count,last_node\n\t  State next(next_idx, \n\t\t     prev_state_it->first.seasonword_count + mr.match_count,\n\t\t     mr.id);\n\n\t  dp[prev_word_length + words[next_idx].size()][next]\n\t    += prev_state_it->second % MOD;\n\t  \n\t  dp[prev_word_length + words[next_idx].size()][next] %= MOD;\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    int res = 0;\n\n    unordered_map<State,int>& last_state = dp[word_limit];\n    for(unordered_map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += prev_state_it->second % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//\tch_cnts[now]++;\n//\tfor (auto&& e : g[now]) {\n//\t\tch_cnts[now] += dfs(g, e, ch_cnts);\n//\t}\n//\treturn ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//\tint from;\n//\tint to;\n//\tbool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//\tint max_ch_id = 1;\n//\t{\n//\t\tint max_ch_num = -1;\n//\t\tfor (auto&&e : g[now]) {\n//\t\t\tif (max_ch_num < ch_cnts[e]) {\n//\t\t\t\tmax_ch_num = ch_cnts[e];\n//\t\t\t\tmax_ch_id = e;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (auto e : g[now]) {\n//\t\tbool heavy = (e == max_ch_id);\n//\n//\t\thl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//\t}\n//\treturn;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//\tvector<int>ch_cnts(ro_tree.size());\n//\n//\tdfs(ro_tree, 0, ch_cnts);\n//\n//\tvector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//\tdfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//\tusing C = complex< double >;\n//\n//\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n//\t{\n//\t\tconst int N = (int)F.size();\n//\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n//\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n//\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n//\t\t\tif (i > j) swap(F[i], F[j]);\n//\t\t}\n//\t\tC w, s, t;\n//\t\tfor (int i = 1; i < N; i <<= 1) {\n//\t\t\tfor (int k = 0; k < i; k++) {\n//\t\t\t\tw = polar(1.0, PI / i * k);\n//\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n//\t\t\t\t\ts = F[j + k];\n//\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//\t}\n//\n//\tvector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//\t{\n//\t\tint sz = 1;\n//\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n//\t\tvector< C > F(sz), G(sz);\n//\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n//\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n//\t\tDiscreteFourierTransform(F, false);\n//\t\tDiscreteFourierTransform(G, false);\n//\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n//\t\tDiscreteFourierTransform(F, true);\n//\t\tvector< int > X(A.size() + B.size() - 1);\n//\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//\t\treturn (X);\n//\t}\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr),valid(-1) {\n\n\t}\n\t\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j=0;j<sts.size();++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next=now->chs[sts[j][i]-'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i]-'a']=make_shared<PMA>();\n\t\t\t\tnext=now->chs[sts[j][i]-'a'];\n\t\t\t}\n\n\t\t\tnow=next;\n\n\t\t}\n\t\tnow->valid=j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor(int i=0;i<26;++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r=afront->fail;\n\n\t\t\t\t\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod=1e9+7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif(!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto&& nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (next_kigo <= 1) {\n\n\t\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//\tch_cnts[now]++;\n//\tfor (auto&& e : g[now]) {\n//\t\tch_cnts[now] += dfs(g, e, ch_cnts);\n//\t}\n//\treturn ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//\tint from;\n//\tint to;\n//\tbool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//\tint max_ch_id = 1;\n//\t{\n//\t\tint max_ch_num = -1;\n//\t\tfor (auto&&e : g[now]) {\n//\t\t\tif (max_ch_num < ch_cnts[e]) {\n//\t\t\t\tmax_ch_num = ch_cnts[e];\n//\t\t\t\tmax_ch_id = e;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (auto e : g[now]) {\n//\t\tbool heavy = (e == max_ch_id);\n//\n//\t\thl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//\t}\n//\treturn;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//\tvector<int>ch_cnts(ro_tree.size());\n//\n//\tdfs(ro_tree, 0, ch_cnts);\n//\n//\tvector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//\tdfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//\tusing C = complex< double >;\n//\n//\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n//\t{\n//\t\tconst int N = (int)F.size();\n//\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n//\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n//\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n//\t\t\tif (i > j) swap(F[i], F[j]);\n//\t\t}\n//\t\tC w, s, t;\n//\t\tfor (int i = 1; i < N; i <<= 1) {\n//\t\t\tfor (int k = 0; k < i; k++) {\n//\t\t\t\tw = polar(1.0, PI / i * k);\n//\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n//\t\t\t\t\ts = F[j + k];\n//\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//\t}\n//\n//\tvector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//\t{\n//\t\tint sz = 1;\n//\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n//\t\tvector< C > F(sz), G(sz);\n//\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n//\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n//\t\tDiscreteFourierTransform(F, false);\n//\t\tDiscreteFourierTransform(G, false);\n//\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n//\t\tDiscreteFourierTransform(F, true);\n//\t\tvector< int > X(A.size() + B.size() - 1);\n//\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//\t\treturn (X);\n//\t}\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr),valid(-1) {\n\n\t}\n\t\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j=0;j<sts.size();++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next=now->chs[sts[j][i]-'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i]-'a']=make_shared<PMA>();\n\t\t\t\tnext=now->chs[sts[j][i]-'a'];\n\t\t\t}\n\n\t\t\tnow=next;\n\n\t\t}\n\t\tnow->valid=j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor(int i=0;i<26;++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r=afront->fail;\n\n\t\t\t\t\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod=1e9+7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif(!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][505][22][606];\nInt used[2][2][505][22][606];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    memset(dp,0,sizeof(dp));\n    memset(used,0,sizeof(used));\n    \n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) goto END;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) goto END;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    END:\n      dp[c][f][x][p][pos]=0;\n      used[c][f][x][p][pos]=0;\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nstring words[510];\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\tmemset(fg,0,sizeof(fg));\n\tmemset(ac,0,sizeof(ac));\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\nmap<int,int> dp[510][510][2]; // len ac words state\n\nint main(void){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words[2*i]=from[i];\n\t\trep(i,n) words[2*i+1]=to[i];\n\t\tsort(words,words+2*n);\n\t\tint w=unique(words,words+2*n)-words;\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words,words+w,from[i])-words;\n\t\t\tint ti=lower_bound(words,words+w,to[i])-words;\n\t\t\tgraph[fi].emplace_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].emplace_back(i);\n\n\t\tdp[0][w][0][root]=1LL;\n\t\trep(i,m){\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tif(dp[i][j][l].find(k)==dp[i][j][l].end()) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][nj][nl][nk]+=dp[i][j][l][k];\n\t\t\t\t\tdp[ni][nj][nl][nk]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,w+1)rep(l,2) dp[i][j][l].clear();\n\t\t}\n\t\tint ans=0LL;\n\t\trep(j,w+1)for(auto &i:dp[m][j][1]){\n\t\t\tans+=i.second;\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t\trep(j,w+1)rep(l,2) dp[m][j][l].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <functional>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\n\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    vector<pair<string,string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects.push_back(pair<string,string>(from,to));\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[600];\n\n    //init\n    for(int connect_idx=0; connect_idx < connect_dic_size; connect_idx++){\n      sm->set_state(start.id);\n      const string& from = connects[connect_idx].first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\tfor(int connect_idx=0; connect_idx < connect_dic_size; connect_idx++){\n\t  const string& from = connects[connect_idx].first;\n\t  const string& to = connects[connect_idx].second;\n\t  \n\t  if(from == prev_state_it->first.last_word){\n\t    sm->set_state(prev_state_it->first.last_node_address);\n\t    AhoCorasick::MatchingResult mr = sm->feed(to);\n\t    \n\t    if(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t    //last_word,season_count,last_node\n\t    State next(to, \n\t\t       prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t       mr.id);\n\t    \n\t    // cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t    \n\t    dp[prev_word_length + to.size()][next]\n\t      += dp[prev_word_length][prev_state_it->first] % MOD;\n\t    dp[prev_word_length + to.size()][next] %= MOD;\n\t  }\n\t}\n      }\n      dp[prev_word_length].clear();\n    }\n    \n    int res = 0;\n\n    map<State,int>& last_state = dp[word_limit];\n    for(map<State,int>::iterator prev_state_it = last_state.begin();\n\tprev_state_it != last_state.end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Trie {\n    struct Node {\n        int num; // node number\n        Node *next[27], *fail;\n        int words;\n\n        Node() : words(0) {;}\n        Node(int n) : words(0), num(n) {\n            for(int i=0; i<27; ++i) next[i] = NULL;\n            fail = NULL;\n        }\n    };\n\n    // default constructor\n    Trie() { nodes.clear(); nodes.push_back(new Node(0)); }\n\n    // insert string\n    void insert(const string &s) {\n        Node *cur = nodes[0];\n        for(int i=0; i<s.length(); ++i) {\n            if(cur->next[s[i]-'a'] == NULL) {\n                cur->next[s[i]-'a'] = new Node(nodes.size());\n                nodes.push_back(cur->next[s[i]-'a']);\n            }\n            cur = cur->next[s[i]-'a'];\n        }\n        cur->words += 1;\n    }\n\n    // list of node\n    vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n    Aho_Corasick(const vector<string> &vs) : keys(vs) {\n        _trie = Trie();\n        for(int i=0; i<vs.size(); ++i) _trie.insert(vs[i]);\n        make_failure_link();\n    }\n\n    void make_failure_link() {\n        queue<Trie::Node *> q;\n        Trie::Node *root = _trie.nodes[0];\n        for(int i=0; i<27; ++i) {\n            if(root->next[i]) {\n                root->next[i]->fail = root;\n                q.push(root->next[i]);\n            }else root->next[i] = root;\n        }\n\n        while(!q.empty()) {\n            Trie::Node *t = q.front(); q.pop();\n            for(int i=0; i<27; ++i) {\n                Trie::Node *u = t->next[i];\n                if(u) {\n                    q.push(u);\n                    Trie::Node *r = t->fail;\n                    while(!r->next[i]) r = r->fail;\n                    u->fail = r->next[i];\n                    u->words += u->fail->words;\n                }\n            }\n        }\n    }\n\n    pair<int,int> match(const string &s,int num = 0) {\n        Trie::Node *v = _trie.nodes[num];\n        int ret = 0;\n        for(int i=0; i<s.length(); ++i) {\n            while(!v->next[s[i]-'a']) v = v->fail;\n            v = v->next[s[i]-'a'];\n            if(v->words > 0) ret += v->words;\n        }\n        return make_pair(ret,v->num);\n    }\n\n    void free() {\n        for(int i=0; i<_trie.nodes.size(); ++i)\n            delete _trie.nodes[i];\n    }\n\n    Trie _trie;\n    vector<string> keys;\n};\n\nconst int MAXM = 501;\nconst int MAXS = 20*30+5;\nconst int MAXN = 501;\nconst int mod = 1000000007;\nmap<int,int> dp[21];\npair<int,int> memo[MAXS][MAXN];\n\ninline int encode(int k,int s,int w) { return (s*MAXN+w)*MAXN+k; }\n\nint main() {\n    int n,m,k;\n    while(cin>>n>>m>>k, n|m|k) {\n        string from,to;\n\n        map<string,int> idx;\n        vector<string> ridx;\n        vector<pair<int,int> > e;\n\n        for(int i=0; i<n; ++i) {\n            cin>>from>>to;\n\n            // make index of word\n            if(idx.find(from) == idx.end()) {\n                idx[from] = ridx.size();\n                ridx.push_back(from);\n            }\n            if(idx.find(to) == idx.end()) {\n                idx[to] = ridx.size();\n                ridx.push_back(to);\n            }\n            e.push_back(make_pair(idx[from],idx[to]));\n        }\n\n        vector<vector<int> > edge(idx.size());\n        for(int i=0; i<e.size(); ++i) edge[e[i].first].push_back(e[i].second);\n\n        vector<string> kigo(k);\n        for(int i=0; i<k; ++i) cin>>kigo[i];\n        Aho_Corasick ac(kigo);\n\n        int s = ac._trie.nodes.size();\n\n        for(int i=0; i<s; ++i)\n            for(int j=0; j<ridx.size(); ++j)\n                memo[i][j] = ac.match(ridx[j],i);\n\n        // hoge\n        for(int i=0; i<21; ++i) dp[i].clear();\n        for(int i=0; i<ridx.size(); ++i) {\n            int m = ridx[i].length();\n            pair<int,int> p = ac.match(ridx[i]);\n            dp[m%21][encode(p.first,p.second,i)] = 1;\n        }\n\n        for(int i=0; i<m; ++i) {\n            for(map<int,int>::iterator it = dp[i%21].begin(); it != dp[i%21].end(); ++it) {\n                int key = it->first;\n                int k = key%MAXN, prev = (key/MAXN)%MAXN, s = (key/MAXN)/MAXN,d = it->second;\n\n                for(int j=0; j<edge[prev].size(); ++j) {\n                    int nlen = i+ridx[edge[prev][j]].length();\n                    if(nlen > m) continue;\n\n                    pair<int,int> p = memo[s][edge[prev][j]];\n                    if(k+p.first < 2) {\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] += d;\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] %= mod;\n                    }\n                }\n            }\n            if(i < m) dp[i%21].clear();\n        }\n\n\n        ac.free();\n\n        int ans = 0;\n        for(int i=0; i<ridx.size(); ++i) {\n            for(int j=0; j<MAXS; ++j) {\n                ans += dp[m%21][encode(1,j,i)];\n                ans %= mod;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      //int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      //ini.push_back(tf);\n      //edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n    /*\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    */\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct state{\n  int n,m,f;\n  string str;\n  state(){}\n  state(int n,int m,int f,string str) : n(n),m(m),f(f),str(str){}\n  bool operator<(const state& st) const{\n    if( n == st.n )\n      if( m == st.m )\n\tif( f == st.f )\n\t  return str < st.str;\n\telse\n\t  return f < st.f;\n      else\n\treturn m < st.m;\n    else\n      return n < st.n;\t    \n  }\n};\nunordered_map<string,int> S;\nmap<state,int> dp;\n\nint N,M,K;\nvector<int> G[255];\nstring Sm[255];\nstring Sk[55];\nunordered_map<string,pair<string,int>> mcp;\nvoid init(){\n  mcp.clear();\n  dp.clear();\n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\npair<string,int> check(const string &s){\n  if( mcp.count(s) != 0 ){\n    return mcp[s];\n  }\n  int cnt = 0;\n  string ret = \"\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"\" ) ret = ss;\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  return mcp[s] = {ret,cnt};\n} \nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  if( dp.count( state(n,m,cnt,str) ) != 0 ) return dp[{n,m,cnt,str}];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n    return dp[{n,m,cnt,str}] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    pair<string,int> np = check(rs);\n    int nct = cnt + np.second - check(str).second;\n    rs = np.first;\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n  //    cout << N << \" \" << M << \" \" << K << endl;\n  //cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[{n,m,cnt,str}] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      auto np = check(rs);\n      rs = np.first;\n      int cnt = np.second;\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 250;\nconst int NODE=100;\nvector<int> redge[N];\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n/*\nint dp[101][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,len+1)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len+1){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\n\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n  }\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len][i][j][1])%mod;\n  return ret;\n}\n*/\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      redge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n      redge[tt].push_back(tf);\n    }\n    rep(i,m)cin>>kigo[i];\n//    PMA *root = buildPMA(kigo,m,P);\n  //  makeGraph(all,P);\n    //sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n   // cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(128), fail(NULL) {}\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 128; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 128; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            // add que\n            que.push(np);\n\n            // search failure link\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            // update matching list\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\n// (node id, match count)\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\nstruct State{\n    int i, k, s;\n    State(int i, int k, int s) :\n        i(i), k(k), s(s) {}\n    bool operator < (const State& st) const {\n        if(i != st.i) return i < st.i;\n        if(k != st.k) return k < st.k;\n        return s < st.s;\n    }\n};\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        map<State, int> dp[501];\n        // start\n        for(auto& p : next){\n            string bs = idm.get(p.first);\n            pair<int, int> pi = match(root, bs);\n            if(pi.second < 2){\n                //cout << bs.length() << \" \" << bs << \" \" << pi.first << \" \" << pi.second << endl;\n                update(dp[ bs.length() ][ State(p.first, pi.first, pi.second) ], 1);\n            }\n        }\n\n        // update\n        for(int l = 0; l < M; l++){\n            for(auto& p : dp[l]){\n                int i = p.first.i, k = p.first.k, s = p.first.s;\n                for(auto ni : next[i]){\n                    //cout << l << \" \" << idm.get(i) << \" \" << k << \" \" << s << \" \" << dp[l][i][k][s] << endl;\n\n                    string str = idm.get(ni);\n                    pair<int, int> pi = match(nodes[k], str);\n                    if(l + str.size() <= M && s + pi.second <= 1){\n                        update(dp[l + str.size()][ State(ni, pi.first, s + pi.second) ], p.second);\n                        /*\n                           cout << \"\\t\" << l + str.size() << \" \" << idm.get(ni) << \" \" << pi.first << \" \" << s + pi.second << \" \" << \n                           dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ] << endl;\n                           */\n                    }\n                }\n            }\n            dp[l].clear();\n        }\n\n        int ans = 0;\n        for(auto& p : dp[M]){\n            if(p.first.s == 1){\n                update(ans, p.second);\n            }\n        }\n        cout << ans << endl;\n\n        for(auto p : nodes) delete p;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Trie {\n    struct Node {\n        int num; // node number\n        Node *next[27], *fail;\n        int words;\n\n        Node() : words(0) {;}\n        Node(int n) : words(0), num(n) {\n            for(int i=0; i<27; ++i) next[i] = NULL;\n            fail = NULL;\n        }\n    };\n\n    // default constructor\n    Trie() { nodes.clear(); nodes.push_back(new Node(0)); }\n\n    // insert string\n    void insert(const string &s) {\n        Node *cur = nodes[0];\n        for(int i=0; i<s.length(); ++i) {\n            if(cur->next[s[i]-'a'] == NULL) {\n                cur->next[s[i]-'a'] = new Node(nodes.size());\n                nodes.push_back(cur->next[s[i]-'a']);\n            }\n            cur = cur->next[s[i]-'a'];\n        }\n        cur->words += 1;\n    }\n\n    // list of node\n    vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n    Aho_Corasick(const vector<string> &vs) : keys(vs) {\n        _trie = Trie();\n        for(int i=0; i<vs.size(); ++i) _trie.insert(vs[i]);\n        make_failure_link();\n    }\n\n    void make_failure_link() {\n        queue<Trie::Node *> q;\n        Trie::Node *root = _trie.nodes[0];\n        for(int i=0; i<27; ++i) {\n            if(root->next[i]) {\n                root->next[i]->fail = root;\n                q.push(root->next[i]);\n            }else root->next[i] = root;\n        }\n\n        while(!q.empty()) {\n            Trie::Node *t = q.front(); q.pop();\n            for(int i=0; i<27; ++i) {\n                Trie::Node *u = t->next[i];\n                if(u) {\n                    q.push(u);\n                    Trie::Node *r = t->fail;\n                    while(!r->next[i]) r = r->fail;\n                    u->fail = r->next[i];\n                    u->words += u->fail->words;\n                }\n            }\n        }\n    }\n\n    pair<int,int> match(const string &s,int num = 0) {\n        Trie::Node *v = _trie.nodes[num];\n        int ret = 0;\n        for(int i=0; i<s.length(); ++i) {\n            while(!v->next[s[i]-'a']) v = v->fail;\n            v = v->next[s[i]-'a'];\n            if(v->words > 0) ret += v->words;\n        }\n        return make_pair(ret,v->num);\n    }\n\n    void free() {\n        for(int i=0; i<_trie.nodes.size(); ++i)\n            delete _trie.nodes[i];\n    }\n\n    Trie _trie;\n    vector<string> keys;\n};\n\nconst int MAXM = 501;\nconst int MAXS = 20*30+5;\nconst int MAXN = 501;\nconst int mod = 1000000007;\nmap<int,int> dp[21];\n\ninline int encode(int k,int s,int w) { return (s*MAXN+w)*MAXN+k; }\n\nint main() {\n    int n,m,k;\n    while(cin>>n>>m>>k, n|m|k) {\n        string from,to;\n\n        map<int, vector<int> > edge;\n        map<string,int> idx;\n        vector<string> ridx;\n\n        for(int i=0; i<n; ++i) {\n            cin>>from>>to;\n\n            // make index of word\n            if(idx.find(from) == idx.end()) {\n                idx[from] = ridx.size();\n                ridx.push_back(from);\n            }\n            if(idx.find(to) == idx.end()) {\n                idx[to] = ridx.size();\n                ridx.push_back(to);\n            }\n\n\n            if(edge.find(idx[from]) == edge.end())\n                edge[idx[from]] = vector<int>(1,idx[to]);\n            else\n                edge[idx[from]].push_back(idx[to]);\n        }\n\n        vector<string> kigo(k);\n        for(int i=0; i<k; ++i) cin>>kigo[i];\n        Aho_Corasick ac(kigo);\n\n        int s = ac._trie.nodes.size();\n\n        // hoge\n        for(int i=0; i<21; ++i) dp[i].clear();\n        for(int i=0; i<ridx.size(); ++i) {\n            int m = ridx[i].length();\n            pair<int,int> p = ac.match(ridx[i]);\n            dp[m%21][encode(p.first,p.second,i)] = 1;\n        }\n\n        for(int i=0; i<=m; ++i) {\n            for(map<int,int>::iterator it = dp[i%21].begin(); it != dp[i%21].end(); ++it) {\n                int key = it->first;\n                int k = key%MAXN, prev = (key/MAXN)%MAXN, s = (key/MAXN)/MAXN,d = it->second;\n\n                for(int j=0; j<edge[prev].size(); ++j) {\n                    int nlen = i+ridx[edge[prev][j]].length();\n                    if(nlen > m) continue;\n\n                    pair<int,int> p = ac.match(ridx[edge[prev][j]],s);\n                    if(k+p.first < 2) {\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] += d;\n                        dp[nlen%21][encode(k+p.first,p.second,edge[prev][j])] %= mod;\n                    }\n                }\n            }\n            if(i < m) dp[i%21].clear();\n        }\n\n\n        ac.free();\n\n        int ans = 0;\n        for(int i=0; i<ridx.size(); ++i) {\n            for(int j=0; j<MAXS; ++j) {\n                ans += dp[m%21][encode(1,j,i)];\n                ans %= mod;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int X>\nstruct Trie{\n  struct Node{\n    char c;\n    vector<Int> nxt,idxs;\n    Int idx;\n    Node(char c):c(c),nxt(X,-1),idx(-1){}\n  };\n\n  using F = function<Int(char)>;\n  vector<Node> v;\n  F conv;\n  \n  Trie(F conv,char c='$'):conv(conv){v.emplace_back(c);}\n\n  void add(const string &s,Int x){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(~v[pos].nxt[k]){\n\tpos=v[pos].nxt[k];\n\tcontinue;\n      }\n      Int npos=v.size();\n      v[pos].nxt[k]=npos;\n      v.emplace_back(s[i]);\n      pos=npos;\n    }\n    v[pos].idx=x;\n    v[pos].idxs.emplace_back(x);\n  }\n\n  Int find(const string &s){\n    Int pos=0;\n    for(Int i=0;i<(Int)s.size();i++){\n      Int k=conv(s[i]);\n      if(v[pos].nxt[k]<0) return -1;\n      pos=v[pos].nxt[k];\n    }\n    return pos;\n  }\n  \n  Int find(Int pos,char c){\n    return v[pos].nxt[conv(c)];\n  }\n\n  Int idx(Int pos){\n    return pos<0?-1:v[pos].idx;\n  }\n  \n  vector<Int> idxs(Int pos){\n    return pos<0?vector<Int>():v[pos].idxs;\n  }\n  \n};\n\ntemplate<Int X>\nstruct AhoCorasick : Trie<X+1>{\n  using TRIE = Trie<X+1>;\n  using TRIE::TRIE;\n  vector<Int> cnt;\n\n  void build(bool heavy=true){\n    auto &v=TRIE::v;\n    Int n=v.size();\n    cnt.resize(n);\n    for(Int i=0;i<n;i++) cnt[i]=v[i].idxs.size();\n    \n    queue<Int> q;\n    for(Int i=0;i<X;i++){\n      if(~v[0].nxt[i]){\n\tv[v[0].nxt[i]].nxt[X]=0;\n\tq.emplace(v[0].nxt[i]);\n      }else{\n\tv[0].nxt[i]=0;\n      }      \n    }\n\n    while(!q.empty()){\n      auto &x=v[q.front()];\n      cnt[q.front()]+=cnt[x.nxt[X]];\n      q.pop();\n      for(Int i=0;i<X;i++){\n\tif(x.nxt[i]<0) continue;\n\tInt fail=x.nxt[X];\n\twhile(v[fail].nxt[i]<0) fail=v[fail].nxt[X];\n\tv[x.nxt[i]].nxt[X]=v[fail].nxt[i];\n\tif(heavy){\n\t  auto &idx=v[x.nxt[i]].idxs;\n\t  auto &idy=v[v[fail].nxt[i]].idxs;\n\t  vector<Int> idz;\n\t  set_union(idx.begin(),idx.end(),\n\t\t    idy.begin(),idy.end(),\n\t\t    back_inserter(idz));\n\t  idx=idz;\n\t}\n\tq.emplace(x.nxt[i]);\n      }\n    }\n  }\n\n  vector<Int> match(string s,Int heavy=true){\n    auto &v=TRIE::v;\n    vector<Int> res(heavy?TRIE::size():1);\n    Int pos=0;\n    for(auto &c:s){\n      Int k=TRIE::conv(c);\n      while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n      pos=v[pos].nxt[k];\n      if(heavy) for(auto &x:v[pos].idxs) res[x]++;\n      else res[0]+=cnt[pos];\n    }\n    return res;\n  }\n\n  Int move(Int pos,char c){\n    auto &v=TRIE::v;\n    Int k=TRIE::conv(c);\n    while(v[pos].nxt[k]<0) pos=v[pos].nxt[X];\n    pos=v[pos].nxt[k];\n    return pos;\n  }\n  \n};\n\n\n//INSERT ABOVE HERE\nInt dp[2][2][505][22][606];\nInt used[2][2][505][22][606];\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    vector<string> from(n),to(n);\n    for(Int i=0;i<n;i++) cin>>from[i]>>to[i];\n    vector<string> season(k);\n    for(Int i=0;i<k;i++) cin>>season[i];\n\n    Trie<27>::F f=[](char c){return c-'a';};\n    AhoCorasick<26> aho(f);\n    for(Int i=0;i<k;i++) aho.add(season[i],i);\n    aho.build();\n    Int l=aho.v.size();\n    \n    vector<string> v;\n    for(Int i=0;i<n;i++){\n      v.emplace_back(from[i]);\n      v.emplace_back(to[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    map<string, Int> idx;\n    for(Int i=0;i<(Int)v.size();i++) idx[v[i]]=i;\n\n    vector<vector<Int> > G(v.size());\n    for(Int i=0;i<n;i++)\n      G[idx[from[i]]].emplace_back(idx[to[i]]);\n\n    const Int MOD = 1e9+7;\n    memset(dp,0,sizeof(dp));\n    using T = tuple<Int, Int, Int, Int, Int>;\n    queue<T> q;\n    for(Int i=0;i<(Int)v.size();i++){\n      dp[0][0][i][0][0]=1;\n      q.emplace(0,0,i,0,0);\n    }\n    \n    auto mfill=[&](Int f){\n      for(Int i=0;i<2;i++)\n\tfor(Int j=0;j<505;j++)\n\t  for(Int k=0;k<22;k++)\n\t    for(Int l=0;l<606;l++)\n\t      dp[i][f][j][k][l]=used[i][f][j][k][l]=0;\n    };\n    \n    Int pre=-1;\n    while(!q.empty()){\n      Int c,d,x,p,pos;\n      tie(c,d,x,p,pos)=q.front();q.pop();      \n      if(d==m) break;\n      Int f=d&1;\n      if(pre!=d){\n\tmfill(!f);\n\tpre=d;\n      }\n     \n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<p<<\" \"<<pos<<endl;\n      //cout<<v[x]<<\":\"<<dp[c][f][x][p][pos]<<endl;\n      \n      if(p==(Int)v[x].size()){\n\tfor(Int y:G[x]){\n\t  Int npos=aho.move(pos,v[y][0]);\n\t  if(aho.cnt[npos]>1) continue;\n\t  Int nc=aho.cnt[npos];\n\t  if(c&&nc) continue;\n\t  dp[c||nc][!f][y][1][npos]+=dp[c][f][x][p][pos];\n\t  dp[c||nc][!f][y][1][npos]%=MOD;\n\t  if(!used[c||nc][!f][y][1][npos])\n\t    q.emplace((c||nc),d+1,y,1,npos);\n\t  used[c||nc][!f][y][1][npos]=1;\n\t}\n      }else{\n\tInt npos=aho.move(pos,v[x][p]);\n\tInt np=p+1;\n\tif(aho.cnt[npos]>1) continue;\n\tInt nc=aho.cnt[npos];\n\tif(c&&nc) continue;\n\tdp[c||nc][!f][x][np][npos]+=dp[c][f][x][p][pos];\n\tdp[c||nc][!f][x][np][npos]%=MOD;\n\tif(!used[c||nc][!f][x][np][npos])\n\t  q.emplace((c||nc),d+1,x,np,npos);\n\tused[c||nc][!f][x][np][npos]=1;\n      }\n    }\n    Int ans=0;\n    for(Int i=0;i<(Int)v.size();i++){\n      for(Int j=0;j<l;j++){\n\tans+=dp[1][m&1][i][v[i].size()][j];\n\tans%=MOD;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nint wnxt[601][605];\nint wcnt[601][605];\nvector<P> vec[255];\nvector<int> v2[605][605];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=0;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst ll MOD = 1e9+7;\n\nstruct Node {\n    string suffix;\n    vector<int> accept;\n    map<char,Node*> next;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    Node* addNode() {\n        Node* node = new Node();\n        node->next[failure] = root;\n\n        return node;\n    }\n\n    void build(vector<string> vstr) {\n        for (int i = 0, vlen = vstr.size(); i < vlen; i++) {\n            Node* now = root;\n            string tmp;\n            for (auto c : vstr[i]) {\n                if (now->next.find(c) == now->next.end())\n                    now->next[c] = addNode();\n                now = now->next[c];\n                tmp += c;\n                now->suffix = tmp;\n            }\n            now->accept.push_back(i);\n        }\n\n        queue<Node*> que;\n\n        const string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto c : symbol_array) {\n            if (root->next.find(c) != root->next.end()) {\n                root->next[c]->next[failure] = root;\n                que.push(root->next[c]);\n            } else {\n                root->next[c] = root;\n            }\n        }\n\n        while (!que.empty()) {\n            Node* node = que.front(); que.pop();\n            for (auto p : node->next) {\n\n                char c = p.first; // i\n                Node* now = p.second; // now->next[i]\n\n                if (c == failure) {\n                    continue;\n                }\n\n                que.push(now);\n\n                Node* rev = node->next[failure];\n                while (rev->next.find(c) == rev->next.end())\n                    rev = rev->next[failure];\n                now->next[failure] = rev->next[c];\n\n                vector<int> acc;\n                set_union(now->accept.begin(),\n                          now->accept.end(),\n                          rev->next[c]->accept.begin(),\n                          rev->next[c]->accept.end(),\n                          back_inserter(acc));\n                now->accept = acc;\n            }\n        }\n    }\n\n    int match(string str, Node* now, vector<int>& result) {\n        int len = str.size();\n        int count = 0;\n\n        for (auto c  : str) {\n            while (now->next.find(c) == now->next.end()) now = now->next[failure];\n            now = now->next[c];\n\n            for (auto ac : now->accept) {\n                result[ac]++;\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto c : str) {\n            while (now->next.find(c) == now->next.end())\n                now = now->next[failure];\n            now = now->next[c];\n\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,ll> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        // dp[0][0][0][pma.getRoot()] = 1LL;\n\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (from[i].size() > M || count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1LL;\n        }\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(to[i], now, count);\n            if (to[i].size() > M || count > 1) continue;\n            dp[to[i].size()][ston[to[i]]][count][now] = 1LL;\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            ll num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        ll ans = 0LL;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nconstexpr int mod = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, k; cin >> n >> m >> k;\n        if (n == 0) break;\n        multimap<string, string> conn;\n        repeat (i, n) {\n            string from, to; cin >> from >> to;\n            conn.emplace(from, to);\n        }\n        vector<string> seasonword(k);\n        repeat (i, k) {\n            cin >> seasonword[i];\n        }\n        // solve\n        auto count_seasonwords = [&](string const & s) {\n            int cnt = 0;\n            repeat (i, k) {\n                for (int j = 0; ; ) {\n                    j = s.find(seasonword[i], j);\n                    if (j == string::npos) break;\n                    ++ j;\n                    ++ cnt;\n                    if (cnt >= 2) return cnt;\n                }\n            }\n            return cnt;\n        };\n        int max_seasonword_length = 0;\n        repeat (i, k) {\n            setmax<int>(max_seasonword_length, seasonword[i].length());\n        }\n        auto shrink = [&](string const & s) {\n            return s.length() <= max_seasonword_length ? s : s.substr(s.length() - max_seasonword_length);\n        };\n        vector<string> word;\n        map<string, int> index;\n        for (auto const & it : conn) {\n            for (string s : { it.first, it.second }) {\n                if (not index.count(s)) {\n                    index.emplace(s, index.size());\n                    word.push_back(s);\n                }\n            }\n        }\n        vector<vector<int> > g(word.size());\n        for (auto const & it : conn) {\n            g[index[it.first]].push_back(index[it.second]);\n        }\n        vector<map<tuple<int, bool, string>, int> > dp(m + 1);\n        repeat (i, word.size()) if (word[i].length() <= m) {\n            int season = count_seasonwords(word[i]);\n            if (season >= 2) continue;\n            dp[word[i].length()][make_tuple(i, bool(season), word[i])] += 1;\n        }\n        repeat (l, m) {\n            for (auto const & state : dp[l]) {\n                int i; bool is_season; string s; tie(i, is_season, s) = state.first;\n                int cnt = state.second;\n                int count_seasonwords_s = count_seasonwords(s);\n                for (int j : g[i]) if (l + word[j].length() <= m) {\n                    string t = s + word[j];\n                    int next_season = is_season + count_seasonwords(t) - count_seasonwords_s;\n                    if (next_season >= 2) continue;\n                    int & it = dp[l + word[j].length()][make_tuple(j, bool(next_season), shrink(t))];\n                    it = (it + cnt) % mod;\n                }\n            }\n            dp[l] = map<tuple<int, bool, string>, int>(); // release\n        }\n        // output\n        int result = 0;\n        for (auto const & state : dp[m]) {\n            bool is_season; tie(ignore, is_season, ignore) = state.first;\n            if (not is_season) continue;\n            int cnt = state.second;\n            result = (result + cnt) % mod;\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[MAX_M+1][MAX_ps][MAX_W],b[MAX_M+1][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nint wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,M+1) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,ps){\n\t\t\t\trep(k,ws){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tif(i+words[u].size()<=M) add(a[i+words[u].size()][ne[j][u]][u],b[i][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(i+words[u].size()<=M) add(a[i+words[u].size()][ne[j][u]][u],a[i][j][k]);\n\t\t\t\t\t\t\tif(i+words[u].size()<=M) add(b[i+words[u].size()][ne[j][u]][u],b[i][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t\tif(nl>=2) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tif(dp[m].find(make_tuple(j,k,1))==dp[m].end()) continue;\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n   PMA *root = buildPMA(kigo,m,P);\n//    makeGraph(all,P);\n //   sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 21;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 250;\nconst int NODE=100;\nvector<int> redge[N];\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n/*\nint dp[101][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,len+1)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len+1){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\n\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n  }\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len][i][j][1])%mod;\n  return ret;\n}\n*/\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[30];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      redge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n      redge[tt].push_back(tf);\n    }\n    rep(i,m)cin>>kigo[i];\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\n\ntemplate< int char_size >\nstruct TrieNode {\n  int nxt[char_size];\n\n  int exist;\n  vector< int > accept;\n\n  TrieNode() : exist(0) {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\ntemplate< int char_size, int margin >\nstruct Trie {\n  using Node = TrieNode< char_size >;\n\n  vector< Node > nodes;\n  int root;\n\n  Trie() : root(0) {\n    nodes.push_back(Node());\n  }\n\n  void update_direct(int node, int id) {\n    nodes[node].accept.push_back(id);\n  }\n\n  void update_child(int node, int child, int id) {\n    ++nodes[node].exist;\n  }\n\n  void add(const string &str, int str_index, int node_index, int id) {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - margin;\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(Node());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id) {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str) {\n    add(str, nodes[0].exist);\n  }\n\n  void query(const string &str, const function< void(int) > &f, int str_index, int node_index) {\n    for(auto &idx : nodes[node_index].accept) f(idx);\n    if(str_index == str.size()) {\n      return;\n    } else {\n      const int c = str[str_index] - margin;\n      if(nodes[node_index].nxt[c] == -1) return;\n      query(str, f, str_index + 1, nodes[node_index].nxt[c]);\n    }\n  }\n\n  void query(const string &str, const function< void(int) > &f) {\n    query(str, f, 0, 0);\n  }\n\n  int count() const {\n    return (nodes[0].exist);\n  }\n\n  int size() const {\n    return ((int) nodes.size());\n  }\n};\n\ntemplate< int char_size, int margin >\nstruct AhoCorasick : Trie< char_size + 1, margin > {\n  using Trie< char_size + 1, margin >::Trie;\n\n  const int FAIL = char_size;\n  vector< int > correct;\n\n  void build(bool heavy = true) {\n    correct.resize(this->size());\n    for(int i = 0; i < this->size(); i++) {\n      correct[i] = (int) this->nodes[i].accept.size();\n    }\n    queue< int > que;\n    for(int i = 0; i <= char_size; i++) {\n      if(~this->nodes[0].nxt[i]) {\n        this->nodes[this->nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(this->nodes[0].nxt[i]);\n      } else {\n        this->nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      auto &now = this->nodes[que.front()];\n      int fail = now.nxt[FAIL];\n      correct[que.front()] += correct[fail];\n      que.pop();\n      for(int i = 0; i < char_size; i++) {\n        if(~now.nxt[i]) {\n          this->nodes[now.nxt[i]].nxt[FAIL] = this->nodes[fail].nxt[i];\n          if(heavy) {\n            auto &u = this->nodes[now.nxt[i]].accept;\n            auto &v = this->nodes[this->nodes[fail].nxt[i]].accept;\n            vector< int > accept;\n            set_union(begin(u), end(u), begin(v), end(v), back_inserter(accept));\n            u = accept;\n          }\n          que.emplace(now.nxt[i]);\n        } else {\n          now.nxt[i] = this->nodes[fail].nxt[i];\n        }\n      }\n    }\n  }\n\n  map< int, int > match(const string &str, int now = 0) {\n    map< int, int > result;\n    for(auto &c : str) {\n      now = this->nodes[now].nxt[c - margin];\n      for(auto &v : this->nodes[now].accept) result[v] += 1;\n    }\n    return result;\n  }\n\n  pair< int64_t, int > move(const char &c, int now = 0) {\n    now = this->nodes[now].nxt[c - margin];\n    return {correct[now], now};\n  }\n\n  pair< int64_t, int > move(const string &str, int now = 0) {\n    int64_t sum = 0;\n    for(auto &c : str) {\n      auto nxt = move(c, now);\n      sum += nxt.first;\n      now = nxt.second;\n    }\n    return {sum, now};\n  }\n};\n\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[21][500][2];\n\nint main() {\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    AhoCorasick< 26, 'a' > aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.first > 1) continue;\n      ++dp[nums[i].size()][i][get.first][get.second];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i % 21][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.first > 1) continue;\n              (dp[(i + nums[t].size()) % 21][t][k + get.first][get.second] += v.second) %= mod;\n            }\n          }\n          dp[i % 21][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M % 21][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 0; i < 21; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nstruct Node {\n    string suffix;\n    vector<int> accept;\n    vector<Node*> next;\n};\n\nclass PMA {\nprivate :\n\n    Node* root;\n    const char failure = 0;\npublic :\n    PMA () {\n        root = new Node();\n        root->next.resize(256, nullptr);\n        root->next[failure] = root;\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    Node* addNode() {\n        Node* node = new Node();\n        node->next.resize(256, nullptr);\n        node->next[failure] = root;\n\n        return node;\n    }\n\n    void build(vector<string> vstr) {\n        for (int i = 0, vlen = vstr.size(); i < vlen; i++) {\n            Node* now = root;\n            string tmp;\n            for (auto c : vstr[i]) {\n                if (!now->next[c]) now->next[c] = addNode();\n                now = now->next[c];\n                tmp += c;\n                now->suffix = tmp;\n            }\n            now->accept.push_back(i);\n        }\n\n        queue<Node*> que;\n        const string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto c : symbol_array) {\n            if (root->next[c] != nullptr) {\n                root->next[c]->next[failure] = root;\n                que.push(root->next[c]);\n            } else {\n                root->next[c] = root;\n            }\n        }\n\n        while (!que.empty()) {\n            Node* node = que.front(); que.pop();\n            for (auto c : symbol_array) {\n                auto now = node->next[c];\n                if (now == nullptr) continue;\n                que.push(now);\n\n                Node* rev = node->next[failure];\n                while (rev->next[c] == nullptr) rev = rev->next[failure];\n                now->next[failure] = rev->next[c];\n\n                vector<int> acc;\n                set_union(now->accept.begin(),\n                          now->accept.end(),\n                          rev->next[c]->accept.begin(),\n                          rev->next[c]->accept.end(),\n                          back_inserter(acc));\n                now->accept = acc;\n            }\n        }\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto c : str) {\n            while (now->next[c] == nullptr) now = now->next[failure];\n            now = now->next[c];\n\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,int> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        vector<vector<bool> > flag(M+1, vector<bool>(ston.size(), false));\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (from[i].size() > M || count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1;\n            flag[from[i].size()][ston[from[i]]] = true;\n        }\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(to[i], now, count);\n            if (to[i].size() > M || count > 1) continue;\n            dp[to[i].size()][ston[to[i]]][count][now] = 1;\n            flag[to[i].size()][ston[to[i]]] = true;\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                if (!flag[i][j]) continue;\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            int num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                                flag[i+ntos[nx].size()][nx] = true;\n                            }\n                        }\n                    }\n                    dp[i][j][k].clear();\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\nlong long mod=1000000007;\nchar in[30];\nstring table[600];\nvector<int>g[600];\nstruct wolf{\n\tint chi[26];\n\tint mark;\n\tint par;\n\tint fail;\n\tint var;\n\twolf(){\n\t\tfor(int i=0;i<26;i++)chi[i]=-1;mark=0;\n\t\tpar=fail=var=-1;\n\t}\n};\nwolf node[700];\nint ns;\nvoid add(){\n\tint at=0;\n\tfor(int i=0;in[i];i++){\n\t\tif(node[at].chi[in[i]-'a']==-1){\n\t\t\tnode[at].chi[in[i]-'a']=ns;\n\t\t\tnode[ns].par=at;\n\t\t\tnode[ns].var=in[i]-'a';\n\t\t\tat=ns++;\n\t\t}else{\n\t\t\tat=node[at].chi[in[i]-'a'];\n\t\t}\n\t}\n\tnode[at].mark=1;\n}\nint n;\nvector<int>dp[2][520][520];\nint conv[520][520];\nint cs[520];\nint calc(int a,int b,int c,int d){\n\tif(~dp[d][a][b][conv[b][c]])return dp[d][a][b][conv[b][c]];\n\tif(a==n){\n\t\tif(d==1)return 1;\n\t\telse return 0;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<g[b].size();i++){\n\t\tint to=c;\n\t\tint cnt=d;\n\t\tint use=g[b][i];\n\t\tif(a+table[use].size()>n)continue;\n\t\tfor(int j=0;j<table[use].size();j++){\n\t\t\twhile(1){\n\t\t\t\tif(node[to].chi[table[use][j]-'a']!=-1){\n\t\t\t\t\tto=node[to].chi[table[use][j]-'a'];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(to==0)break;\n\t\t\t\tto=node[to].fail;\n\t\t\t}\n\t\t\tcnt+=node[to].mark;\n\t\t}\n\t\tif(cnt>1)continue;\n\t\tret=(ret+calc(a+table[use].size(),use,to,cnt))%mod;\n\t}\n\t//if(ret)printf(\"%d %d %d %d: %d\\n\",a,b,c,d,ret);\n\treturn dp[d][a][b][conv[b][c]]=ret;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tn=b;\n\t\tmap<string,int> word;\n\t\tfor(int i=0;i<600;i++)g[i].clear();\n\t\tfor(int k=0;k<2;k++)for(int i=0;i<520;i++)for(int j=0;j<520;j++)dp[k][i][j].clear();\n\t\tfor(int i=0;i<520;i++)cs[i]=0;\n\t\tint sz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint P,Q2;\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring p=in;\n\t\t\tif(word.count(p))P=word[p];\n\t\t\telse{\n\t\t\t\tword[p]=sz;\n\t\t\t\ttable[sz]=p;\n\t\t\t\tP=sz++;\n\t\t\t}\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring q=in;\n\t\t\tif(word.count(q))Q2=word[q];\n\t\t\telse{\n\t\t\t\tword[q]=sz;\n\t\t\t\ttable[sz]=q;\n\t\t\t\tQ2=sz++;\n\t\t\t}\n\t\t\tg[P].push_back(Q2);\n\t\t}\n\t\tfor(int i=0;i<700;i++)node[i]=wolf();\n\t\tns=1;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tadd();\n\t\t}\n\t\tqueue<int>Q;\n\t\tQ.push(0);\n\t\twhile(Q.size()){\n\t\t\tint at=Q.front();Q.pop();\n\t\t\tif(at==0||node[at].par==0)node[at].fail=0;\n\t\t\telse{\n\t\t\t\tint to=node[at].par;\n\t\t\t\twhile(1){\n\t\t\t\t\tint tmp=node[to].fail;\n\t\t\t\t\tif(node[tmp].chi[node[at].var]!=-1){\n\t\t\t\t\t\tnode[at].fail=node[tmp].chi[node[at].var];\n\t\t\t\t\t\tnode[at].mark+=node[node[at].fail].mark;break;\n\t\t\t\t\t}\n\t\t\t\t\tto=tmp;\n\t\t\t\t\tif(to==0){node[at].fail=0;break;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<26;i++)if(node[at].chi[i]!=-1){\n\t\t\t\tQ.push(node[at].chi[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<ns;j++){\n\t\t\t\tbool ok=true;\n\t\t\t\tint at=j;\n\t\t\t\tint in=table[i].size()-1;\n\t\t\t\twhile(at&&in>=0){\n\t\t\t\t\tif(node[at].var!=table[i][in]-'a'){ok=false;break;}\n\t\t\t\t\tat=node[at].par;\n\t\t\t\t\tin--;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tconv[i][j]=cs[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<sz;i++)printf(\"%d\\n\",cs[i]);\n\t\tconv[sz][0]=0;cs[sz]=1;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<=b;j++)for(int k=0;k<=sz;k++){\n\t\t\tdp[i][j][k]=vector<int>(cs[k],-1);\n\t\t}\n\t\tfor(int i=0;i<sz;i++)g[sz].push_back(i);\n\t\tint ret=calc(0,sz,0,0);\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 601;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }else move[id][i]=-1,ac[id][i]=-1;\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n    cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\nstatic const int MOD = 1000000007;\n\nnamespace AhoCorasick{\n  class Node;\n  class SearchMachine;\n  struct MatchingResult {\n    map<string,int> rv;\n    long long id;\n  };\n};\n\nclass AhoCorasick::Node {\nprivate:\n  set<string> results;\n  map<char,AhoCorasick::Node*> transitions;\n  vector<AhoCorasick::Node*> v_transitions;\n  char character;\n  AhoCorasick::Node* parent;\n  AhoCorasick::Node* failure;\npublic:\n  Node() : character('\\0'),parent(NULL),failure(NULL){}\n  Node(AhoCorasick::Node* _p,char _c) : parent(_p),character(_c),failure(NULL){}\n  const char get_char() const {\n    return character;\n  }\n  \n  AhoCorasick::Node* get_parent() const{\n    return parent;\n  }\n\n  AhoCorasick::Node* get_failure() const{\n    return failure;\n  }\n\n  void set_failure(AhoCorasick::Node* _n){\n    failure = _n;\n  }\n\n  AhoCorasick::Node* get_transition(const char c){\n    if(transitions.find(c) == transitions.end()) return NULL;\n    return transitions[c];\n  }\n\n  const set<string>& get_results() const{\n    return results;\n  }\n\n  void add_result(const string& str){\n    results.insert(str);\n  }\n\n  void add_transition(AhoCorasick::Node* node){\n    transitions[node->get_char()] = node;\n    v_transitions.push_back(node);\n  }\n\n  long long get_id() const{\n    return reinterpret_cast<long long>(this);\n  }\n\n  const vector<AhoCorasick::Node*>& get_transitions() const{\n    return v_transitions;\n  }\n  \n};\nclass AhoCorasick::SearchMachine{\nprivate:\n  set<string> keywords;\n  AhoCorasick::Node* root;\n  AhoCorasick::Node* state;\npublic:\n  SearchMachine(set<string> _k) : keywords(_k){\n    _build_tree();\n  }\n  SearchMachine(){\n    _build_tree();\n  }\n  void _build_tree(){\n    root = new AhoCorasick::Node();\n    \n    for(set<string>::iterator it = keywords.begin();\n\tit != keywords.end();\n\tit++){\n      AhoCorasick::Node* node = root;\n\n      const string& keyword = *it;\n      for(int i = 0; i < keyword.length(); i++){\n\tAhoCorasick::Node* next_node = node->get_transition(keyword[i]);\n\tif(next_node == NULL){\n\t  next_node = new AhoCorasick::Node(node,keyword[i]);\n\t  node->add_transition(next_node);\n\t}\n\tnode = next_node;\n      }\n      node->add_result(keyword);\n    }\n\n    vector<AhoCorasick::Node*> nodes;\n    for(int i=0;i<root->get_transitions().size();i++){\n      root->get_transitions()[i]->set_failure(root);\n\n      vector<AhoCorasick::Node*> tmp_nodes;\n      tmp_nodes.reserve(nodes.size() + root->get_transitions()[i]->get_transitions().size() + 1); \n      merge(nodes.begin(), nodes.end(),\n\t    root->get_transitions()[i]->get_transitions().begin(), root->get_transitions()[i]->get_transitions().end(),\n\t    back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n      nodes.swap(tmp_nodes);\n    }\n\n    while(nodes.size() > 0){\n      vector<AhoCorasick::Node*> next_nodes;\n      for(int i=0;i<nodes.size();i++){\n\tAhoCorasick::Node* r = nodes[i]->get_parent()->get_failure();\n\tconst char c = nodes[i]->get_char();\n      \n\twhile((r != NULL) && (r->get_transition(c) == NULL)){\n\t  r = r->get_failure();\n\t}\n\n\tif(r == NULL){\n\t  nodes[i]->set_failure(root);\n\t}\n\telse{\n\t  AhoCorasick::Node* tc = r->get_transition(c);\n\t  nodes[i]->set_failure(tc);\n\t  \n\t  set<string> results;\n\t  if(tc != NULL) results = tc->get_results();\n\t  for(set<string>::iterator it = results.begin();\n\t      it != results.end();\n\t      it++){\n\t    nodes[i]->add_result(*it);\n\t  }\n\t}\n\n\tvector<AhoCorasick::Node*> tmp_nodes;\n\ttmp_nodes.reserve(next_nodes.size() + nodes[i]->get_transitions().size() + 1); \n\tmerge(next_nodes.begin(), next_nodes.end(),\n\t      nodes[i]->get_transitions().begin(), nodes[i]->get_transitions().end(),\n\t      back_inserter<vector<AhoCorasick::Node*> >(tmp_nodes));\n\tnext_nodes.swap(tmp_nodes);\n      }\n\n      nodes = next_nodes;\n    }\n\n    root->set_failure(root);\n    state = root;\n  }\n\n  void set_state(AhoCorasick::Node* current){\n    state = current;\n  }\n\n  void set_state(long long current_num){\n    state = reinterpret_cast<AhoCorasick::Node*>(current_num);\n  }\n\n  MatchingResult feed(const string& text){\n    MatchingResult mr;\n    int index = 0;\n    while(index < text.length()){\n      AhoCorasick::Node* trans = NULL;\n      while(state != NULL){\n\ttrans = state->get_transition(text[index]);\n\tif(state == root || trans != NULL) break;\n\tstate = state->get_failure();\n      }\n\n      if(trans != NULL){\n\tstate = trans;\n      }\n      \n      set<string> results;\n      if(state != NULL) results = state->get_results();\n      for(set<string>::iterator it = results.begin();\n\t  it != results.end();\n\t  it++){\n\tmr.rv[*it] = index - it->length() + 1;\n      }\n      index++;\n    }\n    mr.id = state->get_id();\n    state = root;\n    return mr;\n  }\n};\n\n\nclass State{\npublic:\n  const string& last_word;\n  int seasonword_count;\n  ll last_node_address;\n  State() : last_word(\"\"),seasonword_count(0),last_node_address(0) {}\n  State(ll _a) : last_word(\"\"),seasonword_count(0),last_node_address(_a) {}\n  State(const string& _s,int _sc,ll _a) : last_word(_s),seasonword_count(_sc),last_node_address(_a) {}\n\n  bool operator<(const State& s) const{\n    if(last_word == s.last_word){\n      if(seasonword_count == s.seasonword_count){\n\treturn last_node_address < s.last_node_address;\n      }\n      else{\n\treturn seasonword_count < s.seasonword_count;\n      }\n    }\n    else{\n      return last_word < s.last_word;\n    }\n  }\n};\n\nint main(){\n  int connect_dic_size;\n  int word_limit;\n  int total_seasonwords;\n  \n  while(~scanf(\"%d %d %d\",\n\t       &connect_dic_size,\n\t       &word_limit,\n\t       &total_seasonwords)){\n    if(word_limit == 0) break;\n\n    set<string> seasonwords;\n    map<string,vector<string> > connects;\n    for(int i=0;i<connect_dic_size;i++){\n      string from,to;\n      cin >> from >> to;\n      connects[from].push_back(to);\n    }\n    for(int i=0;i<total_seasonwords;i++){\n      string seasonword;\n      cin >> seasonword;\n      seasonwords.insert(seasonword);\n    }\n\n    AhoCorasick::SearchMachine* sm = new AhoCorasick::SearchMachine(seasonwords);\n    AhoCorasick::MatchingResult start = sm->feed(\"\");\n    //dp[word_length][State]\n    map<State,int> dp[600];\n\n    //init\n    for(map<string,vector<string> >::iterator it = connects.begin();\n\tit != connects.end();\n\tit++){\n\n      sm->set_state(start.id);\n      const string& from = it->first;\n      AhoCorasick::MatchingResult mr = sm->feed(from);\n\n      //last_word,season_count,last_node\n      State next(from, \n\t\t mr.rv.size(),\n\t\t mr.id);\n      dp[from.size()][next] = 1;\n    }\n\n\n    for(int prev_word_length = 0; prev_word_length < word_limit; prev_word_length++){\n      map<State,int>& prev = dp[prev_word_length];\n      for(map<State,int>::iterator prev_state_it = prev.begin();\n\t  prev_state_it != prev.end();\n\t  prev_state_it++){\n\n\t  for(map<string,vector<string> >::iterator it = connects.begin();\n\t      it != connects.end();\n\t      it++){\n\t    const string& from = it->first;\n\t    for(int to_idx=0;to_idx < it->second.size(); to_idx++){\n\t      const string& to = it->second[to_idx];\n\n\t      if(from == prev_state_it->first.last_word){\n\t\tsm->set_state(prev_state_it->first.last_node_address);\n\t\tAhoCorasick::MatchingResult mr = sm->feed(to);\n\t\t\n\t\tif(prev_state_it->first.seasonword_count + mr.rv.size() >= 2) continue;\n\t\t//last_word,season_count,last_node\n\t\tState next(to, \n\t\t\t   prev_state_it->first.seasonword_count + mr.rv.size(),\n\t\t\t   mr.id);\n\t\t\n\t\t// cout << \"from:\" << from <<  \" to:\" << to << endl;\n\t\t\n\t\tdp[prev_word_length + to.size()][next]\n\t\t  += dp[prev_word_length][prev_state_it->first] % MOD;\n\t\tdp[prev_word_length + to.size()][next] %= MOD;\n\t      }\n\t    }\n\t  }\n      }\n      dp[prev_word_length].clear();\n    }\n    \n    int res = 0;\n    for(map<State,int>::iterator prev_state_it = dp[word_limit].begin();\n\tprev_state_it != dp[word_limit].end();\n\tprev_state_it++){\n      if(prev_state_it->first.seasonword_count != 1) continue;\n\n      res += dp[word_limit][prev_state_it->first] % MOD;\n      res %= MOD;\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE*60];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\n\nbool solve(){\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n    //debug(ssword);\n  }\n  \n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[501];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    //debug(i);\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n  \n  return true;\n}\n\nint main(){\n  while(solve()){\n    for(int i=0;i<pos_size;i++){\n      free(pos[i]);\n    }\n    pos_size = 0;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nmap< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define MOD 1000000007\n\nclass State\n{\npublic:\n\tint pv,pl,f;\n\tState(int pv, int pl, int f)\n\t\t:pv(pv),pl(pl),f(f)\n\t{}\n\n\tbool operator<(const State& s) const\n\t{\n\t\tif(pv!=s.pv) return pv<s.pv;\n\t\tif(pl!=s.pl) return pl<s.pl;\n\n\t\treturn f<s.f;\n\t}\n};\n\nmap<State, int> dp[25];\nconst int WL = 25;\n//[前につかったやつ(500)][どこまで(500)][PMAどこまで(20)][季語の有無(2)]=数%100000007\nint Psz;\n\nstruct PMA {\n\tint n;\n\tPMA *next[0x100]; // next[0] is for fail\n\tvector<int> accept;\n\tPMA() { fill(next, next+0x100, (PMA*)0); }\n\tPMA(int a)\n\t{\n\t\tn=a;\n\t\tfill(next, next+0x100, (PMA*)0);\n\t}\n};\nPMA *buildPMA(vector<string>& p, vector<PMA*>& vpma, int size) {\n  Psz=0;\n  PMA *root = new PMA(Psz++);\n  vpma.push_back(root);\n  for (int i = 0; i < size; ++i) { // make trie\n    PMA *t = root;\n    for (int j = 0; j<p[i].size(); ++j) {\n      char c = p[i][j];\n      if (t->next[c] == NULL) \n\t  {\n\t\t  t->next[c] = new PMA(Psz++);\n\t\t  vpma.push_back(t->next[c]);\n\t  }\n      t = t->next[c];\n    }\n    //t->accept.push_back(i);\n  }\n  queue<PMA*> Q; // make failure link using bfs\n  for (int c = 'a'; c <= 'z'; ++c) {\n    if (root->next[c]) {\n      root->next[c]->next[0] = root;\n      Q.push(root->next[c]);\n    } else root->next[c] = root;\n  }\n  while (!Q.empty()) {\n    PMA *t = Q.front(); Q.pop();\n    for (int c = 'a'; c <= 'z'; ++c) {\n      if (t->next[c]) {\n        Q.push(t->next[c]);\n        PMA *r = t->next[0];\n        while (!r->next[c]) r = r->next[0];\n        t->next[c]->next[0] = r->next[c];\n      }\n    }\n  }\n  return root;\n}\n\nbool g[500][500];\n\nint match(string t, PMA *v, int &ret) {\n  int n = t.size();\n  int r = v->n;\n\n  for (int i = 0; i < n; ++i) {\n    char c = t[i];\n    while (!v->next[c]) v = v->next[0];\n    v = v->next[c];\n\tr = v->n;\n\tret+=v->accept.size();\n  }\n\n  return r;\n}\n\nvoid aaa(PMA* p, int n, string w)\n{\n    PMA *t = p;\n    for (int j = 0; j<w.size(); ++j) {\n      char c = w[j];\n      if (t->next[c] == NULL) return;\n      t = t->next[c];\n    }\n\tfor(int i=0; i<t->accept.size(); i++)\n\t\tif(t->accept[i]==n) return;\n    t->accept.push_back(n);\n}\n\nint kigo[505][25];\nint nextpma[505][25];\n\nint main()\n{\n\tint N,M,K;\n\twhile(cin >> N >> M >> K, (N||M||K))\n\t{\n\t\tfor(int i=0; i<WL; i++)\n\t\t\tdp[i].clear();\n\n\t\tmemset(g,0,sizeof(g));\n\t\tmemset(kigo, 0, sizeof(kigo));\n\n\t\tint d=0;\n\t\tmap<string, int> dic;\n\t\tvector<string> w(K);\n\t\tvector<string> str;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tstring s,t;\n\t\t\tcin >> s >> t;\n\t\t\tif(!dic.count(s)) \n\t\t\t{\n\t\t\t\tdic[s]=d++;\n\t\t\t\tstr.push_back(s);\n\t\t\t}\n\t\t\tif(!dic.count(t)) \n\t\t\t{\n\t\t\t\tdic[t]=d++;\n\t\t\t\tstr.push_back(t);\n\t\t\t}\n\n\t\t\tg[dic[s]][dic[t]]=1;\n\t\t}\n\n\t\tfor(int i=0; i<K; i++)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tw[i]=t;\n\t\t}\n\n\t\tvector<PMA*> vpma;\n\t\tPMA* tree=buildPMA(w,vpma,w.size());\n\t\tfor(int j=0; j<K; j++)\n\t\tfor(int i=0; i<Psz; i++)\n\t\t{\n\t\t\tPMA* p=vpma[i];\n\t\t\taaa(p, j, w[j]);\n\t\t}\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\tfor(int j=0; j<str.size(); j++)\n\t\t\tnextpma[j][i] = match(str[j], vpma[i], kigo[j][i]);\n\n\t\tfor(int i=0; i<str.size(); i++)\n\t\t{\n\t\t\tif(kigo[i][0]>1) continue;\n\t\t\tState s=State(i,nextpma[i][0],kigo[i][0]);\n\n\t\t\tint l = str[i].size();\n\t\t\tdp[l][s]=1;\n\t\t}\n\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tfor(map<State, int>::iterator it = dp[i%WL].begin(); it != dp[i%WL].end(); it++)\n\t\t\t{\n\t\t\t\tState t=it->first;\n\t\t\t\tint val = it->second;\n\t\t\t\n\t\t\t\tfor(int m=0; m<str.size(); m++)\n\t\t\t\t{\n\t\t\t\t\tif(!g[t.pv][m]) continue;\n\n\t\t\t\t\tint k = t.pl;\n\t\t\t\t\tint twl=i+str[m].size();\n\t\t\t\t\tint r=nextpma[m][k];\n\t\t\t\t\tint tf=t.f+kigo[m][k];\n\n\t\t\t\t\tif(twl>M) continue;\n\t\t\t\t\tif(tf>1) continue;\n\n\t\t\t\t\tState ns = State(m,r, tf);\n\n\t\t\t\t\tif(!dp[twl%WL].count(ns)) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl%WL][ns]=val;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[twl%WL][ns]+=val;\n\t\t\t\t\t\tdp[twl%WL][ns]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\t\t\tdp[i%WL].clear();\n\n\t\t}\n\n\t\tint ret=0;\n\t\tfor(map<State, int>::iterator it = dp[M%WL].begin(); it != dp[M%WL].end(); it++)\n\t\t{\n\t\t\tState s=it->first;\n\t\t\tif(s.f != 1) continue;\n\t\t\tret+=dp[M%WL][s];\n\t\t\tret%=MOD;\n\t\t}\n\n\t\tcout << ret << endl;\n\n\t\tfor(int i=0; i<Psz; i++)\n\t\t\tdelete vpma[i];\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int n,m,f,no,num;\n  state(){}\n  state(int n,int m,int f,int no,int num) : n(n),m(m),f(f),no(no),num(num) {}\n  bool operator<(const state& st) const{\n    if( n == st.n )\n      if( m == st.m )\n\tif( f == st.f )\n\t  if( no == st.no )\n\t    return num < st.num;\n\t  else\n\t    return no < st.no;\n\telse\n\t  return f < st.f;\n      else\n\treturn m < st.m;\n    else\n      return n < st.n;\t    \n  }\n};\nunordered_map<string,int> S;\nmap<state,int> dp;\n//unordered_map<string,int> dp[501][501][2];\n//int dp[501][501][2][31][20];\n\nint N,M,K;\nvector<int> G[505];\nstring Sm[515];\nstring Sk[55];\nunordered_map<string,pair<int,pair<int,int>>> mcp;\nvoid init(){\n  mcp.clear();\n  dp.clear();\n  /*\n    for(int i=0;i<=2*N;i++){\n    for(int j=0;j<=M;j++){\n      dp[i][j][0].clear();\n      dp[i][j][1].clear();\n    }\n  }\n  */  \n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\n//pair<string,int> check(const string &s){\npair<int,pair<int,int>> check(const string &s){\n  if( mcp.count(s) != 0 ){\n    return mcp[s];\n  }\n  int cnt = 0;\n  pair<int,int> ret={-1,-1};\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret.first == -1 )\n\t    ret = {i,ss.size()};\t  \n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  return mcp[s] = {cnt,ret};\n} \nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\n//int solve(int n,int m,int cnt,string str){\nint solve(int n,int m,int cnt,int no,int num){\n  int ret=0;\n  if( dp.count( state(n,m,cnt,no,num) ) != 0 ) return dp[{n,m,cnt,no,num}];\n  //if( dp[n][m][cnt].count(str) != 0 ) return dp[n][m][cnt][str];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n    return dp[{n,m,cnt,no,num}] = cnt;\n    //return dp[n][m][cnt][str] = cnt;\n  }\n  string str = \"\";\n  if( no >= 0 )\n    str = Sk[no].substr(0,num);\n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    pair<int,pair<int,int>> np = check(rs);\n    int nct = cnt + np.first - check(str).first;\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, np.second.first, np.second.second )); \n  }\n  //    cout << N << \" \" << M << \" \" << K << endl;\n  //cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[{n,m,cnt,no,num}] = ret;\n  //return dp[n][m][cnt][no][num] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    //cout << N << \" \" << M << \" \"<< K << endl;\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    //cout << S.size() << endl;    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      auto np = check(rs);\n      int cnt = np.first;\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,np.second.first,np.second.second) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Trie {\n    struct Node {\n        int num; // node number\n        Node *next[27], *fail;\n        int words;\n\n        Node() : words(0) {;}\n        Node(int n) : words(0), num(n) {\n            for(int i=0; i<27; ++i) next[i] = NULL;\n            fail = NULL;\n        }\n    };\n\n    // default constructor\n    Trie() { nodes.clear(); nodes.push_back(new Node(0)); }\n\n    // insert string\n    void insert(const string &s) {\n        Node *cur = nodes[0];\n        for(int i=0; i<s.length(); ++i) {\n            if(cur->next[s[i]-'a'] == NULL) {\n                cur->next[s[i]-'a'] = new Node(nodes.size());\n                nodes.push_back(cur->next[s[i]-'a']);\n            }\n            cur = cur->next[s[i]-'a'];\n        }\n        cur->words += 1;\n    }\n\n    // list of node\n    vector<Node*> nodes;\n};\n\nclass Aho_Corasick {\npublic:\n    Aho_Corasick(const vector<string> &vs) : keys(vs) {\n        _trie = Trie();\n        for(int i=0; i<vs.size(); ++i) _trie.insert(vs[i]);\n        make_failure_link();\n    }\n\n    void make_failure_link() {\n        queue<Trie::Node *> q;\n        Trie::Node *root = _trie.nodes[0];\n        for(int i=0; i<27; ++i) {\n            if(root->next[i]) {\n                root->next[i]->fail = root;\n                q.push(root->next[i]);\n            }else root->next[i] = root;\n        }\n\n        while(!q.empty()) {\n            Trie::Node *t = q.front(); q.pop();\n            for(int i=0; i<27; ++i) {\n                Trie::Node *u = t->next[i];\n                if(u) {\n                    q.push(u);\n                    Trie::Node *r = t->fail;\n                    while(!r->next[i]) r = r->fail;\n                    u->fail = r->next[i];\n                    u->words += u->fail->words;\n                }\n            }\n        }\n    }\n\n    pair<int,int> match(const string &s,int num = 0) {\n        Trie::Node *v = _trie.nodes[num];\n        int ret = 0;\n        for(int i=0; i<s.length(); ++i) {\n            while(!v->next[s[i]-'a']) v = v->fail;\n            v = v->next[s[i]-'a'];\n            if(v->words > 0) ret += v->words;\n        }\n        return make_pair(ret,v->num);\n    }\n\n    void free() {\n        for(int i=0; i<_trie.nodes.size(); ++i)\n            delete _trie.nodes[i];\n    }\n\n    Trie _trie;\n    vector<string> keys;\n};\n\nconst int MAXM = 501;\nconst int MAXS = 20*30+5;\nconst int MAXN = 501;\nconst int mod = 1000000007;\nmap<int,int> dp[MAXM];\n\ninline int encode(int k,int s,int w) { return (s*MAXN+w)*MAXN+k; }\n\nint main() {\n    int n,m,k;\n    while(cin>>n>>m>>k, n|m|k) {\n        string from,to;\n\n        map<int, vector<int> > edge;\n        map<string,int> idx;\n        vector<string> ridx;\n\n        for(int i=0; i<n; ++i) {\n            cin>>from>>to;\n\n            // make index of word\n            if(idx.find(from) == idx.end()) {\n                idx[from] = ridx.size();\n                ridx.push_back(from);\n            }\n            if(idx.find(to) == idx.end()) {\n                idx[to] = ridx.size();\n                ridx.push_back(to);\n            }\n\n\n            if(edge.find(idx[from]) == edge.end())\n                edge[idx[from]] = vector<int>(1,idx[to]);\n            else\n                edge[idx[from]].push_back(idx[to]);\n        }\n\n        vector<string> kigo(k);\n        for(int i=0; i<k; ++i) cin>>kigo[i];\n        Aho_Corasick ac(kigo);\n\n        int s = ac._trie.nodes.size();\n\n        // hoge\n        for(int i=0; i<MAXM; ++i) dp[i].clear();\n        for(int i=0; i<ridx.size(); ++i) {\n            int m = ridx[i].length();\n            pair<int,int> p = ac.match(ridx[i]);\n            dp[m][encode(p.first,p.second,i)] = 1;\n        }\n\n        for(int i=0; i<=m; ++i) {\n            for(map<int,int>::iterator it = dp[i].begin(); it != dp[i].end(); ++it) {\n                int key = it->first;\n                int k = key%MAXN, prev = (key/MAXN)%MAXN, s = (key/MAXN)/MAXN,d = it->second;\n\n                for(int j=0; j<edge[prev].size(); ++j) {\n                    int nlen = i+ridx[edge[prev][j]].length();\n                    if(nlen > m) continue;\n\n                    pair<int,int> p = ac.match(ridx[edge[prev][j]],s);\n                    if(k+p.first < 2) {\n                        dp[nlen][encode(k+p.first,p.second,edge[prev][j])] += d;\n                        dp[nlen][encode(k+p.first,p.second,edge[prev][j])] %= mod;\n                    }\n                }\n            }\n        }\n\n\n        ac.free();\n\n        int ans = 0;\n        for(int i=0; i<ridx.size(); ++i) {\n            for(int j=0; j<MAXS; ++j) {\n                ans += dp[m][encode(1,j,i)];\n                ans %= mod;\n            }\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nbool is_suffix(string const & a, string const & b) {\n    if (a.length() > b.length()) return false;\n    return b.compare(b.length() - a.length(), b.length(), a) == 0;\n}\n\nint count_seasonwords(string const & s, vector<string> const & seasonwords) {\n    int cnt = 0;\n    for (string const & seasonword : seasonwords) {\n        for (int j = 0; ; ) {\n            j = s.find(seasonword, j);\n            if (j == string::npos) break;\n            ++ j;\n            ++ cnt;\n            if (cnt >= 2) return cnt;\n        }\n    }\n    return cnt;\n}\n\nstring shrink_to_seasonwords(string s, vector<string> const & seasonwords) {\n    int len = 0;\n    for (string const & seasonword : seasonwords) {\n        string t = seasonword;\n        if (t.length() > s.length()) t = t.substr(0, s.length());\n        for (; not t.empty(); t.pop_back()) {\n            if (is_suffix(t, s)) {\n                setmax<int>(len, t.length());\n                break;\n            }\n        }\n    }\n    return s.substr(s.length() - len);\n}\n\nconstexpr int mod = 1e9+7;\nint main() {\n    while (true) {\n        // input\n        int n, m, k; cin >> n >> m >> k;\n        if (n == 0) break;\n        multimap<string, string> conn;\n        repeat (i, n) {\n            string from, to; cin >> from >> to;\n            conn.emplace(from, to);\n        }\n        vector<string> seasonword(k);\n        repeat (i, k) {\n            cin >> seasonword[i];\n        }\n        // solve\n        vector<string> word;\n        map<string, int> index;\n        for (auto const & it : conn) {\n            for (string s : { it.first, it.second }) {\n                if (not index.count(s)) {\n                    index.emplace(s, index.size());\n                    word.push_back(s);\n                }\n            }\n        }\n        vector<vector<int> > g(word.size());\n        for (auto const & it : conn) {\n            g[index[it.first]].push_back(index[it.second]);\n        }\n        map<tuple<int, bool, string>, int> compression;\n        vector<tuple<int, bool, string> > uncompress;\n        vector<bool> used;\n        vector<vector<pair<int, int> > > h;\n        auto compress = [&](int i, bool is_season, string const & s) {\n            auto key = make_tuple(i, is_season, s);\n            auto it = compression.find(key);\n            if (it != compression.end()) return it->second;\n            compression.emplace(key, compression.size());\n            uncompress.push_back(key);\n            used.push_back(false);\n            h.emplace_back();\n            return int(compression.size()) - 1;\n        };\n        vector<map<int, int> > dp(m + 1);\n        repeat (i, word.size()) if (word[i].length() <= m) {\n            int season = count_seasonwords(word[i], seasonword);\n            if (season >= 2) continue;\n            dp[word[i].length()][compress(i, bool(season), word[i])] += 1;\n        }\n        repeat (l, m) {\n            for (auto state : dp[l]) {\n                int p, cnt; tie(p, cnt) = state;\n                if (not used[p]) {\n                    used[p] = true;\n                    int i; bool is_season; string s; tie(i, is_season, s) = uncompress[p];\n                    int count_seasonwords_s = count_seasonwords(s, seasonword);\n                    for (int j : g[i]) {\n                        if (m < l + word[j].length()) continue; // this is ok\n                        string t = s + word[j];\n                        int next_season = is_season + count_seasonwords(t, seasonword) - count_seasonwords_s;\n                        if (next_season >= 2) continue;\n                        int q = compress(j, bool(next_season), shrink_to_seasonwords(t, seasonword));\n                        h[p].emplace_back(q, word[j].length());\n                    }\n                }\n                for (auto edge : h[p]) {\n                    int q, dl; tie(q, dl) = edge;\n                    if (m < l + dl) continue;\n                    int & it = dp[l + dl][q];\n                    it += cnt;\n                    if (it >= mod) it -= mod;\n                }\n            }\n            dp[l] = map<int, int>(); // release\n        }\n        // output\n        int result = 0;\n        for (auto state : dp[m]) {\n            int p, cnt; tie(p, cnt) = state;\n            bool is_season; tie(ignore, is_season, ignore) = uncompress[p];\n            if (not is_season) continue;\n            result = (result + cnt) % mod;\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint cur = 0;\n\nstruct T{\n\tint id,flag;\n\tT *next[26];\n\tT(){ id = flag=0;for(int i = 0 ; i < 26 ; i++) next[i] = NULL; }\n};\n\nT *rope[1000];\nint bad[1000];\n\nstring ttt[1000];\n\nint n,m,K;\nvoid add(T *root,string s){\n\t//cout << \"[\" << s << \"]\" << endl;\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t}else{\n\t\t\troot = root->next[s[i]-'a'] = new T();\n\t\t\trope[cur] = root;\n\t\t\troot->id = cur++;\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tif( ttt[j].size() <= (i+1) ){\n\t\t\t\t\tif( s.substr(i+1-ttt[j].size(),ttt[j].size()) == ttt[j] ){\n\t\t\t\t\t\troot->flag++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool done[1000];\n\nint tmp;\nint exists(T *root,string s){\n\tfor(int i = 0 ; i < s.size() ; i++){\n\t\tif( root->next[s[i]-'a'] ){\n\t\t\troot = root->next[s[i]-'a'];\n\t\t\ttmp += root->flag;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn root->id;\n}\nvoid failed_generate(T *root,string c,T *src){\n\tif( done[root->id] ) return;\n\telse done[root->id] = true;\n\t//cout << root->id << \": \" << c << \" \" << root->flag << endl;\n\tfor(int i = 0 ; i < 26 ; i++){\n\t\tif( root->next[i] ){\n\t\t\tfailed_generate(root->next[i],c+(char)(i+'a'),src);\n\t\t}else{\n\t\t\t\n\t\t\tstring w = c + (char)(i+'a');\n\t\t\tint idx = 0;\n\t\t\tfor(int j = 0 ; j < w.size() ; j++){\n\t\t\t\tint r = exists(src,w.substr(j));\n\t\t\t\tif( r != -1 ){\n\t\t\t\t\tidx = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot->next[i] = rope[idx];\n\t\t}\n\t}\n}\n\n\nmap<string,int> dic;\nstring ln[500];\n\nvector<int> connect[500];\n\nshort mem[610][500];\nshort mem2[610][500];\n\nint dp[21][500][610][2];\n\n/*\nmap< pair< pair<int,int> , pair<int,int> >, int > memo;\nint dfs(int pos,int word,int info,int ok){\n\tif( ok > 1 ) return 0;\n\tpair< pair<int,int>, pair<int,int> > key = make_pair( make_pair(pos,word) , make_pair(info,ok) );\n\t//cout << ln[pos] << \" \" << word << \" \" << info << \" \" << ok << endl;\n\tif( memo.count(key) ) return memo[key];\n\tif( word < 0 ) return 0;\n\tif( word == 0 ) return ok == 1;\n\tint ans = 0;\n\tfor(int i = 0 ; i < connect[pos].size() ; i++){\n\t\tans += dfs(connect[pos][i],word - ln[connect[pos][i]].size() , mem[info][connect[pos][i]],ok+mem2[info][connect[pos][i]]);\n\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t}\n\treturn memo[key] = ans;\n}\n*/\nint main(){\n\twhile(cin >> n >> m >> K && n){\n\t\tdic.clear();\n\t\t\n\t\tfor(int i = 0 ; i < 1000 ; i++) done[i] = 0;\n\t\tfor(int i = 0 ; i < 500 ; i++) ln[i] = \"\", connect[i].clear();\n\t\tfor(int i = 0 ; i < 1000 ; i++) rope[i] = NULL;\n\t\tfor(int i = 0 ; i < 1000 ; i++)bad[i] = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif( dic.count(a) == 0 ){ int k = dic.size(); dic[a] = k; ln[k] = a;}\n\t\t\tif( dic.count(b) == 0 ){ int k = dic.size(); dic[b] = k; ln[k] = b;}\n\t\t\tconnect[dic[a]].push_back(dic[b]);\n\t\t\t\n\t\t}\n\t\tT *root = new T();\n\t\trope[0] = root;\n\t\tcur = 1;\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tstring l;\n\t\t\tcin >> l;\n\t\t\tttt[i] = l;\n\t\t\t//cout << l << endl;\n\t\t}\n\t\tfor(int i = 0 ; i < K ; i++){\n\t\t\tadd(root,ttt[i]);\n\t\t}\n\t\t\n\t\tfailed_generate(root,\"\",root);\n\t\t\n\t\tfor(int i = 0 ; i < cur ; i++){\n\t\t\tfor(int k = 0 ; k < dic.size() ; k++){\n\t\t\t\ttmp = 0;\n\t\t\t\tmem[i][k] = exists(rope[i],ln[k]);\n\t\t\t\tmem2[i][k] = tmp;\n\t\t\t\t//cout << i << \" \" << ln[k] << \" \" << tmp << \" \" << mem[i][k] << \" \" << mem2[i][k] << endl;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tif( mem2[0][i] < 2 ) dp[ln[i].size()][i][mem[0][i]][mem2[0][i]] = 1;\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tfor(int j = 0 ; j < dic.size() ; j++){\n\t\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\t\tfor(int f = 0 ; f < 2 ; f ++){\n\t\t\t\t\t\tif( dp[i%21][j][k][f] == 0 ) continue;\n\t\t\t\t\t\tfor(int l = 0 ; l < connect[j].size() ; l++){\n\t\t\t\t\t\t\tif( i + ln[connect[j][l]].size() <= m && f+mem2[k][connect[j][l]] < 2 ){\n\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] += dp[i%21][j][k][f];\n\t\t\t\t\t\t\t\tif( dp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] >= 1000000007 ){\n\t\t\t\t\t\t\t\t\tdp[(i+ln[connect[j][l]].size())%21][connect[j][l]][mem[k][connect[j][l]]][f+mem2[k][connect[j][l]]] -= 1000000007;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(dp[i%21],0,sizeof(dp[i%21]));\n\t\t}\n\t\tfor(int i = 0 ; i < dic.size() ; i++){\n\t\t\tfor(int k = 0 ; k < cur ; k++){\n\t\t\t\tans += dp[m%21][i][k][1];\n\t\t\t\tif( ans >= 1000000007 ) ans -= 1000000007;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//\tch_cnts[now]++;\n//\tfor (auto&& e : g[now]) {\n//\t\tch_cnts[now] += dfs(g, e, ch_cnts);\n//\t}\n//\treturn ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//\tint from;\n//\tint to;\n//\tbool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//\tint max_ch_id = 1;\n//\t{\n//\t\tint max_ch_num = -1;\n//\t\tfor (auto&&e : g[now]) {\n//\t\t\tif (max_ch_num < ch_cnts[e]) {\n//\t\t\t\tmax_ch_num = ch_cnts[e];\n//\t\t\t\tmax_ch_id = e;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (auto e : g[now]) {\n//\t\tbool heavy = (e == max_ch_id);\n//\n//\t\thl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//\t}\n//\treturn;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//\tvector<int>ch_cnts(ro_tree.size());\n//\n//\tdfs(ro_tree, 0, ch_cnts);\n//\n//\tvector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//\tdfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//\tusing C = complex< double >;\n//\n//\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n//\t{\n//\t\tconst int N = (int)F.size();\n//\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n//\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n//\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n//\t\t\tif (i > j) swap(F[i], F[j]);\n//\t\t}\n//\t\tC w, s, t;\n//\t\tfor (int i = 1; i < N; i <<= 1) {\n//\t\t\tfor (int k = 0; k < i; k++) {\n//\t\t\t\tw = polar(1.0, PI / i * k);\n//\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n//\t\t\t\t\ts = F[j + k];\n//\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//\t}\n//\n//\tvector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//\t{\n//\t\tint sz = 1;\n//\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n//\t\tvector< C > F(sz), G(sz);\n//\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n//\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n//\t\tDiscreteFourierTransform(F, false);\n//\t\tDiscreteFourierTransform(G, false);\n//\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n//\t\tDiscreteFourierTransform(F, true);\n//\t\tvector< int > X(A.size() + B.size() - 1);\n//\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//\t\treturn (X);\n//\t}\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr),valid(-1) {\n\n\t}\n\t\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j=0;j<sts.size();++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next=now->chs[sts[j][i]-'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i]-'a']=make_shared<PMA>();\n\t\t\t\tnext=now->chs[sts[j][i]-'a'];\n\t\t\t}\n\n\t\t\tnow=next;\n\n\t\t}\n\t\tnow->valid=j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor(int i=0;i<26;++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r=afront->fail;\n\n\t\t\t\t\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod=1e9+7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif(!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\n\t\tmap<pair<shared_ptr<PMA>,int>,shared_ptr<PMA>>memo;\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto&& nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\n\t\t\t\t\t\tif (memo.find(make_pair(now_pma, i)) == memo.end()) {\n\t\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tauto ach = now_pma->chs[i];\n\n\t\t\t\t\t\t\tmemo[make_pair(now_pma,i)]=ach;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tauto ch=memo[make_pair(now_pma,i)];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (next_kigo <= 1) {\n\n\t\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nbool solve(){\n  int n,m,q;\n  string from[SIZE], to[SIZE], ssword[SIZE];\n  int fromid[SIZE], toid[SIZE];\n  string word[SIZE];\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n  }\n\n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[500];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  for(int i=0;i<pos_size;i++){\n    free(pos[i]);\n  }\n  pos_size = 0;\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst ll MOD = 1e9+7;\n\nstruct Node {\n    vector<int> accept;\n    map<char,Node*> chd;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\n\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    void build(vector<string> vstr) {\n        int vlen = vstr.size();\n        vector<vector<pair<int,int> > > substring(vlen);\n        for (int i = 0; i < vlen; i++) {\n            for (int j = 0; j < vlen; j++) {\n                if (i == j) continue;\n                auto pos = vstr[i].find(vstr[j]);\n                if (pos != string::npos) {\n                    substring[i].push_back(make_pair(j, pos + vstr[j].size()-1));\n                }\n            }\n        }\n\n        for (int i = 0; i < vlen; i++) {\n            Node* now = root;\n            for (int j = 0; j < vstr[i].size(); j++) {\n                char s = vstr[i][j];\n                if (now->chd.find(s) == now->chd.end())\n                    now->chd[s] = new Node();\n                now = now->chd[s];\n                for (auto p : substring[i]) {\n                    int v = p.first;\n                    int ps = p.second;\n                    if (ps == j) {\n                        now->accept.push_back(v);\n                    }\n                }\n            }\n            now->accept.push_back(i);\n        }\n\n\n        queue<Node*> que;\n        string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto s : symbol_array) {\n            if (root->chd.find(s) == root->chd.end()) {\n                root->chd[s] = root;\n            } else {\n                root->chd[s]->chd[failure] = root;\n                que.push(root->chd[s]);\n            }\n        }\n\n        while (!que.empty()) {\n            Node* now = que.front();\n            que.pop();\n\n            for (auto& v : now->chd) {\n                if (v.first == failure) continue;\n                que.push(v.second);\n                Node* rev = now->chd[failure];\n                while (rev->chd.find(v.first) == rev->chd.end())\n                    rev = rev->chd[failure];\n                now->chd[v.first]->chd[failure] = rev->chd[v.first];\n            }\n        }\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto s : str) {\n            while (now->chd.find(s) == now->chd.end())\n                now = now->chd[failure];\n            now = now->chd[s];\n            count = count + 0;\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,ll> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1LL;\n        }\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            ll num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        ll ans = 0LL;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <vector>\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint add_name(const std::string &s){\n\t\treturn (*this)[s];\n\t}\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n\tconst std::string &operator[](size_t i) const {\n\t\treturn m_inv_table[i];\n\t}\n\tsize_t size() const { return m_inv_table.size(); }\n};\n}\nnamespace lc {\ntemplate <int MAX_CODE = std::numeric_limits<char>::max()>\nclass AhoCorasick {\nprivate:\n\tstruct State {\n\t\tint next[MAX_CODE + 1];\n\t\tint failure;\n\t\tstd::vector<int> accept;\n\t\tState() : failure(0), accept() {\n\t\t\tstd::fill(next, next + MAX_CODE + 1, -1);\n\t\t}\n\t};\n\tstd::vector<State> m_states;\n\ttemplate <class Iterator>\n\tvoid construct_trie(Iterator first, Iterator last){\n\t\tm_states.emplace_back();\n\t\tint i = 0;\n\t\tfor(Iterator it = first; it != last; ++it, ++i){\n\t\t\tint cur = 0;\n\t\t\tfor(const int c : *it){\n\t\t\t\tif(m_states[cur].next[c] < 0){\n\t\t\t\t\tm_states[cur].next[c] = m_states.size();\n\t\t\t\t\tm_states.emplace_back();\n\t\t\t\t}\n\t\t\t\tcur = m_states[cur].next[c];\n\t\t\t}\n\t\t\tm_states[cur].accept.push_back(i);\n\t\t}\n\t}\n\tvoid write_failure_links(){\n\t\tstd::queue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int index = q.front();\n\t\t\tq.pop();\n\t\t\tconst State &s = m_states[index];\n\t\t\tfor(int i = 0; i <= MAX_CODE; ++i){\n\t\t\t\tconst int next = s.next[i];\n\t\t\t\tif(next < 0){ continue; }\n\t\t\t\tq.push(next);\n\t\t\t\tif(index == 0){ continue; }\n\t\t\t\tint f = s.failure;\n\t\t\t\twhile(f != 0 && m_states[f].next[i] < 0){\n\t\t\t\t\tf = m_states[f].failure;\n\t\t\t\t}\n\t\t\t\tconst int failure = std::max(0, m_states[f].next[i]);\n\t\t\t\tm_states[next].failure = failure;\n\t\t\t\tconst auto &accept = m_states[failure].accept;\n\t\t\t\tstd::copy(\n\t\t\t\t\taccept.begin(), accept.end(),\n\t\t\t\t\tstd::back_inserter(m_states[next].accept));\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tAhoCorasick()\n\t\t: m_states(1)\n\t{ }\n\ttemplate <class Iterator>\n\tAhoCorasick(Iterator first, Iterator last)\n\t\t: m_states()\n\t{\n\t\tconstruct_trie(first, last);\n\t\twrite_failure_links();\n\t}\n\tstd::pair<int, const std::vector<int> &> iterate(int c, int s) const {\n\t\twhile(s != 0 && m_states[s].next[c] < 0){ s = m_states[s].failure; }\n\t\ts = std::max(0, m_states[s].next[c]);\n\t\treturn std::pair<int, const std::vector<int> &>(s, m_states[s].accept);\n\t}\n\tsize_t size() const {\n\t\treturn m_states.size();\n\t}\n};\n}\nusing namespace std;\ntypedef lc::AhoCorasick<27> AhoCorasick;\nstatic const int MOD = 1000000007;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, k;\n\t\tcin >> n >> m >> k;\n\t\tif(n == 0 && m == 0 && k == 0){ break; }\n\t\tvector< vector<int> > next_words(2 * n + 1);\n\t\tlc::NameTable words;\n\t\twords.add_name(\"\");\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tfor(auto &c : from){ c -= 'a' - 1; }\n\t\t\tfor(auto &c : to){ c -= 'a' - 1; }\n\t\t\tconst int from_key = words[from], to_key = words[to];\n\t\t\tnext_words[from_key].push_back(to_key);\n\t\t}\n\t\tfor(size_t i = 1; i < words.size(); ++i){\n\t\t\tnext_words[0].push_back(i);\n\t\t}\n\t\tvector<string> season_words(k);\n\t\tfor(int i = 0; i < k; ++i){\n\t\t\tcin >> season_words[i];\n\t\t\tfor(auto &c : season_words[i]){ c -= 'a' - 1; }\n\t\t}\n\t\tAhoCorasick ac(season_words.begin(), season_words.end());\n\t\tmap<int, int> dp[21][501][2];\n\t\tdp[0][0][0].insert(make_pair(0, 1));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(size_t j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int f = 0; f < 2; ++f){\n\t\t\t\t\tfor(const auto &p : dp[i % 21][j][f]){\n\t\t\t\t\t\tfor(const int next : next_words[j]){\n\t\t\t\t\t\t\tconst string &word = words[next];\n\t\t\t\t\t\t\tif(static_cast<int>(i + word.size()) > m){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint state = p.first, sum = f;\n\t\t\t\t\t\t\tfor(const char c : word){\n\t\t\t\t\t\t\t\tconst auto res = ac.iterate(c, state);\n\t\t\t\t\t\t\t\tstate = res.first;\n\t\t\t\t\t\t\t\tsum += res.second.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(sum >= 2){ continue; }\n\t\t\t\t\t\t\tconst int rot = (i + word.size()) % 21;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] += p.second;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][f].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(size_t i = 0; i < words.size(); ++i){\n\t\t\tfor(size_t j = 0; j < ac.size(); ++j){\n\t\t\t\tanswer += dp[m % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nconst char ALPHABET_MIN = 'a';\nconst char ALPHABET_MAX = 'z';\nconst int ALPHABET_SIZE = ALPHABET_MAX - ALPHABET_MIN + 1;\n\nstruct State {\n    vector<int> next;\n    vector<int> accept;\n    int failure;\n    State(): next(ALPHABET_SIZE, -1), failure(-1) {}\n};\n\nvector<State> build_pma(const vector<string>& keywords) {\n    vector<State> pma(1);\n    // make trie\n    REP(i, keywords.size()) {\n        int k = 0;\n        for (char ch : keywords[i]) {\n            assert(ALPHABET_MIN <= ch && ch <= ALPHABET_MAX);\n            ch -= ALPHABET_MIN;\n            if (pma[k].next[ch] == -1) {\n                pma[k].next[ch] = pma.size();\n                pma.emplace_back();\n            }\n            k = pma[k].next[ch];\n        }\n        pma[k].accept.push_back(i);\n    }\n    // bfs\n    queue<int> Q;\n    REP(ch, ALPHABET_SIZE) {\n        int k = pma[0].next[ch];\n        if (k == -1) {\n            pma[0].next[ch] = 0;\n        } else {\n            pma[k].failure = 0;\n            Q.push(k);\n        }\n    }\n    while (!Q.empty()) {\n        int k = Q.front(); Q.pop();\n        REP(ch, ALPHABET_SIZE) {\n            int j = pma[k].next[ch];\n            if (j == -1) continue;\n            int i = pma[k].failure;\n            while (pma[i].next[ch] == -1) i = pma[i].failure;\n            i = pma[i].next[ch];\n            pma[j].failure = i;\n            vector<int> accept;\n            set_union(pma[j].accept.begin(), pma[j].accept.end(),\n                      pma[i].accept.begin(), pma[i].accept.end(), back_inserter(accept));\n            pma[j].accept = accept;\n            Q.push(j);\n        }\n    }\n    return pma;\n}\n\npair<int, int> transit(const vector<State>& pma, const string& s, int initial) {\n    int k = initial, accept = 0;\n    REP(i, s.size()) {\n        char ch = s[i] - ALPHABET_MIN;\n        while (pma[k].next[ch] == -1)\n            k = pma[k].failure;\n        k = pma[k].next[ch];\n        accept += pma[k].accept.size();\n    }\n    return make_pair(k, accept);\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, K;\n    while (cin>>N>>M>>K, N|M|K) {\n        unordered_map<string, int> word2id;\n        vector<vector<int>> graph;\n        REP(i, N) {\n            string s, t; cin >> s >> t;\n            if (!word2id.count(s)) {\n                int id = word2id.size();\n                word2id[s] = id;\n            }\n            if (!word2id.count(t)) {\n                int id = word2id.size();\n                word2id[t] = id;\n            }\n            graph.resize(word2id.size());\n            graph[word2id[s]].push_back(word2id[t]);\n        }\n        vector<string> seasonword(K);\n        REP(i, K) cin >> seasonword[i];\n\n        vector<State> pma = build_pma(seasonword);\n\n        vector<vector<int>> next_state(pma.size(), vector<int>(word2id.size()));\n        vector<vector<int>> n_accept(pma.size(), vector<int>(word2id.size()));\n        REP(state, pma.size()) {\n            for (auto p : word2id) {\n                string word; int i; tie(word, i) = p;\n                tie(next_state[state][i], n_accept[state][i]) = transit(pma, word, state);\n            }\n        }\n\n        vector<int> word_len(word2id.size());\n        for (auto p : word2id) {\n            string word; int i; tie(word, i) = p;\n            word_len[i] = word.size();\n        }\n\n        using Entry = tuple<short, short, char>;\n        vector<map<Entry, int>> dp(M+1);\n        REP(word, word2id.size()) {\n            Entry e = Entry(next_state[0][word], word, n_accept[0][word]);\n            if (word_len[word] <= M && get<2>(e) <= 1)\n                dp[word_len[word]][e] = 1;\n        }\n        REP(length, M+1) {\n            REP(state, pma.size()) {\n                REP(word1, word2id.size()) {\n                    REP(n_season, 2) {\n                        if (!dp[length].count(Entry(state, word1, n_season)))\n                            continue;\n                        int c = dp[length][Entry(state, word1, n_season)];\n                        for (int word2 : graph[word1]) {\n                            int length2 = length + word_len[word2];\n                            Entry next = Entry(\n                                next_state[state][word2],\n                                word2,\n                                n_season + n_accept[state][word2]);\n                            if (length2 > M || get<2>(next) > 1) continue;\n                            dp[length2][next] = (dp[length2][next] + c) % 1000000007;\n                        }\n                    }\n                }\n            }\n            if (length != M) map<Entry, int>().swap(dp[length]);\n        }\n\n        int ans = 0;\n        REP(state, pma.size()) REP(word, word2id.size()) if (dp[M].count(Entry(state, word, 1)))\n            ans = (ans + dp[M][Entry(state, word, 1)]) % 1000000007;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tREP(i, MAXCHAR){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst) continue;\n\t\t\t\tq.push(dst);\n\t\t\t\tint f = states[p].failure;\n\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\tif(p){\n\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tint p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n    inline int size() const { return v.size(); }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(128), fail(NULL) {}\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 128; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 128; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            // add que\n            que.push(np);\n\n            // search failure link\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            // update matching list\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\n// (node id, match count)\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\nstruct State{\n    int i, k, s;\n    State(int i, int k, int s) :\n        i(i), k(k), s(s) {}\n    bool operator < (const State& st) const {\n        if(i != st.i) return i < st.i;\n        if(k != st.k) return k < st.k;\n        return s < st.s;\n    }\n};\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        map<State, int> dp[501];\n        // start\n        for(int i = 0; i < idm.size(); i++){\n            string bs = idm.get(i);\n            pair<int, int> pi = match(root, bs);\n            if(bs.length() <= M && pi.second < 2){\n                //cout << bs.length() << \" \" << bs << \" \" << pi.first << \" \" << pi.second << endl;\n                update(dp[ bs.length() ][ State(i, pi.first, pi.second) ], 1);\n            }\n        }\n\n        // update\n        for(int l = 0; l < M; l++){\n            for(auto& p : dp[l]){\n                int i = p.first.i, k = p.first.k, s = p.first.s;\n                for(auto ni : next[i]){\n                    //cout << l << \" \" << idm.get(i) << \" \" << k << \" \" << s << \" \" << dp[l][i][k][s] << endl;\n\n                    string str = idm.get(ni);\n                    pair<int, int> pi = match(nodes[k], str);\n                    if(l + str.size() <= M && s + pi.second <= 1){\n                        update(dp[l + str.size()][ State(ni, pi.first, s + pi.second) ], p.second);\n                        /*\n                           cout << \"\\t\" << l + str.size() << \" \" << idm.get(ni) << \" \" << pi.first << \" \" << s + pi.second << \" \" << \n                           dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ] << endl;\n                           */\n                    }\n                }\n            }\n            dp[l].clear();\n        }\n\n        int ans = 0;\n        for(auto& p : dp[M]){\n            if(p.first.s == 1){\n                update(ans, p.second);\n            }\n        }\n        cout << ans << endl;\n\n        for(auto p : nodes) delete p;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t\t// 大量に呼び出す時はnextを全部埋めとくといい\n\t\t\t\t\tint q=p;\n\t\t\t\t\twhile(q && !states[q].next[i]) q = states[q].failure;\n\t\t\t\t\tstates[p].next[i] = states[q].next[i];\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\????????????¨?????????????????????°????????¨?\n  vector< int > accept; // ???????????????id\n\n  TrieNode() : exist(0)\n  {\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nstruct Trie\n{\n  vector< TrieNode > nodes;\n  int root;\n\n  Trie() : root(0)\n  {\n    nodes.push_back(TrieNode());\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    nodes[node].accept.push_back(id);\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[node_index].nxt[c] = (int) nodes.size();\n        nodes.push_back(TrieNode());\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return ((int) nodes.size());\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n  vector< int > correct;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    correct.resize(nodes.size());\n    for(int i = 0; i < nodes.size(); i++) {\n      correct[i] = (int) nodes[i].accept.size();\n    }\n\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      correct[que.front()] += correct[now.nxt[FAIL]];\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += correct[now];\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][480][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums[i].size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(get.second > 1) continue;\n      ++dp[nums[i].size()][i][get.second][get.first];\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int MOD = 1e9+7;\n\nstruct Node {\n    string suffix;\n    vector<int> accept;\n    map<char,Node*> next;\n};\n\nclass PMA {\nprivate :\n    Node* root;\n    const char failure = 0;\npublic :\n    PMA () {\n        root = new Node();\n    }\n\n    Node* getRoot() {\n        return root;\n    }\n\n    Node* addNode() {\n        Node* node = new Node();\n        node->next[failure] = root;\n\n        return node;\n    }\n\n    void build(vector<string> vstr) {\n        for (int i = 0, vlen = vstr.size(); i < vlen; i++) {\n            Node* now = root;\n            string tmp;\n            for (auto c : vstr[i]) {\n                if (now->next.find(c) == now->next.end())\n                    now->next[c] = addNode();\n                now = now->next[c];\n                tmp += c;\n                now->suffix = tmp;\n            }\n            now->accept.push_back(i);\n        }\n\n        queue<Node*> que;\n\n        const string symbol_array = \"abcdefghijklmnopqrstuvwxyz\";\n        for (auto c : symbol_array) {\n            if (root->next.find(c) != root->next.end()) {\n                root->next[c]->next[failure] = root;\n                que.push(root->next[c]);\n            } else {\n                root->next[c] = root;\n            }\n        }\n\n        while (!que.empty()) {\n            Node* node = que.front(); que.pop();\n            for (auto p : node->next) {\n\n                char c = p.first; // i\n                Node* now = p.second; // now->next[i]\n\n                if (c == failure) {\n                    continue;\n                }\n\n                que.push(now);\n\n                Node* rev = node->next[failure];\n                while (rev->next.find(c) == rev->next.end())\n                    rev = rev->next[failure];\n                now->next[failure] = rev->next[c];\n\n                vector<int> acc;\n                set_union(now->accept.begin(),\n                          now->accept.end(),\n                          rev->next[c]->accept.begin(),\n                          rev->next[c]->accept.end(),\n                          back_inserter(acc));\n                now->accept = acc;\n            }\n        }\n    }\n\n    int match(string str, Node* now, vector<int>& result) {\n        int len = str.size();\n        int count = 0;\n\n        for (auto c  : str) {\n            while (now->next.find(c) == now->next.end()) now = now->next[failure];\n            now = now->next[c];\n\n            for (auto ac : now->accept) {\n                result[ac]++;\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    Node* next(string str, Node* now, int& count) {\n        for (auto c : str) {\n            while (now->next.find(c) == now->next.end())\n                now = now->next[failure];\n            now = now->next[c];\n\n            for (auto i : now->accept) {\n                count++;\n            }\n        }\n\n        return now;\n    }\n};\n\nint main() {\n    int N, M, K;\n    while (cin >> N >> M >> K, N || M || K) {\n        PMA pma;\n        vector<string> from(N), to(N), season(K);\n        map<string,int> ston;\n        vector<string> ntos;\n        for (int i = 0; i < N; i++) {\n            cin >> from[i] >> to[i];\n            if (ston.find(from[i]) == ston.end())\n                ston[from[i]] = ston.size()-1, ntos.push_back(from[i]);\n            if (ston.find(to[i]) == ston.end())\n                ston[to[i]] = ston.size()-1, ntos.push_back(to[i]);\n        }\n\n        vector<vector<int> > next(ston.size());\n        for (int i = 0; i < N; i++) {\n            next[ston[from[i]]].push_back(ston[to[i]]);\n        }\n\n        for (int i = 0; i < K; i++) cin >> season[i];\n        pma.build(season);\n\n        vector<vector<vector<map<Node*,int> > > > dp(M+1);\n        for (auto& i : dp) {\n            i.resize(ston.size()+1);\n            for (auto& j : i) {\n                j.resize(2);\n            }\n        }\n\n        vector<vector<bool> > flag(M+1, vector<bool>(ston.size(), false));\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(from[i], now, count);\n            if (from[i].size() > M || count > 1) continue;\n            dp[from[i].size()][ston[from[i]]][count][now] = 1;\n            flag[from[i].size()][ston[from[i]]] = true;\n        }\n        for (int i = 0; i < N; i++) {\n            Node* now = pma.getRoot();\n            int count = 0;\n            now = pma.next(to[i], now, count);\n            if (to[i].size() > M || count > 1) continue;\n            dp[to[i].size()][ston[to[i]]][count][now] = 1;\n            flag[to[i].size()][ston[to[i]]] = true;\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < (int)ston.size(); j++) {\n                if (!flag[i][j]) continue;\n                for (int k = 0; k < 2; k++) {\n                    for (auto now : dp[i][j][k]) {\n                        for (auto nx : next[j]) {\n                            Node* node = now.first;\n                            ll num = now.second;\n                            int count = k;\n                            node = pma.next(ntos[nx], node, count);\n                            if (count <= 1 && i+ntos[nx].size() <= M) {\n                                dp[i+ntos[nx].size()][nx][count][node] += num;\n                                dp[i+ntos[nx].size()][nx][count][node] %= MOD;\n                                flag[i+ntos[nx].size()][nx] = true;\n                            }\n                        }\n                    }\n                    dp[i][j][k].clear();\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int i = 0; i < (int)ston.size(); i++) {\n            for (auto now : dp[M][i][1]) {\n                ans += now.second;\n                ans %= MOD;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE*60] = {};\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n\n  DATA(int now = 0, int acpos = 0, bool usessword = false):now(now),acpos(acpos),usessword(usessword){}\n  \n  bool operator<(const DATA &b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return (int)usessword < (int)b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\nchar ssword[50];\n\nbool solve(){\n  map<string, int> dict;\n  int dictid = 0;\n  vector<int> way[SIZE];\n\n  cin >> n >> m >> q;\n  \n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dictid] = from[i];\n      dict[from[i]] = dictid++;\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dictid] = to[i];\n      dict[to[i]] = dictid++;\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    cin >> ssword;\n    ac.insert(ssword);\n  }\n  \n  ac.build();\n\n  for(int i=0;i<(int)dict.size();i++){\n    way[(int)dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[501];\n  DATA initData = DATA((int)dict.size(), 0, false);\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    for(const pair<DATA,ll> &it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<(int)way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          ACNode *acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = DATA(way[p.now][j], acpos->id, v+p.usessword > 0);\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(const pair<DATA,ll> it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n  \n  return true;\n}\n\nint main(){\n  while(solve()){\n    for(int i=0;i<pos_size;i++){\n      free(pos[i]);\n    }\n    pos_size = 0;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <vector>\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint add_name(const std::string &s){\n\t\treturn (*this)[s];\n\t}\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n\tconst std::string &operator[](size_t i) const {\n\t\treturn m_inv_table[i];\n\t}\n\tsize_t size() const { return m_inv_table.size(); }\n};\n}\nnamespace lc {\ntemplate <int MAX_CODE = std::numeric_limits<char>::max()>\nclass AhoCorasick {\nprivate:\n\tstruct State {\n\t\tint next[MAX_CODE + 1];\n\t\tint failure;\n\t\tstd::vector<int> accept;\n\t\tState() : failure(0), accept() {\n\t\t\tconst int EMPTY_LINK = std::numeric_limits<int>::min();\n\t\t\tstd::fill(next, next + MAX_CODE + 1, EMPTY_LINK);\n\t\t}\n\t};\n\tstd::vector<State> m_states;\n\ttemplate <class Iterator>\n\tvoid construct_trie(Iterator first, Iterator last){\n\t\tm_states.emplace_back();\n\t\tint i = 0;\n\t\tfor(Iterator it = first; it != last; ++it, ++i){\n\t\t\tint cur = 0;\n\t\t\tfor(const int c : *it){\n\t\t\t\tif(m_states[cur].next[c] < 0){\n\t\t\t\t\tm_states[cur].next[c] = m_states.size();\n\t\t\t\t\tm_states.emplace_back();\n\t\t\t\t}\n\t\t\t\tcur = m_states[cur].next[c];\n\t\t\t}\n\t\t\tm_states[cur].accept.push_back(i);\n\t\t}\n\t}\n\tvoid write_failure_links(){\n\t\tstd::queue<int> q;\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tconst int index = q.front();\n\t\t\tq.pop();\n\t\t\tconst State &s = m_states[index];\n\t\t\tfor(int i = 0; i <= MAX_CODE; ++i){\n\t\t\t\tconst int next = s.next[i];\n\t\t\t\tif(next < 0){ continue; }\n\t\t\t\tq.push(next);\n\t\t\t\tif(index == 0){ continue; }\n\t\t\t\tint f = s.failure;\n\t\t\t\twhile(f != 0 && m_states[f].next[i] < 0){\n\t\t\t\t\tf = m_states[f].failure;\n\t\t\t\t}\n\t\t\t\tconst int failure = std::max(0, m_states[f].next[i]);\n\t\t\t\tm_states[next].failure = failure;\n\t\t\t\tconst auto &accept = m_states[failure].accept;\n\t\t\t\tstd::copy(\n\t\t\t\t\taccept.begin(), accept.end(),\n\t\t\t\t\tstd::back_inserter(m_states[next].accept));\n\t\t\t}\n\t\t}\n\t}\n\tint shorten_recur(int i, int c){\n\t\tconst int EMPTY_LINK = std::numeric_limits<int>::min();\n\t\tState &s = m_states[i];\n\t\tif(i == 0 || s.next[c] >= 0){ return ~i; }\n\t\tif(s.next[c] != EMPTY_LINK){ return s.next[c]; }\n\t\ts.next[c] = shorten_recur(s.failure, c);\n\t\treturn s.next[c];\n\t}\n\tvoid shorten_failure_links(){\n\t\tconst int n = m_states.size();\n\t\tfor(int i = 1; i < n; ++i){\n\t\t\tfor(int j = 0; j <= MAX_CODE; ++j){ shorten_recur(i, j); }\n\t\t}\n\t}\npublic:\n\tAhoCorasick()\n\t\t: m_states(1)\n\t{ }\n\ttemplate <class Iterator>\n\tAhoCorasick(Iterator first, Iterator last)\n\t\t: m_states()\n\t{\n\t\tconstruct_trie(first, last);\n\t\twrite_failure_links();\n\t\tshorten_failure_links();\n\t}\n\tstd::pair<int, const std::vector<int> &> iterate(int c, int s) const {\n\t\tif(s != 0 && m_states[s].next[c] < 0){ s = ~m_states[s].next[c]; }\n\t\ts = std::max(0, m_states[s].next[c]);\n\t\treturn std::pair<int, const std::vector<int> &>(s, m_states[s].accept);\n\t}\n\tsize_t size() const {\n\t\treturn m_states.size();\n\t}\n};\n}\nusing namespace std;\ntypedef lc::AhoCorasick<'z'> AhoCorasick;\nstatic const int MOD = 1000000007;\nstatic map<int, int> dp[21][501][2];\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, k;\n\t\tcin >> n >> m >> k;\n\t\tif(n == 0 && m == 0 && k == 0){ break; }\n\t\tvector< vector<int> > next_words(2 * n + 1);\n\t\tlc::NameTable words;\n\t\twords.add_name(\"\");\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring from, to;\n\t\t\tcin >> from >> to;\n\t\t\tconst int from_key = words[from], to_key = words[to];\n\t\t\tnext_words[from_key].push_back(to_key);\n\t\t}\n\t\tfor(size_t i = 1; i < words.size(); ++i){\n\t\t\tnext_words[0].push_back(i);\n\t\t}\n\t\tvector<string> season_words(k);\n\t\tfor(int i = 0; i < k; ++i){ cin >> season_words[i]; }\n\t\tAhoCorasick ac(season_words.begin(), season_words.end());\n\t\tfor(int i = 0; i <= 20; ++i){\n\t\t\tfor(size_t j = 0; j < words.size(); ++j){\n\t\t\t\tdp[i][j][0].clear();\n\t\t\t\tdp[i][j][1].clear();\n\t\t\t}\n\t\t}\n\t\tdp[0][0][0].insert(make_pair(0, 1));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(size_t j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int f = 0; f < 2; ++f){\n\t\t\t\t\tfor(const auto &p : dp[i % 21][j][f]){\n\t\t\t\t\t\tfor(const int next : next_words[j]){\n\t\t\t\t\t\t\tconst string &word = words[next];\n\t\t\t\t\t\t\tif(static_cast<int>(i + word.size()) > m){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint state = p.first, sum = f;\n\t\t\t\t\t\t\tfor(const char c : word){\n\t\t\t\t\t\t\t\tconst auto res = ac.iterate(c, state);\n\t\t\t\t\t\t\t\tstate = res.first;\n\t\t\t\t\t\t\t\tsum += res.second.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(sum >= 2){ continue; }\n\t\t\t\t\t\t\tconst int rot = (i + word.size()) % 21;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] += p.second;\n\t\t\t\t\t\t\tdp[rot][next][sum][state] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][f].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(size_t i = 0; i < words.size(); ++i){\n\t\t\tfor(size_t j = 0; j < ac.size(); ++j){\n\t\t\t\tanswer += dp[m % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct IDM{\n    map<string, int> m;\n    vector<string> v;\n    int get(string s){\n        if(!m.count(s)){\n            int k = m.size();\n            m[s] = k;\n            v.push_back(s);\n        }\n        return m[s];\n    }\n    string get(int k){\n        return v[k];\n    }\n};\n\nstruct Node{\n    int id;\n    vector<Node*> next; \n    Node* fail;\n    vector<int> match;\n    Node(int id) : id(id), next(256), fail(NULL) {}\n};\n\nNode *build(vector<string> pattens, vector<Node*>& nodes){\n    Node* root = new Node(0);\n    nodes.push_back(root);\n    root->fail = root;\n    for(int i = 0; i < pattens.size(); i++){\n        Node* p = root;\n        for(auto c : pattens[i]){\n            if(p->next[c] == 0){\n                p->next[c] = new Node(nodes.size());\n                nodes.push_back(p->next[c]);\n            }\n            p = p->next[c];\n        }\n        p->match.push_back(i);\n    }\n\n    queue<Node*> que;\n    for(int i = 0; i < 256; i++){\n        if(!root->next[i]){\n            root->next[i] = root;\n        }else{\n            root->next[i]->fail = root;\n            que.push(root->next[i]);\n        }\n\n    }\n    while(!que.empty()){\n        Node* p = que.front(); que.pop();\n        for(int i = 0; i < 256; i++) if(p->next[i]) {\n            Node* np = p->next[i];\n\n            // add que\n            que.push(np);\n\n            // search failure link\n            Node* f = p->fail;\n            while(!f->next[i]) f = f->fail;\n            np->fail = f->next[i];\n\n            // update matching list\n            np->match.insert(np->match.end(), np->fail->match.begin(), np->fail->match.end());\n        }\n    }\n    return root;\n}\n\n// (node id, match count)\npair<int, int> match(Node* p, string query){\n    int res = 0;\n    for(int i = 0; i < query.size(); i++){\n        int c = query[i];\n        while(!p->next[c]) p = p->fail; \n        p = p->next[c];\n        res += p->match.size();\n    }\n    return make_pair(p->id, res);\n}\n\nvoid update(int& x, int y){\n    const int MOD = 1000000007;\n    x = (x + y) % MOD;\n}\n\n\nint main(){\n    int N, M, K;\n    while(cin >> N >> M >> K && N){\n        IDM idm;\n        map<int, vector<int>> next;\n        REP(i, N){\n            string fs, ts;\n            cin >> fs >> ts;\n            next[ idm.get(fs) ].push_back(idm.get(ts));\n        }\n\n        vector<string> pattens(K);\n        REP(i, K) cin >> pattens[i];\n\n        vector<Node*> nodes;\n        Node* root = build(pattens, nodes);\n\n        static int dp[501][501][601][2] = {}; // len, last str, last node, season or not\n        bool exist[501][501] = {};\n        memset(dp, 0, sizeof(dp));\n        // start\n        for(auto& p : next){\n            string bs = idm.get(p.first);\n            pair<int, int> pi = match(root, bs);\n            if(pi.second < 2){\n                //cout << bs.length() << \" \" << bs << \" \" << pi.first << \" \" << pi.second << endl;\n                dp[ bs.length() ][p.first][pi.first][ pi.second ] = 1;\n                exist[ bs.length() ][ p.first ] = true;\n            }\n        }\n\n        // update\n        for(int l = 0; l < M; l++)\n        for(int i = 0; i < 2 * N; i++) if(next[i].size() > 0 && exist[l][i])\n        for(int k = 0; k < nodes.size(); k++)\n        for(int s = 0; s <= 1; s++) if(dp[l][i][k][s] > 0){\n            for(auto ni : next[i]){\n                //cout << l << \" \" << idm.get(i) << \" \" << k << \" \" << s << \" \" << dp[l][i][k][s] << endl;\n\n                string str = idm.get(ni);\n                pair<int, int> pi = match(nodes[k], str);\n                if(l + str.size() <= M && s + pi.second <= 1){\n                    update(dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ], dp[l][i][k][s]);\n                    exist[ l + str.size() ][ ni ] = true;\n                    /*\n                       cout << \"\\t\" << l + str.size() << \" \" << idm.get(ni) << \" \" << pi.first << \" \" << s + pi.second << \" \" << \n                       dp[l + str.size()][ ni ][ pi.first ][ s + pi.second ] << endl;\n                       */\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int i = 0; i < 2 * N; i++)\n        for(int k = 0; k < nodes.size(); k++)\n        if(dp[M][i][k][1] > 0){\n            //cout << idm.get(i) << \" \" << k << endl;\n            update(ans, dp[M][i][k][1]);\n        }\n        cout << ans << endl;\n\n        for(auto p : nodes) delete p;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i,a,b) for(int i=a;i<b;++i)\n#define rep(i,n) range(i,0,n)\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m,k;\nvector<string> words;\nstring from[255],to[255];\nstring season[35];\n\nint fg[610][27];\nint ac[610];\n\nint build(){\n\trep(i,k*20)rep(j,27) fg[i][j]=0;\n\trep(i,k*20) ac[i]=0;\n\tint root=1,size=2;\n\tfg[root][0]=root;\n\trep(i,k){\n\t\tint cur=root;\n\t\trep(j,season[i].size()){\n\t\t\tint tar=season[i][j]-'a'+1;\n\t\t\tif(fg[cur][tar]==0) fg[cur][tar]=size++;\n\t\t\tcur=fg[cur][tar];\n\t\t}\n\t\tac[cur]|=(1<<i);\n\t}\n\tqueue<int> q;\n\trange(i,1,27){\n\t\tif(fg[root][i]){\n\t\t\tfg[fg[root][i]][0]=root;\n\t\t\tint tar=fg[root][i];\n\t\t\tq.push(tar);\n\t\t}else\n\t\t\tfg[root][i]=root;\n\t}\n\twhile(!q.empty()){\n\t\tint now=q.front();q.pop();\n\t\trange(i,1,27){\n\t\t\tif(fg[now][i]){\n\t\t\t\tint tar=fg[now][0];\n\t\t\t\twhile(!fg[tar][i]) tar=fg[tar][0];\n\t\t\t\tfg[fg[now][i]][0]=fg[tar][i];\n\t\t\t\tac[fg[now][i]]|=ac[fg[tar][i]];\n\t\t\t\tq.push(fg[now][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn size;\n}\n\nconst ll mod=1000000007;\ntypedef tuple<int,int,int> state;\nmap<state,int> dp[510]; // len words state ac\n\nint main(void){\n\twhile(cin >> n >> m >> k){\n\t\tif(n==0) break;\n\n\t\twords.clear();\n\t\trep(i,n) cin >> from[i] >> to[i];\n\t\trep(i,n) words.push_back(from[i]);\n\t\trep(i,n) words.push_back(to[i]);\n\t\tsort(words.begin(),words.end());\n\t\twords.erase(unique(words.begin(),words.end()),words.end());\n\t\tint w=words.size();\n\n\t\trep(i,k) cin >> season[i];\n\t\tint root=1,s=build();\n\n\t\tvector<int> graph[510];\n\t\trep(i,n){\n\t\t\tint fi=lower_bound(words.begin(),words.end(),from[i])-words.begin();\n\t\t\tint ti=lower_bound(words.begin(),words.end(),to[i])-words.begin();\n\t\t\tgraph[fi].push_back(ti);\n\t\t}\n\t\trep(i,w) graph[w].push_back(i);\n\n\t\trep(i,m+1) dp[i].clear();\n\t\tdp[0][make_tuple(w,root,0)]=1LL;\n\t\trep(i,m){\n\t\t\tif(i-1>=0) dp[i-1].clear();\n\t\t\trep(j,w+1)range(k,root,s)rep(l,2){\n\t\t\t\tif(dp[i].find(make_tuple(j,k,l))==dp[i].end()) continue;\n\t\t\t\tif(i>0&&j==w) continue;\n\t\t\t\tfor(auto &nj:graph[j]){\n\t\t\t\t\tint ni=i+words[nj].size();\n\t\t\t\t\tif(ni>m) continue;\n\t\t\t\t\tint nk=k,nl=l;\n\t\t\t\t\trep(a,words[nj].size()){\n\t\t\t\t\t\tint tar=words[nj][a]-'a'+1;\n\t\t\t\t\t\twhile(!fg[nk][tar]) nk=fg[nk][0];\n\t\t\t\t\t\tnk=fg[nk][tar];\n\t\t\t\t\t\tnl+=__builtin_popcount(ac[nk]);\n\t\t\t\t\t}\n\t\t\t\t\tif(nl>=2) continue;\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]+=dp[i][make_tuple(j,k,l)];\n\t\t\t\t\tdp[ni][make_tuple(nj,nk,nl)]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=0LL;\n\t\trep(j,w)range(k,1,s){\n\t\t\tans+=dp[m][make_tuple(j,k,1)];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\n\nstruct PMA{\n  PMA *next[0x100];\n  int ac;\n  PMA(){fill(next,next+0x100,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j];\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,128){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    REP(c,'a','z'+1){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,0x100){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i];\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=100;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=501;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n   PMA *root = buildPMA(kigo,m,P);\n//    makeGraph(all,P);\n //   sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int MOD>\nclass mod_int {\n\tunsigned x;\npublic:\n\tmod_int() : x(0) { }\n\tmod_int(int sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tmod_int(long long sig) { int sigt = sig % MOD; if (sigt < 0) sigt += MOD; x = sigt; }\n\tint get() const { return (int)x; }\n\n\tmod_int &operator+=(mod_int that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator-=(mod_int that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n\tmod_int &operator*=(mod_int that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n\tmod_int &operator/=(mod_int that) { return *this *= that.inverse(); }\n\n\tmod_int operator+(mod_int that) const { return mod_int(*this) += that; }\n\tmod_int operator-(mod_int that) const { return mod_int(*this) -= that; }\n\tmod_int operator*(mod_int that) const { return mod_int(*this) *= that; }\n\tmod_int operator/(mod_int that) const { return mod_int(*this) /= that; }\n\n\tbool operator==(const mod_int& that) const { return x == that.x; }\n\n\tmod_int inverse() const {\n\t\tlong long a = x, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tlong long t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\treturn mod_int(u);\n\t}\n};\n\ntemplate<int MOD>\nistream& operator >> (istream& is, mod_int<MOD>& val) {\n\tlong long x;\n\tis >> x; val = x;\n\treturn is;\n}\n\ntemplate<int MOD>\nostream& operator << (ostream& os, const mod_int<MOD>& val) {\n\tos << val.get();\n\treturn os;\n}\n\nconst int mod = 1e9 + 7;\nusing mint = mod_int<mod>;\n\nconst int var = 26;\n\nint trans(char c) {\n\treturn c - 'a';\n}\n\nclass aho_corasick {\n\tstruct ac_node {\n\t\tint fail;\n\t\tint next[var];\n\t\tvector<int> ok;\n\t\tac_node() : fail(-1) {\n\t\t\tfor (int i = 0; i < var; i++) next[i] = -1;\n\t\t}\n\t};\n\tvector<int> unite(const vector<int>& a, const vector<int>& b) {\n\t\tvector<int> res;\n\t\tset_union(a.begin(), a.end(), b.begin(), b.end(), back_inserter(res));\n\t\treturn move(res);\n\t}\n\tint n;\n\tvector<ac_node> dat;\npublic:\n\taho_corasick(const vector<string>& Ts) : n(Ts.size()), dat(1) {\n\t\tint now;\n\t\tdat[0].fail = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tauto &T = Ts[i];\n\t\t\tnow = 0;\n\t\t\tfor (auto c : T) {\n\t\t\t\tif (dat[now].next[trans(c)] == -1) {\n\t\t\t\t\tdat[now].next[trans(c)] = dat.size();\n\t\t\t\t\tdat.emplace_back();\n\t\t\t\t}\n\t\t\t\tnow = dat[now].next[trans(c)];\n\t\t\t}\n\t\t\tdat[now].ok.push_back(i);\n\t\t}\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < var; i++) {\n\t\t\tif (dat[0].next[i] == -1) {\n\t\t\t\tdat[0].next[i] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdat[dat[0].next[i]].fail = 0;\n\t\t\t\tq.push(dat[0].next[i]);\n\t\t\t}\n\t\t}\n\t\twhile (!q.empty()) {\n\t\t\tnow = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < var; i++) {\n\t\t\t\tif (dat[now].next[i] != -1) {\n\t\t\t\t\tint nx = dat[now].fail;\n\t\t\t\t\twhile (dat[nx].next[i] == -1) {\n\t\t\t\t\t\tnx = dat[nx].fail;\n\t\t\t\t\t}\n\t\t\t\t\tint nex = dat[now].next[i];\n\t\t\t\t\tdat[nex].fail = dat[nx].next[i];\n\t\t\t\t\tdat[nex].ok = unite(dat[nex].ok, dat[dat[nx].next[i]].ok);\n\t\t\t\t\tq.push(nex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint size() const {\n\t\treturn dat.size();\n\t}\n\tbool is_ok(int id) const {\n\t\treturn !dat[id].ok.empty();\n\t}\n\tint ok_cnt(int id) const {\n\t\treturn dat[id].ok.size();\n\t}\n\tint get_next(int id, char c) const {\n\t\twhile (dat[id].next[trans(c)] == -1) id = dat[id].fail;\n\t\treturn dat[id].next[trans(c)];\n\t}\n\tvector<int> count(const string& S) const {\n\t\tvector<int> res(n);\n\t\tint now = 0;\n\t\tfor (auto c : S) {\n\t\t\tnow = get_next(now, c);\n\t\t\tfor (auto k : dat[now].ok) res[k]++;\n\t\t}\n\t\treturn res;\n\t}\n\tvector<vector<int>> all_count(const string& S) const {\n\t\tint N = S.size();\n\t\tvector<vector<int>> res(N);\n\t\tint now = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnow = get_next(now, S[i]);\n\t\t\tres[i] = dat[now].ok;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nunordered_map<int, mint> dp[501][500][2];\n\nint main()\n{\n\tint N, M, K;\n\twhile (cin >> N >> M >> K, N | M | K) {\n\t\tvector<string> f(N), t(N);\n\t\tvector<string> word;\n\t\tmap<string, int> dic;\n\t\tvector<vector<int>> g(500);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> f[i] >> t[i];\n\t\t\tif (!dic.count(f[i])) dic[f[i]] = word.size(), word.push_back(f[i]);\n\t\t\tif (!dic.count(t[i])) dic[t[i]] = word.size(), word.push_back(t[i]);\n\t\t\tint fid = dic[f[i]], tid = dic[t[i]];\n\t\t\tg[fid].push_back(tid);\n\t\t}\n\t\tN = word.size();\n\t\tg.resize(N);\n\t\tvector<string> ss(K);\n\t\tfor (int i = 0; i < K; i++) {\n\t\t\tcin >> ss[i];\n\t\t}\n\t\taho_corasick ac(ss);\n\t\tint sz = ac.size();\n\t\tvector<vector<pair<int, int>>> nex(N, vector<pair<int, int>>(sz));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tint cnt = 0;\n\t\t\t\tint it = j;\n\t\t\t\tfor (auto c : word[i]) {\n\t\t\t\t\tit = ac.get_next(it, c);\n\t\t\t\t\tcnt += ac.ok_cnt(it);\n\t\t\t\t}\n\t\t\t\tnex[i][j] = make_pair(cnt, it);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tdp[i][j][k].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tauto &p = nex[i][0];\n\t\t\tint pos = word[i].size();\n\t\t\tif (pos <= M && p.first < 2) dp[pos][i][p.first][p.second] += 1;\n\t\t}\n\t\tfor (int i = 1; i < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (auto to : g[j]) {\n\t\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\t\tfor (auto kv : dp[i][j][b]) {\n\t\t\t\t\t\t\tint k;\n\t\t\t\t\t\t\tmint val;\n\t\t\t\t\t\t\ttie(k, val) = kv;\n\t\t\t\t\t\t\tauto &p = nex[to][k];\n\t\t\t\t\t\t\tint pos = i + word[to].size(), c = b + p.first;\n\t\t\t\t\t\t\tif (pos <= M && c < 2) {\n\t\t\t\t\t\t\t\tdp[pos][to][c][p.second] += val;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmint res = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < sz; j++) {\n\t\t\t\tres += dp[M][i][1][j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  void init()\n  {\n    exist = accept = 0;\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nTrieNode nodes[600];\n\nstruct Trie\n{\n  int ptr;\n\n  Trie()\n  {\n    nodes[0].init();\n    ptr = 1;\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[ptr].init();\n        nodes[node_index].nxt[c] = ptr++;\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return (ptr);\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< int, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define reps(i,j,k) for(int i=(j);i<=(k);++i)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define sz size()\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<class T> ostream & operator<<(ostream &os,const vector<T> &t){os<<\"{\";rep(i,t.size()){os<<t[i]<<\",\";}os<<\"}\"<<endl;return os;}\ntemplate<class T,class S> ostream& operator<<(ostream &os,const pair<T,S> &o){os<<\"(\"<<o.X<<\",\"<<o.Y<<\")\";return os;}\n\nclass Matcher{\npublic:\n  struct PMA{\n    int next[256];\n    vector<int> ac;\n    PMA(){fill(next,next+256,-1);}\n  };\n  vector<PMA> states;\n\n  Matcher(const vector<string> &pats){\n    states.pb(PMA());\n    rep(i,pats.size()){\n      int cur=0;\n      for(const char &c:pats[i]){\n\tif(states[cur].next[c]<0){\n\t  states[cur].next[c]=states.size();\n\t  states.pb(PMA());\n\t}\n\tcur=states[cur].next[c];\n      }\n      states[cur].ac.pb(i);\n    }\n    queue<int> q;\n    rep(c,256)if(c){\n      if(states[0].next[c]>=0){\n\tstates[states[0].next[c]].next[0]=0;\n\tq.push(states[0].next[c]);\n      }else{\n\tstates[0].next[c]=0;\n      }\n    }\n    while(!q.empty()){\n      int t=q.front();\n      q.pop();\n      rep(c,256)if(c){\n\tif(states[t].next[c]>=0){\n\t  q.push(states[t].next[c]);\n\t  int r=states[t].next[0];\n\t  while(states[r].next[c]<0){r=states[r].next[0];}\n\t  states[states[t].next[c]].next[0]=states[r].next[c];\n\t}\n      }\n    }\n    for(int i=0;i<pats.size();++i){\n      const string &pat=pats[i];\n      rep(j,states.size())if(j){\n\tint cur=j,k=0;\n\tfor(;k<pat.size();++k){\n\t  if(states[cur].next[pat[k]]<0) break;\n\t  cur=states[cur].next[pat[k]];\n\t}\n\tif(k==pat.size()){states[cur].ac.pb(i);}\n      }\n    }\n  }\n  int match(const string &str,int &res,int state=0){\n    res=0;\n    rep(i,str.size()){\n      char c=str[i];\n      while(states[state].next[c]<0){state=states[state].next[0];}\n      state=states[state].next[c];\n      rep(j,states[state].ac.size())\n\t++res;\n    }\n    return state;\n  }\n  int stateNum() const {return states.size();}\n};\n\ntypedef pair<string,string> pss;\ntypedef vector<vector<int>> Graph;\n\n//pos*words*aho*match\nll dp[30][312][612][2];\nconst ll MOD=1e9+7;\n\nint main(){\n  int e,l,m;\n  while(cin>>e>>l>>m,e){\n    memset(dp,0,sizeof(dp));\n    vector<pss> stre(e);\n    rep(i,e)\n      cin>>stre[i].X>>stre[i].Y;\n    vector<string> toi;\n    rep(i,e){\n      toi.pb(stre[i].X); toi.pb(stre[i].Y);\n    }\n    sort(all(toi));\n    toi.erase(unique(all(toi)),toi.end());\n    //cout<<toi;\n    int n=toi.size();\n    Graph g(n);\n    rep(i,e){\n      g[lower_bound(all(toi),stre[i].X)-toi.begin()].\n\tpb(lower_bound(all(toi),stre[i].Y)-toi.begin());\n    }\n    //cout<<g;\n\n    vector<string> sea(m);\n    rep(i,m)\n      cin>>sea[i];\n    Matcher matcher(sea);\n    int vs=matcher.states.size();\n    /* rep(i,vs){\n      cout<<i<<\":\"<<endl;\n      cout<<\"fail:\"<<matcher.states[i].next[0]<<endl;\n      for(char c:string(\"ahnskur\"))\n\tcout<<c<<\":\"<<matcher.states[i].next[c]<<endl;\n      cout<<endl;\n      }*/\n    vector<vector<pii>> mov(n,vector<pii>(vs));\n    rep(i,n)rep(j,vs){\n      int res;\n      int x=matcher.match(toi[i],res,j);\n      mov[i][j]=pii(x,res);\n    }\n    //cout<<mov;\n    int res;\n    rep(i,n){\n      int x=matcher.match(toi[i],res);\n      if(res<2)\n\tdp[toi[i].size()][i][x][res]=1;\n    }\n    rep(pos,l){\n      rep(wd,n)rep(v,vs)rep(t,2){\n\tfor(int w:g[wd]){\n\t  int x=matcher.match(toi[w],res,v);\n\t  //cout<<w<<\",\"<<x<<\",\"<<res+t<<\",\"<<pos<<\",\"<<wd<<\",\"<<v<<\",\"<<t<<endl;\n\t  if(res+t<2)\n\t    (dp[(pos+toi[w].size())%30][w][x][res+t]+=dp[pos%30][wd][v][t])%=MOD;\n\t}\n      }\n      //rep(wd,n){rep(v,vs)cout<<\"(\"<<dp[pos%30][wd][v][0]<<\",\"<<dp[pos%30][wd][v][1]<<\"),\";cout<<endl;}cout<<endl;\n      fill(dp[pos%30][0][0],dp[pos%30][0][0]+312*612*2,0);\n    }\n    ll re=0;\n    rep(w,n)rep(v,vs)\n      (re+=dp[l%30][w][v][1])%=MOD;\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[521];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tfor(int i=0;i<521;i++)dp[i].clear();\n\t\tvector<int> to[250];\n\t\tstring str[250];\n\t\tmap<string,int> id;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tint len=i+str[dest].size();\n\t\t\t\t\t\tmap<S,int>::iterator it2=dp[len].find(t);\n\t\t\t\t\t\tif(it2==dp[len].end())it2=dp[len].insert(make_pair(t,0)).first;\n\t\t\t\t\t\tADD(it2->second,it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tfor(int i='a';i<='z';i++){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst){\n\t\t\t\t\tint q=p;\n\t\t\t\t\twhile(q && !states[q].next[i]) q = states[q].failure;\n\t\t\t\t\tstates[p].next[i] = states[q].next[i];\n\t\t\t\t}else{\n\t\t\t\t\tq.push(dst);\n\t\t\t\t\tint f = states[p].failure;\n\t\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\t\tif(p){\n\t\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\treturn states[p].next[c];\n\t}\n\tpair<int, int> apply(const string &s, int p=0){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn make_pair(p, res);\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nunordered_map<int, unordered_map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tconst int p = p_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tauto res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res.second > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res.second][*v][res.first], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\n#define AHOSIZE 256\n\nstruct Aho;\n\nconst int mod = 1000000007;\nint N,M,K;\nmap<Aho*,int> memo;\nvector<int> dict[500];\nstring from[250], to[250];\n\nstruct Aho{\n    string str;\n    Aho *next[AHOSIZE], *fail;\n\n    Aho(){\n        int i,j;\n        fail = NULL;\n        rep(i,AHOSIZE) next[i] = NULL;\n    }\n    ~Aho(){\n        int i;\n        rep(i,AHOSIZE) if( next[i] ) delete next[i];\n    }\n\n    void insert(const string& in){\n        int i,n = in.length();\n        Aho *now = this;\n\n        rep(i,n){\n            if( now->next[in[i]] == NULL ){\n                now->next[in[i]] = new Aho();\n            }\n            now = now->next[in[i]];\n        }\n        now->str = in;\n    }\n\n    // failツづーツ催ャツづゥ\n    void build(){\n        int i;\n        queue<Aho*> q;\n        q.push(this);\n        \n        while( !q.empty() ){\n            Aho *now = q.front();\n            q.pop();\n            \n            rep(i,AHOSIZE) if( now->next[i] ) {\n                q.push(now->next[i]);\n\n                Aho *r = now->fail;\n                while( r != NULL && r->next[i] == NULL ) r = r->fail;\n                if( r != NULL ){\n                    now->next[i]->fail = r->next[i];\n                }\n                else{\n                    now->next[i]->fail = this;\n                }\n            }\n        }\n    }\n\n    Aho* match(Aho* root, const string& in, int* hit){\n        int i, n = in.length();\n        Aho *now = root;\n        \n        rep(i,n){\n            if( now->next[in[i]] ){\n                now = now->next[in[i]];\n            }\n            else{\n                while( now != this ){\n                    now = now->fail;\n                    if( now->next[in[i]] ){\n                        now = now->next[in[i]];\n                        break;\n                    }\n                }\n            }\n            \n            // ツつアツつアツづ個渉按猟敖づ債δδつ可サツつキツづゥツつアツづづ債つ堕ャツ可サツづつォツづゥ\n            /*\n              [now] = hit\n             */\n            \n            Aho* tmp = now;\n            \n            // ツ全ツ探ツ催オ\n            /*\n            while( tmp != this ){\n                if( tmp->str != \"\" ) ++*hit;\n                if( *hit >= 2 ) return NULL;\n                tmp = tmp->fail;\n            }\n            */\n            \n            // ツδδつ可サ\n            \n            if( memo.count(now) ){\n                *hit += memo[now];\n                if( *hit >= 2 ) return NULL;\n            }\n            else{\n                int cc = 0;\n                while( tmp != NULL ){\n                    if( tmp->str != \"\" ){\n                        cc++;\n                    }\n                    tmp = tmp->fail;\n                    if( memo.count(tmp) ) break;\n                }\n                if( tmp == NULL ){\n                    memo[now] = cc;\n                    *hit += cc;\n                }\n                else{\n                    memo[now] = memo[tmp] + cc;\n                    *hit += memo[tmp] + cc;\n                }\n                if( *hit >= 2 ) return NULL;\n            }\n            \n            \n        }\n\n        return now;\n    }\n\n};\n\n\nstruct state{\n    int from,cnt;\n    Aho* node;\n    state(int f, int c, Aho *n){\n        from = f, cnt = c, node = n;\n    }\n    bool operator<(const state& a)const{\n        if( cnt != a.cnt ) return cnt < a.cnt;\n        if( node != a.node ) return node < a.node;\n        return from < a.from;\n    }\n};\n\nmap<state,int> dp[550];\n\nint main(){\n    int i,j;\n\n    while( cin >> N >> M >> K, N|M|K ){\n        // init\n        rep(i,550) dp[i].clear();\n        rep(i,500) dict[i].clear();\n        memo.clear();\n\n\n        Aho Ahoinit;\n        set<string> ss;\n\n\n        // dict[from is new index][ツ古つ青脳 = to is new index \n\n        // input\n        rep(i,N){\n            cin >> from[i] >> to[i];\n            ss.insert(from[i]);\n            ss.insert(to[i]);\n        }\n\n        //\n        vector<string> words(ss.begin(), ss.end());\n        rep(i,words.size()){\n            rep(j,N) if( words[i] == from[j] ) {\n                dict[i].push_back(lower_bound(all(words), to[j]) - words.begin());\n            }\n        }\n\n        rep(i,K){\n            string kigo; cin >> kigo;\n            Ahoinit.insert(kigo);\n        }\n        Ahoinit.build();\n\n        // start\n        rep(i,words.size()){\n            int cnt = 0;\n            Aho* next = Ahoinit.match(&Ahoinit, words[i], &cnt);\n            if( cnt < 2 ){\n                dp[words[i].length()][state(i,cnt,next)] = 1;\n            }\n        }\n        \n        rep(j,M){\n            foreach(it,dp[j]){\n                int f_id = it->first.from;\n                int cnt = it->first.cnt;\n                Aho *now = it->first.node;\n                int res = it->second;\n\n                rep(i,dict[f_id].size()){\n                    int t_id = dict[f_id][i];\n                    int n = words[t_id].length();\n                    if( j + n > M ) continue;\n\n                    int tcnt = cnt;\n                    Aho *next = Ahoinit.match(now, words[t_id], &tcnt);\n                    if( tcnt < 2 && next != NULL ){\n                        dp[j + n][state(t_id, tcnt, next)] += res;\n                        dp[j + n][state(t_id, tcnt, next)] %= mod;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        foreach(it,dp[M]) if( it->first.cnt == 1 ) {\n            ans += it->second;\n            ans %= mod;\n        }\n        cout << ans << endl;\n        \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n //   sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct AhoCorasick {\n  static const int SIZE = 128;\n  struct State {\n    int index;\n    int next[SIZE]; // next[0] is failuer link\n    vector<int> accept;\n    State(int index) : index(index) {\n      memset(next, -1, sizeof(next));\n    }\n  };\n\n  bool build;\n  vector<State> pma;\n  vector<int> lens;\n  //vector<string. strs;\n\n  AhoCorasick() {\n    build = false;\n    pma.clear();\n    pma.push_back(State(0));\n    lens.clear();\n    //strs.clear();\n  }\n\n  void AddString(const char *str) {\n    assert(!build);\n    int t = 0;\n    for (int i = 0; str[i]; i++) {\n      int c = str[i];\n      if (pma[t].next[c] == -1) {\n        int m = pma.size();\n        pma[t].next[c] = m;\n        pma.push_back(State(m));\n      }\n      t = pma[t].next[c];\n    }\n    pma[t].accept.push_back(lens.size());\n    lens.push_back(strlen(str));\n    //strs.push_back(str);\n  }\n\n  void BuildPMA() {\n    assert(!build);\n    queue<int> que;  // make failure link using bfs\n    for (int c = 1; c < SIZE; c++) {\n      if (pma[0].next[c] != -1) {\n        pma[pma[0].next[c]].next[0] = 0;\n        que.push(pma[0].next[c]);\n      } else {\n        pma[0].next[c] = 0;\n      }\n    }\n    while (!que.empty()) {\n      int t = que.front();\n      que.pop();\n      for (int c = 1; c < SIZE; c++) {\n        if (pma[t].next[c] != -1) {\n          que.push(pma[t].next[c]);\n          int r = pma[t].next[0];\n          while (pma[r].next[c] == -1) {\n            r = pma[r].next[0];\n          }\n          pma[pma[t].next[c]].next[0] = pma[r].next[c];\n          for (vector<int>::iterator it = pma[pma[r].next[c]].accept.begin(); it != pma[pma[r].next[c]].accept.end(); it++) {\n            pma[pma[t].next[c]].accept.push_back(*it);\n          }\n        }\n      }\n    }\n    build = true;\n  }\n\n  int OneMove(int index, int c) {\n    return pma[index].next[c] != -1 ?\n      pma[index].next[c] :\n      pma[index].next[c] = OneMove(pma[index].next[0], c);\n    //while (pma[index].next[c] == -1) { index = pma[index].next[0]; }\n    //return pma[index].next[c];\n  }\n\n  // return first match indices\n  vector<int> Match(const char *t) {\n    assert(build);\n    int index = 0;\n    vector<int> ret(lens.size(), -1);\n    int n = strlen(t);\n    for (int i = 0; i < n; i++) {\n      int c = t[i];\n      index = OneMove(index, c);\n      for (vector<int>::const_iterator it = pma[index].accept.begin(); it != pma[index].accept.end(); it++) {\n        if (ret[*it] != -1) { continue; }\n        ret[*it] = i - lens[*it] + 1;\n      }\n    }\n    return ret;\n  }\n};\n\ntypedef vector<vector<int> > Graph;\n\n//=======================================\n\nstruct State {\n  int depth;\n  int prev;\n  int index;\n  char exist;\n  State() {;}\n  State(int depth, int prev, int index, int exist) : depth(depth), prev(prev), index(index), exist(exist) {;}\n  bool operator<(const State &rhs) const {\n    if (depth != rhs.depth) { return depth < rhs.depth; }\n    if (prev != rhs.prev) { return prev < rhs.prev; }\n    if (index != rhs.index) { return index < rhs.index; }\n    return exist < rhs.exist;\n  }\n};\n\nll MOD = 1000000007;\nint n, m, k, s;\nGraph g;\nmap<string, int> mapto;\nstring mapfrom[1010];\nint len[1010];\nAhoCorasick aho;\nmap<State, int> memo;\npair<int, char> moveMemo[6001][1010];\n\n//===========================================\n\npair<int, int> Move(int index, int word) {\n  if (moveMemo[index][word].first != -1) { return moveMemo[index][word]; }\n  pair<int, int> ret(index, 0);\n  FORIT(it, mapfrom[word]) {\n    ret.first = aho.OneMove(ret.first, *it);\n    ret.second += aho.pma[ret.first].accept.size();\n  }\n  ret.second = min(ret.second, 2);\n  return moveMemo[index][word] = ret;\n}\n\nll calc(State state);\nll NextState(State state, int word) {\n  pair<int, char> result = Move(state.index, word);\n  State next = State(state.depth + len[word], word, result.first, state.exist + result.second);\n  return calc(next);\n}\n\nll calc(State state) {\n  //cout <<state.depth << \" \" << state.prev << \" \" << state.index << \" \" << (int)state.exist << endl;\n  if (state.exist >= 2) { return 0; }\n  if (state.depth > m) { return 0; }\n  if (state.depth == m) {\n    return state.exist == 1 ? 1 : 0;\n  }\n  if (memo.count(state)) { return memo[state]; }\n  ll ret = 0;\n  FORIT(it, g[state.prev]) {\n    ret = (ret + NextState(state, *it)) % MOD;\n  }\n  return memo[state] = ret;\n}\n\nchar str1[100], str2[100];\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &k), n|m|k) {\n    memo.clear();\n    aho = AhoCorasick();\n    MEMSET(moveMemo, -1);\n    mapto.clear();\n    s = 0;\n    g = Graph(n * 2);\n    REP(i, n) {\n      scanf(\"%s %s\", str1, str2);\n      if (!mapto.count(str1)) {\n        mapto[str1] = s++;\n        mapfrom[mapto[str1]] = str1;\n        len[mapto[str1]] = strlen(str1);\n      }\n      if (!mapto.count(str2)) {\n        mapto[str2] = s++;\n        mapfrom[mapto[str2]] = str2;\n        len[mapto[str2]] = strlen(str2);\n      }\n      g[mapto[str1]].push_back(mapto[str2]);\n    }\n    REP(i, k) {\n      scanf(\"%s\", str1);\n      aho.AddString(str1);\n    }\n    aho.BuildPMA();\n    assert(aho.pma.size() <= 6000);\n    ll ans = 0;\n    REP(i, s) {\n      ans = (ans + NextState(State(0, -1, 0, 0), i)) % MOD;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define MOD 1000000007 \n#define ADD(a,b) a=(a+b)%MOD \n\nclass PMA{//Aho-Corasick\n\tint id;\n\tint match;\n\tPMA *failure;\n\tPMA *next[256];\npublic:\n\tPMA(int id=0):id(id),match(0),failure(0){\n\t\tmemset(next,0,sizeof(next));\n\t}\n\t~PMA(){\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]&&next[i]!=this)delete next[i];\n\t\t}\n\t}\n\tint getID()const{return id;}\n\tint matched()const{return match;}\n\tvoid build(const vector<string> &p){\n\t\tint num=0;\n\t\tfor(int i=0;i<(int)p.size();i++){\n\t\t\tconst string &s=p[i];\n\t\t\tPMA *t=this;\n\t\t\tfor(int j=0;j<(int)s.size();j++){\n\t\t\t\tif(!t->next[s[j]])t->next[s[j]]=new PMA(++num);\n\t\t\t\tt=t->next[s[j]];\n\t\t\t}\n\t\t\tt->match++;\n\t\t}\n\t\tqueue<PMA*> q;\n\t\tfor(int i=0;i<256;i++){\n\t\t\tif(next[i]){\n\t\t\t\tq.push(next[i]);\n\t\t\t\tnext[i]->failure=this;\n\t\t\t}else next[i]=this;\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tPMA *t=q.front();q.pop();\n\t\t\tfor(int i=0;i<256;i++){\n\t\t\t\tif(t->next[i]){\n\t\t\t\t\tq.push(t->next[i]);\n\t\t\t\t\tPMA *r=t->failure->step(i);\n\t\t\t\t\tt->next[i]->failure=r;\n\t\t\t\t\tt->next[i]->match += r->match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPMA *step(char c)const{\n\t\tconst PMA *t=this;\n\t\twhile(!t->next[c])t=t->failure;\n\t\treturn t->next[c];\n\t}\n\tPMA *step(string s,int *n){\n\t\t*n=0;\n\t\tPMA *pma=this;\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tpma=pma->step(s[i]);\n\t\t\t*n += pma->matched();\n\t\t}\n\t\treturn pma;\n\t}\n};\n\n\nstruct S{\n\tint pre,hit;\n\tPMA *pma;\n\tS(){}\n\tS(int a,int b,PMA *c):pre(a),hit(b),pma(c){}\n\tbool operator<(S s)const{\n\t\tif(pre!=s.pre)return pre<s.pre;\n\t\tif(hit!=s.hit)return hit<s.hit;\n\t\treturn pma<s.pma;\n\t}\n};\n\nmap<S,int> dp[521];\n\nint main(){\n\tint n,m,k;\n\twhile(cin>>n>>m>>k,n|m|k){\n\t\tfor(int i=0;i<521;i++)dp[i].clear();\n\t\tvector<int> to[250];\n\t\tstring str[250];\n\t\tmap<string,int> id;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a,b;\n\t\t\tint x,y;\n\t\t\tcin>>a>>b;\n\t\t\tif(id.find(a)==id.end()){\n\t\t\t\tid.insert(make_pair(a,x=id.size()));\n\t\t\t\tstr[x]=a;\n\t\t\t}else x=id.find(a)->second;\n\t\t\tif(id.find(b)==id.end()){\n\t\t\t\tid.insert(make_pair(b,y=id.size()));\n\t\t\t\tstr[y]=b;\n\t\t\t}else y=id.find(b)->second;\n\t\t\tto[x].push_back(y);\n\t\t}\n\t\tvector<string> seasonword(k);\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcin>>seasonword[i];\n\t\t}\n\t\tPMA pma;\n\t\tpma.build(seasonword);\n\t\tfor(int i=0;i<id.size();i++){\n\t\t\tint n;\n\t\t\tPMA *p=pma.step(str[i],&n);\n\t\t\tif(n<=1)dp[str[i].size()].insert(make_pair(S(i,n,p),1));\n\t\t}\n\t\tfor(int i=1;i<m;i++){\n\t\t\tfor(map<S,int>::iterator it=dp[i].begin();it!=dp[i].end();++it){\n\t\t\t\tconst S &s=it->first;\n\t\t\t\tfor(int j=0;j<to[s.pre].size();j++){\n\t\t\t\t\tint dest=to[s.pre][j];\n\t\t\t\t\tint n;\n\t\t\t\t\tPMA *p=s.pma->step(str[dest],&n);\n\t\t\t\t\tif(s.hit+n<=1){\n\t\t\t\t\t\tS t(dest,s.hit+n,p);\n\t\t\t\t\t\tADD(dp[i+str[dest].size()][t],it->second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(map<S,int>::iterator it=dp[m].begin();it!=dp[m].end();++it){\n\t\t\tif(it->first.hit==1)ADD(ans,it->second);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m,k,K;\nvector<string> vs,vs2;\nstring f[255],t[255],ss[255];\nint fid[255],tid[255],tid2[255];\nint nxt[601][26];\nshort wnxt[601][505];\nshort wcnt[601][505];\nvector<P> vec[255];\nvector<short> v2[605][505];\nint cnt[601];\n\nvoid init(){\n\tvector<string> pfx;\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j<=ss[i].size();j++){\n\t\t\tpfx.push_back(ss[i].substr(0,j));\n\t\t}\n\t}\n\tsort(pfx.begin(),pfx.end());\n\tpfx.erase(unique(pfx.begin(),pfx.end()),pfx.end());\n\tK=pfx.size();\n\tfor(int i=0;i<K;i++){\n\t\tcnt[i]=0;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tcnt[i]+=ss[j].size()<=pfx[i].size() && pfx[i].substr(pfx[i].size()-ss[j].size(),ss[j].size())==ss[j];\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tstring s=pfx[i];\n\t\t\ts+=('a'+j);\n\t\t\tint kk=0;\n\t\t\twhile(1){\n\t\t\t\tkk=lower_bound(pfx.begin(),pfx.end(),s)-pfx.begin();\n\t\t\t\tif(kk<K && pfx[kk]==s)break;\n\t\t\t\ts=s.substr(1);\n\t\t\t}\n\t\t\tnxt[i][j]=kk;\n\t\t}\n\t}\n\tfor(int i=0;i<vs2.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tint cur=j;\n\t\t\tint ccnt=0;\n\t\t\tfor(int l=0;l<vs2[i].size();l++){\n\t\t\t\tcur=nxt[cur][(vs2[i][l]-'a')];\n\t\t\t\tccnt+=cnt[cur];\n\t\t\t}\n\t\t\twnxt[i][j]=cur;\n\t\t\twcnt[i][j]=ccnt;\n\t\t}\n\t}\n}\n\nint dp[25][251][601][2];\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tcin >> f[i] >> t[i];\n\t\tvs.push_back(f[i]);\n\t\tvs2.push_back(f[i]);\n\t\tvs2.push_back(t[i]);\n\t}\n\tvs.push_back(\"\");\n\tsort(vs.begin(),vs.end());\n\tvs.erase(unique(vs.begin(),vs.end()),vs.end());\n\tsort(vs2.begin(),vs2.end());\n\tvs2.erase(unique(vs2.begin(),vs2.end()),vs2.end());\n\tfor(int i=0;i<n;i++){\n\t\tfid[i]=lower_bound(vs.begin(),vs.end(),f[i])-vs.begin();\n\t\ttid[i]=lower_bound(vs.begin(),vs.end(),t[i])-vs.begin();\n\t\ttid2[i]=lower_bound(vs2.begin(),vs2.end(),t[i])-vs2.begin();\n\t\tif(tid[i]==vs.size() || vs[tid[i]]!=t[i]){\n\t\t\tv2[fid[i]][t[i].size()].push_back(tid2[i]);\n\t\t}else{\n\t\t\tvec[fid[i]].push_back(P(tid[i],tid2[i]));\n\t\t}\n\t}\n\tfor(int i=1;i<vs.size();i++){\n\t\tint v=lower_bound(vs2.begin(),vs2.end(),vs[i])-vs2.begin();\n\t\tvec[0].push_back(P(i,v));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin >> ss[i];\n\t}\n\tinit();\n\tint ans=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tint val=dp[i%25][j][k][l];\n\t\t\t\t\tif(val==0)continue;\n\t\t\t\t\t//printf(\"%d %d %d %d %d\\n\",i,j,k,l,val);\n\t\t\t\t\tfor(int a=0;a<vec[j].size();a++){\n\t\t\t\t\t\tP p=vec[j][a];\n\t\t\t\t\t\tint ni=i+vs[p.first].size();\n\t\t\t\t\t\tif(ni>m)continue;\n\t\t\t\t\t\tni%=25;\n\t\t\t\t\t\tint nj=p.first;\n\t\t\t\t\t\tint nk=wnxt[p.second][k];\n\t\t\t\t\t\tint nl=wcnt[p.second][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tdp[ni][nj][nk][nl]+=val;\n\t\t\t\t\t\tif(dp[ni][nj][nk][nl]>=MOD){\n\t\t\t\t\t\t\tdp[ni][nj][nk][nl]-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int a=0;a<v2[j][m-i].size();a++){\n\t\t\t\t\t\tint p=v2[j][m-i][a];\n\t\t\t\t\t\tint nl=wcnt[p][k]+l;\n\t\t\t\t\t\tif(nl>=2)continue;\n\t\t\t\t\t\tans+=val;\n\t\t\t\t\t\tif(ans>=MOD){\n\t\t\t\t\t\t\tans-=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i%25][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<vs.size();i++){\n\t\tfor(int j=0;j<K;j++){\n\t\t\tans+=dp[m%25][i][j][1];\n\t\t\tif(ans>=MOD)ans-=MOD;\n\t\t}\n\t}\n\tfor(int i=0;i<25;i++){\n\t\tfor(int j=0;j<vs.size();j++){\n\t\t\tfor(int k=0;k<K;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tdp[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n} \n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tif(n==0 && m==0 && k==0)break;\n\t\tfor(int i=0;i<vs.size();i++){\n\t\t\tvec[i].clear();\n\t\t}\n\t\tfor(int i=0;i<vs2.size();i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tv2[i][j].clear();\n\t\t\t}\n\t\t}\n\t\tvs.clear();\n\t\tvs2.clear();\n\t\tsolve();\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nstruct state{\n  int n,m,f;\n  string str;\n  state(){}\n  state(int n,int m,int f,string str) : n(n),m(m),f(f),str(str){}\n  bool operator<(const state& st) const{\n    if( n == st.n )\n      if( m == st.m )\n\tif( f == st.f )\n\t  return str < st.str;\n\telse\n\t  return f < st.f;\n      else\n\treturn m < st.m;\n    else\n      return n < st.n;\t    \n  }\n};\nunordered_map<string,int> S;\nmap<state,int> dp;\n\nint N,M,K;\nvector<int> G[505];\nstring Sm[515];\nstring Sk[55];\nunordered_map<string,pair<string,int>> mcp;\nvoid init(){\n  mcp.clear();\n  dp.clear();\n  for(int i=0;i<(int)S.size();i++)\n    G[i].clear();\n  S.clear();\n\n}\n\npair<string,int> check(const string &s){\n  if( mcp.count(s) != 0 ){\n    return mcp[s];\n  }\n  int cnt = 0;\n  string ret = \"\";\n  for(int j=0;j<(int)s.size();j++){\n    string ss = s.substr(j);\n    for(int i=0;i<K;i++){\n      \n      if( ss.size() > Sk[i].size() ){\n\tif( ss.substr(0,Sk[i].size()) == Sk[i] ) cnt++;\n      } else if( ss.size() < Sk[i].size() ){\n\tif( ss == Sk[i].substr(0,ss.size()) )\n\t  if( ret == \"\" ) ret = ss;\n      } else {\n\tif( ss == Sk[i] ) cnt++;\n      }      \n    }\n  }\n  return mcp[s] = {ret,cnt};\n} \nconst int MOD = 1000000007;\nvoid add(int &a,int b){\n  a+=b;\n  a%=MOD;\n}\n\nint solve(int n,int m,int cnt,string str){\n  int ret=0;\n  if( dp.count( state(n,m,cnt,str) ) != 0 ) return dp[{n,m,cnt,str}];\n\n  if( m == M ) {\n    //cout << \"return \" << n << \" \"<< cnt << \" \" << str << \" \" << Sm[n] << endl;\n    return dp[{n,m,cnt,str}] = cnt;\n  }\n  \n  for(int i=0;i<(int)G[n].size();i++){\n    int to = G[n][i];\n    int nm = m + Sm[to].size();\n    if( nm > M ) continue;\n    string rs = str + Sm[to];\n    pair<string,int> np = check(rs);\n    int nct = cnt + np.second - check(str).second;\n    rs = np.first;\n    if( nct > 1 ) continue;\n    add(ret,solve( to, nm, nct, rs )); \n  }\n  //    cout << N << \" \" << M << \" \" << K << endl;\n  //cout << n << \" \" << m << \" \" << cnt << \" \" << str << \" \" << Sm[n] << \" \"<< ret << endl; \n  \n  return dp[{n,m,cnt,str}] = ret;\n}\n\nint main(){\n  while( cin >> N >> M >> K && (N|M|K) ){\n    init();\n    //cout << N << \" \" << M << \" \"<< K << endl;\n    for(int i=0;i<N;i++){\n      string from,to;\n      cin >> from >> to;\n      if( S.count(from) == 0 )\n\tS[from] = S.size()-1;\n      if( S.count(to) == 0 )\n\tS[to] = S.size()-1;\n      G[S[from]].push_back(S[to]);\n      Sm[S[from]] = from;\n      Sm[S[to]] = to;\n    }\n    //cout << S.size() << endl;    \n    for(int i=0;i<K;i++)\n      cin >> Sk[i];\n\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      string rs = Sm[i];\n      auto np = check(rs);\n      rs = np.first;\n      int cnt = np.second;\n      if(cnt>1) continue;\n      add( res, solve(i,Sm[i].size(),cnt,rs) );\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = double;\nconst ld eps = 1e-9;\n//\n//using Graph = vector<vector<int>>;\n//\n//int dfs(const Graph&g, const int now, vector<int>&ch_cnts) {\n//\tch_cnts[now]++;\n//\tfor (auto&& e : g[now]) {\n//\t\tch_cnts[now] += dfs(g, e, ch_cnts);\n//\t}\n//\treturn ch_cnts[now];\n//}\n//\n//struct HL_Edge {\n//\tint from;\n//\tint to;\n//\tbool heavy;\n//};\n//\n//void dfs2(const Graph&g, vector<vector<HL_Edge>>&hl_tree, const int now, const vector<int>&ch_cnts) {\n//\n//\tint max_ch_id = 1;\n//\t{\n//\t\tint max_ch_num = -1;\n//\t\tfor (auto&&e : g[now]) {\n//\t\t\tif (max_ch_num < ch_cnts[e]) {\n//\t\t\t\tmax_ch_num = ch_cnts[e];\n//\t\t\t\tmax_ch_id = e;\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (auto e : g[now]) {\n//\t\tbool heavy = (e == max_ch_id);\n//\n//\t\thl_tree[now].push_back(HL_Edge{ now,e,heavy });\n//\t}\n//\treturn;\n//}\n//\n//void HL(const vector<vector<int>>&ro_tree) {\n//\tvector<int>ch_cnts(ro_tree.size());\n//\n//\tdfs(ro_tree, 0, ch_cnts);\n//\n//\tvector<vector<HL_Edge>>hl_tree(ro_tree.size());\n//\n//\tdfs2(ro_tree, hl_tree, 0, ch_cnts);\n//}\n//\n//namespace FastFourierTransform\n//{\n//\tusing C = complex< double >;\n//\n//\tvoid DiscreteFourierTransform(vector< C > &F, bool rev)\n//\t{\n//\t\tconst int N = (int)F.size();\n//\t\tconst double PI = (rev ? -1 : 1) * acos(-1);\n//\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n//\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n//\t\t\tif (i > j) swap(F[i], F[j]);\n//\t\t}\n//\t\tC w, s, t;\n//\t\tfor (int i = 1; i < N; i <<= 1) {\n//\t\t\tfor (int k = 0; k < i; k++) {\n//\t\t\t\tw = polar(1.0, PI / i * k);\n//\t\t\t\tfor (int j = 0; j < N; j += i * 2) {\n//\t\t\t\t\ts = F[j + k];\n//\t\t\t\t\tt = C(F[j + k + i].real() * w.real() - F[j + k + i].imag() * w.imag(),\n//\t\t\t\t\t\tF[j + k + i].real() * w.imag() + F[j + k + i].imag() * w.real());\n//\t\t\t\t\tF[j + k] = s + t, F[j + k + i] = s - t;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tif (rev) for (int i = 0; i < N; i++) F[i] /= N;\n//\t}\n//\n//\tvector< int> Multiply(const vector<int > &A, const vector<int > &B)\n//\t{\n//\t\tint sz = 1;\n//\t\twhile (sz <= A.size() + B.size()) sz <<= 1;\n//\t\tvector< C > F(sz), G(sz);\n//\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n//\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n//\t\tDiscreteFourierTransform(F, false);\n//\t\tDiscreteFourierTransform(G, false);\n//\t\tfor (int i = 0; i < sz; i++) F[i] *= G[i];\n//\t\tDiscreteFourierTransform(F, true);\n//\t\tvector< int > X(A.size() + B.size() - 1);\n//\t\tfor (int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n//\t\treturn (X);\n//\t}\n//};\n\nstruct PMA {\n\tvector<shared_ptr<PMA>>chs;\n\n\tshared_ptr<PMA>fail;\n\n\n\tint valid;\n\n\tPMA() : chs(26), fail(nullptr),valid(-1) {\n\n\t}\n\t\n};\nshared_ptr<PMA> buildPMA(const vector<string>&sts) {\n\n\tshared_ptr<PMA>root(make_shared<PMA>());\n\t//root->fail=root;\n\tfor (int j=0;j<sts.size();++j) {\n\n\t\tshared_ptr<PMA>now(root);\n\t\tfor (int i = 0; i < sts[j].size(); ++i) {\n\t\t\tauto next=now->chs[sts[j][i]-'a'];\n\t\t\tif (next == nullptr) {\n\t\t\t\tnow->chs[sts[j][i]-'a']=make_shared<PMA>();\n\t\t\t\tnext=now->chs[sts[j][i]-'a'];\n\t\t\t}\n\n\t\t\tnow=next;\n\n\t\t}\n\t\tnow->valid=j;\n\t}\n\tqueue<shared_ptr<PMA>>que;\n\tfor(int i=0;i<26;++i) {\n\t\tif (root->chs[i]) {\n\t\t\troot->chs[i]->fail = root;\n\t\t\tque.push(root->chs[i]);\n\t\t}\n\t\telse root->chs[i] = root;\n\t}\n\n\twhile (!que.empty()) {\n\t\tauto afront(que.front());\n\t\tque.pop();\n\n\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\tif (afront->chs[i]) {\n\n\t\t\t\tauto r=afront->fail;\n\n\t\t\t\t\n\t\t\t\twhile (!r->chs[i])r = r->fail;\n\n\t\t\t\tafront->chs[i]->fail = r->chs[i];\n\n\t\t\t\tque.push(afront->chs[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//auto it=root->chs[0]->chs[2]->chs[3]->fail;\n\treturn root;\n}\n\nstruct voca {\n\tstring name;\n\tvector<int>edges;\n\tbool kigo;\n};\nconst long long int mod=1e9+7;\nint main() {\n\twhile (true) {\n\t\tint N, M, K; cin >> N >> M >> K;\n\n\t\tif(!N)break;\n\n\t\tvector<string>sts;\n\t\tvector<vector<int>>edges(2 * N + K);\n\t\tvector<int>valids(2 * N + K);\n\t\t{\n\t\t\tint n_id = 0;\n\t\t\tmap<string, int>mp;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tstring a, b; cin >> a >> b;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tif (mp.find(b) == mp.end()) {\n\t\t\t\t\tmp[b] = n_id++;\n\t\t\t\t\tsts.push_back(b);\n\t\t\t\t}\n\t\t\t\tedges[mp[a]].push_back(mp[b]);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < K; ++i) {\n\t\t\t\tstring a; cin >> a;\n\t\t\t\tif (mp.find(a) == mp.end()) {\n\t\t\t\t\tmp[a] = n_id++;\n\t\t\t\t\tsts.push_back(a);\n\t\t\t\t}\n\t\t\t\tvalids[mp[a]] = true;\n\t\t\t}\n\n\t\t\tvalids.erase(valids.begin() + sts.size(), valids.end());\n\t\t\tedges.erase(edges.begin() + sts.size(), edges.end());\n\t\t}\n\n\t\tauto root = buildPMA(sts);\n\n\t\tstruct aa {\n\t\t\tshared_ptr<PMA>now;\n\t\t\tint now_st_id;\n\t\t\tint now_st_po;\n\t\t\tint now_kigo;\n\n\t\t\tconst bool operator<(const aa&l)const {\n\t\t\t\treturn this->now == l.now ?\n\t\t\t\t\tthis->now_st_id == l.now_st_id ?\n\t\t\t\t\tthis->now_st_po == l.now_st_po ?\n\t\t\t\t\tthis->now_kigo<l.now_kigo :\n\t\t\t\t\tthis->now_st_po<l.now_st_po :\n\t\t\t\t\tthis->now_st_id<l.now_st_id :\n\t\t\t\t\tthis->now<l.now;\n\t\t\t}\n\t\t};\n\t\tmap<aa, long long int>now_mp;\n\t\tfor (int st_id = 0; st_id < sts.size() - K; ++st_id) {\n\n\t\t\tnow_mp[aa{ root,st_id,0,0 }] = 1;\n\t\t}\n\t\tfor (int time = 0; time < M; ++time) {\n\t\t\tmap<aa, long long int>next_mp;\n\n\t\t\tfor (auto nm : now_mp) {\n\t\t\t\tconst long long int num = nm.second;\n\n\n\t\t\t\tconst int now_kigo = nm.first.now_kigo;\n\t\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\t\tif (now_st_po == sts[now_st_id].size()) {\n\t\t\t\t\tfor (auto e : edges[now_st_id]) {\n\t\t\t\t\t\tint next_st_id = e;\n\t\t\t\t\t\tint next_st_po = 1;\n\t\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tassert(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint next_st_id = now_st_id;\n\t\t\t\t\tint next_st_po = now_st_po + 1;\n\t\t\t\t\tshared_ptr<PMA>now_pma(nm.first.now);\n\n\t\t\t\t\tint i = sts[next_st_id][next_st_po - 1] - 'a';\n\t\t\t\t\twhile (!now_pma->chs[i]) {\n\t\t\t\t\t\tnow_pma = now_pma->fail;\n\t\t\t\t\t}\n\t\t\t\t\tauto ch = now_pma->chs[i];\n\n\t\t\t\t\tif (ch == now_pma) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (ch) {\n\t\t\t\t\t\tint next_kigo = now_kigo;\n\t\t\t\t\t\tif (ch->valid >= 0) {\n\t\t\t\t\t\t\tnext_kigo += valids[ch->valid];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto next_aa = aa{ ch,next_st_id,next_st_po,next_kigo };\n\t\t\t\t\t\tnext_mp[next_aa] += num;\n\t\t\t\t\t\tnext_mp[next_aa] %= mod;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassert(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tnow_mp = next_mp;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (auto nm : now_mp) {\n\t\t\tconst int now_st_id = nm.first.now_st_id;\n\t\t\tconst int now_st_po = nm.first.now_st_po;\n\t\t\tif (nm.first.now_kigo == 1 && now_st_po == sts[now_st_id].size()) {\n\t\t\t\tans += nm.second;\n\t\t\t}\n\t\t}\n\t\tcout << ans%mod << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct TrieNode\n{\n  int nxt[27];\n\n  int exist; // ???????????\\???????????¨????????????????????°???????¨?\n  int accept;\n\n  void init()\n  {\n    exist = accept = 0;\n    memset(nxt, -1, sizeof(nxt));\n  }\n};\n\nTrieNode nodes[600];\n\nstruct Trie\n{\n  int ptr;\n\n  Trie()\n  {\n    nodes[0].init();\n    ptr = 1;\n  }\n\n  virtual void direct_action(int node, int id) {}\n\n  virtual void child_action(int node, int child, int id) {}\n\n  void update_direct(int node, int id)\n  {\n    ++nodes[node].accept;\n    direct_action(node, id);\n  }\n\n  void update_child(int node, int child, int id)\n  {\n    ++nodes[node].exist;\n    child_action(node, child, id);\n  }\n\n  void add(const string &str, int str_index, int node_index, int id)\n  {\n    if(str_index == str.size()) {\n      update_direct(node_index, id);\n    } else {\n      const int c = str[str_index] - 'a';\n      if(nodes[node_index].nxt[c] == -1) {\n        nodes[ptr].init();\n        nodes[node_index].nxt[c] = ptr++;\n      }\n      add(str, str_index + 1, nodes[node_index].nxt[c], id);\n      update_child(node_index, nodes[node_index].nxt[c], id);\n    }\n  }\n\n  void add(const string &str, int id)\n  {\n    add(str, 0, 0, id);\n  }\n\n  void add(const string &str)\n  {\n    add(str, nodes[0].exist);\n  }\n\n  int size()\n  {\n    return (nodes[0].exist);\n  }\n\n  int nodesize()\n  {\n    return (ptr);\n  }\n};\n\nstruct Aho_Corasick : Trie\n{\n  static const int FAIL = 26;\n\n  Aho_Corasick() : Trie() {}\n\n  void build()\n  {\n    queue< int > que;\n    for(int i = 0; i < 27; i++) {\n      if(~nodes[0].nxt[i]) {\n        nodes[nodes[0].nxt[i]].nxt[FAIL] = 0;\n        que.emplace(nodes[0].nxt[i]);\n      } else {\n        nodes[0].nxt[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      TrieNode &now = nodes[que.front()];\n      nodes[que.front()].accept += nodes[nodes[que.front()].nxt[FAIL]].accept;\n      que.pop();\n      for(int i = 0; i < 26; i++) {\n        if(now.nxt[i] == -1) continue;\n        int fail = now.nxt[FAIL];\n        while(nodes[fail].nxt[i] == -1) {\n          fail = nodes[fail].nxt[FAIL];\n        }\n        nodes[now.nxt[i]].nxt[FAIL] = nodes[fail].nxt[i];\n        que.emplace(now.nxt[i]);\n      }\n    }\n  }\n\n  pair< int, int > move(const string &str, int now = 0)\n  {\n    int match = 0;\n    for(auto &c : str) {\n      while(nodes[now].nxt[c - 'a'] == -1) now = nodes[now].nxt[FAIL];\n      now = nodes[now].nxt[c - 'a'];\n      match += nodes[now].accept;\n    }\n    return {now, match};\n  }\n};\n\n\nconst int mod = 1e9 + 7;\n\nint N, M, K;\nstring from[250], to[250];\nstring seasonword[30];\nunordered_map< unsigned short, int > dp[501][500][2];\n\nint main()\n{\n  while(cin >> N >> M >> K, N) {\n\n    vector< int > g[500];\n    vector< string > nums;\n\n    for(int i = 0; i < N; i++) {\n      cin >> from[i] >> to[i];\n      nums.push_back(from[i]);\n      nums.push_back(to[i]);\n    }\n    for(int i = 0; i < K; i++) {\n      cin >> seasonword[i];\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    for(int i = 0; i < N; i++) {\n      int u = lower_bound(begin(nums), end(nums), from[i]) - begin(nums);\n      int v = lower_bound(begin(nums), end(nums), to[i]) - begin(nums);\n      g[u].push_back(v);\n    }\n\n    Aho_Corasick aho;\n    for(int i = 0; i < K; i++) aho.add(seasonword[i]);\n    aho.build();\n\n    for(int i = 0; i < nums.size(); i++) {\n      if(nums.size() > M) continue;\n      auto get = aho.move(nums[i]);\n      if(nums.size() > M) continue;\n      dp[nums[i].size()][i][get.second][get.first] = 1;\n    }\n    for(int i = 1; i < M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) {\n          for(auto &v : dp[i][j][k]) {\n            for(auto &t : g[j]) {\n              if(i + nums[t].size() > M) continue;\n              auto get = aho.move(nums[t], v.first);\n              if(k + get.second > 1) continue;\n              (dp[i + nums[t].size()][t][k + get.second][get.first] += v.second) %= mod;\n            }\n          }\n          dp[i][j][k].clear();\n        }\n      }\n    }\n    int ret = 0;\n    for(int j = 0; j < nums.size(); j++) {\n      for(auto &v : dp[M][j][1]) (ret += v.second) %= mod;\n    }\n    cout << ret << endl;\n\n\n    for(int i = 1; i <= M; i++) {\n      for(int j = 0; j < nums.size(); j++) {\n        for(int k = 0; k < 2; k++) dp[i][j][k].clear();\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int mod = 1000000007;\nconst int TR=28;\n\nstruct PMA{\n  PMA *next[TR];\n  int ac;\n  PMA(){fill(next,next+TR,(PMA*)0);ac=0;}\n};\n\nconst int M = 31;\nPMA *buildPMA(string in[],int size,map<PMA*,int> &P){\n  PMA *root=new PMA;\n  P[root]=0;\n  rep(i,size){\n    PMA *t = root;\n    rep(j,(int)in[i].size()){\n      char c=in[i][j]-'a'+1;\n      if (t->next[c] == NULL){\n\tint ind=P.size();\n\tt->next[c]=new PMA;\n\tP[t->next[c]]=ind;\n      }\n      t=t->next[c];\n    }\n    t->ac++;\n  }\n  queue<PMA*> Q;\n  REP(i,1,TR){\n    char c=i;\n    if (root->next[c]){\n      root->next[c]->next[0]=root;\n      Q.push(root->next[c]);\n    }else root->next[c]=root;\n  }\n  \n  while(!Q.empty()){\n    PMA *t=Q.front();Q.pop();\n    //REP(c,'a','z'+1){\n    REP(c,1,TR){\n      if (t->next[c]){\n\tQ.push(t->next[c]);\t\n\tPMA *r=t->next[0];\n\twhile(!r->next[c])r=r->next[0];\n\tt->next[c]->next[0]=r->next[c];\n\tt->next[c]->ac+=r->next[c]->ac;\n      }\n    }\n  }\n  return root;\n}\n\n\nvoid travarse(PMA *now,char a,PMA* root,map<PMA*,int> &P){\n  cout <<\"now \" << (int)a << \" \" << now->ac << \" \"<< P[now] << endl;\n  rep(i,TR){\n    if (now->next[i] != NULL && \n\tnow->next[i] != root)travarse(now->next[i],i,root,P);\n  }\n}\n\npair<int,int> match(PMA *r,string &tar,map<PMA*,int> &P){\n  int ac=0;\n  rep(i,(int)tar.size()){\n    char c = tar[i]-'a'+1;\n    while(!r->next[c])r=r->next[0];\n    r=r->next[c];\n    ac+=r->ac;\n  }\n  return make_pair(P[r],ac);\n}\n\nconst int N = 501;\nconst int NODE=200;\nvector<int> edge[N];\nint move[NODE][N];//PMAstate,word -> nextPMA stace\nint ac[NODE][N];// PMAstate,wort -> num of ac\n\nvoid makeGraph(vector<string> &in,map<PMA*,int> &P){\n  map<PMA*,int>::iterator itr = P.begin();\n  while(itr != P.end()){\n    int id=(*itr).second;\n    rep(i,in.size()){\n      pair<int,int> tmp=match((*itr).first,in[i],P);\n      if (tmp.second <= 1){\n\tmove[id][i]=tmp.first;\n\tac[id][i]=tmp.second;\n      }\n    }\n    itr++;\n  }\n}\n\n\nconst int MOD=21;\nint dp[MOD][N][NODE][2];\nconst int ROOT=0;\nint solve(int len,int n,int pmasize,vector<int> &ini,vector<string> &all){\n  rep(i,MOD)rep(j,n)rep(k,pmasize)rep(l,2)dp[i][j][k][l]=0;\n  rep(i,ini.size()){\n    int id=ini[i];\n    int size=all[id].size();\n    if (size <= len && move[ROOT][id] != -1){\n      dp[size%MOD][id][move[ROOT][id]][ac[ROOT][id]]=1;\n    }\n  }\n  rep(i,len){\n    rep(j,n){\n      rep(k,(int)edge[j].size()){\n\tint readword=edge[j][k];\n\trep(l,pmasize){\n\t  rep(m,2){\n\t    int nextlen=i+all[readword].size();\n\t    int nextn=readword;\n\t    int nextpma=move[l][readword];\n\t    int nextac=m+ac[l][readword];\n\t    if (nextlen > len ||nextpma == -1 ||nextac == -1)continue;\n\t    if (nextac >= 2)continue;\n\t    nextlen%=MOD;\n\t    dp[nextlen][nextn][nextpma][nextac]=\n\t      (dp[nextlen][nextn][nextpma][nextac]+\n\t       dp[i%MOD][j][l][m])%mod;\n\t  }\n\t}\n      }\n    }\n    rep(j,n)rep(k,pmasize)rep(l,2)dp[i%MOD][j][k][l]=0;\n  }\n\n  int ret=0;\n  rep(i,n)rep(j,pmasize)ret=(ret+dp[len%MOD][i][j][1])%mod;\n  return ret;\n}\n\n\nint getindex(string &in,map<string,int> &M,vector<string> &a){\n  int index=M.size();\n  if (M.find(in) == M.end())M[in]=index,a.push_back(in);\n  return M[in];\n}\n\nmain(){\n  int n,len,m;\n  static string kigo[M];\n  while(cin>>n>>len>>m && n){\n    rep(i,N){\n      edge[i].clear();\n      rep(j,NODE){\n\tmove[j][i]=-1;\n\tac[j][i]=-1;\n      }\n    }\n    map<string,int> M;\n    map<PMA*,int> P;\n    vector<string> all;\n    vector<int> ini;\n    rep(i,n){\n      string f,t;\n      cin>>f>>t;\n      int tf=getindex(f,M,all),tt=getindex(t,M,all);\n      ini.push_back(tf);\n      edge[tf].push_back(tt);\n    }\n    rep(i,m)cin>>kigo[i];\n\n    PMA *root = buildPMA(kigo,m,P);\n    makeGraph(all,P);\n    sort(ini.begin(),ini.end());ini.erase(unique(ini.begin(),ini.end()),ini.end());\n  //  cout << solve(len,all.size(),P.size(),ini,all) << endl;\n    //cout<<\"end\"<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <map>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define DEB 0\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n/*----------------------------------------------------\n  Aho-Corasick\n  ----------------------------------------------------*/\nstruct PMA{\n  PMA *next[256]; // next[0] is for fail\n  vector<int> accept;\n  PMA(){ fill(next, next+256, (PMA*)0); }\n};\n\nPMA *buildPMA(const vector<string>& p){\n  PMA *root = new PMA;\n  rep(i,p.size()){ // make trie\n    PMA *t = root;\n    rep(j,p[i].size()){\n      char c = p[i][j];\n      if( t->next[c]==NULL ) t->next[c] = new PMA;\n      t = t->next[c];\n    }\n    t->accept.push_back(i);\n  }\n  queue<PMA*> q; // make failure link using bfs\n  // init \n  for(int c='a'; c<='z'; ++c){ // lower\n    if( root->next[c] ){\n      root->next[c]->next[0] = root;\n      q.push(root->next[c]);\n    }else{\n      root->next[c] = root;\n    }\n  }\n  while( !q.empty() ){\n    PMA *t = q.front(); q.pop();\n    for(int c='a'; c<='z'; ++c)if( t->next[c] ){  // lower\n      q.push(t->next[c]);\n      PMA *r = t->next[0];\n      while( !r->next[c] ){\n        r=r->next[0];\n      }\n      t->next[c]->next[0] = r->next[c];\n    }\n  }\n  return root;\n}\nPMA *next_PMA(const string& str, PMA *v, int *result){\n  PMA *ret = v;\n  rep(i,str.length()){\n    char c = str[i];\n    while( !ret->next[c] ) ret=ret->next[0];\n    ret = ret->next[c];\n#if DEB\n    printf(\"%c : %p  ac:%d\\n\",c,ret,ret->accept.size());\n    if( ret->next[0] ) printf(\"failed : %p  ac:%d\\n\",ret->next[0], ret->next[0]->accept.size());\n#endif    \n    //rep(j,ret->accept.size())result[ret->accept[j]]+++\n    *result += ret->accept.size();\n    if( ret->next[0] ) *result += ret->next[0]->accept.size();\n    if( *result>1 ) return ret;\n  }\n  return ret;\n}\n\nconst int mod = 1000000007;\nint n,m,k;\nbool edge[510][510];\nmap<string,int> ms;\nmap<PMA*,int> dp[2][510][510]; // [kigo][n][edge] [PMA]\nvector<string> kigo;\n\nint main(){\n  while(cin>>n>>m>>k,n|m|k){\n    kigo.clear();\n    ms.clear();\n    rep(i,510)rep(j,510){\n      dp[0][i][j].clear(); dp[1][i][j].clear();\n    }\n    memset(edge,false,sizeof(edge));\n    \n    rep(i,n){\n      string a,b; cin>>a>>b;\n      int c,d;\n      if( ms.count(a) ) c=ms[a]; else{ c=ms.size(); ms[a]=c; }\n      if( ms.count(b) ) d=ms[b]; else{ d=ms.size(); ms[b]=d; }\n      edge[c][d] = true;\n    }\n    rep(i,k){\n      string a; cin>>a;\n      kigo.push_back(a);\n    }\n    PMA *root = buildPMA(kigo);\n    \n    vector<string> vs(ms.size());\n    map<string,int>::iterator it;\n    for(it=ms.begin(); it!=ms.end(); it++){\n      vs[it->second] = it->first;\n    }\n   \n    set<PMA*> pm;\n    set<PMA*>::iterator itr;\n    // init\n    rep(i,vs.size()){\n      int re = 0;\n      PMA *ne = next_PMA(vs[i],root,&re);\n      int len = vs[i].size();\n      if( re<=1 ){\n        dp[re][len][i][ne]++;\n        pm.insert(ne);\n      }\n    }\n#if DEB\n    for(itr=pm.begin(); itr!=pm.end(); itr++){\n      printf(\"%p\\n\",*itr);\n    }\n#endif    \n    \n    REP(len,1,m){\n      rep(i,vs.size()){\n        for(itr=pm.begin(); itr!=pm.end(); itr++){\n          rep(u,2){\n            if( dp[u][len][i].count(*itr) ){\n              rep(j,vs.size())if( edge[i][j] && len+vs[j].length()<=m ){\n                int re = 0;\n                PMA *tmp = next_PMA(vs[j], *itr, &re);\n                int h = re+u;\n                if( h>1 )continue;\n#if DEB\n                printf(\"%s -> %s   len:%d  , u:%d  h:%d\\n\",vs[i].c_str(), vs[j].c_str(),len+vs[j].length(),u,h);\n#endif                \n                dp[h][len+vs[j].length()][j][tmp] =\n                  (dp[h][len+vs[j].length()][j][tmp] + dp[u][len][i][*itr] ) % mod;\n                pm.insert(tmp);\n              }\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    rep(i,vs.size()){\n      for(itr=pm.begin(); itr!=pm.end(); itr++){\n        ret = (ret + dp[1][m][i][*itr]) % mod;\n      }\n    }\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstring>\n\nusing namespace std;\n\nclass Matcher {\n\tstruct PMA {\n\t\tint next[256];\n\t\tvector<int> accept;\n\t\tPMA(){ fill(next, next + 256, -1); }\n\t};\n\tvector<PMA> states;\npublic:\n\tMatcher(const vector<string> &patterns){\n\t\t// Trie Ì¶¬\n\t\tstates.push_back(PMA());\n\t\tfor(int i = 0; i < patterns.size(); ++i){\n\t\t\tint cur = 0;\n\t\t\tfor(size_t j = 0; j < patterns[i].size(); ++j){\n\t\t\t\tchar c = patterns[i][j];\n\t\t\t\tif(states[cur].next[c] < 0){\n\t\t\t\t\tstates[cur].next[c] = static_cast<int>(states.size());\n\t\t\t\t\tstates.push_back(PMA());\n\t\t\t\t}\n\t\t\t\tcur = states[cur].next[c];\n\t\t\t}\n\t\t\tstates[cur].accept.push_back(i);\n\t\t}\n\t\t// failure link Ì¶¬\n\t\tqueue<int> q;\n\t\tfor(int c = 1; c < 256; ++c){\n\t\t\tif(states[0].next[c] >= 0){\n\t\t\t\tstates[states[0].next[c]].next[0] = 0;\n\t\t\t\tq.push(states[0].next[c]);\n\t\t\t}else{\n\t\t\t\tstates[0].next[c] = 0;\n\t\t\t}\n\t\t}\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int c = 1; c < 256; ++c){\n\t\t\t\tif(states[t].next[c] >= 0){\n\t\t\t\t\tq.push(states[t].next[c]);\n\t\t\t\t\tint r = states[t].next[0];\n\t\t\t\t\twhile(states[r].next[c] < 0){ r = states[r].next[0]; }\n\t\t\t\t\tstates[states[t].next[c]].next[0] = states[r].next[c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// ¼p^[Ìª¶ñÆµÄ\\êép^[ÖÌÎ\n\t\tfor(int i = 0; i < patterns.size(); ++i){\n\t\t\tconst string &pat = patterns[i];\n\t\t\tfor(int j = 1; j < states.size(); ++j){\n\t\t\t\tint current = j, k = 0;\n\t\t\t\tfor(; k < pat.size(); ++k){\n\t\t\t\t\tif(states[current].next[pat[k]] < 0){ break; }\n\t\t\t\t\tcurrent = states[current].next[pat[k]];\n\t\t\t\t}\n\t\t\t\tif(k == pat.size()){ states[current].accept.push_back(i); }\n\t\t\t}\n\t\t}\n\t}\n\tint match(const string &str, vector<int> &result, int state = 0){\n\t\tint matchCount = 0;\n\t\tfor(size_t i = 0; i < str.size(); ++i){\n\t\t\tchar c = str[i];\n\t\t\twhile(states[state].next[c] < 0){ state = states[state].next[0]; }\n\t\t\tstate = states[state].next[c];\n\t\t\tfor(size_t j = 0; j < states[state].accept.size(); ++j){\n\t\t\t\t++(result[states[state].accept[j]]);\n\t\t\t\tif(++matchCount >= 2){ return state; } // âèÉí¹ÄÅK»\n\t\t\t}\n\t\t}\n\t\treturn state;\n\t}\n\tint statesNum() const { return static_cast<int>(states.size()); }\n};\n\nmap<int, int> dp[21][501][2];\n\nconst int MOD = 1000000007;\n\nint main(){\n\twhile(true){\n\t\tint N, M, K;\n\t\tcin >> N >> M >> K;\n\t\tif(N == 0 && M == 0 && K == 0){ break; }\n\t\tvector<int> nextWords[501];\n\t\tmap<string, int> wordMap;\n\t\tvector<string> words(1);\n\t\twordMap.insert(pair<string, int>(\"\", 0));\n\t\tstring from, to;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tcin >> from >> to;\n\t\t\tint fromIndex, toIndex;\n\t\t\tif(wordMap.find(from) != wordMap.end()){\n\t\t\t\tfromIndex = wordMap[from];\n\t\t\t}else{\n\t\t\t\tfromIndex = wordMap.size();\n\t\t\t\twordMap[from] = fromIndex;\n\t\t\t\twords.push_back(from);\n\t\t\t\tnextWords[0].push_back(fromIndex);\n\t\t\t}\n\t\t\tif(wordMap.find(to) != wordMap.end()){\n\t\t\t\ttoIndex = wordMap[to];\n\t\t\t}else{\n\t\t\t\ttoIndex = wordMap.size();\n\t\t\t\twordMap[to] = toIndex;\n\t\t\t\twords.push_back(to);\n\t\t\t\tnextWords[0].push_back(toIndex);\n\t\t\t}\n\t\t\tnextWords[fromIndex].push_back(toIndex);\n\t\t}\n\t\tvector<string> seasonWords(K);\n\t\tfor(int i = 0; i < K; ++i){ cin >> seasonWords[i]; }\n\t\tMatcher matcher(seasonWords);\n\t\tint stateNum = matcher.statesNum();\n\t\tfor(int i = 0; i < 21; ++i){\n\t\t\tfor(int j = 0; j < 501; ++j){\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\tdp[i][j][k].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0][0][0][0] = 1;\n\t\tvector<int> result(seasonWords.size());\n\t\tfor(int i = 0; i < M; ++i){\n\t\t\tfor(int j = 0; j < words.size(); ++j){\n\t\t\t\tfor(int k = 0; k < 2; ++k){\n//\t\t\t\t\tfor(int l = 0; l < stateNum; ++l){\n\t\t\t\t\tfor(\n\t\t\t\t\t\tmap<int, int>::iterator it = dp[i % 21][j][k].begin();\n\t\t\t\t\t\tit != dp[i % 21][j][k].end(); ++it\n\t\t\t\t\t){\n//\t\t\t\t\t\tif(dp[i % 21][j][k][l] == 0){ continue; }\n\t\t\t\t\t\tfor(int n = 0; n < nextWords[j].size(); ++n){\n\t\t\t\t\t\t\tint next = nextWords[j][n];\n\t\t\t\t\t\t\tstring &word = words[next];\n\t\t\t\t\t\t\tif(i + word.size() > M){ continue; }\n\t\t\t\t\t\t\tfill(result.begin(), result.end(), 0);\n\t\t\t\t\t\t\tint s = matcher.match(word, result, it->first);//l);\n\t\t\t\t\t\t\tint m = k + accumulate(result.begin(), result.end(), 0);\n\t\t\t\t\t\t\tif(m >= 2){ continue; }\n\t\t\t\t\t\t\tdp[(i + word.size()) % 21][next][m][s] += it->second; //dp[i % 21][j][k][l];\n\t\t\t\t\t\t\tdp[(i + word.size()) % 21][next][m][s] %= MOD;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tdp[i % 21][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 21][j][k].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tfor(int i = 0; i < words.size(); ++i){\n\t\t\tfor(int j = 0; j < stateNum; ++j){\n\t\t\t\tanswer += dp[M % 21][i][1][j];\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <unordered_map>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nstruct AhoCorasick{\n\tstatic const int MAXCHAR = 'z'+1;\n\tstruct State{\n\t\tint next[MAXCHAR], failure;\n\t\tvi accepts;\n\t\tState():failure(0){memset(next, 0, sizeof(next));}\n\t};\n\tvector<State> states;\n\tint pats;\n\t\n\tAhoCorasick(vector<string> patterns):states(1),pats(patterns.size()){\n\t\tREP(i, pats){\t// make trie\n\t\t\tint p = 0;\n\t\t\tFOR(c, patterns[i]){\n\t\t\t\tif(states[p].next[*c] <= 0){\n\t\t\t\t\tstates[p].next[*c] = states.size();\n\t\t\t\t\tstates.emplace_back();\n\t\t\t\t}\n\t\t\t\tp = states[p].next[*c];\n\t\t\t}\n\t\t\tstates[p].accepts.push_back(i);\n\t\t}\n\t\t\n\t\tqueue<int> q;\t// make failure link\n\t\tq.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint p = q.front();q.pop();\n\t\t\tREP(i, MAXCHAR){\n\t\t\t\tconst int dst = states[p].next[i];\n\t\t\t\tif(!dst) continue;\n\t\t\t\tq.push(dst);\n\t\t\t\tint f = states[p].failure;\n\t\t\t\twhile(f && states[f].next[i] <= 0) f = states[f].failure;\n\t\t\t\tif(p){\n\t\t\t\t\tstates[dst].failure = states[f].next[i];\n\t\t\t\t\tstates[dst].accepts.insert(states[dst].accepts.end(), ALL(states[states[f].next[i]].accepts));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint go_next(int p, const int &c){\n\t\twhile(p && !states[p].next[c]) p = states[p].failure;\n\t\treturn states[p].next[c];\n\t}\n\tint apply(const string &s, int &p){\n\t\tint res=0;\n\t\tREP(i, s.size()){\n\t\t\tp = go_next(p, s[i]);\n\t\t\tres += states[p].accepts.size();\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nint N, M, K;\n\n\ninline void add(int &a, int b){\n\ta += b;\n\tif(a >= MOD) a-= MOD;\n}\n\nmap<int, map<int, int>> dp[1000][2];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> N >> M >> K, N){\n\t\tmap<string, int> StI;\n\t\tvector<string> strs(1, \"\");\n\t\tvector<vi> g(2*N+2);\n\t\tREP(i, N){\n\t\t\tstring from, to;\n\t\t\tint u, v;\n\t\t\tcin >> from >> to;\n\t\t\tauto it = StI.find(from);\n\t\t\tif(it == StI.end()){\n\t\t\t\tu = StI[from] = strs.size();\n\t\t\t\tstrs.push_back(from);\n\t\t\t}else u = it->second;\n\t\t\tit = StI.find(to);\n\t\t\tif(it == StI.end()){\n\t\t\t\tv = StI[to] = strs.size();\n\t\t\t\tstrs.push_back(to);\n\t\t\t}else v = it->second;\n\t\t\tg[u].push_back(v);\n\t\t}\n\t\tREP(i, (int)strs.size() - 1) g[0].push_back(i+1);\n\t\tvector<string> pat(K);\n\t\tREP(i, K) cin >> pat[i];\n\t\tAhoCorasick ahc(pat);\n\t\tdp[0][0][0][0] = 1;\n\t\tREP(i, M)REP(f, 2){\n\t\t\tFOR(u_, dp[i][f])FOR(p_, u_->second){\n\t\t\t\tconst ll t = p_->second;\n\t\t\t\tconst int u = u_->first;\n\t\t\t\tFOR(v, g[u]){\n\t\t\t\t\tint p = p_->first;\n\t\t\t\t\tconst string &s = strs[*v];\n\t\t\t\t\tif(i+s.size() > M) continue;\n\t\t\t\t\tint res = ahc.apply(s, p);\n\t\t\t\t\tif(f + res > 1) continue;\n\t\t\t\t\tadd(dp[i+s.size()][f + res][*v][p], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][f].clear();\n\t\t}\n\t\tll ans = 0;\n\t\tFOR(u_, dp[M][1])FOR(p_, u_->second) ans += p_->second;\n\t\tcout << ans % MOD << endl;\n\t\tREP(j, 2) dp[M][j].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define MAX_W 501\n#define MAX_M 500\n#define MAX_ps 600\nvector<string> pre;\nint mod=1e9+7;\nint N,M,K;\nint a[21][MAX_ps][MAX_W],b[21][MAX_ps][MAX_W];\t//len,suffix,last word\nint ne[MAX_ps][MAX_W];\nbool appear[MAX_ps][MAX_W],twice[MAX_ps][MAX_W],can[MAX_ps][MAX_W];\nstring from[250],to[250],s[30];\nvector<string> words;\nvector<int> G[MAX_W];\nvector<int> cans[MAX_ps];\ninline int wordid(string s){\n\treturn lower_bound(all(words),s)-words.begin();\n}\ninline void add(int &x,int y){\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>K;\n\t\tif(N==0) break;\n\t\tpre.clear();\n\t\twords.clear();\n\t\trep(i,MAX_ps) cans[i].clear();\n\t\trep(i,N){\n\t\t\tcin>>from[i]>>to[i];\n\t\t\twords.pb(from[i]);\n\t\t\twords.pb(to[i]);\n\t\t}\n\t\twords.pb(\"\");\n\t\tsort(all(words));\n\t\twords.erase(unique(all(words)),words.end());\n\t\trep(i,words.size()) G[i].clear();\n\t\trep(i,N){\n\t\t\tG[wordid(from[i])].pb(wordid(to[i]));\n\t\t}\n\t\trep1(i,words.size()-1) G[0].pb(i);\n\t\trep(i,K) cin>>s[i];\n\t\tsort(s,s+K);\n\t\trep(i,K){\n\t\t\trep(j,s[i].size()+1) pre.pb(s[i].substr(0,j));\n\t\t}\n\t\tsort(all(pre));\n\t\tpre.erase(unique(all(pre)),pre.end());\n\t\tint ps=pre.size(),ws=words.size();\n\t\tif(false){\n\t\t\trep(i,ps){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(pre[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\trep(i,ws){\n\t\t\t\tcout<<i<<\" \";\n\t\t\t\tshow(words[i]);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\trep(i,ps) rep(j,ws) can[i][j]=false;\n\t\trep(i,ps){\n\t\t\tstring x=pre[i];\n\t\t\trep(j,ws){\n\t\t\t\tstring st=x+words[j];\n\t\t\t\tint k;\n\t\t\t\twhile(true){\n\t\t\t\t\tk=lower_bound(all(pre),st)-pre.begin();\n\t\t\t\t\tif(k<ps&&pre[k]==st) break;\n\t\t\t\t\tst=st.substr(1);\n\t\t\t\t}\n\t\t\t\tne[i][j]=k;\n\t\t\t\tcan[k][j]=true;\n\t\t\t\tappear[i][j]=false;\n\t\t\t\ttwice[i][j]=false;\n\t\t\t\tst=x;\n\t\t\t\tint cnt=0;\n\t\t\t\trep(h,words[j].size()){\n\t\t\t\t\tst+=words[j][h];\n\t\t\t\t\trep(p,K) if(st.size()>=s[p].size()&&st.substr(st.size()-s[p].size())==s[p]) cnt++;\n\t\t\t\t\tif(cnt>=2) break;\n\t\t\t\t}\n\t\t\t\tif(cnt>=1) appear[i][j]=true;\n\t\t\t\tif(cnt>=2) twice[i][j]=true;\n//\t\t\t\tif(appear[i][j]) printf(\"i=%d,j=%d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t\trep(i,ps) rep(j,ws) if(can[i][j]) cans[i].pb(j);\n\t\trep(i,21) rep(j,ps) rep(k,ws) a[i][j][k]=b[i][j][k]=0;\n\t\tb[0][0][0]=1;\n\t\trep(i,M){\n\t\t\tint i21=i%21;\n\t\t\trep(j,ps){\n\t\t\t\tfor(int k:cans[j]){\n\t\t\t\t\tfor(int u : G[k]){\n\t\t\t\t\t\tif(twice[j][u]) continue;\n\t\t\t\t\t\tint ni=i+words[u].size();\n\t\t\t\t\t\tint ni21=i21+words[u].size();\n\t\t\t\t\t\tif(ni21>=21) ni21-=21;\n\t\t\t\t\t\tif(ni>M) continue;\n\t\t\t\t\t\tif(appear[j][u]){\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tadd(a[ni21][ne[j][u]][u],a[i21][j][k]);\n\t\t\t\t\t\t\tadd(b[ni21][ne[j][u]][u],b[i21][j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,ps) for(int k:cans[j]) a[i21][j][k]=b[i21][j][k]=0;\n\t\t}\n\t\tint ans=0;\n\t\trep(i,ps) rep(j,ws) add(ans,a[M%21][i][j]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main implements Runnable{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// new SakuraPoetry().run();\n\t\tnew Thread(null, new Main(), \"\", 16 * 1024L * 1024L).start();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[500][601][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\ttr(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n//\t\t\ttr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[500][601][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\ttr(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new long[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tSystem.gc();\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tHashMap<List<Integer>, Integer>[] map = new HashMap[21];\n\t\t\tfor (int i = 0; i < 21; i++) {\n\t\t\t\tmap[i] = new HashMap<>();\n\t\t\t}\n\t\t\tmap[0].put(Arrays.asList(0, 0, n - 1), 1);\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tmap[(len - 1 + 21) % 21].clear();\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\n\t\t\t\t\t\t\tInteger val = map[len % 21].get(Arrays.asList(nodeid, seasonWord, cur));\n\n\t\t\t\t\t\t\tif (val != null && val > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1 || nLen > M)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tList<Integer> nkey = Arrays.asList(state[0], nSeasonWord, dst);\n\t\t\t\t\t\t\t\t\tInteger nval = map[nLen % 21].get(nkey);\n\t\t\t\t\t\t\t\t\tif (nval == null)\n\t\t\t\t\t\t\t\t\t\tnval = 0;\n\t\t\t\t\t\t\t\t\tmap[nLen % 21].put(nkey, (val + nval) % MOD);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tInteger val = map[M % 21].get(Arrays.asList(nodeid, 1, cur));\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t\tans = (ans + val) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tint MOD = 1_000_000_007;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[21][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 21) % 21] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 21][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] += dp[len % 21][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] %= MOD;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 21][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n//\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tHashMap<List<Integer>, Integer>[] map = new HashMap[21];\n\t\t\tfor (int i = 0; i < 21; i++) {\n\t\t\t\tmap[i] = new HashMap<>();\n\t\t\t}\n\t\t\tmap[0].put(Arrays.asList(0, 0, n - 1), 1);\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tmap[(len - 1 + 21) % 21].clear();\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tInteger val = map[len % 21].get(Arrays.asList(nodeid, seasonWord, cur));\n\t\t\t\t\t\t\tif (val != null && val > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = (len + ss[dst].length()) % 21;\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tList<Integer> nkey = Arrays.asList(state[0], nSeasonWord, dst);\n\t\t\t\t\t\t\t\t\tInteger nval=map[nLen].get(nkey);\n\t\t\t\t\t\t\t\t\tif(nval==null)nval=0;\n\t\t\t\t\t\t\t\t\tmap[nLen % 21].put(nkey, (val + nval) % MOD);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tInteger val = map[M % 21].get(Arrays.asList(nodeid, 1, cur));\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t\tans = (ans + val) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tint MOD = 1_000_000_007;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t        new Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new long[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[21][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 21) % 21] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 21][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] += dp[len % 21][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 21][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[21][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 21) % 21] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 21][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] += dp[len % 21][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 21][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[21][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 21) % 21] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 21][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] += dp[len % 21][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 21][state[0]][nSeasonWord][dst] %= MOD;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 21][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new long[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[500][601][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\ttr(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tSystem.gc();\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tHashMap<List<Integer>, Integer>[] map = new HashMap[21];\n\t\t\tfor (int i = 0; i < 21; i++) {\n\t\t\t\tmap[i] = new HashMap<>();\n\t\t\t}\n\t\t\tmap[0].put(Arrays.asList(0, 0, n - 1), 1);\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tmap[(len - 1 + 21) % 21].clear();\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\n\t\t\t\t\t\t\tInteger val = map[len % 21].get(Arrays.asList(nodeid, seasonWord, cur));\n\n\t\t\t\t\t\t\tif (val != null && val > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1 || nLen > M)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tList<Integer> nkey = Arrays.asList(state[0], nSeasonWord, dst);\n\t\t\t\t\t\t\t\t\tInteger nval = map[nLen % 21].get(nkey);\n\t\t\t\t\t\t\t\t\tif (nval == null)\n\t\t\t\t\t\t\t\t\t\tnval = 0;\n\t\t\t\t\t\t\t\t\tmap[nLen % 21].put(nkey, (val + nval) % MOD);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tInteger val = map[M % 21].get(Arrays.asList(nodeid, 1, cur));\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t\tans = (ans + val) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(a\\\\ns);\n\n\t\t}\n\t}\n\n\tint MOD = 1_000_000_007;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tif (len % 100 == 0)\n\t\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tHashMap<List<Integer>, Integer>[] map = new HashMap[21];\n\t\t\tfor (int i = 0; i < 21; i++) {\n\t\t\t\tmap[i] = new HashMap<>();\n\t\t\t}\n\t\t\tmap[0].put(Arrays.asList(0, 0, n - 1), 1);\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tmap[(len - 1 + 21) % 21].clear();\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\n\t\t\t\t\t\t\tInteger val = map[len % 21].get(Arrays.asList(nodeid, seasonWord, cur));\n\n\t\t\t\t\t\t\tif (val != null && val > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1 || nLen > M)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tList<Integer> nkey = Arrays.asList(state[0], nSeasonWord, dst);\n\t\t\t\t\t\t\t\t\tInteger nval = map[nLen % 21].get(nkey);\n\t\t\t\t\t\t\t\t\tif (nval == null)\n\t\t\t\t\t\t\t\t\t\tnval = 0;\n\t\t\t\t\t\t\t\t\tmap[nLen % 21].put(nkey, (val + nval) % MOD);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tInteger val = map[M % 21].get(Arrays.asList(nodeid, 1, cur));\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t\tans = (ans + val) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tint MOD = 1_000_000_007;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main implements Runnable {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// new SakuraPoetry().run();\n\t\tnew Thread(null, new Main(), \"\", 16 * 1024L * 1024L).start();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\t\t\t\n\t\t\tdp = new long[M + 1][trie.gen][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t        new Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new long[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tif (len % 22 == 0)\n\t\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tif(len%200==0)\n\t\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t        new Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new long[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tSystem.gc();\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tHashMap<List<Integer>, Integer>[] map = new HashMap[21];\n\t\t\tfor (int i = 0; i < 21; i++) {\n\t\t\t\tmap[i] = new HashMap<>();\n\t\t\t}\n\t\t\tmap[0].put(Arrays.asList(0, 0, n - 1), 1);\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tmap[(len - 1 + 21) % 21].clear();\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\n\t\t\t\t\t\t\tInteger val = map[len % 21].get(Arrays.asList(nodeid, seasonWord, cur));\n\n\t\t\t\t\t\t\tif (val != null && val > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1 || nLen > M)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tList<Integer> nkey = Arrays.asList(state[0], nSeasonWord, dst);\n\t\t\t\t\t\t\t\t\tInteger nval = map[nLen % 21].get(nkey);\n\t\t\t\t\t\t\t\t\tif (nval == null)\n\t\t\t\t\t\t\t\t\t\tnval = 0;\n\t\t\t\t\t\t\t\t\tmap[nLen % 21].put(nkey, (val + nval) % MOD);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tInteger val = map[M % 21].get(Arrays.asList(nodeid, 1, cur));\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t\tans = (ans + val) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(a\\\\ns);\n\n\t\t}\n\t}\n\n\tint MOD = 1_000_000_007;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new int[22][trie.gen][2][n];\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = 0;\n\n\t\t\tdp[0][0][0][n - 1] = 1;\n\n\t\t\tfor (int len = 0; len < M; len++) {\n\n\t\t\t\tdp[(len - 1 + 22) % 22] = new int[trie.gen][2][n];\n\n\t\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\t\tfor (int seasonWord = 0; seasonWord < 2; seasonWord++) {\n\t\t\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\t\t\tif (dp[len % 22][nodeid][seasonWord][cur] > 0) {\n\t\t\t\t\t\t\t\tfor (int dst : g[cur]) {\n\t\t\t\t\t\t\t\t\tif (len % 100 == 0)\n\t\t\t\t\t\t\t\t\t\tSystem.gc();\n\t\t\t\t\t\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);\n\t\t\t\t\t\t\t\t\tint nLen = len + ss[dst].length();\n\t\t\t\t\t\t\t\t\tint nSeasonWord = seasonWord + state[1];\n\t\t\t\t\t\t\t\t\tif (nSeasonWord > 1)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] += dp[len % 22][nodeid][seasonWord][cur];\n\t\t\t\t\t\t\t\t\tdp[nLen % 22][state[0]][nSeasonWord][dst] %= MOD;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int nodeid = 0; nodeid < trie.gen; nodeid++) {\n\t\t\t\tfor (int cur = 0; cur < n; cur++) {\n\t\t\t\t\tans = (ans += dp[M % 22][nodeid][1][cur]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t\t// tr(Runtime.getRuntime().totalMemory()/1000);\n\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tint[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tif (hit > 1) {\n\t\t\t\t\t\t\treturn new int[] { cur.id, hit };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[500][601][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\ttr(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint K = ni();\n\t\t\tif (N == 0 && M == 0 && K == 0)\n\t\t\t\tbreak;\n\t\t\tString[] from = new String[N];\n\t\t\tString[] to = new String[N];\n\t\t\tss = new String[2 * N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfrom[i] = ns();\n\t\t\t\tto[i] = ns();\n\t\t\t\tss[2 * i] = from[i];\n\t\t\t\tss[2 * i + 1] = to[i];\n\t\t\t}\n\t\t\tArrays.sort(ss);\n\t\t\tss = unique(ss);\n\n\t\t\tint n = ss.length;\n\t\t\tn++;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tint src = Arrays.binarySearch(ss, from[i]);\n\t\t\t\tint dst = Arrays.binarySearch(ss, to[i]);\n\t\t\t\tg[src].add(dst);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tg[n - 1].add(i);\n\n\t\t\ttrie = new TrieByList();\n\n\t\t\twhile (K-- > 0) {\n\t\t\t\ttrie.add(ns().toCharArray());\n\t\t\t}\n\n\t\t\ttrie.buildFailure();\n\n\t\t\tdp = new long[500][601][2][n];// [???????????????][trie???Node???id][??£????????????????????????][?????¨??????]\n\t\t\tfor (int i = 0; i < dp.length; i++)\n\t\t\t\tfor (int j = 0; j < dp[0].length; j++)\n\t\t\t\t\tfor (int k = 0; k < dp[0][0].length; k++)\n\t\t\t\t\t\tfor (int l = 0; l < dp[0][0][0].length; l++)\n\t\t\t\t\t\t\tdp[i][j][k][l] = -1;\n\n\t\t\tlong ans = 0;\n\t\t\tans = dfs(M, 0, 1, n - 1) % MOD;\n\t\t\ttr(ans);\n\t\t}\n\t}\n\n\tlong MOD = 1_000_000_007;\n\tlong[][][][] dp;\n\tArrayList<Integer>[] g;\n\tString[] ss;\n\tTrieByList trie;\n\n\tlong dfs(int len, int nodeid, int seasonWordNum, int cur) {\n\t\tif (seasonWordNum < 0 || len < 0)\n\t\t\treturn 0;\n\t\tif (seasonWordNum == 0 && len == 0)\n\t\t\treturn 1;\n\t\tif (dp[len][nodeid][seasonWordNum][cur] >= 0) {\n\t\t\treturn dp[len][nodeid][seasonWordNum][cur];\n\t\t} else {\n\t\t\tlong sum = 0;\n\t\t\tfor (int dst : g[cur]) {\n\t\t\t\tint[] state = trie.move(ss[dst].toCharArray(), nodeid);// {nodeid,hit};\n\t\t\t\t// tr(ss[dst],state[1]);\n\t\t\t\tsum += dfs(len - ss[dst].length(), state[0], seasonWordNum - state[1], dst);\n\t\t\t\tsum %= MOD;\n\t\t\t}\n\t\t\treturn (dp[len][nodeid][seasonWordNum][cur] = sum);\n\t\t}\n\t}\n\n\tString[] unique(String[] ss) {\n\t\tString[] ret = new String[ss.length];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\tif (i == 0 || !ss[i].equals(ss[i - 1])) {\n\t\t\t\tret[p] = ss[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(ret, p);\n\t}\n\n\tclass TrieByList {\n\t\tNode[] list = new Node[601];\n\t\tNode root = new Node(0, (char) 0);\n\t\tint gen = 1;\n\n\t\tpublic TrieByList() {\n\t\t\tlist[gen - 1] = root;\n\t\t}\n\n\t\tclass Node {\n\t\t\tint id;\n\t\t\tchar c;\n\t\t\tNode[] child = null;\n\t\t\tint p = 0;\n\t\t\tint ptn = 0;\n\t\t\tNode fail;\n\t\t\tint hit = 0;\n\n\t\t\tpublic Node(int id, char c) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.c = c;\n\t\t\t}\n\n\t\t\tNode search(char c) {\n\t\t\t\tif (ptn << 31 - (c - 'a') < 0) {\n\t\t\t\t\treturn child[Integer.bitCount(ptn << 31 - (c - 'a')) - 1];\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvoid appendChild(Node n) {\n\t\t\t\tif (p == 0) {\n\t\t\t\t\tchild = new Node[1];\n\t\t\t\t} else if (p + 1 > child.length) {\n\t\t\t\t\tchild = Arrays.copyOf(child, 2 * child.length);\n\t\t\t\t}\n\t\t\t\tint z = n.c - 'a';\n\t\t\t\tint zind = Integer.bitCount(ptn << 31 - z);\n\t\t\t\tSystem.arraycopy(child, zind, child, zind + 1, p - zind);\n\t\t\t\tptn |= 1 << z;\n\t\t\t\tchild[zind] = n;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n\t\tvoid buildFailure() {\n\t\t\troot.fail = null;\n\t\t\tQueue<Node> q = new ArrayDeque<>();\n\t\t\tq.add(root);\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode cur = q.poll();\n\t\t\t\tinner: for (int i = 0; i < cur.p; i++) {\n\t\t\t\t\tNode ch = cur.child[i];\n\t\t\t\t\tq.add(ch);\n\t\t\t\t\tfor (Node to = cur.fail; to != null; to = to.fail) {\n\t\t\t\t\t\tNode next = to.search(ch.c);\n\t\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\t\tch.fail = next;\n\t\t\t\t\t\t\tch.hit += next.hit;\n\t\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tch.fail = root;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid add(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tNode pre = null;\n\t\t\tfor (char c : s) {\n\t\t\t\tpre = cur;\n\t\t\t\tcur = pre.search(c);\n\t\t\t\tif (cur == null) {\n\t\t\t\t\tcur = new Node(gen++, c);\n\t\t\t\t\tlist[gen - 1] = cur;\n\t\t\t\t\tpre.appendChild(cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.hit++;\n\t\t}\n\n\t\tint countHit(char[] s) {\n\t\t\tNode cur = root;\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn hit;\n\t\t}\n\n\t\tint[] move(char[] s, int curid) {\n\t\t\tNode cur = list[curid];\n\t\t\tint hit = 0;\n\t\t\touter: for (char c : s) {\n\t\t\t\tfor (; cur != null; cur = cur.fail) {\n\t\t\t\t\tNode next = cur.search(c);\n\t\t\t\t\tif (next != null) {\n\t\t\t\t\t\thit += next.hit;\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = root;\n\t\t\t}\n\t\t\treturn new int[] { cur.id, hit };\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nca = ord('a')\nclass AhoCorasick:\n    def __init__(self):\n        self.root = root = [None]*30\n        root[-2] = 0; root[-3] = 0\n        root[-4] = 0\n        self.nodes = [root]\n\n    def add(self, s):\n        node = self.root\n        nodes = self.nodes\n        for c in s:\n            code = ord(c) - ca\n            child = node[code]\n            if not child:\n                node[code] = child = [None]*30\n                child[-2] = node[-2] + 1\n                child[-3] = 0\n                child[-4] = len(nodes)\n                nodes.append(child)\n            node = child\n        node[-3] = 1\n\n    def suffix(self):\n        root = self.root\n        que = deque([root])\n        while que:\n            v = que.popleft()\n            if v[-1]:\n                v[-3] += v[-1][-3]\n            for i in range(26):\n                if not v[i]:\n                    if v[-1]:\n                        v[i] = v[-1][i]\n                    else:\n                        v[i] = root[i] or root\n                    continue\n                if v[-1]:\n                    v[i][-1] = v[-1][i]\n                else:\n                    v[i][-1] = root\n                que.append(v[i])\n        root[-1] = root\n\ndef solve():\n    MOD = 10**9 + 7\n    N, M, K = map(int, readline().split())\n    if N == M == K == 0:\n        return False\n    mp = {}\n    G = []\n    S = []\n    cur = 0\n    fc = lambda x: ord(x) - ca\n    for i in range(N):\n        f, t = readline().strip().split()\n        if f not in mp:\n            mp[f] = cur\n            G.append([])\n            S.append(list(map(fc, f)))\n            cur += 1\n        if t not in mp:\n            mp[t] = cur\n            G.append([])\n            S.append(list(map(fc, t)))\n            cur += 1\n        G[mp[f]].append(mp[t])\n    *LS, = map(len, S)\n    tree = AhoCorasick()\n    for i in range(K):\n        s = readline().strip()\n        tree.add(s)\n    tree.suffix()\n    L = len(S)\n    K = len(tree.nodes)\n    G0 = [[None]*L for i in range(K)]\n    for k in range(K):\n        nd0 = tree.nodes[k]\n        g = G0[k]\n        for i in range(L):\n            s = S[i]\n            if len(s) > M:\n                continue\n            nd = nd0\n            c = 0\n            for e in s:\n                nd = nd[e]\n                c += nd[-3]\n            if c <= 1:\n                g[i] = (nd[-4], c)\n\n    dp = [defaultdict(int) for i in range(M+1)]\n    root = tree.root\n    v0 = root[-4]\n    for i in range(L):\n        e = G0[v0][i]\n        if e is None:\n            continue\n        w, c = e\n        dp[LS[i]][i, w, c] = 1\n    for i in range(M):\n        for (v, p, c0), v0 in dp[i].items():\n            v0 %= MOD\n            g = G0[p]\n            for w in G[v]:\n                e = g[w]\n                if e is None or i+LS[w] > M:\n                    continue\n                q, c = e\n                if c0+c <= 1:\n                    dp[i+LS[w]][w, q, c0+c] += v0\n    ans = 0\n    for (v, p, c0), v0 in dp[M].items():\n        if c0 == 1:\n            ans += v0\n    write(\"%d\\n\" % (ans % MOD))\n    return True\nwhile solve():\n    ...\n"
  }
]