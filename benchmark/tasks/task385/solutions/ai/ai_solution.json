[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MOD 1000000007\n#define MAX_WORDS 1000\n#define MAX_LEN 20\n\ntypedef struct {\n    char word[MAX_LEN];\n    int is_seasonal;\n} Word;\n\nWord words[MAX_WORDS];\nint adj[MAX_WORDS][MAX_WORDS];\nint word_count = 0;\nint seasonal_count = 0;\nint total_seasonal_words_used = 0;\nlong long result = 0;\n\nint find_word_index(char *word) {\n    for (int i = 0; i < word_count; i++) {\n        if (strcmp(words[i].word, word) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid dfs(int current, int seasonal_used_mask, int length, int total_length) {\n    if (length == total_length) {\n        if (__builtin_popcount(seasonal_used_mask) == seasonal_count) {\n            result = (result + 1) % MOD;\n        }\n        return;\n    }\n\n    for (int next = 0; next < word_count; next++) {\n        if (adj[current][next]) {\n            if (words[next].is_seasonal) {\n                if (seasonal_used_mask & (1 << next)) {\n                    continue;\n                }\n                dfs(next, seasonal_used_mask | (1 << next), length + 1, total_length);\n            } else {\n                dfs(next, seasonal_used_mask, length + 1, total_length);\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    for (int i = 0; i < N; i++) {\n        char word[MAX_LEN];\n        int is_seasonal;\n        scanf(\"%s %d\", word, &is_seasonal);\n        strcpy(words[word_count].word, word);\n        words[word_count].is_seasonal = is_seasonal;\n        if (is_seasonal) seasonal_count++;\n        word_count++;\n    }\n\n    for (int i = 0; i < M; i++) {\n        char word1[MAX_LEN], word2[MAX_LEN];\n        scanf(\"%s %s\", word1, word2);\n        int u = find_word_index(word1);\n        int v = find_word_index(word2);\n        adj[u][v] = 1;\n    }\n\n    int total_length = K;\n\n    for (int i = 0; i < word_count; i++) {\n        int seasonal_used_mask = 0;\n        if (words[i].is_seasonal) {\n            seasonal_used_mask = 1 << i;\n        }\n        dfs(i, seasonal_used_mask, 1, total_length);\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    unordered_map<string, unordered_set<string>> graph;\n    unordered_set<string> seasonalWords;\n\n    for (int i = 0; i < N; ++i) {\n        string a, b;\n        cin >> a >> b;\n        graph[a].insert(b);\n    }\n\n    for (int i = 0; i < M; ++i) {\n        string word;\n        cin >> word;\n        seasonalWords.insert(word);\n    }\n\n    unordered_map<string, int> dpCurrent;\n    unordered_map<string, int> dpNext;\n\n    for (const auto& word : graph) {\n        dpCurrent[word.first] = 1;\n    }\n\n    for (int step = 1; step < K; ++step) {\n        dpNext.clear();\n        for (const auto& [word, count] : dpCurrent) {\n            for (const auto& nextWord : graph[word]) {\n                dpNext[nextWord] = (dpNext[nextWord] + count) % MOD;\n            }\n        }\n        dpCurrent = dpNext;\n    }\n\n    int total = 0;\n    for (const auto& [word, count] : dpCurrent) {\n        if (seasonalWords.count(word)) {\n            total = (total + count) % MOD;\n        }\n    }\n\n    cout << total << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PoemCounter {\n    private static final int MOD = 1_000_000_007;\n    private Map<String, List<String>> graph;\n    private Set<String> seasonalWords;\n    private int totalWords;\n    private int seasonalCount;\n    private long[][][] dp;\n\n    public int countPoems(String[] dictionary, String[] seasonal, int n) {\n        buildGraph(dictionary);\n        seasonalWords = new HashSet<>(Arrays.asList(seasonal));\n        totalWords = n;\n        seasonalCount = seasonal.length;\n        dp = new long[n + 1][seasonalCount + 1][2];\n        for (long[][] arr2 : dp) {\n            for (long[] arr1 : arr2) {\n                Arrays.fill(arr1, -1);\n            }\n        }\n        long result = 0;\n        for (String word : graph.keySet()) {\n            boolean isSeasonal = seasonalWords.contains(word);\n            int s = isSeasonal ? 1 : 0;\n            result = (result + dfs(word, 1, s, isSeasonal)) % MOD;\n        }\n        return (int) result;\n    }\n\n    private long dfs(String currentWord, int length, int usedSeasonal, int endsWithSeasonal) {\n        if (length == totalWords) {\n            return usedSeasonal == seasonalCount ? 1 : 0;\n        }\n        if (dp[length][usedSeasonal][endsWithSeasonal] != -1) {\n            return dp[length][usedSeasonal][endsWithSeasonal];\n        }\n        long count = 0;\n        for (String nextWord : graph.getOrDefault(currentWord, Collections.emptyList())) {\n            boolean isSeasonal = seasonalWords.contains(nextWord);\n            int newUsedSeasonal = usedSeasonal + (isSeasonal ? 1 : 0);\n            if (newUsedSeasonal > seasonalCount) {\n                continue;\n            }\n            int newEndsWithSeasonal = isSeasonal ? 1 : 0;\n            count = (count + dfs(nextWord, length + 1, newUsedSeasonal, newEndsWithSeasonal)) % MOD;\n        }\n        dp[length][usedSeasonal][endsWithSeasonal] = count;\n        return count;\n    }\n\n    private void buildGraph(String[] dictionary) {\n        graph = new HashMap<>();\n        for (String pair : dictionary) {\n            String[] words = pair.split(\" \");\n            String from = words[0];\n            String to = words[1];\n            graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\n        }\n    }\n\n    public static void main(String[] args) {\n        PoemCounter counter = new PoemCounter();\n        String[] dictionary = {\"hello world\", \"world hello\", \"hello hello\", \"world world\"};\n        String[] seasonal = {\"hello\"};\n        int n = 2;\n        System.out.println(counter.countPoems(dictionary, seasonal, n));\n    }\n}",
    "timestamp": "2025-08-05 21:21:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int countPoems(Map<String, List<String>> connections, List<String> seasonalWords) {\n        Map<String, Integer> wordCounts = new HashMap<>();\n        for (String word : seasonalWords) {\n            wordCounts.put(word, 1);\n        }\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (Map.Entry<String, List<String>> entry : connections.entrySet()) {\n            graph.putIfAbsent(entry.getKey(), new ArrayList<>());\n            graph.get(entry.getKey()).addAll(entry.getValue());\n        }\n\n        return dfs(graph, wordCounts, new HashSet<>(), null);\n    }\n\n    private int dfs(Map<String, List<String>> graph, Map<String, Integer> wordCounts, \n                    Set<String> visited, String currentWord) {\n        if (currentWord != null && wordCounts.containsKey(currentWord)) {\n            wordCounts.put(currentWord, wordCounts.get(currentWord) - 1);\n            if (wordCounts.get(currentWord) < 0) {\n                wordCounts.put(currentWord, wordCounts.get(currentWord) + 1);\n                return 0;\n            }\n        }\n\n        if (allUsed(wordCounts)) {\n            return 1;\n        }\n\n        int totalPoems = 0;\n        if (currentWord != null) {\n            visited.add(currentWord);\n        }\n\n        List<String> nextWords = currentWord == null ? \n            new ArrayList<>(graph.keySet()) : graph.getOrDefault(currentWord, new ArrayList<>());\n\n        for (String nextWord : nextWords) {\n            if (!visited.contains(nextWord)) {\n                totalPoems = (totalPoems + dfs(graph, wordCounts, visited, nextWord)) % MOD;\n            }\n        }\n\n        if (currentWord != null) {\n            visited.remove(currentWord);\n        }\n\n        if (currentWord != null && wordCounts.containsKey(currentWord)) {\n            wordCounts.put(currentWord, wordCounts.get(currentWord) + 1);\n        }\n\n        return totalPoems;\n    }\n\n    private boolean allUsed(Map<String, Integer> wordCounts) {\n        for (int count : wordCounts.values()) {\n            if (count > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:21:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_WORDS 1000\n#define MOD 1000000007\n\ntypedef struct {\n    char word[50];\n    int connections[MAX_WORDS];\n    int connection_count;\n} WordNode;\n\nint dfs(WordNode* graph, int word_count, int* seasonal_words, int seasonal_count, int* used, int current_word, int remaining_seasonal) {\n    if (remaining_seasonal == 0) {\n        return 1;\n    }\n\n    int total_poems = 0;\n    for (int i = 0; i < graph[current_word].connection_count; i++) {\n        int next_word = graph[current_word].connections[i];\n        \n        if (used[next_word]) continue;\n\n        int is_seasonal = 0;\n        for (int j = 0; j < seasonal_count; j++) {\n            if (next_word == seasonal_words[j]) {\n                is_seasonal = 1;\n                break;\n            }\n        }\n\n        used[next_word] = 1;\n        total_poems = (total_poems + dfs(graph, word_count, seasonal_words, seasonal_count, used, \n                      next_word, remaining_seasonal - is_seasonal)) % MOD;\n        used[next_word] = 0;\n    }\n\n    return total_poems;\n}\n\nint count_distinct_poems(WordNode* graph, int word_count, int* seasonal_words, int seasonal_count) {\n    int total_poems = 0;\n    int* used = calloc(word_count, sizeof(int));\n\n    for (int start = 0; start < word_count; start++) {\n        int is_seasonal = 0;\n        for (int j = 0; j < seasonal_count; j++) {\n            if (start == seasonal_words[j]) {\n                is_seasonal = 1;\n                break;\n            }\n        }\n\n        used[start] = 1;\n        total_poems = (total_poems + dfs(graph, word_count, seasonal_words, seasonal_count, used, \n                      start, seasonal_count - is_seasonal)) % MOD;\n        used[start] = 0;\n    }\n\n    free(used);\n    return total_poems;\n}\n\nint main() {\n    int word_count, connection_count, seasonal_count;\n    scanf(\"%d %d %d\", &word_count, &connection_count, &seasonal_count);\n\n    WordNode* graph = calloc(word_count, sizeof(WordNode));\n    \n    for (int i = 0; i < word_count; i++) {\n        scanf(\"%s\", graph[i].word);\n    }\n\n    for (int i = 0; i < connection_count; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a].connections[graph[a].connection_count++] = b;\n        graph[b].connections[graph[b].connection_count++] = a;\n    }\n\n    int* seasonal_words = malloc(seasonal_count * sizeof(int));\n    for (int i = 0; i < seasonal_count; i++) {\n        scanf(\"%d\", &seasonal_words[i]);\n    }\n\n    int result = count_distinct_poems(graph, word_count, seasonal_words, seasonal_count);\n    printf(\"%d\\n\", result);\n\n    free(graph);\n    free(seasonal_words);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:21:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPoems(unordered_map<string, vector<string>>& connections, vector<string>& seasonalWords) {\n        const int MOD = 1000000007;\n        int n = seasonalWords.size();\n        \n        // Adjacency list to represent word connections\n        unordered_map<string, vector<string>> graph;\n        for (auto& [word, neighbors] : connections) {\n            graph[word] = neighbors;\n        }\n        \n        // DP state: [current word][used seasonal words mask]\n        vector<vector<long long>> dp(graph.size() + 1, vector<long long>(1 << n, 0));\n        \n        // Starting with each seasonal word\n        for (int start = 0; start < n; start++) {\n            string currentWord = seasonalWords[start];\n            if (graph.count(currentWord)) {\n                dp[graph.size() + 1][1 << start] = 1;\n            }\n        }\n        \n        // Dynamic programming to explore all possible poems\n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (auto& [word, neighbors] : graph) {\n                for (string& nextWord : neighbors) {\n                    for (int seasonalIndex = 0; seasonalIndex < n; seasonalIndex++) {\n                        if (!(mask & (1 << seasonalIndex)) && nextWord == seasonalWords[seasonalIndex]) {\n                            for (int prevMask = 0; prevMask < mask; prevMask++) {\n                                if ((prevMask & mask) == 0) {\n                                    dp[graph.size() + 1][mask | (1 << seasonalIndex)] += \n                                        dp[graph.size() + 1][prevMask];\n                                    dp[graph.size() + 1][mask | (1 << seasonalIndex)] %= MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Sum all valid poem configurations\n        long long totalPoems = 0;\n        for (int mask = 1; mask < (1 << n); mask++) {\n            if (__builtin_popcount(mask) == n) {\n                totalPoems += dp[graph.size() + 1][mask];\n                totalPoems %= MOD;\n            }\n        }\n        \n        return totalPoems;\n    }\n};",
    "timestamp": "2025-08-05 21:21:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_distinct_poems(connections, seasonal_words):\n    MOD = 1_000_000_007\n\n    # Initialize a set for all words and get the start words\n    words = set(connections.keys())\n    start_words = [word for word in words if word not in seasonal_words]\n\n    def dfs(word, visited, seasonal_count):\n        if seasonal_count == len(seasonal_words):\n            return 1\n\n        total = 0\n        visited.add(word)\n        for next_word in connections.get(word, []):\n            if next_word not in visited or next_word in seasonal_words:\n                next_seasonal_count = seasonal_count + (1 if next_word in seasonal_words and next_word not in visited else 0)\n                total += dfs(next_word, visited, next_seasonal_count)\n                total %= MOD\n        visited.remove(word)\n        return total\n\n    # Try to create the poems from each possible starting word\n    result = 0\n    for start_word in start_words:\n        result += dfs(start_word, set(), 0)\n        result %= MOD\n\n    return result\n\n# Example Usage\nconnections = {\n    'winter': ['is', 'coming'],\n    'is': ['cold', 'dark'],\n    'cold': ['but'],\n    'dark': ['but'],\n    'but': ['also'],\n    'also': ['colorful', 'hopeful'],\n    'hopeful': ['spring'],\n    'spring': []\n}\n\nseasonal_words = ['winter', 'spring']\nprint(count_distinct_poems(connections, seasonal_words))  # Output will be the number of distinct poems modulo 1,000,000,007",
    "timestamp": "2025-08-13 05:58:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class PoemGenerator {\n    private static final int MOD = 1_000_000_007;\n\n    public static int countDistinctPoems(Map<String, List<String>> connections, List<String> seasonalWords) {\n        Set<String> visited = new HashSet<>();\n        return dfs(connections, seasonalWords, visited, \"\");\n    }\n\n    private static int dfs(Map<String, List<String>> connections, List<String> seasonalWords, Set<String> visited, String word) {\n        if (visited.contains(word)) return 0;\n        visited.add(word);\n\n        int count = 1; // Count this path as an option\n\n        if (seasonalWords.contains(word)) {\n            seasonalWords.remove(word);\n        }\n\n        if (seasonalWords.isEmpty()) {\n            visited.remove(word);\n            return count;\n        }\n\n        List<String> nextWords = connections.getOrDefault(word, new ArrayList<>());\n        for (String nextWord : nextWords) {\n            count = (count + dfs(connections, seasonalWords, visited, nextWord)) % MOD;\n        }\n        \n        visited.remove(word);\n        if (!seasonalWords.contains(word)) {\n            seasonalWords.add(word);\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Map<String, List<String>> connections = new HashMap<>();\n        connections.put(\"spring\", Arrays.asList(\"summer\", \"fall\"));\n        connections.put(\"summer\", Arrays.asList(\"fall\", \"winter\"));\n        connections.put(\"fall\", Arrays.asList(\"winter\", \"spring\"));\n        connections.put(\"winter\", Arrays.asList());\n\n        List<String> seasonalWords = Arrays.asList(\"spring\", \"summer\", \"fall\", \"winter\");\n\n        System.out.println(countDistinctPoems(connections, seasonalWords)); // Example test case\n    }\n}",
    "timestamp": "2025-08-13 05:58:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MOD 1000000007\n#define MAX_WORDS 1000\n\ntypedef struct {\n    int count;\n    char words[MAX_WORDS][100];\n} WordList;\n\ntypedef struct {\n    int connections[MAX_WORDS][MAX_WORDS];\n    int wordCount;\n    int seasonalIndex[MAX_WORDS];\n} ConnectionDictionary;\n\nvoid dfs(int index, int usedSeasonalWords, ConnectionDictionary *dict, bool *visited, int *distinctPoems) {\n    if (usedSeasonalWords == (1 << dict->wordCount) - 1) {\n        *distinctPoems = (*distinctPoems + 1) % MOD;\n        return;\n    }\n    visited[index] = true;\n    for (int i = 0; i < dict->wordCount; i++) {\n        if (!visited[i] && dict->connections[index][i] > 0) {\n            int nextUsedSeasonalWords = usedSeasonalWords;\n            if (dict->seasonalIndex[i]) {\n                nextUsedSeasonalWords |= (1 << i);\n            }\n            dfs(i, nextUsedSeasonalWords, dict, visited, distinctPoems);\n        }\n    }\n    visited[index] = false;\n}\n\nint countDistinctPoems(ConnectionDictionary *dict) {\n    int distinctPoems = 0;\n    bool visited[MAX_WORDS] = {false};\n\n    for (int i = 0; i < dict->wordCount; i++) {\n        if (dict->seasonalIndex[i]) {\n            dfs(i, 1 << i, dict, visited, &distinctPoems);\n        }\n    }\n    return distinctPoems;\n}\n\nint main() {\n    ConnectionDictionary dict;\n    dict.wordCount = 4;\n    // Sample connection data\n    // 0: \"spring\", 1: \"breeze\", 2: \"autumn\", 3: \"leaves\"\n    char words[MAX_WORDS][100] = {\"spring\", \"breeze\", \"autumn\", \"leaves\"};\n    int seasonalWords[MAX_WORDS] = {1, 0, 1, 0};\n\n    for (int i = 0; i < dict.wordCount; i++) {\n        dict.seasonalIndex[i] = seasonalWords[i];\n    }\n    // Sample connections: spring->breeze, breeze->autumn, autumn->leaves\n    memset(dict.connections, 0, sizeof(dict.connections));\n    dict.connections[0][1] = 1;\n    dict.connections[1][2] = 1;\n    dict.connections[2][3] = 1;\n\n    int result = countDistinctPoems(&dict);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:58:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_distinct_poems(connections, seasonal_words):\n    MOD = 10**9 + 7\n    \n    def dfs(node, used_seasonal, path):\n        if len(path) > 0 and len(set(path)) < len(path):\n            return 0\n        \n        if len(path) > 1 and len(used_seasonal) == len(seasonal_words):\n            return 1\n        \n        total_poems = 0\n        \n        for next_word in connections.get(node, []):\n            new_used_seasonal = used_seasonal.copy()\n            \n            if next_word in seasonal_words:\n                if next_word in new_used_seasonal:\n                    continue\n                new_used_seasonal.add(next_word)\n            \n            path.append(next_word)\n            total_poems = (total_poems + dfs(next_word, new_used_seasonal, path)) % MOD\n            path.pop()\n        \n        return total_poems\n    \n    distinct_poems = 0\n    \n    for start_word in seasonal_words:\n        path = [start_word]\n        used_seasonal = {start_word}\n        distinct_poems = (distinct_poems + dfs(start_word, used_seasonal, path)) % MOD\n    \n    return distinct_poems",
    "timestamp": "2025-08-13 05:59:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    from collections import defaultdict, deque\n\n    N, M = map(int, sys.stdin.readline().split())\n    adj = defaultdict(list)\n    in_degree = defaultdict(int)\n    out_degree = defaultdict(int)\n    words = set()\n    \n    for _ in range(M):\n        a, b = sys.stdin.readline().split()\n        adj[a].append(b)\n        out_degree[a] += 1\n        in_degree[b] += 1\n        words.add(a)\n        words.add(b)\n    \n    S = int(sys.stdin.readline())\n    seasonal = set()\n    for _ in range(S):\n        word = sys.stdin.readline().strip()\n        seasonal.add(word)\n    \n    # Initialize DP tables\n    dp = defaultdict(int)\n    q = deque()\n    \n    # Find all nodes with in_degree 0 (potential starting points)\n    for word in words:\n        if in_degree.get(word, 0) == 0:\n            q.append(word)\n            dp[(word, frozenset([word] if word in seasonal else []))] = 1\n    \n    total = 0\n    \n    while q:\n        u = q.popleft()\n        current_states = []\n        # Collect all states for current node u\n        for key in list(dp.keys()):\n            if key[0] == u:\n                current_states.append(key)\n        \n        for state in current_states:\n            current_word, current_seasonal = state[0], state[1]\n            count = dp[state]\n            \n            if out_degree.get(current_word, 0) == 0:\n                if len(current_seasonal) == S:\n                    total = (total + count) % MOD\n                continue\n            \n            for neighbor in adj.get(current_word, []):\n                new_seasonal = set(current_seasonal)\n                if neighbor in seasonal:\n                    if neighbor in new_seasonal:\n                        continue  # already used this seasonal word\n                    new_seasonal.add(neighbor)\n                new_seasonal_frozen = frozenset(new_seasonal)\n                new_state = (neighbor, new_seasonal_frozen)\n                dp[new_state] = (dp[new_state] + count) % MOD\n                # Decrement in_degree for neighbor conceptually, but since we're using BFS, it's handled by the queue\n        \n        # Decrement in_degree for all neighbors and enqueue if in_degree becomes 0\n        # But since we're not tracking in_degree dynamically, this approach is not perfect\n        # Alternative: process all nodes in topological order (pre-computed)\n    \n    # To handle DAG properly, we need topological sorting\n    # Re-initialize with topological order\n    # Compute topological order\n    in_degree_copy = defaultdict(int)\n    for word in words:\n        in_degree_copy[word] = in_degree.get(word, 0)\n    \n    topo_order = []\n    q_topo = deque([word for word in words if in_degree_copy[word] == 0])\n    \n    while q_topo:\n        u = q_topo.popleft()\n        topo_order.append(u)\n        for v in adj.get(u, []):\n            in_degree_copy[v] -= 1\n            if in_degree_copy[v] == 0:\n                q_topo.append(v)\n    \n    dp = defaultdict(int)\n    total = 0\n    \n    for word in topo_order:\n        if in_degree.get(word, 0) == 0:\n            seasonal_set = set()\n            if word in seasonal:\n                seasonal_set.add(word)\n            dp[(word, frozenset(seasonal_set))] = 1\n    \n    for u in topo_order:\n        current_states = []\n        for key in list(dp.keys()):\n            if key[0] == u:\n                current_states.append(key)\n        \n        for state in current_states:\n            current_word, current_seasonal = state[0], state[1]\n            count = dp[state]\n            \n            if out_degree.get(current_word, 0) == 0:\n                if len(current_seasonal) == S:\n                    total = (total + count) % MOD\n                continue\n            \n            for neighbor in adj.get(current_word, []):\n                new_seasonal = set(current_seasonal)\n                if neighbor in seasonal:\n                    if neighbor in new_seasonal:\n                        continue\n                    new_seasonal.add(neighbor)\n                new_seasonal_frozen = frozenset(new_seasonal)\n                new_state = (neighbor, new_seasonal_frozen)\n                dp[new_state] = (dp[new_state] + count) % MOD\n    \n    print(total % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 05:59:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\n#define MOD 1000000007\n\nusing namespace std;\n\nunordered_map<string, vector<string>> connections;\nunordered_set<string> seasonalSet;\nunordered_map<string, int> memo;\nvector<string> seasonalWords;\n\nint countPoems(string current, vector<bool>& seasonalUsed, int usedCount) {\n    if (usedCount == seasonalWords.size()) {\n        return 1;\n    }\n    \n    string state = current;\n    for (bool used : seasonalUsed) {\n        state += (used ? '1' : '0');\n    }\n\n    if (memo.find(state) != memo.end()) {\n        return memo[state];\n    }\n\n    int totalWays = 0;\n    for (string& next : connections[current]) {\n        bool isSeasonal = seasonalSet.count(next) > 0;\n        if (isSeasonal) {\n            auto it = find(seasonalWords.begin(), seasonalWords.end(), next);\n            int index = distance(seasonalWords.begin(), it);\n\n            if (!seasonalUsed[index]) {\n                seasonalUsed[index] = true;\n                totalWays = (totalWays + countPoems(next, seasonalUsed, usedCount + 1)) % MOD;\n                seasonalUsed[index] = false;\n            }\n        } else {\n            totalWays = (totalWays + countPoems(next, seasonalUsed, usedCount)) % MOD;\n        }\n    }\n\n    memo[state] = totalWays;\n    return totalWays;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    connections.clear();\n    seasonalSet.clear();\n    memo.clear();\n    seasonalWords.resize(m);\n\n    for (int i = 0; i < n; ++i) {\n        string u, v;\n        cin >> u >> v;\n        connections[u].push_back(v);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        cin >> seasonalWords[i];\n        seasonalSet.insert(seasonalWords[i]);\n    }\n\n    int result = 0;\n    for (const auto& entry : connections) {\n        vector<bool> seasonalUsed(m, false);\n        result = (result + countPoems(entry.first, seasonalUsed, 0)) % MOD;\n    }\n\n    cout << result << \"\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:26"
  }
]