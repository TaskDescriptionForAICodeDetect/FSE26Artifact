[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n;\n  while(cin>>n,n){\n    map<string,pair<int,int> > S;\n    for(int i=0;i<n;++i){\n      string s;cin>>s;\n      int weekday,start;\n      cin>>weekday>>start;\n      if(start>=2400){\n        weekday=(weekday+1)%7;\n        start%=2400;\n      }\n      S[s]=make_pair(weekday,start);\n    }\n    int p;cin>>p;\n    set<string> F;\n    for(int i=0;i<p;++i){\n      string s;cin>>s;\n      F.insert(s);\n    }\n    vector<int> A(60*24*7);\n    int ans=F.size();\n    for(set<string>::iterator it=F.begin();it!=F.end();++it){\n      int w = S[*it].first;\n      int t = S[*it].second;\n      int tt = t/100*60+t%100;\n      for(int i=0;i<30;++i){\n        ++A[(60*24*w+tt+i)%(60*24*7)];\n        if(A[(60*24*w+tt+i)%(60*24*7)]>1) ans=-1;\n      }\n    }\n    if(ans>=0){\n\t    vector<int> nF;\n\t    int i=0,mx=ans;\n\t    for(map<string,pair<int,int> >::iterator it=S.begin();it!=S.end();++it){\n\t      int w = (*it).second.first;\n\t      int t = (*it).second.second;\n\t      int tt = t/100*60+t%100;\n\t      nF.push_back(w*24*60+tt);\n\t    }\n\t    sort(nF.begin(),nF.end());\n\t    //cerr<<\"#\"<<nF.size()<<endl;\n    \tfor(int i=0;i<nF.size();++i){\n    \t\tint cnt=0;\n    \t\tvector<int> B(24*60*7);\n    \t\tfor(int j=0;j<24*60*7;++j)B[j]=A[j];\n    \t\tfor(int j=i;j<i+nF.size();++j){\n    \t\t\tint strt = nF[j%nF.size()];\n\t    \t\tbool f=false;\n\t    \t\t//cerr<<\"##\"<<*it<<endl;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\tif(B[k%(24*60*7)]>0) f=true;\n\t    \t\t}\n\t    \t\tif(f)continue;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\t++B[k%(24*60*7)];\n\t    \t\t}\n\t    \t\t++cnt;\n    \t\t}\n    \t\tif(ans+cnt>mx)mx=ans+cnt;\n    \t}\n    \tans=mx;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint n, p;\ntypedef pair<int, string> TV;\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tvector<TV> tvs;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tstring name;\n\t\t\tint week, start;\n\t\t\tcin >> name >> week >> start;\n\t\t\ttvs.push_back(TV(week * 60*24 + (start / 100 * 60) + start % 100, name));\n\t\t}\n\t\tvector<int> times;\n\t\tcin >> p;\n\t\tint curTime = -300;\n\t\tint tvCount = p;\n\t\tsort(tvs.begin(), tvs.end());\n\t\tfor(int i = 0; i < p; i++) {\n\t\t\tstring fav;\n\t\t\tcin >> fav;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(tvs[j].second == fav) {\n\t\t\t\t\tfor(int k = 0; k < (int)times.size(); k++) {\n\t\t\t\t\t\tif(tvs[j].first < times[k] + 30 && times[k] < tvs[j].first + 30) {\n\t\t\t\t\t\t\tgoto mirenai;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttimes.push_back(tvs[j].first);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tsort(times.begin(), times)\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tbool watchable = true;\n\t\t\tfor(int k = 0; k < times.size(); k++) {\n\t\t\t\tif(tvs[i].first < times[k] + 30 && times[k] < tvs[i].first + 30) {\n\t\t\t\t\twatchable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!watchable || tvs[i].first < curTime + 30 && curTime < tvs[i].first + 30) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttvCount++;\n\t\t\t\tcurTime = tvs[i].first;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << tvCount << endl;\n\t\tcontinue;\n\t\t\n\t\tmirenai:\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint n,i,r,last,time,day;\n\tfor(;cin>>n,n;){\n\t\tvector<pair<int,string> >program;\n\t\tset<string>fav;\n\t\t{\n\t\t\tstring s;\n\t\t\tmap<string,int>m;\n\t\t\tfor(;n--;){\n\t\t\t\tcin>>s>>day>>time;\n\t\t\t\tprogram.push_back(make_pair(time=day*1440+time/100*60+time%100,s));\n\t\t\t\tm[s]=time;\n\t\t\t}\n\t\t\tvector<int>v;\n\t\t\tfor(cin>>n;n--;v.push_back(m[s]),fav.insert(s))cin>>s;\n\t\t\tsort(v.begin(),v.end());\n\t\t\tfor(i=0;i<v.size()-1;i++)if(v[i+1]-v[i]<30){puts(\"-1\");goto next;}\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tfor(last=r=i=0;i<program.size();i++){\n\t\t\tif(program[i].first>=last){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t\tr++;\n\t\t\t}else if(fav.find(program[i].second)!=fav.end()){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    if(start >= 2400){\n      weekday++;\n      start -= 2400;\n      if(weekday == 7){\n        weekday = 0;\n      }\n    }\n    favorite = false;\n  }\n\n  int minutes(){\n    int tmp = start / 100;\n    return (tmp * 60) + start - (tmp * 100);\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  if(a1.weekday == a2.weekday){\n    return a1.start < a2.start;\n  }\n  return a1.weekday < a2.weekday;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n    /*  for(int i=0; i<n; i++){\n        cout << table[i].name << \" \" << table[i].weekday;\n        cout << \" \" << table[i].start << \" \";\n        cout << table[i].favorite << endl;\n      }*/\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      //cout << endl;\n\n      while(last != n){\n\n        while(1){\n          if(table[first].weekday == table[last].weekday){\n\n          /*  cout << table[first].name << \" \" << table[first].weekday;\n            cout << \" \" << table[first].start << \" \";\n            cout << table[first].minutes() << \" \";\n            cout << table[last].name << \" \" << table[last].weekday;\n            cout << \" \" << table[last].start << \" \";\n            cout << table[last].minutes() << endl;*/\n\n            if(table[last].minutes() - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          else{\n            if((table[last].minutes()+2400) - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        //cout << first << \" \" << last << endl;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n        /*  cout << table[first].name << \" \" << table[first].weekday;\n          cout << \" \" << table[first].start << \" \";\n          cout << table[first].favorite << endl;*/\n          count++;\n        }\n\n        first = last;\n        last++;\n\n\n\n      }\n\n      if(table[n-1].weekday == table[n-2].weekday){\n        if(table[n-1].minutes() - table[n-2].minutes() >= 30){\n          count++;\n        }\n      }\n      else{\n        if((table[n-2].minutes()+2400) - table[n-1].minutes() >= 30){\n          count++;\n        }\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nvector<P> anime;\nvector<P> fav;\n\nbool Overlap(int x,int y) {\n\tint _max=max(x,y),_min=min(x,y);\n\treturn (_max-_min)<30;\n}\n\nbool Check(P& p) {\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(p.second!=fav[i].second&&Overlap(p.first,fav[i].first)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tstart=weekday*1440+start/100*60+start%100;\n\t\t\tif(start<360) start+=1440*7;\n\t\t\tanime.push_back(P(start,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(anime[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<p&&ok;i++) {\n\t\t\tfor(int j=0;j<p&&ok;j++) {\n\t\t\t\tif(i!=j&&Overlap(fav[i].first,fav[j].first)) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {cout<<-1<<endl;continue;}\n\t\tanime.erase(remove_if(anime.begin(),anime.end(),Check),anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<vst.size()&&ok;j++) {\n\t\t\t\tif(Overlap(anime[i].first,vst[j])) ok=false;\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcount++;\n\t\t\t\tvst.push_back(anime[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : TopCoderCompetition.cpp\n// Author      : taguchi\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <list>\nusing namespace std;\n//#define P pair<int,int>\n#define rep(i,n) for(int i = 0;i<n;i++)\n#define pb(n) push_back(n)\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nstruct edge{int cost,to;};\n\nvector<string> split(string &in,char delimiter){\n\tvector<string> re; uint cur = 0,next;\n\twhile((next = in.find_first_of(delimiter,cur)) != string::npos){\n\t\tre.pb(string(in,cur,next-cur));\n\t\tcur = next + 1;\n\t}\n\tre.pb(string(in,cur,in.size()-cur));\n\treturn re;\n}\nvector<int> split_int(string &in, char delimiter){\n\tvector<string> str = split(in,delimiter);\n\tvector<int> re;\n\trep(i,str.size()){\n\t\tre.pb(strtol(str[i].c_str(),NULL,10));\n\t}\n\treturn re;\n}\n\nclass Range{\npublic:\n\tint a,b;\n\tRange(int an,int bn) : a(an),b(bn){}\n\n\tbool operator()(int n){\n\t\treturn a<=n&&n<=b;\n\t}\n\tbool isCross(Range x){\n\t\treturn x(a) || x(b);\n\t}\n\tbool contains(Range x){\n\t\treturn this->a <= x.a && x.b <= this->b;\n\t}\n};\n\nclass RangeHandler{\npublic:\n\tlist<Range> Ranges;\n\n\tbool insert(Range x){\n\t\tif(Ranges.empty()){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\n\t\tif(x.b < Ranges.front().a){\n\t\t\tRanges.push_front(x);\n\t\t\treturn true;\n\t\t}\n\t\tif(Ranges.back().b < x.a){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\t\tfor(list<Range>::iterator i = Ranges.begin();i != Ranges.end();i++){\n\t\t\tlist<Range>::iterator l = i;\n\t\t\tl++;\n\t\t\t//cout << \"dbg\" << i->b << \" \" << i->a << endl;\n\t\t\tif(Range(i->b,l->a).contains(x)){\n\t\t\t\tRanges.insert(l,x);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nint N,P;\nint main(){\n\twhile(true){\n\t\tint result = 0;\n\t\tcin >> N;\n\t\tif(N == 0)break;\n\t\tvector<pair<int,string> > Programs,Table;\n\t\tvector<pair<int,string> >::iterator ip;\n\t\trep(i,N){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tint weekday,start;\n\t\t\tcin >> weekday >> start;\n\t\t\tstart -=600;\n\t\t\tint time = 1440 * weekday + (start / 100) * 60 + (start % 100);\n\t\t\tPrograms.pb(make_pair(time,name));\n\t\t}\n\t\tcin >> P;\n\t\trep(i,P){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tfor(ip = Programs.begin();ip!=Programs.end();ip++){\n\t\t\t\tif(ip->second == name){\n\t\t\t\t\tTable.pb(*ip);\n\t\t\t\t\tPrograms.erase(ip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(Programs.begin(),Programs.end());\n\t\trep(i,Programs.size()){\n\t\t\tTable.pb(Programs[i]);\n\t\t}\n\t\tRangeHandler rg;\n\t\tbool ans = true;\n\t\trep(i,Table.size()){\n\t\t\tif(rg.insert(Range(Table[i].first,Table[i].first+30))){\n\t\t\t\tans &= true;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tans = false;\n\t\t\tif(i < P && !ans) {\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef map<string, P> Program;\n\nProgram prog;\nvector<string> all;\nvector<string> fav;\nvector<string> normal;\nbool watched[7][1800];\nint ans;\n\nint toMinute(string t){\n  int ret = 0;\n  if(t.size() == 3){\n    ret += (t[0]-'0') * 60;\n    ret += (t[1]-'0') * 10 + (t[2]-'0');\n  }\n  else if(t.size() == 4){\n    int h =(t[0]-'0') * 10 + (t[1]-'0');\n    ret += h * 60;\n    ret += (t[2]-'0') * 10 + (t[3]-'0');\n  }\n  return ret;\n}\n\nbool watchFavAnime(){\n  rep(i, fav.size()){\n    P t = prog[fav[i]];\n    for(int T = t.s ; T < t.s+30 ; T++){\n      if(watched[t.f][T] == 1) return false;\n      watched[t.f][T] = 1;\n    }\n    ans++;\n  }\n  return true;\n}\n\nvoid init(){\n  prog.clear();\n  fav.clear();\n  all.clear();\n  normal.clear();\n  memset(watched, 0, sizeof(watched));\n  ans = 0;\n}\n\nint main(){\n  int n, p;  \n  while(cin >> n, n){\n    init();\n    string name, tim;\n    P t;\n    rep(i, n){\n      cin >> name >> t.f >> tim;\n      int m = toMinute(tim);\n      t.s = m;\n      prog[name] = t;\n      all.push_back(name);\n    }\n    \n    cin >> p;\n    rep(i, p){\n      cin >> name;\n      fav.push_back(name);\n    }\n    // input finish\n    \n    bool flag = true;\n    \n    flag = watchFavAnime();\n    if(!flag){\n      cout << \"-1\" << endl;\n      continue;\n    }\n    \n    rep(i, n){\n      bool fl = true;\n      rep(j, fav.size()){\n\tif(all[i] == fav[j]){\n\t  fl = false;\n\t  break;\n\t}\n      }\n      if(fl) normal.push_back(all[i]);\n    }\n    \n    vector<P> nor;\n    rep(i, normal.size()){\n      nor.push_back(prog[normal[i]]);\n    }\n    \n    sort(nor.begin(), nor.end());\n    \n    rep(i, nor.size()){\n      int w = nor[i].f;\n      int m = nor[i].s;\n      bool f = true;\n      for(int T = m ; T < m+30 ; T++){\n\tif(watched[w][T] == 1){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f){\n\tfor(int T = m ; T < m+30 ; T++){\n\t  watched[w][T] = 1;\n\t}\n\t//cout << normal[i] << endl;\n\tans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Interval{\n\tint a,b;\n\tInterval(){}\n\tInterval(int A,int B):a(A),b(B){}\n\tbool operator<(const Interval &I)const{ return b<I.b; }\n};\n\nconst int M=7*24*60;\n\nbool intersect(const Interval &I,const Interval &J){\n\tfor(int t=I.a+1;t<=I.b-1;t++){\n\t\tif(J.a%M<=t%M && t%M<=J.b%M) return true;\n\t}\n\treturn false;\n}\n\nint solve(int n,Interval *I){\n\tsort(I,I+n);\n\n\tint ans=0;\n\tInterval J[500];\n\trep(i,n){\n\t\tint n2=0,j;\n\t\tfor(j=i+1;j<n;j++) if(!intersect(I[i],I[j])) J[n2++]=I[j];\n\t\tfor(j= 0 ;j<i;j++) if(!intersect(I[i],I[j])) J[n2++]=Interval(I[j].a+M,I[j].b+M);\n\n\t\tint cnt=0,r=-1;\n\t\trep(j,n2){\n\t\t\tif(r<=J[j].a) r=J[j].b, cnt++;\n\t\t}\n\t\tans=max(ans,1+cnt);\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tmap<string,int> f;\n\t\tInterval I[500];\n\t\trep(i,n){\n\t\t\tchar name[33];\n\t\t\tint week,start; scanf(\"%s%d%d\",name,&week,&start);\n\t\t\tf[name]=i;\n\n\t\t\tint h=start/100,m=start%100;\n\t\t\tstart=(week*24*60+h*60+m)%M;\n\t\t\tI[i]=Interval(start,start+30);\n\t\t}\n\n\t\tint nf; scanf(\"%d\",&nf);\n\t\tInterval fav[500];\n\t\trep(i,nf){\n\t\t\tchar name[33]; scanf(\"%s\",name);\n\t\t\tfav[i]=I[f[name]];\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(j,nf) rep(i,j) if(intersect(fav[i],fav[j])) ok=false;\n\t\tif(!ok){ puts(\"-1\"); continue; }\n\n\t\tint n2=0;\n\t\tInterval J[500];\n\t\trep(i,n){\n\t\t\tbool ok=true;\n\t\t\trep(j,nf) if(intersect(I[i],fav[j])) ok=false;\n\t\t\tif(ok) J[n2++]=I[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\",nf+solve(n2,J));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<string> ps(n);\n\t\tvector<int> ts(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>ps[i];\n\t\t\tint w,s; cin>>w>>s;\n\t\t\tts[i]=(w*24*60+s/100*60+s%100)%(7*24*60);\n\t\t}\n\t\tint m; cin>>m;\n\t\tvector<int> fs(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tfs[find(begin(ps),end(ps),s)-begin(ps)]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tts.push_back(ts[i]+7*24*60);\n\t\tvector<int> is(n*2);\n\t\tiota(begin(is),end(is),0);\n\t\tsort(begin(is),end(is),[&](int i,int j){return ts[i]<ts[j];});\n\t\t\n\t\tint res=-1;\n\t\tfor(int l=0,r=7*24*60;l<30;l++,r++){\n\t\t\tvector<int> dp(r+1);\n\t\t\tint p=0;\n\t\t\tfor(int i:is){\n\t\t\t\tint t=ts[i];\n\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+(fs[i]?1000:1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\tif(dp[r]/1000!=m) continue;\n\t\t\tres=max(res,dp[r]/1000+dp[r]%1000);\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(weekday != arg.weekday){\n\t\t\treturn weekday < arg.weekday;\n\t\t}else{\n\t\t\treturn start < arg.start;\n\t\t}\n\t}\n\tint weekday,start,end;\n\tchar name[33];\n};\n\nint N;\nInfo info[500];\nbool check[7][1440];\nbool used[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint translate_TIME(char buf[5]){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tint hour,minute;\n\n\tif(length == 3){\n\t\thour = buf[0]-'0';\n\t\tminute = 10*(buf[1]-'0')+(buf[2]-'0');\n\t}else{\n\t\thour = 10*(buf[0]-'0')+(buf[1]-'0');\n\t\tminute = 10*(buf[2]-'0')+(buf[3]-'0');\n\t}\n\thour -= 6;\n\treturn 60*hour+minute;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int k = 0; k < 1440; k++)check[i][k] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tchar start[5];\n\tint tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s\",info[i].name,&info[i].weekday,start);\n\n\t\ttmp = translate_TIME(start);\n\n\t\tinfo[i].start = tmp;\n\t\tinfo[i].end = tmp+29;\n\t}\n\n\tsort(info,info+N);\n\n\t/*for(int i = 0; i < N; i++){\n\t\tprintf(\"w_day:%d start:%d end:%d\\n\",info[i].weekday,info[i].start,info[i].end);\n\t}*/\n\n\tvector<int> MUST;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tchar tmp_name[33];\n\n\tfor(int loop = 0; loop < P; loop++){\n\t\tscanf(\"%s\",tmp_name);\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(strCmp(info[i].name,tmp_name)){\n\t\t\t\tMUST.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//???????????????????????????????????????????????????\n\tbool FLG = true;\n\n\tfor(int i = 0; i < P-1; i++){\n\t\tfor(int k = i+1; k < P; k++){\n\t\t\tif(info[MUST[i]].start > info[MUST[k]].end || info[MUST[i]].end < info[MUST[k]].start){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!FLG){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tused[MUST[i]] = true;\n\t\tfor(int k = info[MUST[i]].start; k <= info[MUST[i]].end; k++){\n\t\t\tcheck[info[MUST[i]].weekday][k] = true;\n\t\t}\n\t}\n\n\tvector<int> V; //??????????????????????????§???????????????\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\t\t\tV.push_back(i);\n\t\t}\n\t}\n\n\tint ans = P;\n\tint right,V_index = 0;\n\tbool Found;\n\n\tif(V.size() == 0){\n\t\tprintf(\"%d\\n\",P);\n\t\treturn;\n\t}\n\n\tfor(int w_day = 0; w_day < 7; w_day++){\n\t\tfor(int time = 0; time < 1440;){\n\t\t\tif(check[w_day][time]){\n\t\t\t\ttime++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(right = time; right+1 < 1440 && check[w_day][right+1] == false; right++);\n\n\t\t\tif(right-time+1 < 30){ //????????????????¶?:?°?????????¨???right?????§????????¬?????????????????????\n\n\t\t\t\t//right??\\???????§????????????????????????????\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start <= right)){\n\t\t\t\t\t\t V_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime = right+1;\n\t\t\t}else{ //right?????§?????????????????????????????°????????´??????\n\n\t\t\t\tFound = false;\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start < time)){\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t}else if(info[V[V_index]].weekday == w_day && info[V[V_index]].start >= time && info[V[V_index]].end <= right){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ttime = info[V[V_index]].end+1;\n\t\t\t\t\t\tFound = true;\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Found){\n\t\t\t\t\ttime = right+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]<ma[fav[i-1]]+30){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n            sort(res.begin(),res.end(),sv);\n        }\n        if(nex){\n            continue;\n        }\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                resi++;\n            }\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/8/22 13:58:15\n * File Name: B.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nconst int maxn = 500 + 50;\n\nmap<string, int> idx;\nint n, p, cnt;\n\nstruct Pro {\n    int day, time, idx;\n    bool operator < (const Pro & A) const{\n        if(day == A.day)    return time < A.time;\n        return day < A.day;\n    }\n    void solve() {\n        int h = time / 100;\n        int m = time % 100;\n        h += m / 60;\n        m %= 60;\n        day += h / 24;\n        h %= 24;\n        day %= 7;\n        time = h * 100 + m;\n    }\n}pro[maxn];\n\nchar name[100];\nint day, time;\nbool must[maxn], cannot[maxn];\n\nint hash(const string &str) {\n    if(idx.count(str))  return idx[str];\n    ++cnt;\n    return idx[str] = cnt;\n}\n\nbool con(const Pro &p1, const Pro &p2) {\n    Pro t1 = p1, t2 = p2;\n    if(t2 < t1) {\n        swap(t1, t2);\n    }\n    t1.time += 30;\n    t1.solve();\n    return t2 < t1;\n}\n\nint calc(int l, int r) {\n    if(l > r)   return 0;\n    Pro tmp;\n    tmp.day = -100;\n    tmp.time = -100;\n    int res = 0;\n    for(int i = l; i <= r; i++) {\n        if(cannot[i])   continue;\n        if(pro[i] < tmp) continue;\n        res++;\n        tmp = pro[i];\n        tmp.time += 30;\n        tmp.solve();\n    }\n    return res;\n}\n\nint main() {\n    while(scanf(\"%d\", &n) == 1 && n) {\n        idx.clear();\n        cnt = 0;\n        for(int i = 1; i <= n; i++) {\n            scanf(\"%s%d%d\", name, &day, &time);\n            pro[i].idx = hash(string(name));\n            pro[i].day = day;\n            pro[i].time = time;\n            pro[i].solve();\n        }\n        scanf(\"%d\", &p);\n        memset(must, false, sizeof(must));\n        memset(cannot, false, sizeof(cannot));\n        for(int i = 1; i <= p; i++) {\n            scanf(\"%s\", name);\n            must[hash(string(name))] = true;\n        }\n        stable_sort(pro + 1, pro + 1 + n);\n        int last = 0;\n        int ans = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(i == j) continue;\n                if(must[pro[i].idx] && must[pro[j].idx]) {\n                    if(con(pro[i], pro[j])) {\n                        ans = -1;\n                    }\n                }\n            }\n        }\n        \n        for(int i = 1; i <= n; i++) {\n            if(must[pro[i].idx]) {\n                for(int j = 1; j <= n; j++) {\n                    if(i == j)  continue;\n                    if(con(pro[i], pro[j]) || con(pro[j], pro[i])) {\n                        cannot[j] = true;\n                    }\n                }\n            }\n        }\n        \n        if(ans != -1) {\n            ans = p;\n            for(int i = 1; i <= n; i++) {\n                if(must[pro[i].idx]) {\n                    ans += calc(last + 1, i - 1);\n                    last = i;\n                }\n            }\n            ans += calc(last + 1, n);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]%10080<(ma[fav[i-1]]+30)%10080){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n        }\n        if(nex){\n            continue;\n        }\n        sort(res.begin(),res.end(),sv);\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                resi++;\n            }\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint n,i,r,last,time,day;\n\tfor(;cin>>n,n;){\n\t\tvector<pair<int,string> >program;\n\t\tset<string>fav;\n\t\t{\n\t\t\tstring s;\n\t\t\tmap<string,int>m;\n\t\t\tfor(;n--;){\n\t\t\t\tcin>>s>>day>>time;\n\t\t\t\tprogram.push_back(make_pair(day*1440+time/100*60+time%100,s));\n\t\t\t\tm[s]=day*1440+time/100*60+time%100;\n\t\t\t}\n\t\t\tvector<int>v;\n\t\t\tfor(cin>>n;n--;v.push_back(m[s]),fav.insert(s))cin>>s;\n\t\t\tsort(v.begin(),v.end());\n\t\t\tfor(i=0;i<v.size()-1;i++)if(v[i+1]-v[i]<30){puts(\"-1\");goto next;}\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tfor(last=r=i=0;i<program.size();i++){\n\t\t\tif(program[i].first>=last){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t\tr++;\n\t\t\t}else if(fav.find(program[i].second)!=fav.end()){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint main(void){\n  int n;\n  while(cin>>n,n){\n    map<string,pair<int,int> > S;\n    for(int i=0;i<n;++i){\n      string s;cin>>s;\n      int weekday,start;\n      cin>>weekday>>start;\n      if(start>=2400){\n        weekday=(weekday+1)%7;\n        start%=2400;\n      }\n      S[s]=make_pair(weekday,start);\n    }\n    int p;cin>>p;\n    set<string> F;\n    for(int i=0;i<p;++i){\n      string s;cin>>s;\n      F.insert(s);\n    }\n    vector<int> A(60*24*7);\n    int ans=F.size();\n    for(set<string>::iterator it=F.begin();it!=F.end();++it){\n      int w = S[*it].first;\n      int t = S[*it].second;\n      int tt = t/100*60+t%100;\n      for(int i=0;i<30;++i){\n        ++A[(60*24*w+tt+i)%(60*24*7)];\n        if(A[(60*24*w+tt+i)%(60*24*7)]>1) ans=-1;\n      }\n    }\n    set<int> nF;\n    for(map<string,pair<int,int> >::iterator it=S.begin();it!=S.end();++it){\n      int w = (*it).second.first;\n      int t = (*it).second.second;\n      int tt = t/100*60+t%100;\n      nF.insert(w*24*60+tt);\n    }\n    //cerr<<\"#\"<<nF.size()<<endl;\n    if(ans>=0){\n    \tfor(set<int>::iterator it=nF.begin();it!=nF.end();++it){\n    \t\tbool f=false;\n    \t\t//cerr<<\"##\"<<*it<<endl;\n    \t\tfor(int i=*it;i<*it+30;++i){\n    \t\t\tif(A[i]>0) f=true;\n    \t\t}\n    \t\tif(f)continue;\n    \t\tfor(int i=*it;i<*it+30;++i){\n    \t\t\t++A[i%(24*60*7)];\n    \t\t}\n    \t\t++ans;\n    \t}\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size();i++) {\n\t\t\tfor(int j=0;j<fav.size();j++) {\n\t\t\t\tif(i!=j&&Diff(fav[i].first,fav[j].first)) {okay=false;}\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(!Diff(anime[i].first,anime[j].first)) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nmap <string,int> my_map;\nint n,map_si,m;\nint f[3000];\nchar ch[100];\nint id[3000];\nstruct AA\n{\n\tint p,w,t;\n\tbool f;\n}a[1010];\nbool cmp(AA a,AA b)\n{\n\tif (a.w==b.w) return a.t<b.t;\n\treturn a.w<b.w;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile (n!=0)\n\t{\n\t\tmy_map.clear();\n\t\tmap_si=0;\n\t\tfor (int i=0;i<n;i++)\n\t\t{\t\n\t\t\tscanf(\"%s\",ch);\n\t\t\tif (my_map[ch]==0) my_map[ch]=++map_si;\n\t\t\ta[i].p=map_si;\n\t\t\tid[map_si]=i;\n\t\t\tscanf(\"%d%d\",&a[i].w,&a[i].t);\n\t\t\ta[i].t=a[i].t/100*60+a[i].t%100;\n\t\t\ta[i].t-=240;\n\t\t\ta[i].f=false;\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor (int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%s\",ch);\n\t\t\ta[id[my_map[ch]]].f=true;\n\t\t}\n\t\tsort(a,a+n,cmp);\n\t\tint now=0,p=0;\n\t\tint ans=0;\n\t\tbool fail=false;\n\t\twhile (now<7)\n\t\t{\n\t\t\tint q=0,pre=-100;\n\t\t\tf[0]=0;\n\t\t\twhile (a[p].w==now)\n\t\t\t{\n\t\t\t\twhile (q<a[p].t)\n\t\t\t\t{\n\t\t\t\t\tq++;\n\t\t\t\t\tf[q]=f[q-1];\n\t\t\t\t}\n\t\t\t\tif (a[p].f)\n\t\t\t\t{\n\t\t\t\t\tif (a[p].t-30<pre)\n\t\t\t\t\t{\n\t\t\t\t\t\tfail=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpre=a[p].t;\n\t\t\t\t\tif (q<30) f[q]=1;\n\t\t\t\t\telse f[q]=f[q-30]+1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (a[p].t-30>=pre) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (q<30) f[q]=1;\n\t\t\t\t\t\telse f[q]=max(f[q],f[q-30]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (fail) break;\n\t\t\telse ans+=f[q];\n\t\t\tnow++;\n\t\t}\n\t\tif (fail) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t\tscanf(\"%d\",&n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct pro{\n    char name[40];\n    int st;\n    bool operator <(const pro &a)const{\n        return st <= a.st;\n    }\n}p[600];\nchar nam[600][40];\nint pi[600];\nint d[600][2];\nint cal(int l,int r)\n{\n    for(int i = l; i <= r; ++i){\n        d[i][0] = 0,d[i][1] = 1;\n        for(int j = l; j < i; ++j){\n            if(d[i][0] < d[j][0])\n                d[i][0] = d[j][0];\n            if(d[i][0] < d[j][1])\n                d[i][0] = d[j][1];\n            if(p[i].st - p[j].st>=30&&d[i][1] < d[j][0]+1)\n                d[i][1] = d[j][0]+1;\n            if(p[i].st - p[j].st>=30&&d[i][1] < d[j][1]+1)\n                d[i][1] = d[j][1]+1;\n        }\n    }\n    int ans = 0;\n    for(int i = l; i <= r; ++i){\n        if(ans < d[i][0])\n            ans = d[i][0];\n        if(ans < d[i][1])\n            ans = d[i][1];\n    }\n    return ans;\n}\nint main()\n{\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    int n,m;\n    while(scanf(\"%d\",&n),n){\n        for(int i = 0; i < n; ++i){\n            int a,b;\n            scanf(\"%s %d %d\",p[i].name,&a,&b);\n            p[i].st = a*1440+b/100*60+b%100;\n            //printf(\"%d %s %d %d %d\\n\",i,p[i].name,a,b,p[i].st);\n        }\n        sort(p,p+n);\n        //for(int i = 0; i < n; ++i)\n        //    printf(\"%d %s %d\\n\",i,p[i].name,p[i].st);\n        scanf(\"%d\",&m);\n        int cnt = 0;\n        bool fg = true;\n        for(int i = 0 ;i < m; ++i){\n            scanf(\"%s\",nam[i]);\n            bool flag = true;\n            for(int j = 0; j < n; ++j){\n                if(strcmp(nam[i],p[j].name) == 0){\n                    pi[cnt++] = j;\n                    flag = false;\n                }\n            }\n            if(flag)\n                fg = false;\n        }\n        if(fg == false){\n            puts(\"-1\");\n            continue;\n        }\n        m = cnt;\n        sort(pi,pi+m);\n        fg = true;\n        for(int i = 1;i < m; ++i){\n            if(p[pi[i]].st -p[pi[i-1]].st < 30){\n                fg = false;\n                break;\n            }\n        }\n        if(fg == false){\n            puts(\"-1\");\n            continue;\n        }\n        int ans = m;\n        for(int i = 1; i < m; ++i){\n            int l = pi[i-1];\n            while(l < pi[i]){\n                if(p[l].st-p[pi[i-1]].st >= 30)\n                    break;\n                ++l;\n            }\n            if(l == pi[i])\n                continue;\n            //printf(\"#%d\\n\",l);\n            int r = pi[i];\n            while(r > pi[i-1]){\n                if(p[pi[i]].st-p[r].st >= 30)\n                    break;\n                --r;\n            }\n            if(r == pi[i-1]){\n                continue;\n            }\n            //printf(\"%d %d %d\\n\",i,l,r);\n            ans += cal(l,r);\n        }\n        //printf(\"%d\\n\",pi[0]);\n        int l = pi[m-1];\n        while(l < n){\n            if(p[l].st-p[pi[m-1]].st >= 30)\n                break;\n            ++l;\n        }\n        if(l < n)\n            ans += cal(l,n-1);\n        //printf(\"%d\\n\",ans);\n        int r = pi[0];\n        while(r >= 0){\n            if(p[pi[0]].st-p[r].st >= 30)\n                break;\n            --r;\n        }\n        if(r >= 0){\n            ans += cal(0,r);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        set<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.insert(s);\n        }\n        int p=-100000;\n        bool m=false;\n        int c=0;\n        for(int i=0;i<n;i++){\n            if(p+30>vec[i].first){\n                if(fav.count(vec[i].second)){\n                    if(m){\n                        c=-1;\n                        break;\n                    }else{\n                        m=true;\n                        p=vec[i].first;\n                    }\n                }\n            }else{\n                c++;\n                p=vec[i].first;\n                m=fav.count(vec[i].second);\n            }\n        }\n        cout<<c<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvi in(n);\n\t\trep(i,n){\n\t\t\tstring s;int a,b;\n\t\t\tcin>>s>>a>>b;\n\t\t\tin[i]=(a*24*60)+(b/100*60+b%100)-6*60;\n\t\t\tma[s]=i;\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tint out=m;\n\t\tvi dp(7*24*60+100);\n\t\tbool h=true;\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint t=ma[s];\n\t\t\tloop(j,in[t],in[t]+30){\n\t\t\t\tif(dp[j])h=false;\n\t\t\t\tdp[j]=true;\n\t\t\t}\n\t\t}\n\t\tif(!h){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(in));\n\t\tint t=-1;\n\t\trep(i,n){\n\t\t\tif(dp[in[i]]||dp[in[i]+29])continue;\n\t\t\tif(in[i]<t)continue;\n\t\t\tt=in[i]+30;\n\t\t\tout++;\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF (1<<30)\nint main(){\n  int N,P;\n  while(cin >> N , N){\n    int ans = 0;\n    vector<pair<int,string> > vc(N);\n    for(int i = 0 ; i < N ; i++ ){\n      string name;\n      int weekday , start;\n      cin >> name >> weekday >> start;\n      vc[i] = make_pair(weekday * 24 * 60 + (start/100)*60 + start % 100,name);\n    }\n    sort(vc.begin(),vc.end());\n    cin >> P;\n    for(int q = 0 ; q < P ; q++ ){\n      string fav;\n      bool OR = false;\n      cin >> fav;\n      for(int i = 0 ; i < (int)vc.size() ; i++ ){\n        if(vc[i].sc == fav){\n          OR = true;\n          pair<int,string> r = make_pair(vc[i].fr-29,\"0\"),l = make_pair(vc[i].fr+30,\"0\");\n          vc.erase(lower_bound(vc.begin(),vc.end(),r),lower_bound(vc.begin(),vc.end(),l));\n          break;\n        }\n      }\n      if(!OR) ans = -INF;\n    }\n    int now = 0;\n    for(int i = 0 ; i < (int)vc.size() ; i++ ){\n      if(vc[i].fr >= now) now = vc[i].fr + 30 , ans++;\n    }\n    cout << max(-1,ans+P) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n \n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n#define f first\n#define s second\n \ntypedef pair<int, int> P;\ntypedef map<string, P> Program;\n \nProgram prog;\nvector<string> all;\nvector<string> fav;\nvector<string> normal;\nbool watched[7][1800];\nint ans;\n\nint toMinute(string t){\n  int ret = 0;\n  if(t.size() == 3){\n    ret += (t[0]-'0') * 60;\n    ret += (t[1]-'0') * 10 + (t[2]-'0');\n  }\n  else if(t.size() == 4){\n    int h =(t[0]-'0') * 10 + (t[1]-'0');\n    ret += h * 60;\n    ret += (t[2]-'0') * 10 + (t[3]-'0');\n  }\n  return ret;\n}\n \nbool watchFavAnime(){\n  rep(i, fav.size()){\n    P t = prog[fav[i]];\n    for(int T = t.s ; T < t.s+30 ; T++){\n      if(watched[t.f][T] == 1) return false;\n      watched[t.f][T] = 1;\n    }\n    ans++;\n  }\n  return true;\n}\n\nvoid init(){\n  prog.clear();\n  fav.clear();\n  all.clear();\n  normal.clear();\n  memset(watched, 0, sizeof(watched));\n  ans = 0;\n}\n\nint main(){\n  int n, p; \n  while(cin >> n, n){\n    init();\n    string name, tim;\n    P t;\n    rep(i, n){\n      cin >> name >> t.f >> tim;\n      int m = toMinute(tim);\n      t.s = m;\n      prog[name] = t;\n      all.push_back(name);\n    }\n     \n    cin >> p;\n    rep(i, p){\n      cin >> name;\n      fav.push_back(name);\n    }\n    \n    if(!watchFavAnime()){\n      cout << \"-1\" << endl;\n      continue;\n    }\n     \n    rep(i, n){\n      bool flag = true;\n      rep(j, fav.size()){\n\tif(all[i] == fav[j]){\n\t  flag = false;\n\t  break;\n\t}\n      }\n      if(flag) normal.push_back(all[i]);\n    }\n    \n    vector<P> nor;\n    rep(i, normal.size()){\n      nor.push_back(prog[normal[i]]);\n    }\n    \n    sort(nor.begin(), nor.end());\n    \n    rep(i, nor.size()){\n      int w = nor[i].f;\n      int m = nor[i].s;\n      bool f = true;\n      for(int T = m ; T < m+30 ; T++){\n\tif(watched[w][T] == 1){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f){\n\tfor(int T = m ; T < m+30 ; T++){\n\t  watched[w][T] = 1;\n\t}\n\tans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m)%10080;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    vector<pair<int,string>> animes2;\n    map<int,string> range;\n    bool ok=true;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        //cout<<m<<endl;\n        animes[name]=m;\n        animes2.pb(mp(m,name));\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) ok=false;;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    sort(all(animes2));\n    for(const auto &anime : animes2) {\n        string s=anime.second;\n        int m=anime.first;\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    if(!ok) return -1;\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nclass Program{\npublic:\n\tstring name;\n\tint time;\n\tbool operator<(const Program program)const{return time<program.time;}\n};\n\nvector<Program> program;\nvector<int> f;\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tprogram.clear();\n\t\tf.clear();\n\t\tint i,j;\n\t\tfor(i=0;i<n;i++){\n\t\t\tProgram buf;\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tbuf.name=name;\n\t\t\tbuf.time=weekday*1440+start/100*60+start%100;\n\t\t\tprogram.push_back(buf);\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tint p=in();\n\t\tstring fav;\n\t\tfor(i=0;i<p;i++){\n\t\t\tcin>>fav;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(program[j].name==fav){\n\t\t\t\t\tf.push_back(program[j].time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(f.begin(),f.end());\n\t\tfor(i=0;i<p-1;i++){\n\t\t\tif(f[i]+30>f[i+1])break;\n\t\t}\n\t\tif(i!=p-1){\n\t\t\tcout<<-1<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint res=p,end=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(end>program[i].time)continue;\n\t\t\tfor(j=0;j<p;j++){\n\t\t\t\tif(program[i].time-30<f[j]&&f[j]<program[i].time+30)break;\n\t\t\t}\n\t\t\tif(j<p)continue;\n//cout<<program[i].name<<\" \"<<program[i].time<<endl;\n\t\t\tres++;\n\t\t\tend=program[i].time+30;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : TopCoderCompetition.cpp\n// Author      : taguchi\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <list>\nusing namespace std;\n//#define P pair<int,int>\n#define rep(i,n) for(int i = 0;i<n;i++)\n#define pb(n) push_back(n)\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nstruct edge{int cost,to;};\n\nvector<string> split(string &in,char delimiter){\n\tvector<string> re; uint cur = 0,next;\n\twhile((next = in.find_first_of(delimiter,cur)) != string::npos){\n\t\tre.pb(string(in,cur,next-cur));\n\t\tcur = next + 1;\n\t}\n\tre.pb(string(in,cur,in.size()-cur));\n\treturn re;\n}\nvector<int> split_int(string &in, char delimiter){\n\tvector<string> str = split(in,delimiter);\n\tvector<int> re;\n\trep(i,str.size()){\n\t\tre.pb(strtol(str[i].c_str(),NULL,10));\n\t}\n\treturn re;\n}\n\nclass Range{\npublic:\n\tint a,b;\n\tRange(int an,int bn) : a(an),b(bn){}\n\n\tbool operator()(int n){\n\t\treturn a<=n&&n<=b;\n\t}\n\tbool isCross(Range x){\n\t\treturn x(a) || x(b);\n\t}\n\tbool contains(Range x){\n\t\treturn this->a <= x.a && x.b <= this->b;\n\t}\n};\n\nclass RangeHandler{\npublic:\n\tlist<Range> Ranges;\n\n\tbool insert(Range x){\n\t\tif(Ranges.empty()){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\n\t\tif(x.b <= Ranges.front().a){\n\t\t\tRanges.push_front(x);\n\t\t\treturn true;\n\t\t}\n\t\tif(Ranges.back().b <= x.a){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\t\tfor(list<Range>::iterator i = Ranges.begin();i != Ranges.end();i++){\n\t\t\tlist<Range>::iterator l = i;\n\t\t\tl++;\n\t\t\t//cout << \"dbg\" << i->b << \" \" << i->a << endl;\n\t\t\tif(Range(i->b,l->a).contains(x)){\n\t\t\t\tRanges.insert(l,x);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nint N,P;\nint main(){\n\twhile(true){\n\t\tint result = 0;\n\t\tcin >> N;\n\t\tif(N == 0)break;\n\t\tvector<pair<int,string> > Programs,Table;\n\t\tvector<pair<int,string> >::iterator ip;\n\t\trep(i,N){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tint weekday,start;\n\t\t\tcin >> weekday >> start;\n\t\t\tstart -=600;\n\t\t\tint time = 1440 * weekday + (start / 100) * 60 + (start % 100);\n\t\t\tPrograms.pb(make_pair(time,name));\n\t\t}\n\t\tcin >> P;\n\t\trep(i,P){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tfor(ip = Programs.begin();ip!=Programs.end();ip++){\n\t\t\t\tif(ip->second == name){\n\t\t\t\t\tTable.pb(*ip);\n\t\t\t\t\tPrograms.erase(ip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(Programs.begin(),Programs.end());\n\t\trep(i,Programs.size()){\n\t\t\tTable.pb(Programs[i]);\n\t\t}\n\t\tRangeHandler rg;\n\t\tbool ans = true;\n\t\trep(i,Table.size()){\n\t\t\tif(rg.insert(Range(Table[i].first,Table[i].first+30))){\n\t\t\t\tans &= true;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\telse ans = false;\n\t\t\tif(i < P && !ans) {\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint main()\n{\n\tint n, p;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\ttypedef pair<int, string> P;\n\t\t\n\t\tP pro[512];\n\t\trep (i, n)\n\t\t{\n\t\t\tchar buf[64];\n\t\t\tint w, s;\n\t\t\tscanf(\"%s%d%d\", buf, &w, &s);\n\t\t\tpro[i] = P(w*24*60 + s/100*60 + s%100, buf);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\tset<string> fav;\n\t\trep (i, p)\n\t\t{\n\t\t\tchar buf[64];\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfav.insert(buf);\n\t\t}\n\n\t\tconst int week_minutes = 7*24*60;\n\t\tbool watch[week_minutes];\n\t\tfill_n(watch, week_minutes, false);\n\t\tint res = 0;\n\t\trep (i, n)\n\t\t{\n\t\t\tstring& name = pro[i].second;\n\t\t\tint time = pro[i].first;\n\t\t\tif (!fav.count(name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < 30; ++j)\n\t\t\t{\n\t\t\t\tint t = (time + j) % week_minutes;\n\t\t\t\tif (watch[t])\n\t\t\t\t{\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twatch[t] = true;\n\t\t\t}\n\t\t\tif (res == -1)\n\t\t\t\tbreak;\n\n\t\t\t++res;\n\t\t}\n\t\tif (res == -1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\n\t\trep (i, n)\n\t\t{\n\t\t\tstring& name = pro[i].second;\n\t\t\tint time = pro[i].first;\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < 30; ++j)\n\t\t\t{\n\t\t\t\tint t = (time + j) % week_minutes;\n\t\t\t\tif (watch[t])\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twatch[t] = true;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\t++res;\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\tifstream cin(\"input.txt\");\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size();i++) {\n\t\t\tfor(int j=0;j<fav.size();j++) {\n\t\t\t\tif(i!=j&&Diff(fav[i].first,fav[j].first)) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(!Diff(anime[i].first,anime[j].first)) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef map<string,P>M;\nint main()\n{\n\tint n,d,t,r,i,j;\n\tchar s[99];\n\tM m;\n\tM::iterator ite;\n\tP p;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint f[7][1440]={};\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%s%d%d\",s,&d,&t);\n\t\t\tt=t%100+(t-600)/100*60;\n\t\t\tm[s]=P(d,t);\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(r=n;n--;)\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tp=(ite=m.find(s))->second;\n\t\t\tfor(i=0;i<30;++i)\n\t\t\t\tif(f[p.first][p.second+i]++)r=-1;\n\t\t\tm.erase(ite);\n\t\t}\n\t\tif(r>=0)\n\t\t{\n\t\t\tvector<P>v;\n\t\t\tfor(ite=m.begin();ite!=m.end();++ite)v.push_back(ite->second);\n\t\t\tsort(v.begin(),v.end());\n\t\t\tfor(i=0;i<v.size();++i)\n\t\t\t{\n\t\t\t\tP p=v[i];\n\t\t\t\tif(!f[p.first][p.second]&&!f[p.first][p.second+29])\n\t\t\t\t{\n\t\t\t\t\t++r;\n\t\t\t\t\tfor(j=0;j<30;++j)f[p.first][p.second+j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nvector<P> anime;\nvector<P> fav;\n\nbool Overlap(int x,int y) {\n\tint _max=max(x,y),_min=min(x,y);\n\treturn (_max-_min)<30;\n}\n\nbool Check(P& p) {\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(p.second!=fav[i].second&&Overlap(p.first,fav[i].first)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tstart=weekday*1440+start/100*60+start%100;\n\t\t\tif(start<600) start+=1440*7;\n\t\t\tanime.push_back(P(start,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(anime[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<p&&ok;i++) {\n\t\t\tfor(int j=0;j<p&&ok;j++) {\n\t\t\t\tif(i!=j&&Overlap(fav[i].first,fav[j].first)) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {cout<<-1<<endl;continue;}\n\t\tanime.erase(remove_if(anime.begin(),anime.end(),Check),anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<vst.size()&&ok;j++) {\n\t\t\t\tif(Overlap(anime[i].first,vst[j])) ok=false;\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcount++;\n\t\t\t\tvst.push_back(anime[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1063\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <int, int> P;\n\nint main(void)\n{\n\tint n, p;\n\n\twhile (cin >> n, n){\n\t\tvector < pair <P, int> > v, must;\n\t\tvector < string > name;\n\t\tstring tmp;\n\t\tint week, start;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> tmp >> week >> start;\n\t\t\tint s = (week * 60 * 60 * 24) + (start / 100 * 60 * 60) + ((start % 100) * 60);\n\t\t\tint t = s + (60 * 30);\n\t\t\tv.push_back(make_pair(make_pair(t, s), i));\n\t\t\tname.push_back(tmp);\n\t\t}\n\t\tcin >> p;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tcin >> tmp;\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (tmp == name[j]){\n\t\t\t\t\tmust.push_back(make_pair(v[j].first, j));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\tsort(must.begin(), must.end());\n\n\t\t// for (int i = 0; i < n; i++){\n\t\t// \tint s = v[i].first.second, e = v[i].first.first, id = v[i].second;\n\t\t// \tcout << name[id] << \" \" << s << \" \" << e << endl;\n\t\t// }\n\n\t\tint ret = -1, last = -1;\n\t\tbool done[512] = {false}, flag = true;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tif (last > must[i].first.second){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = must[i].first.first;\n\t\t}\n\t\tif (!flag){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = p;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tdone[must[i].second] = true;\n\t\t}\n\n\t\tlast = -1;\n\t\t// cout << \"*****\" << endl;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint s = v[i].first.second, e = v[i].first.first, id = v[i].second;\n\t\t\t// cout << last << \" \" << name[id] << endl;\n\t\t\tif (done[id]){\n\t\t\t\t// cout << \" <3 \" << name[id] << endl;\n\t\t\t\tlast = e;\n\t\t\t\tfor (int j = i - 1; j >= 0; j--){\n\t\t\t\t\t// cout << name[v[j].second] << \" \" << done[v[j].second] << endl;\n\t\t\t\t\tif (s < v[j].first.first){\n\t\t\t\t\t\tif (done[v[j].second]){\n\t\t\t\t\t\t\tret--;\n\t\t\t\t\t\t\tdone[v[j].second] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// cout << \" xx \" << name[v[j].second] << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (last > s) continue;\n\t\t\tret++;\n\t\t\tlast = e;\n\t\t\tdone[id] = true;\n\t\t\t// cout << \" <3 \" << name[id] << endl;\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\n//Watchin' TVA\nclass Program{\npublic:\n\tint time;\n\tstring name;\n\tProgram(int _time, string _name) : time(_time), name(_name) {}\n\n\tbool operator < (const Program& p) const{\n\t\treturn time < p.time;\n\t}\n};\n\nint main(){\n\tint N,P;\n\t\n\n\twhile(~scanf(\"%d\",&N)){\n\t\tif(N==0) break;\n\t\tmap<int,vector<Program> > PRO;\n\t\tmap<string,bool> FAV;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring name;\n\t\t\tint day;\n\t\t\tint time;\n\t\t\tcin >> name >> day >> time;\n\t\t\tint m = time % 100;\n\t\t\tint h = time / 100;\n\t\t\tint total = h * 60 + m;\n\t\t\tPRO[day].push_back(Program(total,name));\n\t\t}\n\t\tscanf(\"%d\",&P);\n\t\tfor(int i=0;i<P;i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tFAV[name] = true;\n\t\t}\n\n\t\tbool failed = false;\n\t\tint res = 0;\n\t\tfor(map<int,vector<Program> >::iterator it = PRO.begin(); it != PRO.end(); it++){\n\t\t\tbool reserve[10000];\n\t\t\tmemset(reserve,0,sizeof(reserve));\n\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) != FAV.end()){\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(reserve[j]){\n\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treserve[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) == FAV.end()){\n\t\t\t\t\tbool tmp[10000];\n\t\t\t\t\tmemcpy(tmp,reserve,sizeof(reserve));\n\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(tmp[j]){\n\t\t\t\t\t\t\tgoto cancel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(reserve,tmp,sizeof(tmp));\n\t\t\t\t\tres++;\n\t\t\t\t}\t\t\ncancel:;\n\t\t\t}\n\t\t}\nnext:;\n\n\t\tif(failed){\n\t\t\tprintf(\"%d\\n\",-1);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n\n/*struct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};*/\n\nint setup(int w,int s){\n  int h = s / 100;\n  int m = s % 100;\n  if(h >= 24){\n    h -= 24;\n    w++;\n  }\n  return h*60 + m + w * 60 * 24;\n\n}\n/*\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}*/\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<int> table;\n      vector<int> favoritetable;\n      map<string,int> amap;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        int t;\n        t = setup(we,st);\n        table.push_back(t);\n        amap[na] = t;\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        favoritetable.push_back(amap[na]);\n      }\n\n      sort(table.begin() , table.end());\n      sort(favoritetable.begin(), favoritetable.end());\n\n    //  int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      for(int i=1; i<favoritetable.size(); ++i){\n        if(abs(favoritetable[i] - favoritetable[i-1]) < 30){\n          cansee = false;\n        }\n      }\n\n      for(int i=0; i<table.size(); i++){\n        for(int j=0; j<favoritetable.size(); j++){\n          if(abs(table[i] - favoritetable[j]) < 30){\n            table.erase(table.begin() + i);\n            i--;\n            break;\n          }\n        }\n      }\n\n      int ans = table.size() + f;\n      long int tmp = 0;\n\n      for(int i=0; i<table.size(); i++){\n        if(abs(table[i] - tmp) < 30){\n          ans--;\n        }\n        else{\n          tmp = table[i];\n        }\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << ans << endl;\n      }\n\n      /*\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n      */\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size();i++) {\n\t\t\tfor(int j=0;j<fav.size();j++) {\n\t\t\t\tif(i!=j&&Diff(fav[i].first,fav[j].first)) {okay=false;}\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tif(anime[i].first==-1) continue; else count++;\n\t\t\tint temp=anime[i].first;\n\t\t\tfor(int j=0;j<anime.size();j++) {\n\t\t\t\tif(Diff(temp,anime[j].first)) anime[j].first=-1;\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m)%10080;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    vector<pair<int,string>> animes2;\n    map<int,string> range;\n    bool f=true;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        //cout<<m<<endl;\n        animes[name]=m;\n        animes2.pb(mp(m,name));\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) f=false;;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    sort(all(animes2));\n    for(const auto &anime : animes2) {\n        string s=anime.second;\n        int m=anime.first;\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    if(!f) return -1;\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : TopCoderCompetition.cpp\n// Author      : taguchi\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <list>\nusing namespace std;\n//#define P pair<int,int>\n#define rep(i,n) for(int i = 0;i<n;i++)\n#define pb(n) push_back(n)\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nstruct edge{int cost,to;};\n\nvector<string> split(string &in,char delimiter){\n\tvector<string> re; uint cur = 0,next;\n\twhile((next = in.find_first_of(delimiter,cur)) != string::npos){\n\t\tre.pb(string(in,cur,next-cur));\n\t\tcur = next + 1;\n\t}\n\tre.pb(string(in,cur,in.size()-cur));\n\treturn re;\n}\nvector<int> split_int(string &in, char delimiter){\n\tvector<string> str = split(in,delimiter);\n\tvector<int> re;\n\trep(i,str.size()){\n\t\tre.pb(strtol(str[i].c_str(),NULL,10));\n\t}\n\treturn re;\n}\n\nclass Range{\npublic:\n\tint a,b;\n\tRange(int an,int bn) : a(an),b(bn){}\n\n\tbool operator()(int n){\n\t\treturn a<=n&&n<=b;\n\t}\n\tbool isCross(Range x){\n\t\treturn x(a) || x(b);\n\t}\n\tbool contains(Range x){\n\t\treturn this->a <= x.a && x.b <= this->b;\n\t}\n};\n\nclass RangeHandler{\npublic:\n\tlist<Range> Ranges;\n\n\tbool insert(Range x){\n\t\tif(Ranges.empty()){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\n\t\tif(x.b < Ranges.front().a){\n\t\t\tRanges.push_front(x);\n\t\t\treturn true;\n\t\t}\n\t\tif(Ranges.back().b < x.a){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\t\tfor(list<Range>::iterator i = Ranges.begin();i != Ranges.end();i++){\n\t\t\tlist<Range>::iterator l = i;\n\t\t\tl++;\n\t\t\t//cout << \"dbg\" << i->b << \" \" << i->a << endl;\n\t\t\tif(Range(i->b,l->a).contains(x)){\n\t\t\t\tRanges.insert(l,x);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nint N,P;\nint main(){\n\twhile(true){\n\t\tint result = 0;\n\t\tcin >> N;\n\t\tif(N == 0)break;\n\t\tvector<pair<int,string> > Programs,Table;\n\t\tvector<pair<int,string> >::iterator ip;\n\t\trep(i,N){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tint weekday,start;\n\t\t\tcin >> weekday >> start;\n\t\t\tstart -=600;\n\t\t\tint time = 1440 * weekday + (start / 100) * 60 + (start % 100);\n\t\t\tPrograms.pb(make_pair(time,name));\n\t\t}\n\t\tcin >> P;\n\t\trep(i,P){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tfor(ip = Programs.begin();ip!=Programs.end();ip++){\n\t\t\t\tif(ip->second == name){\n\t\t\t\t\tTable.pb(*ip);\n\t\t\t\t\tPrograms.erase(ip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(Programs.begin(),Programs.end());\n\t\trep(i,Programs.size()){\n\t\t\tTable.pb(Programs[i]);\n\t\t}\n\t\tRangeHandler rg;\n\t\tbool ans = true;\n\t\trep(i,Table.size()){\n\t\t\tif(rg.insert(Range(Table[i].first,Table[i].first+30))){\n\t\t\t\tans &= true;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\telse ans = false;\n\t\t\tif(i < P && !ans) {\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nconst int MOD=7*24*60;\nint time[ 30000 ];\nint n,m;\nchar data[ 600 ][ 50 ];\nint start[ 600 ];\nint main( void ){\n    int a,b,ret;\n    int s,t,tf;\n    int temp;\n    char c[ 50 ];\n    while( ( scanf( \"%d\",&n ),n ) ){\n        memset( time,0,sizeof( time ) );\n        ret=0;\n        for( int i=0;i<n;i++ ){\n            scanf( \"%s\",data[ i ] );\n            scanf( \"%d%d\",&a,&b );\n            b=b/100*60+( b-b/100*100 );\n            b=a*24*60+b;\n            b=b%MOD;\n            start[ i ]=b;\n        }\n        scanf( \"%d\",&m );\n        for( int i=1;i<=m;i++ ){\n            scanf( \"%s\",c );\n            for( int j=0;j<n;j++ )\n                if( !strcmp( c,data[ j ] ) ){\n                    time[ start[ j ] ]=-1;\n                    break;\n                }\n        }\n        ret=m;\n        sort( start,start+n );\n        t=0;\n        while( t<n ){\n            if( time[ start[ t ] ]==-1 ){\n                temp=start[ t ]+30;\n                for( ;t<n&&start[ t ]<temp;t++ );\n            }\n            else{\n                temp=start[ t ]+30;\n                tf=0;\n                for( int i=t;i<n&&start[ i ]<temp;i++ )\n                    if( time[ start[ i ] ]==-1 ){\n                        tf=i;\n                        break;\n                    }\n                if( tf ){\n                    t=tf;\n                }\n                else{\n                    ret++;\n                    temp=start[ t ]+30;\n                    for( ;t<n&&start[ t ]<temp;t++ );\n                }\n            }\n        }\n        printf( \"%d\\n\",ret );\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N, P;\nmap<string,int> all[7];\nmap<string,int> weeks;\nbool flag[7][3100];\n\nint main() {\n  while (cin>>N, N) {\n    rep(i,7) all[i].clear();\n    weeks.clear();\n    {\n      string name;\n      int week, start;\n      rep(i,N) {\n        cin>>name>>week>>start;\n        all[week].insert(make_pair(name,start/100*60+start%100));\n        weeks.insert(make_pair(name,week));\n      }\n      cin>>P;\n      memset(flag, false, sizeof flag);\n      //vector<string> fav;\n      set<string> fav;\n      bool ok  = true;\n      rep(i,P) {\n        cin>>name;\n        //fav.push_back(name);\n        fav.insert(name);\n        int week = weeks[name];\n        int offset = all[week][name];\n        if (flag[week][offset]) { ok = false; }\n        if (!ok) { continue; }\n        for (int j = offset; j < offset+30; ++j) flag[week][j] = true;\n      }\n      if (!ok) { puts(\"-1\"); continue; }\n\n      //sort(fav.begin(), fav.end());\n      rep(i,7) {\n        set<int> s;\n        foreach(all[i],itr) {\n          // if(!binary_search(fav.begin(), fav.end(), itr->first)) {\n          //   if (s.count(itr->second)) s.insert(itr->second);\n          // }\n          if (!fav.count(itr->first)) {\n            s.insert(itr->second);\n          }\n        }\n        //cout<<\"[\"<<s.size()<<\"]\"<<endl;\n        foreach(s,itr) {\n          int v = *itr;\n          //cout<<\"(\"<<v<<\")\"<<endl;\n          if (flag[i][v] || flag[i][v+29]) continue;\n          for (int j = v; j < v+30; ++j) flag[i][j] = true;\n        }\n      }\n\n      int ret = 0;\n      rep(i,7) {\n        for (int j = 0; j < 3000; ++j) {\n          if (!flag[i][j]) continue;\n          //cout << i << \",\" <<j << endl;\n          ++ret;\n          j += 29;\n        }\n      }\n      cout << ret << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m);\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    vector<pair<int,string>> animes2;\n    map<int,string> range;\n    bool ok=true;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        //cout<<m<<endl;\n        animes[name]=m;\n        animes2.pb(mp(m,name));\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) ok=false;;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    sort(all(animes2));\n    for(const auto &anime : animes2) {\n        string s=anime.second;\n        int m=anime.first;\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    if(!ok) return -1;\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m)%10080;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    map<int,string> range;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        animes[name]=m;\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) return -1;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    for(const auto &anime : animes) {\n        string s=anime.first;\n        int m=anime.second;\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\nconst int MAXN = 11111;\nint dp[555][MAXN];\nstring name;\nmap<string, int> mp;\n//dp[i][j] = max(dp[i - 1][j - 30]);\nstruct bit {\n\tint n, c[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tmemset(c, 0, n * sizeof(int));\n\t}\n\tvoid update(int x, int y) {\n\t\tx+=2;\n\t\twhile (x < n) {\n\t\t\tc[x] = max(c[x], y);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint get(int x) {\n\t\tx+=2;\n\t\tint ret = 0;\n\t\twhile (x) {\n\t\t\tret = max(ret, c[x]);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}b;\n\nstruct data {\n\tint id, time;\n\tbool over;\n\tfriend bool operator <(const data& a, const data& b) {\n\t\treturn a.time < b.time;\n\t}\n}d[555];\nint id[555], idx = 0;\n\nbool notok(int a, int b) {\n\tif (d[a].time > d[b].time) {\n\t\tswap(a, b);\n\t}\n\tif (d[a].time + 30 > d[b].time) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint used[11111];\n\nint main() {\n\tint n, m;\n\tstring name;\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tmp.clear();\n\t\tint week, hour;\n\t\tint maxv = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> name >> week >> hour;\n\t\t\td[i].id = i - 1;\n\t\t\td[i].over = false;\n\t\t\td[i].time = week * 24 * 60 + ((hour / 100) - 5) * 60 + ((hour % 100));\n\t\t\tmaxv = max(maxv, d[i].time);\n\t\t\tcout << d[i].time << endl;\n\t\t\tmp[name] = i;\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tgetchar();\n\t\tidx = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tgetline(cin, name);\n\t\t\td[mp[name]].over = true;\n\t\t\tid[idx++] = mp[name];\n\t\t}\n\t\tmemset(used, 0, sizeof(used));\n\t\tbool die = false;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < idx; i++) {\n\t\t\tfor (int j = i + 1; j < idx; j++) {\n\t\t\t\tif (notok(id[i], id[j])) {\n\t\t\t\t\tdie = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << id[i] << endl;\n\t\t\tfor (int j = d[id[i]].time; j < d[id[i]].time + 30; j++) {\n\t\t\t\tused[j] = true;\n\t\t\t}\n\t\t\tans++;\n\t\t\tif (die) break;\n\t\t}\n\t\tif (die) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(d + 1, d + n + 1);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\tif (used[j]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\t//cout << i << endl;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<anime> table;\n      vector<anime> favoritetable;\n      map<string,anime> amap;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        anime t;\n        t.setup(na,we,st);\n        table.push_back(t);\n        amap[na] = t;\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        favoritetable.push_back(amap[na]);\n      }\n\n      sort(table.begin() , table.end());\n      sort(favoritetable.begin(), favoritetable.end());\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      for(int i=0; i<favoritetable.size()-1; i++){\n        if(abs(favoritetable[i+1].minutes - favoritetable[i].minutes) < 30){\n          cansee = false;\n          break;\n        }\n      }\n\n      for(int i=0; i<table.size(); i++){\n        for(int j=0; j<favoritetable.size(); j++){\n          if(abs(table[i].minutes - favoritetable[j].minutes) < 30){\n            table.erase(table.begin() + i);\n            i--;\n            break;\n          }\n        }\n      }\n\n      int ans = table.size() + f;\n      long int tmp = 0;\n\n      for(int i=0; i<table.size(); i++){\n        if(abs(table[i].minutes - tmp) < 30){\n          ans--;\n        }\n        else{\n          tmp = table[i].minutes;\n        }\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << ans << endl;\n      }\n\n      /*\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n      */\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nint solve(int start){\n  int ai=0,bi=0,now=start,res=0;\n  int as=A.size(),bs=B.size();\n  while(ai<as||bi<bs){\n    int ag=(ai<as?A[ai].first:1e9);\n    int bg=(bi<bs?B[bi].first:1e9);\n    if(now<=ag&&ag+30<=bg){\n      now=ag+30;\n      if(now<=7*60*24+start)res++;\n      ai++;\n    }else if(ag<now){\n      ai++;\n    }else{\n      now=bg+30;\n      if(now<=7*60*24+start)res++;\n      bi++;\n    }\n  }\n  return res;\n}\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b%(7*60*24),i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n    int ans=0;\n    for(int i=0;i<30;i++)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return w*1440+h*60+m;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    map<int,string> range;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        animes[name]=m;\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) return -1;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    for(const auto &anime : animes) {\n        string s=anime.first;\n        int m=anime.second;\n        if(!range.count(m) && !range.count(m+29)) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint n,p;\nstruct data{\n\tstring name;\n\tint h,m;\n\tdata(){}\n\tdata(string s,int hh,int mm){\n\t\tname=s;\n\t\th=hh;\n\t\tm=mm;\n\t}\n};\n\nbool comp(const data& d1,const data& d2){\n\tif(d1.h==d2.h)return d1.m<d2.m;\n\treturn d1.h<d2.h;\n}\n\ndata d[7][501];\nint dcnt[7];\nset<string> fav;\nbool used[7][30][61];\n\nbool check(){\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<dcnt[i];j++){\n\t\t\tif(fav.find(d[i][j].name)!=fav.end()){\n\t\t\t\tint k=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\twhile(k<30){\n\t\t\t\t\tif(used[i][nh][nm])return false;\n\t\t\t\t\tused[i][nh][nm]=true;\n\t\t\t\t\tk++;\n\t\t\t\t\tnm++;\n\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\tnh++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(dcnt,0,sizeof(dcnt));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint w,s;\n\t\t\tstring str;\n\t\t\tcin >> str >> w >> s;\n\t\t\td[w][dcnt[w]]=data(str,s/100,s%100);\n\t\t\tdcnt[w]++;\n\t\t}\n\t\tfav.clear();\n\t\tscanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfav.insert(str);\n\t\t}\n\t\tmemset(used,false,sizeof(used));\n\t\tif(!check()){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tsort(d[i],d[i]+dcnt[i],comp);\n\t\t\tfor(int j=0;j<dcnt[i];j++){\n\t\t\t\tif(fav.find(d[i][j].name)!=fav.end())continue;\n\t\t\t\tint k=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\twhile(k<30){\n\t\t\t\t\tif(used[i][nh][nm])break;\n\t\t\t\t\tk++;\n\t\t\t\t\tnm++;\n\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\tnh++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==30){\n\t\t\t\t\tk=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\t\tcnt++;\n\t\t\t\t\twhile(k<30){\n\t\t\t\t\t\tif(used[i][nh][nm])return false;\n\t\t\t\t\t\tused[i][nh][nm]=true;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tnm++;\n\t\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\t\tnh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt+p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(weekday != arg.weekday){\n\t\t\treturn weekday < arg.weekday;\n\t\t}else{\n\t\t\treturn start < arg.start;\n\t\t}\n\t}\n\tint weekday,start,end;\n\tchar name[33];\n};\n\nint N;\nInfo info[500];\nbool check[7][1440];\nbool used[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint translate_TIME(char buf[5]){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tint hour,minute;\n\n\tif(length == 3){\n\t\thour = buf[0]-'0';\n\t\tminute = 10*(buf[1]-'0')+(buf[2]-'0');\n\t}else{\n\t\thour = 10*(buf[0]-'0')+(buf[1]-'0');\n\t\tminute = 10*(buf[2]-'0')+(buf[3]-'0');\n\t}\n\thour -= 6;\n\treturn 60*hour+minute;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int k = 0; k < 1440; k++)check[i][k] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tchar start[5];\n\tint tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s\",info[i].name,&info[i].weekday,start);\n\n\t\ttmp = translate_TIME(start);\n\n\t\tinfo[i].start = tmp;\n\t\tinfo[i].end = tmp+29;\n\t}\n\n\tsort(info,info+N);\n\n\t/*for(int i = 0; i < N; i++){\n\t\tprintf(\"w_day:%d start:%d end:%d\\n\",info[i].weekday,info[i].start,info[i].end);\n\t}*/\n\n\tvector<int> MUST;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tchar tmp_name[33];\n\n\tfor(int loop = 0; loop < P; loop++){\n\t\tscanf(\"%s\",tmp_name);\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(strCmp(info[i].name,tmp_name)){\n\t\t\t\tMUST.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//???????????????????????????????????????????????????\n\tbool FLG = true;\n\n\tfor(int i = 0; i < P-1; i++){\n\t\tfor(int k = i+1; k < P; k++){\n\t\t\tif(info[MUST[i]].start >= info[MUST[k]].end || info[MUST[i]].end <= info[MUST[k]].start){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!FLG){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tused[MUST[i]] = true;\n\t\tfor(int k = info[MUST[i]].start; k < info[MUST[i]].end; k++){\n\t\t\tcheck[info[MUST[i]].weekday][k] = true;\n\t\t}\n\t}\n\n\tvector<int> V; //??????????????????????????§???????????????\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\t\t\tV.push_back(i);\n\t\t}\n\t}\n\n\tint ans = P;\n\tint right,V_index = 0;\n\tbool Found;\n\n\tfor(int w_day = 0; w_day < 7; w_day++){\n\t\tfor(int time = 0; time < 1440;){\n\t\t\tif(check[w_day][time]){\n\t\t\t\ttime++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(right = time; right+1 < 1440 && check[w_day][right+1] == false; right++);\n\n\t\t\tif(right-time+1 < 30){ //????????????????¶?:?°?????????¨???right?????§????????¬?????????????????????\n\n\t\t\t\t//right??\\???????§????????????????????????????\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start <= right)){\n\t\t\t\t\t\t V_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime = right+1;\n\t\t\t}else{ //right?????§?????????????????????????????°????????´??????\n\n\t\t\t\tFound = false;\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start < time)){\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t}else if(info[V[V_index]].weekday == w_day && info[V[V_index]].start >= time && info[V[V_index]].end <= right){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ttime = info[V[V_index]].end;\n\t\t\t\t\t\tFound = true;\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Found){\n\t\t\t\t\ttime = right+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint n,i,r,last,time,day;\n\tfor(;cin>>n,n;){\n\t\tvector<pair<int,string> >program;\n\t\tset<string>precious;\n\t\t{\n\t\t\tstring s;\n\t\t\tmap<string,int>m;\n\t\t\tfor(;n--;){\n\t\t\t\tcin>>s>>day>>time;\n\t\t\t\tprogram.push_back(make_pair(day*1440+time/100*60+time%100,s));\n\t\t\t\tm[s]=day*1440+time/100*60+time%100;\n\t\t\t}\n\t\t\tbool flg=true;\n\t\t\tfor(cin>>n;n--;){\n\t\t\t\tcin>>s;\n\t\t\t\tset<string>::iterator it=precious.begin();\n\t\t\t\tfor(;it!=precious.end();it++){\n\t\t\t\t\tif(abs(m[*it]-m[s])<30)flg=false;\n\t\t\t\t}\n\t\t\t\tprecious.insert(s);\n\t\t\t}\n\t\t\tif(!flg){puts(\"-1\");continue;}\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tfor(last=r=i=0;i<program.size();i++){\n\t\t\tif(program[i].first>=last){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t\tr++;\n\t\t\t}else if(precious.find(program[i].second)!=precious.end()){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nstatic const int MAX = 500;\nstatic const int L = 30;\n\nbool overlap(int a, int b){\n  if ( a > b ) swap(a, b);\n  return a + 30 > b;\n}\n\nint getProgram(vector<int> v){\n  sort(v.begin(), v.end());\n  int dp[MAX];\n  int maxv = v.size()>0?1:0;\n  for ( int i = 0; i < v.size(); i++ ) dp[i] = 1;\n  for ( int i = 1; i < v.size(); i++ ){\n    for ( int j = i-1; j >= 0; j-- ){\n      if ( !overlap(v[j], v[i]) ){\n\tdp[i] = dp[j]+1;\n\tmaxv = max(maxv, dp[i]);\n\tbreak;\n      }\n    }\n  }\n  return maxv;\n}\n\nint solve(int N){\n  int in[MAX], w, s, P;\n  map<string, int> M;\n  string name;\n  vector<int> F, T;\n  rep(i, N){\n    cin >> name >> w >> s;\n    M[name] = i;\n    in[i] = w*1440 + (s/100)*60 + s%100;\n  }\n  cin >> P;\n  rep(i, P){\n    cin >> name;\n    F.push_back(in[M[name]]);\n  }\n\n  int ans = getProgram(F);\n  if ( ans == 0 ) return -1;\n\n  rep(i, N){\n    bool f = true;\n    for ( int j = 0; j < F.size(); j++ ){\n      if ( overlap(F[j], in[i]) ) { f = false; break; }\n    }\n    if ( f ) T.push_back(in[i]);\n  }\n  return ans + getProgram(T);\n}\n\nmain(){\n  int N;\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin>>N&&N){\n\t\tmap<string,int> anime;\n\t\tvector<int> time;\n\t\tfor(int i=0; i<N; ++i){\n\t\t\tint weekday,start;\n\t\t\tstring name;\n\t\t\tcin >> name >> weekday >> start;\n\t\t\tint tmp=60*(start/100)+start%100;\n\t\t\tanime[name]=weekday*60*24+tmp;\n\t\t\ttime.push_back(weekday*60*24+tmp);\n\t\t}\n\t\tint P;\n\t\tcin >> P;\n\t\tvector<string> fav(P);\n\t\tfor(int i=0; i<P; ++i){\n\t\t\tcin >> fav[i];\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0; i<P; ++i){\n\t\t\tfor(int j=0; j<P; ++j){\n\t\t\t\tif(i!=j&&abs(anime[fav[i]]-anime[fav[j]])<30) flag=false;\n\t\t\t}\n\t\t}\n\t\tsort(time.begin(),time.end());\n\t\tint ans=0,t=0;\n\t\tfor(int i=0; i<N; ++i){\n\t\t\tbool flag_=true;\n\t\t\tif(t<=time[i]){\n\t\t\t\tfor(int j=0; j<P; ++j){\n\t\t\t\t\tif(time[i]!=anime[fav[j]]&&time[i]<anime[fav[j]]&&time[i]+30>anime[fav[j]]){\n\t\t\t\t\t\tflag_=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag_){\n\t\t\t\t\t++ans;\n\t\t\t\t\tt=time[i]+30;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!flag) cout << -1 << endl;\n\t\telse cout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int f = 0, res = 0;\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*24*60)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      f = true;\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tf = false;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(PRO[k].S > m[FAV]-30 && PRO[k].S < m[FAV]+30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tif(f) res -= 1000;\n\tbreak;\n      }\n      map<string, int>::iterator it = m.begin();\n      while(it != m.end()){\n\tif(FAV != it->first && abs(m[FAV]-it->second) < 30) f = 1;\n\tit++;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int tail = 0; \n    rep(i, PRO.size()){\n      if(tail <= PRO[i].S){\n\tres++;\n\ttail = PRO[i].S + 30;\n      }\n    }\n    if(f) puts(\"-1\"); else printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nstatic const int MAX = 500;\nstatic const int L = 30;\n\nbool overlap(int a, int b){\n  if ( a > b ) swap(a, b);\n  return a + 30 > b;\n}\n\nint getProgram(vector<int> v){\n  sort(v.begin(), v.end());\n  int dp[MAX];\n  int maxv = v.size()>0?1:0;\n  for ( int i = 0; i < v.size(); i++ ) dp[i] = 1;\n  for ( int i = 1; i < v.size(); i++ ){\n    for ( int j = i-1; j >= 0; j-- ){\n      if ( !overlap(v[j], v[i]) ){\n\tdp[i] = dp[j]+1;\n\tmaxv = max(maxv, dp[i]);\n\tbreak;\n      }\n    }\n  }\n  return maxv;\n}\n\nint solve(int N){\n  int in[MAX], w, s, P;\n  map<string, int> M;\n  string name;\n  vector<int> F, T;\n  rep(i, N){\n    cin >> name >> w >> s;\n    M[name] = i;\n    in[i] = w*1440 + (s/100)*60 + s%100;\n  }\n  cin >> P;\n  rep(i, P){\n    cin >> name;\n    F.push_back(in[M[name]]);\n  }\n\n  int ans = getProgram(F);\n  if ( ans != P ) return -1;\n\n  rep(i, N){\n    bool f = true;\n    for ( int j = 0; j < F.size(); j++ ){\n      if ( overlap(F[j], in[i]) ) { f = false; break; }\n    }\n    if ( f ) T.push_back(in[i]);\n  }\n  return ans + getProgram(T);\n}\n\nmain(){\n  int N;\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    if(start >= 2400){\n      weekday++;\n      start -= 2400;\n      if(weekday == 7){\n        weekday = 0;\n      }\n    }\n    favorite = false;\n  }\n\n  int minutes(){\n    int tmp = start / 100;\n    return (tmp * 60) + start - (tmp * 100);\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  if(a1.weekday == a2.weekday){\n    return a1.start < a2.start;\n  }\n  return a1.weekday < a2.weekday;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[first].weekday == table[last].weekday){\n\n            if(table[last].minutes() - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          else{\n            if((table[last].minutes()+2400) - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].weekday == table[n-2].weekday){\n        if(table[n-1].minutes() - table[n-2].minutes() >= 30){\n          count++;\n        }\n      }\n      else{\n        if((table[n-2].minutes()+2400) - table[n-1].minutes() >= 30){\n          count++;\n        }\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int f = 0;\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*100000)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(PRO[k].S > m[FAV]-30 && PRO[k].S < m[FAV]+30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tbreak;\n      }\n      map<string, int>::iterator it = m.begin();\n      while(it != m.end()){\n\tif(FAV != it->first && abs(m[FAV]-it->second) < 30) f = 1;\n\tit++;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int tail = 0, res = 0; \n    rep(i, PRO.size()){\n      if(tail <= PRO[i].S){\n\tres++;\n\ttail = PRO[i].S + 30;\n      }\n    }\n    if(f) puts(\"-1\"); else printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  string s;\n  int t;\n  bool is;\n  DATA(): s(){ t=0; is=false; }\n};\n\nvoid input1(DATA* d){\n  int w, t, m, s;\n  cin >> d->s >> w >> t;\n  m = t/100;\n  s = t - 100*m;\n  d->t = 24*60*w + 60*m + s;\n}\n\nvoid input2(vector<DATA>* d){\n  string s;\n  cin >> s;\n  for(vector<DATA>::iterator i=d->begin(); i!=d->end(); ++i){\n    if(i->s == s){\n      i->is = true;\n      return;\n    }\n  }\n}\n\nbool comp_time(const DATA& a, const DATA& b){\n  if(a.t != b.t) return a.t < b.t;\n  return a.is;\n}\n\nint solve(vector<DATA>& data){\n  sort(data.begin(), data.end(), comp_time);\n  int n=0, t=0;\n  bool f=false;\n  for(int i=0; i<data.size(); ++i){\n    if(t <= data[i].t){\n      ++n;\n      t = data[i].t + 30;\n      f = data[i].is;\n    }else{\n      if(f && data[i].is) return -1;\n      if(data[i].is){\n\tt = data[i].t + 30;\n\tf = true;\n      }\n    }\n  }\n  return n;\n}\n\nint main(){\n  int n, m;\n  string s;\n  while(1){\n    cin >> n;\n    if(!n) break;\n    vector<DATA> data(n, DATA());\n    for(int i=0; i<n; ++i) input1(&data[i]);\n    cin >> m;\n    for(int i=0; i<m; ++i) input2(&data);\n    cout << solve(data) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            if(start == m.end())\n              start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          ite++;\n          if(ite == m.end())\n            flag = true;\n          ite--;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct anim\n{\n  string name;\n  int begin;\n};\n\nbool operator==( anim const& lhs, anim const& rhs )\n{\n  return lhs.name == rhs.name;\n}\n\nbool operator>( anim const& lhs, anim const& rhs )\n{\n  return lhs.begin > rhs.begin;\n}\n\nint calc_begin( int week, int begin )\n{\n  int subs = 0;\n  while( begin >= 2400 ) {\n    begin -= 2400;\n    ++subs;\n  }\n  int const minute = begin % 100, hour = begin / 100;\n  week += subs;\n  if ( week >= 7 )\n    week -= 7;\n\n  return week * 24 * 60 + hour * 60 + minute; // test\n}\n\nbool is_over( vector<anim> const& an, anim const& a )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( a == *it )\n      continue;\n\n    if (\n\t( a.begin >= it->begin && a.begin < it->begin + 30 )\n\t|| ( a.begin + 30 > it->begin && a.begin + 30 < it->begin + 30 )\n\t)\n      return true;\n  }\n\n  return false;\n}\n\nbool is_over( vector<anim> const& an )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( is_over( an, *it ) )\n      return true;\n  }\n\n  return false;\n}\n\n\n\n\nint main()\n{\n  int n;\n  while( cin >> n ) {\n    if ( n == 0 )\n      break;\n\n    map<string, anim> mx;\n    priority_queue<anim, vector<anim>, greater<anim> > pq;\n\n    for( int ii=0; ii<n; ++ii ) {\n      string n;\n      int week, b;\n      cin >> n >> week >> b;\n      anim const a = { n, calc_begin( week, b ) }; // test\n\n      mx.insert( pair<string, anim>( n, a ) ); // test\n      pq.push( a );\n    }\n\n    vector<anim> als;\n    int num = 0;\n\n    int f;\n    cin >> f;\n    for( int ii=0; ii<f; ++ii ) {\n      string fav;\n      cin >> fav;\n\n      als.push_back( mx[fav] );\n    }\n    if ( is_over( als ) ) {\n      num = -1;\n      goto fin;\n    }\n    \n    while( !pq.empty() ) {\n      anim const& a = pq.top();\n      if ( !is_over( als, a ) ) {\n\tals.push_back( a );\n\t++num;\n\t//cout << \"-> \";\n      }\n\n      //cout << a.name << \" \" << a.begin << endl;\n      pq.pop();\n    }\n\n  fin:\n    cout << num << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n\ntypedef pair<int, string> pis;\n\nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty())\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            end--;\n            if(start == end){\n              m.erase(m.begin());\n              f.erase(f.begin());\n              ans++;\n              break;\n            }else{\n              end++;\n              m.erase(start, end);\n              f.erase(f.begin());\n              ans++;\n            }\n          }\n        }\n        while(m.size() > 1){\n          ite = ++m.begin();\n          while(ite != m.end()){\n            if(m.begin()->first + 30 > ite->first){\n              m.erase(ite);\n              ite = ++m.begin();;\n            }else{\n              break;\n            }\n          }\n          m.erase(m.begin());\n          ans++;\n        }\n        if(!f.empty())\n          cout << \"-1\" << endl;\n        else\n          cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b,i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n\n    int ai=0,bi=0,now=0,ans=0;\n    int as=A.size(),bs=B.size();\n    while(ai<as||bi<bs){\n      int ag=(ai<as?A[ai].first:1e9);\n      int bg=(bi<bs?B[bi].first:1e9);\n      if(now<=ag&&ag+30<=bg){\n\tnow=ag+30;\n\tans++;\n\tai++;\n      }else if(ag<now){\n\tai++;\n      }else{\n\tnow=bg+30;\n\tbi++;\n\tans++;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\nconst int MAXN = 11111;\nint dp[555][MAXN];\nstring name;\nmap<string, int> mp;\n//dp[i][j] = max(dp[i - 1][j - 30]);\nstruct bit {\n\tint n, c[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tmemset(c, 0, n * sizeof(int));\n\t}\n\tvoid update(int x, int y) {\n\t\tx+=2;\n\t\twhile (x < n) {\n\t\t\tc[x] = max(c[x], y);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint get(int x) {\n\t\tx+=2;\n\t\tint ret = 0;\n\t\twhile (x) {\n\t\t\tret = max(ret, c[x]);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}b;\n\nstruct data {\n\tint id, time;\n\tbool over;\n\tfriend bool operator <(const data& a, const data& b) {\n\t\treturn a.time < b.time;\n\t}\n}d[555];\nint id[555], idx = 0;\n\nbool notok(int a, int b) {\n\tif (d[a].time > d[b].time) {\n\t\tswap(a, b);\n\t}\n\tif (d[a].time + 30 > d[b].time) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint used[111112];\n\nint main() {\n\tint n, m;\n\tstring name;\n\twhile (scanf(\"%d\", &n) != EOF && n) {\n\t\tmp.clear();\n\t\tint week, hour;\n\t\tint maxv = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> name >> week >> hour;\n\t\t\td[i].id = i - 1;\n\t\t\td[i].over = false;\n\t\t\td[i].time = week * 24 * 60 + ((hour / 100)) * 60 + ((hour % 100));\n\t\t\tmaxv = max(maxv, d[i].time);\n\t\t\t//cout << d[i].time << endl;\n\t\t\tmp[name] = i;\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tgetchar();\n\t\tidx = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tgetline(cin, name);\n\t\t\td[mp[name]].over = true;\n\t\t\tid[idx++] = mp[name];\n\t\t}\n\t\tmemset(used, 0, sizeof(used));\n\t\tbool die = false;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < idx; i++) {\n\t\t\tfor (int j = i + 1; j < idx; j++) {\n\t\t\t\tif (notok(id[i], id[j])) {\n\t\t\t\t\tdie = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << id[i] << endl;\n\t\t\tfor (int j = d[id[i]].time; j < d[id[i]].time + 30; j++) {\n\t\t\t\tused[j] = true;\n\t\t\t}\n\t\t\tans++;\n\t\t\tif (die) break;\n\t\t}\n\t\tif (die) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(d + 1, d + n + 1);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\tif (used[j]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\t//cout << i << endl;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      int n = f.size();\n      for(int i = 0; i < n; i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            //if(start == m.end())\n            //start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = -1;\n            break;\n          }\n          ite++;\n          if(ite == m.end())\n            flag = true;\n          ite--;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\n#define DIFF(X,Y) (abs((X)-(Y)))\n\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size()-1;i++) {\n\t\t\tfor(int j=i+1;j<fav.size();j++) {\n\t\t\t\tif(DIFF(fav[i].first,fav[j].first)<30) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(DIFF(anime[i].first,anime[j].first)>=30) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&DIFF(fav[i].first,p.first)<30) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nstatic const int MAX = 500;\nstatic const int L = 30;\n\nbool overlap(int a, int b){\n  if ( a > b ) swap(a, b);\n  return a + 30 > b;\n}\n\nint getProgram(vector<int> v){\n  sort(v.begin(), v.end());\n  int dp[MAX];\n  int maxv = v.size()>0?1:0;\n  for ( int i = 0; i < v.size(); i++ ) dp[i] = 1;\n  for ( int i = 1; i < v.size(); i++ ){\n    for ( int j = i-1; j >= 0; j-- ){\n      if ( !overlap(v[j], v[i]) ){\n\tdp[i] = dp[j]+1;\n\tmaxv = max(maxv, dp[i]);\n\tbreak;\n      }\n    }\n  }\n  return maxv;\n}\n\nint solve(int N){\n  int in[MAX], w, s, P;\n  map<string, int> M;\n  string name;\n  vector<int> F, T;\n  rep(i, N){\n    cin >> name >> w >> s;\n    M[name] = i;\n    in[i] = w*1440 + (s/100)*60 + s%100;\n  }\n  cin >> P;\n  rep(i, P){\n    cin >> name;\n    F.push_back(in[M[name]]);\n  }\n\n  int ans = getProgram(F);\n  if ( ans == 0 ) return -1;\n\n  rep(i, N){\n    bool f = true;\n    for ( int j = 0; j < F.size(); j++ ){\n      if ( overlap(F[j], in[i]) ) { f = false; break; }\n    }\n    if ( f ) T.push_back(in[i]);\n  }\n  return ans + getProgram(T);\n}\n\nmain(){\n  int N;\n  while(1){\n    cin >> N;\n    if ( N == 0 ) break;\n    cout << solve(N) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nstruct P{\n\tstring s;\n\tint day,t;\n}pre[509];\n\nbool cmp(P a,P b){\n\treturn a.t<b.t;\n}\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\",&n) == 1){\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>pre[i].s>>pre[i].day>>pre[i].t;\n\t\t\tpre[i].t=pre[i].day*24*60+pre[i].t/100*60+pre[i].t%100;\n\t\t\tif(pre[i].t>=7*24*60){\n\t\t\t\tpre[i].t-=7*24*60;\n\t\t\t}\n\t\t}\n\t\tsort(pre,pre+n,cmp);\n\t\tint m,ans=0;\n\t\tint mus[509];\n\t\tmemset(mus,0,sizeof(mus));\n\t\tstring ss;\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--){\n\t\t\tcin>>ss;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(pre[i].s == ss){\n\t\t\t\t\tmus[i]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag=true;\n\t\tint l=-30;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(mus[i]){\n\t\t\t\tif(pre[i].t-l>29)\n\t\t\t\t\tl=pre[i].t;\n\t\t\t\telse{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag==false){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint p=0,MM=0;\n\t\tfor(int j=0;j<=30;j++){\n\t\t\tp=0;\n\t\t\tint ret=j;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mus[i]){\n\t\t\t\t\tif(pre[i].t>=ret){\n\t\t\t\t\t\tret=pre[i].t+30;\n\t\t\t\t\t\tif(ret>=j+7*24*60){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tret=pre[i].t+30;\n\t\t\t\t\t\tif(ret>=j+7*24*60){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(pre[i].t>=ret){\n\t\t\t\t\t\tret=pre[i].t+30;\n\t\t\t\t\t\tif(ret>=j+7*24*60){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(p>MM)\n\t\t\t\tMM=p;\n\t\t}\n\t\tprintf(\"%d\\n\",MM);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n//            if(time>=2400){\n//                day=(day+1)%7;\n//                time-=2400;\n//            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        set<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.insert(s);\n        }\n        int p=-100000;\n        bool m=false;\n        int c=0;\n        for(int i=0;i<n;i++){\n            if(p+30>vec[i].first){\n                if(fav.count(vec[i].second)){\n                    if(m){\n                        c=-1;\n                        break;\n                    }else{\n                        m=true;\n                        p=vec[i].first;\n                    }\n                }\n            }else{\n                c++;\n                p=vec[i].first;\n                m=fav.count(vec[i].second);\n            }\n        }\n        cout<<c<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\n\nstruct node {\n    char name[50];\n    int begin_time,end_time;\n    bool flag;\n}f[550];\n\nint dp[4000 * 7];\nbool cmp(node a, node b) {\n    return a.end_time < b.end_time;\n}\n\nint Max(int a, int b) {\n    return a > b ? a : b;\n}\n\n\nvector<int>::iterator v_iter;\nmap<int , int >::iterator iter;\nint main(){\n    int n;\n    char str[50];\n    int week, t;\n    while(~scanf(\"%d\", &n) && n) {\n\t\tint num = 1;\n\t\tvector<int>coll[550];\n        int ans = 0;\n        map<int, int>flag;\n        map<string, int>M;\n        for(int i = 0; i < n; ++ i) {\n            memset(dp, 0, sizeof(dp));\n            scanf(\"%s %d %d\", f[i].name, &week, &t);\n            t += week * 2400 ;\n            f[i].begin_time = t;\n            t = f[i].begin_time % 100;\n            t += 30;\n            if(t > 60){\n                t = t % 60 + 100;\n            }\n            f[i].end_time = t + f[i].begin_time / 100 * 100;\n            f[i].flag = 0;\n        }\n\t\t\n        sort(f,f+n,cmp);\n\t\t\n        int m;\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tM[f[i].name] = i;\n\t\t}\n\t\t/**\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tprintf(\"%s %d %d\\n\", f[i].name, f[i].begin_time, f[i].end_time);\n\t\t}\n\t\t**/\n        scanf(\"%d\", &m);\n        for(int i = 0; i < m; ++ i) {\n            scanf(\"%s\", str);\n            int index = M[str];\n            f[index].flag = 1;\n        }\n\t\tbool note = 0;\n\t\tfor(int i = 0; i < n; ++ i) {\n\t\t\tif(f[i].flag == 0)continue;\n\t\t\tfor(int j = i + 1; j < n; ++ j) {\n\t\t\t\tif(f[j].flag == 0)continue;\n\t\t\t\tif(f[i].end_time > f[j].begin_time && f[i].end_time < f[j].end_time){\n\t\t\t\t\tnote = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(f[j].end_time > f[i].begin_time && f[j].end_time < f[i].end_time){\n\t\t\t\t\tnote = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(note == 1)break;\n\t\t}\n\t\tif(note) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n        for(int i = 0; i < n; ++ i) {\n\t\t\tint index = flag[f[i].end_time];\n\t\t\tif( index == 0) {\n\t\t\t\tflag[f[i].end_time] = num;\n\t\t\t\tcoll[num ++].push_back(i);\n\t\t\t} else {\n\t\t\t\tcoll[index].push_back(i);\n\t\t\t}\n        }\n        \n        for(int i = 1; i < 7 * 4000; ++ i) {\n            iter = flag.find(i);\n            if(iter != flag.end()) {\n\t\t\t\tint index = iter -> second;\n\t\t\t\tint size = coll[index].size();\n\t\t\t\tint stt,edt;\n\t\t\t\tstt = f[coll[index][0]].begin_time;\n\t\t\t\tedt = f[coll[index][0]].end_time;\n\t\t\t\tfor(int j = 0; j < size; ++ j) {\n\t\t\t\t\tif(f[coll[index][j]].flag == 1) {\t\n\t\t\t\t\t\tfor(int k = stt + 1; k < edt; ++ k) {\n\t\t\t\t\t\t\tdp[k] = -0x7f7f7f7f;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n                dp[i] = Max(Max(dp[i], dp[stt] + 1), dp[i-1]);\n\t\t\t\t//printf(\"%d %d,\", i, dp[i]);\n            } else dp[i] = dp[i - 1];\n            ans = Max(ans, dp[i]);\n        }\n        printf(\"%d\\n\", ans);\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n\ntypedef pair<int, string> pis;\n\nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      \n  //printf(\"--------------??????--------------\\n\");\n/* multimap<int, string>::iterator ite2;\n   for(ite2 = m.begin(); ite2 != m.end(); ++ite2)\n    cout << ite2->first << \" \" << ite2->second << endl;\n*/\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty())\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            //cout << \"x = \" << x << endl;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            end--;\n            if(start == end){\n              m.erase(m.begin());\n              f.erase(f.begin());\n              ans++;\n              break;\n            }else{\n              end++;\n              m.erase(start, end);\n              f.erase(f.begin());\n              ans++;\n            }\n            //cout << \"start = \" << start->first << \" \" << start->second << \"  end = \" << end->first << \" \" << end->second << endl;\n          }\n          //printf(\"--------------------------\\n\");\n/*    multimap<int, string>::iterator ite2;\n      for(ite2 = m.begin(); ite2 != m.end(); ++ite2)\n      cout << ite2->first << \" \" << ite2->second << endl;\n      }\n*/\n        }\n        while(m.size() > 1){\n          ite = ++m.begin();\n          while(ite != m.end()){\n            if(m.begin()->first + 30 > ite->first){\n              m.erase(ite);\n              ite = ++m.begin();;\n            }else{\n              break;\n            }\n          }\n          m.erase(m.begin());\n          ans++;\n        }\n        if(!f.empty())\n          cout << \"-1\" << endl;\n        else\n          cout << ans + m.size() << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DAY_MIN (30*60)\nusing namespace std;\nstruct Pox\n{\n  int weekday,start;\n  Pox(int weekday=-1,int start=-1):weekday(weekday),start(start){}\n};\nint N,P;\nbool used[7][DAY_MIN+1];\n\nint toMin(int v)\n{\n  int tp = (int)floor(v/100.0);\n  int bm = v%100;\n  return tp*60 + bm;\n}\n\nbool cmp(const Pox &a,const Pox &b)\n{\n  if(a.weekday != b.weekday)return a.weekday < b.weekday;\n  return a.start < b.start;\n}\n\nint main()\n{\n\n  while(cin >> N , N)\n    {\n      map<string,Pox> index;\n      rep(j,7)rep(i,DAY_MIN+1)used[j][i] = false;\n      bool AUTO = false;\n      vector<Pox> info(N);\n      vector<string> name(N);\n      map<string,bool> drowsiness;\n\n      rep(i,N)\n\t{\n\t  cin >> name[i] >> info[i].weekday >> info[i].start;\n\t  info[i].start = toMin(info[i].start);\n\t  index[name[i]] = info[i];\n\t}\n\n      /*\n      rep(i,N)\n      cout << name[i] << \" \" << info[i].weekday << \" \" << info[i].start << endl;\n      */\n      \n      cin >> P;\n      int cnt = P;\n      vector<string> name2(P);\n      rep(i,P)\n\t{\n\t  cin >> name2[i];\n\t  Pox pox = index[name2[i]];\n\t  drowsiness[name2[i]] = true;\n\t  int week = pox.weekday;\n\t  if(!AUTO)\n\t    {\n\t      //cout << \"fill in : \" << pox.start << \" \" << pox.start+30 << \" from \" << week << \" \";\n\t      REP(j,pox.start,pox.start+30)\n\t\t{\n\t\t  if(used[week][j])\n\t\t    {\n\t\t      AUTO = true;\n\t\t      break;\n\t\t    }\n\t\t  used[week][j] = true;\n\t\t}\n\t      //cout << \" to \" << week << endl;\n\t    }\n\t}\n\n      vector<Pox> FIFA;\n      rep(i,name.size())\n\t{\n\t  //cout << name[i] << \" = \";\n\t  if(!drowsiness[name[i]])\n\t    {\n\t      //cout << \"IN\" << endl;\n\t      FIFA.push_back(index[name[i]]);\n\t    }\t\n\t}\n\n      //cout << \"------\" << endl;\n\n      sort(FIFA.begin(),FIFA.end(),cmp);\n\n      rep(i,FIFA.size())\n\t{\n\t  int week = FIFA[i].weekday;\n\t  bool check = true;\n\t  //cout << \"fill in | \" << FIFA[i].start << \" \" << FIFA[i].start+30 << \" : \" << week;\n\t  REP(j,FIFA[i].start,FIFA[i].start+30)\n\t    {\n\t      if(used[week][j])\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t      used[week][j] = true;\n\t    }\n\t  if(check)cnt++;\n\t  //cout << \" to \" << week << \" cnt = \" << cnt << endl;\n\t}\n\n      if(AUTO)cout << -1 << endl;\n      else    cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nint N, P;\nmap<string,int> all[7];\nmap<string,int> weeks;\nbool flag[7][3100];\n\nint main() {\n  while (cin>>N, N) {\n    rep(i,7) all[i].clear();\n    weeks.clear();\n    {\n      string name;\n      int week, start;\n      rep(i,N) {\n        cin>>name>>week>>start;\n        all[week].insert(make_pair(name,start/100*60+start%100));\n        weeks.insert(make_pair(name,week));\n      }\n      cin>>P;\n      memset(flag, false, sizeof flag);\n      //vector<string> fav;\n      set<string> fav;\n      bool ok  = true;\n      rep(i,P) {\n        cin>>name;\n        //fav.push_back(name);\n        fav.insert(name);\n        int week = weeks[name];\n        int offset = all[week][name];\n        if (flag[week][offset] || flag[week][offset+29]) { ok = false; }\n        if (!ok) { continue; }\n        for (int j = offset; j < offset+30; ++j) flag[week][j] = true;\n      }\n      if (!ok) { puts(\"-1\"); continue; }\n\n      //sort(fav.begin(), fav.end());\n      rep(i,7) {\n        set<int> s;\n        foreach(all[i],itr) {\n          // if(!binary_search(fav.begin(), fav.end(), itr->first)) {\n          //   if (s.count(itr->second)) s.insert(itr->second);\n          // }\n          if (!fav.count(itr->first)) {\n            s.insert(itr->second);\n          }\n        }\n        //cout<<\"[\"<<s.size()<<\"]\"<<endl;\n        foreach(s,itr) {\n          int v = *itr;\n          //cout<<\"(\"<<v<<\")\"<<endl;\n          if (flag[i][v] || flag[i][v+29]) continue;\n          for (int j = v; j < v+30; ++j) flag[i][j] = true;\n        }\n      }\n\n      int ret = 0;\n      rep(i,7) {\n        for (int j = 0; j < 3000; ++j) {\n          if (!flag[i][j]) continue;\n          //cout << i << \",\" <<j << endl;\n          ++ret;\n          j += 29;\n        }\n      }\n      cout << ret << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<string>\n#include<iostream>\nusing namespace std;\nstruct P{\n    int st;\n    int i;\n    bool operator<(const P &a)const{\n        return st<a.st;\n    }\n}p[850];\nbool mark[850];\nint must[850];\nint n,m,tim,we,k=1;\nstring s;\nmap<string,int>mymap;\nint main()\n{\n    while(scanf(\"%d\",&n)&&n){\n        mymap.clear();\n        for(int i=0;i<n;++i)\n        {\n            cin>>s>>we>>tim;\n            mymap[s]=i;\n            p[i].i=i;\n            p[i].st=we*2400+tim%100+(tim/100)*60;\n        }\n        cin>>m;\n        memset(mark,0,sizeof(mark));\n        for(int i=0;i<m;++i){\n            cin>>s;\n            mark[mymap[s]]=1;\n        }\n        sort(p,p+n);\n        int ans=0,k=1,end;\n        bool flag=0;\n        must[0]=-1;\n        for(int i=0;i<n;++i)\n            if(mark[p[i].i]) must[k++]=i;\n        for(int i=1;i<k;++i){\n            if(i>1&&p[must[i-1]].st+30>p[must[i]].st)\n            {\n                flag=1;\n                break;\n            }\n            end=p[must[i]].st;\n            for(int j=must[i]-1;j>=must[i-1]&&j>=0;--j)\n                if(p[j].st+30<=end){\n                    ans++;\n                    end=p[j].st;\n                }\n        }\n        ans++;\n        end=p[must[k-1]].st;\n        for(int i=must[k-1]+1;i<n;++i)\n            if(end+30<=p[i].st){\n                ans++;\n                end=p[i].st;\n            }\n        if(flag) cout<<\"-1\"<<endl;\n        else cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]%10080<(ma[fav[i-1]]+30)%10080){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n        }\n        if(nex){\n            continue;\n        }\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&(ma[res[resi]]+30)%10080<=start%10080){\n                resi++;\n            }\n            if(resi==res.size()||(start+30)%10080<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nvector<string> names;\nvector<int> starts;\nint P;\nvector<string> favs;\nmap<string, int> to_id;\nbool cross_impl(int s1, int s2) {\n    if (s1 <= s2 && s2 < s1 + 30) return true;\n    return false;\n}\nbool cross(int s1, int s2) { return cross_impl(s1, s2) || cross_impl(s2, s1); }\nvoid solve() {\n    rep(i, P) rep(j, P) if (i != j) {\n        int a = to_id[favs[i]];\n        int b = to_id[favs[j]];\n        if (cross(starts[a], starts[b])) {\n            // cout << \"muri: \" << favs[i] << \", \" << favs[j] << endl;\n            // cout << a << \", \" << b << endl;\n            // cout << starts[a] << \", \" << starts[b] << endl;\n            cout << \"-1\" << endl;\n            return;\n        }\n    }\n    vector<int> used;\n    rep(i, P) {\n        int a = to_id[favs[i]];\n        used.push_back(starts[a]);\n    }\n    rep(_, N) {\n        int mini = 1e8;\n        for (auto s : starts) {\n            bool ok = true;\n            for (auto x : used) ok &= !cross(x, s);\n            if (ok && mini > s) mini = s;\n        }\n        if (mini != 1e8) used.push_back(mini);\n    }\n    cout << used.size() << endl;\n}\nint main() {\n    while (cin >> N, N) {\n        rep(i, N) {\n            string n;\n            int w, s;\n            cin >> n >> w >> s;\n            s = s / 100 * 60 + s % 100;\n            s += w * 86400;\n            names.push_back(n);\n            starts.push_back(s);\n            // cout << i << \": \" << s << endl;\n            int t = to_id.size();\n            to_id[n] = t;\n        }\n        cin >> P;\n        rep(i, P) {\n            string n;\n            cin >> n;\n            favs.push_back(n);\n        }\n        solve();\n        favs.clear();\n        starts.clear();\n        to_id.clear();\n        names.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\n#define DIFF(X,Y) (abs((X)-(Y)))\n\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100+30)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size()-1;i++) {\n\t\t\tfor(int j=i+1;j<fav.size();j++) {\n\t\t\t\tif(DIFF(fav[i].first,fav[j].first)<30) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(DIFF(anime[i].first,anime[j].first)>=30) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&DIFF(fav[i].first,p.first)<30) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Interval{\n\tint a,b;\n\tInterval(){}\n\tInterval(int A,int B):a(A),b(B){}\n\tbool operator<(const Interval &I)const{ return b<I.b; }\n};\n\nbool intersect(const Interval &I,const Interval &J){\n\treturn I.a<J.b && J.a<I.b;\n}\n\nint solve(int n,Interval *I){\n\tsort(I,I+n);\n\n\tint ans=0,r=-1;\n\trep(i,n) if(r<=I[i].a) r=I[i].b, ans++;\n\n\treturn ans;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tmap<string,int> f;\n\t\tInterval I[500];\n\t\trep(i,n){\n\t\t\tchar name[33];\n\t\t\tint week,start; scanf(\"%s%d%d\",name,&week,&start);\n\t\t\tf[name]=i;\n\n\t\t\tint h=start/100,m=start%100;\n\t\t\tstart=week*24*60+h*60+m;\n\t\t\tI[i]=Interval(start,start+30);\n\t\t}\n\n\t\tint nf; scanf(\"%d\",&nf);\n\t\tInterval fav[500];\n\t\trep(i,nf){\n\t\t\tchar name[33]; scanf(\"%s\",name);\n\t\t\tfav[i]=I[f[name]];\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(j,nf) rep(i,j) if(intersect(fav[i],fav[j])) ok=false;\n\t\tif(!ok){ puts(\"-1\"); continue; }\n\n\t\tint n2=0;\n\t\tInterval J[500];\n\t\trep(i,n){\n\t\t\tbool ok=true;\n\t\t\trep(j,nf) if(intersect(I[i],fav[j])) ok=false;\n\t\t\tif(ok) J[n2++]=I[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\",nf+solve(n2,J));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<string> ps(n);\n\t\tvector<int> ts(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>ps[i];\n\t\t\tint w,s; cin>>w>>s;\n\t\t\tts[i]=(w*24*60+s/100*60+s%60)%(7*24*60);\n\t\t}\n\t\tint m; cin>>m;\n\t\tvector<int> fs(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tfs[find(begin(ps),end(ps),s)-begin(ps)]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tts.push_back(ts[i]+7*24*60);\n\t\tvector<int> is(n*2);\n\t\tiota(begin(is),end(is),0);\n\t\tsort(begin(is),end(is),[&](int i,int j){return ts[i]<ts[j];});\n\t\t\n\t\tint res=-1;\n\t\tfor(int l=0,r=7*24*60;l<30;l++,r++){\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is) if(fs[i]){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tif(dp[r]!=m) continue;\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tres=max(res,dp[r]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include<algorithm>\n#include<cstdio>\n#define inf 0x7fffffff\nusing namespace std;\n#define N 1005\nmap<string, int>fy;\nint n, m;\n\nstruct node\n{\n    int s, t;\n} p[N], q[N];\n\nvoid change(int i)\n{\n    if (p[i].t >= 2400)\n    {\n        p[i].s += 1;\n        p[i].t -= 2400;\n    }\n    p[i].s = p[i].s * 24 * 60 + (p[i].t / 100)*60 + p[i].t % 100;\n    p[i].t = p[i].s + 30;\n}\n\nbool cmp(const node a, const node b)\n{\n    if (a.s != b.s)\n        return a.s < b.s;\n    else\n        return a.t < b.t;\n}\n\nint main()\n{\n    string fuck;\n    while (scanf(\"%d\", &n))\n    {\n        if (n == 0)\n            break;\n        fy.clear();\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> fuck >> p[i].s >> p[i].t;\n            if (!fy[fuck])\n                fy[fuck] = i;\n\n            change(i);\n        }\n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++)\n        {\n            cin >> fuck;\n            q[i].s = p[fy[fuck]].s;\n            q[i].t = p[fy[fuck]].t;\n        }\n        sort(q, q + m, cmp);\n        bool flag=1;\n        for (int i = 1; i < m; i++)\n        {\n            if (q[i].s < q[i - 1].t)\n            {\n                flag=0;\n                break;\n            }\n        }\n        if(!flag)\n        {\n        printf(\"-1\\n\");\n        continue;\n        }\n        sort(&p[1], &p[n + 1], cmp);\n        int ans = m;\n        if (m == 0)\n        {\n            int cur = -inf;\n            for (int gg = 1; gg <= n; gg++)\n            {\n                if (p[gg].s >= cur)\n                {\n                    ans++;\n                    cur = p[gg].t;\n                }\n                else if (p[gg].t < cur)\n                {\n                    cur = p[gg].t;\n                }\n            }\n            printf(\"%d\\n\", ans);\n            continue;\n        }\n        int cnt = 0;\n        q[m].s = inf;\n        for (int i = 1; i <= n;)\n        {\n            int j = i;\n            for (; j <= n && p[j].t <= q[cnt].s;)\n                j++;\n            int cur = -inf;\n            for (int gg = i; gg <= j - 1; gg++)\n            {\n                if (p[gg].s >= cur)\n                {\n                    ans++;\n                    cur = p[gg].t;\n                }\n                else if (p[gg].t < cur)\n                {\n                    cur = p[gg].t;\n                }\n            }\n            for (; j <= n && p[j].s < q[cnt].t;)\n                j++;\n            cnt++;\n            i = j;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Interval{\n\tint a,b;\n\tInterval(){}\n\tInterval(int A,int B):a(A),b(B){}\n\tbool operator<(const Interval &I)const{ return b<I.b; }\n};\n\nbool intersect(const Interval &I,const Interval &J){\n\treturn I.a<J.b && J.a<I.b;\n}\n\nint solve(int n,Interval *I){\n\tsort(I,I+n);\n\n\tint ans=0,r=-1;\n\trep(i,n) if(r<=I[i].a) r=I[i].b, ans++;\n\n\treturn ans;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tmap<string,int> f;\n\t\tInterval I[500];\n\t\trep(i,n){\n\t\t\tchar name[33];\n\t\t\tint week,start; scanf(\"%s%d%d\",name,&week,&start);\n\t\t\tf[name]=i;\n\n\t\t\tint h=start/100,m=start%100;\n\t\t\tstart=week*24*60+h*60+m;\n\t\t\tI[i]=Interval(start,start+30);\n\t\t}\n\n\t\tint nf; scanf(\"%d\",&nf);\n\t\tInterval fav[500];\n\t\trep(i,nf){\n\t\t\tchar name[33]; scanf(\"%s\",name);\n\t\t\tfav[i]=I[f[name]];\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(j,nf) rep(i,j) if(intersect(fav[i],fav[j])) ok=false;\n\t\tif(!ok){ puts(\"-1\"); continue; }\n\n\t\tint n2=0;\n\t\tInterval J[500];\n\t\trep(i,n){\n\t\t\tbool ok=true;\n\t\t\trep(j,nf) if(intersect(I[i],fav[j])) ok=false;\n\t\t\tif(ok) J[n2++]=I[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\",nf+solve(n2,J));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <list>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\nusing namespace std;\nvector<string> to[20000];\nstruct A{int da,x;} dp[20000];\nvoid zy(A &a,int bx,int bda)\n{\n\tif(a.x<bx||(a.x==bx&&a.da<bda))\n\t\ta.da=bda,a.x=bx;\n}\nset<string>st;\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint m=15000;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tto[i].clear();\n\t\twhile(n--)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint d,h,m;\n\t\t\tcin>>d>>h;\n\t\t\tm=h%100;\n\t\t\th/=100;\n\t\t\tif(m>=60)h++,m-=60;\n\t\t\tif(h>=24)h-=24,d++;\n\t\t\tif(d==7)d=0;\n\t\t\tto[d*1440+h*60+m].push_back(s);\n\t\t}\n\t\tint P;\n\t\tcin>>P;\n\t\tst.clear();\n\t\twhile(P--)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tst.insert(s);\n\t\t}\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tzy(dp[i+1],dp[i].x,dp[i].da);\n\t\t\tfor(int q=0;q<to[i].size();q++)\n\t\t\t{\n\t\t\t\tif(st.find(to[i][q])!=st.end())\n\t\t\t\t\tzy(dp[i+30],dp[i].x+1,dp[i].da+1);\n\t\t\t\telse zy(dp[i+30],dp[i].x,dp[i].da+1);\n\t\t\t}\n\t\t}\n\t\t//cout<<dp[m].x<<\"       \";\n\t\tcout<<dp[m].da<<endl;\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n//        set<string>fav;\n//        for(int i=0;i<p;i++){\n//            cin>>s;\n//            fav.insert(s);\n//        }\n//        int p=-100000;\n//        bool m=false;\n//        int c=0;\n//        for(int i=0;i<n;i++){\n//            if(p+30>vec[i].first){\n//                if(fav.count(vec[i].second)){\n//                    if(m){\n//                        c=-1;\n//                        break;\n//                    }else{\n//                        m=true;\n//                        p=vec[i].first;\n//                    }\n//                }\n//            }else{\n//                c++;\n//                p=vec[i].first;\n//                m=fav.count(vec[i].second);\n//            }\n//        }\n//        cout<<c<<endl;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]<ma[fav[i-1]]+30){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n            sort(res.begin(),res.end(),sv);\n        }\n        if(nex){\n            continue;\n        }\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                resi++;\n            }\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      int n = f.size();\n      for(int i = 0; i < n; i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            //if(start == m.end())\n            //start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          ite++;\n          if(ite == m.end())\n            flag = true;\n          ite--;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int f = 0;\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*100000)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(abs(PRO[k].S-m[FAV]) < 30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tbreak;\n      }\n      map<string, int>::iterator it = m.begin();\n      while(it != m.end()){\n\tif(FAV != it->first && abs(m[FAV]-it->second) < 30) f = 1;\n\tit++;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int time = 0, res = 0; \n    //    puts(\"\");\n    rep(i, PRO.size()){\n      if(abs(PRO[i].S-time) < 30) continue;\n      //      printf(\"%d\\n\", time);\n      //      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      res++;\n      time = PRO[i].S;\n    }\n    if(f) puts(\"-1\"); else printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    if(start >= 2400){\n      weekday++;\n      start -= 2400;\n      /*if(weekday == 7){\n        weekday = 0;\n      }*/\n    }\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[last].minutes - table[first].minutes >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].minutes - table[n-2].minutes >= 30){\n          count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define TEMP_T template<typename T>\nTEMP_T void sort(T& v){ sort(v.begin(), v.end()); }\nTEMP_T void revs(T& v){ reverse(v.begin(), v.end()); }\nTEMP_T void uniq(T& v){ sort(v); v.erase(unique(v.begin(), v.end())); }\nTEMP_T T    cums(T& v){ T r(v.size()); partial_sum(v.begin(), v.end(), r); return r; }\nTEMP_T void show(T& v, char delim=' ', char end='\\n'){ for(int i=0; i<v.size()-1; i++) cout << v[i] << delim; cout << v[v.size()-1] << end; }\nTEMP_T T    acum(vector<T>& v, T b=0){ return accumulate(v.begin(), v.end(), b); }\nTEMP_T vector<T> inpt(int n){ vector<T> v(n); for (int i=0; i<n; i++) cin >> v[i]; return v; }\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\n\nstruct Solver {\n  Solver(){}\n  int solve(){\n  }\n};\n\nstruct Info {\n  int kind;\n  int times;\n  Info(int times, int kind) : times(times), kind(kind) {}\n  bool operator<(const Info& x) const {\n    return times == x.times ? kind < x.kind : times > x.times;\n  }\n};\n\nstatic inline int stoi(const string& s){\n  stringstream ss(s);\n  int x;\n  ss >> x;\n  return x;\n}\n\nstatic inline int ttoi(const string& s){\n  if (s.size() == 3){\n    return stoi(s.substr(0, 1)) * 60 + stoi(s.substr(1));\n  }\n  return stoi(s.substr(0, 2)) * 60 + stoi(s.substr(2));\n}\n\nint main()\n{\n  int n;\n  while (n = in()){\n    priority_queue<Info> pQ;\n    map<string, int> chs;\n    for (int i = 0; i < n; i++){\n      string name, times;\n      int day;\n      cin >> name >> day >> times;\n      int ttime = 10000 * day + ttoi(times);\n      chs[name] = ttime;\n      pQ.push(Info(ttime, 0));\n    }\n    int p = in();\n    for (int i = 0; i < p; i++){\n      string name;\n      cin >> name;\n      int ttime = chs[name];\n      pQ.push(Info(ttime, 1));\n      pQ.push(Info(ttime - 30, -1));\n    }\n    int count = 0;\n    int state = 0;\n    while (!pQ.empty()){\n      Info info = pQ.top();\n      pQ.pop();\n      if (info.kind == 0){\n        if (state) continue;\n        state++;\n        pQ.push(Info(info.times + 30, 3));\n        count++;\n      }\n      else if (info.kind == 1){\n        if (state){\n          count = -1;\n          break;\n        }\n        state++;\n        pQ.push(Info(info.times + 30, 3));\n        count++;\n      }\n      else if (info.kind == -1){\n        state++;\n        pQ.push(Info(info.times + 30, 3));\n      }\n      else if (info.kind == 3){\n        state--;\n      }\n    }\n    printf(\"%d\\n\", count);\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\tifstream cin(\"input.txt\");\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100+30)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size()-1;i++) {\n\t\t\tfor(int j=i+1;j<fav.size();j++) {\n\t\t\t\tif(Diff(fav[i].first,fav[j].first)) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(!Diff(anime[i].first,anime[j].first)) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1);\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]<ma[fav[i-1]]+30){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n            sort(res.begin(),res.end(),sv);\n        }\n        if(nex){\n            continue;\n        }\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                resi++;\n            }\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#include <ctime>\n#include <cmath>\n#include <set>\n#include <map>\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define abs(x) ((x)>0?(x):(-(x)))\n#define FOR(i,a,b) for(int i = (a);i<=(b);i++)\n#define FORD(i,a,b) for(int i = (a);i>=(b);i--)\n#define REP(i,n) for(int i = 0;i<(n);i++)\n#define rst(x,k) memset(x,k,sizeof(x))\n#define lowbit(x) ((x)&(-(x)))\n#define h(x) (1<<(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define maxn 210000\n#define INF 2100001000\n#define mod 1000000007LL\n#define link fsafsdfas\nusing namespace std;\ntypedef long long LL;\nconst int maxtime = 10081;\nmap<string,int> bst;\nstring name[maxn];\nint c[10082];\nint ans[maxn];\nint fuck[maxn];\nint n,f;\nvoid update(int pos,int v){\n    while(pos <= maxtime){\n        c[pos] += v;\n        pos += lowbit(pos);\n    }\n}\nint req(int pos){\n    int res = 0;\n    while(pos > 0){\n        res += c[pos];\n        pos -= lowbit(pos);\n    }return res;\n}\nint cal(int a,int b){\n    return req(b) - req(a-1);\n}\nvoid INIT(void){\n    FOR(i,1,n) name[i].clear();\n    bst.clear();\n    rst(c,0);\n    FOR(i,1,n){\n        cin >> name[i];\n        int w,t; cin >> w >> t;\n        t -= 600;\n        ans[i] = w*1440+(t/100*60+t%100)+1;\n        bst[name[i]] = i;\n    }\n    bool ok = true;\n    cin >> f;\n    FOR(i,1,f){\n        string tt; cin >> tt;\n        int kk = bst[tt];\n        int a = ans[kk];\n        ans[kk] = -100;\n        if(cal(a,a+29) >0)ok = false;\n        update(a,1); update(a+29,1);\n    }\n    if(!ok){printf(\"-1\\n\");return;}\n    int cnt = 0;\n    int res = f;\n    FOR(i,1,n){\n        if(ans[i] >= 0)\n            fuck[cnt++] = ans[i];\n    }\n    sort(fuck,fuck+cnt);\n    REP(i,cnt){\n        if(cal(fuck[i],fuck[i]+29) == 0){\n            res++;\n            update(fuck[i],1); update(fuck[i]+29,1);\n        }\n    }\n    printf(\"%d\\n\",res);\n}\n\nint main(void){\n    while(cin >> n && n){\n        INIT();\n    }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      int n = f.size();\n      for(int i = 0; i < n; i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            if(start == m.end())\n              start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          multimap<int, string>::iterator ite2;\n          ite2 = ite;\n          ite2++;\n          if(ite2 == m.end())\n            flag = true;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[last].minutes - table[first].minutes >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              break;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].minutes - table[n-2].minutes >= 30){\n        count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]<ma[fav[i-1]]+30){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n        }\n        if(nex){\n            continue;\n        }\n        \n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            //cout<<res.size()<<\"  start: \"<<start<<\"   i: \"<<i<<\"     \";\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                //cout<<ma[res[resi]]<<\" \";\n                resi++;\n            }\n//            cout<<ma[res[resi]]<<\" !!! \";\n//            for(int ii=0;ii<res.size();ii++){\n//                cout<<ma[res[ii]]<<\" \";\n//            }\n//            cout<<\" !!! \";\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                //cout<<\"  -------  \"<<resi<<\" \"<<ma[res[resi]]<<\" \";if(resi>1)cout<<ma[res[resi-1]];\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n            //cout<<res.size()<<endl;\n        }\n        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(multimap<int,string> a,int b,int e){\n  int sm=0;\n  multimap<int,string>::iterator it=a.begin();\n  for(;it!=a.end()&&(*it).first+30<=e;it++){\n    if((*it).first>=b+30){\n      b=(*it).first;\n      sm++;\n    }\n  }\n  return sm;\n}\nint main(){\n  int i;\n  int m,n;\n  int sm;\n  multimap<int,string> a;\n  multiset<int> b;\n  multiset<int>::iterator it,jt;\n  while(cin>>n&&n){\n    a.clear();\n    for(i=0;i<n;i++){\n      int t,u;\n      string s;\n      cin>>s>>t>>u;\n      a.insert(make_pair(u%100+u/100*60+t*1440,s));\n    }\n    cin>>m;\n    b.clear();\n    for(i=0;i<m;i++){\n      string s;\n      cin>>s;\n      multimap<int,string>::iterator it=a.begin();\n      for(;(*it).second!=s;it++);\n      b.insert((*it).first);\n    }\n    if(m>1){\n      it=jt=b.begin();\n      jt++;\n      for(;jt!=b.end();){\n\tif(*jt-*it<30)\n\t  break;\n\tit++;\n\tjt++;\n      }\n      if(jt!=b.end()){\n\tcout<<-1<<endl;\n\tcontinue;\n      }\n    }\n    if(m){\n      sm=m;\n      it=jt=b.begin();\n      jt++;\n      sm+=f(a,0,*it);\n      for(;jt!=b.end();){\n\tsm+=f(a,*it,*jt);\n\tit++;\n\tjt++;\n      }\n      sm+=f(a,*it,20000);\n    }else{\n      sm=m;\n      sm+=f(a,0,20000);\n    }\n    cout<<sm<<endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: FreeIdea\n * Created Time:  2011/8/22 13:58:15\n * File Name: B.cpp\n */\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\nconst int maxint = -1u>>1;\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\nconst int maxn = 500 + 50;\n\nmap<string, int> idx;\nint n, p, cnt;\n\nstruct Pro {\n    int day, Time, idx;\n    bool operator < (const Pro & A) const{\n        if(day == A.day)    return Time < A.Time;\n        return day < A.day;\n    }\n    void solve() {\n        int h = Time / 100;\n        int m = Time % 100;\n        h += m / 60;\n        m %= 60;\n        day += h / 24;\n        h %= 24;\n        day %= 7;\n        Time = h * 100 + m;\n    }\n}pro[maxn];\n\nchar name[100];\nint day, Time;\nbool must[maxn], cannot[maxn];\n\nint hash(const string &str) {\n    if(idx.count(str))  return idx[str];\n    ++cnt;\n    return idx[str] = cnt;\n}\n\nbool con(const Pro &p1, const Pro &p2) {\n    Pro t1 = p1, t2 = p2;\n    if(t2 < t1) {\n        swap(t1, t2);\n    }\n    t1.Time += 30;\n    t1.solve();\n    return t2 < t1;\n}\n\nint calc(int l, int r) {\n    if(l > r)   return 0;\n    Pro tmp;\n    tmp.day = -100;\n    tmp.Time = -100;\n    int res = 0;\n    for(int i = l; i <= r; i++) {\n        if(cannot[i])   continue;\n        if(pro[i] < tmp) continue;\n        res++;\n        tmp = pro[i];\n        tmp.Time += 30;\n        tmp.solve();\n    }\n    return res;\n}\n\nint main() {\n    while(scanf(\"%d\", &n) == 1 && n) {\n        idx.clear();\n        cnt = 0;\n        for(int i = 1; i <= n; i++) {\n            scanf(\"%s%d%d\", name, &day, &Time);\n            pro[i].idx = hash(string(name));\n            pro[i].day = day;\n            pro[i].Time = Time;\n            pro[i].solve();\n        }\n        scanf(\"%d\", &p);\n        memset(must, false, sizeof(must));\n        memset(cannot, false, sizeof(cannot));\n        for(int i = 1; i <= p; i++) {\n            scanf(\"%s\", name);\n            must[hash(string(name))] = true;\n        }\n        stable_sort(pro + 1, pro + 1 + n);\n        int last = 0;\n        int ans = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(i == j) continue;\n                if(must[pro[i].idx] && must[pro[j].idx]) {\n                    if(con(pro[i], pro[j])) {\n                        ans = -1;\n                    }\n                }\n            }\n        }\n        \n        for(int i = 1; i <= n; i++) {\n            if(must[pro[i].idx]) {\n                for(int j = 1; j <= n; j++) {\n                    if(i == j)  continue;\n                    if(con(pro[i], pro[j]) || con(pro[j], pro[i])) {\n                        cannot[j] = true;\n                    }\n                }\n            }\n        }\n        \n        if(ans != -1) {\n            ans = p;\n            for(int i = 1; i <= n; i++) {\n                if(must[pro[i].idx]) {\n                    ans += calc(last + 1, i - 1);\n                    last = i;\n                }\n            }\n            ans += calc(last + 1, n);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        set<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.insert(s);\n        }\n        int p=-100000;\n        bool m=false;\n        int c=0;\n        for(int i=0;i<n;i++){\n            if(p+30>vec[i].first){\n                if(fav.count(vec[i].second)){\n                    if(m){\n                        c=-1;\n                        break;\n                    }else{\n                        m=true;\n                        p=vec[i].first;\n                    }\n                }\n            }else{\n                c++;\n                p=vec[i].first;\n                m=fav.count(vec[i].second);\n            }\n        }\n        cout<<c<<endl;\n//        vector<string>fav;\n//        for(int i=0;i<p;i++){\n//            cin>>s;\n//            fav.push_back(s);\n//        }\n//        sort(fav.begin(),fav.end(),sv);\n//        vector<string>res;\n//        res.push_back(fav[0]);\n//        bool nex=false;\n//        for(int i=1;i<fav.size();i++){\n//            if(ma[fav[i]]%10080<(ma[fav[i-1]]+30)%10080){\n//                cout<<-1<<endl;\n//                nex=true;\n//                break;\n//            }\n//            res.push_back(fav[i]);\n//        }\n//        if(nex){\n//            continue;\n//        }\n//        for(int i=0;i<vec.size();i++){\n//            int start=vec[i].first;\n//            int resi=0;\n//            while(resi<res.size()&&(ma[res[resi]]+30)%10080<=start%10080){\n//                resi++;\n//            }\n//            if(resi==res.size()||(start+30)%10080<=ma[res[resi]]){\n//                if(resi>0&&ma[res[resi-1]]+30>start){\n//                    continue;\n//                }\n//                res.push_back(vec[i].second);\n//                sort(res.begin(),res.end(),sv);\n//            }\n//        }\n//        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\n//Watchin' TVA\nclass Program{\npublic:\n\tint time;\n\tstring name;\n\tProgram(int _time, string _name) : time(_time), name(_name) {}\n\n\tbool operator < (const Program& p) const{\n\t\treturn time < p.time;\n\t}\n};\n\nint main(){\n\tint N,P;\n\t\n\n\twhile(~scanf(\"%d\",&N)){\n\t\tif(N==0) break;\n\t\tmap<int,vector<Program> > PRO;\n\t\tmap<string,bool> FAV;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring name;\n\t\t\tint day;\n\t\t\tint time;\n\t\t\tcin >> name >> day >> time;\n\t\t\tint m = time % 100;\n\t\t\tint h = time / 100;\n\t\t\tint total = h * 60 + m;\n\t\t\tPRO[day].push_back(Program(total,name));\n\t\t}\n\t\tscanf(\"%d\",&P);\n\t\tfor(int i=0;i<P;i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tFAV[name] = true;\n\t\t}\n\n\t\tbool failed = false;\n\t\tint res = 0;\n\t\tfor(map<int,vector<Program> >::iterator it = PRO.begin(); it != PRO.end(); it++){\n\t\t\tbool reserve[10000];\n\t\t\tmemset(reserve,0,sizeof(reserve));\n\t\t\tsort(it->second.begin(),it->second.end());\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) != FAV.end()){\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(reserve[j]){\n\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treserve[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) == FAV.end()){\n\t\t\t\t\tbool tmp[10000];\n\t\t\t\t\tmemcpy(tmp,reserve,sizeof(reserve));\n\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(tmp[j]){\n\t\t\t\t\t\t\tgoto cancel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(reserve,tmp,sizeof(tmp));\n\t\t\t\t\tres++;\n\t\t\t\t}\t\t\ncancel:;\n\t\t\t}\n\t\t}\nnext:;\n\n\t\tif(failed){\n\t\t\tprintf(\"%d\\n\",-1);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\n//Watchin' TVA\nclass Program{\npublic:\n\tint time;\n\tstring name;\n\tProgram(int _time, string _name) : time(_time), name(_name) {}\n\n\tbool operator < (const Program& p) const{\n\t\treturn time < p.time;\n\t}\n};\n\nint main(){\n\tint N,P;\n\t\n\n\twhile(~scanf(\"%d\",&N)){\n\t\tif(N==0) break;\n\t\tmap<int,vector<Program> > PRO;\n\t\tmap<string,bool> FAV;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring name;\n\t\t\tint day;\n\t\t\tint time;\n\t\t\tcin >> name >> day >> time;\n\t\t\tint m = time % 100;\n\t\t\tint h = time / 100;\n\t\t\tint total = h * 60 + m;\n\t\t\tPRO[day].push_back(Program(total,name));\n\t\t}\n\t\tscanf(\"%d\",&P);\n\t\tfor(int i=0;i<P;i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tFAV[name] = true;\n\t\t}\n\n\t\tbool failed = false;\n\t\tint res = 0;\n\t\tfor(map<int,vector<Program> >::iterator it = PRO.begin(); it != PRO.end(); it++){\n\t\t\tbool reserve[100000];\n\t\t\tmemset(reserve,0,sizeof(reserve));\n\n\t\t\tsort(it->second.begin(),it->second.end());\n\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) != FAV.end()){\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(reserve[j]){\n\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treserve[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i< it->second.size(); i++){\n\t\t\t\tif(FAV.find(it->second[i].name) == FAV.end()){\n\t\t\t\t\tbool tmp[100000];\n\t\t\t\t\tmemcpy(tmp,reserve,sizeof(reserve));\n\n\t\t\t\t\tfor(int j=it->second[i].time; j<it->second[i].time+30;j++){\n\t\t\t\t\t\tif(tmp[j]){\n\t\t\t\t\t\t\tgoto cancel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp[j]=true;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(reserve,tmp,sizeof(tmp));\n\t\t\t\t\tres++;\n\t\t\t\t}\t\t\ncancel:;\n\t\t\t}\n\t\t}\nnext:;\n\n\t\tif(failed){\n\t\t\tprintf(\"%d\\n\",-1);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n            if(time>=2400){\n                day=(day+1)%7;\n                time-=2400;\n            }\n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n//        for(int i=0;i<vec.size();i++){\n//            if(vec[i].second==\"mrahlcalv\")cout<<\"         \";\n//            cout<<vec[i].first<<\" \"<<vec[i].second<<endl;\n//        }\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end());\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]<ma[fav[i-1]]+30){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n        }\n        if(nex){\n            continue;\n        }\n        \n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            //cout<<res.size()<<\"  start: \"<<start<<\"   i: \"<<i<<\"     \";\n            while(resi<res.size()&&ma[res[resi]]+30<=start){\n                //cout<<ma[res[resi]]<<\" \";\n                resi++;\n            }\n//            cout<<ma[res[resi]]<<\" !!! \";\n//            for(int ii=0;ii<res.size();ii++){\n//                cout<<ma[res[ii]]<<\" \";\n//            }\n//            cout<<\" !!! \";\n            if(resi==res.size()||start+30<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                //cout<<\"  -------  \"<<resi<<\" \"<<ma[res[resi]]<<\" \";if(resi>1)cout<<ma[res[resi-1]];\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n            //cout<<res.size()<<endl;\n        }\n        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstdio>\nusing namespace std;\nint main(){\n\tint n,i,r,last,time,day;\n\tfor(;cin>>n,n;){\n\t\tvector<pair<int,string> >program;\n\t\tset<string>precious;\n\t\tstring s;\n\t\t{\n\t\t\tmap<string,int>m;\n\t\t\tfor(;n--;){\n\t\t\t\tcin>>s>>day>>time;\n\t\t\t\tprogram.push_back(make_pair(day*1440+time/100*60+time%100,s));\n\t\t\t\tm[s]=day*1440+time/100*60+time%100;\n\t\t\t}\n\t\t\tfor(cin>>n;n--;){\n\t\t\t\tcin>>s;\n\t\t\t\tset<string>::iterator it=precious.begin();\n\t\t\t\tfor(;it!=precious.end();it++){\n\t\t\t\t\tif(abs(m[*it]-m[s])<30){puts(\"-1\");goto next;}\n\t\t\t\t}\n\t\t\t\tprecious.insert(s);\n\t\t\t}\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tfor(last=r=i=0;i<program.size();i++){\n\t\t\tif(program[i].first>=last){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t\tr++;\n\t\t\t}else if(precious.find(program[i].second)!=precious.end()){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct anim\n{\n  string name;\n  int begin;\n};\n\nbool operator==( anim const& lhs, anim const& rhs )\n{\n  return lhs.name == rhs.name;\n}\n\nbool operator>( anim const& lhs, anim const& rhs )\n{\n  return lhs.begin > rhs.begin;\n}\n\nint calc_begin( int week, int begin )\n{\n  int subs = 0;\n  while( begin >= 2400 ) {\n    begin -= 2400;\n    ++subs;\n  }\n  int const minute = begin % 100, hour = begin / 100;\n  week += subs;\n  if ( week > 6 )\n    week -= 7;\n\n  return week * 24 * 60 + hour * 60 + minute; // test\n}\n\nbool is_over( vector<anim> const& an, anim const& a )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( a == *it )\n      continue;\n\n    if (\n\t( a.begin >= it->begin && a.begin < it->begin + 30 )\n\t|| ( a.begin + 30 > it->begin && a.begin + 30 <= it->begin + 30 )\n\t)\n      return true;\n  }\n\n  return false;\n}\n\nbool is_over( vector<anim> const& an )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( is_over( an, *it ) )\n      return true;\n  }\n\n  return false;\n}\n\n\n\n\nint main()\n{\n  int n;\n  while( cin >> n ) {\n    if ( n == 0 )\n      break;\n\n    map<string, anim> mx;\n    priority_queue<anim, vector<anim>, greater<anim> > pq;\n\n    for( int ii=0; ii<n; ++ii ) {\n      string n;\n      int week, b;\n      cin >> n >> week >> b;\n      anim const a = { n, calc_begin( week, b ) }; // test\n\n      mx.insert( pair<string, anim>( n, a ) ); // test\n      pq.push( a );\n    }\n\n    vector<anim> als;\n    int num = 0;\n\n    int f;\n    cin >> f;\n    for( int ii=0; ii<f; ++ii ) {\n      string fav;\n      cin >> fav;\n\n      als.push_back( mx[fav] );\n    }\n    if ( is_over( als ) ) {\n      num = -1;\n      goto fin;\n    }\n    \n    while( !pq.empty() ) {\n      anim const& a = pq.top();\n      if ( !is_over( als, a ) ) {\n\tals.push_back( a );\n\t++num;\n      }\n\n      pq.pop();\n    }\n\n  fin:\n    cout << num << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\nconst int MAXN = 11111;\nint dp[555][MAXN];\nstring name;\nmap<string, int> mp;\n//dp[i][j] = max(dp[i - 1][j - 30]);\nstruct bit {\n\tint n, c[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n;\n\t\tmemset(c, 0, n * sizeof(int));\n\t}\n\tvoid update(int x, int y) {\n\t\tx+=2;\n\t\twhile (x < n) {\n\t\t\tc[x] = max(c[x], y);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\tint get(int x) {\n\t\tx+=2;\n\t\tint ret = 0;\n\t\twhile (x) {\n\t\t\tret = max(ret, c[x]);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn ret;\n\t}\n}b;\n\nstruct data {\n\tint id, time;\n\tbool over;\n\tfriend bool operator <(const data& a, const data& b) {\n\t\treturn a.time < b.time;\n\t}\n}d[555];\nint id[555], idx = 0;\n\nbool notok(int a, int b) {\n\tif (d[a].time > d[b].time) {\n\t\tswap(a, b);\n\t}\n\tif (d[a].time + 30 > d[b].time) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint used[11111];\n\nint main() {\n\tint n, m;\n\tstring name;\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tmp.clear();\n\t\tint week, hour;\n\t\tint maxv = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> name >> week >> hour;\n\t\t\td[i].id = i - 1;\n\t\t\td[i].over = false;\n\t\t\td[i].time = week * 24 * 60 + ((hour / 100) - 5) * 60 + ((hour % 100));\n\t\t\tmaxv = max(maxv, d[i].time);\n\t\t\tcout << d[i].time << endl;\n\t\t\tmp[name] = i;\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tgetchar();\n\t\tidx = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tgetline(cin, name);\n\t\t\td[mp[name]].over = true;\n\t\t\tid[idx++] = mp[name];\n\t\t}\n\t\tmemset(used, 0, sizeof(used));\n\t\tbool die = false;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < idx; i++) {\n\t\t\tfor (int j = i + 1; j < idx; j++) {\n\t\t\t\tif (notok(id[i], id[j])) {\n\t\t\t\t\tdie = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << id[i] << endl;\n\t\t\tfor (int j = d[id[i]].time; j < d[id[i]].time + 30; j++) {\n\t\t\t\tused[j] = true;\n\t\t\t}\n\t\t\tans++;\n\t\t\tif (die) break;\n\t\t}\n\t\tif (die) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(d + 1, d + n + 1);\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\tif (used[j]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfor (int j = d[i].time; j < d[i].time + 30; j++) {\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t\tans++;\n\t\t\t\t//cout << i << endl;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<anime> table;\n      vector<anime> favoritetable;\n      map<string,anime> amap;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        anime t;\n        t.setup(na,we,st);\n        table.push_back(t);\n        amap[na] = t;\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        favoritetable.push_back(amap[na]);\n      }\n\n      sort(table.begin() , table.end());\n      sort(favoritetable.begin(), favoritetable.end());\n\n    //  int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      for(int i=1; i<favoritetable.size(); ++i){\n        if(abs(favoritetable[i].minutes - favoritetable[i-1].minutes) < 30){\n          cansee = false;\n        }\n      }\n\n      for(int i=0; i<table.size(); i++){\n        for(int j=0; j<favoritetable.size(); j++){\n          if(abs(table[i].minutes - favoritetable[j].minutes) < 30){\n            table.erase(table.begin() + i);\n            i--;\n            break;\n          }\n        }\n      }\n\n      int ans = table.size() + f;\n      long int tmp = 0;\n\n      for(int i=0; i<table.size(); i++){\n        if(abs(table[i].minutes - tmp) < 30){\n          ans--;\n        }\n        else{\n          tmp = table[i].minutes;\n        }\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << ans << endl;\n      }\n\n      /*\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n      */\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct hoge{\n    string name;\n    int start;\n    hoge(string name, int start) : name(name), start(start){ }\n};\nbool operator < (const hoge &a, const hoge &b){\n    return a.start < b.start;\n}\n\nint main(void){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        vector<hoge> v;\n        for(int i=0; i<n; i++){\n            string name;\n            int start, weekday, s;\n            cin >> name >> weekday >> start;\n            s=weekday*24*60+start/100*60+start%100;\n            v.push_back(hoge(name, s));\n        }\n        sort(v.begin(), v.end());\n        int p;\n        cin >> p;\n        bool timezone[12000], tf=true;\n        fill(timezone, timezone+12000, false);\n        \n        for(int i=0; i<p; i++){\n            string str;\n            cin >> str;\n            for(int j=0; j<n; j++){\n                if(tf){\n                    if(v[j].name==str){\n                        if(!timezone[v[j].start] && !timezone[v[j].start+29]){\n                            for(int t=v[j].start; t<v[j].start+30; t++){\n                                timezone[t]=true;\n                            }\n                        }else{\n                            tf=false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        int count=p;\n        if(! tf) cout << -1 << \"\\n\";\n        else{\n            for(int i=0; i<n; i++){\n                //cout << v[i].name << \" time=\" << v[i].start << \"\\n\";\n                if(! timezone[v[i].start] && !timezone[v[i].start+29]){\n                    //cout << \"OK=\" << v[i].name << \"\\n\";\n                    for(int j=v[i].start; j<v[i].start+30; j++){\n                        timezone[j]=true;\n                    }\n                    count++;\n                }\n            }\n            cout << count << \"\\n\";\n        }\n        \n        \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<utility>\n#include<string>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    pair<int,string> sc[500];\n    for(int i=0;i<n;i++){\n      string s;\n      int d,t;\n      cin>>s>>d>>t;\n      if(t>=2400){\n\tt-=2400;\n      }\n      sc[i]=make_pair(d*24*60+t/100*60+t%100,s);\n    }\n    sort(sc,sc+n);\n    set<string> fa;\n    int np;\n    cin>>np;\n    while(np--){\n      string f;\n      cin>>f;\n      fa.insert(f);\n    }\n    int p=-100000;\n    bool m=false;\n    int c=0;\n    for(int i=0;i<n;i++){\n      if(p+30>sc[i].first){\n\tif(fa.count(sc[i].second)){\n\t  if(m){\n\t    c=-1;\n\t    break;\n\t  }else{\n\t    m=true;\n\t    p=sc[i].first;\n\t  }\n\t}\n      }else{\n\tc++;\n\tp=sc[i].first;\n\tm=fa.count(sc[i].second);\n      }\n    }\n    cout<<c<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint main()\n{\n\tint n, p;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\ttypedef pair<int, string> P;\n\t\t\n\t\tP pro[512];\n\t\trep (i, n)\n\t\t{\n\t\t\tchar buf[64];\n\t\t\tint w, s;\n\t\t\tscanf(\"%s%d%d\", buf, &w, &s);\n\t\t\tpro[i] = P(w*24*60 + s/100*60 + s%100, buf);\n\t\t}\n\t\tsort(pro, pro + n);\n\n\t\tscanf(\"%d\", &p);\n\t\tset<string> fav;\n\t\trep (i, p)\n\t\t{\n\t\t\tchar buf[64];\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfav.insert(buf);\n\t\t}\n\n\t\tconst int week_minutes = 7*24*60;\n\t\tbool watch[week_minutes];\n\t\tfill_n(watch, week_minutes, false);\n\t\tint res = 0;\n\t\trep (i, n)\n\t\t{\n\t\t\tstring& name = pro[i].second;\n\t\t\tint time = pro[i].first;\n\t\t\tif (!fav.count(name))\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < 30; ++j)\n\t\t\t{\n\t\t\t\tint t = (time + j) % week_minutes;\n\t\t\t\tif (watch[t])\n\t\t\t\t{\n\t\t\t\t\tres = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twatch[t] = true;\n\t\t\t}\n\t\t\tif (res == -1)\n\t\t\t\tbreak;\n\n\t\t\t++res;\n\t\t}\n\t\tif (res == -1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\n\t\trep (i, n)\n\t\t{\n\t\t\tstring& name = pro[i].second;\n\t\t\tint time = pro[i].first;\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < 30; ++j)\n\t\t\t{\n\t\t\t\tint t = (time + j) % week_minutes;\n\t\t\t\tif (watch[t])\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twatch[t] = true;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t\t++res;\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Prog {\n\tint st, et;\n\tbool fav;\n\tstring name;\n\tProg(){}\n\tProg(int st, int et, bool fav, string name): st(st), et(et), fav(fav), name(name){}\n\tbool operator < (const Prog &t) const {\n\t\treturn st < t.st;\n\t}\n};\n\nint n, p;\nmap<string, int> mp;\nvector<Prog> v;\nvector<int> favs;\nint table[100000];\n\nvoid solve()\n{\n\tint res = 0;\n\tmemset(table, 0, sizeof(table));\n\tfor (int i = 0; i < favs.size(); i++){\n\t\tres++;\n\t\tfor (int t = v[favs[i]].st; t < v[favs[i]].et; t++){\n\t\t\ttable[t]++;\n\t\t\tif (table[t] > 1){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++){\n\t\tif (v[i].fav) continue;\n\t\tif (table[v[i].st] || table[v[i].et - 1]) continue;\n\t\tres++;\n\t\tfor (int t = v[i].st; t < v[i].et; t++){\n\t\t\ttable[t]++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &n), n){\n\t\tv.clear();\n\t\tmp.clear();\n\t\tfavs.clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring name;\n\t\t\tint w, s;\n\t\t\tcin >> name >> w >> s;\n\t\t\tint t = w * 10000 + (s / 100 * 60) + (s % 60);\n\t\t\tv.push_back(Prog(t, t + 30, false, name));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tmp[v[i].name] = i;\n\t\t}\n\t\t\n\t\tscanf(\"%d\", &p);\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tv[mp[name]].fav = true;\n\t\t\tfavs.push_back(mp[name]);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<utility>\n#include<string>\n#include<set>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    pair<int,string> sc[500];\n    for(int i=0;i<n;i++){\n      string s;\n      int d,t;\n      cin>>s>>d>>t;\n      sc[i]=make_pair(d*24*60+t/100*60+t%100,s);\n    }\n    sort(sc,sc+n);\n    set<string> fa;\n    int np;\n    cin>>np;\n    while(np--){\n      string f;\n      cin>>f;\n      fa.insert(f);\n    }\n    int p=-100000;\n    bool m=false;\n    int c=0;\n    for(int i=0;i<n;i++){\n      if(p+30>sc[i].first){\n\tif(fa.count(sc[i].second)){\n\t  if(m){\n\t    c=-1;\n\t    break;\n\t  }else{\n\t    m=true;\n\t    p=sc[i].first;\n\t  }\n\t}\n      }else{\n\tc++;\n\tp=sc[i].first;\n\tm=fa.count(sc[i].second);\n      }\n    }\n    cout<<c<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 7;\nvector<int> in[N];\n\nint solve(int now){\n  int cnt=0,last=0;\n  rep(i,(int)in[now].size()){\n    if (last+30 <= in[now][i]){\n      cnt++;\n      last=in[now][i];\n    }\n  }\n  return cnt;\n}\n\nint getindex(string &in,map<string,int> &M){\n  int index=(int)M.size();\n  if (M.find(in) == M.end())M[in]=index;\n  return M[in];\n}\n\ninline int gettime(int n){\n  int h=n/100,m=n%100;\n  return h*60+m;\n}\n\ninline bool cansee(int i,int j){\n  int maxbeg=max(i,j),minend=min(i+30,j+30);\n  return minend <= maxbeg;\n}\n\nint solve(int n,vector<int> *ng,int *day,int *time,bool *isfav){\n  rep(k,N){\n    rep(i,(int)ng[k].size()){\n      REP(j,i+1,(int)ng[k].size()){\n\tif (!cansee(ng[k][i],ng[k][j]))return -1;\n      }\n    }\n  }\n  rep(i,n){\n    int now=day[i];\n    bool isok=!isfav[i];\n    rep(j,(int)ng[now].size()){\n      if(!cansee(ng[now][j],time[i])){\n\tisok=false;\n\tbreak;\n      }\n    }\n    if (isok)in[now].push_back(time[i]);\n  }\n  int ret=0;\n  rep(i,N){\n    sort(in[i].begin(),in[i].end());\n    //rep(j,(int)in[i].size())cout << in[i][j]<<\" \" ;\n    //cout << endl;\n    ret+=solve(i);\n    //cout << i <<\" \" << ret << \" \" << in[i].size() << endl;\n  }\n  return ret;\n}\n\nmain(){\n  int n;\n  static string tmp[500];\n  static int day[500],time[500];\n  static bool isfav[500];\n  while(cin>>n  && n){\n    map<string,int> M;\n    rep(i,7)in[i].clear();\n    rep(i,n){\n      cin>>tmp[i];\n      M[tmp[i]]=i;\n      cin>>day[i]>>time[i];\n      time[i]=gettime(time[i]);\n      isfav[i]=false;\n    }\n    vector<int> NG[N];\n    int m;\n    cin>>m;\n    rep(i,m){\n      string a;\n      cin>>a;\n      int ind=getindex(a,M);\n      NG[day[ind]].push_back(time[ind]);\n      isfav[ind]=true;\n    }\n    int ans=solve(n,NG,day,time,isfav);\n    if (ans==-1)cout << -1 << endl;\n    else cout << ans+m<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct pro{\n    char name[40];\n    int st;\n    bool operator <(const pro &a)const{\n        return st <= a.st;\n    }\n}p[600];\nchar nam[600][40];\nint pi[600];\nint d[600][2];\nint cal(int l,int r)\n{\n    d[l][0] = 0;d[l][1] = 1;\n    for(int i = l + 1; i <= r; ++i){\n        d[i][0] = 0,d[i][1] = 1;\n        for(int j = l; j < i; ++j){\n            if(d[i][0] < d[j][0])\n                d[i][0] = d[j][0];\n            if(d[i][0] < d[j][1])\n                d[i][0] = d[j][1];\n            if(p[i].st - p[j].st>=30&&d[i][1] < d[j][0]+1)\n                d[i][1] = d[j][0]+1;\n            if(p[i].st - p[j].st>=30&&d[i][1] < d[j][1]+1)\n                d[i][1] = d[j][1]+1;\n        }\n    }\n    int ans = 0;\n    for(int i = l; i <= r; ++i){\n        if(ans < d[i][0])\n            ans = d[i][0];\n        if(ans < d[i][1])\n            ans = d[i][1];\n    }\n    return ans;\n}\nint main()\n{\n    //freopen(\"d:\\\\in.txt\",\"r\",stdin);\n    int n,m;\n    while(scanf(\"%d\",&n),n){\n        for(int i = 0; i < n; ++i){\n            int a,b;\n            scanf(\"%s %d %d\",p[i].name,&a,&b);\n            p[i].st = a*2400+b;\n        }\n        sort(p,p+n);\n        //for(int i = 0; i < n; ++i)\n            //printf(\"%d %s %d\\n\",i,p[i].name,p[i].st);\n        scanf(\"%d\",&m);\n        bool fg = true;\n        for(int i = 0 ;i < m; ++i){\n            scanf(\"%s\",nam[i]);\n            bool flag = true;\n            for(int j = 0; j < n; ++j){\n                if(strcmp(nam[i],p[j].name) == 0){\n                    pi[i] = j;\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag)\n                fg = false;\n        }\n        if(fg == false){\n            puts(\"-1\");\n            continue;\n        }\n        sort(pi,pi+m);\n        fg = true;\n        for(int i = 1;i < m; ++i){\n            if(p[pi[i]].st -p[pi[i-1]].st < 30){\n                fg = false;\n                break;\n            }\n        }\n        if(fg == false){\n            puts(\"-1\");\n            continue;\n        }\n        int ans = m;\n        for(int i = 1; i < m; ++i){\n            int l = pi[i-1];\n            while(l < pi[i]){\n                if(p[l].st-p[pi[i-1]].st >= 30)\n                    break;\n                ++l;\n            }\n            if(l == pi[i])\n                continue;\n            //printf(\"#%d\\n\",l);\n            int r = pi[i];\n            while(r > pi[i-1]){\n                if(p[pi[i]].st-p[r].st >= 30)\n                    break;\n                --r;\n            }\n            if(r == pi[i-1]){\n                continue;\n            }\n            //printf(\"%d %d %d\\n\",i,l,r);\n            ans += cal(l,r);\n        }\n        int l = pi[m-1];\n        while(l < n){\n            if(p[l].st-p[pi[m-1]].st >= 30)\n                break;\n            ++l;\n        }\n        if(l != n)\n            ans += cal(l,n-1);\n\n        int r = pi[0];\n        while(r >= 0){\n            if(p[pi[0]].st-p[r].st >= 30)\n                break;\n            --r;\n        }\n        if(r >= 0){\n            ans += cal(0,r);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 500;\n\nclass P{\npublic:\n  string name;\n  int wd, st;\n  P(){}\n  P(string name, int wd, int st) : name(name), wd(wd), st(st) {}\n  bool operator < (const P& s) const {\n    if(wd == s.wd) return st < s.st;\n    return wd < s.wd;\n  }\n};\n\nint n, m;\nvector<P> data;\nvector<int> f;\nbool used[N];\n\nint solve(){\n  fill(used, used+n, false);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      if(!used[j]) continue;\n      if(data[f[i]].wd != data[j].wd) continue;\n      if(data[f[i]].st <= data[j].st && data[j].st < data[f[i]].st + 30 ||\n        data[j].st <= data[f[i]].st && data[f[i]].st < data[j].st + 30) return -1;\n    }\n    used[f[i]] = true;\n  }\n  int res = m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(!used[j]) continue;\n      if(data[i].wd != data[j].wd) continue;\n      if(data[i].st <= data[j].st && data[j].st < data[i].st + 30 ||\n        data[j].st <= data[i].st && data[i].st < data[j].st + 30) goto FAILED;\n    }\n    res++;\n    used[i] = true;\n    FAILED:;\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    data.clear();\n    f.clear();\n    for(int i=0;i<n;i++){\n      string name, time;\n      int wd, st;\n      cin >> name >> wd >> time;\n      st = atoi(time.substr(0, (int)time.size()-2).c_str()) * 60 + atoi(time.substr((int)time.size()-2).c_str());\n      data.push_back(P(name, wd, st));\n    }\n    sort(data.begin(), data.end());\n    cin >> m;\n    for(int i=0;i<m;i++){\n      string in;\n      cin >> in;\n      for(int j=0;j<n;j++) if(data[j].name == in) f.push_back(j);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[last].minutes - table[first].minutes >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].minutes - table[n-2].minutes >= 30){\n        count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct anim\n{\n  string name;\n  int begin;\n};\n\nbool operator==( anim const& lhs, anim const& rhs )\n{\n  return lhs.name == rhs.name;\n}\n\nbool operator>( anim const& lhs, anim const& rhs )\n{\n  return lhs.begin > rhs.begin;\n}\n\nint calc_begin( int week, int begin )\n{\n  int subs = 0;\n  while( begin >= 2400 ) {\n    begin -= 2400;\n    ++subs;\n  }\n  int const minute = begin % 100, hour = begin / 100;\n  week += subs;\n  if ( week > 6 )\n    week -= 7;\n\n  return week * 24 * 60 + hour * 60 + minute; // test\n}\n\nbool is_over( vector<anim> const& an, anim const& a )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( a == *it )\n      continue;\n\n    if (\n\t( a.begin >= it->begin && a.begin < it->begin + 30 )\n\t|| ( a.begin + 30 > it->begin && a.begin + 30 <= it->begin + 30 )\n\t)\n      return true;\n  }\n\n  return false;\n}\n\nbool is_over( vector<anim> const& an )\n{\n  typedef vector<anim>::const_iterator i_t;\n  for( i_t it=an.begin(); it != an.end(); ++it ) {\n    if ( is_over( an, *it ) )\n      return false;\n  }\n\n  return false;\n}\n\n\n\n\nint main()\n{\n  int n;\n  while( cin >> n ) {\n    if ( n == 0 )\n      break;\n\n    map<string, anim> mx;\n    priority_queue<anim, vector<anim>, greater<anim> > pq;\n\n    for( int ii=0; ii<n; ++ii ) {\n      string n;\n      int week, b;\n      cin >> n >> week >> b;\n      anim const a = { n, calc_begin( week, b ) }; // test\n\n      mx.insert( pair<string, anim>( n, a ) ); // test\n      pq.push( a );\n    }\n\n    vector<anim> als;\n    int num = 0;\n\n    int f;\n    cin >> f;\n    for( int ii=0; ii<f; ++ii ) {\n      string fav;\n      cin >> fav;\n\n      als.push_back( mx[fav] );\n    }\n    if ( is_over( als ) ) {\n      num = -1;\n      goto fin;\n    }\n    \n    while( !pq.empty() ) {\n      anim const& a = pq.top();\n      if ( !is_over( als, a ) ) {\n\tals.push_back( a );\n\t++num;\n      }\n\n      pq.pop();\n    }\n\n  fin:\n    cout << num << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m)%10080;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    vector<pair<int,string>> animes2;\n    map<int,string> range;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        //cout<<m<<endl;\n        animes[name]=m;\n        animes2.pb(mp(m,name));\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) return -1;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    sort(all(animes2));\n    for(const auto &anime : animes2) {\n        string s=anime.second;\n        int m=anime.first;\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n \nconst int DAY = 24*60;\nconst int MAXN = 500;\n \nint N;\nstring name[MAXN];\npair<int,int> V[MAXN];\nint P;\nint F[MAXN];\nbool used[MAXN];\n \nbool kaburi(int a, int b) {\n  return abs(a-b)<30;\n}\n \nint solve() {\n  for(int i = 0; i < P; ++i) {\n    for(int j = 0; j < i; ++j) {\n      if(kaburi(V[F[i]].first, V[F[j]].first)) {\n        return -1;\n      }\n    }\n  }\n \n  vector<pair<int,int> > v;\n  for(int i = 0; i < N; ++i) {\n    bool flag = true;\n    for(int j = 0; j < P; ++j) {\n      if(kaburi(V[i].first, V[F[j]].first)) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      v.push_back(V[i]);\n    }\n  }\n  sort(v.begin(), v.end());\n  fill(used, used+MAXN, false);\n  int res = P;\n  for(int i = 0; i < v.size(); ++i) {\n    bool flag = true;\n    for(int j = 0; j < i; ++j) {\n      if(used[j] && kaburi(v[i].first, v[j].first)) {\n        flag = false;\n        break;\n      }\n    }\n    if(flag) {\n      ++res;\n      used[i] = true;\n    }\n  }\n  return res;\n}\n \nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      int w, s;\n      cin >> name[i] >> w >> s;\n      V[i].first = w*DAY + (s/100) * 60 + s%100;\n      V[i].second = i;\n    }\n    cin >> P;\n    for(int i = 0; i < P; ++i) {\n      string s;\n      cin >> s;\n      for(int j = 0; j < N; ++j) {\n        if(s == name[j]) {\n          F[i] = j;\n          break;\n        }\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, string> P;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n, n) {\n        vector<P> anime(n);\n        REP(i, 0, n) {\n            string s;\n            cin >> s;\n            int w, d;\n            cin >> w >> d;\n            int t = w * 24 * 60 + d / 100 * 60 + d % 100;\n            anime[i] = {t, s};\n        }\n        const int size = 24 * 60 * 7;\n\n        int m;\n        cin >> m;\n        vector<int> used(size, 0);\n        {\n            REP(i, 0, m) {\n                string s;\n                cin >> s;\n                for (auto it = anime.begin(); it != anime.end(); it++) {\n                    if ((*it).second == s) {\n                        REP(j, 0, 30) {\n                            used[((*it).first + j) % size]++;\n                        }\n                        anime.erase(it);\n                        break;\n                    }\n                }\n            }\n            bool check = true;\n            REP(i, 0, size) {\n                if (used[i] > 1) {\n                    check = false;\n                }\n            }\n            if (!check) {\n                cout << -1 << endl;\n                continue;\n            }\n        }\n        sort(anime.begin(), anime.end());\n\n        int ans = m;\n        for (auto &A : anime) {\n            bool check = true;\n            REP(j, 0, 30) {\n                if (used[(A.first + j) % size] != 0) {\n                    check = false;\n                }\n            }\n            if (check) {\n                REP(j, 0, 30) {\n                    used[(A.first + j) % size]++;\n                }\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1063\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair <int, int> P;\n\nint main(void)\n{\n\tint n, p;\n\n\twhile (cin >> n, n){\n\t\tvector < pair <P, int> > v, must;\n\t\tvector < string > name;\n\t\tstring tmp;\n\t\tint week, start;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> tmp >> week >> start;\n\t\t\tint s = (week * 60 * 60 * 24) + (start / 100 * 60 * 60) + (start % 100);\n\t\t\tint t = s + (60 * 30);\n\t\t\tv.push_back(make_pair(make_pair(t, s), i));\n\t\t\tname.push_back(tmp);\n\t\t}\n\t\tcin >> p;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tcin >> tmp;\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (tmp == name[j]){\n\t\t\t\t\tmust.push_back(make_pair(v[j].first, j));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\tsort(must.begin(), must.end());\n\n\t\tint ret = -1, last = -1;\n\t\tbool done[512] = {false}, flag = true;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tif (last > must[i].first.second){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = must[i].first.first;\n\t\t}\n\t\tif (!flag){\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = p;\n\t\tfor (int i = 0; i < p; i++){\n\t\t\tdone[must[i].second] = true;\n\t\t}\n\n\t\tlast = -1;\n\t\t// cout << \"*****\" << endl;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint s = v[i].first.second, e = v[i].first.first, id = v[i].second;\n\t\t\t// cout << last << \" \" << name[id] << endl;\n\t\t\tif (done[id]){\n\t\t\t\tlast = e;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (last > s) continue;\n\t\t\tret++;\n\t\t\tlast = e;\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n \n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nvoid fin(){\n\tfreopen(\"test.txt\", \"r\", stdin);\n}\n\nbool sametime(int s1, int s2){\n\tint e1 = s1+29, e2 = s2+29;\n\tif(s1 <= e2 && s2 <= e1) return true;\n\treturn false;\n}\n\nbool canwatch(vector<int> &v, int s){\n\trep(i, v.size()){\n\t\tif( sametime(v[i], s)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n//\tfin();\n\tint n;\n\twhile(cin >> n, n){\n\t\tmap<string, int> m;\n\t\tvector<int> time;\n\t\trep(i, n){\n\t\t\tstring name;\n\t\t\tint w, start;\n\t\t\tcin >> name >> w >> start;\n\t\t\tstart = start%100 + start/100*60 + w*60*24;\n\t\t\tm[name] = start;\n\t\t\ttime.push_back(start);\n\t\t}\n\t\tvector<int> watch;\n\t\tint p;\n\t\tcin >> p;\n\t\tbool ng = false;\n\t\trep(i, p){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tif(!canwatch(watch, m[name])) ng = true;\n\t\t\twatch.push_back(m[name]);\n\t\t}\n\n\t\tsort(all(time));\n\t\trep(i, time.size()){\n\t\t\tif(!canwatch(watch, time[i])) continue;\n\t\t\twatch.push_back(time[i]);\n\t\t}\n\n\t\tif(ng)cout << -1 << endl;\n\t\telse cout << watch.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint n, p;\ntypedef pair<int, string> TV;\n\nint main() {\n\twhile(cin >> n, n) {\n\t\tvector<TV> tvs;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tstring name;\n\t\t\tint week, start;\n\t\t\tcin >> name >> week >> start;\n\t\t\ttvs.push_back(TV(week * 60*24 + (start / 100 * 60) + start % 100, name));\n\t\t}\n\t\tvector<int> times;\n\t\tcin >> p;\n\t\tint curTime = -300;\n\t\tint tvCount = p;\n\t\tsort(tvs.begin(), tvs.end());\n\t\tfor(int i = 0; i < p; i++) {\n\t\t\tstring fav;\n\t\t\tcin >> fav;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(tvs[j].second == fav) {\n\t\t\t\t\tfor(int k = 0; k < (int)times.size(); k++) {\n\t\t\t\t\t\tif(tvs[j].first < times[k] + 30 && times[k] < tvs[j].first + 30) {\n\t\t\t\t\t\t\tgoto mirenai;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttimes.push_back(tvs[j].first);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tsort(times.begin(), times)\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tbool watchable = true;\n\t\t\tfor(int k = 0; k < times.size(); k++) {\n\t\t\t\tif(tvs[i].first < times[k] + 30 && times[k] < tvs[i].first + 30) {\n\t\t\t\t\twatchable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!watchable || tvs[i].first < curTime + 30 && curTime < tvs[i].first + 30) {\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttvCount++;\n\t\t\t\tcurTime = tvs[i].first;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << tvCount << endl;\n\t\tcontinue;\n\t\t\n\t\tmirenai:\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<anime> table;\n      vector<anime> favoritetable;\n      map<string,anime> amap;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        anime t;\n        t.setup(na,we,st);\n        table.push_back(t);\n        amap[na] = t;\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        favoritetable.push_back(amap[na]);\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table.begin() , table.end());\n      sort(favoritetable.begin(), favoritetable.end());\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      for(int i=0; i<favoritetable.size()-1; i++){\n        if(abs(favoritetable[i+1].minutes - favoritetable[i].minutes) < 30){\n          cansee = false;\n          break;\n        }\n      }\n\n      for(int i=0; i<table.size(); i++){\n        for(int j=0; j<favoritetable.size(); j++){\n          if(abs(table[i].minutes - favoritetable[j].minutes) < 30){\n            table.erase(table.begin() + i);\n            i--;\n            break;\n          }\n        }\n      }\n\n      int ans = table.size() + f;\n      long int tmp = 0;\n\n      for(int i=0; i<table.size(); i++){\n        if(abs(table[i].minutes - tmp) < 30){\n          ans--;\n        }\n        else{\n          tmp = table[i].minutes;\n        }\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << ans << endl;\n      }\n\n      /*\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n      */\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define fr first\n#define sc second\n#define INF (1<<30)\nint main(){\n  int N,P,ans = 0;\n  cin >> N;\n  vector<pair<int,string> > vc(N);\n  for(int i = 0 ; i < N ; i++ ){\n    string name;\n    int weekday , start;\n    cin >> name >> weekday >> start;\n    vc[i] = make_pair(weekday * 24 * 60 + (start/100)*60 + start % 100,name);\n  }\n  sort(vc.begin(),vc.end());\n  cin >> P;\n  for(int q = 0 ; q < P ; q++ ){\n    string fav;\n    bool OR = false;\n    cin >> fav;\n    for(int i = 0 ; i < (int)vc.size() ; i++ ){\n      if(vc[i].sc == fav){\n        OR = true;\n        pair<int,string> r = make_pair(vc[i].fr-29,\"0\"),l = make_pair(vc[i].fr+30,\"0\");\n        vc.erase(lower_bound(vc.begin(),vc.end(),r),lower_bound(vc.begin(),vc.end(),l));\n        break;\n      }\n    }\n    if(!OR) ans = -INF;\n  }\n  int now = 0;\n  for(int i = 0 ; i < (int)vc.size() ; i++ ){\n    if(vc[i].fr >= now) now = vc[i].fr + 30 , ans++;\n  }\n  cout << max(-1,ans+P) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\ntypedef unsigned long long ll;\n\nmap<string, int>ma;\nvector<pair<int, string> >vec;\n\nstruct sortVec{\n    bool operator()(string m1, string m2){\n        return ma[m1]<ma[m2];\n    }\n}sv;\n\nint main(){\n    int n,p;\n    while(cin>>n,n){\n        ma.clear();\n        vec.clear();\n        string s;\n        for(int i=0;i<n;i++){\n            int day,time;\n            cin>>s>>day>>time;\n         \n            time=(time/100)*60+time%100+day*24*60;\n            ma[s]=time;\n            vec.push_back(make_pair(time,s));\n        }\n        sort(vec.begin(),vec.end());\n        cin>>p;\n        vector<string>fav;\n        for(int i=0;i<p;i++){\n            cin>>s;\n            fav.push_back(s);\n        }\n        sort(fav.begin(),fav.end(),sv);\n        vector<string>res;\n        res.push_back(fav[0]);\n        bool nex=false;\n        for(int i=1;i<fav.size();i++){\n            if(ma[fav[i]]%10080<(ma[fav[i-1]]+30)%10080){\n                cout<<-1<<endl;\n                nex=true;\n                break;\n            }\n            res.push_back(fav[i]);\n        }\n        if(nex){\n            continue;\n        }\n        for(int i=0;i<vec.size();i++){\n            int start=vec[i].first;\n            int resi=0;\n            while(resi<res.size()&&(ma[res[resi]]+30)%10080<=start%10080){\n                resi++;\n            }\n            if(resi==res.size()||(start+30)%10080<=ma[res[resi]]){\n                if(resi>0&&ma[res[resi-1]]+30>start){\n                    continue;\n                }\n                res.push_back(vec[i].second);\n                sort(res.begin(),res.end(),sv);\n            }\n        }\n        cout<<res.size()<<endl;\n    ne:;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <string>\ntypedef std::pair<int, int> pb;\n\nint n, m;\nstd::map<std::string, pb> id;\n\nconst int N = 500 + 10;\nconst int T = 20000;\nconst int ch_sz = 40;\n\nchar s[N][ch_sz];\nint week[N], ti[N];\n\npb chose[N], check[N];\nint chosesz, checksz;\n\nchar ch[ch_sz];\nint d[N][T];\n\ninline int Cal(const pb& a) {\n    return a.second * 24 * 60 + a.first / 100 * 60 + a.first % 100;\n}\nbool rok(const pb& a, const pb& b) {\n    int tota = (a.second == 0 ? 7 : a.second) * 24 * 60 + a.first / 100 * 60 + a.first % 100;\n    int totb = (b.second == 0 ? 7 : b.second) * 24 * 60 + b.first / 100 * 60 + b.first % 100;\n    return abs(tota - totb) < 30;\n}\nbool ok(const pb& a, const pb& b) {\n    if (abs(Cal(a) - Cal(b)) < 30) return true;\n    return rok(a, b);\n}\nbool cmp(const pb& a, const pb& b) {\n    return Cal(a) < Cal(b);\n}\nvoid work() {\n    id.clear();\n    checksz = chosesz = 0;\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s%d%d\", s[i], &week[i], &ti[i]);\n        id[s[i]] = pb(ti[i], week[i]);\n    }\n\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%s\", ch);\n        check[checksz ++] = id[ch];\n    }\n\n    for (int i = 0; i < checksz; ++i) {\n        for (int j = i + 1; j < checksz; ++j) {\n            if (ok(check[i], check[j])) {\n                puts(\"-1\");\n                return ;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        bool f = true;\n        for (int j = 0; j < checksz; ++j) {\n            if (ok(pb(ti[i], week[i]), check[j])) {\n                f = false; break;\n            }\n        }\n        if (f) {\n            chose[chosesz ++] = pb(ti[i], week[i]);\n        }\n    }\n\n    std::sort(chose, chose + chosesz, cmp);\n    memset(d, 0, sizeof(d));\n\n    int mx = 0;\n    if (chosesz > 0)\n        mx = 1;\n\n    for (int i = 0; i < chosesz; ++i) {\n        int ed = Cal(chose[i]);\n        d[i][ed + 30] = 1;\n        for (int j = 0; j < i; ++j) {\n            for (int k = ed; k >= 0; --k) {\n                if (d[j][k] > 0 && !rok(chose[i], chose[j]))\n                    d[j][ed + 30] = std::max(d[j][k] + 1, d[j][ed + 30]);\n                mx = std::max(mx, d[j][ed + 30]);\n            }\n        }\n    }\n    printf(\"%d\\n\", mx + m);\n}\nint main() {\n    while (1 == scanf(\"%d\", &n)) {\n        if (0 == n) break;\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b,i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n\n    int ai=0,bi=0,now=0,ans=0;\n    int as=A.size(),bs=B.size();\n    for(int i=0;i<as;i++)A.push_back(P(A[i].first+60*24*7,A[i].second));\n    for(int i=0;i<bs;i++)B.push_back(P(B[i].first+60*24*7,B[i].second));\n    as*=2;\n    bs*=2;\n    bool used[501]={};\n    used[N]=true;\n    while(ai<as||bi<bs){\n      int ag=(ai<as?A[ai].first:1e9);\n      int aw=(ai<as?A[ai].second:N);\n      int bg=(bi<bs?B[bi].first:1e9);\n      int bw=(bi<bs?B[bi].second:N);\n      if(now<=ag&&ag+30<=bg){\n\tnow=ag+30;\n\tif(!used[aw])ans++;\n\tused[aw]=true;\n\tai++;\n      }else if(ag<now){\n\tai++;\n      }else{\n\tnow=bg+30;\n\tif(!used[bw])ans++;\n\tused[bw]=true;\n\tbi++;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nstruct tv {\n\tstring name;\n\tint time;\n};\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N; \n\t\tif (!N)break;\n\t\tvector<tv>tvs;\n\t\tvector<int>needs;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int w, s; cin >> name >> w >> s;\n\t\t\tint time = w * 1440 + (s / 100) * 60 + s % 100;\n\t\t\ttvs.push_back(tv{ name,time });\n\t\t}\n\t\tsort(tvs.begin(), tvs.end(), [](const tv&l, const tv&r) {\n\t\t\treturn l.time < r.time;\n\t\t});\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ttv atv{ tvs[i].name,tvs[i].time + 1440 * 7 };\n\t\t\ttvs.emplace_back(atv);\n\t\t}\n\t\tint P; cin >> P;\n\t\tfor (int i = 0; i < P; ++i) {\n\t\t\tstring target; cin >> target;\n\t\t\tauto it = find_if(tvs.begin(), tvs.end(), [=](const tv&t) {\n\t\t\t\treturn t.name == target;\n\t\t\t});\n\t\t\tneeds.push_back(it - tvs.begin());\n\t\t}\n\t\tsort(needs.begin(), needs.end());\n\t\tneeds.push_back((*needs.begin())+N);\n\t\tbool ok = true;\n\t\tint ans = P;\n\t\tfor (int i = 0; i < needs.size()-1; ++i) {\n\t\t\tint from = tvs[needs[i]].time + 30;\n\t\t\tint to = tvs[needs[i + 1]].time;\n\t\t\tif (to < from)ok = false;\n\t\t\telse {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int p = needs[i] + 1; p < needs[i + 1]; ++p) {\n\t\t\t\t\tif (from <= tvs[p].time&&tvs[p].time + 30 <= to) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tfrom = tvs[p].time + 30;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans += sum;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif (!ok)cout << -1 << endl;\n\t\telse {\n\n\t\t\tcout << ans << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef pair<int,string> P;\n \nbool Diff(int x,int y);\nbool Check(P& p);\n \nvector<P> fav;\nvector<P> anime;\n \nint main() {\n    int n;\n    while(cin>>n,n) {\n        anime.clear();\n        fav.clear();\n        for(int i=0;i<n;i++) {\n            string name;\n            int weekday,start,time;\n            cin>>name>>weekday>>start;\n            time=(weekday*1440+start/100*60+start%100)%(1440*7);\n            anime.push_back(P(time,name));\n        }\n        sort(anime.begin(),anime.end());\n        int p;cin>>p;\n        for(int i=0;i<p;i++) {\n            string name;cin>>name;\n            for(int i=0;i<anime.size();i++) {\n                if(anime[i].second==name) {\n                    fav.push_back(P(anime[i].first,anime[i].second));\n                    break;\n                }\n            }\n        }\n        sort(fav.begin(),fav.end());\n        bool okay=true;\n        for(int i=0;i<fav.size();i++) {\n            for(int j=0;j<fav.size();j++) {\n                if(i!=j&&Diff(fav[i].first,fav[j].first)) {okay=false;}\n            }\n        }\n        if(!okay) {cout<<-1<<endl;continue;}\n        vector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n        anime.erase(itr,anime.end());\n        int count=0;\n        for(int i=0;i<anime.size();i++) {\n            if(anime[i].first==-1) continue; else count++;\n            int temp=anime[i].first;\n            for(int j=0;j<anime.size();j++) {\n                if(Diff(temp,anime[j].first)) anime[j].first=-1;\n            }\n        }\n        cout<<count<<endl;\n    }\n}\n \nbool Diff(int x,int y) {\n    int max_t=max(x,y);\n    int min_t=min(x,y);\n\tint diff1=(max_t-min_t),diff2=(max_t-(min_t+1440*7));\n    return (0<diff1&&diff1<30)||(-30<diff2&&diff2<0);\n}\n \nbool Check(P& p) {\n    bool okay=false;\n    for(int i=0;i<fav.size();i++) {\n        if(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n    }\n    return okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nstruct data{\n    data(){}\n    string name;\n    int start;\n    bool operator<(const data other) const{\n        return start < other.start;\n    }\n};\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        bool t[60*24*8] = {};\n        data d[n];\n        int a, b;\n        for(int i = 0; i < n; i++){\n            cin >> d[i].name >> a >> b;\n            d[i].start = 60*24*a + b/100*60 + b%100;\n        }\n        sort(d, d+n);\n        \n        map<string,int> m;\n        for(int i = 0; i < n; i++)  m[d[i].name] = i;\n\n        int p;\n        cin >> p;\n        \n        string imp;\n        bool valid = true;\n        \n        for(int i = 0; i < p; i++){\n            cin >> imp;\n            for(int j = 0; j < 30; j++){\n                if(t[d[m[imp]].start+j])   valid = false;\n                t[d[m[imp]].start+j] = true;\n            }\n        }\n\n        if(!valid){\n            cout << -1 << endl;\n            continue;\n        }\n\n        int ans = p;\n        for(int i = 0; i < n; i++){\n            bool judge = true;\n            for(int j = 0; j < 30; j++){\n                if(t[d[i].start+j])   judge = false;\n            }\n            if(!judge)  continue;\n            for(int j = 0; j < 30; j++){\n                t[d[i].start+j] = true;\n            }\n            ans++;\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint N;\nvector<string> names;\nvector<int> starts;\nint P;\nvector<string> favs;\nmap<string, int> to_id;\nbool cross_impl(int s1, int s2) {\n    if (s1 <= s2 && s2 < s1 + 30) return true;\n    return false;\n}\nbool cross(int s1, int s2) { return cross_impl(s1, s2) || cross_impl(s2, s1); }\nvoid solve() {\n    rep(i, P) rep(j, P) if (i != j) {\n        int a = to_id[favs[i]];\n        int b = to_id[favs[j]];\n        if (cross(starts[a], starts[b])) {\n            // cout << \"muri: \" << favs[i] << \", \" << favs[j] << endl;\n            // cout << a << \", \" << b << endl;\n            // cout << starts[a] << \", \" << starts[b] << endl;\n            cout << \"-1\" << endl;\n            return;\n        }\n    }\n    vector<int> used;\n    rep(i, P) {\n        int a = to_id[favs[i]];\n        used.push_back(starts[a]);\n    }\n    rep(_, N) {\n        int mini = 1e8;\n        for (auto s : starts) {\n            bool ok = true;\n            for (auto x : used) ok &= !cross(x, s);\n            if (ok && mini > s) mini = s;\n        }\n        if (mini != 1e8) used.push_back(mini);\n    }\n    cout << used.size() << endl;\n}\nint main() {\n    while (cin >> N, N) {\n        rep(i, N) {\n            string n;\n            int w, s;\n            cin >> n >> w >> s;\n            s = s / 100 * 60 + s % 100;\n            s += w * 86400;\n            names.push_back(n);\n            starts.push_back(s);\n            // cout << i << \": \" << s << endl;\n            int t = to_id.size();\n            to_id[n] = t;\n        }\n        cin >> P;\n        rep(i, P) {\n            string n;\n            cin >> n;\n            favs.push_back(n);\n        }\n        solve();\n        favs.clear();\n        starts.clear();\n        to_id.clear();\n        names.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nvector<P> anime;\nvector<P> fav;\n\nbool Overlap(int x,int y) {\n\tint _max=max(x,y),_min=min(x,y);\n\treturn (_max-_min)<30||(_max-_min-1440*7)>-30;\n}\n\nbool Check(P& p) {\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(p.second!=fav[i].second&&Overlap(p.first,fav[i].first)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tstart=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(start,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(anime[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<p&&ok;i++) {\n\t\t\tfor(int j=0;j<p&&ok;j++) {\n\t\t\t\tif(i!=j&&Overlap(fav[i].first,fav[j].first)) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {cout<<-1<<endl;continue;}\n\t\tanime.erase(remove_if(anime.begin(),anime.end(),Check),anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<vst.size()&&ok;j++) {\n\t\t\t\tif(Overlap(anime[i].first,vst[j])) ok=false;\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcount++;\n\t\t\t\tvst.push_back(anime[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<map>\nusing namespace std;\n\nint N,P;\n\nconst int TIME = 30;\n\nstruct T{\n  int day,s;\n  string name;\n  bool f;\n  T(){f = false;};\n  bool operator < (const T&t)const{\n    if(day == t.day)return s < t.s;\n    return day < t.day;\n  }\n};\n\nvector<T>vec;\nvector<pair<int,pair<int,int> > >vec2;\nset<string>st;\n\nvoid init(){\n  vec.clear();\n  st.clear();\n  vec2.clear();\n}\n\nvoid input(){\n  for(int i = 0 ; i < N ; i++){\n    T t;\n    cin >> t.name >> t.day;\n    string tmp,h,m;\n    cin >> tmp;\n    for(int j = 0 ; j < tmp.size() ; j++){\n      if(j < 2)m += tmp[tmp.size()-1-j];\n      else h += tmp[tmp.size()-1-j];\n    }\n    reverse(m.begin(),m.end());\n    reverse(h.begin(),h.end());\n    t.s = atoi(m.c_str()) + atoi(h.c_str())*60;\n    vec.push_back(t);\n  }\n  cin >> P;\n  for(int i = 0 ; i < P ; i++){\n    string str; cin >> str;\n    st.insert(str);\n  }\n}\n\nbool check(int day,int s,int e,int id){\n  for(int i = 0 ; i < vec2.size() ; i++){\n    if(id == i)continue;\n    if(day != vec2[i].first)continue;\n    pair<int,int> p = vec2[i].second;\n    if(p.first <= s && s < p.second)return true;\n    if(p.first < e && e <= p.second)return true;\n    if(s == p.first && p.second == e)return true;\n  }\n  return false;\n}\n\nint solve(){\n  init();\n  input();\n  sort(vec.begin(),vec.end());\n\n  /*\n  for(int i = 0 ; i < vec.size() ; i++){\n    cout << \"name = \" << vec[i].name << ' ' << vec[i].day << ' ' << vec[i].s << ' ' << vec[i].s + TIME << endl;\n  }\n  */\n\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(st.count(vec[i].name)){\n      vec2.push_back(make_pair(vec[i].day,make_pair(vec[i].s,vec[i].s + TIME)));\n      vec[i].f = true;\n    }\n  }\n\n  for(int i = 0 ; i < vec2.size() ; i++){\n    if(check(vec2[i].first,vec2[i].second.first,vec2[i].second.second,i))return -1;\n  }\n\n  int ret,day,now,pre;\n  ret = day = now = 0;\n  pre = -1;\n\n  for(int i = 0 ; i < vec.size() ; i++){\n\n    //cout << \"i = \" << i << \" pre = \" << pre << \" day = \"  << day << \" now = \" << now  << \" ret = \" << ret << endl;\n\n    if(vec[i].f)continue;\n    //cout << \"#1\" << endl;\n    if(pre != vec[i].day){\n      pre = vec[i].day;\n      now = 0;\n    }\n    //cout << \"#2\" << endl;\n    if(now > vec[i].s)continue;\n    //cout << \"#3\" << endl;\n    if(!check(vec[i].day,vec[i].s,vec[i].s + TIME,-1)){\n      //cout << \"name = \" << vec[i].name << endl;\n      ret++;\n      now = vec[i].s + TIME;\n    }\n    //cout << \"#4\" << endl;\n  }\n  return ret + vec2.size();\n}\n\nint main(){\n  while(cin >> N,N)cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\n#define DIFF(X,Y) (abs((X)%(1440*7)-(Y)%(1440*7)))\n\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\tifstream cin(\"input.txt\");\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size()-1;i++) {\n\t\t\tfor(int j=i+1;j<fav.size();j++) {\n\t\t\t\tif(DIFF(fav[i].first,fav[j].first)<30) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(DIFF(anime[i].first,anime[j].first)>=30) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&DIFF(fav[i].first,p.first)<30) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int f = 0, res = 0;\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*100000)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      f = true;\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tf = false;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(PRO[k].S > m[FAV]-30 && PRO[k].S < m[FAV]+30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tif(f) res -= 1000;\n\tbreak;\n      }\n      map<string, int>::iterator it = m.begin();\n      while(it != m.end()){\n\tif(FAV != it->first && abs(m[FAV]-it->second) < 30) f = 1;\n\tit++;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int tail = 0; \n    rep(i, PRO.size()){\n      if(tail <= PRO[i].S){\n\tres++;\n\ttail = PRO[i].S + 30;\n      }\n    }\n    if(f) puts(\"-1\"); else printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    char tmp[32];\n    \n    while (scanf(\"%d\", &n) && n){\n        map<string, int> conv;\n        bool ng[24 * 60 * 7] = {0};\n        \n        for (int i = 0; i < n; i++){\n            int w, t;\n            \n            scanf(\"%s %d %d\", tmp, &w, &t);\n            conv[(string)tmp] = w * 24 * 60 + (t / 100 - 6) * 60 + t % 100;\n        }\n        \n        int m;\n        scanf(\"%d\",  &m);\n        bool able = true;\n        for (int i = 0; i < m; i++){\n            scanf(\"%s\", tmp);\n            \n            for (int s = conv[(string)tmp], t = 0; t < 30; t++){\n                if (ng[s + t]){\n                    able = false;\n                    break;\n                }\n                ng[s + t] = true;\n            }\n        }\n        \n        vector<pair<int, int> > v;\n        for (auto it = conv.begin(); it != conv.end();){\n            if (ng[it->second] || ng[it->second + 29]){\n                auto tmp = it++;\n                conv.erase(tmp);\n            }\n            else {\n                v.push_back(make_pair(it->second + 29, it->second));\n                it++;\n            }\n        }\n        \n        sort(v.begin(), v.end());\n        int prev = -1000, cnt = 0;\n        for (int i = 0; i < v.size(); i++){\n            if (v[i].second > prev){\n                prev = v[i].first;\n                cnt++;\n            }\n        }\n        \n        printf(\"%d\\n\", able ? m + cnt : -1);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint main(void){\n  int n;\n  while(cin>>n,n){\n    map<string,pair<int,int> > S;\n    for(int i=0;i<n;++i){\n      string s;cin>>s;\n      int weekday,start;\n      cin>>weekday>>start;\n      if(start>=2400){\n        weekday=(weekday+1)%7;\n        start%=2400;\n      }\n      S[s]=make_pair(weekday,start);\n    }\n    int p;cin>>p;\n    set<string> F;\n    for(int i=0;i<p;++i){\n      string s;cin>>s;\n      F.insert(s);\n    }\n    vector<int> A(60*24*7);\n    int ans=F.size();\n    for(set<string>::iterator it=F.begin();it!=F.end();++it){\n      int w = S[*it].first;\n      int t = S[*it].second;\n      int tt = t/100*60+t%100;\n      for(int i=0;i<30;++i){\n        ++A[(60*24*w+tt+i)%(60*24*7)];\n        if(A[(60*24*w+tt+i)%(60*24*7)]>1) ans=-1;\n      }\n    }\n    if(ans>=0){\n\t    map<int,int> nF;\n\t    int i=0,mx=ans;\n\t    for(map<string,pair<int,int> >::iterator it=S.begin();it!=S.end();++it){\n\t      int w = (*it).second.first;\n\t      int t = (*it).second.second;\n\t      int tt = t/100*60+t%100;\n\t      nF[i++]=w*24*60+tt;\n\t    }\n\t    //cerr<<\"#\"<<nF.size()<<endl;\n    \tfor(int i=0;i<nF.size();++i){\n    \t\tint cnt=0;\n    \t\tfor(int j=i;j<i+nF.size();++j){\n    \t\t\tint strt = nF[j%nF.size()];\n\t    \t\tbool f=false;\n\t    \t\t//cerr<<\"##\"<<*it<<endl;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\tif(A[k%(24*60*7)]>0) f=true;\n\t    \t\t}\n\t    \t\tif(f)continue;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\t++A[k%(24*60*7)];\n\t    \t\t}\n\t    \t\t++cnt;\n    \t\t}\n    \t\tif(ans+cnt>mx)mx=ans+cnt;\n    \t}\n    \tans=mx;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tmap<string, pii> programs;\n\t\tset<pii> times;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tstring name;\n\t\t\tpii t;\n\t\t\tcin >> name >> t.first >> t.second;\n\t\t\tif(t.second % 100 >= 60){ t.second = 59; }\n\t\t\tprograms.insert(make_pair(name, t));\n\t\t\ttimes.insert(t);\n\t\t}\n\t\tint M;\n\t\tcin >> M;\n\t\tmultiset<pii> favs;\n\t\tfor(int i = 0; i < M; ++i){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tfavs.insert(programs[name]);\n\t\t}\n\t\tbool invalid = false;\n\t\tpii prev(0, 0);\n\t\tfor(multiset<pii>::iterator it = favs.begin(); it != favs.end(); ++it){\n\t\t\tprev.second += 30;\n\t\t\tif(prev.second % 100 >= 60){ prev.second += 100 - 60; }\n\t\t\tif(*it < prev){ invalid = true; break; }\n\t\t\tprev = *it;\n\t\t}\n\t\tif(invalid){\n\t\t\tcout << \"-1\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint answer = 0;\n\t\tpii curTime(0, 600);\n\t\tset<pii>::iterator it;\n\t\twhile((it = times.lower_bound(curTime)) != times.end()){\n\t\t\t++answer;\n\t\t\tcurTime = *it;\n\t\t\tmultiset<pii>::iterator jt = favs.lower_bound(curTime);\n\t\t\tcurTime.second += 30;\n\t\t\tif(curTime.second % 100 >= 60){ curTime.second += 100 - 60; }\n\t\t\tif(jt != favs.end() && *jt < curTime){\n\t\t\t\tcurTime = *jt;\n\t\t\t\tcurTime.second += 30;\n\t\t\t\tif(curTime.second % 100 >= 60){ curTime.second += 100 - 60; }\n\t\t\t}\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *       Author:  8mao\n * Created Time:  2014/3/16 13:31:26\n *    File Name:  1331.cpp\n */\n# include<map>\n# include<set>\n# include<cmath>\n# include<queue>\n# include<stack>\n# include<vector>\n# include<string>\n# include<cstdio>\n# include<cstring>\n# include<iostream>\n# include<algorithm>\n# include<functional>\nusing namespace std;\n\ntypedef pair<int,int> PII;\n# define INF 1<<30\n# define LL long long\n# define MOD 1000000007\n# define VI vector<int>\n# define VLL vector<LL>\n# define VS vector<string>\n# define PII pair<int,int>\n\n# define F first\n# define S second\n# define mp make_pair\n# define pb push_back\n# define lb lower_bound\n# define up upper_bound\n# define lowbit(x)(x&-x)\n# define lson l,m,rt<<1\n# define rson m+1,r,rt<<1|1\n# define clr(x) (x).clear()\n# define sz(x) ((int)(x).size())\n# define all(x) (x).begin(),(x).end()\n# define mem(x,y) memset(x,y,sizeof(x))\n# define forall(it,c) for(typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\n# define N 505\n# define M 20005\nPII a[N];\nint dp[N][M], n;\n\nstruct node\n{\n    char s[50];\n    int t, must, del;\n}e[N];\n\nint calc(int week, int time)\n{\n    int ans = week * 24 * 60;\n    ans += time % 100 + (time / 100 * 60);\n    return ans;\n}\n\nint dfs(int pos, int end)\n{\n    int ans = 0;\n    //printf (\"%d %d:\", pos, end);\n    if (pos == n + 1)\n        return 0;\n    if (dp[pos][end] != -1)\n        return dp[pos][end];\n    if (a[pos].S || a[pos].F >= end) //must  譛牙庄閭ス莨壼?髞?        ans = max (ans, 1 + dfs(pos + 1, a[pos].F + 30));\n    ans = max (ans, dfs(pos + 1, end));\n    //printf (\"%d\\n\", ans);\n    //printf (\"%d %d : %d\\n\", pos, end, dp[pos][end]);\n    return dp[pos][end] = ans;\n}\n\nint Jireh(int m)\n{\n    int i,  j;\n    for (i = 1; i <= m; i++)\n         if (e[i].must)\n             for (j = 1; j <= m; j++)\n                 if (j != i && abs(e[j].t - e[i].t) < 30)  //豕ィ諢冗せ,譛牙庄閭ス莨壼?髞?                    e[j].del = 1;\n    for (i = 1; i <= m; i++)\n         if (e[i].must && e[i].del)\n            return 0;\n    n = 0;\n    for (i = 1; i <= m; i++)\n         if (!e[i].del)\n        {\n            ++n;\n            a[n].F = e[i].t;\n            a[n].S = e[i].must;\n        }\n    //printf (\"n = %d\\n\", n);\n    //for (i = 1; i <= n; i++)\n        //printf (\"%d %d\\n\", a[i].F, a[i].S);\n    //printf (\"\\n\");\n    return 1;\n}\n\nint cmp(const node &a, const node &b)\n{\n    return a.t < b.t;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int i, j, n, m, x, y;\n    char s[50];\n    while (scanf (\"%d\", &n) != EOF && n)\n    {\n        mem (dp, -1);\n        for (i = 1; i <= n; i++)\n        {\n            scanf (\"%s\", e[i].s);\n            scanf (\"%d %d\", &x, &y);\n            e[i].t = calc(x, y);\n            e[i].must = e[i].del = 0;\n        }\n        scanf (\"%d\", &m);\n        for (i = 1; i <= m; i++)\n        {\n            scanf (\"%s\", s);\n            for (j = 1; j <= n; j++)\n                if (strcmp(e[j].s, s) == 0)\n                {\n                    e[j].must = 1;\n                    break;\n                }\n        }\n        sort (e + 1, e + n + 1, cmp);\n        if (!Jireh(n))\n        {\n            printf (\"-1\\n\");\n            continue;\n        }\n        int ans = dfs(1, 0);\n        printf (\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef map<string,int>M;\nint main()\n{\n\tint n,d,t,r,i,j;\n\tchar s[99];\n\tM m;\n\tM::iterator ite;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tm.clear();\n\t\tint f[12345]={};\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%s%d%d\",s,&d,&t);\n\t\t\tt=t%100+(t-600)/100*60+d*1440;\n\t\t\tm[s]=t;\n\t\t}\n\t\tscanf(\"%d\",&n);\n\t\tfor(r=n;n--;)\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tt=(ite=m.find(s))->second;\n\t\t\tfor(i=0;i<30;++i)\n\t\t\t\tif(f[t+i]++)r=-1;\n\t\t\tm.erase(ite);\n\t\t}\n\t\tif(r>=0)\n\t\t{\n\t\t\tvector<int>v;\n\t\t\tfor(ite=m.begin();ite!=m.end();++ite)v.push_back(ite->second);\n\t\t\tsort(v.begin(),v.end());\n\t\t\tfor(i=0;i<v.size();++i)\n\t\t\t{\n\t\t\t\tif(!f[v[i]]&&!f[v[i]+29])\n\t\t\t\t{\n\t\t\t\t\t++r;\n\t\t\t\t\tfor(j=0;j<30;++j)f[v[i]+j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N;\n\nint tominutes(int w, int s){\n  int h = s/100;\n  int m = s%100;\n  if(h >= 24){\n    h -= 24;\n    w++;\n  }\n  return h*60+m+w*60*24;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    map<string, int>fm;\n    vi fv, tv;\n    int weekday, start;\n    char name[64];\n    rep(i, N){\n      scanf(\"%s%d%d\", name, &weekday, &start);\n      int t = tominutes(weekday, start);\n      fm[string(name)] = t;\n      tv.PB(t);\n    }\n\n    int P;\n    scanf(\"%d\", &P);\n    rep(i, P){\n      scanf(\"%s\", name);\n      fv.PB(fm[string(name)]);\n    }\n    int flag = 0;\n    sort(fv.begin(), fv.end());\n    REP(i, 1, fv.size()){\n      if(fv[i] - fv[i-1] < 30) flag = 1;\n    }\n\n\n    sort(tv.begin(), tv.end());\n    rep(i, tv.size()) rep(j, fv.size()){\n      if(abs(tv[i]-fv[j]) < 30){\n\ttv.erase(tv.begin()+i);\n\ti--;\n\tbreak;\n      }\n    }\n\n    int res = tv.size();\n    int time = 0;\n    rep(i, tv.size()){\n      if(tv[i] - time < 30){\n\tres--;\n      }else{\n\ttime = tv[i];\n      }\n    }\n\n    printf(\"%d\\n\", flag?-1:P+res);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[last].minutes - table[first].minutes >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].minutes - table[n-2].minutes >= 30){\n          count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n\ntypedef pair<int, string> pis;\n\nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty())\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            if(start == m.end())\n              start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          multimap<int, string>::iterator ite2;\n          ite2 = ite;\n          ite2++;\n          if(ite2 == m.end()){\n            cout << \"-1\" << endl;\n            return 0;\n          }\n        }\n      }\n      while(!m.empty()){\n        multimap<int, string>::iterator start;\n        multimap<int, string>::iterator end;\n        start = m.begin();\n        end = m.lower_bound(start->first + 30);\n        m.erase(start, end);\n        ans++;\n      }\n      cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<map>\nusing namespace std;\nstring tt;\nmap<string, int> idx;\nint dp[555], n;\nbool b[555];\nstring name[555];\nstruct node {\n\tint da, f;\n\tint ind;\n}s[555];\nbool cmp(node a, node b) {\n\tif(a.da != b.da) return a.da < b.da;\n\treturn a.f < b.f;\n}\nint gao() {\n\tint len = tt.length();\n\tif(len != 3 && len != 4) while(1);\n\tif(len == 3) {\n\t\ttt = \"0\" + tt;\n\t}\n\tint h = tt[0] * 10 + tt[1];\n\th -= 6;\n\tint mi = tt[2] * 10 + tt[3];\n\treturn h * 60 + mi;\n}\nint DP() {\n\tfill(dp, dp + 520, -1);\n\ts[0].da = -100;\n\tdp[0] = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i - 1; j >= 0; j--) {\n\t\t\tif(s[j].da < s[i].da || s[i].f - s[j].f >= 30) {\n\t\t\t\tif(dp[j] == -1) continue;\n\t\t\t\tdp[i] = max(dp[j] + 1, dp[i]);\n\t\t\t}\n\t\t\tif(b[s[j].ind]) break;\n\t\t}\n\t\tif(b[s[i].ind] && dp[i] == -1) return -1;\n\t}\n\tint ans = 0;\n\tfor(int i = n; i >= 1; i--) {\n\t\tans = max(ans, dp[i]);\n\t\tif(b[s[i].ind]) break;\n\t}\n\treturn ans;\n}\nint main() {\n\twhile(cin >> n) {\n\t\tif(n == 0) break;\n\t\tidx.clear();\n\t\tmemset(b, 0, sizeof(b));\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tcin >> name[i] >> s[i].da >> tt;\n\t\t\tidx[name[i]] = i;\n\t\t\ts[i].f = gao();\n\t\t\ts[i].ind = i;\n\t\t}\n\t\tsort(s + 1, s + 1 + n, cmp);\n\t\tmemset(b, false, sizeof(b));\n\t\tint q; cin >> q;\n\t\twhile(q--) {\n\t\t\tcin >> tt;\n\t\t\tb[idx[tt]] = true;\n\t\t}\n\t\tprintf(\"%d\\n\", DP());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    if(start >= 2400){\n      weekday++;\n      start -= 2400;\n      /*if(weekday == 7){\n        weekday = 0;\n      }*/\n    }\n    favorite = false;\n  }\n\n  int minutes(){\n    int tmp = start / 100;\n    return (tmp * 60) + start - (tmp * 100);\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  if(a1.weekday == a2.weekday){\n    return a1.start < a2.start;\n  }\n  return a1.weekday < a2.weekday;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(table[first].weekday == table[last].weekday){\n\n            if(table[last].minutes() - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          else{\n            if((table[last].minutes()+2400) - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(table[n-1].weekday == table[n-2].weekday){\n        if(table[n-1].minutes() - table[n-2].minutes() >= 30){\n          count++;\n        }\n      }\n      else{\n        if((table[n-2].minutes()+2400) - table[n-1].minutes() >= 30){\n          count++;\n        }\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint toTime(int start, int& w){\n    int m = start%100;\n    int h = start/100;\n    if( h >= 24 ){\n        h -= 24;\n        w++;\n    }\n    return ( m + h*60 + w*60*24 ) ;\n}\n\nint main(){\n    int n,p,w,start;\n    string name;\n\t\n    while( cin >> n , n ){\n        map<string,int> f;\n        vector<int> favTime, Time;\n        int ans = 0;\n        bool flag = true;\n\n        for(int i=0 ; i<n ; i++ ){\n            cin >> name >> w >> start;\n            int t = toTime( start , w ) + 30;\n            f[name] = t;\n            Time.push_back( t );\n        }\n\t\t\n        cin >> p;\n        for(int i=0 ; i<p ; i++ ){\n            cin >> name;\n            favTime.push_back( f[name] );\n        }\n\n        sort( favTime.begin() , favTime.end() );\n        for(int i=1 ; i < (int)favTime.size() ; i++ ){\n            if( favTime[i] - favTime[i-1] < 30 ){\n                flag = false;\n            }\n        }\n\n        sort( Time.begin() , Time.end() );\n        for(int i=0 ; i < (int)Time.size() ; i++ ){\n            bool flag_ = true;\n            for(int k=0 ; k < (int)favTime.size() ; k++ ){\n                if( max(favTime[k],Time[i]) - min(favTime[k],Time[i]) < 30 ){\n                     flag_ = false;\n                }\n            }\n            if( flag_ ){\n                ans++;\n                favTime.push_back( Time[i] );\n            }\n        }\n        cout << ((flag)? (ans+p) : -1 ) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(weekday != arg.weekday){\n\t\t\treturn weekday < arg.weekday;\n\t\t}else{\n\t\t\treturn start < arg.start;\n\t\t}\n\t}\n\tint weekday,start,end;\n\tchar name[33];\n};\n\nint N;\nInfo info[500];\nbool check[7][1440];\nbool used[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint translate_TIME(char buf[5]){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tint hour,minute;\n\n\tif(length == 3){\n\t\thour = buf[0]-'0';\n\t\tminute = 10*(buf[1]-'0')+(buf[2]-'0');\n\t}else{\n\t\thour = 10*(buf[0]-'0')+(buf[1]-'0');\n\t\tminute = 10*(buf[2]-'0')+(buf[3]-'0');\n\t}\n\thour -= 6;\n\treturn 60*hour+minute;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int k = 0; k < 1440; k++)check[i][k] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tchar start[5];\n\tint tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s\",info[i].name,&info[i].weekday,start);\n\n\t\ttmp = translate_TIME(start);\n\n\t\tinfo[i].start = tmp;\n\t\tinfo[i].end = tmp+29;\n\t}\n\n\tsort(info,info+N);\n\n\tvector<int> MUST;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tchar tmp_name[33];\n\n\tfor(int loop = 0; loop < P; loop++){\n\t\tscanf(\"%s\",tmp_name);\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(strCmp(info[i].name,tmp_name)){\n\t\t\t\tMUST.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < P-1; i++){\n\t\tfor(int k = i+1; k < P; k++){\n\t\t\tif(info[MUST[i]].start > info[MUST[k]].end || info[MUST[i]].end < info[MUST[k]].start){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!FLG){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tused[MUST[i]] = true;\n\t\tfor(int k = info[MUST[i]].start; k <= info[MUST[i]].end; k++){\n\t\t\tcheck[info[MUST[i]].weekday][k] = true;\n\t\t}\n\t}\n\n\tvector<int> V;\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\t\t\tV.push_back(i);\n\t\t}\n\t}\n\n\tint ans = P;\n\tint right,V_index = 0;\n\tbool Found;\n\n\tfor(int w_day = 0; w_day < 7; w_day++){\n\t\tfor(int time = 0; time < 1440;){\n\t\t\tif(check[w_day][time]){\n\t\t\t\ttime++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(right = time; right+1 < 1440 && check[w_day][right+1] == false; right++);\n\n\t\t\tif(right-time+1 < 30){\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start <= right)){\n\t\t\t\t\t\t V_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime = right+1;\n\t\t\t}else{\n\n\t\t\t\tFound = false;\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start < time)){\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t}else if(info[V[V_index]].weekday == w_day && info[V[V_index]].start >= time && info[V[V_index]].end <= right){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ttime = info[V[V_index]].end+1;\n\t\t\t\t\t\tFound = true;\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Found){\n\t\t\t\t\ttime = right+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int f = 0;\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*100000)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(abs(PRO[k].S-m[FAV]) < 30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tbreak;\n      }\n      map<string, int>::iterator it = m.begin();\n      while(it != m.end()){\n\tif(FAV != it->first && abs(m[FAV]-it->second) < 30) f = 1;\n\tit++;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int tail = 0, res = 0; \n    rep(i, PRO.size()){\n      if(tail <= PRO[i].S){\n\tres++;\n\ttail = PRO[i].S + 30;\n      }\n    }\n    if(f) puts(\"-1\"); else printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main(void){\n  int n;\n  while(cin>>n,n){\n    map<string,pair<int,int> > S;\n    for(int i=0;i<n;++i){\n      string s;cin>>s;\n      int weekday,start;\n      cin>>weekday>>start;\n      if(start>=2400){\n        weekday=(weekday+1)%7;\n        start%=2400;\n      }\n      S[s]=make_pair(weekday,start);\n    }\n    int p;cin>>p;\n    set<string> F;\n    for(int i=0;i<p;++i){\n      string s;cin>>s;\n      F.insert(s);\n    }\n    vector<int> A(60*24*7);\n    int ans=F.size();\n    for(set<string>::iterator it=F.begin();it!=F.end();++it){\n      int w = S[*it].first;\n      int t = S[*it].second;\n      int tt = t/100*60+t%100;\n      for(int i=0;i<30;++i){\n        ++A[(60*24*w+tt+i)%(60*24*7)];\n        if(A[(60*24*w+tt+i)%(60*24*7)]>1) ans=-1;\n      }\n    }\n    if(ans>=0){\n\t    vector<int> nF;\n\t    int i=0,mx=ans;\n\t    for(map<string,pair<int,int> >::iterator it=S.begin();it!=S.end();++it){\n\t      int w = (*it).second.first;\n\t      int t = (*it).second.second;\n\t      int tt = t/100*60+t%100;\n\t      nF.push_back(w*24*60+tt);\n\t    }\n\t    sort(nF.begin(),nF.end());\n\t    //cerr<<\"#\"<<nF.size()<<endl;\n    \tfor(int i=0;i<nF.size();++i){\n    \t\tint cnt=0;\n    \t\tfor(int j=i;j<i+nF.size();++j){\n    \t\t\tint strt = nF[j%nF.size()];\n\t    \t\tbool f=false;\n\t    \t\t//cerr<<\"##\"<<*it<<endl;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\tif(A[k%(24*60*7)]>0) f=true;\n\t    \t\t}\n\t    \t\tif(f)continue;\n\t    \t\tfor(int k=strt;k<strt+30;++k){\n\t    \t\t\t++A[k%(24*60*7)];\n\t    \t\t}\n\t    \t\t++cnt;\n    \t\t}\n    \t\tif(ans+cnt>mx)mx=ans+cnt;\n    \t}\n    \tans=mx;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint main(void){\n  int n;\n  while(cin>>n,n){\n    map<string,pair<int,int> > S;\n    for(int i=0;i<n;++i){\n      string s;cin>>s;\n      int weekday,start;\n      cin>>weekday>>start;\n      if(start>=2400){\n        weekday=(weekday+1)%7;\n        start%=2400;\n      }\n      S[s]=make_pair(weekday,start);\n    }\n    int p;cin>>p;\n    set<string> F;\n    for(int i=0;i<p;++i){\n      string s;cin>>s;\n      F.insert(s);\n    }\n    vector<int> A(60*24*7);\n    int ans=F.size();\n    for(set<string>::iterator it=F.begin();it!=F.end();++it){\n      int w = S[*it].first;\n      int t = S[*it].second;\n      int tt = t/100*60+t%100;\n      for(int i=0;i<30;++i){\n        ++A[(60*24*w+tt+i)%(60*24*7)];\n        if(A[(60*24*w+tt+i)%(60*24*7)]>1) ans=-1;\n      }\n    }\n    if(ans>=0){\n\t    set<int> nF;\n\t    for(map<string,pair<int,int> >::iterator it=S.begin();it!=S.end();++it){\n\t      int w = (*it).second.first;\n\t      int t = (*it).second.second;\n\t      int tt = t/100*60+t%100;\n\t      nF.insert(w*24*60+tt);\n\t    }\n\t    //cerr<<\"#\"<<nF.size()<<endl;\n    \tfor(set<int>::iterator it=nF.begin();it!=nF.end();++it){\n    \t\tbool f=false;\n    \t\t//cerr<<\"##\"<<*it<<endl;\n    \t\tfor(int i=*it;i<*it+30;++i){\n    \t\t\tif(A[i%(24*60*7)]>0) f=true;\n    \t\t}\n    \t\tif(f)continue;\n    \t\tfor(int i=*it;i<*it+30;++i){\n    \t\t\t++A[i%(24*60*7)];\n    \t\t}\n    \t\t++ans;\n    \t}\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 500;\n\nclass P{\npublic:\n  string name;\n  int wd, st;\n  P(){}\n  P(string name, int wd, int st) : name(name), wd(wd), st(st) {}\n  bool operator < (const P& s) const {\n    if(wd == s.wd) return st < s.st;\n    return wd < s.wd;\n  }\n};\n\nint n, m;\nvector<P> data;\nvector<int> f;\nbool used[N];\n\nint solve(){\n  fill(used, used+n, false);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      if(!used[j]) continue;\n      if(data[f[i]].wd != data[j].wd) continue;\n      if(data[f[i]].st <= data[j].st && data[j].st < data[f[i]].st + 30 ||\n        data[j].st <= data[f[i]].st && data[f[i]].st < data[j].st + 30) return -1;\n    }\n    used[f[i]] = true;\n  }\n  int res = m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(!used[j]) continue;\n      if(data[i].wd != data[j].wd) continue;\n      if(data[i].st <= data[j].st && data[j].st < data[i].st + 30 ||\n        data[j].st <= data[i].st && data[i].st < data[j].st + 30) goto FAILED;\n    }\n    res++;\n    used[i] = true;\n    FAILED:;\n  }\n  /*for(int i=0;i<n;i++){\n    cout << data[i].name << ' ' << data[i].wd << ' ' << data[i].st;\n    if(used[i]) cout << \" o\" << endl;\n    else cout << \" x\" << endl;\n  }\n  cout << \"================\" << endl;*/\n  return res;\n}\n\nmain(){\n  while(cin >> n && n){\n    data.clear();\n    f.clear();\n    for(int i=0;i<n;i++){\n      string name, time;\n      int wd, st;\n      cin >> name >> wd >> time;\n      st = atoi(time.substr(0, (int)time.size()-2).c_str()) * 60 + atoi(time.substr((int)time.size()-2).c_str());\n      data.push_back(P(name, wd, st));\n    }\n    sort(data.begin(), data.end());\n    cin >> m;\n    for(int i=0;i<m;i++){\n      string in;\n      cin >> in;\n      for(int j=0;j<n;j++) if(data[j].name == in) f.push_back(j);\n    }\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nvector<P> anime;\nvector<P> fav;\n\nbool Overlap(int x,int y) {\n\tint _max=max(x,y),_min=min(x,y);\n\treturn (_max-_min)<30;\n}\n\nbool Check(P& p) {\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(p.second!=fav[i].second&&Overlap(p.first,fav[i].first)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tstart=weekday*1440+start/100*60+start%100;\n\t\t\tif(start<530) start+=1440*7;\n\t\t\tanime.push_back(P(start,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(anime[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<p&&ok;i++) {\n\t\t\tfor(int j=0;j<p&&ok;j++) {\n\t\t\t\tif(i!=j&&Overlap(fav[i].first,fav[j].first)) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {cout<<-1<<endl;continue;}\n\t\tanime.erase(remove_if(anime.begin(),anime.end(),Check),anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<vst.size()&&ok;j++) {\n\t\t\t\tif(Overlap(anime[i].first,vst[j])) ok=false;\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcount++;\n\t\t\t\tvst.push_back(anime[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tfor(int n;cin>>n && n;){\n\t\tmap<string,int> ps;\n\t\tvector<int> ts(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s; int w,t; cin>>s>>w>>t;\n\t\t\tps[s]=i;\n\t\t\tts[i]=(w*1440+t/100*60+t%100)%10080;\n\t\t}\n\t\tint m; cin>>m;\n\t\tvector<int> fs(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tfs[ps[s]]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tts.push_back(ts[i]+10080);\n\t\tvector<int> is(n*2);\n\t\tiota(begin(is),end(is),0);\n\t\tsort(begin(is),end(is),[&](int i,int j){return ts[i]<ts[j];});\n\t\t\n\t\tint res=-1;\n\t\tfor(int l=0,r=10080;l<30;l++,r++){\n\t\t\tvector<int> dp(r+1);\n\t\t\tint p=0;\n\t\t\tfor(int i:is) if(l<=ts[i] && ts[i]+30<=r){\n\t\t\t\tint t=ts[i];\n\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+(fs[i]?1000:1));\n\t\t\t}\n\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\tif(dp[r]/1000==m)\n\t\t\t\tres=max(res,dp[r]/1000+dp[r]%1000);\n\t\t}\n\t\t\n\t\tcout<<res<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint to_minite(int w,int t) {\n    int h=t/100;\n    int m=t%100;\n\n    return (w*1440+h*60+m)%10080;\n}\n\nint N;\nint solve() {\n    map<string,int> animes;\n    vector<pair<int,string>> animes2;\n    map<int,string> range;\n    rep(i,N) {\n        string name;\n        int w,t;\n        cin>>name>>w>>t;\n        int m=to_minite(w,t);\n        //cout<<m<<endl;\n        animes[name]=m;\n        animes2.pb(mp(m+30,name));\n    }\n    int m; cin>>m;\n    set<string> ans;\n    rep(i,m) {\n        string s; cin>>s;\n        int m=animes[s];\n        rep(i,30) {\n            if(range.count(i+m)) return -1;\n            range[i+m]=s;\n        }\n        ans.insert(s);\n    }\n    sort(all(animes2));\n    for(const auto &anime : animes2) {\n        string s=anime.second;\n        int m=animes[s];\n        bool f=true;\n        rep(i,30) f&=!range.count(m+i);\n        if(f) {\n            ans.insert(s);\n            rep(i,30) {\n                range[i+m]=s;\n            }\n        }\n    }\n\n    return ans.size();\n}\nint main() {\n    while(cin>>N) {\n        if(!N) break;\n        cout<<solve()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<pair<int,string> >in(n);\n\t\trep(i,n){\n\t\t\tint a,b;\n\t\t\tcin>>in[i].second>>a>>b;\n\t\t\tint t=a*24*60+(b/100*60+b%100);\n\t\t\tin[i].first=t%(7*24*60);\n\t\t}\n\t\tsort(all(in));\n\t\tint m;cin>>m;\n\t\tvector<pair<int,string> >d(m);\n\t\trep(i,m){\n\t\t\tcin>>d[i].second;\n\t\t\trep(j,n)if(in[j].second==d[i].second)d[i].first=in[j].first;\n\t\t}\n\t\tsort(all(d));\n\t\tif(m>1){\n\t\t\tbool h=true;\n\t\t\trep(i,m)if(abs(d[(i+1)%m].first-d[i].first)<30)h=false;\n\t\t\tif(!h){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tvi dp(n,1);\n\t\trep(i,n)loop(j,i+1,n){\n\t\t\tint s=in[i].first,t=in[j].first;\n\t\t\tif(t-s<30)continue;\n\t\t\tbool h=true,H=false;\n\t\t\trep(k,m)if(in[i].second==d[k].second||in[j].second==d[k].second)H=true;\n\t\t\tif(!H)rep(k,m)if(s<d[k].first+30&&d[k].first<t+30)h=false;\n\t\t\tif(h||H)dp[j]=max(dp[j],dp[i]+1);\n\t\t}\n\t\tint ma=0;\n\t\trep(i,n)loop(j,i+1,n){\n\t\t\tint t=7*24*60-in[j].first+in[i].first;\n\t\t\tif(t<30)continue;\n\t\t\tma=max(ma,dp[j]-dp[i]+1);\n\t\t}\n//\t\trep(i,n)cout<<\" \"<<dp[i];cout<<endl;\n\t\tcout<<ma<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(weekday != arg.weekday){\n\t\t\treturn weekday < arg.weekday;\n\t\t}else{\n\t\t\treturn start < arg.start;\n\t\t}\n\t}\n\tint weekday,start,end;\n\tchar name[33];\n};\n\nint N;\nInfo info[500];\nbool check[7][1440];\nbool used[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint translate_TIME(char buf[5]){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tint hour,minute;\n\n\tif(length == 3){\n\t\thour = buf[0]-'0';\n\t\tminute = 10*(buf[1]-'0')+(buf[2]-'0');\n\t}else{\n\t\thour = 10*(buf[0]-'0')+(buf[1]-'0');\n\t\tminute = 10*(buf[2]-'0')+(buf[3]-'0');\n\t}\n\thour -= 6;\n\treturn 60*hour+minute;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int k = 0; k < 1440; k++)check[i][k] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tchar start[5];\n\tint tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s\",info[i].name,&info[i].weekday,start);\n\n\t\ttmp = translate_TIME(start);\n\n\t\tinfo[i].start = tmp;\n\t\tinfo[i].end = tmp+29;\n\t}\n\n\tsort(info,info+N);\n\n\tvector<int> MUST;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tchar tmp_name[33];\n\n\tfor(int loop = 0; loop < P; loop++){\n\t\tscanf(\"%s\",tmp_name);\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(strCmp(info[i].name,tmp_name)){\n\t\t\t\tMUST.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < P-1; i++){\n\t\tfor(int k = i+1; k < P; k++){\n\t\t\tif((info[MUST[i]].weekday != info[MUST[k]].weekday) || (info[MUST[i]].start > info[MUST[k]].end || info[MUST[i]].end < info[MUST[k]].start)){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!FLG){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tused[MUST[i]] = true;\n\t\tfor(int k = info[MUST[i]].start; k <= info[MUST[i]].end; k++){\n\t\t\tcheck[info[MUST[i]].weekday][k] = true;\n\t\t}\n\t}\n\n\tvector<int> V;\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\t\t\tV.push_back(i);\n\t\t}\n\t}\n\n\tint ans = P;\n\tint right,V_index = 0;\n\tbool Found;\n\n\tif(V.size() == 0){\n\t\tprintf(\"%d\\n\",P);\n\t\treturn;\n\t}\n\n\tfor(int w_day = 0; w_day < 7; w_day++){\n\t\tfor(int time = 0; time < 1440;){\n\n\t\t\tif(V_index == V.size()){\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(check[w_day][time]){\n\t\t\t\ttime++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(right = time; right+1 < 1440 && check[w_day][right+1] == false; right++);\n\n\t\t\tif(right-time+1 < 30){\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start <= right)){\n\t\t\t\t\t\t V_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime = right+1;\n\t\t\t}else{\n\n\t\t\t\tFound = false;\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start < time)){\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t}else if(info[V[V_index]].weekday == w_day && info[V[V_index]].start >= time && info[V[V_index]].end <= right){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ttime = info[V[V_index]].end+1;\n\t\t\t\t\t\tFound = true;\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Found){\n\t\t\t\t\ttime = right+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nint solve(int start){\n  int ai=0,bi=0,now=start,res=0;\n  int as=A.size(),bs=B.size(),cnt=0;\n  while(1){\n    int ag=(ai<as?A[ai].first:1e8);\n    int bg=(bi<bs?B[bi].first:1e8);\n    if(7*60*24+start-30<ag)ag=1e8;\n    if(7*60*24+start-30<bg)bg=1e8;\n    if(ag==1e8&&bg==1e8)break;\n\n    if(ag<now){ai++;continue;}\n    if(bg<now){bi++;continue;}\n    if(ag+30<=bg){\n      res++;\n      now=ag+30;\n      ai++;\n    }else{\n      res++;\n      cnt++;\n      now=bg+30;\n      bi++;\n    }\n  }\n  if(cnt<M)return -1;\n  else return res;\n}\n\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b%(7*60*24),i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n    int ans=0;\n    for(int i=0;i<30;i++)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          ite++;\n          if(ite == m.end())\n            flag = true;\n          ite--;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint n,p;\nstruct data{\n\tstring name;\n\tint h,m;\n\tdata(){}\n\tdata(string s,int hh,int mm){\n\t\tname=s;\n\t\th=hh;\n\t\tm=mm;\n\t}\n};\n\nbool comp(const data& d1,const data& d2){\n\tif(d1.h==d2.h)return d1.m<d2.m;\n\treturn d1.h<d2.h;\n}\n\ndata d[7][501];\nint dcnt[7];\nset<string> fav;\nbool used[7][30][61];\n\nbool check(){\n\tfor(int i=0;i<7;i++){\n\t\tfor(int j=0;j<dcnt[i];j++){\n\t\t\tif(fav.find(d[i][j].name)!=fav.end()){\n\t\t\t\tint k=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\twhile(k<30){\n\t\t\t\t\tif(used[i][nh][nm])return false;\n\t\t\t\t\tused[i][nh][nm]=true;\n\t\t\t\t\tk++;\n\t\t\t\t\tnm++;\n\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\tnh++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(dcnt,0,sizeof(dcnt));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint w,s;\n\t\t\tstring str;\n\t\t\tcin >> str >> w >> s;\n\t\t\td[w][dcnt[w]]=data(str,s/100,s%100);\n\t\t\tdcnt[w]++;\n\t\t}\n\t\tfav.clear();\n\t\tscanf(\"%d\",&p);\n\t\tfor(int i=0;i<p;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfav.insert(str);\n\t\t}\n\t\tmemset(used,false,sizeof(used));\n\t\tif(!check()){\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<7;i++){\n\t\t\tfor(int j=0;j<dcnt[i];j++){\n\t\t\t\tif(fav.find(d[i][j].name)!=fav.end())continue;\n\t\t\t\tint k=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\twhile(k<30){\n\t\t\t\t\tif(used[i][nh][nm])break;\n\t\t\t\t\tk++;\n\t\t\t\t\tnm++;\n\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\tnh++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(k==30){\n\t\t\t\t\tk=0,nh=d[i][j].h,nm=d[i][j].m;\n\t\t\t\t\tcnt++;\n\t\t\t\t\twhile(k<30){\n\t\t\t\t\t\tif(used[i][nh][nm])return false;\n\t\t\t\t\t\tused[i][nh][nm]=true;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tnm++;\n\t\t\t\t\t\tif(nm==60){\n\t\t\t\t\t\t\tnm=0;\n\t\t\t\t\t\t\tnh++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",cnt+p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nint main(){\n\tint n,i,r,last,time,day;\n\tfor(;cin>>n,n;){\n\t\tvector<pair<int,string> >program;\n\t\tset<string>precious;\n\t\tstring s;\n\t\t{\n\t\t\tmap<string,int>m;\n\t\t\tfor(;n--;){\n\t\t\t\tcin>>s>>day>>time;\n\t\t\t\tprogram.push_back(make_pair(day*1440+time/100*60+time%100,s));\n\t\t\t\tm[s]=day*1440+time/100*60+time%100;\n\t\t\t}\n\t\t\tfor(cin>>n;n--;){\n\t\t\t\tcin>>s;\n\t\t\t\tset<string>::iterator it=precious.begin();\n\t\t\t\tfor(;it!=precious.end();it++){\n\t\t\t\t\tif(abs(m[*it]-m[s])<30){puts(\"-1\");goto next;}\n\t\t\t\t}\n\t\t\t\tprecious.insert(s);\n\t\t\t}\n\t\t}\n\t\tsort(program.begin(),program.end());\n\t\tfor(last=r=i=0;i<program.size();i++){\n\t\t\tif(program[i].first>=last){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t\tr++;\n\t\t\t}else if(precious.find(program[i].second)!=precious.end()){\n\t\t\t\tlast=program[i].first+30;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nint solve(int start){\n  int ai=0,bi=0,now=start,res=0;\n  int as=A.size(),bs=B.size();\n  bool used[501]={};\n  used[N]=true;\n  while(ai<as||bi<bs){\n    int ag=(ai<as?A[ai].first:1e9);\n    int aw=(ai<as?A[ai].second:N);\n    int bg=(bi<bs?B[bi].first:1e9);\n    int bw=(bi<bs?B[bi].second:N);\n\n    if(start<(ag+30)-(7*60*240))ag=1e9;\n    if(start<(bg+30)-(7*60*240))bg=1e9;\n\n    if(now<=ag&&ag+30<=bg){\n      now=ag+30;\n      if(!used[aw])res++;\n      used[aw]=true;\n      ai++;\n    }else if(ag<now){\n      ai++;\n    }else{\n      now=bg+30;\n      if(!used[bw])res++;\n      used[bw]=true;\n      bi++;\n    }\n  }\n  return res;\n}\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b,i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n    int ans=0;\n    for(int i=0;i<30;i++)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nvector<P> anime;\nvector<P> fav;\n\nbool Overlap(int x,int y) {\n\tint _max=max(x,y),_min=min(x,y);\n\treturn (_max-_min)<30||(_max-_min-1440*7)>-30;\n}\n\nbool Check(P& p) {\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(p.second!=fav[i].second&&Overlap(p.first,fav[i].first)) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tfstream cin(\"input.txt\");\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\tstart=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(start,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(anime[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<p&&ok;i++) {\n\t\t\tfor(int j=0;j<p&&ok;j++) {\n\t\t\t\tif(i!=j&&Overlap(fav[i].first,fav[j].first)) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(!ok) {cout<<-1<<endl;continue;}\n\t\tanime.erase(remove_if(anime.begin(),anime.end(),Check),anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<vst.size()&&ok;j++) {\n\t\t\t\tif(Overlap(anime[i].first,vst[j])) ok=false;\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tcount++;\n\t\t\t\tvst.push_back(anime[i].first);\n\t\t\t}\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *       Author:  8mao\n * Created Time:  2014/3/16 13:31:26\n *    File Name:  1331.cpp\n */\n# include<map>\n# include<set>\n# include<cmath>\n# include<queue>\n# include<stack>\n# include<vector>\n# include<string>\n# include<cstdio>\n# include<cstring>\n# include<iostream>\n# include<algorithm>\n# include<functional>\nusing namespace std;\n\ntypedef pair<int,int> PII;\n# define INF 1<<30\n# define LL long long\n# define MOD 1000000007\n# define VI vector<int>\n# define VLL vector<LL>\n# define VS vector<string>\n# define PII pair<int,int>\n\n# define F first\n# define S second\n# define mp make_pair\n# define pb push_back\n# define lb lower_bound\n# define up upper_bound\n# define lowbit(x)(x&-x)\n# define lson l,m,rt<<1\n# define rson m+1,r,rt<<1|1\n# define clr(x) (x).clear()\n# define sz(x) ((int)(x).size())\n# define all(x) (x).begin(),(x).end()\n# define mem(x,y) memset(x,y,sizeof(x))\n# define forall(it,c) for(typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\n# define N 505\n# define M 20005\nPII a[N];\nint dp[N][M], n;\n\nstruct node\n{\n    char s[105];\n    int t, must, del;\n}e[N];\n\nint calc(int week, int time)\n{\n    int ans = week * 24 * 60;\n    ans += time % 100 + (time / 100 * 60);\n    return ans;\n}\n\nint dfs(int pos, int end)\n{\n    int ans = 0;\n    //printf (\"%d %d:\", pos, end);\n    if (pos == n + 1)\n        return 0;\n    if (dp[pos][end] != -1)\n        return dp[pos][end];\n    if (a[pos].S || a[pos].F >= end) //must  譛牙庄閭ス莨壼?髞?        ans = max (ans, 1 + dfs(pos + 1, a[pos].F + 30));\n    ans = max (ans, dfs(pos + 1, end));\n    //printf (\"%d\\n\", ans);\n    //printf (\"%d %d : %d\\n\", pos, end, dp[pos][end]);\n    return dp[pos][end] = ans;\n}\n\nint Jireh(int m)\n{\n    int i, j;\n    for (i = 1; i <= m; i++)\n         if (e[i].must)\n             for (j = 1; j <= m; j++)\n                 if (j != i && abs(e[j].t - e[i].t) < 30)  //豕ィ諢冗せ,譛牙庄閭ス莨壼?髞?                    e[j].del = 1;\n    for (i = 1; i <= m; i++)\n         if (e[i].must && e[i].del)\n            return 0;\n    n = 0;\n    for (i = 1; i <= m; i++)\n         if (!e[i].del)\n        {\n            ++n;\n            a[n].F = e[i].t;\n            a[n].S = e[i].must;\n        }\n    sort (a + 1, a + n + 1);\n    //printf (\"n = %d\\n\", n);\n    //for (i = 1; i <= n; i++)\n        //printf (\"%d %d\\n\", a[i].F, a[i].S);\n    //printf (\"\\n\");\n    return 1;\n}\n\nint cmp(const node &a, const node &b)\n{\n    return a.t < b.t;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    int i, j, n, m, x, y;\n    char s[105];\n    while (scanf (\"%d\", &n) != EOF && n)\n    {\n        mem (dp, -1);\n        for (i = 1; i <= n; i++)\n        {\n            scanf (\"%s\", e[i].s);\n            scanf (\"%d %d\", &x, &y);\n            e[i].t = calc(x, y);\n            e[i].must = e[i].del = 0;\n        }\n        scanf (\"%d\", &m);\n        for (i = 1; i <= m; i++)\n        {\n            scanf (\"%s\", s);\n            for (j = 1; j <= n; j++)\n                if (strcmp(e[j].s, s) == 0)\n                {\n                    e[j].must = 1;\n                    break;\n                }\n        }\n        sort (e + 1, e + n + 1, cmp);\n        if (!Jireh(n))\n        {\n            printf (\"-1\\n\");\n            continue;\n        }\n        int ans = dfs(1, 0);\n        printf (\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size()-1;i++) {\n\t\t\tfor(int j=i+1;j<fav.size();j++) {\n\t\t\t\tif(Diff(fav[i].first,fav[j].first)) okay=false;\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tint i=0,count=0;\n\t\twhile(i<anime.size()) {\n\t\t\tcount++;\n\t\t\tint j;\n\t\t\tfor(j=i+1;j<anime.size();j++) {\n\t\t\t\tif(!Diff(anime[i].first,anime[j].first)) break;\n\t\t\t}\n\t\t\ti=j;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    int n;\n    char tmp[32];\n    \n    while (scanf(\"%d\", &n) && n){\n        map<string, int> conv;\n        bool ng[24 * 60 * 7] = {0};\n        \n        for (int i = 0; i < n; i++){\n            int w, t;\n            \n            scanf(\"%s %d %d\", tmp, &w, &t);\n            conv[(string)tmp] = w * 24 * 60 + (t / 100 - 6) * 60 + t % 100;\n        }\n        \n        int m;\n        scanf(\"%d\",  &m);\n        bool able = true;\n        for (int i = 0; i < m; i++){\n            scanf(\"%s\", tmp);\n            \n            for (int s = conv[(string)tmp], t = 0; t < 30; t++){\n                if (ng[s + t]){\n                    able = false;\n                    break;\n                }\n                ng[s + t] = true;\n            }\n        }\n        \n        vector<pair<int, int> > v;\n        for (auto it = conv.begin(); it != conv.end();){\n            if (ng[it->second] || ng[it->second + 29]){\n                auto tmp = it++;\n                conv.erase(tmp);\n            }\n            else {\n                v.push_back(make_pair(it->second + 29, it->second));\n                it++;\n            }\n        }\n        \n        sort(v.begin(), v.end());\n        int prev = -1000, cnt = 0;\n        for (int i = 0; i < v.size(); i++){\n            if (v[i].second > prev){\n                prev = v[i].first;\n                cnt++;\n            }\n        }\n        \n        printf(\"%d\\n\", able ? m + cnt : -1);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Interval{\n\tint a,b;\n\tInterval(){}\n\tInterval(int A,int B):a(A),b(B){}\n\tbool operator<(const Interval &I)const{ return b<I.b; }\n};\n\nconst int M=7*24*60;\n\nbool intersect(const Interval &I,const Interval &J){\n\tfor(int t=I.a+1;t<=I.b-1;t++){\n\t\tif(J.a%M<=t%M && t%M<=J.b%M) return true;\n\t}\n\treturn false;\n}\n\nint solve(int n,Interval *I){\n\tsort(I,I+n);\n\n\tint ans=0;\n\tInterval J[500];\n\trep(i,n){\n\t\tint n2=0,j;\n\t\tfor(j=i+1;j<n;j++) if(!intersect(I[i],I[j])) J[n2++]=I[j];\n\t\tfor(j= 0 ;j<i;j++) if(!intersect(I[i],I[j])) J[n2++]=Interval(I[j].a+M,I[j].b+M);\n\n\t\tint cnt=0,r=-1;\n\t\trep(j,n2){\n\t\t\tif(r<=J[j].a) r=J[j].b, cnt++;\n\t\t}\n\t\tans=max(ans,1+cnt);\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tmap<string,int> f;\n\t\tInterval I[500];\n\t\trep(i,n){\n\t\t\tchar name[33];\n\t\t\tint week,start; scanf(\"%s%d%d\",name,&week,&start);\n\t\t\tf[name]=i;\n\n\t\t\tint h=start/100,m=start%100;\n\t\t\tstart=(week*24*60+h*60+m)%M;\n\t\t\tI[i]=Interval(start,start+30);\n\t\t}\n\n\t\tint nf; scanf(\"%d\",&nf);\n\t\tInterval fav[500];\n\t\trep(i,nf){\n\t\t\tchar name[33]; scanf(\"%s\",name);\n\t\t\tfav[i]=I[f[name]];\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(j,nf) rep(i,j) if(intersect(fav[i],fav[j])) ok=false;\n\t\tif(!ok){ puts(\"-1\"); continue; }\n\n\t\tint n2=0;\n\t\tInterval J[500];\n\t\trep(i,n){\n\t\t\tbool ok=true;\n\t\t\trep(j,nf) if(intersect(I[i],fav[j])) ok=false;\n\t\t\tif(ok) J[n2++]=I[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\",nf+solve(n2,J));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *       Author:  8mao\n * Created Time:  2014/3/16 13:31:26\n *    File Name:  1331.cpp\n */\n# include<map>\n# include<set>\n# include<cmath>\n# include<queue>\n# include<stack>\n# include<vector>\n# include<string>\n# include<cstdio>\n# include<cstring>\n# include<iostream>\n# include<algorithm>\n# include<functional>\nusing namespace std;\n\ntypedef pair<int,int> PII;\n# define INF 1<<30\n# define LL long long\n# define MOD 1000000007\n# define VI vector<int>\n# define VLL vector<LL>\n# define VS vector<string>\n# define PII pair<int,int>\n\n# define F first\n# define S second\n# define mp make_pair\n# define pb push_back\n# define lb lower_bound\n# define up upper_bound\n# define lowbit(x)(x&-x)\n# define lson l,m,rt<<1\n# define rson m+1,r,rt<<1|1\n# define clr(x) (x).clear()\n# define sz(x) ((int)(x).size())\n# define all(x) (x).begin(),(x).end()\n# define mem(x,y) memset(x,y,sizeof(x))\n# define forall(it,c) for(typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\n# define N 505\n# define M 20005\nPII a[N];\nint dp[N][M], n;\n\nstruct node\n{\n    char s[50];\n    int t, must, del;\n}e[N];\n\nint calc(int week, int time)\n{\n    int ans = week * 24 * 60;\n    ans += time % 100 + (time / 100 * 60);\n    return ans;\n}\n\nint dfs(int pos, int end)\n{\n    int ans = 0;\n    if (pos == n + 1)\n        return 0;\n    if (dp[pos][end] != -1)\n        return dp[pos][end];\n    if (a[pos].S || a[pos].F >= end) //must  譛牙庄閭ス莨壼?髞?        ans = max (ans, 1 + dfs(pos + 1, a[pos].F + 30));\n    ans = max (ans, dfs(pos + 1, end));\n    return dp[pos][end] = ans;\n}\n\nint Jireh(int m)\n{\n    int i,  j;\n    for (i = 1; i <= m; i++)\n         if (e[i].must)\n   \t\t{\n             for (j = 1; j <= m; j++)\n                 if (j != i && abs(e[j].t - e[i].t) < 30)  //豕ィ諢冗せ,譛牙庄閭ス莨壼?髞?                    e[j].del = 1;\n        }\n    for (i = 1; i <= m; i++)\n         if (e[i].must && e[i].del)\n            return 0;\n    n = 0;\n    for (i = 1; i <= m; i++)\n         if (!e[i].del)\n        {\n            ++n;\n            a[n].F = e[i].t;\n            a[n].S = e[i].must;\n        }\n    return 1;\n}\n\nint cmp(const node &a, const node &b)\n{\n    return a.t < b.t;\n}\n\nint main()\n{\n    int i, j, n, m, x, y;\n    char s[50];\n    while (scanf (\"%d\", &n) != EOF && n)\n    {\n        mem (dp, -1);\n        for (i = 1; i <= n; i++)\n        {\n            scanf (\"%s\", e[i].s);\n            scanf (\"%d %d\", &x, &y);\n            e[i].t = calc(x, y);\n            e[i].must = e[i].del = 0;\n        }\n        scanf (\"%d\", &m);\n        for (i = 1; i <= m; i++)\n        {\n            scanf (\"%s\", s);\n            for (j = 1; j <= n; j++)\n                if (strcmp(e[j].s, s) == 0)\n                {\n                    e[j].must = 1;\n                    break;\n                }\n        }\n        sort (e + 1, e + n + 1, cmp);\n        if (!Jireh(n))\n        {\n            printf (\"-1\\n\");\n            continue;\n        }\n        int ans = dfs(1, 0);\n        printf (\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXLEN = 7 * 24 * 60;\n\nchar buff[100];\nbool used[MAXLEN];\nbool next[MAXLEN];\n\nmap< string,int > hash;\nvector< pair<string,int> > prog;\nbool cmp(const pair<string,int> &A,const pair<string,int> &B) {\n    return A.second < B.second;\n}\n\nint main() {\n    int N,M;\n    while(scanf(\"%d\",&N) == 1 && N) {\n        hash.clear();\n        prog.clear();\n        memset(used,false,sizeof(used));\n        for(int i = 0 ; i < N ; i++) {\n            string na;\n            int wk,ti,trans;\n            scanf(\"%s%d%d\",buff,&wk,&ti);\n            na = string(buff);\n            trans = (wk * 24 * 60 + (ti / 100) * 60 + (ti % 100)) % MAXLEN;\n            hash[na] = trans;\n            prog.PB(MP(na,trans));\n        }\n        sort(ALL(prog),cmp);\n        scanf(\"%d\",&M);\n        int res = 0;\n        bool can = true;\n        for(int i = 0 ; i < M ; i++) {\n            scanf(\"%s\",buff);\n            //printf(\"%s\\n\",buff);\n            string na = string(buff);\n            int st = hash[na];\n            //printf(\"st %d\\n\",st);\n            for(int tt = 0 ; tt < 30 ; tt++) {\n                if (used[(st + tt) % MAXLEN]) can = false;\n                else {\n                    used[(st + tt) % MAXLEN] = true;\n                }\n            }\n            res++;\n        }\n        int ans = 0;\n        for(int cir = 0 ; cir <= 30 ; cir ++) {\n            int cnt = res;\n            memcpy(next,used,sizeof(used));\n            for(int i = 0 ; i < SZ(prog) ; i++) {\n                int st = prog[i].second;\n                if (st <= cir) continue;\n                //printf(\"st %d\\n\",st);\n                bool push = true;\n                for(int tt = 0 ; tt < 30 ; tt++) {\n                    if (next[(st + tt) % MAXLEN]) push = false;\n                }\n                if (push) {\n                    for(int tt = 0 ; tt < 30 ; tt++) {\n                        next[(st + tt) % MAXLEN] = true;\n                    }\n                    cnt++;\n                }\n            }\n            ans = max(res,cnt);\n        }\n       \n        if (!can) ans = -1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(weekday != arg.weekday){\n\t\t\treturn weekday < arg.weekday;\n\t\t}else{\n\t\t\treturn start < arg.start;\n\t\t}\n\t}\n\tint weekday,start,end;\n\tchar name[33];\n};\n\nint N;\nInfo info[500];\nbool check[7][1440];\nbool used[500];\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nint translate_TIME(char buf[5]){\n\tint length;\n\tfor(length = 0; buf[length] != '\\0'; length++);\n\n\tint hour,minute;\n\n\tif(length == 3){\n\t\thour = buf[0]-'0';\n\t\tminute = 10*(buf[1]-'0')+(buf[2]-'0');\n\t}else{\n\t\thour = 10*(buf[0]-'0')+(buf[1]-'0');\n\t\tminute = 10*(buf[2]-'0')+(buf[3]-'0');\n\t}\n\thour -= 6;\n\treturn 60*hour+minute;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < 7; i++){\n\t\tfor(int k = 0; k < 1440; k++)check[i][k] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tchar start[5];\n\tint tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %s\",info[i].name,&info[i].weekday,start);\n\n\t\ttmp = translate_TIME(start);\n\n\t\tinfo[i].start = tmp;\n\t\tinfo[i].end = tmp+29;\n\t}\n\n\tsort(info,info+N);\n\n\tvector<int> MUST;\n\n\tint P;\n\tscanf(\"%d\",&P);\n\n\tchar tmp_name[33];\n\n\tfor(int loop = 0; loop < P; loop++){\n\t\tscanf(\"%s\",tmp_name);\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(strCmp(info[i].name,tmp_name)){\n\t\t\t\tMUST.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < P-1; i++){\n\t\tfor(int k = i+1; k < P; k++){\n\t\t\tif((info[MUST[i]].weekday != info[MUST[k]].weekday) || (info[MUST[i]].start > info[MUST[k]].end || info[MUST[i]].end < info[MUST[k]].start)){\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(!FLG){\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tused[MUST[i]] = true;\n\t\tfor(int k = info[MUST[i]].start; k <= info[MUST[i]].end; k++){\n\t\t\tcheck[info[MUST[i]].weekday][k] = true;\n\t\t}\n\t}\n\n\tvector<int> V;\n\tfor(int i = 0; i < N; i++){\n\t\tif(used[i] == false){\n\t\t\tV.push_back(i);\n\t\t}\n\t}\n\n\tint ans = P;\n\tint right,V_index = 0;\n\tbool Found;\n\n\tif(V.size() == 0){\n\t\tprintf(\"%d\\n\",P);\n\t\treturn;\n\t}\n\n\tfor(int w_day = 0; w_day < 7; w_day++){\n\t\tfor(int time = 0; time < 1440;){\n\t\t\tif(check[w_day][time]){\n\t\t\t\ttime++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(right = time; right+1 < 1440 && check[w_day][right+1] == false; right++);\n\n\t\t\tif(right-time+1 < 30){\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start <= right)){\n\t\t\t\t\t\t V_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime = right+1;\n\t\t\t}else{\n\n\t\t\t\tFound = false;\n\n\t\t\t\tfor(; V_index < V.size();){\n\t\t\t\t\tif((info[V[V_index]].weekday < w_day) || (info[V[V_index]].weekday == w_day && info[V[V_index]].start < time)){\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t}else if(info[V[V_index]].weekday == w_day && info[V[V_index]].start >= time && info[V[V_index]].end <= right){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\ttime = info[V[V_index]].end+1;\n\t\t\t\t\t\tFound = true;\n\t\t\t\t\t\tV_index++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!Found){\n\t\t\t\t\ttime = right+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\nint d[1000];\nint t[1000];\nint f[1000];\nchar s[64];\npair<int,int> event[1000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int> m;\n\t\tfor(int i=0;i<1000;i++)f[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s%d%d\",s,d+i,t+i);\n\t\t\tt[i]=t[i]%100+t[i]/100*60;\n\t\t\tstring S=s;\n\t\t\tm[S]=i;\n\t\t}\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",s);\n\t\t\tstring S=s;\n\t\t\tf[m[S]]=1;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tevent[i]=make_pair(d[i]*1440+t[i],i);\n\t\t}\n\t\tstd::sort(event,event+a);\n\t\tint ret=0;\n\t\tbool dame=false;\n\t\tint last=-99999999;\n\t\tfor(int i=0;i<a;i++){\n\t\t//\tprintf(\"%d %d\\n\",event[i].first,f[event[i].second]);\n\t\t\tif(last+30>event[i].first)continue;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tif(event[i].first+30>event[j].first){\n\t\t\t\t\tif(f[event[j].second]){\n\t\t\t\t\t\tok=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tret++;\n\t\t\t\tlast=event[i].first;\n\t\t\t}else{\n\t\t\t\tif(f[event[i].second])dame=true;\n\t\t\t}\n\t\t}\n\t\tif(dame)printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<string> ps(n);\n\t\tvector<int> ts(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>ps[i];\n\t\t\tint w,s; cin>>w>>s;\n\t\t\tts[i]=(w*24*60+s/100*60+s%60)%(7*24*60);\n\t\t}\n\t\tint m; cin>>m;\n\t\tvector<int> fs(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tfs[find(begin(ps),end(ps),s)-begin(ps)]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tts.push_back(ts[i]+7*24*60);\n\t\tvector<int> is(n*2);\n\t\tiota(begin(is),end(is),0);\n\t\tsort(begin(is),end(is),[&](int i,int j){return ts[i]<ts[j];});\n\t\t\n\t\tint res=-1;\n\t\tfor(int l=0,r=7*24*60;l<1440;l++,r++){\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is) if(fs[i]){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tif(dp[r]!=m) continue;\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tres=max(res,dp[r]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<string> ps(n);\n\t\tvector<int> ts(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>ps[i];\n\t\t\tint w,s; cin>>w>>s;\n\t\t\tts[i]=(w*24*60+s/100*60+s%60)%(7*24*60);\n\t\t}\n\t\tint m; cin>>m;\n\t\tvector<int> fs(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s; cin>>s;\n\t\t\tfs[find(begin(ps),end(ps),s)-begin(ps)]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tts.push_back(ts[i]+7*24*60);\n\t\tvector<int> is(n*2);\n\t\tiota(begin(is),end(is),0);\n\t\tsort(begin(is),end(is),[&](int i,int j){return ts[i]<ts[j];});\n\t\t\n\t\tint res=-1;\n\t\tfor(int l=0,r=7*24*60;l<60;l++,r++){\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is) if(fs[i]){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tif(dp[r]!=m) continue;\n\t\t\t}\n\t\t\t{\n\t\t\t\tvector<int> dp(r+1);\n\t\t\t\tint p=0;\n\t\t\t\tfor(int i:is){\n\t\t\t\t\tint t=ts[i];\n\t\t\t\t\tif(l<=t && t+30<=r){\n\t\t\t\t\t\tfor(;p<t;p++) dp[t]=max(dp[t],dp[p]);\n\t\t\t\t\t\tdp[t+30]=max(dp[t+30],dp[t]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(;p<r;p++) dp[r]=max(dp[r],dp[p]);\n\t\t\t\tres=max(res,dp[r]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<anime> table;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        anime t;\n        t.setup(na,we,st);\n        table.push_back(t);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table.begin() , table.end());\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define DAY_MIN (24*60)\nusing namespace std;\nstruct Pox\n{\n  int weekday,start;\n  Pox(int weekday=-1,int start=-1):weekday(weekday),start(start){}\n};\nint N,P;\nbool used[7][DAY_MIN+1];\n\nint toMin(int v)\n{\n  int tp = (int)floor(v/100.0);\n  int bm = v%100;\n  return tp*60 + bm;\n}\n\nbool cmp(const Pox &a,const Pox &b)\n{\n  if(a.weekday != b.weekday)return a.weekday < b.weekday;\n  return a.start < b.start;\n}\n\nint main()\n{\n\n  while(cin >> N , N)\n    {\n      map<string,Pox> index;\n      rep(j,7)rep(i,DAY_MIN+1)used[j][i] = false;\n      bool AUTO = false;\n      vector<Pox> info(N);\n      vector<string> name(N);\n      map<string,bool> drowsiness;\n\n      rep(i,N)\n\t{\n\t  cin >> name[i] >> info[i].weekday >> info[i].start;\n\t  info[i].start = toMin(info[i].start);\n\t  if(info[i].start >= DAY_MIN)\n\t    {\n\t      info[i].weekday = (info[i].weekday+1)%7;\n\t      info[i].start %= DAY_MIN;\n\t    }\n\t  index[name[i]] = info[i];\n\t}\n\n      cin >> P;\n      int cnt = P;\n      vector<string> name2(P);\n      rep(i,P)\n\t{\n\t  cin >> name2[i];\n\t  Pox pox = index[name2[i]];\n\t  drowsiness[name2[i]] = true;\n\t  int week = pox.weekday;\n\t  if(!AUTO)\n\t    {\n\t      //cout << \"fill in : \" << pox.start << \" \" << pox.start+30 << \" from \" << week << \" \";\n\t      REP(j,pox.start,pox.start+30)\n\t\t{\n\t\t  if(j >= DAY_MIN)week = (week+1)%7;\n\t\t  if(used[week][j%DAY_MIN])\n\t\t    {\n\t\t      AUTO = true;\n\t\t      break;\n\t\t    }\n\t\t  used[week][j%DAY_MIN] = true;\n\t\t}\n\t      //cout << \" to \" << week << endl;\n\t    }\n\t}\n\n      vector<Pox> FIFA;\n      rep(i,name.size())\n\t{\n\t  //cout << name[i] << \" = \";\n\t  if(!drowsiness[name[i]])\n\t    {\n\t      //cout << \"IN\" << endl;\n\t      FIFA.push_back(index[name[i]]);\n\t    }\t\n\t}\n\n      //cout << \"------\" << endl;\n\n      sort(FIFA.begin(),FIFA.end(),cmp);\n\n      rep(i,FIFA.size())\n\t{\n\t  int week = FIFA[i].weekday;\n\t  bool check = true;\n\t  //cout << \"fill in | \" << FIFA[i].start << \" \" << FIFA[i].start+30 << \" : \" << week;\n\t  REP(j,FIFA[i].start,FIFA[i].start+30)\n\t    {\n\t      if(j >= DAY_MIN)week = (week+1)%7;\n\t      if(used[week][j%DAY_MIN])\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t      used[week][j%DAY_MIN] = true;\n\t    }\n\t  if(check)cnt++;\n\t  //cout << \" to \" << week << \" cnt = \" << cnt << endl;\n\t}\n\n      if(AUTO)cout << -1 << endl;\n      else    cout << cnt << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n\ntypedef pair<int, string> pis;\n\nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty())\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            end--;\n            if(start == end){\n              m.erase(m.begin());\n              f.erase(f.begin());\n              ans++;\n              break;\n            }else{\n              end++;\n              m.erase(start, end);\n              f.erase(f.begin());\n              ans++;\n            }\n          }\n        }\n      }\n      while(m.size() > 1){\n        ite = ++m.begin();\n        while(ite != m.end()){\n          if(m.begin()->first + 30 > ite->first){\n            m.erase(ite);\n            ite = ++m.begin();;\n          }else{\n            break;\n          }\n        }\n        m.erase(m.begin());\n        ans++;\n      }\n      if(!f.empty())\n        cout << \"-1\" << endl;\n      else\n        cout << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (int)(j))\n#define REP(i,j,k) for(int i=(int)(j);(int)(i)<(int)(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\nint N, P;\nstring name, FAV;\nint weekday, start;\n\nbool cmp(const pair<string, int> &a,const pair<string, int> &b){\n  return a.S < b.S;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    vector<pair<string, int> >PRO;\n    rep(i, N){\n      cin >> name >> weekday >> start;\n      PRO.push_back(MP(name, (weekday*100000)+(start/100)*60+(start%100)));\n    }\n\n    map<string, int>m;    \n    scanf(\"%d\", &P);\n    rep(i, P){\n      cin >> FAV;\n      rep(j, PRO.size()){\n\tif(FAV != PRO[j].F) continue;\n\tm[FAV] = PRO[j].S;\n\t//\tcout << FAV << \" \" << m[FAV] << endl;\n\t//\tputs(\"\");\n\trep(k, PRO.size()){\n\t  if(abs(PRO[k].S-m[FAV]) < 30){\n\t    //\t    cout << PRO[k].F << endl;\n\t    PRO.erase(PRO.begin()+k);\n\t    k--;\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    //    printf(\"%d\\n\", (int)PRO.size());\n    sort(PRO.begin(), PRO.end(), cmp);\n    /*    rep(i, PRO.size()){\n      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      }*/\n\n    int time = 0, res = 0; \n    //    puts(\"\");\n    rep(i, PRO.size()){\n      if(abs(PRO[i].S-time) < 30) continue;\n      //      printf(\"%d\\n\", time);\n      //      cout << PRO[i].F << \" \" << PRO[i].S << endl;\n      res++;\n      time = PRO[i].S;\n    }\n    printf(\"%d\\n\", res+P);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : Watchin.cpp\n// Author      : alpc92\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define REP(i,n) for(int i(0);i<((int)n);++i)\n#define FOR(i,l,h) for(int i((int)l);i<=((int)h);++i)\n#define FORD(i,h,l) for(int i((int)h);i>=((int)l);--i)\n#define CLEAR(arr,k) memset(arr,k,sizeof(arr))\n#define SZ (STL) (int)STL.size();\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nmap<string, int> mp;\nint hash(int d, int st) {\n\tint h(st / 100), m(st % 100);\n\tif (h >= 24) {\n\t\t++d ;\n\t\th %= 24;\n\t}\n\treturn m + (h + d * 24) * 60;\n}\nvector<int> tim, fav;\nbool chkfav() {\n\tFOR(i,1,(int)fav.size()-1)\n\t\tif (fav[i] - fav[i - 1] < 30)\n\t\t\treturn 0;\n\treturn 1;\n}\nint chktim() {\n\tint res(0);\n\tsort(tim.begin(), tim.end());\n\tREP(i,(int)tim.size()) {\n\t\tbool flag(1);\n\t\tREP(j,(int)fav.size())\n\t\t\tif (abs(tim[i] - fav[j]) < 30) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (flag)\n\t\t\t++res, fav.push_back(tim[i]);\n\t}\n\treturn res;\n}\nint main() {\n\tint n, p;\n\twhile (cin >> n, n) {\n\t\tstring s;\n\t\tint d, st;\n\t\tmp.clear();\n\t\ttim.clear();\n\t\tfav.clear();\n\t\tREP(i,n) {\n\t\t\tcin >> s >> d >> st;\n\t\t\tint t(hash(d, st));\n\t\t\tmp[s] = t;\n\t\t\ttim.push_back(t);\n\t\t}\n\t\tcin >> p;\n\t\tREP(i,p) {\n\t\t\tcin >> s;\n\t\t\tfav.push_back(mp[s]);\n\t\t}\n\t\tsort(fav.begin(), fav.end());\n\t\tif (chkfav())\n\t\t\tprintf(\"%d\\n\", p + chktim());\n\t\telse\n\t\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            if(start == m.end())\n              start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          multimap<int, string>::iterator ite2;\n          ite2 = ite;\n          ite2++;\n          if(ite2 == m.end())\n            flag = true;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  long int minutes;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    favorite = false;\n    int h = start / 100;\n    int m = start % 100;\n    if(h >= 24){\n      h -= 24;\n      w++;\n    }\n    minutes = h*60 + m + weekday * 60 * 24;\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  return a1.minutes < a2.minutes;\n}\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      vector<anime> table;\n      vector<anime> favoritetable;\n      map<string,anime> amap;\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        anime t;\n        t.setup(na,we,st);\n        table.push_back(t);\n        amap[na] = t;\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        favoritetable.push_back(amap[na]);\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table.begin() , table.end());\n      sort(favoritetable.begin(), favoritetable.end());\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true,changelast;\n      count = 0;\n\n      for(int i=0; i<favoritetable.size()-1; i++){\n        if(abs(favoritetable[i+1].minutes - favoritetable[i].minutes) < 30){\n          cansee = false;\n          break;\n        }\n      }\n\n      for(int i=0; i<table.size(); i++){\n        for(int j=0; j<favoritetable.size(); j++){\n          if(abs(table[i].minutes - favoritetable[j].minutes) < 30){\n            table.erase(table.begin() + i);\n            i--;\n            break;\n          }\n        }\n      }\n\n      for(int i=0; i<table.size()-1; i++){\n        if(abs(table[i+1].minutes - table[i].minutes) < 30){\n          table.erase(table.begin() + i+1);\n          i--;\n        }\n      }\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << table.size() + f << endl;\n      }\n\n      /*\n\n      while(last != n){\n\n        while(1){\n          if(abs(table[last].minutes - table[first].minutes) >= 30){\n              break;\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        flag = false;\n\n        changelast = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n              changelast = true;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && !changelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n          count++;\n        }\n\n        first = last;\n        last++;\n\n      }\n\n      if(abs(table[n-1].minutes - table[n-2].minutes) >= 30){\n        count++;\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n      */\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef map<string, P> Program;\n\nProgram prog;\nvector<string> all;\nvector<string> fav;\nvector<string> normal;\nint anime[7][1800];\nint ans;\n\nint toMinute(string t){\n  int ret = 0;\n  if(t.size() == 3){\n    ret += (t[0]-'0') * 60;\n    ret += (t[1]-'0') * 10 + (t[2]-'0');\n  }\n  else if(t.size() == 4){\n    int h =(t[0]-'0') * 10 + (t[1]-'0');\n    ret += h * 60;\n    ret += (t[2]-'0') * 10 + (t[3]-'0');\n  }\n  return ret;\n}\n\nbool watchFavAnime(){\n  rep(i, fav.size()){\n    P t = prog[fav[i]];\n    for(int T = t.s ; T < t.s+30 ; T++){\n      if(anime[t.f][T] == 1) return false;\n      anime[t.f][T] = 1;\n    }\n    ans++;\n  }\n  return true;\n}\n\nvoid init(){\n  prog.clear();\n  fav.clear();\n  all.clear();\n  normal.clear();\n  memset(anime, 0, sizeof(anime));\n  ans = 0;\n}\n\nint main(){\n  int n, p;  \n  while(cin >> n, n){\n    init();\n    string name, tim;\n    P t;\n    rep(i, n){\n      cin >> name >> t.f >> tim;\n      int m = toMinute(tim);\n      t.s = m;\n      prog[name] = t;\n      all.push_back(name);\n    }\n    \n    cin >> p;\n    rep(i, p){\n      cin >> name;\n      fav.push_back(name);\n    }    \n    \n    bool flag = true;\n    \n    flag = watchFavAnime();\n    if(!flag){\n      cout << \"-1\" << endl;\n      continue;\n    }\n    \n    rep(i, n){\n      bool f = true;\n      rep(j, p){\n\tif(all[i] == fav[j]){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(flag) normal.push_back(all[i]);\n    }\n    \n    vector<P> nor;\n    rep(i, normal.size()){\n      nor.push_back(prog[normal[i]]);\n    }\n    \n    sort(nor.begin(), nor.end());\n    \n    rep(i, nor.size()){\n      int w = nor[i].f;\n      int m = nor[i].s;\n      bool f = true;\n      for(int T = m ; T < m+30 ; T++){\n\tif(anime[w][T] == 1){\n\t  for(int t = m ; t <= T ; t++){\n\t    anime[w][T] = 0;\n\t  }\n\t  f = false;\n\t  break;\n\t}\n\tanime[w][T] = 1;\n      }\n      if(f){\n\t//cout << normal[i] << endl;\n\tans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstruct anime{\n  string name;\n  int weekday;\n  int start;\n  bool favorite;\n  void setup(string n,int w,int s){\n    name = n;\n    weekday = w;\n    start = s;\n    if(start >= 2400){\n      weekday++;\n      start -= 2400;\n      if(weekday == 7){\n        weekday = 0;\n      }\n    }\n    favorite = false;\n  }\n\n  int minutes(){\n    int tmp = start / 100;\n    return (tmp * 60) + start - (tmp * 100);\n  }\n};\n\nbool operator<(anime a1,anime a2){\n  if(a1.weekday == a2.weekday){\n    return a1.start < a2.start;\n  }\n  return a1.weekday < a2.weekday;\n}\n\nanime table[500];\n\nint main(){\n\n    int n,f,we,st,count;\n    string na;\n\n    while(1){\n      cin >> n;\n      if(n == 0){\n        break;\n      }\n\n      for(int i=0; i<n; i++){\n        cin >> na >> we >> st;\n        table[i].setup(na,we,st);\n      }\n\n      cin >> f;\n\n      for(int i=0; i<f; i++){\n        cin >> na;\n        for(int j=0; j<n; j++){\n          if(table[j].name == na){\n            table[j].favorite = true;\n            break;\n          }\n        }\n      }\n\n      if(n == 1){\n        cout << 1 << endl;\n        continue;\n      }\n\n\n      sort(table , table+n);\n\n    /*  for(int i=0; i<n; i++){\n        cout << table[i].name << \" \" << table[i].weekday;\n        cout << \" \" << table[i].start << \" \";\n        cout << table[i].favorite << endl;\n      }*/\n\n      int first=0,last=1,beforelast;\n      bool flag,cansee = true;\n      count = 0;\n\n      //cout << endl;\n\n      while(last != n){\n\n        while(1){\n          if(table[first].weekday == table[last].weekday){\n\n          /*  cout << table[first].name << \" \" << table[first].weekday;\n            cout << \" \" << table[first].start << \" \";\n            cout << table[first].minutes() << \" \";\n            cout << table[last].name << \" \" << table[last].weekday;\n            cout << \" \" << table[last].start << \" \";\n            cout << table[last].minutes() << endl;*/\n\n            if(table[last].minutes() - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          else{\n            if((table[last].minutes()+2400) - table[first].minutes() >= 30){\n              break;\n            }\n          }\n          last++;\n          if(last == n){\n            last--;\n            break;\n          }\n        }\n\n        beforelast = last;\n\n        //cout << first << \" \" << last << endl;\n\n        flag = false;\n\n        for(int i=first; i<last; i++){\n          if(!flag && table[i].favorite){\n            flag = true;\n            if(i != first){\n              last = i;\n            }\n          }\n          else if(flag && table[i].favorite){\n            cansee = false;\n            break;\n          }\n        }\n\n        if(!cansee){\n          break;\n        }\n\n        if(!flag || (flag && last == beforelast) ){//???????????????????????£??????????????????????????´???????????????count++????????????\n        /*  cout << table[first].name << \" \" << table[first].weekday;\n          cout << \" \" << table[first].start << \" \";\n          cout << table[first].favorite << endl;*/\n          count++;\n        }\n\n        first = last;\n        last++;\n\n\n\n      }\n\n      if(table[n-1].weekday == table[n-2].weekday){\n        if(table[n-1].minutes() - table[n-2].minutes() >= 30){\n          count++;\n        }\n      }\n      else{\n        if((table[n-2].minutes()+2400) - table[n-1].minutes() >= 30){\n          count++;\n        }\n      }\n\n\n\n      if(!cansee){\n        cout << -1 << endl;\n      }\n      else{\n        cout << count << endl;\n      }\n\n\n\n\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nint solve(int start){\n  int ai=0,bi=0,now=start,res=0;\n  int as=A.size(),bs=B.size(),cnt=0;\n  while(1){\n    int ag=(ai<as?A[ai].first:1e8);\n    int bg=(bi<bs?B[bi].first:1e8);\n    if(7*60*24+start-30<ag)ag=1e8;\n    if(7*60*24+start-30<bg)bg=1e8;\n    if(ag==1e8&&bg==1e8)break;\n\n    if(ag<now){ai++;continue;}\n    if(bg<now){bi++;continue;}\n    if(ag+30<=bg){\n      res++;\n      now=ag+30;\n      ai++;\n    }else{\n      res++;\n      cnt++;\n      now=bg+30;\n      bi++;\n    }\n  }\n  if(cnt<M)return -1;\n  else return res;\n}\n\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b%(7*60*24),i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n    int ans=-1;\n    for(int i=0;i<=30;i++)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : TopCoderCompetition.cpp\n// Author      : taguchi\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <list>\nusing namespace std;\n//#define P pair<int,int>\n#define rep(i,n) for(int i = 0;i<n;i++)\n#define pb(n) push_back(n)\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nstruct edge{int cost,to;};\n\nvector<string> split(string &in,char delimiter){\n\tvector<string> re; uint cur = 0,next;\n\twhile((next = in.find_first_of(delimiter,cur)) != string::npos){\n\t\tre.pb(string(in,cur,next-cur));\n\t\tcur = next + 1;\n\t}\n\tre.pb(string(in,cur,in.size()-cur));\n\treturn re;\n}\nvector<int> split_int(string &in, char delimiter){\n\tvector<string> str = split(in,delimiter);\n\tvector<int> re;\n\trep(i,str.size()){\n\t\tre.pb(strtol(str[i].c_str(),NULL,10));\n\t}\n\treturn re;\n}\n\nclass Range{\npublic:\n\tint a,b;\n\tRange(int an,int bn) : a(an),b(bn){}\n\n\tbool operator()(int n){\n\t\treturn a<=n&&n<=b;\n\t}\n\tbool isCross(Range x){\n\t\treturn x(a) || x(b);\n\t}\n\tbool contains(Range x){\n\t\treturn this->a <= x.a && x.b <= this->b;\n\t}\n};\n\nclass RangeHandler{\npublic:\n\tlist<Range> Ranges;\n\n\tbool insert(Range x){\n\t\tif(Ranges.empty()){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\n\t\tif(x.b < Ranges.front().a){\n\t\t\tRanges.push_front(x);\n\t\t\treturn true;\n\t\t}\n\t\tif(Ranges.back().b < x.a){\n\t\t\tRanges.push_back(x);\n\t\t\treturn true;\n\t\t}\n\t\tfor(list<Range>::iterator i = Ranges.begin();i != Ranges.end();i++){\n\t\t\tlist<Range>::iterator l = i;\n\t\t\tl++;\n\t\t\t//cout << \"dbg\" << i->b << \" \" << i->a << endl;\n\t\t\tif(Range(i->b,l->a).contains(x)){\n\t\t\t\tRanges.insert(l,x);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\nint N,P;\nint main(){\n\twhile(true){\n\t\tint result = 0;\n\t\tcin >> N;\n\t\tif(N == 0)break;\n\t\tvector<pair<int,string> > Programs,Table;\n\t\tvector<pair<int,string> >::iterator ip;\n\t\trep(i,N){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tint weekday,start;\n\t\t\tcin >> weekday >> start;\n\t\t\tstart -=600;\n\t\t\tint time = 1440 * weekday + (start / 100) * 60 + (start % 100);\n\t\t\tPrograms.pb(make_pair(time,name));\n\t\t}\n\t\tcin >> P;\n\t\trep(i,P){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tfor(ip = Programs.begin();ip!=Programs.end();ip++){\n\t\t\t\tif(ip->second == name){\n\t\t\t\t\tTable.pb(*ip);\n\t\t\t\t\tPrograms.erase(ip);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(Programs.begin(),Programs.end());\n\t\trep(i,Programs.size()){\n\t\t\tTable.pb(Programs[i]);\n\t\t}\n\t\tRangeHandler rg;\n\t\tbool ans = true;\n\t\trep(i,Table.size()){\n\t\t\tif(rg.insert(Range(Table[i].first,Table[i].first+30))){\n\t\t\t\tans &= true;\n\t\t\t\tresult++;\n\t\t\t}\n\t\t\tif(i < P && !ans) {\n\t\t\t\tresult = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#define MAX_T 1440\nusing namespace std;\n \ntypedef pair<int, string> pis;\n \nint main()\n{\n  while(1){\n    int N;\n    cin >> N;\n    if(N == 0){\n      break;\n    }else{\n      multimap<int, string> m;\n      multimap<int, string>::iterator ite;\n      vector<string> f;\n      int P, ans = 0;\n      bool flag = false;\n      for(int i = 0; i < N; i++){\n        string n, s;\n        int w, x;\n        cin >> n >> w >> s;\n        if(s.size() == 3)\n          x = (s[0] - '0') * 60 + (s[1] - '0') * 10 + (s[2] - '0');\n        else\n          x = ((s[0] - '0') * 10 + (s[1] - '0')) * 60 + (s[2] - '0') * 10 + (s[3] - '0');\n        m.insert(pis(w * MAX_T + x, n));\n      }\n      cin >> P;\n      for(int i = 0; i < P; i++){\n        string s;\n        cin >> s;\n        f.push_back(s);\n      }\n      sort(f.begin(), f.end());\n      for(int i = 0; i < f.size(); i++){\n        if(f.empty() || flag)\n          break;\n        for(ite = m.begin(); ite != m.end(); ++ite){\n          if(ite->second == f[i]){\n            int x = ite->first;\n            multimap<int, string>::iterator start;\n            multimap<int, string>::iterator end;\n            start = m.upper_bound(x - 30);\n            end = m.lower_bound(x + 30);\n            if(start == m.end())\n              start = ite;\n            m.erase(start, end);\n            f.erase(f.begin());\n            ans++;\n            i = 0;\n            break;\n          }\n          multimap<int, string>::iterator ite2;\n          ite2 = ite;\n          ite2++;\n          if(ite2 == m.end())\n            flag = true;\n        }\n      }\n      if(flag){\n        cout << \"-1\" << endl;\n      }else{ \n        while(!m.empty()){\n          multimap<int, string>::iterator start;\n          multimap<int, string>::iterator end;\n          start = m.begin();\n          end = m.lower_bound(start->first + 30);\n          m.erase(start, end);\n          ans++;\n        }\n        cout << ans << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nbool Diff(int x,int y);\nbool Check(P& p);\n\nvector<P> fav;\nvector<P> anime;\n\nint main() {\n\tint n;\n\tifstream cin(\"input.txt\");\n\twhile(cin>>n,n) {\n\t\tanime.clear();\n\t\tfav.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstring name;\n\t\t\tint weekday,start,time;\n\t\t\tcin>>name>>weekday>>start;\n\t\t\ttime=(weekday*1440+start/100*60+start%100)%(1440*7);\n\t\t\tanime.push_back(P(time,name));\n\t\t}\n\t\tsort(anime.begin(),anime.end());\n\t\tint p;cin>>p;\n\t\tfor(int i=0;i<p;i++) {\n\t\t\tstring name;cin>>name;\n\t\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\t\tif(anime[i].second==name) {\n\t\t\t\t\tfav.push_back(P(anime[i].first,anime[i].second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(fav.begin(),fav.end());\n\t\tbool okay=true;\n\t\tfor(int i=0;i<fav.size();i++) {\n\t\t\tfor(int j=0;j<fav.size();j++) {\n\t\t\t\tif(i!=j&&Diff(fav[i].first,fav[j].first)) {okay=false;}\n\t\t\t}\n\t\t}\n\t\tif(!okay) {cout<<-1<<endl;continue;}\n\t\tvector<P>::iterator itr=remove_if(anime.begin(),anime.end(),Check);\n\t\tanime.erase(itr,anime.end());\n\t\tvector<int> vst;\n\t\tint count=0;\n\t\tfor(int i=0;i<anime.size();i++) {\n\t\t\tfor(int j=0;j<vst.size();j++) {\n\t\t\t\tif(Diff(anime[i].first,vst[j])) goto jump;\n\t\t\t}\n\t\t\tvst.push_back(anime[i].first);\n\t\t\tcount++;\n\t\t\tjump:;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n}\n\nbool Diff(int x,int y) {\n\tint max_t=max(x,y);\n\tint min_t=min(x,y);\n\treturn (max_t-min_t)<30||(max_t-(min_t+1440*7))>-30;\n}\n\nbool Check(P& p) {\n\tbool okay=false;\n\tfor(int i=0;i<fav.size();i++) {\n\t\tif(fav[i].second!=p.second&&Diff(fav[i].first,p.first)) okay=true;\n\t}\n\treturn okay;\n}"
  },
  {
    "language": "C++",
    "code": "import bisect\n\nwhile(1):\n    N=int(raw_input())\n    if N==0: break\n    D={}\n    for i in range(N):\n        inp=raw_input().split()\n        inp[1:]=map(int, inp[1:])\n        stt=inp[1]*24*60+inp[2]/100*60+inp[2]%100\n        D[inp[0]]=stt\n    P=int(raw_input())\n    Tlist=[-99999999,999999999]\n    for i in range(P):\n        f=raw_input()\n        Tlist.append(D.pop(f))\n    Tlist.sort()\n    for i in range(P+1):\n        if Tlist[i+1]<Tlist[i]+30:\n            print -1\n            break\n    else:\n        ans=P\n        E=sorted(D.values())\n        for st in E:\n            if (st - Tlist[ bisect.bisect(Tlist, st)-1])>= 30 and (Tlist[ bisect.bisect(Tlist, st)] - st ) >= 30:\n                ans+=1\n                bisect.insort(Tlist, st)\n        print ans"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> mp;\nint N,M;\nvector<P> t,A,B;\n\nint solve(int start){\n  int ai=0,bi=0,now=start,res=0;\n  int as=A.size(),bs=B.size();\n  int cnt=0;\n  while(ai<as||bi<bs){\n    int ag=(ai<as?A[ai].first:1e8);\n    int bg=(bi<bs?B[bi].first:1e8);\n    if(now<=ag&&ag+30<=bg){\n      if(ag+30<=7*60*24+start){\n\tres++;\n\tnow=ag+30;\n\tai++;\n      }else{\n\tai++;\n      }\n    }else if(ag<now){\n      ai++;\n    }else{\n      if(bg+30<=7*60*24+start){\n\tnow=bg+30;\n\tbi++;\n\tcnt++;\n\tres++;\n      }else{\n\treturn -1;\n      }\n    }\n  }\n  if(cnt<M)return -1;\n  else return res;\n}\n\nvoid init(){\n  t.clear();\n  A.clear();\n  B.clear();\n  mp.clear();\n}\n\nint main(){\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    for(int i=0;i<N;i++){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      b=(c/100*60+c%100)+(b*60*24);\n      mp[a]=i;\n      t.push_back(P(b%(7*60*24),i));\n    }\n    cin>>M;\n    for(int i=0;i<M;i++){\n      string a;\n      cin>>a;\n      B.push_back(t[mp[a]]);\n      t[mp[a]]=P(-1,-1);\n    }\n    for(int i=0;i<(int)t.size();i++)\n      if(t[i].first!=-1)\n\tA.push_back(t[i]);\n\n    sort(A.begin(),A.end());\n    sort(B.begin(),B.end());\n    int ans=0;\n    for(int i=0;i<30;i++)ans=max(ans,solve(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1063: Watchin' TVA\n// 2017.9.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSIZ 1999\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char nm[35]; int s, e, f; } T;\nT tbl[502]; int n;\n\nint cmp(T *a, T *b) { return a->s - b->s; }\n\nint main()\n{\n\tint p, i, j, k, e, ans;\n\tchar nm[35];\n\tT *t;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (t = tbl, i = 0; i < n; i++, t++) {\n\t\t\tint w, s, h, m;\n\t\t\tscanf(\"%s%d%d\", t->nm, &w, &s);\n\t\t\th = s / 100, m = s % 100;\n\t\t\tt->s = (1440*w + h*60 + m) % 10080, t->e = t->s + 30; \n\t\t\tt->f = 0;\n\t\t\tinsert(t->nm, i);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\twhile (p-- > 0) {\n\t\t\tscanf(\"%s\", nm);\n\t\t\t(tbl + lookup(nm))->f = 1;\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\n\t\tfor (k = 0; k < n; k++) if (tbl[k].f) break;\n\t\tif (k >= n) k = 0;\n\t\tfor (ans = 1, i = k, j = i+1; j != k; j++) {\n\t\t\tif (i >= n) i = 0;\n\t\t\tif (j >= n) j = 0;\n\t\t\tif (tbl[i].e > 10080) e = tbl[i].e - 10080; else e = 0;\n\t\t\tif ((tbl[i].s <= tbl[j].s && tbl[j].s < tbl[i].e) || tbl[j].s < e) {\n\t\t\t\tif (tbl[j].f & tbl[i].f) { ans = -1; break; }\n\t\t\t\telse if (tbl[j].f) i = j;\n\t\t\t} else if (tbl[j].s <= tbl[k].s && tbl[k].s < tbl[j].e) ;\n\t\t\telse {\n\t\t\t\tans++, i = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1063: Watchin' TVA\n// 2017.9.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSIZ 1999\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5], *hashend = hash + HSIZ;\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return -1;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char nm[35]; int s, e, f; } T;\nT tbl[502]; int n;\n\nint cmp(T *a, T *b) { return a->s - b->s; }\n\nint main()\n{\n\tint p, i, j, k, e, ans;\n\tchar nm[35];\n\tT *t;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (t = tbl, i = 0; i < n; i++, t++) {\n\t\t\tint w, s, h, m;\n\t\t\tscanf(\"%s%d%d\", t->nm, &w, &s);\n\t\t\th = s / 100, m = s % 100;\n\t\t\tt->s = (1440*w + h*60 + m) % 10080, t->e = t->s + 30; \n\t\t\tt->f = 0;\n\t\t\tinsert(t->nm, i);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\twhile (p-- > 0) {\n\t\t\tscanf(\"%s\", nm);\n\t\t\t(tbl + lookup(nm))->f = 1;\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\n\t\tfor (k = 0; k < n; k++) if (tbl[k].f) break;\n\t\tif (k >= n) k = 0;\n\t\tfor (ans = 1, i = k, j = i+1; j != k; j++) {\n\t\t\tif (i >= n) i = 0;\n\t\t\tif (j >= n) j = 0;\n\t\t\tif (tbl[i].e > 10080) e = tbl[i].e - 10080; else e = 0;\n\t\t\tif ((tbl[i].s <= tbl[j].s && tbl[j].s < tbl[i].e) || tbl[j].s < e) {\n\t\t\t\tif (tbl[j].f & tbl[i].f) { ans = -1; break; }\n\t\t\t\telse if (tbl[j].f) i = j;\n\t\t\t} else if (tbl[j].s <= tbl[k].s && tbl[k].s < tbl[j].e) ;\n\t\t\telse {\n\t\t\t\tans++, i = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1063: Watchin' TVA\n// 2017.9.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSIZ 1009\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5], *hashend = hash + HSIZ;\n\nint lookup(char *w)\n{\n\tint l = strlen(w);\n\tint i = (101 * *w + 103 * *(w + l - 1) + 107 * l) % HSIZ;\n\tHASH *tp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint l = strlen(w);\n\tint i = (101 * *w + 103 * *(w + l - 1) + 107 * l) % HSIZ;\n\tHASH *tp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return -1;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { int s, e, f; char nm[35]; } T;\nT tbl[502];\n\nint cmp(T *a, T *b) { return a->s - b->s; }\n\nint main()\n{\n\tint n, p, i, j, k, e, ans;\n\tchar nm[35];\n\tT *t;\n\n\twhile (scanf(\"%d\", &n) == 1 && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (t = tbl, i = 0; i < n; i++, t++) {\n\t\t\tint w, s, h, m;\n\t\t\tscanf(\"%s%d%d\", t->nm, &w, &s);\n\t\t\th = s / 100, m = s % 100;\n\t\t\tt->s = (1440*w + h*60 + m) % 10080, t->e = t->s + 30; \n\t\t\tt->f = 0;\n\t\t\tinsert(t->nm, i);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\twhile (p-- > 0) {\n\t\t\tscanf(\"%s\", nm);\n\t\t\ttbl[lookup(nm)].f = 1;\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\n\t\tfor (k = 0; k < n; k++) if (tbl[k].f) break;\n\t\tif (k >= n) k = 0;\n\t\tfor (ans = 1, i = k, j = i+1; j != k; j++) {\n\t\t\tif (i >= n) i = 0;\n\t\t\tif (j >= n) j = 0;\n\t\t\tif (tbl[i].e > 10080) e = tbl[i].e - 10080; else e = 0;\n\t\t\tif ((tbl[i].s <= tbl[j].s && tbl[j].s < tbl[i].e) || tbl[j].s < e) {\n\t\t\t\tif (tbl[j].f & tbl[i].f) { ans = -1; break; }\n\t\t\t\telse if (tbl[j].f) i = j;\n\t\t\t} else if (tbl[j].s <= tbl[k].s && tbl[k].s < tbl[j].e) ;\n\t\t\telse {\n\t\t\t\tans++, i = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1063: Watchin' TVA\n// 2017.9.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSIZ 1009\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5];\n\nint lookup(char *w)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint i, l;\n\tHASH *tp;\n\ti = (101 * *w + 103 * *(w + (l = strlen(w)) - 1) + 107 * l) % HSIZ;\n\ttp = hash + i;\n\tif (tp->w != NULL) {\n\t\tint inc = *w + (*(w + 1) << 1);\n\t\twhile (1) {\n\t\t\tif (!strcmp(tp->w, w)) return -1;\n\t\t\ti += inc; if (i >= HSIZ) i -= HSIZ;\n\t\t\ttp = hash + i;\n\t\t\tif (tp->w == NULL) break;\n\t\t}\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { char nm[35]; int s, e, f; } T;\nT tbl[502]; int n;\n\nint cmp(T *a, T *b) { return a->s - b->s; }\n\nint main()\n{\n\tint p, i, j, k, e, ans;\n\tchar nm[35];\n\tT *t;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (t = tbl, i = 0; i < n; i++, t++) {\n\t\t\tint w, s, h, m;\n\t\t\tscanf(\"%s%d%d\", t->nm, &w, &s);\n\t\t\th = s / 100, m = s % 100;\n\t\t\tt->s = (1440*w + h*60 + m) % 10080, t->e = t->s + 30; \n\t\t\tt->f = 0;\n\t\t\tinsert(t->nm, i);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\twhile (p-- > 0) {\n\t\t\tscanf(\"%s\", nm);\n\t\t\t(tbl + lookup(nm))->f = 1;\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\n\t\tfor (k = 0; k < n; k++) if (tbl[k].f) break;\n\t\tfor (ans = 1, i = k, j = i+1; j != k; j++) {\n\t\t\tif (i >= n) i = 0;\n\t\t\tif (j >= n) j = 0;\n\t\t\tif (tbl[i].e > 10080) e = tbl[i].e - 10080; else e = 0;\n\t\t\tif ((tbl[i].s <= tbl[j].s && tbl[j].s < tbl[i].e) || tbl[j].s < e) {\n\t\t\t\tif (tbl[j].f & tbl[i].f) { ans = -1; break; }\n\t\t\t\telse if (tbl[j].f) i = j;\n\t\t\t} else if (tbl[j].s <= tbl[k].s && tbl[k].s < tbl[j].e) ;\n\t\t\telse {\n\t\t\t\tans++, i = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1063: Watchin' TVA\n// 2017.9.30 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HSIZ 1009\ntypedef struct { char *w; int k; } HASH;\nHASH hash[HSIZ + 5], *hashend = hash + HSIZ;\n\nint lookup(char *w)\n{\n\tint l = strlen(w);\n\tint i = (101 * *w + 103 * *(w + l - 1) + 107 * l) % HSIZ;\n\tHASH *tp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return tp->k;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nint insert(char *w, int k)\n{\n\tint l = strlen(w);\n\tint i = (101 * *w + 103 * *(w + l - 1) + 107 * l) % HSIZ;\n\tHASH *tp = hash + i;\n\twhile (tp->w != NULL) {\n\t\tif (!strcmp(tp->w, w)) return -1;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->w = w, tp->k = k;\n\treturn 0;\n}\n\ntypedef struct { int s, e, f; char nm[35]; } T;\nT tbl[502];\n\nint cmp(T *a, T *b) { if (a->s - b->s) return a->s - b->s; return b->f - a->f; }\n\nint main()\n{\n\tint n, p, i, j, k, e, ans;\n\tT *t;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tfor (t = tbl, i = 0; i < n; i++, t++) {\n\t\t\tint w, s, h, m;\n\t\t\tscanf(\"%s%d%d\", t->nm, &w, &s);\n\t\t\th = s / 100, m = s % 100;\n\t\t\tt->s = (1440*w + h*60 + m) % 10080, t->e = t->s + 30; \n\t\t\tt->f = 0;\n\t\t\tinsert(t->nm, i);\n\t\t}\n\t\tscanf(\"%d\", &p);\n\t\twhile (p-- > 0) {\n\t\t\tchar nm[35];\n\t\t\tscanf(\"%s\", nm);\n\t\t\tk = lookup(nm); if (k < 0) k = 0;  // panic\n\t\t\ttbl[k].f = 1;\n\t\t}\n\t\tif (n == 1) { puts(\"1\"); continue; }\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\n\t\tfor (k = 0; k < n; k++) if (tbl[k].f) break;\n\t\tif (k >= n) k = 0;\t\t// panic\n\t\tfor (ans = 1, i = k, j = k+1; ; j++) {\n\t\t\tif (i >= n) i = 0; if (j >= n) j = 0;\n\t\t\tif (j == k) break;\n\t\t\tif (tbl[i].e >= 10080) e = tbl[i].e - 10080; else e = 0;\n\t\t\tif ((tbl[i].s <= tbl[j].s && tbl[j].s < tbl[i].e) || tbl[j].s < e) {\n\t\t\t\tif (tbl[j].f && tbl[i].f) { ans = -1; break; }\n\t\t\t\telse if (tbl[j].f) i = j;\n\t\t\t} else if (tbl[j].s <= tbl[k].s && tbl[k].s < tbl[j].e) ; // do nothing\n\t\t\telse {\n\t\t\t\tans++, i = j;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Watchin' TVA\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tMap<Integer, Map<String, Integer>> progs = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint weekday = parseInt(words[1]);\n\t\t\t\tint start;\n\n\t\t\t\tif (words[2].length() == 3) {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 1)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(1));\n\t\t\t\t} else {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 2)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(2));\n\t\t\t\t}\n\n\t\t\t\tprogs.putIfAbsent(weekday, new HashMap<>());\n\t\t\t\tprogs.get(weekday).put(name, start);\n\t\t\t}\n\n\t\t\tint P = parseInt(br.readLine());\n\n\t\t\tSet<String> favs = new HashSet<>();\n\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tfavs.add(br.readLine());\n\t\t\t}\n\n\t\t\t//\n\t\t\tint count = 0;\n\n\t\t\touter:\n\t\t\tfor (int i = 0; i < 7; i++) {\n\n\t\t\t\tif (!progs.containsKey(i)) continue;\n\n\t\t\t\tint[] time = new int[29 * 60 + 30];\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (favs.contains(prog.getKey())) {\n\t\t\t\t\t\ttime[prog.getValue()] += 1;\n\t\t\t\t\t\ttime[prog.getValue() + 30] -= 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j < time.length; j++) {\n\t\t\t\t\ttime[j] += time[j - 1];\n\t\t\t\t\tif (time[j] > 1) {\n\t\t\t\t\t\tcount = -1;\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (!favs.contains(prog.getKey())) {\n\t\t\t\t\t\tint start = prog.getValue();\n\t\t\t\t\t\tif (time[start] == 0 && time[start + 29] == 0) {\n\t\t\t\t\t\t\tfor (int j = start; j <= start + 29; j++) {\n\t\t\t\t\t\t\t\ttime[j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//1063\n\tstatic class WatchinTVA {\n\t\tvoid print_max_watchNum() {\n\t\t\tfor(;;) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tList<Program> list = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString name = sc.next();\n\t\t\t\t\tint weekDay = sc.nextInt();\n\t\t\t\t\tint end = sc.nextInt() + 30;\n\t\t\t\t\tlist.add(new Program(name, toTime(weekDay, end)));\n\t\t\t\t}\n\t\t\t\tCollections.sort(list, new ProgramComparator());\n\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tList<Program> favList = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<p; i++) {\n\t\t\t\t\tString fav = sc.next();\n\t\t\t\t\tfor(Program l:list) {\n\t\t\t\t\t\tif(fav.equals(l.name)) {favList.add(l);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(favList, new ProgramComparator());\n\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i=1; i<p; i++) {\n\t\t\t\t\tif(favList.get(i).end - favList.get(i-1).end < 30) ans = false;\n\t\t\t\t}\n\n\t\t\t\tif(!ans) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}else {\n\t\t\t\t\tint num=0, lastP=0;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tfor(Program f:favList) {\n\t\t\t\t\t\t\tif(Math.abs(f.end - list.get(i).end) < 30)\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judge) {\n\t\t\t\t\t\t\tif(Math.abs(lastP - list.get(i).end) >= 30) {\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tlastP = list.get(i).end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(num + p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint toTime(int wd, int s) {\n\t\t\tint h = s / 100; int m = s % 100;\n\t\t\tif(h >= 24) {\n\t\t\t\th -= 24;\n\t\t\t\twd++;\n\t\t\t}\n\t\t\treturn (wd*60*24) + (h*60) + m;\n\t\t}\n\t}\n\n\tstatic class Program {\n\t\tpublic String name;\n\t\tpublic int end;\n\t\tpublic Program(String name, int end) {\n\t\t\tthis.name = name;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\n\tstatic class ProgramComparator implements java.util.Comparator<Program> {\n\t\tpublic int compare(Program f, Program s) {\n\t\t\treturn f.end - s.end;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//1063\n\t\tWatchinTVA wt = new WatchinTVA();\n\t\twt.print_max_watchNum();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue queue = new PriorityQueue(1, new WatchinTVA().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new WatchinTVA().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList list = new ArrayList();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList favList = new ArrayList();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new WatchinTVA().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue queue2 = new PriorityQueue(1, new WatchinTVA().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new WatchinTVA().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//1063\n\tstatic class WatchinTVA {\n\t\tvoid print_max_watchNum() {\n\t\t\tfor(;;) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tList<Program> list = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString name = sc.next();\n\t\t\t\t\tint weekDay = sc.nextInt();\n\t\t\t\t\tint start = sc.nextInt();\n\t\t\t\t\tif(start >= 2400) {\n\t\t\t\t\t\tif(weekDay+1 > 6) weekDay = 0;\n\t\t\t\t\t\telse weekDay++;\n\t\t\t\t\t\tstart -= 2400;\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(new Program(name, toTime(weekDay, start), toTime(weekDay, start+30)));\n\t\t\t\t}\n\t\t\t\tCollections.sort(list, new ProgramComparator());\n\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tList<Program> favList = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<p; i++) {\n\t\t\t\t\tString fav = sc.next();\n\t\t\t\t\tfor(Program l:list) {\n\t\t\t\t\t\tif(fav.equals(l.name)) {favList.add(l);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(favList, new ProgramComparator());\n\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i=1; i<p; i++) {\n\t\t\t\t\tif(favList.get(i).end - favList.get(i-1).end < 30) ans = false;\n\t\t\t\t}\n\n\t\t\t\tif(!ans) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}else {\n\t\t\t\t\tint num=0, lastP=0;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tfor(Program l:favList) {\n\t\t\t\t\t\t\tif(list.get(i).name.equals(l.name))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if(Math.abs(l.start - list.get(i).start) < 30)\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judge) {\n\t\t\t\t\t\t\tif(lastP <= list.get(i).start) {\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tlastP = list.get(i).end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint toTime(int wd, int s) {\n\t\t\tint h = s / 100; int m = s % 100;\n\t\t\treturn (wd * 10000) + ((h + m/60)*100) + (m % 60);\n\t\t}\n\t}\n\n\tstatic class Program {\n\t\tpublic String name;\n\t\tpublic int start, end;\n\t\tpublic Program(String name, int start, int end) {\n\t\t\tthis.name = name;\n\t\t\tthis.start = start; this.end = end;\n\t\t}\n\t}\n\n\tstatic class ProgramComparator implements java.util.Comparator {\n\t\tpublic int compare(Object f, Object s) {\n\t\t\treturn ((Program)f).end - ((Program)s).end;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//1063\n\t\tWatchinTVA wt = new WatchinTVA();\n\t\twt.print_max_watchNum();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Watchin' TVA\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tMap<Integer, Map<String, Integer>> progs = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint weekday = parseInt(words[1]);\n\t\t\t\tint start;\n\n\t\t\t\tif (words[2].length() == 3) {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 1)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(1));\n\t\t\t\t} else {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 2)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(2));\n\t\t\t\t}\n\n\t\t\t\tprogs.putIfAbsent(weekday, new HashMap<>());\n\t\t\t\tprogs.get(weekday).put(name, start);\n\t\t\t}\n\n\t\t\tint P = parseInt(br.readLine());\n\n\t\t\tSet<String> favs = new HashSet<>();\n\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tfavs.add(br.readLine());\n\t\t\t}\n\n\t\t\t//\n\t\t\tint count = 0;\n\n\t\t\touter:\n\t\t\tfor (int i = 0; i < 7; i++) {\n\n\t\t\t\tif (!progs.containsKey(i)) continue;\n\n\t\t\t\tint[] time = new int[29 * 60 + 31];\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (favs.contains(prog.getKey())) {\n\t\t\t\t\t\ttime[prog.getValue()] += 1;\n\t\t\t\t\t\ttime[prog.getValue() + 30] -= 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j < time.length; j++) {\n\t\t\t\t\ttime[j] += time[j - 1];\n\t\t\t\t\tif (time[j] > 1) {\n\t\t\t\t\t\tcount = -1;\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (!favs.contains(prog.getKey())) {\n\t\t\t\t\t\tint start = prog.getValue();\n\t\t\t\t\t\tif (time[start] == 0 && time[start + 29] == 0) {\n\t\t\t\t\t\t\tfor (int j = start; j <= start + 29; j++) {\n\t\t\t\t\t\t\t\ttime[j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Watchin' TVA\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tString name;\n\t\tint s, t;\n\t\tboolean u;\n\t\tpublic R(String n, int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tname = n;\n\t\t}\n\t\tboolean lap(R r){\n\t\t\treturn s<=r.s&&r.s<s+30 || r.s<=s&&s<r.s+30;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tMap<String, Integer> ref = new TreeMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString name = sc.next();\n\t\t\t\tref.put(name, i);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint s = k*2400 + t/100*60 + t%100;\n\t\t\t\tr[i] = new R(name, s, s+30);\n\t\t\t}\n\t\t\tint p = sc.nextInt();\n\t\t\tList<R> l = new ArrayList<R>();\n\t\t\tboolean f = true;\n\t\t\twhile(p--!=0){\n\t\t\t\tR fav = r[ref.get(sc.next())];\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R v:l){\n\t\t\t\t\tif(v.lap(fav)){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tfav.u = true;\n\t\t\t\t\tl.add(fav);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tSystem.out.println(-1);continue;\n\t\t\t}\n\t\t\tArrays.sort(r);\n\t\t\tfor(R v:r){\n\t\t\t\tif(v.u)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R z:l){\n\t\t\t\t\tif(z.lap(v)){\n\t\t\t\t\t\tok = false;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tl.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l.size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue<Bangumi> queue = new PriorityQueue<Bangumi>(1, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new Main().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList<Bangumi> favList = new ArrayList<Bangumi>();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue<Bangumi> queue2 = new PriorityQueue<Bangumi>(1, new Main().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new Main().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//1063\n\tstatic class WatchinTVA {\n\t\tvoid print_max_watchNum() {\n\t\t\tfor(;;) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tList<Program> list = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString name = sc.next();\n\t\t\t\t\tint weekDay = sc.nextInt();\n\t\t\t\t\tint start = sc.nextInt();\n\t\t\t\t\tif(start >= 2400) {\n\t\t\t\t\t\tif(weekDay+1 > 6) weekDay = 0;\n\t\t\t\t\t\telse weekDay++;\n\t\t\t\t\t\tstart -= 2400;\n\t\t\t\t\t}\n\t\t\t\t\tlist.add(new Program(name, toTime(weekDay, start), toTime(weekDay, start+30)));\n\t\t\t\t}\n\t\t\t\tCollections.sort(list, new ProgramComparator());\n\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tList<Program> favList = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<p; i++) {\n\t\t\t\t\tString fav = sc.next();\n\t\t\t\t\tfor(Program l:list) {\n\t\t\t\t\t\tif(fav.equals(l.name)) {favList.add(l);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(favList, new ProgramComparator());\n\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i=1; i<p; i++) {\n\t\t\t\t\tif(favList.get(i).end - favList.get(i-1).end < 30) ans = false;\n\t\t\t\t}\n\n\t\t\t\tif(!ans) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}else {\n\t\t\t\t\tint num=0, lastP=0;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tfor(Program l:favList) {\n\t\t\t\t\t\t\tif(list.get(i).name.equals(l.name))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse if(Math.abs(l.start - list.get(i).start) < 30)\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judge) {\n\t\t\t\t\t\t\tif(lastP <= list.get(i).start) {\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tlastP = list.get(i).end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint toTime(int wd, int s) {\n\t\t\tint h = s / 100; int m = s % 100;\n\t\t\treturn (wd * 10000) + ((h + m/60)*100) + (m % 60);\n\t\t}\n\t}\n\n\tstatic class Program {\n\t\tpublic String name;\n\t\tpublic int start, end;\n\t\tpublic Program(String name, int start, int end) {\n\t\t\tthis.name = name;\n\t\t\tthis.start = start; this.end = end;\n\t\t}\n\t}\n\n\tstatic class ProgramComparator implements java.util.Comparator<Program> {\n\t\tpublic int compare(Program f, Program s) {\n\t\t\treturn ((Program)f).end - ((Program)s).end;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//1063\n\t\tWatchinTVA wt = new WatchinTVA();\n\t\twt.print_max_watchNum();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//1063\n\tstatic class WatchinTVA {\n\t\tvoid print_max_watchNum() {\n\t\t\tfor(;;) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tList<Program> list = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString name = sc.next();\n\t\t\t\t\tint weekDay = sc.nextInt();\n\t\t\t\t\tint end = sc.nextInt() + 30;\n\t\t\t\t\tif(end >= 2400) {\n\t\t\t\t\t\tif(weekDay+1 > 6) weekDay = 0;\n\t\t\t\t\t\telse weekDay++;\n\t\t\t\t\t\tend -= 2400;\n\t\t\t\t\t}\n\t\t\t\t\tint endTime = toTime(weekDay, end);\n\t\t\t\t\tlist.add(new Program(name, endTime));\n\t\t\t\t}\n\t\t\t\tCollections.sort(list, new ProgramComparator());\n\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tList<Program> favList = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<p; i++) {\n\t\t\t\t\tString fav = sc.next();\n\t\t\t\t\tfor(Program l:list) {\n\t\t\t\t\t\tif(fav.equals(l.name)) {favList.add(l);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(favList, new ProgramComparator());\n\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i=1; i<p; i++) {\n\t\t\t\t\tif(favList.get(i).end - favList.get(i-1).end < 30) ans = false;\n\t\t\t\t}\n\n\t\t\t\tif(!ans) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}else {\n\t\t\t\t\tint num=0, lastP=0;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tfor(Program f:favList) {\n\t\t\t\t\t\t\tif(Math.abs(f.end - list.get(i).end) < 30 || Math.abs(f.end - lastP) < 30)\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judge) {\n\t\t\t\t\t\t\tif(Math.abs(lastP - list.get(i).end) >= 30) {\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tlastP = list.get(i).end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(num + p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint toTime(int wd, int s) {\n\t\t\ts += wd * 2400;\n\t\t\tint h = s / 100; int m = s % 100;\n\t\t\treturn h * 60 + m;\n\t\t}\n\t}\n\n\tstatic class Program {\n\t\tpublic String name;\n\t\tpublic int end;\n\t\tpublic Program(String name, int end) {\n\t\t\tthis.name = name;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\n\tstatic class ProgramComparator implements java.util.Comparator<Program> {\n\t\tpublic int compare(Program f, Program s) {\n\t\t\treturn f.end - s.end;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//1063\n\t\tWatchinTVA wt = new WatchinTVA();\n\t\twt.print_max_watchNum();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Watchin' TVA\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tMap<Integer, Map<String, Integer>> progs = new HashMap<>();\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\twords = br.readLine().split(\" \");\n\n\t\t\t\tString name = words[0];\n\t\t\t\tint weekday = parseInt(words[1]);\n\t\t\t\tint start;\n\n\t\t\t\tif (words[2].length() == 3) {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 1)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(1));\n\t\t\t\t} else {\n\t\t\t\t\tstart = parseInt(words[2].substring(0, 2)) * 60;\n\t\t\t\t\tstart += parseInt(words[2].substring(2));\n\t\t\t\t}\n\n\t\t\t\tprogs.putIfAbsent(weekday, new HashMap<>());\n\t\t\t\tprogs.get(weekday).put(name, start);\n\t\t\t}\n\n\t\t\tint P = parseInt(br.readLine());\n\n\t\t\tSet<String> favs = new HashSet<>();\n\n\t\t\tfor (int i = 0; i < P; i++) {\n\t\t\t\tfavs.add(br.readLine());\n\t\t\t}\n\n\t\t\t//\n\t\t\tint count = 0;\n\n\t\t\touter:\n\t\t\tfor (int i = 0; i < 7; i++) {\n\n\t\t\t\tif (!progs.containsKey(i)) continue;\n\n\t\t\t\tint[] time = new int[30 * 60];\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (favs.contains(prog.getKey())) {\n\t\t\t\t\t\ttime[prog.getValue()] += 1;\n\t\t\t\t\t\ttime[prog.getValue() + 30] -= 1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j < time.length; j++) {\n\t\t\t\t\ttime[j] += time[j - 1];\n\t\t\t\t\tif (time[j] > 1) {\n\t\t\t\t\t\tcount = -1;\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (Map.Entry<String, Integer> prog : progs.get(i).entrySet()) {\n\t\t\t\t\tif (!favs.contains(prog.getKey())) {\n\t\t\t\t\t\tint start = prog.getValue();\n\t\t\t\t\t\tif (time[start] == 0 && time[start + 29] == 0) {\n\t\t\t\t\t\t\tfor (int j = start; j <= start + 29; j++) {\n\t\t\t\t\t\t\t\ttime[j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//1063\n\tstatic class WatchinTVA {\n\t\tvoid print_max_watchNum() {\n\t\t\tfor(;;) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tList<Program> list = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString name = sc.next();\n\t\t\t\t\tint weekDay = sc.nextInt();\n\t\t\t\t\tint end = sc.nextInt() + 30;\n\t\t\t\t\tif(end >= 2400) {\n\t\t\t\t\t\tif(weekDay+1 > 6) weekDay = 0;\n\t\t\t\t\t\telse weekDay++;\n\t\t\t\t\t\tend -= 2400;\n\t\t\t\t\t}\n\t\t\t\t\tint endTime = toTime(weekDay, end);\n\t\t\t\t\tlist.add(new Program(name, endTime));\n\t\t\t\t}\n\t\t\t\tCollections.sort(list, new ProgramComparator());\n\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tList<Program> favList = new ArrayList<Program>();\n\t\t\t\tfor(int i=0; i<p; i++) {\n\t\t\t\t\tString fav = sc.next();\n\t\t\t\t\tfor(Program l:list) {\n\t\t\t\t\t\tif(fav.equals(l.name)) {favList.add(l);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCollections.sort(favList, new ProgramComparator());\n\n\t\t\t\tboolean ans = true;\n\t\t\t\tfor(int i=1; i<p; i++) {\n\t\t\t\t\tif(favList.get(i).end - favList.get(i-1).end < 30) ans = false;\n\t\t\t\t}\n\n\t\t\t\tif(!ans) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}else {\n\t\t\t\t\tint num=0, lastP=0;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tboolean judge = true;\n\t\t\t\t\t\tfor(Program f:favList) {\n\t\t\t\t\t\t\tif(Math.abs(f.end - list.get(i).end) < 30)\n\t\t\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(judge) {\n\t\t\t\t\t\t\tif(Math.abs(lastP - list.get(i).end) >= 30) {\n\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\tlastP = list.get(i).end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(num + p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint toTime(int wd, int s) {\n\t\t\ts += wd * 2400;\n\t\t\tint h = s / 100; int m = s % 100;\n\t\t\treturn h * 60 + m;\n\t\t}\n\t}\n\n\tstatic class Program {\n\t\tpublic String name;\n\t\tpublic int end;\n\t\tpublic Program(String name, int end) {\n\t\t\tthis.name = name;\n\t\t\tthis.end = end;\n\t\t}\n\t}\n\n\tstatic class ProgramComparator implements java.util.Comparator<Program> {\n\t\tpublic int compare(Program f, Program s) {\n\t\t\treturn f.end - s.end;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//1063\n\t\tWatchinTVA wt = new WatchinTVA();\n\t\twt.print_max_watchNum();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue queue = new PriorityQueue(1, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new Main().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList list = new ArrayList();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList favList = new ArrayList();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue queue2 = new PriorityQueue(1, new Main().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new Main().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Watchin' TVA\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tString name;\n\t\tint s, t;\n\t\tboolean u;\n\t\tpublic R(String n, int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tname = n;\n\t\t}\n\t\tboolean lap(R r){\n\t\t\treturn s<=r.s&&r.s<s+30 || r.s<=s&&s<r.s+30;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tMap<String, Integer> ref = new TreeMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString name = sc.next();\n\t\t\t\tref.put(name, i);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tif(k==6&&t>=2400){\n\t\t\t\t\tk = 0;\n\t\t\t\t\tt -= 2400;\n\t\t\t\t}\n\t\t\t\tint s = k*2400 + t/100*60 + t%100;\n\t\t\t\tr[i] = new R(name, s, s+30);\n\t\t\t}\n\t\t\tint p = sc.nextInt();\n\t\t\tList<R> l = new ArrayList<R>();\n\t\t\tboolean f = true;\n\t\t\twhile(p--!=0){\n\t\t\t\tR fav = r[ref.get(sc.next())];\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R v:l){\n\t\t\t\t\tif(v.lap(fav)){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tfav.u = true;\n\t\t\t\t\tl.add(fav);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tSystem.out.println(-1);continue;\n\t\t\t}\n\t\t\tArrays.sort(r);\n\t\t\tfor(R v:r){\n\t\t\t\tif(v.u)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R z:l){\n\t\t\t\t\tif(z.lap(v)){\n\t\t\t\t\t\tok = false;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tl.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l.size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\\import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue queue = new PriorityQueue(1, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new Main().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList list = new ArrayList();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList favList = new ArrayList();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue queue2 = new PriorityQueue(1, new Main().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new Main().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\n//Watchin' TVA\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tString name;\n\t\tint s, t;\n\t\tboolean u;\n\t\tpublic R(String n, int s, int t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tname = n;\n\t\t}\n\t\tboolean lap(R r){\n\t\t\treturn s<=r.s&&r.s<s+30 || r.s<=s&&s<r.s+30;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] r = new R[n];\n\t\t\tMap<String, Integer> ref = new TreeMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString name = sc.next();\n\t\t\t\tref.put(name, i);\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tif(k==6&&t>=2400){\n\t\t\t\t\tk = 0;\n\t\t\t\t\tt -= 2400;\n\t\t\t\t}\n\t\t\t\tint s = k*2400 + t/100*60 + t%100;\n\t\t\t\tr[i] = new R(name, s, s+30);\n\t\t\t}\n\t\t\tint p = sc.nextInt();\n\t\t\tList<R> l = new ArrayList<R>();\n\t\t\tboolean f = true;\n\t\t\twhile(p--!=0){\n\t\t\t\tR fav = r[ref.get(sc.next())];\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R v:l){\n\t\t\t\t\tif(v.lap(fav)){\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tfav.u = true;\n\t\t\t\t\tl.add(fav);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!f){\n\t\t\t\tSystem.out.println(-1);continue;\n\t\t\t}\n\t\t\tArrays.sort(r);\n\t\t\tfor(R v:r){\n\t\t\t\tif(v.u)continue;\n\t\t\t\tboolean ok = true;\n\t\t\t\tfor(R z:l){\n\t\t\t\t\tif(z.lap(v)){\n\t\t\t\t\t\tok = false;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tl.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(l.size());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue queue = new PriorityQueue(1, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new Main().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList list = new ArrayList();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList favList = new ArrayList();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue queue2 = new PriorityQueue(1, new Main().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new Main().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic HashMap<String, Integer> map;\n\tstatic ArrayList<String> favs;\n\tstatic final int WEEKTIME = 7 * 24 * 60;\n\n\tstatic int solve() {\n\t\tboolean[] used = new boolean[WEEKTIME];\n\t\tfor (String f : favs) {\n\t\t\tint t = map.get(f);\n\t\t\tfor (int i = 0; i < 30; ++i) {\n\t\t\t\tif (used[t]) return -1;\n\t\t\t\tused[t] = true;\n\t\t\t\t++t;\n\t\t\t\tif (t >= WEEKTIME) t -= WEEKTIME;\n\t\t\t}\n\t\t\tmap.remove(f);\n\t\t}\n\t\tArrayList<Integer> programs = new ArrayList<Integer>(map.values());\n\t\tCollections.sort(programs);\n\t\tint ret = favs.size();\n\t\tfor (int p : programs) {\n\t\t\tboolean ok = true;\n\t\t\tint t = p;\n\t\t\tfor (int i = 0; i < 30; ++i) {\n\t\t\t\tif (used[t]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++t;\n\t\t\t\tif (t >= WEEKTIME) t -= WEEKTIME;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\t++ret;\n\t\t\t\tt = p;\n\t\t\t\tfor (int i = 0; i < 30; ++i) {\n\t\t\t\t\tused[t] = true;\n\t\t\t\t\t++t;\n\t\t\t\t\tif (t >= WEEKTIME) t -= WEEKTIME;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tmap = new HashMap<String, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint weekday = sc.nextInt();\n\t\t\t\tint time = sc.nextInt();\n\t\t\t\tint weektime = weekday * 24 * 60 + (time / 100) * 60 + time % 100;\n\t\t\t\tweektime += WEEKTIME - 6 * 60;\n\t\t\t\tweektime %= WEEKTIME;\n\t\t\t\tmap.put(name, weektime);\n\t\t\t}\n\t\t\tint P = sc.nextInt();\n\t\t\tfavs = new ArrayList<String>(P);\n\t\t\tfor (int i = 0; i < P; ++i) {\n\t\t\t\tfavs.add(sc.next());\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    void run() {\n        // 1063\n        while (true) {\n            int N = readInt();\n            if (N == 0) break;\n            int[] program = new int[N];\n            HashMap<String, Integer> name2int = new HashMap<String, Integer>();\n            for (int i = 0; i < N; i++) {\n                String name = read();\n                int weekday = readInt();\n                int time = readInt();\n                name2int.put(name, i);\n                program[i] = hash(weekday, time);\n            }\n            int P = readInt();\n            boolean[] fav = new boolean[N];\n            for (int i = 0; i < P; i++) {\n                String s = read();\n                fav[name2int.get(s)] = true;\n            }\n\n            boolean conflict = false;\n            boolean[] used = new boolean[7 * 24 * 60];\n\n            for (int i = 0; i < P; i++) {\n                if (fav[i]) {\n                    for (int j = program[i]; j < program[i] + 30; ++j) {\n                        int k = j % (7 * 24 * 60);\n                        if (used[k]) conflict = true;\n                        used[k] = true;\n                    }\n                }\n            }\n            if (conflict) {\n                sysout.println(-1);\n                continue;\n            }\n\n            int ans = P;\n            for (int t = 0; t < N; t++) {\n                int minT = 7 * 24 * 60;\n                int minArg = -1;\n                for (int i = 0; i < N; i++) {\n                    boolean ok = true;\n                    for (int j = 0; j < 30; ++j) {\n                        int k = program[i] + j;\n                        if (used[k % (7 * 24 * 60)]) ok = false;\n                    }\n                    if (ok) {\n                        if (minT > program[i]) {\n                            minT = program[i];\n                            minArg = i;\n                        }\n                    }\n                }\n                if (minArg != -1) {\n                    ++ans;\n                    for (int i = 0; i < 30; i++) {\n                        int k = program[minArg] + i;\n                        used[k % (7 * 24 * 60)] = true;\n                    }\n                }\n            }\n            sysout.println(ans);\n        }\n    }\n\n    int hash(int weekday, int start) {\n        String s = String.valueOf(start);\n        if (s.length() == 3) s = \"0\" + s;\n        int h = Integer.parseInt(s.substring(0, 2));\n        int m = Integer.parseInt(s.substring(2));\n        int ret = 0;\n        ret += weekday * 24 * 60;\n        ret += h * 60;\n        ret += m;\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    // flush automatically iff you call `println` or `printf` or `format`.\n    PrintWriter sysout = new PrintWriter(System.out, true);\n\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer buffer = new StringTokenizer(\"\");\n\n    String read() {\n        if (!buffer.hasMoreTokens()) {\n            try {\n                buffer = new StringTokenizer(in.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return buffer.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(read());\n    }\n\n    long readLong() {\n        return Long.parseLong(read());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(read());\n    }\n\n    String readLine() {\n        buffer = new StringTokenizer(\"\");\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint channelCnt = sc.nextInt();\n\t\tQueue queue = new PriorityQueue(1, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<channelCnt ; i++) {\n\t\t\tBangumi bangumi = new Main().new Bangumi(sc.next(), sc.next(), sc.next());\n\t\t\tqueue.add(bangumi);\n\t\t}\n\t\tint favCnt = sc.nextInt();\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(int j=0 ; j<favCnt ; j++) {\n\t\t\tlist.add(sc.next());\n\t\t}\n\t\tList<Bangumi> favList = new ArrayList<Bangumi>();\n\t\tObject[] o = queue.toArray();\n\t\tArrays.sort(o, new Main().new MyComparator());\n\t\tfor(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tfor(int j=0 ; j<list.size() ; j++) {\n\t\t\t\tif(list.get(j).toString().equals(b.name)) {\n\t\t\t\t\tfavList.add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQueue queue2 = new PriorityQueue(1, new Main().new MyComparator());\n\t\toutside: for(int i=0 ; i<o.length ; i++) {\n\t\t\tBangumi b = (Bangumi)o[i];\n\t\t\tboolean flg = true;\n\t\t\tfor(int j=0 ; j<favList.size() ; j++) {\n\t\t\t\tBangumi bb = (Bangumi)favList.get(j);\n\t\t\t\tif((b.time+30) > bb.time && (b.time+30) < (bb.time+30)) {\n\t\t\t\t\tflg = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tqueue2.add(b);\n\t\t}\n\t\tObject[] o1 = queue2.toArray();\n\t\tArrays.sort(o1, new Main().new MyComparator());\n\t\tint beforeEnd = 0;\n\t\tint result = 0;\n\t\tfor(int l=0 ; l<o1.length ; l++) {\n\t\t\tif(((Bangumi)o1[l]).time > beforeEnd) {\n\t\t\t\tresult++;\n\t\t\t\tbeforeEnd = ((Bangumi)o1[l]).time + 30;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic class MyComparator implements Comparator<Object> {\n\t\tpublic int compare(Object o1, Object o2) {\n\t\t\tBangumi a = (Bangumi)o1;\n\t\t\tBangumi b = (Bangumi)o2;\n\n\t\t\tif(a.time > b.time)\n\t\t\t\treturn 1;\n\t\t\telse if(a.time < b.time) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\tpublic class Bangumi {\n\t\tString name;\n\t\tint time;\n\t\tpublic Bangumi(String name, String youbi, String time){\n\t\t\tthis.name = name;\n\t\t\tthis.time = new Integer((youbi + time)).intValue();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;;\n\t\t\tnew Sol(n).Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tPg.Sort((x,y)=>x.Date>y.Date?1:x.Date<y.Date?-1:0);\n\t\tList<Prog> FavL=new List<Prog>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(Pg[j].Name==Fav[i]){\n\t\t\t\t\tFavL.Add(Pg[j].Clone());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFavL.Sort((x,y)=>x.Date>y.Date?1:x.Date<y.Date?-1:0);\n\t\tfor(int i=0;i<P-1;i++){\n\t\t\tif(FavL[i].Date+30>FavL[i+1].Date){\n\t\t\t\tConsole.WriteLine(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tint fcnt=0;\n\t\tint time=0;\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(Pg[i].Date<time)continue;\n\t\t\tif(fcnt<P){\n\t\t\t\tif(Pg[i].Date+30<=FavL[fcnt].Date){\n\t\t\t\t\tcnt++;\n\t\t\t\t\ttime=Pg[i].Date+30;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(Pg[i].Date+30>FavL[fcnt].Date){\n\t\t\t\t\tif(Pg[i].Date!=FavL[fcnt].Date){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(Pg[i].Name!=FavL[fcnt].Name){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(Pg[i].Name==FavL[fcnt].Name){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tfcnt++;\n\t\t\t\t\t\ttime=Pg[i].Date+30;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcnt++;\n\t\t\t\ttime=Pg[i].Date+30;\n\t\t\t}\n\t\t}\n\t\t\n\t\tConsole.WriteLine(cnt);\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tint N;\n\tList<Prog> Pg;\n\tint P;\n\tList<String> Fav;\n\tpublic Sol(int n_){\n\t\tN=n_;\n\t\tPg=new List<Prog>();\n\t\tfor(int i=0;i<N;i++)Pg.Add(new Prog(rsa()));\n\t\tP=ri();\n\t\tFav=new List<String>();\n\t\tfor(int i=0;i<P;i++)Fav.Add(rs());\n\t}\n\n\tclass Prog{\n\t\tpublic String Name;\n\t\tpublic int Date;\n\t\tpublic Prog(String[] s_){\n\t\t\tName=s_[0];\n\t\t\tint d=int.Parse(s_[1]);\n\t\t\tint hm=int.Parse(s_[2]);\n\t\t\tDate=d*24*60+(hm/100)*60+hm%100;\n\t\t}\n\t\tpublic Prog(){\n\t\t}\n\t\tpublic Prog Clone(){\n\t\t\tProg P=new Prog();\n\t\t\tP.Name=this.Name;\n\t\t\tP.Date=this.Date;\n\t\t\treturn P;\n\t\t}\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var d = new Dictionary<string, int>();\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                d[line[0]] = getTime(int.Parse(line[1]), line[2]);\n            }\n            var p = int.Parse(Console.ReadLine().Trim());\n            var df = new Dictionary<string, int>();\n            var ff = new int[p];\n            for (int i = 0; i < p; i++)\n            {\n                var w = Console.ReadLine().Trim();\n                df[w] = d[w];\n                ff[i] = d[w];\n            }\n            if (!checkF(ff, p)) { Console.WriteLine(-1); goto exit; }\n            var a = new List<int>();\n            foreach (var x in d)\n            {\n                if (df.ContainsKey(x.Key)) continue;\n                var ok = true;\n                foreach (var y in df)\n                    if (!checkW(y.Value, x.Value)) { ok = false; break; }\n                if (ok) a.Add(x.Value);\n            }\n            var ans = getAns(a);\n            Console.WriteLine(ans + df.Count());\n            exit:;\n        }\n    }\n    static int getAns(List<int> a)\n    {\n        a.Sort();\n        var count = 0;\n        var t = 0;\n        foreach (var x in a)\n        {\n            if (x >= t) { count++; t = x + 30; }\n        }\n        return count;\n    }\n    static bool checkW(int f, int t) => (t <= f - 30) | (t >= f + 30);\n    static bool checkF(int[] ff, int p)\n    {\n        Array.Sort(ff);\n        var t = 0;\n        foreach (var x in ff)\n        {\n            if (x < t) return false;\n            t = x + 30;\n        }\n        return true;\n    }\n    static int getTime(int week, string s)\n    {\n        if (s.Length == 3) return 1440 * week + 60 * int.Parse(s.Substring(0, 1)) + int.Parse(s.Substring(1));\n        else return 1440 * week + 60 * int.Parse(s.Substring(0, 2)) + int.Parse(s.Substring(2));\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var N=arr.shift()-0;\n   if(N==0)break;\n   var obj={};\n   var ary=[];\n   for(var i=0;i<N;i++){\n      var nws=(arr.shift()).split(\" \");\n      var name=nws[0];\n      var w=nws[1]-0;\n      var s=nws[2].split(\"\").map(Number);\n      s=(s.length==3)?s[0]*60+s[1]*10+s[2]:s[0]*600+s[1]*60+10*s[2]+s[3];\n      obj[name]=(w*1440)+s;\n      ary.push((w*1440)+s);\n   }\n   var P=arr.shift()-0;\n   var bad=[];\n   for(var i=0;i<P;i++){\n      var f=arr.shift();\n      ary.push(obj[f]-29.5);\n      bad.push(obj[f]);\n   }\n   ary.sort(function(a,b){return a-b;});\n   bad.sort(function(a,b){return a-b;});\n   var cnt=0;\n   var i=0;\n   ary.forEach(function(v){\n      if(v%1==0.5){cnt++;i=v+29.5+30;}\n      else if(i<=v){cnt++;i=v+30;}\n   });\n   var i=0;\n   bad.forEach(function(v){\n      if(i<=v){i=v+30;}\n      else cnt=-1;\n   });   \n   console.log(cnt);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var N=arr.shift()-0;\n   if(N==0)break;\n   var obj={};\n   var ary=[];\n   for(var i=0;i<N;i++){\n      var nws=(arr.shift()).split(\" \");\n      var name=nws[0];\n      var w=nws[1]-0;\n      var s=nws[2].split(\"\").map(Number);\n      s=(s.length==3)?s[0]*60+s[1]*10+s[2]:s[0]*600+s[1]*60+10*s[2]+s[3];\n      obj[name]=(w*1440)+s;\n      ary.push((w*1440)+s);\n   }\n   var P=arr.shift()-0;\n   for(var i=0;i<P;i++){\n      var f=arr.shift();\n      ary.push(obj[f]-29.5);\n   }\n   ary.sort(function(a,b){return a-b;});\n   var cnt=0;\n   var i=0;\n   var p=0;\n   ary.forEach(function(v){\n      if(v%1==0.5){cnt++;p++;i=v+29.5+30;}\n      else if(i<=v){cnt++;i=v+30;}\n   });\n   if(p!=P)cnt=-1;\n   console.log(cnt);\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef bsearch(ranges, tm)\n  i = 0\n  j = ranges.length - 1\n\n  while i <= j\n    k = (i + j) / 2\n    r0, r1 = ranges[k]\n    if tm + 30 > r0 && tm < r1\n      return k\n    end\n\n    if tm >= r1\n      i = k + 1\n    else\n      j = k - 1\n    end\n  end\n\n  nil\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  prgs = 7.times.map{[]}\n  prghash = {}\n\n  n.times do\n    name, wd, st = gets.strip.split\n    wdi = wd.to_i\n    sti = st.to_i\n    tm = (sti / 100 - 6) * 60 + (sti % 100)\n\n    prghash[name] = [wdi, tm]\n    prgs[wdi] << tm\n  end\n  #p prgs\n  #p prghash\n\n  for prg in prgs\n    prg.sort!.uniq!\n  end\n  #p prgs\n\n  pn = gets.to_i\n  anchors = 7.times.map{[]}\n\n  pn.times do\n    wdi, sti = prghash[gets.strip]\n    anchors[wdi] << sti\n  end\n  #p anchors\n\n  count = 0\n\n  for anc in anchors\n    anc.sort!\n\n    for i in (0...(anc.length - 1))\n      if anc[i + 1] - anc[i] < 30\n        count = -1\n        break\n      end\n    end\n    break if count == -1\n  end\n\n  if count == -1\n    puts -1\n    next\n  end\n\n  for i in (0..6)\n    prg = prgs[i]\n    anc = anchors[i]\n    #p [prg, anc]\n\n    ranges = [[0, 24 * 60]]\n    for an in anc\n      k = bsearch(ranges, an)\n      if ! k.nil?\n        r0, r1 = ranges[k]\n        rs = []\n        if r0 < an && an - r0 >= 30\n          rs << [r0, an]\n        end\n        if an + 30 < r1 && r1 - an >= 60\n          rs << [an + 30, r1]\n        end\n        ranges[k, 1] = rs\n      end\n    end\n    count += anc.length\n\n    for range in ranges\n      r0, r1 = range\n\n      for tm in prg\n        break if tm + 30 > r1\n        if tm >= r0\n          #p [r0, r1, tm]\n          count += 1\n          r0 = tm + 30\n        end\n      end\n    end\n    #p ranges\n  end\n\n  puts count\nend"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nwhile(1):\n    N=int(raw_input())\n    if N==0: break\n    D={}\n    for i in range(N):\n        inp=raw_input().split()\n        inp[1:]=map(int, inp[1:])\n        stt=inp[1]*24*60+inp[2]/100*60+inp[2]%100\n        D[inp[0]]=stt\n    P=int(raw_input())\n    Tlist=[-99999999,999999999]\n    for i in range(P):\n        f=raw_input()\n        Tlist.append(D.pop(f))\n    Tlist.sort()\n    for i in range(P+1):\n        if Tlist[i+1]<Tlist[i]+30:\n            print -1\n            break\n    else:\n        ans=P\n        E=sorted(D.values())\n        for st in E:\n            if (st - Tlist[ bisect.bisect(Tlist, st)-1])>= 30 and (Tlist[ bisect.bisect(Tlist, st)] - st ) >= 30:\n                ans+=1\n                bisect.insort(Tlist, st)\n        print ans"
  },
  {
    "language": "Python",
    "code": "# AOJ 1063: Watchin' TVA\n# Python3 2018.7.8 bal4u\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\tdic, tbl = {}, []\n\tfor i in range(n):\n\t\tnm, w, s = input().split()\n\t\tw, s = int(w), int(s)\n\t\th, m = s//100, s%100\n\t\ts = (1440*w + h*60 + m) % 10080\n\t\te = s + 30;\n\t\ttbl.append([s, e, 0, nm])\n\t\tdic[nm] = i\n\tfor i in range(int(input())): tbl[dic[input()]][2] = 1\n\tif n == 1:\n\t\tprint(1)\n\t\tcontinue\n\ttbl.sort(key=lambda x:(x[0],x[2]))\n\tfor i in range(len(tbl)):\n\t\tif tbl[i][2]:\n\t\t\tk = i\n\t\t\tbreak\n\tans, i, j = 1, k, k\n\twhile True:\n\t\tj += 1\n\t\tif i >= n: i = 0\n\t\tif j >= n: j = 0\n\t\tif j == k: break\n\t\te = tbl[i][1] - 10080 if tbl[i][1] >= 10080 else 0\n\t\tif (tbl[i][0] <= tbl[j][0] and tbl[j][0] < tbl[i][1]) \\\n\t\t    or tbl[j][0] < e:\n\t\t\tif tbl[j][2] and tbl[i][2]:\n\t\t\t\tans = -1\n\t\t\t\tbreak\n\t\t\telif tbl[j][2]: i = j\n\t\telif tbl[j][0] <= tbl[k][0] and tbl[k][0] < tbl[j][1]: pass\n\t\telse:\n\t\t\tans += 1\n\t\t\ti = j\n\tprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\n\nwhile(1):\n    N=int(raw_input())\n    if N==0: break\n    D={}\n    for i in range(N):\n        inp=raw_input().split()\n        inp[1:]=map(int, inp[1:])\n        stt=inp[1]*24*60+inp[2]/100*60+inp[2]%60\n        D[inp[0]]=stt\n    P=int(raw_input())\n    Tlist=[-99999999,999999999]\n    for i in range(P):\n        f=raw_input()\n        Tlist.append(D.pop(f))\n    Tlist.sort()\n    for i in range(P+1):\n        if Tlist[i+1]<Tlist[i]+30:\n            print -1\n            break\n    else:\n        ans=P\n        E=sorted(D.values())\n        for st in E:\n            if (st - Tlist[ bisect.bisect(Tlist, st)-1])>= 30 and (Tlist[ bisect.bisect(Tlist, st)] - st ) >= 30:\n                ans+=1\n                bisect.insort(Tlist, st)\n        print ans"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::str::FromStr;\nuse std::cmp::Ordering;\nuse std::collections::HashSet;\n\nstruct Istream {\n    line: Vec<String>,\n    position: usize\n}\ntype Parse<T: FromStr> = Result<T, T::Err>;\nimpl Istream {\n    fn new() -> Istream {\n        Istream {line:vec![], position: 0}\n    }\n    fn read_word(&mut self) -> &String {\n        if self.position == self.line.len() {\n            let mut line= String::new();\n            std::io::stdin().read_line(&mut line).ok();\n            self.line = line.split_whitespace().map(|x|x.to_string()).collect();\n            self.position = 0\n        }\n        let result = &self.line[self.position];\n        self.position += 1;\n        result\n    }\n    fn read(&mut self) -> String {\n        self.read_word().to_string()\n    }\n    fn get<T: FromStr>(&mut self) -> T {self.read_word().parse().ok().unwrap()}\n    fn read_usize(&mut self) -> usize {self.get()}\n    fn read_int(&mut self) -> i32 {self.get()}\n    fn read_long(&mut self) -> i64 {self.get()}\n    fn read_double(&mut self) -> f64 {self.get()}\n}\nfn tabulate<T, F>(count: usize, elements: &mut F) -> Vec<T> where F: FnMut(usize) -> T {\n    let mut result:Vec<T> = Vec::with_capacity(count);\n    for i in 0 .. count {\n        result.push(elements(i))\n    }\n    result\n}\nfn fill<T, F>(count: usize, generator: F) -> Vec<T> where F: Fn() -> T {\n    let mut result: Vec<T> = Vec::with_capacity(count);\n    for _i in 0 .. count {\n        result.push(generator())\n    }\n    result\n}\n#[derive(Debug)]\nstruct Program {\n    title: String,\n    date: Date,\n}\n#[derive(Debug, Copy, Clone)]\nstruct Date {\n    day: i32,\n    hour: i32,\n    minute: i32,\n}\nimpl Date {\n    fn from_int(day: &i32, time: &i32) -> Date {\n        if time / 100 >= 24 {\n            Date{day: (day + 1) % 7, hour: (time / 100) % 24, minute: (time % 100)}\n        }else {\n            Date{day: day + 0, hour: (time / 100), minute: (time % 100)}\n        }\n    }\n    fn from_minute(minute: i32) -> Date {\n        Date{day: (minute / 1440) % 7, hour: (minute / 60) % 24, minute: minute % 60}\n    }\n    fn to_minute(&self) -> i32 {\n        self.day * 1440 + self.hour * 60 + self.minute\n    }\n    fn add_minute(&self, minute: i32) -> Date {\n        Date::from_minute(self.to_minute() + minute)\n    }\n}\nimpl Ord for Date {\n    fn cmp(&self, other: &Self) -> Ordering {\n        if self.day == other.day {\n            if self.hour == other.hour {\n                self.minute.cmp(&other.minute)\n            }else {\n                self.hour.cmp(&other.hour)\n            }\n        }else {\n            self.day.cmp(&other.day)\n        }\n    }\n}\nimpl PartialOrd for Date {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n\n    fn lt(&self, other: &Self) -> bool {\n        self.cmp(other) == Ordering::Less\n    }\n\n    fn le(&self, other: &Self) -> bool {\n        self.cmp(other) != Ordering::Greater\n    }\n\n    fn gt(&self, other: &Self) -> bool {\n        self.cmp(other) == Ordering::Greater\n    }\n\n    fn ge(&self, other: &Self) -> bool {\n        self.cmp(other) != Ordering::Less\n    }\n}\nimpl PartialEq for Date {\n    fn eq(&self, other: &Self) -> bool {\n        self.day == other.day && self.hour == other.hour && self.minute == other.minute\n    }\n\n    fn ne(&self, other: &Self) -> bool {\n        !self.eq(other)\n    }\n}\nimpl Eq for Date {}\nimpl Program {\n    fn new(title: String, day: i32, start: i32) -> Program {\n        let date = Date::from_int(&day, &start);\n        Program{title: title, date: date}\n    }\n    fn overlapped(&self, other: &Program) -> bool {\n        let s = self.date.to_minute();\n        let o = other.date.to_minute();\n        (s - o + 24 * 60 * 7) % (24 * 60 * 7) < 30 || (o - s + 24 * 60 * 7) % (24 * 60 * 7) < 30\n    }\n}\nfn main() {\n    let mut stdin = Istream::new();\n    let input = &mut stdin;\n    loop {\n        let n = input.read_usize();\n        if n == 0 {\n            break;\n        }\n        let mut programs = tabulate(n, &mut |_i| {\n            let title = input.read();\n            let day = input.read_int();\n            let start = input.read_int();\n            Program::new(title, day, start)\n        });\n        programs.sort_by_key(|p|p.date);\n        let mut favorite: HashSet<String> = HashSet::new();\n        let p = input.read_usize();\n        for _ in 0 .. p {\n            favorite.insert(input.read());\n        }\n        let mut time = vec![false; 7 * 24 * 60];\n        let len: usize = 7 * 24 * 60;\n        let mut count = 0;\n        let mut favorite_i = 0;\n        'outer: for (i, p) in programs.iter().enumerate() {\n            if count >= 0 && favorite.contains(&p.title) {\n                favorite_i = i;\n                count += 1;\n                let minute = p.date.to_minute() as usize;\n                for i in 0 .. 30 {\n                    if time[(minute + i) % len] {\n                        count = -1;\n                        break 'outer;\n                    }else {\n                        time[(minute + i) % len] = true;\n                    }\n                }\n            }\n        }\n        if count >= 0 {\n            'outer: for p in 0..n {\n                let minute = programs[(p + favorite_i) % n].date.to_minute() as usize;\n                let mut is_overlapped = false;\n                for i in 0..30 {\n                    is_overlapped |= time[(minute + i) % len];\n                }\n                if !is_overlapped {\n                    count += 1;\n                    for i in 0 .. 30 {\n                        time[(minute + i) % len] = true;\n                    }\n                }\n            }\n        }\n        println!(\"{}\", count)\n    }\n}\n"
  }
]