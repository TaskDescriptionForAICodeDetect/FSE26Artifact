[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start;\n    int end;\n    int is_favorite;\n} Program;\n\nint compare(const void *a, const void *b) {\n    Program *progA = (Program *)a;\n    Program *progB = (Program *)b;\n    if (progA->end != progB->end) {\n        return progA->end - progB->end;\n    }\n    return progA->start - progB->start;\n}\n\nint main() {\n    int G, N;\n    while (scanf(\"%d %d\", &G, &N) == 2) {\n        if (G == 0 && N == 0) break;\n        \n        Program *programs = malloc(N * sizeof(Program));\n        for (int i = 0; i < N; i++) {\n            int sh, sm, eh, em, f;\n            scanf(\"%d:%d %d:%d %d\", &sh, &sm, &eh, &em, &f);\n            programs[i].start = sh * 60 + sm;\n            programs[i].end = eh * 60 + em;\n            programs[i].is_favorite = f;\n        }\n        \n        // Check if any favorite programs overlap\n        int possible = 1;\n        for (int i = 0; i < N && possible; i++) {\n            if (!programs[i].is_favorite) continue;\n            for (int j = i + 1; j < N && possible; j++) {\n                if (!programs[j].is_favorite) continue;\n                if (programs[i].start < programs[j].end && programs[j].start < programs[i].end) {\n                    possible = 0;\n                }\n            }\n        }\n        \n        if (!possible) {\n            printf(\"-1\\n\");\n            free(programs);\n            continue;\n        }\n        \n        // Sort all programs by end time\n        qsort(programs, N, sizeof(Program), compare);\n        \n        int count = 0;\n        int last_end = -1;\n        \n        // First, schedule all favorite programs\n        for (int i = 0; i < N; i++) {\n            if (programs[i].is_favorite) {\n                if (programs[i].start >= last_end) {\n                    count++;\n                    last_end = programs[i].end;\n                } else {\n                    possible = 0;\n                    break;\n                }\n            }\n        }\n        \n        if (!possible) {\n            printf(\"-1\\n\");\n            free(programs);\n            continue;\n        }\n        \n        // Then, schedule non-favorite programs\n        last_end = -1;\n        for (int i = 0; i < N; i++) {\n            if (!programs[i].is_favorite) {\n                if (programs[i].start >= last_end) {\n                    count++;\n                    last_end = programs[i].end;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n        free(programs);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AnimeScheduler {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt(); // Number of programs\n            if (n == 0) break;\n            \n            int[] start = new int[n];\n            int[] end = new int[n];\n            boolean[] favorite = new boolean[n];\n            \n            for (int i = 0; i < n; i++) {\n                start[i] = scanner.nextInt();\n                end[i] = start[i] + 1; // Each program is 30 minutes\n                favorite[i] = scanner.nextInt() == 1;\n            }\n            \n            int result = solve(n, start, end, favorite);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n    \n    static int solve(int n, int[] start, int[] end, boolean[] favorite) {\n        List<Integer> favoritePrograms = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (favorite[i]) {\n                favoritePrograms.add(i);\n            }\n        }\n        \n        // Check if any favorite programs overlap\n        for (int i = 0; i < favoritePrograms.size(); i++) {\n            for (int j = i + 1; j < favoritePrograms.size(); j++) {\n                int prog1 = favoritePrograms.get(i);\n                int prog2 = favoritePrograms.get(j);\n                \n                if (!(end[prog1] <= start[prog2] || end[prog2] <= start[prog1])) {\n                    return -1;\n                }\n            }\n        }\n        \n        // Greedy approach to maximize programs\n        List<Integer> selectedPrograms = new ArrayList<>(favoritePrograms);\n        boolean[] used = new boolean[n];\n        \n        for (int fav : favoritePrograms) {\n            used[fav] = true;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (!used[i]) {\n                boolean canAdd = true;\n                for (int prog : selectedPrograms) {\n                    if (!(end[prog] <= start[i] || end[i] <= start[prog])) {\n                        canAdd = false;\n                        break;\n                    }\n                }\n                \n                if (canAdd) {\n                    selectedPrograms.add(i);\n                    used[i] = true;\n                }\n            }\n        }\n        \n        return selectedPrograms.size();\n    }\n}",
    "timestamp": "2025-08-05 19:01:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Program {\n    int start;\n    bool isFavorite;\n    int end() const { return start + 30; }\n};\n\nbool isOverlap(const Program &a, const Program &b) {\n    return !(a.end() <= b.start || b.end() <= a.start);\n}\n\nint solve() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        vector<Program> programs(N);\n        for (int i = 0; i < N; ++i) {\n            int s, f;\n            cin >> s >> f;\n            programs[i].start = s * 60 + f;\n            programs[i].isFavorite = false;\n        }\n        for (int i = 0; i < M; ++i) {\n            int s, f;\n            cin >> s >> f;\n            int time = s * 60 + f;\n            bool found = false;\n            for (auto &p : programs) {\n                if (p.start == time) {\n                    p.isFavorite = true;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                programs.push_back({time, true});\n            }\n        }\n\n        sort(programs.begin(), programs.end(), [](const Program &a, const Program &b) {\n            return a.start < b.start;\n        });\n\n        bool conflict = false;\n        for (int i = 0; i < programs.size(); ++i) {\n            if (!programs[i].isFavorite) continue;\n            for (int j = i + 1; j < programs.size(); ++j) {\n                if (!programs[j].isFavorite) continue;\n                if (isOverlap(programs[i], programs[j])) {\n                    conflict = true;\n                    break;\n                }\n            }\n            if (conflict) break;\n        }\n        if (conflict) {\n            cout << -1 << endl;\n            continue;\n        }\n\n        vector<Program> nonFavorites;\n        for (const auto &p : programs) {\n            if (!p.isFavorite) {\n                nonFavorites.push_back(p);\n            }\n        }\n\n        vector<Program> merged;\n        for (const auto &p : programs) {\n            if (p.isFavorite) {\n                merged.push_back(p);\n            }\n        }\n\n        sort(nonFavorites.begin(), nonFavorites.end(), [](const Program &a, const Program &b) {\n            return a.end() < b.end();\n        });\n\n        for (const auto &p : nonFavorites) {\n            bool canAdd = true;\n            for (const auto &fav : merged) {\n                if (isOverlap(p, fav)) {\n                    canAdd = false;\n                    break;\n                }\n            }\n            if (canAdd) {\n                merged.push_back(p);\n            }\n        }\n\n        sort(merged.begin(), merged.end(), [](const Program &a, const Program &b) {\n            return a.end() < b.end();\n        });\n\n        int count = 0;\n        int lastEnd = -1;\n        for (const auto &p : merged) {\n            if (p.start >= lastEnd) {\n                count++;\n                lastEnd = p.end();\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PROGRAMS 100\n#define MAX_FAVORITES 10\n\ntypedef struct {\n    int start;\n    int end;\n    int is_favorite;\n} Program;\n\nint solve(Program programs[], int n, int favorites[], int m) {\n    int schedule[MAX_PROGRAMS] = {0};\n    int total_watched = 0;\n\n    // Mark favorite programs\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (programs[i].start == favorites[j]) {\n                programs[i].is_favorite = 1;\n            }\n        }\n    }\n\n    // Check for conflicting favorite programs\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (programs[i].is_favorite && programs[j].is_favorite &&\n                !(programs[i].end <= programs[j].start || \n                  programs[j].end <= programs[i].start)) {\n                return -1;\n            }\n        }\n    }\n\n    // Greedy selection of programs\n    for (int i = 0; i < n; i++) {\n        int can_watch = 1;\n        for (int j = 0; j < n; j++) {\n            if (schedule[j] && \n                !(programs[i].end <= programs[j].start || \n                  programs[j].end <= programs[i].start)) {\n                can_watch = 0;\n                break;\n            }\n        }\n\n        if (can_watch) {\n            schedule[i] = 1;\n            total_watched++;\n        }\n    }\n\n    return total_watched;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n\n        Program programs[MAX_PROGRAMS];\n        int favorites[MAX_FAVORITES];\n\n        // Read programs\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &programs[i].start);\n            programs[i].end = programs[i].start + 1;\n            programs[i].is_favorite = 0;\n        }\n\n        // Read favorite programs\n        for (int i = 0; i < m; i++) {\n            scanf(\"%d\", &favorites[i]);\n        }\n\n        int result = solve(programs, n, favorites, m);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n != 0 && m != 0) {\n        vector<pair<int, int>> programs(n);\n        set<int> favorites;\n\n        for (int i = 0; i < n; i++) {\n            cin >> programs[i].first >> programs[i].second;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int fav;\n            cin >> fav;\n            favorites.insert(fav - 1);\n        }\n\n        vector<bool> watched(n, false);\n        \n        for (int fav : favorites) {\n            watched[fav] = true;\n        }\n\n        sort(programs.begin(), programs.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n            return a.second < b.second;\n        });\n\n        int count = m;\n        for (int i = 0; i < n; i++) {\n            if (watched[i]) continue;\n\n            bool can_watch = true;\n            for (int j = 0; j < n; j++) {\n                if (watched[j] && \n                    !(programs[j].second <= programs[i].first || \n                      programs[i].second <= programs[j].first)) {\n                    can_watch = false;\n                    break;\n                }\n            }\n\n            if (can_watch) {\n                watched[i] = true;\n                count++;\n            }\n        }\n\n        bool conflict = false;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (watched[i] && watched[j] && \n                    !(programs[i].second <= programs[j].first || \n                      programs[j].second <= programs[i].first)) {\n                    conflict = true;\n                    break;\n                }\n            }\n            if (conflict) break;\n        }\n\n        cout << (conflict ? -1 : count) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Program {\n    int start;\n    int end;\n    boolean isFavorite;\n\n    Program(int start, boolean isFavorite) {\n        this.start = start;\n        this.end = start + 30;\n        this.isFavorite = isFavorite;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            List<Program> programs = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                int h = scanner.nextInt();\n                int m = scanner.nextInt();\n                int start = h * 60 + m;\n                boolean isFavorite = scanner.nextInt() == 1;\n                programs.add(new Program(start, isFavorite));\n            }\n            Collections.sort(programs, (a, b) -> a.end - b.end);\n            boolean conflict = false;\n            int count = 0;\n            int lastEnd = -1;\n            List<Program> favorites = new ArrayList<>();\n            for (Program p : programs) {\n                if (p.isFavorite) {\n                    favorites.add(p);\n                }\n            }\n            for (int i = 0; i < favorites.size(); i++) {\n                for (int j = i + 1; j < favorites.size(); j++) {\n                    Program p1 = favorites.get(i);\n                    Program p2 = favorites.get(j);\n                    if (p1.start < p2.end && p2.start < p1.end) {\n                        conflict = true;\n                        break;\n                    }\n                }\n                if (conflict) break;\n            }\n            if (conflict) {\n                System.out.println(-1);\n                continue;\n            }\n            lastEnd = -1;\n            for (Program p : programs) {\n                if (p.start >= lastEnd) {\n                    count++;\n                    lastEnd = p.end;\n                }\n            }\n            System.out.println(count);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:02:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_programs(n, k, programs, favorites):\n    time_slots = [0] * 48  # Each day has 48 half-hour slots when considering 24 hours\n    favorite_slots = set()\n\n    for start_time in programs:\n        time_slots[start_time] += 1\n\n    for fav_time in favorites:\n        if time_slots[fav_time] > 1:\n            return -1\n        favorite_slots.add(fav_time)\n\n    max_programs_watched = 0\n    current_slots = 0\n\n    for i in range(48):\n        if current_slots + time_slots[i] > 1:\n            current_slots = 0\n        else:\n            current_slots += time_slots[i]\n            if i in favorite_slots:\n                max_programs_watched += 1\n\n    return sum(1 for i in range(48) if time_slots[i] > 0) - (48 - max_programs_watched)\n\nseasons = int(input().strip())\n\nfor _ in range(seasons):\n    n, k = map(int, input().strip().split())\n    programs = list(map(int, input().strip().split()))\n    favorites = list(map(int, input().strip().split()))\n    \n    result = max_programs(n, k, programs, favorites)\n    \n    print(result)",
    "timestamp": "2025-08-13 01:57:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class AnimeScheduler {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while(scanner.hasNext()) {\n            int n = scanner.nextInt(); // Total programs\n            int m = scanner.nextInt(); // Jack's favorite programs\n            if (n == 0 && m == 0) break; // End of input\n            \n            int[] programStartTimes = new int[n];\n            for (int i = 0; i < n; i++) {\n                programStartTimes[i] = scanner.nextInt();\n            }\n            \n            Set<Integer> favoriteStartTimes = new HashSet<>();\n            for (int i = 0; i < m; i++) {\n                favoriteStartTimes.add(scanner.nextInt());\n            }\n            \n            List<Integer>[] favoritePrograms = new ArrayList[48];\n            for (int i = 0; i < 48; i++) favoritePrograms[i] = new ArrayList<>();\n            \n            for (int favStartTime : favoriteStartTimes) {\n                int slot = favStartTime / 30;\n                favoritePrograms[slot].add(favStartTime);\n                if (favoritePrograms[slot].size() > 1) {\n                    System.out.println(\"-1\");\n                    continue;\n                }\n            }\n            \n            Arrays.sort(programStartTimes);\n            boolean[] occupied = new boolean[48];\n            \n            for (int favStartTime : favoriteStartTimes) {\n                int slot = favStartTime / 30;\n                occupied[slot] = true;\n            }\n            \n            int maxPrograms = 0;\n            for (int programStartTime : programStartTimes) {\n                int slot = programStartTime / 30;\n                if (!occupied[slot]) {\n                    occupied[slot] = true;\n                    maxPrograms++;\n                }\n            }\n            \n            System.out.println(maxPrograms + favoriteStartTimes.size());\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 01:57:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_PROGRAMS 1000\n#define TIME_SLOT_COUNT 48 // 24 hours divided into 30 min slots\n\ntypedef struct {\n    int startSlot;\n    int endSlot;\n    int isFavorite;\n} Program;\n\nint main() {\n    int seasons;\n    scanf(\"%d\", &seasons);\n\n    for (int s = 0; s < seasons; ++s) {\n        int n, favorites;\n        scanf(\"%d %d\", &n, &favorites);\n\n        Program programs[MAX_PROGRAMS];\n        int favoriteFlags[TIME_SLOT_COUNT] = {0};\n\n        int canWatchAllFavorites = 1;\n\n        for (int i = 0; i < n; ++i) {\n            int hour, minute, isFavorite;\n            scanf(\"%d:%d %d\", &hour, &minute, &isFavorite);\n\n            programs[i].startSlot = (hour * 60 + minute) / 30;\n            programs[i].endSlot = programs[i].startSlot + 1;\n            programs[i].isFavorite = isFavorite;\n\n            if (programs[i].isFavorite) {\n                for (int slot = programs[i].startSlot; slot < programs[i].endSlot; ++slot) {\n                    if (favoriteFlags[slot]) {\n                        canWatchAllFavorites = 0;\n                    }\n                    favoriteFlags[slot] = 1;\n                }\n            }\n        }\n\n        if (!canWatchAllFavorites) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        int dp[TIME_SLOT_COUNT] = {0};\n\n        for (int i = 0; i < n; ++i) {\n            for (int slot = TIME_SLOT_COUNT - 1; slot >= programs[i].endSlot; --slot) {\n                dp[slot] = dp[slot] > dp[programs[i].startSlot] + 1 ? dp[slot] : dp[programs[i].startSlot] + 1;\n            }\n        }\n\n        int maxPrograms = 0;\n        for (int i = 0; i < TIME_SLOT_COUNT; ++i) {\n            maxPrograms = maxPrograms > dp[i] ? maxPrograms : dp[i];\n        }\n\n        printf(\"%d\\n\", maxPrograms);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:57:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_anime_programs(programs, favorites):\n    n = len(programs)\n    compatible = [[] for _ in range(n)]\n    \n    # Build compatibility graph\n    for i in range(n):\n        for j in range(n):\n            if i != j and not (programs[i][0] < programs[j][1] and programs[j][0] < programs[i][1]):\n                compatible[i].append(j)\n    \n    # Check if all favorites can be watched\n    favorites_set = set(favorites)\n    for fav in favorites:\n        if fav >= n:\n            return -1\n    \n    # Conflict check for favorites\n    for fav in favorites:\n        for other_fav in favorites:\n            if fav != other_fav and not (programs[fav][0] < programs[other_fav][1] and programs[other_fav][0] < programs[fav][1]):\n                return -1\n    \n    # Dynamic programming to maximize programs\n    dp = [0] * (1 << n)\n    \n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                valid = True\n                \n                for j in range(n):\n                    if prev_mask & (1 << j) and i not in compatible[j]:\n                        valid = False\n                        break\n                \n                if valid:\n                    dp[mask] = max(dp[mask], dp[prev_mask] + 1)\n    \n    # Ensure all favorites are included\n    max_programs = 0\n    for mask in range(1, 1 << n):\n        is_valid = all(mask & (1 << fav) for fav in favorites)\n        if is_valid:\n            max_programs = max(max_programs, dp[mask])\n    \n    return max_programs\n\ndef solve():\n    while True:\n        n, f = map(int, input().split())\n        if n == 0 and f == 0:\n            break\n        \n        programs = []\n        for _ in range(n):\n            start, end = map(int, input().split())\n            programs.append((start, end))\n        \n        favorites = list(map(lambda x: int(x) - 1, input().split()))\n        \n        result = max_anime_programs(programs, favorites)\n        print(result)\n\nsolve()",
    "timestamp": "2025-08-13 01:58:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    while True:\n        line = sys.stdin.readline().strip()\n        if line == '0':\n            break\n        N, M = map(int, line.split())\n        programs = []\n        favorites = []\n        for _ in range(N):\n            parts = sys.stdin.readline().strip().split()\n            s = int(parts[0])\n            k = int(parts[1])\n            times = list(map(int, parts[2:2 + k]))\n            is_favorite = (s in range(1, M + 1))\n            for t in times:\n                programs.append((t, t + 30, is_favorite))\n            if is_favorite:\n                favorites.append((s, times))\n        \n        # Check if any favorite programs overlap\n        favorites_times = []\n        for s, times in favorites:\n            for t in times:\n                favorites_times.append((t, t + 30))\n        \n        overlap = False\n        favorites_times.sort()\n        for i in range(1, len(favorites_times)):\n            prev_start, prev_end = favorites_times[i-1]\n            curr_start, curr_end = favorites_times[i]\n            if curr_start < prev_end:\n                overlap = True\n                break\n        if overlap:\n            print(-1)\n            continue\n        \n        # Now find maximum non-overlapping programs including all favorites\n        programs.sort(key=lambda x: x[1])  # sort by end time\n        selected = []\n        last_end = -1\n        # First select all favorites\n        fav_set = set()\n        for s, times in favorites:\n            for t in times:\n                fav_set.add((t, t + 30))\n        \n        # Now select all favorites first\n        selected_fav = []\n        for prog in programs:\n            start, end, is_fav = prog\n            if (start, end) in fav_set:\n                selected_fav.append((start, end))\n        selected_fav.sort(key=lambda x: x[1])\n        \n        # Check if favorites themselves overlap (shouldn't happen as checked earlier)\n        temp_last = -1\n        valid = True\n        for start, end in selected_fav:\n            if start < temp_last:\n                valid = False\n                break\n            temp_last = end\n        if not valid:\n            print(-1)\n            continue\n        \n        # Now select non-favorites that don't overlap with selected favorites\n        # Collect all selected intervals (favorites)\n        selected_intervals = selected_fav.copy()\n        selected_intervals.sort()\n        # Now process all programs, skip favorites, and select non-overlapping\n        other_programs = []\n        for prog in programs:\n            start, end, is_fav = prog\n            if not is_fav:\n                other_programs.append((start, end))\n        other_programs.sort(key=lambda x: x[1])\n        \n        # Merge selected intervals (favorites) and other selected\n        max_programs = len(selected_intervals)\n        last_end = -1\n        if selected_intervals:\n            last_end = selected_intervals[-1][1]\n        # Now select other programs that start >= last_end\n        for start, end in other_programs:\n            if start >= last_end:\n                max_programs += 1\n                last_end = end\n        print(max_programs)\n\nsolve()",
    "timestamp": "2025-08-13 01:59:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint main() {\n    int numSeasons;\n    cin >> numSeasons;\n    \n    while(numSeasons--) {\n        int numPrograms;\n        cin >> numPrograms;\n        \n        vector<pair<int, int>> programs;\n        set<int> favorites;\n        \n        for (int i = 0; i < numPrograms; ++i) {\n            int startTime, endTime;\n            cin >> startTime >> endTime;\n            programs.push_back({startTime, endTime});\n        }\n        \n        int numFavorites;\n        cin >> numFavorites;\n        \n        for (int i = 0; i < numFavorites; ++i) {\n            int favId;\n            cin >> favId;\n            favorites.insert(favId);\n        }\n        \n        map<int, int> timeSlots;  // Maps endTime to startTime\n        \n        for (int i = 0; i < numPrograms; ++i) {\n            timeSlots[programs[i].second] = programs[i].first;\n        }\n        \n        int lastEndTime = -1;\n        int count = 0;\n        set<int> watchedFavorites;\n        \n        for (auto& slot : timeSlots) {\n            if (slot.second >= lastEndTime) {\n                count++;\n                lastEndTime = slot.first;\n                for (int i = 0; i < numPrograms; ++i) {\n                    if (programs[i].second == slot.first && favorites.count(i+1)) {\n                        watchedFavorites.insert(i+1);\n                    }\n                }\n            }\n        }\n        \n        if (watchedFavorites.size() < favorites.size()) {\n            cout << -1 << endl;\n        } else {\n            cout << count << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:03:37"
  }
]